{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Spectral_Radius_Largest_Jordan_Block.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma sum_root_unity: fixes x :: \"'a :: {comm_ring,division_ring}\" \n  assumes \"x^n = 1\" \n  shows \"sum (\\<lambda> i. x^i) {..< n} = (if x = 1 then of_nat n else 0)\"", "lemma sum_root_unity_power_pos_implies_1:  \n  assumes sumpos: \"\\<And> k. Re (sum (\\<lambda> i. b i * x i ^ k) I) > 0\" \n  and root_unity: \"\\<And> i. i \\<in> I \\<Longrightarrow> \\<exists> d. d \\<noteq> 0 \\<and> x i ^ d = 1\" \nshows \"1 \\<in> x ` I\"", "lemma j_to_jb_index: assumes \"i < sum_list (map fst n_as)\" \n  and \"j < sum_list (map fst n_as)\" \n  and \"j_to_jb_index n_as i = (bi, li)\" \n  and \"j_to_jb_index n_as j = (bj, lj)\" \n  and \"n_as ! bj = (n, a)\" \nshows \"((jordan_matrix n_as) ^\\<^sub>m r) $$ (i,j) = (if bi = bj then ((jordan_block n a) ^\\<^sub>m r) $$ (li, lj) else 0)\n  \\<and> (bi = bj \\<longrightarrow> li < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n,a) \\<in> set n_as)\"", "lemma j_to_jb_index_rev: assumes j: \"j_to_jb_index n_as i = (bi, li)\" \n  and i: \"i < sum_list (map fst n_as)\" \n  and k: \"k \\<le> li\" \nshows \"li \\<le> i \\<and> j_to_jb_index n_as (i - k) = (bi, li - k) \\<and> (\n  j_to_jb_index n_as j = (bi,li - k) \\<longrightarrow> j < sum_list (map fst n_as) \\<longrightarrow> j = i - k)\"", "lemma n_as0: \"0 \\<notin> fst ` set n_as\"", "lemma m0: \"m \\<noteq> 0\"", "lemma sim_A_J: \"similar_mat cA J\"", "lemma c_gt_0: \"c > 0\"", "lemma c0: \"c \\<noteq> 0\"", "lemma c_int_def: \"c = (\\<Prod>ia = 0..<m-1. (of_nat m :: int) - 1 - of_nat ia)\"", "lemma c_int: \"c \\<in> \\<int>\"", "lemma c_ge_1: \"c \\<ge> 1\"", "lemma JNF: \"P \\<in> carrier_mat n n\" \"iP \\<in> carrier_mat n n\" \"J \\<in> carrier_mat n n\"\n  \"P * iP = 1\\<^sub>m n\" \"iP * P = 1\\<^sub>m n\" \"cA = P * J * iP\"", "lemma sumlist_nf: \"sum_list (map fst n_as) = n\"", "lemma I_nonempty: \"I \\<noteq> {}\"", "lemma I_n: \"I \\<subseteq> {..<n}\"", "lemma root_unity_cmod_1: assumes la: \"la \\<in> snd ` set n_as\" and 1: \"cmod la = 1\" \n  shows \"\\<exists> d. d \\<noteq> 0 \\<and> la ^ d = 1\"", "lemma d: assumes \"(k,la) \\<in> set n_as\" \"cmod la = 1\" \n  shows \"la ^ (d la) = 1 \\<and> d la \\<noteq> 0\"", "lemma D0: \"D \\<noteq> 0\"", "lemma mono_K: \"strict_mono (K off)\"", "lemma limit_jordan_block: assumes kla: \"(k, la) \\<in> set n_as\"\n  and ij: \"i < k\" \"j < k\" \nshows \"(\\<lambda>N. (jordan_block k la ^\\<^sub>m (K off N)) $$ (i, j) * C off N)\n  \\<longlonglongrightarrow> (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la^off else 0)\"", "lemma cmod_Lam: \"i \\<in> I \\<Longrightarrow> cmod (Lam i) = 1\"", "lemma I_Lam: assumes i: \"i \\<in> I\" \n  shows \"(m, Lam i) \\<in> set n_as\"", "lemma limit_jordan_matrix: assumes ij: \"i < n\" \"j < n\" \nshows \"(\\<lambda>N. (J ^\\<^sub>m (K off N)) $$ (i, j) * C off N)\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1) then (Lam j)^off else 0)\"", "lemma A_power_P: \"cA ^\\<^sub>m k * P = P * J ^\\<^sub>m k\"", "lemma C_nonneg: \"C off k \\<ge> 0\"", "lemma P_nonzero_entry: assumes j: \"j < n\"\n  shows \"\\<exists> i < n. P $$ (i,j) \\<noteq> 0\"", "lemma i: \"i \\<in> I\"", "lemma i_n: \"i < n\"", "lemma j: \"j < n\" \"P $$ (j, i - (m - 1)) \\<noteq> 0\"", "lemma B: \"0 < B\"", "lemma w: \"w \\<in> carrier_vec n\"", "lemma v: \"v \\<in> carrier_vec n\"", "lemma main_step: \"\\<exists> a. \\<forall> l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)\"", "lemma main_theorem: \"(m, 1) \\<in> set n_as\"", "lemma nonneg_sr_1_largest_jb:\n  assumes nonneg: \"nonneg_mat A\" \n  and jnf: \"jordan_nf (map_mat complex_of_real A) n_as\" \n  and mem: \"(m, lam) \\<in> set n_as\" \n  and lam1: \"cmod lam = 1\"\n  and sr1: \"\\<And>x. poly (char_poly A) x = 0 \\<Longrightarrow> x \\<le> 1\" \n  shows \"\\<exists> M. M \\<ge> m \\<and> (M,1) \\<in> set n_as\"", "lemma (in ring_hom) hom_smult_mat: \"mat\\<^sub>h (a \\<cdot>\\<^sub>m A) = hom a \\<cdot>\\<^sub>m mat\\<^sub>h A\"", "lemma root_char_poly_smult: fixes A :: \"complex mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and k: \"k \\<noteq> 0\" \nshows \"(poly (char_poly (k \\<cdot>\\<^sub>m A)) x = 0) = (poly (char_poly A) (x / k) = 0)\"", "theorem real_nonneg_mat_spectral_radius_largest_jordan_block: \n  assumes \"real_nonneg_mat A\" \n  and \"jordan_nf A n_as\"\n  and \"(m, lam) \\<in> set n_as\" \n  and \"cmod lam = spectral_radius A\" \nshows \"\\<exists> M \\<ge> m. (M, of_real (spectral_radius A)) \\<in> set n_as\""], "translations": [["", "lemma sum_root_unity: fixes x :: \"'a :: {comm_ring,division_ring}\" \n  assumes \"x^n = 1\" \n  shows \"sum (\\<lambda> i. x^i) {..< n} = (if x = 1 then of_nat n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "proof (cases \"x = 1 \\<or> n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = (1::'a) \\<or> n = 0 \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))\n 2. \\<not> (x = (1::'a) \\<or> n = 0) \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "case x: False"], ["proof (state)\nthis:\n  \\<not> (x = (1::'a) \\<or> n = 0)\n\ngoal (2 subgoals):\n 1. x = (1::'a) \\<or> n = 0 \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))\n 2. \\<not> (x = (1::'a) \\<or> n = 0) \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "from x"], ["proof (chain)\npicking this:\n  \\<not> (x = (1::'a) \\<or> n = 0)", "obtain m where n: \"n = Suc m\""], ["proof (prove)\nusing this:\n  \\<not> (x = (1::'a) \\<or> n = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n, auto)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. x = (1::'a) \\<or> n = 0 \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))\n 2. \\<not> (x = (1::'a) \\<or> n = 0) \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "have id: \"{..< n} = {0..m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<n} = {0..m}", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<Suc m} = {0..m}", "by auto"], ["proof (state)\nthis:\n  {..<n} = {0..m}\n\ngoal (2 subgoals):\n 1. x = (1::'a) \\<or> n = 0 \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))\n 2. \\<not> (x = (1::'a) \\<or> n = 0) \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "using assms x n"], ["proof (prove)\nusing this:\n  x ^ n = (1::'a)\n  \\<not> (x = (1::'a) \\<or> n = 0)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "unfolding id sum_gp"], ["proof (prove)\nusing this:\n  x ^ n = (1::'a)\n  \\<not> (x = (1::'a) \\<or> n = 0)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. (if m < 0 then 0::'a\n     else if x = (1::'a) then of_nat (m + 1 - 0)\n          else (x ^ 0 - x ^ Suc m) / ((1::'a) - x)) =\n    (if x = (1::'a) then of_nat n else (0::'a))", "by (auto simp: divide_inverse)"], ["proof (state)\nthis:\n  sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))\n\ngoal (1 subgoal):\n 1. x = (1::'a) \\<or> n = 0 \\<Longrightarrow>\n    sum ((^) x) {..<n} = (if x = (1::'a) then of_nat n else (0::'a))", "qed auto"], ["", "lemma sum_root_unity_power_pos_implies_1:  \n  assumes sumpos: \"\\<And> k. Re (sum (\\<lambda> i. b i * x i ^ k) I) > 0\" \n  and root_unity: \"\\<And> i. i \\<in> I \\<Longrightarrow> \\<exists> d. d \\<noteq> 0 \\<and> x i ^ d = 1\" \nshows \"1 \\<in> x ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> x ` I", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  1 \\<notin> x ` I\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "hence x: \"i \\<in> I \\<Longrightarrow> x i \\<noteq> 1\" for i"], ["proof (prove)\nusing this:\n  1 \\<notin> x ` I\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<Longrightarrow> x i \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> x ?i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "from sumpos[of 0]"], ["proof (chain)\npicking this:\n  0 < Re (\\<Sum>i\\<in>I. b i * x i ^ 0)", "have I: \"finite I\" \"I \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < Re (\\<Sum>i\\<in>I. b i * x i ^ 0)\n\ngoal (1 subgoal):\n 1. finite I &&& I \\<noteq> {}", "using sum.infinite"], ["proof (prove)\nusing this:\n  0 < Re (\\<Sum>i\\<in>I. b i * x i ^ 0)\n  infinite ?A \\<Longrightarrow> sum ?g ?A = (0::?'a)\n\ngoal (1 subgoal):\n 1. finite I &&& I \\<noteq> {}", "by fastforce+"], ["proof (state)\nthis:\n  finite I\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have \"\\<forall> i. \\<exists> d. i \\<in> I \\<longrightarrow> d \\<noteq> 0 \\<and> x i ^ d = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>d.\n          i \\<in> I \\<longrightarrow> d \\<noteq> 0 \\<and> x i ^ d = 1", "using root_unity"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> \\<exists>d. d \\<noteq> 0 \\<and> x ?i ^ d = 1\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>d.\n          i \\<in> I \\<longrightarrow> d \\<noteq> 0 \\<and> x i ^ d = 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>d. i \\<in> I \\<longrightarrow> d \\<noteq> 0 \\<and> x i ^ d = 1\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>xa.\n        xa \\<in> I \\<longrightarrow> f xa \\<noteq> 0 \\<and> x xa ^ f xa = 1", "obtain d where d: \"\\<And> i. i \\<in> I \\<Longrightarrow> d i \\<noteq> 0 \\<and> x i ^ (d i) = 1\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>xa.\n        xa \\<in> I \\<longrightarrow> f xa \\<noteq> 0 \\<and> x xa ^ f xa = 1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (\\<And>i.\n            i \\<in> I \\<Longrightarrow>\n            d i \\<noteq> 0 \\<and> x i ^ d i = 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> d ?i \\<noteq> 0 \\<and> x ?i ^ d ?i = 1\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "define D where \"D = prod d I\""], ["proof (state)\nthis:\n  D = prod d I\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have D0: \"0 < D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < prod d I", "by (rule prod_pos, insert d, auto)"], ["proof (state)\nthis:\n  0 < D\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have \"0 < sum (\\<lambda> k. Re (sum (\\<lambda> i. b i * x i ^ k) I)) {..< D}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>k<D. Re (\\<Sum>i\\<in>I. b i * x i ^ k))", "by (rule sum_pos[OF _ _ sumpos], insert D0, auto)"], ["proof (state)\nthis:\n  0 < (\\<Sum>k<D. Re (\\<Sum>i\\<in>I. b i * x i ^ k))\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 < (\\<Sum>k<D. Re (\\<Sum>i\\<in>I. b i * x i ^ k))\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have \"\\<dots> = Re (sum (\\<lambda> k. sum (\\<lambda> i. b i * x i ^ k) I) {..< D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<D. Re (\\<Sum>i\\<in>I. b i * x i ^ k)) =\n    Re (\\<Sum>k<D. \\<Sum>i\\<in>I. b i * x i ^ k)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k<D. Re (\\<Sum>i\\<in>I. b i * x i ^ k)) =\n  Re (\\<Sum>k<D. \\<Sum>i\\<in>I. b i * x i ^ k)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<D. Re (\\<Sum>i\\<in>I. b i * x i ^ k)) =\n  Re (\\<Sum>k<D. \\<Sum>i\\<in>I. b i * x i ^ k)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have \"sum (\\<lambda> k. sum (\\<lambda> i. b i * x i ^ k) I) {..< D}\n    = sum (\\<lambda> i. sum (\\<lambda> k. b i * x i ^ k) {..< D}) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<D. \\<Sum>i\\<in>I. b i * x i ^ k) =\n    (\\<Sum>i\\<in>I. \\<Sum>k<D. b i * x i ^ k)", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>k<D. \\<Sum>i\\<in>I. b i * x i ^ k) =\n  (\\<Sum>i\\<in>I. \\<Sum>k<D. b i * x i ^ k)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<D. \\<Sum>i\\<in>I. b i * x i ^ k) =\n  (\\<Sum>i\\<in>I. \\<Sum>k<D. b i * x i ^ k)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have \"\\<dots> = sum (\\<lambda> i. b i * sum (\\<lambda> k. x i ^ k) {..< D}) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. \\<Sum>k<D. b i * x i ^ k) =\n    (\\<Sum>i\\<in>I. b i * sum ((^) (x i)) {..<D})", "by (rule sum.cong, auto simp: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. \\<Sum>k<D. b i * x i ^ k) =\n  (\\<Sum>i\\<in>I. b i * sum ((^) (x i)) {..<D})\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. \\<Sum>k<D. b i * x i ^ k) =\n  (\\<Sum>i\\<in>I. b i * sum ((^) (x i)) {..<D})\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. b i * sum ((^) (x i)) {..<D}) = 0", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "assume i: \"i \\<in> I\""], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "from d[OF this] x[OF this]"], ["proof (chain)\npicking this:\n  d i \\<noteq> 0 \\<and> x i ^ d i = 1\n  x i \\<noteq> 1", "have d: \"d i \\<noteq> 0\" and rt_unity: \"x i ^ d i = 1\" \n      and x: \"x i \\<noteq> 1\""], ["proof (prove)\nusing this:\n  d i \\<noteq> 0 \\<and> x i ^ d i = 1\n  x i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. d i \\<noteq> 0 &&& x i ^ d i = 1 &&& x i \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  d i \\<noteq> 0\n  x i ^ d i = 1\n  x i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have \"\\<exists> C. D = d i * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. D = d i * C", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. prod d I = d i * C", "by (subst prod.remove[of _ i], insert i I, auto)"], ["proof (state)\nthis:\n  \\<exists>C. D = d i * C\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>C. D = d i * C", "obtain C where D: \"D = d i * C\""], ["proof (prove)\nusing this:\n  \\<exists>C. D = d i * C\n\ngoal (1 subgoal):\n 1. (\\<And>C. D = d i * C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  D = d i * C\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have image: \"(\\<And> x. f x = x) \\<Longrightarrow> {..< D} = f ` {..< D}\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x = x) \\<Longrightarrow> {..<D} = f ` {..<D}", "by auto"], ["proof (state)\nthis:\n  (\\<And>x. ?f x = x) \\<Longrightarrow> {..<D} = ?f ` {..<D}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "let ?g = \"(\\<lambda> (a,c). a + d i * c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have \"{..< D} = ?g ` (\\<lambda> j. (j mod d i, j div d i)) ` {..< d i * C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<D} =\n    (\\<lambda>(a, c). a + d i * c) `\n    (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}", "unfolding image_image split D[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<D} = (\\<lambda>x. x mod d i + d i * (x div d i)) ` {..<D}", "by (rule image, insert d mod_mult_div_eq, blast)"], ["proof (state)\nthis:\n  {..<D} =\n  (\\<lambda>(a, c). a + d i * c) `\n  (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "also"], ["proof (state)\nthis:\n  {..<D} =\n  (\\<lambda>(a, c). a + d i * c) `\n  (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have \"(\\<lambda> j. (j mod d i, j div d i)) ` {..< d i * C} = {..< d i} \\<times> {..< C}\" (is \"?f ` ?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "assume \"x \\<in> ?B\""], ["proof (state)\nthis:\n  x \\<in> {..<d i} \\<times> {..<C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {..<d i} \\<times> {..<C}", "obtain a c where x: \"x = (a,c)\" and a: \"a < d i\" and c: \"c < C\""], ["proof (prove)\nusing this:\n  x \\<in> {..<d i} \\<times> {..<C}\n\ngoal (1 subgoal):\n 1. (\\<And>a c.\n        \\<lbrakk>x = (a, c); a < d i; c < C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (a, c)\n  a < d i\n  c < C\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "hence \"a + c * d i < d i * (1 + c)\""], ["proof (prove)\nusing this:\n  x = (a, c)\n  a < d i\n  c < C\n\ngoal (1 subgoal):\n 1. a + c * d i < d i * (1 + c)", "by simp"], ["proof (state)\nthis:\n  a + c * d i < d i * (1 + c)\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "also"], ["proof (state)\nthis:\n  a + c * d i < d i * (1 + c)\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "have \"\\<dots> \\<le> d i * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * (1 + c) \\<le> d i * C", "by (rule mult_le_mono2, insert c, auto)"], ["proof (state)\nthis:\n  d i * (1 + c) \\<le> d i * C\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "finally"], ["proof (chain)\npicking this:\n  a + c * d i < d i * C", "have \"a + c * d i \\<in> ?A\""], ["proof (prove)\nusing this:\n  a + c * d i < d i * C\n\ngoal (1 subgoal):\n 1. a + c * d i \\<in> {..<d i * C}", "by auto"], ["proof (state)\nthis:\n  a + c * d i \\<in> {..<d i * C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "hence \"?f (a + c * d i) \\<in> ?f ` ?A\""], ["proof (prove)\nusing this:\n  a + c * d i \\<in> {..<d i * C}\n\ngoal (1 subgoal):\n 1. ((a + c * d i) mod d i, (a + c * d i) div d i)\n    \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}", "by blast"], ["proof (state)\nthis:\n  ((a + c * d i) mod d i, (a + c * d i) div d i)\n  \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "also"], ["proof (state)\nthis:\n  ((a + c * d i) mod d i, (a + c * d i) div d i)\n  \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "have \"?f (a + c * d i) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a + c * d i) mod d i, (a + c * d i) div d i) = x", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a + c * d i) mod d i, (a + c * d i) div d i) = (a, c)", "using a"], ["proof (prove)\nusing this:\n  a < d i\n\ngoal (1 subgoal):\n 1. ((a + c * d i) mod d i, (a + c * d i) div d i) = (a, c)", "by auto"], ["proof (state)\nthis:\n  ((a + c * d i) mod d i, (a + c * d i) div d i) = x\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "finally"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}", "have \"x \\<in> ?f ` ?A\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}", "."], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "}"], ["proof (state)\nthis:\n  ?xa2 \\<in> {..<d i} \\<times> {..<C} \\<Longrightarrow>\n  ?xa2 \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?xa2 \\<in> {..<d i} \\<times> {..<C} \\<Longrightarrow>\n  ?xa2 \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "using d"], ["proof (prove)\nusing this:\n  ?xa2 \\<in> {..<d i} \\<times> {..<C} \\<Longrightarrow>\n  ?xa2 \\<in> (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C}\n  d i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n    {..<d i} \\<times> {..<C}", "by (auto simp: div_lt_nat)"], ["proof (state)\nthis:\n  (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n  {..<d i} \\<times> {..<C}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>j. (j mod d i, j div d i)) ` {..<d i * C} =\n  {..<d i} \\<times> {..<C}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "finally"], ["proof (chain)\npicking this:\n  {..<D} =\n  (\\<lambda>a. case a of (a, c) \\<Rightarrow> a + d i * c) `\n  ({..<d i} \\<times> {..<C})", "have D: \"{..< D} = (\\<lambda> (a,c). a + d i * c) ` ?B\""], ["proof (prove)\nusing this:\n  {..<D} =\n  (\\<lambda>a. case a of (a, c) \\<Rightarrow> a + d i * c) `\n  ({..<d i} \\<times> {..<C})\n\ngoal (1 subgoal):\n 1. {..<D} = (\\<lambda>(a, c). a + d i * c) ` ({..<d i} \\<times> {..<C})", "by auto"], ["proof (state)\nthis:\n  {..<D} = (\\<lambda>(a, c). a + d i * c) ` ({..<d i} \\<times> {..<C})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have inj: \"inj_on ?g ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "fix a1 a2 c1 c2"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "assume id: \"?g (a1,c1) = ?g (a2,c2)\" and *: \"(a1,c1) \\<in> ?B\" \"(a2,c2) \\<in> ?B\""], ["proof (state)\nthis:\n  (case (a1, c1) of (a, c) \\<Rightarrow> a + d i * c) =\n  (case (a2, c2) of (a, c) \\<Rightarrow> a + d i * c)\n  (a1, c1) \\<in> {..<d i} \\<times> {..<C}\n  (a2, c2) \\<in> {..<d i} \\<times> {..<C}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "from arg_cong[OF id, of \"\\<lambda> x. x div d i\"] *"], ["proof (chain)\npicking this:\n  (case (a1, c1) of (a, c) \\<Rightarrow> a + d i * c) div d i =\n  (case (a2, c2) of (a, c) \\<Rightarrow> a + d i * c) div d i\n  (a1, c1) \\<in> {..<d i} \\<times> {..<C}\n  (a2, c2) \\<in> {..<d i} \\<times> {..<C}", "have c: \"c1 = c2\""], ["proof (prove)\nusing this:\n  (case (a1, c1) of (a, c) \\<Rightarrow> a + d i * c) div d i =\n  (case (a2, c2) of (a, c) \\<Rightarrow> a + d i * c) div d i\n  (a1, c1) \\<in> {..<d i} \\<times> {..<C}\n  (a2, c2) \\<in> {..<d i} \\<times> {..<C}\n\ngoal (1 subgoal):\n 1. c1 = c2", "by auto"], ["proof (state)\nthis:\n  c1 = c2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "from arg_cong[OF id, of \"\\<lambda> x. x mod d i\"] *"], ["proof (chain)\npicking this:\n  (case (a1, c1) of (a, c) \\<Rightarrow> a + d i * c) mod d i =\n  (case (a2, c2) of (a, c) \\<Rightarrow> a + d i * c) mod d i\n  (a1, c1) \\<in> {..<d i} \\<times> {..<C}\n  (a2, c2) \\<in> {..<d i} \\<times> {..<C}", "have a: \"a1 = a2\""], ["proof (prove)\nusing this:\n  (case (a1, c1) of (a, c) \\<Rightarrow> a + d i * c) mod d i =\n  (case (a2, c2) of (a, c) \\<Rightarrow> a + d i * c) mod d i\n  (a1, c1) \\<in> {..<d i} \\<times> {..<C}\n  (a2, c2) \\<in> {..<d i} \\<times> {..<C}\n\ngoal (1 subgoal):\n 1. a1 = a2", "by auto"], ["proof (state)\nthis:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "note a c"], ["proof (state)\nthis:\n  a1 = a2\n  c1 = c2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(case (?a1.2, ?c1.2) of (a, c) \\<Rightarrow> a + d i * c) =\n           (case (?a2.2, ?c2.2) of (a, c) \\<Rightarrow> a + d i * c);\n   (?a1.2, ?c1.2) \\<in> {..<d i} \\<times> {..<C};\n   (?a2.2, ?c2.2) \\<in> {..<d i} \\<times> {..<C}\\<rbrakk>\n  \\<Longrightarrow> ?a1.2 = ?a2.2\n  \\<lbrakk>(case (?a1.2, ?c1.2) of (a, c) \\<Rightarrow> a + d i * c) =\n           (case (?a2.2, ?c2.2) of (a, c) \\<Rightarrow> a + d i * c);\n   (?a1.2, ?c1.2) \\<in> {..<d i} \\<times> {..<C};\n   (?a2.2, ?c2.2) \\<in> {..<d i} \\<times> {..<C}\\<rbrakk>\n  \\<Longrightarrow> ?c1.2 = ?c2.2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(case (?a1.2, ?c1.2) of (a, c) \\<Rightarrow> a + d i * c) =\n           (case (?a2.2, ?c2.2) of (a, c) \\<Rightarrow> a + d i * c);\n   (?a1.2, ?c1.2) \\<in> {..<d i} \\<times> {..<C};\n   (?a2.2, ?c2.2) \\<in> {..<d i} \\<times> {..<C}\\<rbrakk>\n  \\<Longrightarrow> ?a1.2 = ?a2.2\n  \\<lbrakk>(case (?a1.2, ?c1.2) of (a, c) \\<Rightarrow> a + d i * c) =\n           (case (?a2.2, ?c2.2) of (a, c) \\<Rightarrow> a + d i * c);\n   (?a1.2, ?c1.2) \\<in> {..<d i} \\<times> {..<C};\n   (?a2.2, ?c2.2) \\<in> {..<d i} \\<times> {..<C}\\<rbrakk>\n  \\<Longrightarrow> ?c1.2 = ?c2.2\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})", "by (smt SigmaE inj_onI)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(a, c). a + d i * c) ({..<d i} \\<times> {..<C})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have \"sum (\\<lambda> k. x i ^ k) {..< D} = sum (\\<lambda> (a,c). x i ^ (a + d i * c)) ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (x i)) {..<D} =\n    (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c))", "unfolding D"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (x i))\n     ((\\<lambda>(a, c). a + d i * c) ` ({..<d i} \\<times> {..<C})) =\n    (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c))", "by (subst sum.reindex, rule inj, auto intro!: sum.cong)"], ["proof (state)\nthis:\n  sum ((^) (x i)) {..<D} =\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "also"], ["proof (state)\nthis:\n  sum ((^) (x i)) {..<D} =\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have \"\\<dots> = sum (\\<lambda> (a,c). x i ^ a) ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c)) =\n    (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ a)", "by (rule sum.cong, auto simp: power_add power_mult rt_unity)"], ["proof (state)\nthis:\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c)) =\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ a)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ (a + d i * c)) =\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ a)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ a) = 0", "unfolding sum.cartesian_product[symmetric]  sum.swap[of _ \"{..<C}\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<C. sum ((^) (x i)) {..<d i}) = 0", "by (rule sum.neutral, intro ballI, subst sum_root_unity[OF rt_unity], insert x, auto)"], ["proof (state)\nthis:\n  (\\<Sum>(a, c)\\<in>{..<d i} \\<times> {..<C}. x i ^ a) = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> I \\<Longrightarrow> b xa * sum ((^) (x xa)) {..<D} = 0", "finally"], ["proof (chain)\npicking this:\n  sum ((^) (x i)) {..<D} = 0", "show \"b i * sum (\\<lambda> k. x i ^ k) {..< D} = 0\""], ["proof (prove)\nusing this:\n  sum ((^) (x i)) {..<D} = 0\n\ngoal (1 subgoal):\n 1. b i * sum ((^) (x i)) {..<D} = 0", "by simp"], ["proof (state)\nthis:\n  b i * sum ((^) (x i)) {..<D} = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. b i * sum ((^) (x i)) {..<D}) = 0\n\ngoal (1 subgoal):\n 1. 1 \\<notin> x ` I \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 < Re 0", "show False"], ["proof (prove)\nusing this:\n  0 < Re 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "fun j_to_jb_index :: \"(nat \\<times> 'a)list \\<Rightarrow> nat \\<Rightarrow> nat \\<times> nat\" where\n  \"j_to_jb_index ((n,a) # n_as) i = (if i < n then (0,i) else \n     let rec = j_to_jb_index n_as (i - n) in (Suc (fst rec), snd rec))\""], ["", "fun jb_to_j_index :: \"(nat \\<times> 'a)list \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat\" where\n  \"jb_to_j_index n_as (0,j) = j\" \n| \"jb_to_j_index ((n,_) # n_as) (Suc i, j) = n + jb_to_j_index n_as (i,j)\""], ["", "lemma j_to_jb_index: assumes \"i < sum_list (map fst n_as)\" \n  and \"j < sum_list (map fst n_as)\" \n  and \"j_to_jb_index n_as i = (bi, li)\" \n  and \"j_to_jb_index n_as j = (bj, lj)\" \n  and \"n_as ! bj = (n, a)\" \nshows \"((jordan_matrix n_as) ^\\<^sub>m r) $$ (i,j) = (if bi = bj then ((jordan_block n a) ^\\<^sub>m r) $$ (li, lj) else 0)\n  \\<and> (bi = bj \\<longrightarrow> li < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n,a) \\<in> set n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (jordan_matrix n_as ^\\<^sub>m r) $$ (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as)", "unfolding jordan_matrix_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as)", "using assms"], ["proof (prove)\nusing this:\n  i < sum_list (map fst n_as)\n  j < sum_list (map fst n_as)\n  j_to_jb_index n_as i = (bi, li)\n  j_to_jb_index n_as j = (bj, lj)\n  n_as ! bj = (n, a)\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as)", "proof (induct n_as arbitrary: i j bi bj)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "case (Cons mb n_as i j bi bj)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < sum_list (map fst n_as); ?j < sum_list (map fst n_as);\n   j_to_jb_index n_as ?i = (?bi, li); j_to_jb_index n_as ?j = (?bj, lj);\n   n_as ! ?bj = (n, a)\\<rbrakk>\n  \\<Longrightarrow> diag_block_mat\n                     (map (\\<lambda>a.\n                              case a of\n                              (n, a) \\<Rightarrow>\n                                jordan_block n a ^\\<^sub>m r)\n                       n_as) $$\n                    (?i, ?j) =\n                    (if ?bi = ?bj\n                     then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                     else (0::'a)) \\<and>\n                    (?bi = ?bj \\<longrightarrow>\n                     li < n \\<and>\n                     lj < n \\<and>\n                     ?bj < length n_as \\<and> (n, a) \\<in> set n_as)\n  i < sum_list (map fst (mb # n_as))\n  j < sum_list (map fst (mb # n_as))\n  j_to_jb_index (mb # n_as) i = (bi, li)\n  j_to_jb_index (mb # n_as) j = (bj, lj)\n  (mb # n_as) ! bj = (n, a)\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "obtain m b where mb: \"mb = (m,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m b. mb = (m, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  mb = (m, b)\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "note Cons = Cons[unfolded mb]"], ["proof (state)\nthis:\n  \\<lbrakk>?i < sum_list (map fst n_as); ?j < sum_list (map fst n_as);\n   j_to_jb_index n_as ?i = (?bi, li); j_to_jb_index n_as ?j = (?bj, lj);\n   n_as ! ?bj = (n, a)\\<rbrakk>\n  \\<Longrightarrow> diag_block_mat\n                     (map (\\<lambda>a.\n                              case a of\n                              (n, a) \\<Rightarrow>\n                                jordan_block n a ^\\<^sub>m r)\n                       n_as) $$\n                    (?i, ?j) =\n                    (if ?bi = ?bj\n                     then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                     else (0::'a)) \\<and>\n                    (?bi = ?bj \\<longrightarrow>\n                     li < n \\<and>\n                     lj < n \\<and>\n                     ?bj < length n_as \\<and> (n, a) \\<in> set n_as)\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "have [simp]: \"dim_col (case x of (n, a) \\<Rightarrow> 1\\<^sub>m n) = fst x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (case x of (n, a) \\<Rightarrow> 1\\<^sub>m n) = fst x", "by (cases x, auto)"], ["proof (state)\nthis:\n  dim_col (case ?x1 of (n, a) \\<Rightarrow> 1\\<^sub>m n) = fst ?x1\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "have [simp]: \"dim_row (case x of (n, a) \\<Rightarrow> 1\\<^sub>m n) = fst x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (case x of (n, a) \\<Rightarrow> 1\\<^sub>m n) = fst x", "by (cases x, auto)"], ["proof (state)\nthis:\n  dim_row (case ?x2 of (n, a) \\<Rightarrow> 1\\<^sub>m n) = fst ?x2\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "have [simp]: \"dim_col (case x of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) = fst x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (case x of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) =\n    fst x", "by (cases x, auto)"], ["proof (state)\nthis:\n  dim_col (case ?x3 of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) =\n  fst ?x3\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "have [simp]: \"dim_row (case x of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) = fst x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (case x of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) =\n    fst x", "by (cases x, auto)"], ["proof (state)\nthis:\n  dim_row (case ?x4 of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) =\n  fst ?x4\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "consider (UL) \"i < m\" \"j < m\" | (UR) \"i < m\" \"j \\<ge> m\" | (LL) \"i \\<ge> m\" \"j < m\" \n    | (LR) \"i \\<ge> m\" \"j \\<ge> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i < m; j < m\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>i < m; m \\<le> j\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>m \\<le> i; j < m\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>i < m; j < m\\<rbrakk> \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>i < m; m \\<le> j\\<rbrakk> \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>m \\<le> i; j < m\\<rbrakk> \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n\ngoal (2 subgoals):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])\n 2. \\<And>aa n_as i j bi bj.\n       \\<lbrakk>\\<And>i j bi bj.\n                   \\<lbrakk>i < sum_list (map fst n_as);\n                    j < sum_list (map fst n_as);\n                    j_to_jb_index n_as i = (bi, li);\n                    j_to_jb_index n_as j = (bj, lj);\n                    n_as ! bj = (n, a)\\<rbrakk>\n                   \\<Longrightarrow> diag_block_mat\n(map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n                                     (i, j) =\n                                     (if bi = bj\nthen (jordan_block n a ^\\<^sub>m r) $$ (li, lj) else (0::'a)) \\<and>\n                                     (bi = bj \\<longrightarrow>\nli < n \\<and> lj < n \\<and> bj < length n_as \\<and> (n, a) \\<in> set n_as);\n        i < sum_list (map fst (aa # n_as));\n        j < sum_list (map fst (aa # n_as));\n        j_to_jb_index (aa # n_as) i = (bi, li);\n        j_to_jb_index (aa # n_as) j = (bj, lj);\n        (aa # n_as) ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            (aa # n_as)) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length (aa # n_as) \\<and>\n                          (n, a) \\<in> set (aa # n_as))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>i < m; j < m\\<rbrakk> \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>i < m; m \\<le> j\\<rbrakk> \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>m \\<le> i; j < m\\<rbrakk> \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < m; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 3. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 4. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "case UL"], ["proof (state)\nthis:\n  i < m\n  j < m\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i < m; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 3. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 4. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "with Cons(2-)"], ["proof (chain)\npicking this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  i < m\n  j < m", "show ?thesis"], ["proof (prove)\nusing this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "unfolding mb"], ["proof (prove)\nusing this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       ((m, b) # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length ((m, b) # n_as) \\<and> (n, a) \\<in> set ((m, b) # n_as))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     (mb # n_as)) $$\n  (i, j) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and>\n   bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 3. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 3. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "case UR"], ["proof (state)\nthis:\n  i < m\n  m \\<le> j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 3. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "with Cons(2-)"], ["proof (chain)\npicking this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  i < m\n  m \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  i < m\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "unfolding mb"], ["proof (prove)\nusing this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  i < m\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       ((m, b) # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length ((m, b) # n_as) \\<and> (n, a) \\<in> set ((m, b) # n_as))", "by (auto simp: Let_def dim_diag_block_mat o_def)"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     (mb # n_as)) $$\n  (i, j) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and>\n   bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "case LL"], ["proof (state)\nthis:\n  m \\<le> i\n  j < m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> i; j < m\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))\n 2. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "with Cons(2-)"], ["proof (chain)\npicking this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  m \\<le> i\n  j < m", "show ?thesis"], ["proof (prove)\nusing this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  m \\<le> i\n  j < m\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "unfolding mb"], ["proof (prove)\nusing this:\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  m \\<le> i\n  j < m\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       ((m, b) # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length ((m, b) # n_as) \\<and> (n, a) \\<in> set ((m, b) # n_as))", "by (auto simp: Let_def dim_diag_block_mat o_def)"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     (mb # n_as)) $$\n  (i, j) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and>\n   bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "case LR"], ["proof (state)\nthis:\n  m \\<le> i\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "let ?i = \"i - m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "let ?j = \"j - m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "from LR Cons(2-)"], ["proof (chain)\npicking this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)", "have bi: \"j_to_jb_index n_as ?i = (bi - 1, li)\" \"bi \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (i - m) = (bi - 1, li) &&& bi \\<noteq> 0", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  j_to_jb_index n_as (i - m) = (bi - 1, li)\n  bi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "from LR Cons(2-)"], ["proof (chain)\npicking this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)", "have bj: \"j_to_jb_index n_as ?j = (bj - 1, lj)\" \"bj \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (j - m) = (bj - 1, lj) &&& bj \\<noteq> 0", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  j_to_jb_index n_as (j - m) = (bj - 1, lj)\n  bj \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "from LR Cons(2-)"], ["proof (chain)\npicking this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)", "have i: \"?i < sum_list (map fst n_as)\""], ["proof (prove)\nusing this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n\ngoal (1 subgoal):\n 1. i - m < sum_list (map fst n_as)", "by auto"], ["proof (state)\nthis:\n  i - m < sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "from LR Cons(2-)"], ["proof (chain)\npicking this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)", "have j: \"?j < sum_list (map fst n_as)\""], ["proof (prove)\nusing this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n\ngoal (1 subgoal):\n 1. j - m < sum_list (map fst n_as)", "by auto"], ["proof (state)\nthis:\n  j - m < sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "from LR Cons(2-) bj(2)"], ["proof (chain)\npicking this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  bj \\<noteq> 0", "have nas: \"n_as ! (bj - 1) = (n, a)\""], ["proof (prove)\nusing this:\n  m \\<le> i\n  m \\<le> j\n  i < sum_list (map fst ((m, b) # n_as))\n  j < sum_list (map fst ((m, b) # n_as))\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  j_to_jb_index ((m, b) # n_as) j = (bj, lj)\n  ((m, b) # n_as) ! bj = (n, a)\n  bj \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n_as ! (bj - 1) = (n, a)", "by (cases bj, auto)"], ["proof (state)\nthis:\n  n_as ! (bj - 1) = (n, a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "from bi(2) bj(2)"], ["proof (chain)\npicking this:\n  bi \\<noteq> 0\n  bj \\<noteq> 0", "have id: \"(bi - 1 = bj - 1) = (bi = bj)\""], ["proof (prove)\nusing this:\n  bi \\<noteq> 0\n  bj \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (bi - 1 = bj - 1) = (bi = bj)", "by auto"], ["proof (state)\nthis:\n  (bi - 1 = bj - 1) = (bi = bj)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "note IH = Cons(1)[OF i j bi(1) bj(1) nas, unfolded id]"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     n_as) $$\n  (i - m, j - m) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and> bj - 1 < length n_as \\<and> (n, a) \\<in> set n_as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "have id: \"diag_block_mat (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) (mb # n_as)) $$ (i, j)\n      = diag_block_mat (map (\\<lambda>a. case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r) n_as) $$ (?i, ?j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       n_as) $$\n    (i - m, j - m)", "using i j LR"], ["proof (prove)\nusing this:\n  i - m < sum_list (map fst n_as)\n  j - m < sum_list (map fst n_as)\n  m \\<le> i\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       n_as) $$\n    (i - m, j - m)", "unfolding mb"], ["proof (prove)\nusing this:\n  i - m < sum_list (map fst n_as)\n  j - m < sum_list (map fst n_as)\n  m \\<le> i\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       ((m, b) # n_as)) $$\n    (i, j) =\n    diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       n_as) $$\n    (i - m, j - m)", "by (auto simp: Let_def dim_diag_block_mat o_def)"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     (mb # n_as)) $$\n  (i, j) =\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     n_as) $$\n  (i - m, j - m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> diag_block_mat\n                       (map (\\<lambda>a.\n                                case a of\n                                (n, a) \\<Rightarrow>\n                                  jordan_block n a ^\\<^sub>m r)\n                         (mb # n_as)) $$\n                      (i, j) =\n                      (if bi = bj\n                       then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                       else (0::'a)) \\<and>\n                      (bi = bj \\<longrightarrow>\n                       li < n \\<and>\n                       lj < n \\<and>\n                       bj < length (mb # n_as) \\<and>\n                       (n, a) \\<in> set (mb # n_as))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "using IH"], ["proof (prove)\nusing this:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     n_as) $$\n  (i - m, j - m) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and> bj - 1 < length n_as \\<and> (n, a) \\<in> set n_as)\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>a.\n              case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n       (mb # n_as)) $$\n    (i, j) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "unfolding id"], ["proof (prove)\nusing this:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     n_as) $$\n  (i - m, j - m) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and> bj - 1 < length n_as \\<and> (n, a) \\<in> set n_as)\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>(n, a). jordan_block n a ^\\<^sub>m r) n_as) $$\n    (i - m, j - m) =\n    (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n     else (0::'a)) \\<and>\n    (bi = bj \\<longrightarrow>\n     li < n \\<and>\n     lj < n \\<and>\n     bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))", "by auto"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     (mb # n_as)) $$\n  (i, j) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and>\n   bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  diag_block_mat\n   (map (\\<lambda>a.\n            case a of (n, a) \\<Rightarrow> jordan_block n a ^\\<^sub>m r)\n     (mb # n_as)) $$\n  (i, j) =\n  (if bi = bj then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n   else (0::'a)) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < n \\<and>\n   lj < n \\<and>\n   bj < length (mb # n_as) \\<and> (n, a) \\<in> set (mb # n_as))\n\ngoal (1 subgoal):\n 1. \\<And>i j bi bj.\n       \\<lbrakk>i < sum_list (map fst []); j < sum_list (map fst []);\n        j_to_jb_index [] i = (bi, li); j_to_jb_index [] j = (bj, lj);\n        [] ! bj = (n, a)\\<rbrakk>\n       \\<Longrightarrow> diag_block_mat\n                          (map (\\<lambda>(n, a).\n                                   jordan_block n a ^\\<^sub>m r)\n                            []) $$\n                         (i, j) =\n                         (if bi = bj\n                          then (jordan_block n a ^\\<^sub>m r) $$ (li, lj)\n                          else (0::'a)) \\<and>\n                         (bi = bj \\<longrightarrow>\n                          li < n \\<and>\n                          lj < n \\<and>\n                          bj < length [] \\<and> (n, a) \\<in> set [])", "qed auto"], ["", "lemma j_to_jb_index_rev: assumes j: \"j_to_jb_index n_as i = (bi, li)\" \n  and i: \"i < sum_list (map fst n_as)\" \n  and k: \"k \\<le> li\" \nshows \"li \\<le> i \\<and> j_to_jb_index n_as (i - k) = (bi, li - k) \\<and> (\n  j_to_jb_index n_as j = (bi,li - k) \\<longrightarrow> j < sum_list (map fst n_as) \\<longrightarrow> j = i - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index n_as (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index n_as j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst n_as) \\<longrightarrow> j = i - k)", "using j i"], ["proof (prove)\nusing this:\n  j_to_jb_index n_as i = (bi, li)\n  i < sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index n_as (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index n_as j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst n_as) \\<longrightarrow> j = i - k)", "proof (induct n_as arbitrary: i bi j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i bi j.\n       \\<lbrakk>j_to_jb_index [] i = (bi, li);\n        i < sum_list (map fst [])\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index [] (i - k) = (bi, li - k) \\<and>\n                         (j_to_jb_index [] j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list (map fst []) \\<longrightarrow>\n                          j = i - k)\n 2. \\<And>a n_as i bi j.\n       \\<lbrakk>\\<And>i bi j.\n                   \\<lbrakk>j_to_jb_index n_as i = (bi, li);\n                    i < sum_list (map fst n_as)\\<rbrakk>\n                   \\<Longrightarrow> li \\<le> i \\<and>\n                                     j_to_jb_index n_as (i - k) =\n                                     (bi, li - k) \\<and>\n                                     (j_to_jb_index n_as j =\n(bi, li - k) \\<longrightarrow>\nj < sum_list (map fst n_as) \\<longrightarrow> j = i - k);\n        j_to_jb_index (a # n_as) i = (bi, li);\n        i < sum_list (map fst (a # n_as))\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index (a # n_as) (i - k) =\n                         (bi, li - k) \\<and>\n                         (j_to_jb_index (a # n_as) j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list\n                               (map fst (a # n_as)) \\<longrightarrow>\n                          j = i - k)", "case (Cons mb n_as i bi j)"], ["proof (state)\nthis:\n  \\<lbrakk>j_to_jb_index n_as ?i = (?bi, li);\n   ?i < sum_list (map fst n_as)\\<rbrakk>\n  \\<Longrightarrow> li \\<le> ?i \\<and>\n                    j_to_jb_index n_as (?i - k) = (?bi, li - k) \\<and>\n                    (j_to_jb_index n_as ?j = (?bi, li - k) \\<longrightarrow>\n                     ?j < sum_list (map fst n_as) \\<longrightarrow>\n                     ?j = ?i - k)\n  j_to_jb_index (mb # n_as) i = (bi, li)\n  i < sum_list (map fst (mb # n_as))\n\ngoal (2 subgoals):\n 1. \\<And>i bi j.\n       \\<lbrakk>j_to_jb_index [] i = (bi, li);\n        i < sum_list (map fst [])\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index [] (i - k) = (bi, li - k) \\<and>\n                         (j_to_jb_index [] j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list (map fst []) \\<longrightarrow>\n                          j = i - k)\n 2. \\<And>a n_as i bi j.\n       \\<lbrakk>\\<And>i bi j.\n                   \\<lbrakk>j_to_jb_index n_as i = (bi, li);\n                    i < sum_list (map fst n_as)\\<rbrakk>\n                   \\<Longrightarrow> li \\<le> i \\<and>\n                                     j_to_jb_index n_as (i - k) =\n                                     (bi, li - k) \\<and>\n                                     (j_to_jb_index n_as j =\n(bi, li - k) \\<longrightarrow>\nj < sum_list (map fst n_as) \\<longrightarrow> j = i - k);\n        j_to_jb_index (a # n_as) i = (bi, li);\n        i < sum_list (map fst (a # n_as))\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index (a # n_as) (i - k) =\n                         (bi, li - k) \\<and>\n                         (j_to_jb_index (a # n_as) j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list\n                               (map fst (a # n_as)) \\<longrightarrow>\n                          j = i - k)", "obtain m b where mb: \"mb = (m,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m b. mb = (m, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  mb = (m, b)\n\ngoal (2 subgoals):\n 1. \\<And>i bi j.\n       \\<lbrakk>j_to_jb_index [] i = (bi, li);\n        i < sum_list (map fst [])\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index [] (i - k) = (bi, li - k) \\<and>\n                         (j_to_jb_index [] j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list (map fst []) \\<longrightarrow>\n                          j = i - k)\n 2. \\<And>a n_as i bi j.\n       \\<lbrakk>\\<And>i bi j.\n                   \\<lbrakk>j_to_jb_index n_as i = (bi, li);\n                    i < sum_list (map fst n_as)\\<rbrakk>\n                   \\<Longrightarrow> li \\<le> i \\<and>\n                                     j_to_jb_index n_as (i - k) =\n                                     (bi, li - k) \\<and>\n                                     (j_to_jb_index n_as j =\n(bi, li - k) \\<longrightarrow>\nj < sum_list (map fst n_as) \\<longrightarrow> j = i - k);\n        j_to_jb_index (a # n_as) i = (bi, li);\n        i < sum_list (map fst (a # n_as))\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index (a # n_as) (i - k) =\n                         (bi, li - k) \\<and>\n                         (j_to_jb_index (a # n_as) j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list\n                               (map fst (a # n_as)) \\<longrightarrow>\n                          j = i - k)", "note Cons = Cons[unfolded mb]"], ["proof (state)\nthis:\n  \\<lbrakk>j_to_jb_index n_as ?i = (?bi, li);\n   ?i < sum_list (map fst n_as)\\<rbrakk>\n  \\<Longrightarrow> li \\<le> ?i \\<and>\n                    j_to_jb_index n_as (?i - k) = (?bi, li - k) \\<and>\n                    (j_to_jb_index n_as ?j = (?bi, li - k) \\<longrightarrow>\n                     ?j < sum_list (map fst n_as) \\<longrightarrow>\n                     ?j = ?i - k)\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  i < sum_list (map fst ((m, b) # n_as))\n\ngoal (2 subgoals):\n 1. \\<And>i bi j.\n       \\<lbrakk>j_to_jb_index [] i = (bi, li);\n        i < sum_list (map fst [])\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index [] (i - k) = (bi, li - k) \\<and>\n                         (j_to_jb_index [] j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list (map fst []) \\<longrightarrow>\n                          j = i - k)\n 2. \\<And>a n_as i bi j.\n       \\<lbrakk>\\<And>i bi j.\n                   \\<lbrakk>j_to_jb_index n_as i = (bi, li);\n                    i < sum_list (map fst n_as)\\<rbrakk>\n                   \\<Longrightarrow> li \\<le> i \\<and>\n                                     j_to_jb_index n_as (i - k) =\n                                     (bi, li - k) \\<and>\n                                     (j_to_jb_index n_as j =\n(bi, li - k) \\<longrightarrow>\nj < sum_list (map fst n_as) \\<longrightarrow> j = i - k);\n        j_to_jb_index (a # n_as) i = (bi, li);\n        i < sum_list (map fst (a # n_as))\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index (a # n_as) (i - k) =\n                         (bi, li - k) \\<and>\n                         (j_to_jb_index (a # n_as) j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list\n                               (map fst (a # n_as)) \\<longrightarrow>\n                          j = i - k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "proof (cases \"i < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)\n 2. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "case True"], ["proof (state)\nthis:\n  i < m\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)\n 2. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "unfolding mb"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index ((m, b) # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index ((m, b) # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst ((m, b) # n_as)) \\<longrightarrow> j = i - k)", "using Cons(2-)"], ["proof (prove)\nusing this:\n  i < m\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  i < sum_list (map fst ((m, b) # n_as))\n\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index ((m, b) # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index ((m, b) # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst ((m, b) # n_as)) \\<longrightarrow> j = i - k)", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  li \\<le> i \\<and>\n  j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n  (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n   j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "case i_large: False"], ["proof (state)\nthis:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "let ?i = \"i - m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "have i: \"?i < sum_list (map fst n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - m < sum_list (map fst n_as)", "using Cons(2-) i_large"], ["proof (prove)\nusing this:\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  i < sum_list (map fst ((m, b) # n_as))\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. i - m < sum_list (map fst n_as)", "by auto"], ["proof (state)\nthis:\n  i - m < sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from Cons(2-) i_large"], ["proof (chain)\npicking this:\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  i < sum_list (map fst ((m, b) # n_as))\n  \\<not> i < m", "have j: \"j_to_jb_index n_as ?i = (bi - 1, li)\" \n      and bi: \"bi \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j_to_jb_index ((m, b) # n_as) i = (bi, li)\n  i < sum_list (map fst ((m, b) # n_as))\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (i - m) = (bi - 1, li) &&& bi \\<noteq> 0", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  j_to_jb_index n_as (i - m) = (bi - 1, li)\n  bi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "note IH = Cons(1)[OF j i]"], ["proof (state)\nthis:\n  li \\<le> i - m \\<and>\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k) \\<and>\n  (j_to_jb_index n_as ?j = (bi - 1, li - k) \\<longrightarrow>\n   ?j < sum_list (map fst n_as) \\<longrightarrow> ?j = i - m - k)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from IH"], ["proof (chain)\npicking this:\n  li \\<le> i - m \\<and>\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k) \\<and>\n  (j_to_jb_index n_as ?j = (bi - 1, li - k) \\<longrightarrow>\n   ?j < sum_list (map fst n_as) \\<longrightarrow> ?j = i - m - k)", "have IH1: \"j_to_jb_index n_as (i - m - k) = (bi - 1, li - k)\" and\n       li: \"li \\<le> i - m\""], ["proof (prove)\nusing this:\n  li \\<le> i - m \\<and>\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k) \\<and>\n  (j_to_jb_index n_as ?j = (bi - 1, li - k) \\<longrightarrow>\n   ?j < sum_list (map fst n_as) \\<longrightarrow> ?j = i - m - k)\n\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (i - m - k) = (bi - 1, li - k) &&& li \\<le> i - m", "by auto"], ["proof (state)\nthis:\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k)\n  li \\<le> i - m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from li"], ["proof (chain)\npicking this:\n  li \\<le> i - m", "have aim1: \"li \\<le> i\""], ["proof (prove)\nusing this:\n  li \\<le> i - m\n\ngoal (1 subgoal):\n 1. li \\<le> i", "by auto"], ["proof (state)\nthis:\n  li \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from li k i_large"], ["proof (chain)\npicking this:\n  li \\<le> i - m\n  k \\<le> li\n  \\<not> i < m", "have \"i - k \\<ge> m\""], ["proof (prove)\nusing this:\n  li \\<le> i - m\n  k \\<le> li\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. m \\<le> i - k", "by auto"], ["proof (state)\nthis:\n  m \\<le> i - k\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "hence aim2: \"j_to_jb_index (mb # n_as) (i - k) = (bi, li - k)\""], ["proof (prove)\nusing this:\n  m \\<le> i - k\n\ngoal (1 subgoal):\n 1. j_to_jb_index (mb # n_as) (i - k) = (bi, li - k)", "using IH1 bi"], ["proof (prove)\nusing this:\n  m \\<le> i - k\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k)\n  bi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j_to_jb_index (mb # n_as) (i - k) = (bi, li - k)", "by (auto simp: mb Let_def add.commute)"], ["proof (state)\nthis:\n  j_to_jb_index (mb # n_as) (i - k) = (bi, li - k)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "{"], ["proof (state)\nthis:\n  j_to_jb_index (mb # n_as) (i - k) = (bi, li - k)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "assume *: \"j_to_jb_index (mb # n_as) j = (bi, li - k)\"\n        \"j < sum_list (map fst (mb # n_as))\""], ["proof (state)\nthis:\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from * bi"], ["proof (chain)\npicking this:\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))\n  bi \\<noteq> 0", "have j: \"j \\<ge> m\""], ["proof (prove)\nusing this:\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))\n  bi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<le> j", "unfolding mb"], ["proof (prove)\nusing this:\n  j_to_jb_index ((m, b) # n_as) j = (bi, li - k)\n  j < sum_list (map fst ((m, b) # n_as))\n  bi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<le> j", "by (auto simp: Let_def split: if_splits)"], ["proof (state)\nthis:\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "let ?j = \"j - m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from j *"], ["proof (chain)\npicking this:\n  m \\<le> j\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))", "have jj: \"?j < sum_list (map fst n_as)\""], ["proof (prove)\nusing this:\n  m \\<le> j\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))\n\ngoal (1 subgoal):\n 1. j - m < sum_list (map fst n_as)", "unfolding mb"], ["proof (prove)\nusing this:\n  m \\<le> j\n  j_to_jb_index ((m, b) # n_as) j = (bi, li - k)\n  j < sum_list (map fst ((m, b) # n_as))\n\ngoal (1 subgoal):\n 1. j - m < sum_list (map fst n_as)", "by auto"], ["proof (state)\nthis:\n  j - m < sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from j *"], ["proof (chain)\npicking this:\n  m \\<le> j\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))", "have **: \"j_to_jb_index n_as (j - m) = (bi - 1, li - k)\""], ["proof (prove)\nusing this:\n  m \\<le> j\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))\n\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (j - m) = (bi - 1, li - k)", "using bi mb"], ["proof (prove)\nusing this:\n  m \\<le> j\n  j_to_jb_index (mb # n_as) j = (bi, li - k)\n  j < sum_list (map fst (mb # n_as))\n  bi \\<noteq> 0\n  mb = (m, b)\n\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (j - m) = (bi - 1, li - k)", "by (cases \"j_to_jb_index n_as (j - m)\", auto simp: Let_def)"], ["proof (state)\nthis:\n  j_to_jb_index n_as (j - m) = (bi - 1, li - k)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "from IH[of ?j] jj **"], ["proof (chain)\npicking this:\n  li \\<le> i - m \\<and>\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k) \\<and>\n  (j_to_jb_index n_as (j - m) = (bi - 1, li - k) \\<longrightarrow>\n   j - m < sum_list (map fst n_as) \\<longrightarrow> j - m = i - m - k)\n  j - m < sum_list (map fst n_as)\n  j_to_jb_index n_as (j - m) = (bi - 1, li - k)", "have \"j - m = i - m - k\""], ["proof (prove)\nusing this:\n  li \\<le> i - m \\<and>\n  j_to_jb_index n_as (i - m - k) = (bi - 1, li - k) \\<and>\n  (j_to_jb_index n_as (j - m) = (bi - 1, li - k) \\<longrightarrow>\n   j - m < sum_list (map fst n_as) \\<longrightarrow> j - m = i - m - k)\n  j - m < sum_list (map fst n_as)\n  j_to_jb_index n_as (j - m) = (bi - 1, li - k)\n\ngoal (1 subgoal):\n 1. j - m = i - m - k", "by auto"], ["proof (state)\nthis:\n  j - m = i - m - k\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "with j i_large k"], ["proof (chain)\npicking this:\n  m \\<le> j\n  \\<not> i < m\n  k \\<le> li\n  j - m = i - m - k", "have \"j = i - k\""], ["proof (prove)\nusing this:\n  m \\<le> j\n  \\<not> i < m\n  k \\<le> li\n  j - m = i - m - k\n\ngoal (1 subgoal):\n 1. j = i - k", "using \\<open>m \\<le> i - k\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> j\n  \\<not> i < m\n  k \\<le> li\n  j - m = i - m - k\n  m \\<le> i - k\n\ngoal (1 subgoal):\n 1. j = i - k", "by linarith"], ["proof (state)\nthis:\n  j = i - k\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>j_to_jb_index (mb # n_as) j = (bi, li - k);\n   j < sum_list (map fst (mb # n_as))\\<rbrakk>\n  \\<Longrightarrow> j = i - k\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "note aim3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>j_to_jb_index (mb # n_as) j = (bi, li - k);\n   j < sum_list (map fst (mb # n_as))\\<rbrakk>\n  \\<Longrightarrow> j = i - k\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "using aim1 aim2 aim3"], ["proof (prove)\nusing this:\n  li \\<le> i\n  j_to_jb_index (mb # n_as) (i - k) = (bi, li - k)\n  \\<lbrakk>j_to_jb_index (mb # n_as) j = (bi, li - k);\n   j < sum_list (map fst (mb # n_as))\\<rbrakk>\n  \\<Longrightarrow> j = i - k\n\ngoal (1 subgoal):\n 1. li \\<le> i \\<and>\n    j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n    (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n     j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)", "by blast"], ["proof (state)\nthis:\n  li \\<le> i \\<and>\n  j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n  (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n   j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  li \\<le> i \\<and>\n  j_to_jb_index (mb # n_as) (i - k) = (bi, li - k) \\<and>\n  (j_to_jb_index (mb # n_as) j = (bi, li - k) \\<longrightarrow>\n   j < sum_list (map fst (mb # n_as)) \\<longrightarrow> j = i - k)\n\ngoal (1 subgoal):\n 1. \\<And>i bi j.\n       \\<lbrakk>j_to_jb_index [] i = (bi, li);\n        i < sum_list (map fst [])\\<rbrakk>\n       \\<Longrightarrow> li \\<le> i \\<and>\n                         j_to_jb_index [] (i - k) = (bi, li - k) \\<and>\n                         (j_to_jb_index [] j =\n                          (bi, li - k) \\<longrightarrow>\n                          j < sum_list (map fst []) \\<longrightarrow>\n                          j = i - k)", "qed auto"], ["", "locale spectral_radius_1_jnf_max = \n  fixes A :: \"real mat\" and n m :: nat and lam :: complex and n_as\n  assumes A: \"A \\<in> carrier_mat n n\" \n  and nonneg: \"nonneg_mat A\" \n  and jnf: \"jordan_nf (map_mat complex_of_real A) n_as\" \n  and mem: \"(m, lam) \\<in> set n_as\" \n  and lam1: \"cmod lam = 1\"  \n  and sr1: \"\\<And>x. poly (char_poly A) x = 0 \\<Longrightarrow> x \\<le> 1\" \n  and max_block: \"\\<And> k la. (k,la) \\<in> set n_as \\<Longrightarrow> cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> m)\" \nbegin"], ["", "lemma n_as0: \"0 \\<notin> fst ` set n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` set n_as", "using jnf[unfolded jordan_nf_def]"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and>\n  similar_mat (of_real_hom.mat_hom A) (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` set n_as", ".."], ["", "lemma m0: \"m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "using mem n_as0"], ["proof (prove)\nusing this:\n  (m, lam) \\<in> set n_as\n  0 \\<notin> fst ` set n_as\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "by force"], ["", "abbreviation cA where \"cA \\<equiv> map_mat complex_of_real A\""], ["", "abbreviation J where \"J \\<equiv> jordan_matrix n_as\""], ["", "lemma sim_A_J: \"similar_mat cA J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (of_real_hom.mat_hom A) J", "using jnf[unfolded jordan_nf_def]"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat (of_real_hom.mat_hom A) J\n\ngoal (1 subgoal):\n 1. similar_mat (of_real_hom.mat_hom A) J", ".."], ["", "definition \"c = (\\<Prod>ia = 0..<m-1. (of_nat m :: real) - 1 - of_nat ia)\""], ["", "lemma c_gt_0: \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Prod>ia = 0..<m - 1. real m - 1 - real ia)", "by (rule prod_pos, auto)"], ["", "lemma c0: \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using c_gt_0"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["", "lemma c_int_def: \"c = (\\<Prod>ia = 0..<m-1. (of_nat m :: int) - 1 - of_nat ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = real_of_int (\\<Prod>ia = 0..<m - 1. int m - 1 - int ia)", "using c_def"], ["proof (prove)\nusing this:\n  c = (\\<Prod>ia = 0..<m - 1. real m - 1 - real ia)\n\ngoal (1 subgoal):\n 1. c = real_of_int (\\<Prod>ia = 0..<m - 1. int m - 1 - int ia)", "by auto"], ["", "lemma c_int: \"c \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> \\<int>", "using c_int_def Ints_of_int"], ["proof (prove)\nusing this:\n  c = real_of_int (\\<Prod>ia = 0..<m - 1. int m - 1 - int ia)\n  of_int ?z \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. c \\<in> \\<int>", "by metis"], ["", "lemma c_ge_1: \"c \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> c", "using c_gt_0"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. 1 \\<le> c", "unfolding c_int_def"], ["proof (prove)\nusing this:\n  0 < real_of_int (\\<Prod>ia = 0..<m - 1. int m - 1 - int ia)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real_of_int (\\<Prod>ia = 0..<m - 1. int m - 1 - int ia)", "by presburger"], ["", "definition PP where \"PP = (SOME PP. similar_mat_wit cA J (fst PP) (snd PP))\""], ["", "definition P where \"P = fst PP\""], ["", "definition iP where \"iP = snd PP\""], ["", "lemma JNF: \"P \\<in> carrier_mat n n\" \"iP \\<in> carrier_mat n n\" \"J \\<in> carrier_mat n n\"\n  \"P * iP = 1\\<^sub>m n\" \"iP * P = 1\\<^sub>m n\" \"cA = P * J * iP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n &&&\n     iP \\<in> carrier_mat n n &&& J \\<in> carrier_mat n n) &&&\n    P * iP = 1\\<^sub>m n &&&\n    iP * P = 1\\<^sub>m n &&& of_real_hom.mat_hom A = P * J * iP", "proof (atomize (full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "have n: \"n = dim_row cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = dim_row (of_real_hom.mat_hom A)", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. n = dim_row (of_real_hom.mat_hom A)", "by auto"], ["proof (state)\nthis:\n  n = dim_row (of_real_hom.mat_hom A)\n\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "from sim_A_J[unfolded similar_mat_def]"], ["proof (chain)\npicking this:\n  \\<exists>P. Ex (similar_mat_wit (of_real_hom.mat_hom A) J P)", "obtain Q iQ\n    where \"similar_mat_wit cA J Q iQ\""], ["proof (prove)\nusing this:\n  \\<exists>P. Ex (similar_mat_wit (of_real_hom.mat_hom A) J P)\n\ngoal (1 subgoal):\n 1. (\\<And>Q iQ.\n        similar_mat_wit (of_real_hom.mat_hom A) J Q iQ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit (of_real_hom.mat_hom A) J Q iQ\n\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "hence \"similar_mat_wit cA J (fst (Q,iQ)) (snd (Q,iQ))\""], ["proof (prove)\nusing this:\n  similar_mat_wit (of_real_hom.mat_hom A) J Q iQ\n\ngoal (1 subgoal):\n 1. similar_mat_wit (of_real_hom.mat_hom A) J (fst (Q, iQ)) (snd (Q, iQ))", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit (of_real_hom.mat_hom A) J (fst (Q, iQ)) (snd (Q, iQ))\n\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "hence \"similar_mat_wit cA J P iP\""], ["proof (prove)\nusing this:\n  similar_mat_wit (of_real_hom.mat_hom A) J (fst (Q, iQ)) (snd (Q, iQ))\n\ngoal (1 subgoal):\n 1. similar_mat_wit (of_real_hom.mat_hom A) J P iP", "unfolding PP_def iP_def P_def"], ["proof (prove)\nusing this:\n  similar_mat_wit (of_real_hom.mat_hom A) J (fst (Q, iQ)) (snd (Q, iQ))\n\ngoal (1 subgoal):\n 1. similar_mat_wit (of_real_hom.mat_hom A) J\n     (fst (SOME PP.\n              similar_mat_wit (of_real_hom.mat_hom A) J (fst PP) (snd PP)))\n     (snd (SOME PP.\n              similar_mat_wit (of_real_hom.mat_hom A) J (fst PP) (snd PP)))", "by (rule someI)"], ["proof (state)\nthis:\n  similar_mat_wit (of_real_hom.mat_hom A) J P iP\n\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "from similar_mat_witD[OF n this]"], ["proof (chain)\npicking this:\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n  of_real_hom.mat_hom A \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n", "show ?case"], ["proof (prove)\nusing this:\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n  of_real_hom.mat_hom A \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (P \\<in> carrier_mat n n \\<and>\n     iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n    P * iP = 1\\<^sub>m n \\<and>\n    iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP", "by auto"], ["proof (state)\nthis:\n  (P \\<in> carrier_mat n n \\<and>\n   iP \\<in> carrier_mat n n \\<and> J \\<in> carrier_mat n n) \\<and>\n  P * iP = 1\\<^sub>m n \\<and>\n  iP * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * iP\n\ngoal:\nNo subgoals!", "qed"], ["", "definition I :: \"nat set\" where\n  \"I = {i | i bi li nn la. i < n \\<and> j_to_jb_index n_as i = (bi, li) \n    \\<and> n_as ! bi = (nn,la) \\<and> cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\""], ["", "lemma sumlist_nf: \"sum_list (map fst n_as) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "have \"sum_list (map fst n_as) = dim_row (jordan_matrix n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = dim_row J", "by simp"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = dim_row J\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "also"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = dim_row J\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "have \"\\<dots> = dim_row cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row J = dim_row (of_real_hom.mat_hom A)", "using similar_matD[OF sim_A_J]"], ["proof (prove)\nusing this:\n  \\<exists>n P Q.\n     {of_real_hom.mat_hom A, J, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and> of_real_hom.mat_hom A = P * J * Q\n\ngoal (1 subgoal):\n 1. dim_row J = dim_row (of_real_hom.mat_hom A)", "by auto"], ["proof (state)\nthis:\n  dim_row J = dim_row (of_real_hom.mat_hom A)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "finally"], ["proof (chain)\npicking this:\n  sum_list (map fst n_as) = dim_row (of_real_hom.mat_hom A)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map fst n_as) = dim_row (of_real_hom.mat_hom A)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "using A"], ["proof (prove)\nusing this:\n  sum_list (map fst n_as) = dim_row (of_real_hom.mat_hom A)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "by auto"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma I_nonempty: \"I \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "from split_list[OF mem]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. n_as = ys @ (m, lam) # zs", "obtain as bs where n_as: \"n_as = as @ (m,lam) # bs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (m, lam) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        n_as = as @ (m, lam) # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n_as = as @ (m, lam) # bs\n\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "let ?i = \"sum_list (map fst as) + (m - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "have \"j_to_jb_index n_as ?i = (length as, m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j_to_jb_index n_as (sum_list (map fst as) + (m - 1)) =\n    (length as, m - 1)", "unfolding n_as"], ["proof (prove)\ngoal (1 subgoal):\n 1. j_to_jb_index (as @ (m, lam) # bs) (sum_list (map fst as) + (m - 1)) =\n    (length as, m - 1)", "by (induct as, insert m0, auto simp: Let_def)"], ["proof (state)\nthis:\n  j_to_jb_index n_as (sum_list (map fst as) + (m - 1)) = (length as, m - 1)\n\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "with lam1"], ["proof (chain)\npicking this:\n  cmod lam = 1\n  j_to_jb_index n_as (sum_list (map fst as) + (m - 1)) = (length as, m - 1)", "have \"?i \\<in> I\""], ["proof (prove)\nusing this:\n  cmod lam = 1\n  j_to_jb_index n_as (sum_list (map fst as) + (m - 1)) = (length as, m - 1)\n\ngoal (1 subgoal):\n 1. sum_list (map fst as) + (m - 1) \\<in> I", "unfolding I_def"], ["proof (prove)\nusing this:\n  cmod lam = 1\n  j_to_jb_index n_as (sum_list (map fst as) + (m - 1)) = (length as, m - 1)\n\ngoal (1 subgoal):\n 1. sum_list (map fst as) + (m - 1)\n    \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}", "unfolding sumlist_nf[symmetric] n_as"], ["proof (prove)\nusing this:\n  cmod lam = 1\n  j_to_jb_index (as @ (m, lam) # bs) (sum_list (map fst as) + (m - 1)) =\n  (length as, m - 1)\n\ngoal (1 subgoal):\n 1. sum_list (map fst as) + (m - 1)\n    \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < sum_list (map fst (as @ (m, lam) # bs)) \\<and>\n              j_to_jb_index (as @ (m, lam) # bs) i = (bi, li) \\<and>\n              (as @ (m, lam) # bs) ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}", "using m0"], ["proof (prove)\nusing this:\n  cmod lam = 1\n  j_to_jb_index (as @ (m, lam) # bs) (sum_list (map fst as) + (m - 1)) =\n  (length as, m - 1)\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum_list (map fst as) + (m - 1)\n    \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < sum_list (map fst (as @ (m, lam) # bs)) \\<and>\n              j_to_jb_index (as @ (m, lam) # bs) i = (bi, li) \\<and>\n              (as @ (m, lam) # bs) ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}", "by auto"], ["proof (state)\nthis:\n  sum_list (map fst as) + (m - 1) \\<in> I\n\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map fst as) + (m - 1) \\<in> I\n\ngoal (1 subgoal):\n 1. I \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  I \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma I_n: \"I \\<subseteq> {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> {..<n}", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>i bi li nn la.\n        uu_ = i \\<and>\n        i < n \\<and>\n        j_to_jb_index n_as i = (bi, li) \\<and>\n        n_as ! bi = (nn, la) \\<and>\n        cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n    \\<subseteq> {..<n}", "by auto"], ["", "lemma root_unity_cmod_1: assumes la: \"la \\<in> snd ` set n_as\" and 1: \"cmod la = 1\" \n  shows \"\\<exists> d. d \\<noteq> 0 \\<and> la ^ d = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "from la"], ["proof (chain)\npicking this:\n  la \\<in> snd ` set n_as", "obtain k where kla: \"(k,la) \\<in> set n_as\""], ["proof (prove)\nusing this:\n  la \\<in> snd ` set n_as\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (k, la) \\<in> set n_as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (k, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "from n_as0 kla"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as\n  (k, la) \\<in> set n_as", "have k0: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as\n  (k, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "from split_list[OF kla]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs", "obtain as bs where nas: \"n_as = as @ (k,la) # bs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        n_as = as @ (k, la) # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n_as = as @ (k, la) # bs\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "have rt: \"poly (char_poly cA) la = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom A)) la = 0", "using k0"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom A)) la = 0", "unfolding jordan_nf_char_poly[OF jnf] nas poly_prod_list prod_list_zero_iff"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> set (map (\\<lambda>p. poly p la)\n                  (map (\\<lambda>(n, a). [:- a, 1:] ^ n)\n                    (as @ (k, la) # bs)))", "by auto"], ["proof (state)\nthis:\n  poly (char_poly (of_real_hom.mat_hom A)) la = 0\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "obtain ks f where decomp: \"decompose_prod_root_unity (char_poly A) = (ks, f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ks f.\n        decompose_prod_root_unity (char_poly A) = (ks, f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  decompose_prod_root_unity (char_poly A) = (ks, f)\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "from sumlist_nf[unfolded nas] k0"], ["proof (chain)\npicking this:\n  sum_list (map fst (as @ (k, la) # bs)) = n\n  k \\<noteq> 0", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sum_list (map fst (as @ (k, la) # bs)) = n\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "note pf = perron_frobenius_for_complexity_jnf(1,7)[OF A n0 nonneg sr1 decomp, simplified]"], ["proof (state)\nthis:\n  0 \\<notin> set ks\n  \\<lbrakk>cmod ?x = 1;\n   poly (char_poly (of_real_hom.mat_hom A)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>set ks. ?x ^ k = 1\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "from pf(1) pf(2)[OF 1 rt]"], ["proof (chain)\npicking this:\n  0 \\<notin> set ks\n  \\<exists>k\\<in>set ks. la ^ k = 1", "show \"\\<exists> d. d \\<noteq> 0 \\<and> la ^ d = 1\""], ["proof (prove)\nusing this:\n  0 \\<notin> set ks\n  \\<exists>k\\<in>set ks. la ^ k = 1\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1", "by metis"], ["proof (state)\nthis:\n  \\<exists>d. d \\<noteq> 0 \\<and> la ^ d = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition d where \"d = (SOME d. \\<forall> la. la \\<in> snd ` set n_as \\<longrightarrow> cmod la = 1 \\<longrightarrow> \n  d la \\<noteq> 0 \\<and> la ^ (d la) = 1)\""], ["", "lemma d: assumes \"(k,la) \\<in> set n_as\" \"cmod la = 1\" \n  shows \"la ^ (d la) = 1 \\<and> d la \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "let ?P = \"\\<lambda> d. \\<forall> la. la \\<in> snd ` set n_as \\<longrightarrow> cmod la = 1 \\<longrightarrow> \n    d la \\<noteq> 0 \\<and> la ^ (d la) = 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "from root_unity_cmod_1"], ["proof (chain)\npicking this:\n  \\<lbrakk>?la \\<in> snd ` set n_as; cmod ?la = 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d. d \\<noteq> 0 \\<and> ?la ^ d = 1", "have \"\\<forall> la. \\<exists> d. la \\<in> snd ` set n_as \\<longrightarrow> cmod la = 1 \\<longrightarrow> \n    d \\<noteq> 0 \\<and> la ^ d = 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?la \\<in> snd ` set n_as; cmod ?la = 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d. d \\<noteq> 0 \\<and> ?la ^ d = 1\n\ngoal (1 subgoal):\n 1. \\<forall>la.\n       \\<exists>d.\n          la \\<in> snd ` set n_as \\<longrightarrow>\n          cmod la = 1 \\<longrightarrow> d \\<noteq> 0 \\<and> la ^ d = 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>la.\n     \\<exists>d.\n        la \\<in> snd ` set n_as \\<longrightarrow>\n        cmod la = 1 \\<longrightarrow> d \\<noteq> 0 \\<and> la ^ d = 1\n\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        x \\<in> snd ` set n_as \\<longrightarrow>\n        cmod x = 1 \\<longrightarrow> f x \\<noteq> 0 \\<and> x ^ f x = 1", "have \"\\<exists> d. ?P d\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        x \\<in> snd ` set n_as \\<longrightarrow>\n        cmod x = 1 \\<longrightarrow> f x \\<noteq> 0 \\<and> x ^ f x = 1\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       \\<forall>la.\n          la \\<in> snd ` set n_as \\<longrightarrow>\n          cmod la = 1 \\<longrightarrow> d la \\<noteq> 0 \\<and> la ^ d la = 1", "."], ["proof (state)\nthis:\n  \\<exists>d.\n     \\<forall>la.\n        la \\<in> snd ` set n_as \\<longrightarrow>\n        cmod la = 1 \\<longrightarrow> d la \\<noteq> 0 \\<and> la ^ d la = 1\n\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "from someI_ex[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>la.\n     la \\<in> snd ` set n_as \\<longrightarrow>\n     cmod la = 1 \\<longrightarrow>\n     (SOME x.\n         \\<forall>la.\n            la \\<in> snd ` set n_as \\<longrightarrow>\n            cmod la = 1 \\<longrightarrow>\n            x la \\<noteq> 0 \\<and> la ^ x la = 1)\n      la \\<noteq>\n     0 \\<and>\n     la ^\n     (SOME x.\n         \\<forall>la.\n            la \\<in> snd ` set n_as \\<longrightarrow>\n            cmod la = 1 \\<longrightarrow>\n            x la \\<noteq> 0 \\<and> la ^ x la = 1)\n      la =\n     1", "have \"?P d\""], ["proof (prove)\nusing this:\n  \\<forall>la.\n     la \\<in> snd ` set n_as \\<longrightarrow>\n     cmod la = 1 \\<longrightarrow>\n     (SOME x.\n         \\<forall>la.\n            la \\<in> snd ` set n_as \\<longrightarrow>\n            cmod la = 1 \\<longrightarrow>\n            x la \\<noteq> 0 \\<and> la ^ x la = 1)\n      la \\<noteq>\n     0 \\<and>\n     la ^\n     (SOME x.\n         \\<forall>la.\n            la \\<in> snd ` set n_as \\<longrightarrow>\n            cmod la = 1 \\<longrightarrow>\n            x la \\<noteq> 0 \\<and> la ^ x la = 1)\n      la =\n     1\n\ngoal (1 subgoal):\n 1. \\<forall>la.\n       la \\<in> snd ` set n_as \\<longrightarrow>\n       cmod la = 1 \\<longrightarrow> d la \\<noteq> 0 \\<and> la ^ d la = 1", "unfolding d_def"], ["proof (prove)\nusing this:\n  \\<forall>la.\n     la \\<in> snd ` set n_as \\<longrightarrow>\n     cmod la = 1 \\<longrightarrow>\n     (SOME x.\n         \\<forall>la.\n            la \\<in> snd ` set n_as \\<longrightarrow>\n            cmod la = 1 \\<longrightarrow>\n            x la \\<noteq> 0 \\<and> la ^ x la = 1)\n      la \\<noteq>\n     0 \\<and>\n     la ^\n     (SOME x.\n         \\<forall>la.\n            la \\<in> snd ` set n_as \\<longrightarrow>\n            cmod la = 1 \\<longrightarrow>\n            x la \\<noteq> 0 \\<and> la ^ x la = 1)\n      la =\n     1\n\ngoal (1 subgoal):\n 1. \\<forall>la.\n       la \\<in> snd ` set n_as \\<longrightarrow>\n       cmod la = 1 \\<longrightarrow>\n       (SOME d.\n           \\<forall>la.\n              la \\<in> snd ` set n_as \\<longrightarrow>\n              cmod la = 1 \\<longrightarrow>\n              d la \\<noteq> 0 \\<and> la ^ d la = 1)\n        la \\<noteq>\n       0 \\<and>\n       la ^\n       (SOME d.\n           \\<forall>la.\n              la \\<in> snd ` set n_as \\<longrightarrow>\n              cmod la = 1 \\<longrightarrow>\n              d la \\<noteq> 0 \\<and> la ^ d la = 1)\n        la =\n       1", "."], ["proof (state)\nthis:\n  \\<forall>la.\n     la \\<in> snd ` set n_as \\<longrightarrow>\n     cmod la = 1 \\<longrightarrow> d la \\<noteq> 0 \\<and> la ^ d la = 1\n\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "from this[rule_format, of la, OF _ assms(2)] assms(1)"], ["proof (chain)\npicking this:\n  la \\<in> snd ` set n_as \\<Longrightarrow>\n  d la \\<noteq> 0 \\<and> la ^ d la = 1\n  (k, la) \\<in> set n_as", "show ?thesis"], ["proof (prove)\nusing this:\n  la \\<in> snd ` set n_as \\<Longrightarrow>\n  d la \\<noteq> 0 \\<and> la ^ d la = 1\n  (k, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. la ^ d la = 1 \\<and> d la \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  la ^ d la = 1 \\<and> d la \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition D where \"D = prod_list (map (\\<lambda> na. if cmod (snd na) = 1 then d (snd na) else 1) n_as)\""], ["", "lemma D0: \"D \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<noteq> 0", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>na\\<leftarrow>n_as. if cmod (snd na) = 1 then d (snd na)\n                                else 1) \\<noteq>\n    0", "by (unfold prod_list_zero_iff, insert d, force)"], ["", "definition K where \"K off k = D * k + (m-1) + off\""], ["", "lemma mono_K: \"strict_mono (K off)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono (K off)", "unfolding strict_mono_def K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x < y \\<longrightarrow> D * x + (m - 1) + off < D * y + (m - 1) + off", "using D0"], ["proof (prove)\nusing this:\n  D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x < y \\<longrightarrow> D * x + (m - 1) + off < D * y + (m - 1) + off", "by auto"], ["", "definition C where \"C off k = (c / real (K off k) ^ (m - 1))\""], ["", "lemma limit_jordan_block: assumes kla: \"(k, la) \\<in> set n_as\"\n  and ij: \"i < k\" \"j < k\" \nshows \"(\\<lambda>N. (jordan_block k la ^\\<^sub>m (K off N)) $$ (i, j) * C off N)\n  \\<longlonglongrightarrow> (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la^off else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?c = \"of_nat :: nat \\<Rightarrow> complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?r = \"of_nat :: nat \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?cr = complex_of_real"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "from ij"], ["proof (chain)\npicking this:\n  i < k\n  j < k", "have k0: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i < k\n  j < k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "from jordan_nf_char_poly[OF jnf]"], ["proof (chain)\npicking this:\n  char_poly (of_real_hom.mat_hom A) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)", "have cA: \"char_poly cA = (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\""], ["proof (prove)\nusing this:\n  char_poly (of_real_hom.mat_hom A) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\n\ngoal (1 subgoal):\n 1. char_poly (of_real_hom.mat_hom A) =\n    (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)", "."], ["proof (state)\nthis:\n  char_poly (of_real_hom.mat_hom A) =\n  (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "from degree_monic_char_poly[OF A]"], ["proof (chain)\npicking this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1", "have \"degree (char_poly A) = n\""], ["proof (prove)\nusing this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n\ngoal (1 subgoal):\n 1. degree (char_poly A) = n", "by auto"], ["proof (state)\nthis:\n  degree (char_poly A) = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have deg: \"degree (char_poly cA) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (char_poly (of_real_hom.mat_hom A)) = n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. degree (char_poly (of_real_hom.mat_hom A)) = n", "by (simp add: degree_monic_char_poly)"], ["proof (state)\nthis:\n  degree (char_poly (of_real_hom.mat_hom A)) = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "from this[unfolded cA]"], ["proof (chain)\npicking this:\n  degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n) = n", "have \"n = degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\""], ["proof (prove)\nusing this:\n  degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n) = n\n\ngoal (1 subgoal):\n 1. n = degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)", "by auto"], ["proof (state)\nthis:\n  n = degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "also"], ["proof (state)\nthis:\n  n = degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"\\<dots> =  sum_list (map degree (map (\\<lambda>(n, a). [:- a, 1:] ^ n) n_as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n) =\n    sum_list (map degree (map (\\<lambda>(n, a). [:- a, 1:] ^ n) n_as))", "by (subst degree_prod_list_eq, auto)"], ["proof (state)\nthis:\n  degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n) =\n  sum_list (map degree (map (\\<lambda>(n, a). [:- a, 1:] ^ n) n_as))\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>(n, a)\\<leftarrow>n_as. [:- a, 1:] ^ n) =\n  sum_list (map degree (map (\\<lambda>(n, a). [:- a, 1:] ^ n) n_as))\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"\\<dots> = sum_list (map fst n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map degree (map (\\<lambda>(n, a). [:- a, 1:] ^ n) n_as)) =\n    sum_list (map fst n_as)", "by (rule arg_cong[of _ _ sum_list], auto simp: degree_linear_power)"], ["proof (state)\nthis:\n  sum_list (map degree (map (\\<lambda>(n, a). [:- a, 1:] ^ n) n_as)) =\n  sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "finally"], ["proof (chain)\npicking this:\n  n = sum_list (map fst n_as)", "have sum: \"sum_list (map fst n_as) = n\""], ["proof (prove)\nusing this:\n  n = sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "by auto"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "with split_list[OF kla] k0"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs\n  k \\<noteq> 0\n  sum_list (map fst n_as) = n", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs\n  k \\<noteq> 0\n  sum_list (map fst n_as) = n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "obtain ks f where decomp: \"decompose_prod_root_unity (char_poly A) = (ks, f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ks f.\n        decompose_prod_root_unity (char_poly A) = (ks, f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  decompose_prod_root_unity (char_poly A) = (ks, f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "note pf = perron_frobenius_for_complexity_jnf[OF A n0 nonneg sr1 decomp]"], ["proof (state)\nthis:\n  (\\<And>x.\n      poly (char_poly A) x = 0 \\<Longrightarrow>\n      poly (char_poly A) x = 0) \\<Longrightarrow>\n  0 \\<notin> set ks\n  (\\<And>x.\n      poly (char_poly A) x = 0 \\<Longrightarrow>\n      poly (char_poly A) x = 0) \\<Longrightarrow>\n  char_poly A = prod_root_unity ks * f\n  (\\<And>x.\n      poly (char_poly A) x = 0 \\<Longrightarrow>\n      poly (char_poly A) x = 0) \\<Longrightarrow>\n  char_poly (of_real_hom.mat_hom A) =\n  prod_root_unity ks * map_poly complex_of_real f\n  \\<lbrakk>\\<And>x.\n              poly (char_poly A) x = 0 \\<Longrightarrow>\n              poly (char_poly A) x = 0;\n   poly (char_poly (of_real_hom.mat_hom A)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> cmod ?x \\<le> 1\n  \\<lbrakk>\\<And>x.\n              poly (char_poly A) x = 0 \\<Longrightarrow>\n              poly (char_poly A) x = 0;\n   poly (map_poly complex_of_real f) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> cmod ?x < 1\n  \\<lbrakk>\\<And>x.\n              poly (char_poly A) x = 0 \\<Longrightarrow>\n              poly (char_poly A) x = 0;\n   cmod ?x = 1\\<rbrakk>\n  \\<Longrightarrow> Polynomial.order ?x\n                     (char_poly (of_real_hom.mat_hom A)) =\n                    length (filter (\\<lambda>k. ?x ^ k = 1) ks)\n  \\<lbrakk>\\<And>x.\n              poly (char_poly A) x = 0 \\<Longrightarrow>\n              poly (char_poly A) x = 0;\n   cmod ?x = 1; poly (char_poly (of_real_hom.mat_hom A)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>set ks. ?x ^ k = 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "define ji where \"ji = j - i\""], ["proof (state)\nthis:\n  ji = j - i\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?f = \"\\<lambda> N. (c / (?r N)^(m-1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?jb = \"\\<lambda> N. (jordan_block k la ^\\<^sub>m N) $$ (i,j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?jbc = \"\\<lambda> N. (jordan_block k la ^\\<^sub>m N) $$ (i,j) * ?f N\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "define e where \"e = (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la^off else 0)\""], ["proof (state)\nthis:\n  e =\n  (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n   else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?e1 = \"\\<lambda> N :: nat. (\\<Prod>ia = 0..<ji. (?c N - ?c ia) / ?c (ji - ia)) * la ^ (N - ji)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?e2 = \"\\<lambda> N. (\\<Prod>ia = 0..<ji. (?c N - ?c ia) / ?c (ji - ia)) * la ^ (N - ji) * (c / ((?c N^(m-1))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "define e2 where \"e2 = ?e2\""], ["proof (state)\nthis:\n  e2 =\n  (\\<lambda>N.\n      (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n      la ^ (N - ji) *\n      (complex_of_real c / of_nat N ^ (m - 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "let ?e3 = \"\\<lambda> N. (((\\<Prod>ia = 0..<ji. (?c N - ?c ia) / ?c (ji - ia))) * la ^ (N - ji)) * ?f N\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "assume ij': \"i \\<le> j\" and la0: \"la \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<le> j\n  la \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "{"], ["proof (state)\nthis:\n  i \\<le> j\n  la \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "fix N"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "assume \"N \\<ge> k\""], ["proof (state)\nthis:\n  k \\<le> N\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "with ij ij'"], ["proof (chain)\npicking this:\n  i < k\n  j < k\n  i \\<le> j\n  k \\<le> N", "have ji: \"j - i \\<le> N\" and id: \"N + i - j = N - ji\""], ["proof (prove)\nusing this:\n  i < k\n  j < k\n  i \\<le> j\n  k \\<le> N\n\ngoal (1 subgoal):\n 1. j - i \\<le> N &&& N + i - j = N - ji", "unfolding ji_def"], ["proof (prove)\nusing this:\n  i < k\n  j < k\n  i \\<le> j\n  k \\<le> N\n\ngoal (1 subgoal):\n 1. j - i \\<le> N &&& N + i - j = N - (j - i)", "by auto"], ["proof (state)\nthis:\n  j - i \\<le> N\n  N + i - j = N - ji\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"?jb N = (?c (N choose (j - i)) * la ^ (N + i - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n    of_nat (N choose (j - i)) * la ^ (N + i - j)", "unfolding jordan_block_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat k k\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (N choose (j - i)) * la ^ (N + i - j)\n         else 0) $$\n    (i, j) =\n    of_nat (N choose (j - i)) * la ^ (N + i - j)", "using ij ij'"], ["proof (prove)\nusing this:\n  i < k\n  j < k\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. Matrix.mat k k\n     (\\<lambda>(i, j).\n         if i \\<le> j then of_nat (N choose (j - i)) * la ^ (N + i - j)\n         else 0) $$\n    (i, j) =\n    of_nat (N choose (j - i)) * la ^ (N + i - j)", "by auto"], ["proof (state)\nthis:\n  (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n  of_nat (N choose (j - i)) * la ^ (N + i - j)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "also"], ["proof (state)\nthis:\n  (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n  of_nat (N choose (j - i)) * la ^ (N + i - j)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"\\<dots> = ?e1 N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (N choose (j - i)) * la ^ (N + i - j) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji)", "unfolding ji_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (N choose (j - i)) * la ^ (N + i - j) =\n    (\\<Prod>ia = 0..<j - i. (of_nat N - of_nat ia) / of_nat (j - i - ia)) *\n    la ^ (N - (j - i))", "unfolding binomial_altdef_of_nat[OF ji] id ji_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<j - i. of_nat (N - ia) / of_nat (j - i - ia)) *\n    la ^ (N - (j - i)) =\n    (\\<Prod>ia = 0..<j - i. (of_nat N - of_nat ia) / of_nat (j - i - ia)) *\n    la ^ (N - (j - i))", "proof (rule arg_cong[of _ _ \"\\<lambda> x. x * _\"], rule prod.cong[OF refl], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<j - i} \\<Longrightarrow>\n       of_nat (N - x) / of_nat (j - i - x) =\n       (of_nat N - of_nat x) / of_nat (j - i - x)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> {0..<j - i}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<j - i} \\<Longrightarrow>\n       of_nat (N - x) / of_nat (j - i - x) =\n       (of_nat N - of_nat x) / of_nat (j - i - x)", "hence \"x \\<le> N\""], ["proof (prove)\nusing this:\n  x \\<in> {0..<j - i}\n\ngoal (1 subgoal):\n 1. x \\<le> N", "using \\<open>N \\<ge> k\\<close> ij"], ["proof (prove)\nusing this:\n  x \\<in> {0..<j - i}\n  k \\<le> N\n  i < k\n  j < k\n\ngoal (1 subgoal):\n 1. x \\<le> N", "by auto"], ["proof (state)\nthis:\n  x \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<j - i} \\<Longrightarrow>\n       of_nat (N - x) / of_nat (j - i - x) =\n       (of_nat N - of_nat x) / of_nat (j - i - x)", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<le> N\n\ngoal (1 subgoal):\n 1. of_nat (N - x) / of_nat (j - i - x) =\n    (of_nat N - of_nat x) / of_nat (j - i - x)", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  of_nat (N - x) / of_nat (j - i - x) =\n  (of_nat N - of_nat x) / of_nat (j - i - x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (N choose (j - i)) * la ^ (N + i - j) =\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (N - ji)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "finally"], ["proof (chain)\npicking this:\n  (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (N - ji)", "have id: \"?jb N = ?e1 N\""], ["proof (prove)\nusing this:\n  (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (N - ji)\n\ngoal (1 subgoal):\n 1. (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji)", "."], ["proof (state)\nthis:\n  (jordan_block k la ^\\<^sub>m N) $$ (i, j) =\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (N - ji)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"?jbc N = e2 N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n    complex_of_real (c / real N ^ (m - 1)) =\n    e2 N", "unfolding id e2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    complex_of_real (c / real N ^ (m - 1)) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    (complex_of_real c / of_nat N ^ (m - 1))", "using c_gt_0"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    complex_of_real (c / real N ^ (m - 1)) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    (complex_of_real c / of_nat N ^ (m - 1))", "by (simp add: norm_mult norm_divide norm_power)"], ["proof (state)\nthis:\n  (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n  complex_of_real (c / real N ^ (m - 1)) =\n  e2 N\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "}"], ["proof (state)\nthis:\n  k \\<le> ?N2 \\<Longrightarrow>\n  (jordan_block k la ^\\<^sub>m ?N2) $$ (i, j) *\n  complex_of_real (c / real ?N2 ^ (m - 1)) =\n  e2 ?N2\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "note jbc = this"], ["proof (state)\nthis:\n  k \\<le> ?N2 \\<Longrightarrow>\n  (jordan_block k la ^\\<^sub>m ?N2) $$ (i, j) *\n  complex_of_real (c / real ?N2 ^ (m - 1)) =\n  e2 ?N2\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have e23: \"?e2 N = ?e3 N\" for N"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    (complex_of_real c / of_nat N ^ (m - 1)) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    complex_of_real (c / real N ^ (m - 1))", "using c_gt_0"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    (complex_of_real c / of_nat N ^ (m - 1)) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    complex_of_real (c / real N ^ (m - 1))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat ?N - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (?N - ji) *\n  (complex_of_real c / of_nat ?N ^ (m - 1)) =\n  (\\<Prod>ia = 0..<ji. (of_nat ?N - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (?N - ji) *\n  complex_of_real (c / real ?N ^ (m - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"(e2 o K off) \\<longlonglongrightarrow> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "proof (cases \"cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n 2. \\<not> (cmod la = 1 \\<and>\n            k = m \\<and> i = 0 \\<and> j = k - 1) \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "case False"], ["proof (state)\nthis:\n  \\<not> (cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1)\n\ngoal (2 subgoals):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n 2. \\<not> (cmod la = 1 \\<and>\n            k = m \\<and> i = 0 \\<and> j = k - 1) \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "then"], ["proof (chain)\npicking this:\n  \\<not> (cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1)", "consider (0) \"la = 0\" | (small) \"la \\<noteq> 0\" \"cmod la < 1\" | \n        (medium) \"cmod la = 1\" \"k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\""], ["proof (prove)\nusing this:\n  \\<not> (cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>la = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>cmod la = 1;\n      k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using max_block[OF kla]"], ["proof (prove)\nusing this:\n  \\<not> (cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1)\n  cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>la = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>cmod la = 1;\n      k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>la = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>cmod la = 1;\n    k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n 2. \\<not> (cmod la = 1 \\<and>\n            k = m \\<and> i = 0 \\<and> j = k - 1) \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "hence main: \"e2 \\<longlonglongrightarrow> e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>la = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>cmod la = 1;\n    k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. e2 \\<longlonglongrightarrow> e", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. la = 0 \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 3. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "case 0"], ["proof (state)\nthis:\n  la = 0\n\ngoal (3 subgoals):\n 1. la = 0 \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 3. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "hence e0: \"e = 0\""], ["proof (prove)\nusing this:\n  la = 0\n\ngoal (1 subgoal):\n 1. e = 0", "unfolding e_def"], ["proof (prove)\nusing this:\n  la = 0\n\ngoal (1 subgoal):\n 1. (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n     else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  e = 0\n\ngoal (3 subgoals):\n 1. la = 0 \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 3. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 \\<longlonglongrightarrow> e", "unfolding e0 0 LIMSEQ_iff e2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r>0.\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             cmod\n              ((\\<Prod>ia = 0..<ji.\n                   (of_nat n - of_nat ia) / of_nat (ji - ia)) *\n               0 ^ (n - ji) *\n               (complex_of_real c / of_nat n ^ (m - 1)) -\n               0)\n             < r", "proof (intro exI[of _ \"Suc ji\"] impI allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r n.\n       \\<lbrakk>0 < r; Suc ji \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cmod\n                          ((\\<Prod>ia = 0..<ji.\n                               (of_nat n - of_nat ia) / of_nat (ji - ia)) *\n                           0 ^ (n - ji) *\n                           (complex_of_real c / of_nat n ^ (m - 1)) -\n                           0)\n                         < r", "case (1 r n)"], ["proof (state)\nthis:\n  0 < r\n  Suc ji \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>r n.\n       \\<lbrakk>0 < r; Suc ji \\<le> n\\<rbrakk>\n       \\<Longrightarrow> cmod\n                          ((\\<Prod>ia = 0..<ji.\n                               (of_nat n - of_nat ia) / of_nat (ji - ia)) *\n                           0 ^ (n - ji) *\n                           (complex_of_real c / of_nat n ^ (m - 1)) -\n                           0)\n                         < r", "thus ?case"], ["proof (prove)\nusing this:\n  0 < r\n  Suc ji \\<le> n\n\ngoal (1 subgoal):\n 1. cmod\n     ((\\<Prod>ia = 0..<ji. (of_nat n - of_nat ia) / of_nat (ji - ia)) *\n      0 ^ (n - ji) *\n      (complex_of_real c / of_nat n ^ (m - 1)) -\n      0)\n    < r", "by (cases \"n - ji\", auto)"], ["proof (state)\nthis:\n  cmod\n   ((\\<Prod>ia = 0..<ji. (of_nat n - of_nat ia) / of_nat (ji - ia)) *\n    0 ^ (n - ji) *\n    (complex_of_real c / of_nat n ^ (m - 1)) -\n    0)\n  < r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e2 \\<longlonglongrightarrow> e\n\ngoal (2 subgoals):\n 1. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "case small"], ["proof (state)\nthis:\n  la \\<noteq> 0\n  cmod la < 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "have e0: \"e = 0 * (of_real (if m - 1 = 0 then c else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = 0 * complex_of_real (if m - 1 = 0 then c else 0)", "using small"], ["proof (prove)\nusing this:\n  la \\<noteq> 0\n  cmod la < 1\n\ngoal (1 subgoal):\n 1. e = 0 * complex_of_real (if m - 1 = 0 then c else 0)", "unfolding e_def"], ["proof (prove)\nusing this:\n  la \\<noteq> 0\n  cmod la < 1\n\ngoal (1 subgoal):\n 1. (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n     else 0) =\n    0 * complex_of_real (if m - 1 = 0 then c else 0)", "by auto"], ["proof (state)\nthis:\n  e = 0 * complex_of_real (if m - 1 = 0 then c else 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>la \\<noteq> 0; cmod la < 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e\n 2. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 \\<longlonglongrightarrow> e", "unfolding e0"], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 \\<longlonglongrightarrow> 0 *\n                                 complex_of_real\n                                  (if m - 1 = 0 then c else 0)", "unfolding e23 e2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (N - ji) *\n        complex_of_real (c / real N ^ (m - 1)))\n    \\<longlonglongrightarrow> 0 *\n                              complex_of_real (if m - 1 = 0 then c else 0)", "proof (rule tendsto_mult[OF _ tendsto_of_real])"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. c / real x ^ (m - 1))\n    \\<longlonglongrightarrow> (if m - 1 = 0 then c else 0)", "show \"(\\<lambda>x. c / real x ^ (m - 1)) \\<longlonglongrightarrow> (if m - 1 = 0 then c else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. c / real x ^ (m - 1))\n    \\<longlonglongrightarrow> (if m - 1 = 0 then c else 0)", "by (cases \"m - 1\"; real_asymp)"], ["proof (state)\nthis:\n  (\\<lambda>x. c / real x ^ (m - 1))\n  \\<longlonglongrightarrow> (if m - 1 = 0 then c else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "let ?laji = \"inverse (la^ji)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "let ?f = \"(\\<lambda>x. (\\<Prod>ia = 0..<ji. (?c x - ?c ia) / ?c (ji - ia)) * la ^ (x - ji))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "let ?g = \"\\<lambda>x. (\\<Prod>ia = 0..<ji. (1 - ?c ia * inverse (?c x)) / ?c (ji - ia)) * (((?c x)^ji * la ^ x) * ?laji)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "have fg: \"\\<forall>\\<^sub>F x in sequentially. ?f x = ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n       la ^ (x - ji) =\n       (\\<Prod>ia = 0..<ji.\n           (1 - of_nat ia * inverse (of_nat x)) / of_nat (ji - ia)) *\n       (of_nat x ^ ji * la ^ x * inverse (la ^ ji))", "apply (rule eventually_sequentiallyI[of \"Suc ji\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Suc ji \\<le> x \\<Longrightarrow>\n       (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n       la ^ (x - ji) =\n       (\\<Prod>ia = 0..<ji.\n           (1 - of_nat ia * inverse (of_nat x)) / of_nat (ji - ia)) *\n       (of_nat x ^ ji * la ^ x * inverse (la ^ ji))", "unfolding prod_pow[symmetric] prod.distrib[symmetric] mult.assoc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Suc ji \\<le> x \\<Longrightarrow>\n       (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n       (\\<Prod>i = 0..<x - ji. la) =\n       (\\<Prod>xa = 0..<ji.\n           (1 - of_nat xa * inverse (of_nat x)) / of_nat (ji - xa) *\n           of_nat x) *\n       (\\<Prod>i = 0..<x. la) *\n       inverse (\\<Prod>i = 0..<ji. la)", "unfolding prod_pow mult.assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Suc ji \\<le> x \\<Longrightarrow>\n       (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n       la ^ (x - ji) =\n       (\\<Prod>xa = 0..<ji.\n           (1 - of_nat xa * inverse (of_nat x)) / of_nat (ji - xa) *\n           of_nat x) *\n       (la ^ x * inverse (la ^ ji))", "by (rule arg_cong2[of _ _ _ _ \"(*)\"], rule prod.cong, auto simp: ring_distribs, \n              insert small, subst power_diff, auto simp: divide_inverse)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in sequentially.\n     (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n     la ^ (x - ji) =\n     (\\<Prod>ia = 0..<ji.\n         (1 - of_nat ia * inverse (of_nat x)) / of_nat (ji - ia)) *\n     (of_nat x ^ ji * la ^ x * inverse (la ^ ji))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "have 0: \"0 = (\\<Prod>ia = 0..<ji. (1 - of_nat ia * 0) / of_nat (ji - ia)) * (0 * ?laji)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    (\\<Prod>ia = 0..<ji. (1 - of_nat ia * 0) / of_nat (ji - ia)) *\n    (0 * inverse (la ^ ji))", "by simp"], ["proof (state)\nthis:\n  0 =\n  (\\<Prod>ia = 0..<ji. (1 - of_nat ia * 0) / of_nat (ji - ia)) *\n  (0 * inverse (la ^ ji))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "show \"?f \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n        la ^ (x - ji))\n    \\<longlonglongrightarrow> 0", "unfolding tendsto_cong[OF fg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji.\n            (1 - of_nat ia * inverse (of_nat x)) / of_nat (ji - ia)) *\n        (of_nat x ^ ji * la ^ x * inverse (la ^ ji)))\n    \\<longlonglongrightarrow> 0", "proof (subst 0, rule tendsto_mult[OF tendsto_prod tendsto_mult[OF _ tendsto_const]], \n              intro tendsto_intros inverse_of_nat_tendsto_zero)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow> of_nat (ji - ia) \\<noteq> 0\n 2. (\\<lambda>x. of_nat x ^ ji * la ^ x) \\<longlonglongrightarrow> 0", "show \"(\\<lambda>x. of_nat x ^ ji * la ^ x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_nat x ^ ji * la ^ x) \\<longlonglongrightarrow> 0", "by (rule poly_times_exp_tendsto_zero, insert small, auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. of_nat x ^ ji * la ^ x) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow> of_nat (ji - ia) \\<noteq> 0", "qed auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n      la ^ (x - ji))\n  \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e2 \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "case medium"], ["proof (state)\nthis:\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "with max_block[OF kla]"], ["proof (chain)\npicking this:\n  cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> m)\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1", "have \"k \\<le> m\" and 1: \"\\<And> x. cmod la ^ x = 1\""], ["proof (prove)\nusing this:\n  cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> m)\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n\ngoal (1 subgoal):\n 1. k \\<le> m &&& (\\<And>x. cmod la ^ x = 1)", "by auto"], ["proof (state)\nthis:\n  k \\<le> m\n  cmod la ^ ?x = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "with ij medium"], ["proof (chain)\npicking this:\n  i < k\n  j < k\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n  k \\<le> m\n  cmod la ^ ?x = 1", "have \"ji < m - 1\""], ["proof (prove)\nusing this:\n  i < k\n  j < k\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n  k \\<le> m\n  cmod la ^ ?x = 1\n\ngoal (1 subgoal):\n 1. ji < m - 1", "unfolding ji_def"], ["proof (prove)\nusing this:\n  i < k\n  j < k\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n  k \\<le> m\n  cmod la ^ ?x = 1\n\ngoal (1 subgoal):\n 1. j - i < m - 1", "by linarith"], ["proof (state)\nthis:\n  ji < m - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "then"], ["proof (chain)\npicking this:\n  ji < m - 1", "obtain d where m1: \"m - 1 = Suc d + ji\""], ["proof (prove)\nusing this:\n  ji < m - 1\n\ngoal (1 subgoal):\n 1. (\\<And>d. m - 1 = Suc d + ji \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_iff_Suc_add"], ["proof (prove)\nusing this:\n  ji < m - 1\n  (?m < ?n) = (\\<exists>k. ?n = Suc (?m + k))\n\ngoal (1 subgoal):\n 1. (\\<And>d. m - 1 = Suc d + ji \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m - 1 = Suc d + ji\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "have e0: \"e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = 0", "using medium"], ["proof (prove)\nusing this:\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n\ngoal (1 subgoal):\n 1. e = 0", "unfolding e_def"], ["proof (prove)\nusing this:\n  cmod la = 1\n  k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\n\ngoal (1 subgoal):\n 1. (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n     else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  e = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "have 0: \"0 = (\\<Prod>ia = 0..<ji. (1 - ?c ia * 0) / ?c (ji - ia)) * (of_real c) * 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    (\\<Prod>ia = 0..<ji. (1 - of_nat ia * 0) / of_nat (ji - ia)) *\n    complex_of_real c *\n    0", "by simp"], ["proof (state)\nthis:\n  0 =\n  (\\<Prod>ia = 0..<ji. (1 - of_nat ia * 0) / of_nat (ji - ia)) *\n  complex_of_real c *\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "let ?e = \"\\<lambda> ia N. if N = 0 then 0 else (1 - ?c ia / ?c N) / ?c (ji - ia)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "let ?f = \"\\<lambda> ia N. (1 - ?c ia * (1 / ?c N)) / ?c (ji - ia)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "fix N"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "have \"e2 N = ((\\<Prod>ia = 0..<ji. (?c N - ?c ia) / ?c (ji - ia)) / ?c N ^ ji) * la ^ (N - ji) * (of_real c / ?c N ^ Suc d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 N =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) /\n    of_nat N ^ ji *\n    la ^ (N - ji) *\n    (complex_of_real c / of_nat N ^ Suc d)", "unfolding medium m1 power_add e2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (N - ji) *\n    (complex_of_real c / (of_nat N ^ Suc d * of_nat N ^ ji)) =\n    (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) /\n    of_nat N ^ ji *\n    la ^ (N - ji) *\n    (complex_of_real c / of_nat N ^ Suc d)", "by simp"], ["proof (state)\nthis:\n  e2 N =\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) /\n  of_nat N ^ ji *\n  la ^ (N - ji) *\n  (complex_of_real c / of_nat N ^ Suc d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  e2 N =\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) /\n  of_nat N ^ ji *\n  la ^ (N - ji) *\n  (complex_of_real c / of_nat N ^ Suc d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "have \"(\\<Prod>ia = 0..<ji. (?c N - ?c ia) / ?c (ji - ia)) / ?c N ^ ji \n            = (\\<Prod>ia = 0..<ji. ?e ia N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) /\n    of_nat N ^ ji =\n    (\\<Prod>ia = 0..<ji.\n        if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia))", "unfolding prod_pow[symmetric] prod_dividef[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x = 0..<ji.\n        (of_nat N - of_nat x) / of_nat (ji - x) / of_nat N) =\n    (\\<Prod>ia = 0..<ji.\n        if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia))", "by (cases \"?c N = 0\", auto simp add: field_simps)"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat N - of_nat ia) / of_nat (ji - ia)) /\n  of_nat N ^ ji =\n  (\\<Prod>ia = 0..<ji.\n      if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "finally"], ["proof (chain)\npicking this:\n  e2 N =\n  (\\<Prod>ia = 0..<ji.\n      if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n  la ^ (N - ji) *\n  (complex_of_real c / of_nat N ^ Suc d)", "have \"e2 N = (\\<Prod>ia = 0..<ji. ?e ia N) * of_real c * inverse (?c N ^ Suc d) * la ^ (N - ji)\""], ["proof (prove)\nusing this:\n  e2 N =\n  (\\<Prod>ia = 0..<ji.\n      if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n  la ^ (N - ji) *\n  (complex_of_real c / of_nat N ^ Suc d)\n\ngoal (1 subgoal):\n 1. e2 N =\n    (\\<Prod>ia = 0..<ji.\n        if N = 0 then 0\n        else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat N ^ Suc d) *\n    la ^ (N - ji)", "by (simp add: divide_inverse)"], ["proof (state)\nthis:\n  e2 N =\n  (\\<Prod>ia = 0..<ji.\n      if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n  complex_of_real c *\n  inverse (of_nat N ^ Suc d) *\n  la ^ (N - ji)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  e2 N =\n  (\\<Prod>ia = 0..<ji.\n      if N = 0 then 0 else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n  complex_of_real c *\n  inverse (of_nat N ^ Suc d) *\n  la ^ (N - ji)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "have \"cmod \\<dots> = cmod ((\\<Prod>ia = 0..<ji. ?e ia N) * of_real c * (inverse (?c N ^ Suc d)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((\\<Prod>ia = 0..<ji.\n          if N = 0 then 0\n          else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n      complex_of_real c *\n      inverse (of_nat N ^ Suc d) *\n      la ^ (N - ji)) =\n    cmod\n     ((\\<Prod>ia = 0..<ji.\n          if N = 0 then 0\n          else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n      complex_of_real c *\n      inverse (of_nat N ^ Suc d))", "unfolding norm_mult norm_power 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (\\<Prod>ia = 0..<ji.\n         if N = 0 then 0\n         else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    cmod (complex_of_real c) *\n    cmod (inverse (of_nat N ^ Suc d)) *\n    1 =\n    cmod\n     (\\<Prod>ia = 0..<ji.\n         if N = 0 then 0\n         else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    cmod (complex_of_real c) *\n    cmod (inverse (of_nat N ^ Suc d))", "by simp"], ["proof (state)\nthis:\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if N = 0 then 0\n        else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat N ^ Suc d) *\n    la ^ (N - ji)) =\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if N = 0 then 0\n        else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat N ^ Suc d))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "finally"], ["proof (chain)\npicking this:\n  cmod (e2 N) =\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if N = 0 then 0\n        else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat N ^ Suc d))", "have \"cmod (e2 N) = cmod ((\\<Prod>ia = 0..<ji. ?e ia N) * of_real c * (inverse (?c N ^ Suc d)))\""], ["proof (prove)\nusing this:\n  cmod (e2 N) =\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if N = 0 then 0\n        else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat N ^ Suc d))\n\ngoal (1 subgoal):\n 1. cmod (e2 N) =\n    cmod\n     ((\\<Prod>ia = 0..<ji.\n          if N = 0 then 0\n          else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n      complex_of_real c *\n      inverse (of_nat N ^ Suc d))", "by simp"], ["proof (state)\nthis:\n  cmod (e2 N) =\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if N = 0 then 0\n        else (1 - of_nat ia / of_nat N) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat N ^ Suc d))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "}"], ["proof (state)\nthis:\n  cmod (e2 ?N2) =\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if ?N2 = 0 then 0\n        else (1 - of_nat ia / of_nat ?N2) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat ?N2 ^ Suc d))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "note e2 = this"], ["proof (state)\nthis:\n  cmod (e2 ?N2) =\n  cmod\n   ((\\<Prod>ia = 0..<ji.\n        if ?N2 = 0 then 0\n        else (1 - of_nat ia / of_nat ?N2) / of_nat (ji - ia)) *\n    complex_of_real c *\n    inverse (of_nat ?N2 ^ Suc d))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod la = 1;\n     k < m \\<or> i \\<noteq> 0 \\<or> j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> e2 \\<longlonglongrightarrow> e", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 \\<longlonglongrightarrow> e", "unfolding e0"], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 \\<longlonglongrightarrow> 0", "apply (rule tendsto_norm_zero_cancel, unfold e2, rule tendsto_norm_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji.\n            if x = 0 then 0\n            else (1 - of_nat ia / of_nat x) / of_nat (ji - ia)) *\n        complex_of_real c *\n        inverse (of_nat x ^ Suc d))\n    \\<longlonglongrightarrow> 0", "apply (subst (2) 0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<ji.\n            if x = 0 then 0\n            else (1 - of_nat ia / of_nat x) / of_nat (ji - ia)) *\n        complex_of_real c *\n        inverse (of_nat x ^ Suc d))\n    \\<longlonglongrightarrow> (\\<Prod>ia = 0..<ji.\n                                  (1 - of_nat ia * 0) / of_nat (ji - ia)) *\n                              complex_of_real c *\n                              0", "apply (rule tendsto_mult[OF tendsto_mult[OF tendsto_prod tendsto_const] inverse_power_tendsto_zero], goal_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow>\n       (\\<lambda>x.\n           if x = 0 then 0\n           else (1 - of_nat ia / of_nat x) / of_nat (ji - ia))\n       \\<longlonglongrightarrow> (1 - of_nat ia * 0) / of_nat (ji - ia)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow>\n       (\\<lambda>x.\n           if x = 0 then 0\n           else (1 - of_nat ia / of_nat x) / of_nat (ji - ia))\n       \\<longlonglongrightarrow> (1 - of_nat ia * 0) / of_nat (ji - ia)", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> {0..<ji}\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow>\n       (\\<lambda>x.\n           if x = 0 then 0\n           else (1 - of_nat ia / of_nat x) / of_nat (ji - ia))\n       \\<longlonglongrightarrow> (1 - of_nat ia * 0) / of_nat (ji - ia)", "let ?g = \"\\<lambda> x. (1 - ?c i * (1 / of_nat x)) / of_nat (ji - i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow>\n       (\\<lambda>x.\n           if x = 0 then 0\n           else (1 - of_nat ia / of_nat x) / of_nat (ji - ia))\n       \\<longlonglongrightarrow> (1 - of_nat ia * 0) / of_nat (ji - ia)", "have eq: \"\\<forall>\\<^sub>F x in sequentially. ?e i x = ?g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       (if x = 0 then 0 else (1 - of_nat i / of_nat x) / of_nat (ji - i)) =\n       (1 - of_nat i * (1 / of_nat x)) / of_nat (ji - i)", "by (rule eventually_sequentiallyI[of 1], auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in sequentially.\n     (if x = 0 then 0 else (1 - of_nat i / of_nat x) / of_nat (ji - i)) =\n     (1 - of_nat i * (1 / of_nat x)) / of_nat (ji - i)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {0..<ji} \\<Longrightarrow>\n       (\\<lambda>x.\n           if x = 0 then 0\n           else (1 - of_nat ia / of_nat x) / of_nat (ji - ia))\n       \\<longlonglongrightarrow> (1 - of_nat ia * 0) / of_nat (ji - ia)", "show \"?e i \\<longlonglongrightarrow> (1 - ?c i * 0) / ?c (ji - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        if N = 0 then 0 else (1 - of_nat i / of_nat N) / of_nat (ji - i))\n    \\<longlonglongrightarrow> (1 - of_nat i * 0) / of_nat (ji - i)", "unfolding tendsto_cong[OF eq]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N. (1 - of_nat i * (1 / of_nat N)) / of_nat (ji - i))\n    \\<longlonglongrightarrow> (1 - of_nat i * 0) / of_nat (ji - i)", "using 1"], ["proof (prove)\nusing this:\n  i \\<in> {0..<ji}\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. (1 - of_nat i * (1 / of_nat N)) / of_nat (ji - i))\n    \\<longlonglongrightarrow> (1 - of_nat i * 0) / of_nat (ji - i)", "by (intro tendsto_intros lim_1_over_n, auto)"], ["proof (state)\nthis:\n  (\\<lambda>N.\n      if N = 0 then 0 else (1 - of_nat i / of_nat N) / of_nat (ji - i))\n  \\<longlonglongrightarrow> (1 - of_nat i * 0) / of_nat (ji - i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e2 \\<longlonglongrightarrow> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e2 \\<longlonglongrightarrow> e\n\ngoal (2 subgoals):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n 2. \\<not> (cmod la = 1 \\<and>\n            k = m \\<and> i = 0 \\<and> j = k - 1) \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "show \"(e2 o K off) \\<longlonglongrightarrow> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "by (rule LIMSEQ_subseq_LIMSEQ[OF main mono_K])"], ["proof (state)\nthis:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "case True"], ["proof (state)\nthis:\n  cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "hence large: \"cmod la = 1\" \"k = m\" \"i = 0\" \"j = k - 1\""], ["proof (prove)\nusing this:\n  cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1\n\ngoal (1 subgoal):\n 1. (cmod la = 1 &&& k = m) &&& i = 0 &&& j = k - 1", "by auto"], ["proof (state)\nthis:\n  cmod la = 1\n  k = m\n  i = 0\n  j = k - 1\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "hence e: \"e = la^off\""], ["proof (prove)\nusing this:\n  cmod la = 1\n  k = m\n  i = 0\n  j = k - 1\n\ngoal (1 subgoal):\n 1. e = la ^ off", "unfolding e_def"], ["proof (prove)\nusing this:\n  cmod la = 1\n  k = m\n  i = 0\n  j = k - 1\n\ngoal (1 subgoal):\n 1. (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n     else 0) =\n    la ^ off", "by auto"], ["proof (state)\nthis:\n  e = la ^ off\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "from large k0"], ["proof (chain)\npicking this:\n  cmod la = 1\n  k = m\n  i = 0\n  j = k - 1\n  k \\<noteq> 0", "have m0: \"m \\<ge> 1\""], ["proof (prove)\nusing this:\n  cmod la = 1\n  k = m\n  i = 0\n  j = k - 1\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> m", "by auto"], ["proof (state)\nthis:\n  1 \\<le> m\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "define m1 where \"m1 = m - 1\""], ["proof (state)\nthis:\n  m1 = m - 1\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have id: \"(real (m - 1) - real ia) = ?r m - 1 - ?r ia\" for ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (m - 1) - real ia = real m - 1 - real ia", "using m0"], ["proof (prove)\nusing this:\n  1 \\<le> m\n\ngoal (1 subgoal):\n 1. real (m - 1) - real ia = real m - 1 - real ia", "unfolding m1_def"], ["proof (prove)\nusing this:\n  1 \\<le> m\n\ngoal (1 subgoal):\n 1. real (m - 1) - real ia = real m - 1 - real ia", "by auto"], ["proof (state)\nthis:\n  real (m - 1) - real ?ia = real m - 1 - real ?ia\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "let ?e4 = \"\\<lambda> x. (\\<Prod>ia = 0..<m1. 1 - ?cr (?r ia / x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "fix x :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "assume x: \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"?e2 x = ((\\<Prod>ia = 0..<m1. (?c x - ?c ia) / ?c (m1 - ia)) *\n            (\\<Prod>ia = 0..<m1. ?cr (real m1 - real ia))) /\n            (\\<Prod>i = 0..<m1. ?c x) * la ^ (x - (m-1))\" (is \"_ = ?A / ?B * ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (x - ji) *\n    (complex_of_real c / of_nat x ^ (m - 1)) =\n    (\\<Prod>ia = 0..<m1. (of_nat x - of_nat ia) / of_nat (m1 - ia)) *\n    (\\<Prod>ia = 0..<m1. complex_of_real (real m1 - real ia)) /\n    (\\<Prod>i = 0..<m1. of_nat x) *\n    la ^ (x - (m - 1))", "unfolding m1_def ji_def large c_def prod_pow[symmetric] id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<m - 1 - 0.\n        (of_nat x - of_nat ia) / of_nat (m - 1 - 0 - ia)) *\n    (\\<Prod>i = 0..<x - (m - 1 - 0). la) *\n    (complex_of_real (\\<Prod>ia = 0..<m - 1. real m - 1 - real ia) /\n     (\\<Prod>i = 0..<m - 1. of_nat x)) =\n    (\\<Prod>ia = 0..<m - 1. (of_nat x - of_nat ia) / of_nat (m - 1 - ia)) *\n    (\\<Prod>ia = 0..<m - 1. complex_of_real (real m - 1 - real ia)) /\n    (\\<Prod>i = 0..<m - 1. of_nat x) *\n    (\\<Prod>i = 0..<x - (m - 1). la)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (x - ji) *\n  (complex_of_real c / of_nat x ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. (of_nat x - of_nat ia) / of_nat (m1 - ia)) *\n  (\\<Prod>ia = 0..<m1. complex_of_real (real m1 - real ia)) /\n  (\\<Prod>i = 0..<m1. of_nat x) *\n  la ^ (x - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (x - ji) *\n  (complex_of_real c / of_nat x ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. (of_nat x - of_nat ia) / of_nat (m1 - ia)) *\n  (\\<Prod>ia = 0..<m1. complex_of_real (real m1 - real ia)) /\n  (\\<Prod>i = 0..<m1. of_nat x) *\n  la ^ (x - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"?A = (\\<Prod>ia = 0..<m1. (?cr x - ?c ia))\" (is \"_ = ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<m1. (of_nat x - of_nat ia) / of_nat (m1 - ia)) *\n    (\\<Prod>ia = 0..<m1. complex_of_real (real m1 - real ia)) =\n    (\\<Prod>ia = 0..<m1. complex_of_real (real x) - of_nat ia)", "unfolding prod.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>xa = 0..<m1.\n        (of_nat x - of_nat xa) / of_nat (m1 - xa) *\n        complex_of_real (real m1 - real xa)) =\n    (\\<Prod>ia = 0..<m1. complex_of_real (real x) - of_nat ia)", "by (rule prod.cong[OF refl], subst of_nat_diff, auto)"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<m1. (of_nat x - of_nat ia) / of_nat (m1 - ia)) *\n  (\\<Prod>ia = 0..<m1. complex_of_real (real m1 - real ia)) =\n  (\\<Prod>ia = 0..<m1. complex_of_real (real x) - of_nat ia)\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<m1. (of_nat x - of_nat ia) / of_nat (m1 - ia)) *\n  (\\<Prod>ia = 0..<m1. complex_of_real (real m1 - real ia)) =\n  (\\<Prod>ia = 0..<m1. complex_of_real (real x) - of_nat ia)\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"?A / ?B = (\\<Prod>ia = 0..<m1. 1 - ?cr (?r ia / x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<m1. complex_of_real (real x) - of_nat ia) /\n    (\\<Prod>i = 0..<m1. of_nat x) =\n    (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x))", "unfolding prod_dividef[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>xa = 0..<m1.\n        (complex_of_real (real x) - of_nat xa) / of_nat x) =\n    (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x))", "by (rule prod.cong[OF refl], insert x, auto simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<m1. complex_of_real (real x) - of_nat ia) /\n  (\\<Prod>i = 0..<m1. of_nat x) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (x - ji) *\n  (complex_of_real c / of_nat x ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) *\n  la ^ (x - (m - 1))", "have \"?e2 x = ?e4 x * ?C\""], ["proof (prove)\nusing this:\n  (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (x - ji) *\n  (complex_of_real c / of_nat x ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) *\n  la ^ (x - (m - 1))\n\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (x - ji) *\n    (complex_of_real c / of_nat x ^ (m - 1)) =\n    (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) *\n    la ^ (x - (m - 1))", "."], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat x - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (x - ji) *\n  (complex_of_real c / of_nat x ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) *\n  la ^ (x - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "}"], ["proof (state)\nthis:\n  ?x2 \\<noteq> 0 \\<Longrightarrow>\n  (\\<Prod>ia = 0..<ji. (of_nat ?x2 - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (?x2 - ji) *\n  (complex_of_real c / of_nat ?x2 ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real ?x2)) *\n  la ^ (?x2 - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "note main = this"], ["proof (state)\nthis:\n  ?x2 \\<noteq> 0 \\<Longrightarrow>\n  (\\<Prod>ia = 0..<ji. (of_nat ?x2 - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (?x2 - ji) *\n  (complex_of_real c / of_nat ?x2 ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real ?x2)) *\n  la ^ (?x2 - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "from d[OF kla large(1)]"], ["proof (chain)\npicking this:\n  la ^ d la = 1 \\<and> d la \\<noteq> 0", "have 1: \"la ^ d la = 1\""], ["proof (prove)\nusing this:\n  la ^ d la = 1 \\<and> d la \\<noteq> 0\n\ngoal (1 subgoal):\n 1. la ^ d la = 1", "by auto"], ["proof (state)\nthis:\n  la ^ d la = 1\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "from split_list[OF kla]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs", "obtain as bs where n_as: \"n_as = as @ (k,la) # bs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        n_as = as @ (k, la) # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n_as = as @ (k, la) # bs\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "obtain C where D: \"D = d la * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C. D = d la * C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<Prod>na\\<leftarrow>n_as. if cmod (snd na) = 1 then d (snd na)\n                                    else 1) =\n        d la * C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_as"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<Prod>na\\<leftarrow>as @\n                              (k, la) #\n                              bs. if cmod (snd na) = 1\n                                  then spectral_radius_1_jnf_max.d\n  (as @ (k, la) # bs) (snd na)\n                                  else 1) =\n        spectral_radius_1_jnf_max.d (as @ (k, la) # bs) la *\n        C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using large"], ["proof (prove)\nusing this:\n  cmod la = 1\n  k = m\n  i = 0\n  j = k - 1\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<Prod>na\\<leftarrow>as @\n                              (k, la) #\n                              bs. if cmod (snd na) = 1\n                                  then spectral_radius_1_jnf_max.d\n  (as @ (k, la) # bs) (snd na)\n                                  else 1) =\n        spectral_radius_1_jnf_max.d (as @ (k, la) # bs) la *\n        C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D = d la * C\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"(\\<lambda> x. ?e4 x * e) \\<longlonglongrightarrow> (\\<Prod>ia = 0..<m1. 1 - ?cr 0) * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n    \\<longlonglongrightarrow> (\\<Prod>ia = 0..<m1. 1 - complex_of_real 0) *\n                              e", "by (intro tendsto_intros real_tendsto_divide_at_top, auto simp: filterlim_real_sequentially)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n  \\<longlonglongrightarrow> (\\<Prod>ia = 0..<m1. 1 - complex_of_real 0) * e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n  \\<longlonglongrightarrow> (\\<Prod>ia = 0..<m1. 1 - complex_of_real 0) * e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"(\\<Prod>ia = 0..<m1. 1 - ?cr 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<m1. 1 - complex_of_real 0) = 1", "unfolding e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<m1. 1 - complex_of_real 0) = 1", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real 0) = 1\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n  \\<longlonglongrightarrow> 1 * e", "have \"(\\<lambda> x. ?e4 x * e)  \\<longlonglongrightarrow> e\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n  \\<longlonglongrightarrow> 1 * e\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n    \\<longlonglongrightarrow> e", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) * e)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "from LIMSEQ_subseq_LIMSEQ[OF this mono_K]"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) *\n       e) \\<circ>\n   K ?off1)\n  \\<longlonglongrightarrow> e", "have e4: \"(\\<lambda> k. (?e4 o K off) k * e) \\<longlonglongrightarrow> e\" (is \"?A \\<longlonglongrightarrow> e\")"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real x)) *\n       e) \\<circ>\n   K ?off1)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        ((\\<lambda>x.\n             \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n         (\\<lambda>x. real (K off x)))\n         k *\n        e)\n    \\<longlonglongrightarrow> e", "by (auto simp: o_def)"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      ((\\<lambda>x.\n           \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n       (\\<lambda>x. real (K off x)))\n       k *\n      e)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "{"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      ((\\<lambda>x.\n           \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n       (\\<lambda>x. real (K off x)))\n       k *\n      e)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "assume k: \"k \\<noteq> 0\""], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "hence 0: \"K off k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. K off k \\<noteq> 0", "unfolding K_def"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. D * k + (m - 1) + off \\<noteq> 0", "using D0"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. D * k + (m - 1) + off \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  K off k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"?e2 (K off k) = ?e4 (K off k) * la^(K off k - (m-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji.\n        (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (K off k - ji) *\n    (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n    (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) *\n    la ^ (K off k - (m - 1))", "unfolding main[OF 0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) *\n    la ^ (K off k - (m - 1)) =\n    (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) *\n    la ^ (K off k - (m - 1))", ".."], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (K off k - ji) *\n  (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) *\n  la ^ (K off k - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  (\\<Prod>ia = 0..<ji. (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (K off k - ji) *\n  (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) *\n  la ^ (K off k - (m - 1))\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"K off k - (m-1) = D * k + off\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K off k - (m - 1) = D * k + off", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D * k + (m - 1) + off - (m - 1) = D * k + off", "by simp"], ["proof (state)\nthis:\n  K off k - (m - 1) = D * k + off\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "also"], ["proof (state)\nthis:\n  K off k - (m - 1) = D * k + off\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have \"la ^ \\<dots> = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. la ^ (D * k + off) = e", "unfolding e power_add D power_mult 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 ^ C) ^ k * la ^ off = la ^ off", "by auto"], ["proof (state)\nthis:\n  la ^ (D * k + off) = e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>ia = 0..<ji. (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (K off k - ji) *\n  (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) * e", "have \"e2 (K off k) = (?e4 o K off) k * e\""], ["proof (prove)\nusing this:\n  (\\<Prod>ia = 0..<ji. (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (K off k - ji) *\n  (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) * e\n\ngoal (1 subgoal):\n 1. e2 (K off k) =\n    ((\\<lambda>x.\n         \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n     (\\<lambda>x. real (K off x)))\n     k *\n    e", "unfolding o_def e2_def"], ["proof (prove)\nusing this:\n  (\\<Prod>ia = 0..<ji. (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n  la ^ (K off k - ji) *\n  (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n  (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) * e\n\ngoal (1 subgoal):\n 1. (\\<Prod>ia = 0..<ji.\n        (of_nat (K off k) - of_nat ia) / of_nat (ji - ia)) *\n    la ^ (K off k - ji) *\n    (complex_of_real c / of_nat (K off k) ^ (m - 1)) =\n    (\\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / real (K off k))) * e", "."], ["proof (state)\nthis:\n  e2 (K off k) =\n  ((\\<lambda>x.\n       \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n   (\\<lambda>x. real (K off x)))\n   k *\n  e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "}"], ["proof (state)\nthis:\n  ?ka2 \\<noteq> 0 \\<Longrightarrow>\n  e2 (K off ?ka2) =\n  ((\\<lambda>x.\n       \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n   (\\<lambda>x. real (K off x)))\n   ?ka2 *\n  e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "note main = this"], ["proof (state)\nthis:\n  ?ka2 \\<noteq> 0 \\<Longrightarrow>\n  e2 (K off ?ka2) =\n  ((\\<lambda>x.\n       \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n   (\\<lambda>x. real (K off x)))\n   ?ka2 *\n  e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "have id: \"(?A \\<longlonglongrightarrow> e) = ((e2 o K off) \\<longlonglongrightarrow> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        ((\\<lambda>x.\n             \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n         (\\<lambda>x. real (K off x)))\n         k *\n        e)\n    \\<longlonglongrightarrow> e =\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "by (rule tendsto_cong, unfold eventually_at_top_linorder, \n            rule exI[of _ 1], insert main, auto)"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      ((\\<lambda>x.\n           \\<Prod>ia = 0..<m1. 1 - complex_of_real (real ia / x)) \\<circ>\n       (\\<lambda>x. real (K off x)))\n       k *\n      e)\n  \\<longlonglongrightarrow> e =\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<and> k = m \\<and> i = 0 \\<and> j = k - 1 \\<Longrightarrow>\n    (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "from e4[unfolded id]"], ["proof (chain)\npicking this:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "show ?thesis"], ["proof (prove)\nusing this:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (e2 \\<circ> K off) \\<longlonglongrightarrow> e", "."], ["proof (state)\nthis:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "also"], ["proof (state)\nthis:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"((e2 o K off) \\<longlonglongrightarrow> e) = ((?jbc o K off)  \\<longlonglongrightarrow> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e2 \\<circ> K off) \\<longlonglongrightarrow> e =\n    ((\\<lambda>N.\n         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n     K off)\n    \\<longlonglongrightarrow> e", "proof (rule tendsto_cong, unfold eventually_at_top_linorder, rule exI[of _ k], \n        intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       k \\<le> n \\<Longrightarrow>\n       (e2 \\<circ> K off) n =\n       ((\\<lambda>N.\n            (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n            complex_of_real (c / real N ^ (m - 1))) \\<circ>\n        K off)\n        n", "case (1 n)"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       k \\<le> n \\<Longrightarrow>\n       (e2 \\<circ> K off) n =\n       ((\\<lambda>N.\n            (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n            complex_of_real (c / real N ^ (m - 1))) \\<circ>\n        K off)\n        n", "from mono_K[of off] 1"], ["proof (chain)\npicking this:\n  strict_mono (K off)\n  k \\<le> n", "have \"K off n \\<ge> k\""], ["proof (prove)\nusing this:\n  strict_mono (K off)\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. k \\<le> K off n", "using le_trans seq_suble"], ["proof (prove)\nusing this:\n  strict_mono (K off)\n  k \\<le> n\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n  strict_mono ?f \\<Longrightarrow> ?n \\<le> ?f ?n\n\ngoal (1 subgoal):\n 1. k \\<le> K off n", "by blast"], ["proof (state)\nthis:\n  k \\<le> K off n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       k \\<le> n \\<Longrightarrow>\n       (e2 \\<circ> K off) n =\n       ((\\<lambda>N.\n            (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n            complex_of_real (c / real N ^ (m - 1))) \\<circ>\n        K off)\n        n", "from jbc[OF this]"], ["proof (chain)\npicking this:\n  (jordan_block k la ^\\<^sub>m K off n) $$ (i, j) *\n  complex_of_real (c / real (K off n) ^ (m - 1)) =\n  e2 (K off n)", "show ?case"], ["proof (prove)\nusing this:\n  (jordan_block k la ^\\<^sub>m K off n) $$ (i, j) *\n  complex_of_real (c / real (K off n) ^ (m - 1)) =\n  e2 (K off n)\n\ngoal (1 subgoal):\n 1. (e2 \\<circ> K off) n =\n    ((\\<lambda>N.\n         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n     K off)\n     n", "by (simp add: o_def)"], ["proof (state)\nthis:\n  (e2 \\<circ> K off) n =\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n   n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (e2 \\<circ> K off) \\<longlonglongrightarrow> e =\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e", "have \"(?jbc o K off) \\<longlonglongrightarrow> e\""], ["proof (prove)\nusing this:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. ((\\<lambda>N.\n         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n     K off)\n    \\<longlonglongrightarrow> e", "."], ["proof (state)\nthis:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; la \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>N.\n                         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n                         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n                     K off)\n                    \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "note part1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; la \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>N.\n                         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n                         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n                     K off)\n                    \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; la \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>N.\n                         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n                         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n                     K off)\n                    \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "assume \"i > j \\<or> la = 0\""], ["proof (state)\nthis:\n  j < i \\<or> la = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "hence e: \"e = 0\" and jbn: \"N \\<ge> k \\<Longrightarrow> ?jbc N = 0\" for N"], ["proof (prove)\nusing this:\n  j < i \\<or> la = 0\n\ngoal (1 subgoal):\n 1. e = 0 &&&\n    (k \\<le> N \\<Longrightarrow>\n     (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n     complex_of_real (c / real N ^ (m - 1)) =\n     0)", "unfolding jordan_block_pow e_def"], ["proof (prove)\nusing this:\n  j < i \\<or> la = 0\n\ngoal (1 subgoal):\n 1. (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n     else 0) =\n    0 &&&\n    (k \\<le> N \\<Longrightarrow>\n     Matrix.mat k k\n      (\\<lambda>(i, j).\n          if i \\<le> j then of_nat (N choose (j - i)) * la ^ (N + i - j)\n          else 0) $$\n     (i, j) *\n     complex_of_real (c / real N ^ (m - 1)) =\n     0)", "using ij"], ["proof (prove)\nusing this:\n  j < i \\<or> la = 0\n  i < k\n  j < k\n\ngoal (1 subgoal):\n 1. (if i = 0 \\<and> j = k - 1 \\<and> cmod la = 1 \\<and> k = m then la ^ off\n     else 0) =\n    0 &&&\n    (k \\<le> N \\<Longrightarrow>\n     Matrix.mat k k\n      (\\<lambda>(i, j).\n          if i \\<le> j then of_nat (N choose (j - i)) * la ^ (N + i - j)\n          else 0) $$\n     (i, j) *\n     complex_of_real (c / real N ^ (m - 1)) =\n     0)", "by auto"], ["proof (state)\nthis:\n  e = 0\n  k \\<le> ?N \\<Longrightarrow>\n  (jordan_block k la ^\\<^sub>m ?N) $$ (i, j) *\n  complex_of_real (c / real ?N ^ (m - 1)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "have \"?jbc \\<longlonglongrightarrow> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n        complex_of_real (c / real N ^ (m - 1)))\n    \\<longlonglongrightarrow> e", "unfolding e LIMSEQ_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r>0.\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             cmod\n              ((jordan_block k la ^\\<^sub>m n) $$ (i, j) *\n               complex_of_real (c / real n ^ (m - 1)) -\n               0)\n             < r", "by (intro exI[of _ k] allI impI, subst jbn, auto)"], ["proof (state)\nthis:\n  (\\<lambda>N.\n      (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n      complex_of_real (c / real N ^ (m - 1)))\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "from LIMSEQ_subseq_LIMSEQ[OF this mono_K]"], ["proof (chain)\npicking this:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K ?off1)\n  \\<longlonglongrightarrow> e", "have \"(?jbc o K off) \\<longlonglongrightarrow> e\""], ["proof (prove)\nusing this:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K ?off1)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. ((\\<lambda>N.\n         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n     K off)\n    \\<longlonglongrightarrow> e", "."], ["proof (state)\nthis:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "}"], ["proof (state)\nthis:\n  j < i \\<or> la = 0 \\<Longrightarrow>\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "note part2 = this"], ["proof (state)\nthis:\n  j < i \\<or> la = 0 \\<Longrightarrow>\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "from part1 part2"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<le> j; la \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>N.\n                         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n                         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n                     K off)\n                    \\<longlonglongrightarrow> e\n  j < i \\<or> la = 0 \\<Longrightarrow>\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e", "have \"(?jbc o K off) \\<longlonglongrightarrow> e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> j; la \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>N.\n                         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n                         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n                     K off)\n                    \\<longlonglongrightarrow> e\n  j < i \\<or> la = 0 \\<Longrightarrow>\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. ((\\<lambda>N.\n         (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n         complex_of_real (c / real N ^ (m - 1))) \\<circ>\n     K off)\n    \\<longlonglongrightarrow> e", "by linarith"], ["proof (state)\nthis:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>N.\n       (jordan_block k la ^\\<^sub>m N) $$ (i, j) *\n       complex_of_real (c / real N ^ (m - 1))) \\<circ>\n   K off)\n  \\<longlonglongrightarrow> e\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "unfolding e_def o_def C_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      (jordan_block k la ^\\<^sub>m K off x) $$ (i, j) *\n      complex_of_real (c / real (K off x) ^ (m - 1)))\n  \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                             then la ^ off else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n        complex_of_real (c / real (K off N) ^ (m - 1)))\n    \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                  j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                               then la ^ off else 0)", "."], ["proof (state)\nthis:\n  (\\<lambda>N.\n      (jordan_block k la ^\\<^sub>m K off N) $$ (i, j) *\n      complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if i = 0 \\<and>\n                                j = k - 1 \\<and> cmod la = 1 \\<and> k = m\n                             then la ^ off else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Lam where \"Lam i = snd (n_as ! fst (j_to_jb_index n_as i))\""], ["", "lemma cmod_Lam: \"i \\<in> I \\<Longrightarrow> cmod (Lam i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> I \\<Longrightarrow> cmod (Lam i) = 1", "unfolding I_def Lam_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {uu_.\n             \\<exists>i bi li nn la.\n                uu_ = i \\<and>\n                i < n \\<and>\n                j_to_jb_index n_as i = (bi, li) \\<and>\n                n_as ! bi = (nn, la) \\<and>\n                cmod la = 1 \\<and>\n                nn = m \\<and> li = nn - 1} \\<Longrightarrow>\n    cmod (snd (n_as ! fst (j_to_jb_index n_as i))) = 1", "by auto"], ["", "lemma I_Lam: assumes i: \"i \\<in> I\" \n  shows \"(m, Lam i) \\<in> set n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, Lam i) \\<in> set n_as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (m, Lam i) \\<in> set n_as", "from i[unfolded I_def]"], ["proof (chain)\npicking this:\n  i \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}", "obtain bi li la where i: \"i < n\" and jb: \"j_to_jb_index n_as i = (bi, li)\" \n    and nth: \"n_as ! bi = (m, la)\" and \"cmod la = 1 \\<and> li = m - 1\""], ["proof (prove)\nusing this:\n  i \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n\ngoal (1 subgoal):\n 1. (\\<And>bi li la.\n        \\<lbrakk>i < n; j_to_jb_index n_as i = (bi, li);\n         n_as ! bi = (m, la); cmod la = 1 \\<and> li = m - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  j_to_jb_index n_as i = (bi, li)\n  n_as ! bi = (m, la)\n  cmod la = 1 \\<and> li = m - 1\n\ngoal (1 subgoal):\n 1. (m, Lam i) \\<in> set n_as", "hence lam: \"Lam i = la\""], ["proof (prove)\nusing this:\n  i < n\n  j_to_jb_index n_as i = (bi, li)\n  n_as ! bi = (m, la)\n  cmod la = 1 \\<and> li = m - 1\n\ngoal (1 subgoal):\n 1. Lam i = la", "unfolding Lam_def"], ["proof (prove)\nusing this:\n  i < n\n  j_to_jb_index n_as i = (bi, li)\n  n_as ! bi = (m, la)\n  cmod la = 1 \\<and> li = m - 1\n\ngoal (1 subgoal):\n 1. snd (n_as ! fst (j_to_jb_index n_as i)) = la", "by auto"], ["proof (state)\nthis:\n  Lam i = la\n\ngoal (1 subgoal):\n 1. (m, Lam i) \\<in> set n_as", "from j_to_jb_index[of _ n_as, unfolded sumlist_nf, OF i i jb jb nth] lam"], ["proof (chain)\npicking this:\n  (J ^\\<^sub>m ?r) $$ (i, i) =\n  (if bi = bi then (jordan_block m la ^\\<^sub>m ?r) $$ (li, li)\n   else 0) \\<and>\n  (bi = bi \\<longrightarrow>\n   li < m \\<and>\n   li < m \\<and> bi < length n_as \\<and> (m, la) \\<in> set n_as)\n  Lam i = la", "show ?thesis"], ["proof (prove)\nusing this:\n  (J ^\\<^sub>m ?r) $$ (i, i) =\n  (if bi = bi then (jordan_block m la ^\\<^sub>m ?r) $$ (li, li)\n   else 0) \\<and>\n  (bi = bi \\<longrightarrow>\n   li < m \\<and>\n   li < m \\<and> bi < length n_as \\<and> (m, la) \\<in> set n_as)\n  Lam i = la\n\ngoal (1 subgoal):\n 1. (m, Lam i) \\<in> set n_as", "by auto"], ["proof (state)\nthis:\n  (m, Lam i) \\<in> set n_as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma limit_jordan_matrix: assumes ij: \"i < n\" \"j < n\" \nshows \"(\\<lambda>N. (J ^\\<^sub>m (K off N)) $$ (i, j) * C off N)\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1) then (Lam j)^off else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "obtain bi li where bi: \"j_to_jb_index n_as i = (bi, li)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bi li.\n        j_to_jb_index n_as i = (bi, li) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  j_to_jb_index n_as i = (bi, li)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "obtain bj lj where bj: \"j_to_jb_index n_as j = (bj, lj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bj lj.\n        j_to_jb_index n_as j = (bj, lj) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  j_to_jb_index n_as j = (bj, lj)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "define la where \"la = snd (n_as ! fst (j_to_jb_index n_as j))\""], ["proof (state)\nthis:\n  la = snd (n_as ! fst (j_to_jb_index n_as j))\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "obtain nn where nbj: \"n_as ! bj = (nn,la)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        n_as ! bj = (nn, la) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding la_def bj fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        n_as ! bj = (nn, snd (n_as ! bj)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  n_as ! bj = (nn, la)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "from j_to_jb_index[OF ij[folded sumlist_nf] bi bj nbj]"], ["proof (chain)\npicking this:\n  (J ^\\<^sub>m ?r) $$ (i, j) =\n  (if bi = bj then (jordan_block nn la ^\\<^sub>m ?r) $$ (li, lj)\n   else 0) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < nn \\<and>\n   lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as)", "have eq: \"bi = bj \\<Longrightarrow> li < nn \\<and> lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as\" and \n    index: \"(J ^\\<^sub>m r) $$ (i, j) =\n    (if bi = bj then (jordan_block nn la ^\\<^sub>m r) $$ (li, lj) else 0)\" for r"], ["proof (prove)\nusing this:\n  (J ^\\<^sub>m ?r) $$ (i, j) =\n  (if bi = bj then (jordan_block nn la ^\\<^sub>m ?r) $$ (li, lj)\n   else 0) \\<and>\n  (bi = bj \\<longrightarrow>\n   li < nn \\<and>\n   lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as)\n\ngoal (1 subgoal):\n 1. (bi = bj \\<Longrightarrow>\n     li < nn \\<and>\n     lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as) &&&\n    (J ^\\<^sub>m r) $$ (i, j) =\n    (if bi = bj then (jordan_block nn la ^\\<^sub>m r) $$ (li, lj) else 0)", "by auto"], ["proof (state)\nthis:\n  bi = bj \\<Longrightarrow>\n  li < nn \\<and>\n  lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as\n  (J ^\\<^sub>m ?r) $$ (i, j) =\n  (if bi = bj then (jordan_block nn la ^\\<^sub>m ?r) $$ (li, lj) else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "note index_rev = j_to_jb_index_rev[OF bj, unfolded sumlist_nf, OF ij(2) le_refl]"], ["proof (state)\nthis:\n  lj \\<le> j \\<and>\n  j_to_jb_index n_as (j - lj) = (bj, lj - lj) \\<and>\n  (j_to_jb_index n_as ?j = (bj, lj - lj) \\<longrightarrow>\n   ?j < n \\<longrightarrow> ?j = j - lj)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "proof (cases \"bi = bj\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "case False"], ["proof (state)\nthis:\n  bi \\<noteq> bj\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "hence id: \"(bi = bj) = False\""], ["proof (prove)\nusing this:\n  bi \\<noteq> bj\n\ngoal (1 subgoal):\n 1. (bi = bj) = False", "by auto"], ["proof (state)\nthis:\n  (bi = bj) = False\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "{"], ["proof (state)\nthis:\n  (bi = bj) = False\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "assume \"j \\<in> I\" \"i = j - (m - 1)\""], ["proof (state)\nthis:\n  j \\<in> I\n  i = j - (m - 1)\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "from this[unfolded I_def] bj nbj"], ["proof (chain)\npicking this:\n  j \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n  i = j - (m - 1)\n  j_to_jb_index n_as j = (bj, lj)\n  n_as ! bj = (nn, la)", "have \"i = j - lj\""], ["proof (prove)\nusing this:\n  j \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n  i = j - (m - 1)\n  j_to_jb_index n_as j = (bj, lj)\n  n_as ! bj = (nn, la)\n\ngoal (1 subgoal):\n 1. i = j - lj", "by auto"], ["proof (state)\nthis:\n  i = j - lj\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "from index_rev[folded this] bi False"], ["proof (chain)\npicking this:\n  lj \\<le> j \\<and>\n  j_to_jb_index n_as i = (bj, lj - lj) \\<and>\n  (j_to_jb_index n_as ?j = (bj, lj - lj) \\<longrightarrow>\n   ?j < n \\<longrightarrow> ?j = i)\n  j_to_jb_index n_as i = (bi, li)\n  bi \\<noteq> bj", "have False"], ["proof (prove)\nusing this:\n  lj \\<le> j \\<and>\n  j_to_jb_index n_as i = (bj, lj - lj) \\<and>\n  (j_to_jb_index n_as ?j = (bj, lj - lj) \\<longrightarrow>\n   ?j < n \\<longrightarrow> ?j = i)\n  j_to_jb_index n_as i = (bi, li)\n  bi \\<noteq> bj\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<in> I; i = j - (m - 1)\\<rbrakk> \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)\n 2. bi \\<noteq> bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<in> I; i = j - (m - 1)\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "unfolding index id if_False"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<in> I; i = j - (m - 1)\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<lambda>N. 0 * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                             then Lam j ^ off else 0)\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "case True"], ["proof (state)\nthis:\n  bi = bj\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "hence id: \"(bi = bj) = True\""], ["proof (prove)\nusing this:\n  bi = bj\n\ngoal (1 subgoal):\n 1. (bi = bj) = True", "by auto"], ["proof (state)\nthis:\n  (bi = bj) = True\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "from eq[OF True]"], ["proof (chain)\npicking this:\n  li < nn \\<and>\n  lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as", "have eq: \"li < nn\" \"lj < nn\" \"(nn,la) \\<in> set n_as\" \"bj < length n_as\""], ["proof (prove)\nusing this:\n  li < nn \\<and>\n  lj < nn \\<and> bj < length n_as \\<and> (nn, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. (li < nn &&& lj < nn) &&& (nn, la) \\<in> set n_as &&& bj < length n_as", "by auto"], ["proof (state)\nthis:\n  li < nn\n  lj < nn\n  (nn, la) \\<in> set n_as\n  bj < length n_as\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "have \"(\\<lambda>N. (J ^\\<^sub>m (K off N)) $$ (i, j) * C off N)\n      \\<longlonglongrightarrow> (if li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m then la^off else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if li = 0 \\<and>\n                                  lj = nn - 1 \\<and>\n                                  cmod la = 1 \\<and> nn = m\n                               then la ^ off else 0)", "unfolding index id if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block nn la ^\\<^sub>m K off N) $$ (li, lj) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if li = 0 \\<and>\n                                  lj = nn - 1 \\<and>\n                                  cmod la = 1 \\<and> nn = m\n                               then la ^ off else 0)", "using limit_jordan_block[OF eq(3,1,2)]"], ["proof (prove)\nusing this:\n  (\\<lambda>N.\n      (jordan_block nn la ^\\<^sub>m K ?off N) $$ (li, lj) *\n      complex_of_real (C ?off N))\n  \\<longlonglongrightarrow> (if li = 0 \\<and>\n                                lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n                             then la ^ ?off else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (jordan_block nn la ^\\<^sub>m K off N) $$ (li, lj) *\n        complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if li = 0 \\<and>\n                                  lj = nn - 1 \\<and>\n                                  cmod la = 1 \\<and> nn = m\n                               then la ^ off else 0)", "."], ["proof (state)\nthis:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if li = 0 \\<and>\n                                lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n                             then la ^ off else 0)\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "also"], ["proof (state)\nthis:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if li = 0 \\<and>\n                                lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n                             then la ^ off else 0)\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "have \"(li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m) = (j \\<in> I \\<and> i = j - (m - 1))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m) =\n    (j \\<in> I \\<and> i = j - (m - 1))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)\n 2. j \\<in> I \\<and> i = j - (m - 1) \\<Longrightarrow>\n    li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "assume ?r"], ["proof (state)\nthis:\n  j \\<in> I \\<and> i = j - (m - 1)\n\ngoal (2 subgoals):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)\n 2. j \\<in> I \\<and> i = j - (m - 1) \\<Longrightarrow>\n    li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "hence \"j \\<in> I\""], ["proof (prove)\nusing this:\n  j \\<in> I \\<and> i = j - (m - 1)\n\ngoal (1 subgoal):\n 1. j \\<in> I", ".."], ["proof (state)\nthis:\n  j \\<in> I\n\ngoal (2 subgoals):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)\n 2. j \\<in> I \\<and> i = j - (m - 1) \\<Longrightarrow>\n    li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "from this[unfolded I_def] bj nbj"], ["proof (chain)\npicking this:\n  j \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n  j_to_jb_index n_as j = (bj, lj)\n  n_as ! bj = (nn, la)", "have *: \"nn = m\" \"cmod la = 1\" \"lj = nn - 1\""], ["proof (prove)\nusing this:\n  j \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n  j_to_jb_index n_as j = (bj, lj)\n  n_as ! bj = (nn, la)\n\ngoal (1 subgoal):\n 1. nn = m &&& cmod la = 1 &&& lj = nn - 1", "by auto"], ["proof (state)\nthis:\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n\ngoal (2 subgoals):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)\n 2. j \\<in> I \\<and> i = j - (m - 1) \\<Longrightarrow>\n    li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "from \\<open>?r\\<close> *"], ["proof (chain)\npicking this:\n  j \\<in> I \\<and> i = j - (m - 1)\n  nn = m\n  cmod la = 1\n  lj = nn - 1", "have \"i = j - lj\""], ["proof (prove)\nusing this:\n  j \\<in> I \\<and> i = j - (m - 1)\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n\ngoal (1 subgoal):\n 1. i = j - lj", "by auto"], ["proof (state)\nthis:\n  i = j - lj\n\ngoal (2 subgoals):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)\n 2. j \\<in> I \\<and> i = j - (m - 1) \\<Longrightarrow>\n    li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "with *"], ["proof (chain)\npicking this:\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n  i = j - lj", "have \"li = 0\""], ["proof (prove)\nusing this:\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n  i = j - lj\n\ngoal (1 subgoal):\n 1. li = 0", "using index_rev bi"], ["proof (prove)\nusing this:\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n  i = j - lj\n  lj \\<le> j \\<and>\n  j_to_jb_index n_as (j - lj) = (bj, lj - lj) \\<and>\n  (j_to_jb_index n_as ?j = (bj, lj - lj) \\<longrightarrow>\n   ?j < n \\<longrightarrow> ?j = j - lj)\n  j_to_jb_index n_as i = (bi, li)\n\ngoal (1 subgoal):\n 1. li = 0", "by auto"], ["proof (state)\nthis:\n  li = 0\n\ngoal (2 subgoals):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)\n 2. j \\<in> I \\<and> i = j - (m - 1) \\<Longrightarrow>\n    li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "with *"], ["proof (chain)\npicking this:\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n  li = 0", "show ?l"], ["proof (prove)\nusing this:\n  nn = m\n  cmod la = 1\n  lj = nn - 1\n  li = 0\n\ngoal (1 subgoal):\n 1. li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "by auto"], ["proof (state)\nthis:\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n\ngoal (1 subgoal):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)", "assume ?l"], ["proof (state)\nthis:\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n\ngoal (1 subgoal):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)", "hence jI: \"j \\<in> I\""], ["proof (prove)\nusing this:\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n\ngoal (1 subgoal):\n 1. j \\<in> I", "using bj nbj ij"], ["proof (prove)\nusing this:\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n  j_to_jb_index n_as j = (bj, lj)\n  n_as ! bj = (nn, la)\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. j \\<in> I", "by (auto simp: I_def)"], ["proof (state)\nthis:\n  j \\<in> I\n\ngoal (1 subgoal):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)", "from \\<open>?l\\<close>"], ["proof (chain)\npicking this:\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m", "have \"li = 0\""], ["proof (prove)\nusing this:\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n\ngoal (1 subgoal):\n 1. li = 0", "by auto"], ["proof (state)\nthis:\n  li = 0\n\ngoal (1 subgoal):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)", "with index_rev[of i] bi ij(1) \\<open>?l\\<close> True"], ["proof (chain)\npicking this:\n  lj \\<le> j \\<and>\n  j_to_jb_index n_as (j - lj) = (bj, lj - lj) \\<and>\n  (j_to_jb_index n_as i = (bj, lj - lj) \\<longrightarrow>\n   i < n \\<longrightarrow> i = j - lj)\n  j_to_jb_index n_as i = (bi, li)\n  i < n\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n  bi = bj\n  li = 0", "have \"i = j - (m - 1)\""], ["proof (prove)\nusing this:\n  lj \\<le> j \\<and>\n  j_to_jb_index n_as (j - lj) = (bj, lj - lj) \\<and>\n  (j_to_jb_index n_as i = (bj, lj - lj) \\<longrightarrow>\n   i < n \\<longrightarrow> i = j - lj)\n  j_to_jb_index n_as i = (bi, li)\n  i < n\n  li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m\n  bi = bj\n  li = 0\n\ngoal (1 subgoal):\n 1. i = j - (m - 1)", "by auto"], ["proof (state)\nthis:\n  i = j - (m - 1)\n\ngoal (1 subgoal):\n 1. li = 0 \\<and>\n    lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m \\<Longrightarrow>\n    j \\<in> I \\<and> i = j - (m - 1)", "with jI"], ["proof (chain)\npicking this:\n  j \\<in> I\n  i = j - (m - 1)", "show ?r"], ["proof (prove)\nusing this:\n  j \\<in> I\n  i = j - (m - 1)\n\ngoal (1 subgoal):\n 1. j \\<in> I \\<and> i = j - (m - 1)", "by auto"], ["proof (state)\nthis:\n  j \\<in> I \\<and> i = j - (m - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (li = 0 \\<and> lj = nn - 1 \\<and> cmod la = 1 \\<and> nn = m) =\n  (j \\<in> I \\<and> i = j - (m - 1))\n\ngoal (1 subgoal):\n 1. bi = bj \\<Longrightarrow>\n    (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                             then la ^ off else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                             then la ^ off else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then Lam j ^ off else 0)", "unfolding la_def Lam_def"], ["proof (prove)\nusing this:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                             then snd (n_as ! fst (j_to_jb_index n_as j)) ^\n                                  off\n                             else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>N.\n        (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n    \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                               then snd (n_as !\n   fst (j_to_jb_index n_as j)) ^\n                                    off\n                               else 0)", "."], ["proof (state)\nthis:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                             then Lam j ^ off else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>N. (J ^\\<^sub>m K off N) $$ (i, j) * complex_of_real (C off N))\n  \\<longlonglongrightarrow> (if j \\<in> I \\<and> i = j - (m - 1)\n                             then Lam j ^ off else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare sumlist_nf[simp]"], ["", "lemma A_power_P: \"cA ^\\<^sub>m k * P = P * J ^\\<^sub>m k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k * P = P * J ^\\<^sub>m k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. of_real_hom.mat_hom A ^\\<^sub>m 0 * P = P * J ^\\<^sub>m 0\n 2. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. of_real_hom.mat_hom A ^\\<^sub>m 0 * P = P * J ^\\<^sub>m 0\n 2. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m 0 * P = P * J ^\\<^sub>m 0", "using A JNF"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m 0 * P = P * J ^\\<^sub>m 0", "by simp"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m 0 * P = P * J ^\\<^sub>m 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "case (Suc k)"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k * P = P * J ^\\<^sub>m k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "have \"cA ^\\<^sub>m Suc k * P = cA ^\\<^sub>m k * cA * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m Suc k * P =\n    of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P", "by simp"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "have \"\\<dots> = cA ^\\<^sub>m k * (P * J * iP) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P =\n    of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P", "using JNF"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P =\n    of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P", "by simp"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k * of_real_hom.mat_hom A * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "have \"\\<dots> = (cA ^\\<^sub>m k * P) * (J * (iP * P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P =\n    of_real_hom.mat_hom A ^\\<^sub>m k * P * (J * (iP * P))", "using A JNF(1-3)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P =\n    of_real_hom.mat_hom A ^\\<^sub>m k * P * (J * (iP * P))", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * P * (J * (iP * P))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k * (P * J * iP) * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * P * (J * (iP * P))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "have \"J * (iP * P) = J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J * (iP * P) = J", "unfolding JNF"], ["proof (prove)\ngoal (1 subgoal):\n 1. J * 1\\<^sub>m n = J", "using JNF"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n\ngoal (1 subgoal):\n 1. J * 1\\<^sub>m n = J", "by auto"], ["proof (state)\nthis:\n  J * (iP * P) = J\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       of_real_hom.mat_hom A ^\\<^sub>m k * P =\n       P * J ^\\<^sub>m k \\<Longrightarrow>\n       of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "finally"], ["proof (chain)\npicking this:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * P * J", "show ?case"], ["proof (prove)\nusing this:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P =\n  of_real_hom.mat_hom A ^\\<^sub>m k * P * J\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "unfolding Suc"], ["proof (prove)\nusing this:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m k * J\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "using A JNF(1-3)"], ["proof (prove)\nusing this:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m k * J\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m Suc k * P = P * J ^\\<^sub>m Suc k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_nonneg: \"C off k \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C off k", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> c / real (K off k) ^ (m - 1)", "using c_gt_0"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 \\<le> c / real (K off k) ^ (m - 1)", "by auto"], ["", "lemma P_nonzero_entry: assumes j: \"j < n\"\n  shows \"\\<exists> i < n. P $$ (i,j) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<n. P $$ (i, j) \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "hence 0: \"\\<And> i. i < n \\<Longrightarrow> P $$ (i,j) = 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> P $$ (i, j) = 0", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> P $$ (?i, j) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "have \"1 = (iP * P) $$ (j,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = (iP * P) $$ (j, j)", "using j"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. 1 = (iP * P) $$ (j, j)", "unfolding JNF"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. 1 = 1\\<^sub>m n $$ (j, j)", "by auto"], ["proof (state)\nthis:\n  1 = (iP * P) $$ (j, j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  1 = (iP * P) $$ (j, j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iP * P) $$ (j, j) = (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j))", "using j JNF(1-2)"], ["proof (prove)\nusing this:\n  j < n\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (iP * P) $$ (j, j) = (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j))", "by (auto simp: scalar_prod_def)"], ["proof (state)\nthis:\n  (iP * P) $$ (j, j) = (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (iP * P) $$ (j, j) = (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j)) = 0", "by (rule sum.neutral, insert 0, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. iP $$ (j, i) * P $$ (i, j)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. P $$ (i, j) \\<noteq> 0) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  1 = 0", "show False"], ["proof (prove)\nusing this:\n  1 = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition i where \"i = (SOME i. i \\<in> I)\""], ["", "lemma i: \"i \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> I", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> I) \\<in> I", "using I_nonempty some_in_eq"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  ((SOME x. x \\<in> ?A) \\<in> ?A) = (?A \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> I) \\<in> I", "by blast"], ["", "lemma i_n: \"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n", "using i"], ["proof (prove)\nusing this:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. i < n", "unfolding I_def"], ["proof (prove)\nusing this:\n  i \\<in> {uu_.\n           \\<exists>i bi li nn la.\n              uu_ = i \\<and>\n              i < n \\<and>\n              j_to_jb_index n_as i = (bi, li) \\<and>\n              n_as ! bi = (nn, la) \\<and>\n              cmod la = 1 \\<and> nn = m \\<and> li = nn - 1}\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["", "definition \"j = (SOME j. j < n \\<and> P $$ (j, i - (m - 1)) \\<noteq> 0)\""], ["", "lemma j: \"j < n\" \"P $$ (j, i - (m - 1)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < n &&& P $$ (j, i - (m - 1)) \\<noteq> 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. j < n\n 2. P $$ (j, i - (m - 1)) \\<noteq> 0", "from i_n"], ["proof (chain)\npicking this:\n  i < n", "have lt: \"i - (m - 1) < n\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. i - (m - 1) < n", "by auto"], ["proof (state)\nthis:\n  i - (m - 1) < n\n\ngoal (2 subgoals):\n 1. j < n\n 2. P $$ (j, i - (m - 1)) \\<noteq> 0", "show \"j < n\" \"P $$ (j, i - (m - 1)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < n &&& P $$ (j, i - (m - 1)) \\<noteq> 0", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME j. j < n \\<and> P $$ (j, i - (m - 1)) \\<noteq> 0) < n &&&\n    P $$\n    (SOME j. j < n \\<and> P $$ (j, i - (m - 1)) \\<noteq> 0,\n     i - (m - 1)) \\<noteq>\n    0", "using someI_ex[OF P_nonzero_entry[OF lt]]"], ["proof (prove)\nusing this:\n  (SOME x. x < n \\<and> P $$ (x, i - (m - 1)) \\<noteq> 0) < n \\<and>\n  P $$\n  (SOME x. x < n \\<and> P $$ (x, i - (m - 1)) \\<noteq> 0,\n   i - (m - 1)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (SOME j. j < n \\<and> P $$ (j, i - (m - 1)) \\<noteq> 0) < n &&&\n    P $$\n    (SOME j. j < n \\<and> P $$ (j, i - (m - 1)) \\<noteq> 0,\n     i - (m - 1)) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  j < n\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"B = cmod (P $$ (j, i - (m - 1))) / 2\""], ["", "lemma B: \"0 < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cmod (P $$ (j, i - (m - 1))) / 2", "using j"], ["proof (prove)\nusing this:\n  j < n\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < cmod (P $$ (j, i - (m - 1))) / 2", "by auto"], ["", "definition \"w = P *\\<^sub>v unit_vec n i\""], ["", "lemma w: \"w \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "using JNF"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "unfolding w_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n\ngoal (1 subgoal):\n 1. P *\\<^sub>v unit_vec n i \\<in> carrier_vec n", "by auto"], ["", "definition \"v = map_vec cmod w\""], ["", "lemma v: \"v \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vec cmod w \\<in> carrier_vec n", "using w"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. map_vec cmod w \\<in> carrier_vec n", "by auto"], ["", "lemma main_step: \"\\<exists> a. \\<forall> l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "let ?c = \"complex_of_real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "let ?cv = \"map_vec ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "let ?cm = \"map_mat ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "let ?v = \"?cv v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define u where \"u = iP *\\<^sub>v ?v\""], ["proof (state)\nthis:\n  u = iP *\\<^sub>v of_real_hom.vec_hom v\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define cc where \n    \"cc = (\\<lambda> i. ((\\<Sum>k = 0..<n. (if k = i - (m - 1) then P $$ (j, k) else 0)) * u $v i))\""], ["proof (state)\nthis:\n  cc =\n  (\\<lambda>i.\n      (\\<Sum>k = 0..<n. if k = i - (m - 1) then P $$ (j, k) else 0) *\n      u $v i)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define a where \"a = (\\<lambda> i. P $$ (j, i - (m - 1)) * u $v i)\""], ["proof (state)\nthis:\n  a = (\\<lambda>i. P $$ (j, i - (m - 1)) * u $v i)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have u: \"u \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> carrier_vec n", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iP *\\<^sub>v of_real_hom.vec_hom v \\<in> carrier_vec n", "using JNF(2) v"], ["proof (prove)\nusing this:\n  iP \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. iP *\\<^sub>v of_real_hom.vec_hom v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "{"], ["proof (state)\nthis:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "fix off"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from i i_n"], ["proof (chain)\npicking this:\n  i \\<in> I\n  i < n", "have iI: \"i \\<in> I\" and i: \"i < n\""], ["proof (prove)\nusing this:\n  i \\<in> I\n  i < n\n\ngoal (1 subgoal):\n 1. i \\<in> I &&& i < n", "by auto"], ["proof (state)\nthis:\n  i \\<in> I\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "let ?exp = \"\\<lambda> k. sum (\\<lambda> ii. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii,i)) {..<n}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define M where \"M = (\\<lambda> k. cmod (?exp (K off k) * C off k))\""], ["proof (state)\nthis:\n  M =\n  (\\<lambda>k.\n      cmod\n       ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n        complex_of_real (C off k)))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "let ?i = \"i - (m - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define G where \"G = (\\<lambda> k. (A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k)\""], ["proof (state)\nthis:\n  G = (\\<lambda>k. (A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "{"], ["proof (state)\nthis:\n  G = (\\<lambda>k. (A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "fix kk"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define k where \"k = K off kk\""], ["proof (state)\nthis:\n  k = K off kk\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define cAk where \"cAk = cA ^\\<^sub>m k\""], ["proof (state)\nthis:\n  cAk = of_real_hom.mat_hom A ^\\<^sub>m k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have cAk: \"cAk \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cAk \\<in> carrier_mat n n", "unfolding cAk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  cAk \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"((A ^\\<^sub>m k) *\\<^sub>v v) $ j = ((map_mat cmod cAk) *\\<^sub>v map_vec cmod w) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ^\\<^sub>m k *\\<^sub>v v) $v j =\n    (map_mat cmod cAk *\\<^sub>v map_vec cmod w) $v j", "unfolding v_def[symmetric] cAk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ^\\<^sub>m k *\\<^sub>v v) $v j =\n    (map_mat cmod (of_real_hom.mat_hom A ^\\<^sub>m k) *\\<^sub>v v) $v j", "by (rule arg_cong[of _ _ \"\\<lambda> x. (x *\\<^sub>v v) $ j\"],\n          unfold of_real_hom.mat_hom_pow[OF A, symmetric],\n        insert nonneg_mat_power[OF A nonneg, of k], insert i j, \n        auto simp: nonneg_mat_def elements_mat_def)"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j =\n  (map_mat cmod cAk *\\<^sub>v map_vec cmod w) $v j\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j =\n  (map_mat cmod cAk *\\<^sub>v map_vec cmod w) $v j\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> \\<ge> cmod ((cAk *\\<^sub>v w) $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod ((cAk *\\<^sub>v w) $v j)\n    \\<le> (map_mat cmod cAk *\\<^sub>v map_vec cmod w) $v j", "by (subst (1 2) index_mult_mat_vec, insert j cAk w, auto simp: scalar_prod_def\n        intro!: sum_norm_le norm_mult_ineq)"], ["proof (state)\nthis:\n  cmod ((cAk *\\<^sub>v w) $v j)\n  \\<le> (map_mat cmod cAk *\\<^sub>v map_vec cmod w) $v j\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  cmod ((cAk *\\<^sub>v w) $v j)\n  \\<le> (map_mat cmod cAk *\\<^sub>v map_vec cmod w) $v j\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"cAk *\\<^sub>v w = (cAk * P) *\\<^sub>v unit_vec n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cAk *\\<^sub>v w = cAk * P *\\<^sub>v unit_vec n i", "unfolding w_def i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cAk *\\<^sub>v (P *\\<^sub>v unit_vec n (SOME i. i \\<in> I)) =\n    cAk * P *\\<^sub>v unit_vec n (SOME i. i \\<in> I)", "using JNF cAk"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n  cAk \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. cAk *\\<^sub>v (P *\\<^sub>v unit_vec n (SOME i. i \\<in> I)) =\n    cAk * P *\\<^sub>v unit_vec n (SOME i. i \\<in> I)", "by simp"], ["proof (state)\nthis:\n  cAk *\\<^sub>v w = cAk * P *\\<^sub>v unit_vec n i\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  cAk *\\<^sub>v w = cAk * P *\\<^sub>v unit_vec n i\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v unit_vec n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cAk * P *\\<^sub>v unit_vec n i =\n    P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v unit_vec n i)", "unfolding cAk_def A_power_P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * J ^\\<^sub>m k *\\<^sub>v unit_vec n i =\n    P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v unit_vec n i)", "using JNF"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  iP \\<in> carrier_mat n n\n  J \\<in> carrier_mat n n\n  P * iP = 1\\<^sub>m n\n  iP * P = 1\\<^sub>m n\n  of_real_hom.mat_hom A = P * J * iP\n\ngoal (1 subgoal):\n 1. P * J ^\\<^sub>m k *\\<^sub>v unit_vec n i =\n    P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v unit_vec n i)", "by (subst assoc_mult_mat_vec[of _ n n _ n], auto)"], ["proof (state)\nthis:\n  cAk * P *\\<^sub>v unit_vec n i =\n  P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v unit_vec n i)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  cAk * P *\\<^sub>v unit_vec n i =\n  P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v unit_vec n i)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"J ^\\<^sub>m k *\\<^sub>v unit_vec n i = col (J ^\\<^sub>m k) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J ^\\<^sub>m k *\\<^sub>v unit_vec n i = col (J ^\\<^sub>m k) i", "by (rule eq_vecI, insert i, auto)"], ["proof (state)\nthis:\n  J ^\\<^sub>m k *\\<^sub>v unit_vec n i = col (J ^\\<^sub>m k) i\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  J ^\\<^sub>m k *\\<^sub>v unit_vec n i = col (J ^\\<^sub>m k) i\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"(P *\\<^sub>v (col (J ^\\<^sub>m k) i)) $ j = Matrix.row P j \\<bullet> col (J ^\\<^sub>m k) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P *\\<^sub>v col (J ^\\<^sub>m k) i) $v j =\n    Matrix.row P j \\<bullet> col (J ^\\<^sub>m k) i", "by (subst index_mult_mat_vec, insert j JNF, auto)"], ["proof (state)\nthis:\n  (P *\\<^sub>v col (J ^\\<^sub>m k) i) $v j =\n  Matrix.row P j \\<bullet> col (J ^\\<^sub>m k) i\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (P *\\<^sub>v col (J ^\\<^sub>m k) i) $v j =\n  Matrix.row P j \\<bullet> col (J ^\\<^sub>m k) i\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = sum (\\<lambda> ii. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii,i)) {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.row P j \\<bullet> col (J ^\\<^sub>m k) i =\n    (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec (col (J ^\\<^sub>m k) i).\n        Matrix.row P j $v ia * col (J ^\\<^sub>m k) i $v ia) =\n    (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))", "by (rule sum.cong, insert i j JNF(1), auto)"], ["proof (state)\nthis:\n  Matrix.row P j \\<bullet> col (J ^\\<^sub>m k) i =\n  (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j", "have \"(A ^\\<^sub>m k *\\<^sub>v v) $v j \\<ge> cmod (?exp k)\""], ["proof (prove)\nusing this:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))\n    \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j", "."], ["proof (state)\nthis:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i))\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from mult_right_mono[OF this C_nonneg]"], ["proof (chain)\npicking this:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) * C ?off1 ?k1\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C ?off1 ?k1", "have \"(A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk \\<ge> cmod (?exp k * C off kk)\""], ["proof (prove)\nusing this:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) * C ?off1 ?k1\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C ?off1 ?k1\n\ngoal (1 subgoal):\n 1. cmod\n     ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) *\n      complex_of_real (C off kk))\n    \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk", "unfolding norm_mult"], ["proof (prove)\nusing this:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) * C ?off1 ?k1\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C ?off1 ?k1\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) *\n    cmod (complex_of_real (C off kk))\n    \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk", "using C_nonneg"], ["proof (prove)\nusing this:\n  cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) * C ?off1 ?k1\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C ?off1 ?k1\n  0 \\<le> C ?off ?k\n\ngoal (1 subgoal):\n 1. cmod (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) *\n    cmod (complex_of_real (C off kk))\n    \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk", "by auto"], ["proof (state)\nthis:\n  cmod\n   ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m k) $$ (ii, i)) *\n    complex_of_real (C off kk))\n  \\<le> (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "}"], ["proof (state)\nthis:\n  cmod\n   ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off ?kk2) $$ (ii, i)) *\n    complex_of_real (C off ?kk2))\n  \\<le> (A ^\\<^sub>m K off ?kk2 *\\<^sub>v v) $v j * C off ?kk2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "hence ge: \"(A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k \\<ge> M k\" for k"], ["proof (prove)\nusing this:\n  cmod\n   ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off ?kk2) $$ (ii, i)) *\n    complex_of_real (C off ?kk2))\n  \\<le> (A ^\\<^sub>m K off ?kk2 *\\<^sub>v v) $v j * C off ?kk2\n\ngoal (1 subgoal):\n 1. M k \\<le> (A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k", "unfolding M_def"], ["proof (prove)\nusing this:\n  cmod\n   ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off ?kk2) $$ (ii, i)) *\n    complex_of_real (C off ?kk2))\n  \\<le> (A ^\\<^sub>m K off ?kk2 *\\<^sub>v v) $v j * C off ?kk2\n\ngoal (1 subgoal):\n 1. cmod\n     ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n      complex_of_real (C off k))\n    \\<le> (A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k", "by auto"], ["proof (state)\nthis:\n  M ?k \\<le> (A ^\\<^sub>m K off ?k *\\<^sub>v v) $v j * C off ?k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from i"], ["proof (chain)\npicking this:\n  i < n", "have mem: \"i - (m - 1) \\<in> {..<n}\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. i - (m - 1) \\<in> {..<n}", "by auto"], ["proof (state)\nthis:\n  i - (m - 1) \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"(\\<lambda> k. ?exp (K off k) * C off k) \\<longlonglongrightarrow> \n      (\\<Sum>ii<n. P $$ (j, ii) * (if i \\<in> I \\<and> ii = i - (m - 1) then Lam i ^ off else 0))\"\n      (is \"_ \\<longlonglongrightarrow> ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n        complex_of_real (C off k))\n    \\<longlonglongrightarrow> (\\<Sum>ii<n.\n                                  P $$ (j, ii) *\n                                  (if i \\<in> I \\<and> ii = i - (m - 1)\n                                   then Lam i ^ off else 0))", "unfolding sum_distrib_right mult.assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        \\<Sum>n<n.\n           P $$ (j, n) *\n           ((J ^\\<^sub>m K off k) $$ (n, i) * complex_of_real (C off k)))\n    \\<longlonglongrightarrow> (\\<Sum>ii<n.\n                                  P $$ (j, ii) *\n                                  (if i \\<in> I \\<and> ii = i - (m - 1)\n                                   then Lam i ^ off else 0))", "by (rule tendsto_sum, rule tendsto_mult, force, rule limit_jordan_matrix[OF _ i], auto)"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n      complex_of_real (C off k))\n  \\<longlonglongrightarrow> (\\<Sum>ii<n.\n                                P $$ (j, ii) *\n                                (if i \\<in> I \\<and> ii = i - (m - 1)\n                                 then Lam i ^ off else 0))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n      complex_of_real (C off k))\n  \\<longlonglongrightarrow> (\\<Sum>ii<n.\n                                P $$ (j, ii) *\n                                (if i \\<in> I \\<and> ii = i - (m - 1)\n                                 then Lam i ^ off else 0))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"?sum = P $$ (j, i - (m - 1)) * Lam i ^ off\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ii<n.\n        P $$ (j, ii) *\n        (if i \\<in> I \\<and> ii = i - (m - 1) then Lam i ^ off else 0)) =\n    P $$ (j, i - (m - 1)) * Lam i ^ off", "by (subst sum.remove[OF _ mem], force, subst sum.neutral, insert iI, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ii<n.\n      P $$ (j, ii) *\n      (if i \\<in> I \\<and> ii = i - (m - 1) then Lam i ^ off else 0)) =\n  P $$ (j, i - (m - 1)) * Lam i ^ off\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k.\n      (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n      complex_of_real (C off k))\n  \\<longlonglongrightarrow> P $$ (j, i - (m - 1)) * Lam i ^ off", "have tend1: \"(\\<lambda> k. ?exp (K off k) * C off k) \\<longlonglongrightarrow> P $$ (j, i - (m - 1)) * Lam i ^ off\""], ["proof (prove)\nusing this:\n  (\\<lambda>k.\n      (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n      complex_of_real (C off k))\n  \\<longlonglongrightarrow> P $$ (j, i - (m - 1)) * Lam i ^ off\n\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n        complex_of_real (C off k))\n    \\<longlonglongrightarrow> P $$ (j, i - (m - 1)) * Lam i ^ off", "."], ["proof (state)\nthis:\n  (\\<lambda>k.\n      (\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n      complex_of_real (C off k))\n  \\<longlonglongrightarrow> P $$ (j, i - (m - 1)) * Lam i ^ off\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have tend2: \"M \\<longlonglongrightarrow> cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<longlonglongrightarrow> cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        cmod\n         ((\\<Sum>ii<n. P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n          complex_of_real (C off k)))\n    \\<longlonglongrightarrow> cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)", "by (rule tendsto_norm, rule tend1)"], ["proof (state)\nthis:\n  M \\<longlonglongrightarrow> cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "{"], ["proof (state)\nthis:\n  M \\<longlonglongrightarrow> cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from j"], ["proof (chain)\npicking this:\n  j < n\n  P $$ (j, i - (m - 1)) \\<noteq> 0", "have 0: \"P $$ (j, i - (m - 1)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  j < n\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. P $$ (j, i - (m - 1)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define E where \"E = cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)\""], ["proof (state)\nthis:\n  E = cmod (P $$ (j, i - (m - 1)) * Lam i ^ off)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from cmod_Lam[OF iI] 0"], ["proof (chain)\npicking this:\n  cmod (Lam i) = 1\n  P $$ (j, i - (m - 1)) \\<noteq> 0", "have E: \"E / 2 > 0\""], ["proof (prove)\nusing this:\n  cmod (Lam i) = 1\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < E / 2", "unfolding E_def"], ["proof (prove)\nusing this:\n  cmod (Lam i) = 1\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < cmod (P $$ (j, i - (m - 1)) * Lam i ^ off) / 2", "by auto"], ["proof (state)\nthis:\n  0 < E / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from tend2[folded E_def]"], ["proof (chain)\npicking this:\n  M \\<longlonglongrightarrow> E", "have tend2: \"M \\<longlonglongrightarrow> E\""], ["proof (prove)\nusing this:\n  M \\<longlonglongrightarrow> E\n\ngoal (1 subgoal):\n 1. M \\<longlonglongrightarrow> E", "."], ["proof (state)\nthis:\n  M \\<longlonglongrightarrow> E\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from ge"], ["proof (chain)\npicking this:\n  M ?k \\<le> (A ^\\<^sub>m K off ?k *\\<^sub>v v) $v j * C off ?k", "have ge: \"G k \\<ge> M k\" for k"], ["proof (prove)\nusing this:\n  M ?k \\<le> (A ^\\<^sub>m K off ?k *\\<^sub>v v) $v j * C off ?k\n\ngoal (1 subgoal):\n 1. M k \\<le> G k", "unfolding G_def"], ["proof (prove)\nusing this:\n  M ?k \\<le> (A ^\\<^sub>m K off ?k *\\<^sub>v v) $v j * C off ?k\n\ngoal (1 subgoal):\n 1. M k \\<le> (A ^\\<^sub>m K off k *\\<^sub>v v) $v j * C off k", "."], ["proof (state)\nthis:\n  M ?k \\<le> G ?k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from tend2[unfolded LIMSEQ_iff, rule_format, OF E]"], ["proof (chain)\npicking this:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (M n - E) < E / 2", "obtain k' where diff: \"\\<And> k. k \\<ge> k' \\<Longrightarrow> norm (M k - E) < E / 2\""], ["proof (prove)\nusing this:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (M n - E) < E / 2\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        (\\<And>k.\n            k' \\<le> k \\<Longrightarrow>\n            norm (M k - E) < E / 2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k' \\<le> ?k \\<Longrightarrow> norm (M ?k - E) < E / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "{"], ["proof (state)\nthis:\n  k' \\<le> ?k \\<Longrightarrow> norm (M ?k - E) < E / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "assume \"k \\<ge> k'\""], ["proof (state)\nthis:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from diff[OF this]"], ["proof (chain)\npicking this:\n  norm (M k - E) < E / 2", "have norm: \"norm (M k - E) < E / 2\""], ["proof (prove)\nusing this:\n  norm (M k - E) < E / 2\n\ngoal (1 subgoal):\n 1. norm (M k - E) < E / 2", "."], ["proof (state)\nthis:\n  norm (M k - E) < E / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"M k \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> M k", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod\n             ((\\<Sum>ii<n.\n                  P $$ (j, ii) * (J ^\\<^sub>m K off k) $$ (ii, i)) *\n              complex_of_real (C off k))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> M k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "with E norm"], ["proof (chain)\npicking this:\n  0 < E / 2\n  norm (M k - E) < E / 2\n  0 \\<le> M k", "have \"M k \\<ge> E / 2\""], ["proof (prove)\nusing this:\n  0 < E / 2\n  norm (M k - E) < E / 2\n  0 \\<le> M k\n\ngoal (1 subgoal):\n 1. E / 2 \\<le> M k", "by (smt real_norm_def field_sum_of_halves)"], ["proof (state)\nthis:\n  E / 2 \\<le> M k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "with ge[of k] E"], ["proof (chain)\npicking this:\n  M k \\<le> G k\n  0 < E / 2\n  E / 2 \\<le> M k", "have \"G k \\<ge> E / 2\""], ["proof (prove)\nusing this:\n  M k \\<le> G k\n  0 < E / 2\n  E / 2 \\<le> M k\n\ngoal (1 subgoal):\n 1. E / 2 \\<le> G k", "by auto"], ["proof (state)\nthis:\n  E / 2 \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  E / 2 \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"E / 2 = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E / 2 = B", "unfolding E_def B_def j norm_mult norm_power \n          cmod_Lam[OF iI]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (P $$ (j, i - (m - 1))) * 1 ^ off / 2 =\n    cmod (P $$ (j, i - (m - 1))) / 2", "by auto"], ["proof (state)\nthis:\n  E / 2 = B\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "finally"], ["proof (chain)\npicking this:\n  B \\<le> G k", "have \"G k \\<ge> B\""], ["proof (prove)\nusing this:\n  B \\<le> G k\n\ngoal (1 subgoal):\n 1. B \\<le> G k", "."], ["proof (state)\nthis:\n  B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "}"], ["proof (state)\nthis:\n  k' \\<le> ?k2 \\<Longrightarrow> B \\<le> G ?k2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "hence \"\\<exists> k'. \\<forall> k. k \\<ge> k' \\<longrightarrow> G k \\<ge> B\""], ["proof (prove)\nusing this:\n  k' \\<le> ?k2 \\<Longrightarrow> B \\<le> G ?k2\n\ngoal (1 subgoal):\n 1. \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k", "by auto"], ["proof (state)\nthis:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "}"], ["proof (state)\nthis:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "hence Bound: \"\\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\""], ["proof (prove)\nusing this:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k", "by auto"], ["proof (state)\nthis:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "{"], ["proof (state)\nthis:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "fix kk"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define k where \"k = K off kk\""], ["proof (state)\nthis:\n  k = K off kk\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"((A ^\\<^sub>m k) *\\<^sub>v v) $ j * C off kk = Re (?c (((A ^\\<^sub>m k) *\\<^sub>v v) $ j * C off kk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n    Re (complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk))", "by simp"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re (complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re (complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"?c (((A ^\\<^sub>m k) *\\<^sub>v v) $ j * C off kk) = ?cv ((A ^\\<^sub>m k) *\\<^sub>v v) $ j * ?c (C off kk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk) =\n    of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) $v j *\n    complex_of_real (C off kk)", "using j A"], ["proof (prove)\nusing this:\n  j < n\n  P $$ (j, i - (m - 1)) \\<noteq> 0\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk) =\n    of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) $v j *\n    complex_of_real (C off kk)", "by simp"], ["proof (state)\nthis:\n  complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk) =\n  of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) $v j *\n  complex_of_real (C off kk)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  complex_of_real ((A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk) =\n  of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) $v j *\n  complex_of_real (C off kk)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"?cv ((A ^\\<^sub>m k) *\\<^sub>v v) = (?cm (A ^\\<^sub>m k) *\\<^sub>v ?v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) =\n    of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) =\n    of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v", "by (subst of_real_hom.mult_mat_vec_hom[OF _ v], auto)"], ["proof (state)\nthis:\n  of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) =\n  of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  of_real_hom.vec_hom (A ^\\<^sub>m k *\\<^sub>v v) =\n  of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (cA ^\\<^sub>m k *\\<^sub>v ?v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v =\n    of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v", "by (simp add: of_real_hom.mat_hom_pow[OF A])"], ["proof (state)\nthis:\n  of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v =\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom (A ^\\<^sub>m k) *\\<^sub>v of_real_hom.vec_hom v =\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (cA ^\\<^sub>m k *\\<^sub>v ((P * iP) *\\<^sub>v ?v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v =\n    of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n    (P * iP *\\<^sub>v of_real_hom.vec_hom v)", "unfolding JNF"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P * J * iP) ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v =\n    (P * J * iP) ^\\<^sub>m k *\\<^sub>v\n    (1\\<^sub>m n *\\<^sub>v of_real_hom.vec_hom v)", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (P * J * iP) ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v =\n    (P * J * iP) ^\\<^sub>m k *\\<^sub>v\n    (1\\<^sub>m n *\\<^sub>v of_real_hom.vec_hom v)", "by auto"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v =\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n  (P * iP *\\<^sub>v of_real_hom.vec_hom v)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v of_real_hom.vec_hom v =\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n  (P * iP *\\<^sub>v of_real_hom.vec_hom v)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (cA ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n    (P * iP *\\<^sub>v of_real_hom.vec_hom v) =\n    of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u)", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n    (P * iP *\\<^sub>v of_real_hom.vec_hom v) =\n    of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n    (P *\\<^sub>v (iP *\\<^sub>v of_real_hom.vec_hom v))", "by (subst assoc_mult_mat_vec, insert JNF v, auto)"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n  (P * iP *\\<^sub>v of_real_hom.vec_hom v) =\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v\n  (P * iP *\\<^sub>v of_real_hom.vec_hom v) =\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (P * J ^\\<^sub>m k *\\<^sub>v u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u) =\n    P * J ^\\<^sub>m k *\\<^sub>v u", "unfolding A_power_P[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u) =\n    of_real_hom.mat_hom A ^\\<^sub>m k * P *\\<^sub>v u", "by (subst assoc_mult_mat_vec, insert u JNF(1) A, auto)"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u) =\n  P * J ^\\<^sub>m k *\\<^sub>v u\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  of_real_hom.mat_hom A ^\\<^sub>m k *\\<^sub>v (P *\\<^sub>v u) =\n  P * J ^\\<^sub>m k *\\<^sub>v u\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * J ^\\<^sub>m k *\\<^sub>v u = P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)", "by (rule assoc_mult_mat_vec, insert u JNF(1) A, auto)"], ["proof (state)\nthis:\n  P * J ^\\<^sub>m k *\\<^sub>v u = P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "finally"], ["proof (chain)\npicking this:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n      complex_of_real (C off kk))", "have \"(A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk = Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $ j * C off kk)\""], ["proof (prove)\nusing this:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n      complex_of_real (C off kk))\n\ngoal (1 subgoal):\n 1. (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n    Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n        complex_of_real (C off kk))", "by simp"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n      complex_of_real (C off kk))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n      complex_of_real (C off kk))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = Re (\\<Sum>i = 0..<n.\n           P $$ (j, i) * (\\<Sum>ia = 0..< n. (J ^\\<^sub>m k) $$ (i, ia) * u $v ia * C off kk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n        complex_of_real (C off kk)) =\n    Re (\\<Sum>i = 0..<n.\n           P $$ (j, i) *\n           (\\<Sum>ia = 0..<n.\n               (J ^\\<^sub>m k) $$ (i, ia) * u $v ia *\n               complex_of_real (C off kk)))", "by (subst index_mult_mat_vec, insert JNF(1) j u, auto simp: scalar_prod_def sum_distrib_right[symmetric]\n           mult.assoc[symmetric])"], ["proof (state)\nthis:\n  Re ((P *\\<^sub>v (J ^\\<^sub>m k *\\<^sub>v u)) $v j *\n      complex_of_real (C off kk)) =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m k) $$ (i, ia) * u $v ia *\n             complex_of_real (C off kk)))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "finally"], ["proof (chain)\npicking this:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m k) $$ (i, ia) * u $v ia *\n             complex_of_real (C off kk)))", "have \"(A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n        Re (\\<Sum>i = 0..<n. P $$ (j, i) * (\\<Sum>ia = 0..<n. (J ^\\<^sub>m k) $$ (i, ia) * C off kk * u $v ia))\""], ["proof (prove)\nusing this:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m k) $$ (i, ia) * u $v ia *\n             complex_of_real (C off kk)))\n\ngoal (1 subgoal):\n 1. (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n    Re (\\<Sum>i = 0..<n.\n           P $$ (j, i) *\n           (\\<Sum>ia = 0..<n.\n               (J ^\\<^sub>m k) $$ (i, ia) * complex_of_real (C off kk) *\n               u $v ia))", "unfolding k_def"], ["proof (prove)\nusing this:\n  (A ^\\<^sub>m K off kk *\\<^sub>v v) $v j * C off kk =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m K off kk) $$ (i, ia) * u $v ia *\n             complex_of_real (C off kk)))\n\ngoal (1 subgoal):\n 1. (A ^\\<^sub>m K off kk *\\<^sub>v v) $v j * C off kk =\n    Re (\\<Sum>i = 0..<n.\n           P $$ (j, i) *\n           (\\<Sum>ia = 0..<n.\n               (J ^\\<^sub>m K off kk) $$ (i, ia) *\n               complex_of_real (C off kk) *\n               u $v ia))", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  (A ^\\<^sub>m k *\\<^sub>v v) $v j * C off kk =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m k) $$ (i, ia) * complex_of_real (C off kk) *\n             u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "}"], ["proof (state)\nthis:\n  (A ^\\<^sub>m K off ?kk2 *\\<^sub>v v) $v j * C off ?kk2 =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m K off ?kk2) $$ (i, ia) *\n             complex_of_real (C off ?kk2) *\n             u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "note A_to_u = this"], ["proof (state)\nthis:\n  (A ^\\<^sub>m K off ?kk2 *\\<^sub>v v) $v j * C off ?kk2 =\n  Re (\\<Sum>i = 0..<n.\n         P $$ (j, i) *\n         (\\<Sum>ia = 0..<n.\n             (J ^\\<^sub>m K off ?kk2) $$ (i, ia) *\n             complex_of_real (C off ?kk2) *\n             u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define F where \"F = (\\<Sum>ia\\<in>I. a ia * Lam ia ^ off)\""], ["proof (state)\nthis:\n  F = (\\<Sum>ia\\<in>I. a ia * Lam ia ^ off)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"G \\<longlonglongrightarrow> \n       Re (\\<Sum>i = 0..<n. P $$ (j, i) *\n           (\\<Sum>ia = 0..<n. (if ia \\<in> I \\<and> i = ia - (m - 1) then (Lam ia)^off else 0) * u $v ia))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<longlonglongrightarrow> Re (\\<Sum>i = 0..<n.\n P $$ (j, i) *\n (\\<Sum>ia = 0..<n.\n     (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off else 0) *\n     u $v ia))", "unfolding A_to_u G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        Re (\\<Sum>i = 0..<n.\n               P $$ (j, i) *\n               (\\<Sum>ia = 0..<n.\n                   (J ^\\<^sub>m K off k) $$ (i, ia) *\n                   complex_of_real (C off k) *\n                   u $v ia)))\n    \\<longlonglongrightarrow> Re (\\<Sum>i = 0..<n.\n                                     P $$ (j, i) *\n                                     (\\<Sum>ia = 0..<n.\n   (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off else 0) *\n   u $v ia))", "by (rule tendsto_Re[OF tendsto_sum[OF tendsto_mult[OF _ \n        tendsto_sum[OF tendsto_mult[OF limit_jordan_matrix]]]]], auto)"], ["proof (state)\nthis:\n  G \\<longlonglongrightarrow> Re (\\<Sum>i = 0..<n.\n                                     P $$ (j, i) *\n                                     (\\<Sum>ia = 0..<n.\n   (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off else 0) *\n   u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  G \\<longlonglongrightarrow> Re (\\<Sum>i = 0..<n.\n                                     P $$ (j, i) *\n                                     (\\<Sum>ia = 0..<n.\n   (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off else 0) *\n   u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"(\\<Sum>i = 0..<n. P $$ (j, i) *\n           (\\<Sum>ia = 0..<n. (if ia \\<in> I \\<and> i = ia - (m - 1) then (Lam ia)^off else 0) * u $v ia))\n      = (\\<Sum>i = 0..<n. (\\<Sum>ia \\<in> I. (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) * ((Lam ia)^off * u $v ia)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        P $$ (j, i) *\n        (\\<Sum>ia = 0..<n.\n            (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off\n             else 0) *\n            u $v ia)) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>ia\\<in>I.\n          (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) *\n          (Lam ia ^ off * u $v ia))", "by (rule sum.cong[OF refl], unfold sum_distrib_left, subst (2) sum.mono_neutral_left[of \"{0..<n}\"],\n        insert I_n, auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      P $$ (j, i) *\n      (\\<Sum>ia = 0..<n.\n          (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off else 0) *\n          u $v ia)) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>ia\\<in>I.\n        (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) *\n        (Lam ia ^ off * u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      P $$ (j, i) *\n      (\\<Sum>ia = 0..<n.\n          (if ia \\<in> I \\<and> i = ia - (m - 1) then Lam ia ^ off else 0) *\n          u $v ia)) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>ia\\<in>I.\n        (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) *\n        (Lam ia ^ off * u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (\\<Sum>ia \\<in> I. (\\<Sum>i = 0..<n. (if i = ia - (m - 1) then P $$ (j, i) else 0)) * ((Lam ia)^off * u $v ia))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        \\<Sum>ia\\<in>I.\n          (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) *\n          (Lam ia ^ off * u $v ia)) =\n    (\\<Sum>ia\\<in>I.\n       (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n       (Lam ia ^ off * u $v ia))", "unfolding sum.swap[of _ I] sum_distrib_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ja\\<in>I.\n       \\<Sum>i = 0..<n.\n          (if ja \\<in> I \\<and> i = ja - (m - 1) then P $$ (j, i) else 0) *\n          (Lam ja ^ off * u $v ja)) =\n    (\\<Sum>ia\\<in>I.\n       \\<Sum>n = 0..<n.\n          (if n = ia - (m - 1) then P $$ (j, n) else 0) *\n          (Lam ia ^ off * u $v ia))", "by (rule sum.cong[OF refl], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      \\<Sum>ia\\<in>I.\n        (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) *\n        (Lam ia ^ off * u $v ia)) =\n  (\\<Sum>ia\\<in>I.\n     (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n     (Lam ia ^ off * u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      \\<Sum>ia\\<in>I.\n        (if ia \\<in> I \\<and> i = ia - (m - 1) then P $$ (j, i) else 0) *\n        (Lam ia ^ off * u $v ia)) =\n  (\\<Sum>ia\\<in>I.\n     (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n     (Lam ia ^ off * u $v ia))\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = (\\<Sum>ia \\<in> I. cc ia * (Lam ia)^off)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>I.\n       (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n       (Lam ia ^ off * u $v ia)) =\n    (\\<Sum>ia\\<in>I. cc ia * Lam ia ^ off)", "unfolding cc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>I.\n       (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n       (Lam ia ^ off * u $v ia)) =\n    (\\<Sum>ia\\<in>I.\n       (\\<Sum>k = 0..<n. if k = ia - (m - 1) then P $$ (j, k) else 0) *\n       u $v ia *\n       Lam ia ^ off)", "by (rule sum.cong[OF refl], simp)"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<in>I.\n     (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n     (Lam ia ^ off * u $v ia)) =\n  (\\<Sum>ia\\<in>I. cc ia * Lam ia ^ off)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<in>I.\n     (\\<Sum>i = 0..<n. if i = ia - (m - 1) then P $$ (j, i) else 0) *\n     (Lam ia ^ off * u $v ia)) =\n  (\\<Sum>ia\\<in>I. cc ia * Lam ia ^ off)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "have \"\\<dots> = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>I. cc ia * Lam ia ^ off) = F", "unfolding cc_def a_def F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>I.\n       (\\<Sum>k = 0..<n. if k = ia - (m - 1) then P $$ (j, k) else 0) *\n       u $v ia *\n       Lam ia ^ off) =\n    (\\<Sum>ia\\<in>I. P $$ (j, ia - (m - 1)) * u $v ia * Lam ia ^ off)", "by (rule sum.cong[OF refl], insert I_n, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<in>I. cc ia * Lam ia ^ off) = F\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "finally"], ["proof (chain)\npicking this:\n  G \\<longlonglongrightarrow> Re F", "have tend3: \"G \\<longlonglongrightarrow> Re F\""], ["proof (prove)\nusing this:\n  G \\<longlonglongrightarrow> Re F\n\ngoal (1 subgoal):\n 1. G \\<longlonglongrightarrow> Re F", "."], ["proof (state)\nthis:\n  G \\<longlonglongrightarrow> Re F\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from this[unfolded LIMSEQ_iff, rule_format, of \"B / 2\"] B"], ["proof (chain)\npicking this:\n  0 < B / 2 \\<Longrightarrow>\n  \\<exists>no. \\<forall>n\\<ge>no. norm (G n - Re F) < B / 2\n  0 < B", "obtain kk where kk: \"\\<And> k. k \\<ge> kk \\<Longrightarrow> norm (G k - Re F) < B / 2\""], ["proof (prove)\nusing this:\n  0 < B / 2 \\<Longrightarrow>\n  \\<exists>no. \\<forall>n\\<ge>no. norm (G n - Re F) < B / 2\n  0 < B\n\ngoal (1 subgoal):\n 1. (\\<And>kk.\n        (\\<And>k.\n            kk \\<le> k \\<Longrightarrow>\n            norm (G k - Re F) < B / 2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kk \\<le> ?k \\<Longrightarrow> norm (G ?k - Re F) < B / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "from Bound"], ["proof (chain)\npicking this:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k", "obtain kk' where kk': \"\\<And> k. k \\<ge> kk' \\<Longrightarrow> B \\<le> G k\""], ["proof (prove)\nusing this:\n  \\<exists>k'. \\<forall>k\\<ge>k'. B \\<le> G k\n\ngoal (1 subgoal):\n 1. (\\<And>kk'.\n        (\\<And>k.\n            kk' \\<le> k \\<Longrightarrow> B \\<le> G k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kk' \\<le> ?k \\<Longrightarrow> B \\<le> G ?k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "define k where \"k = max kk kk'\""], ["proof (state)\nthis:\n  k = max kk kk'\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "with kk kk'"], ["proof (chain)\npicking this:\n  kk \\<le> ?k \\<Longrightarrow> norm (G ?k - Re F) < B / 2\n  kk' \\<le> ?k \\<Longrightarrow> B \\<le> G ?k\n  k = max kk kk'", "have 1: \"norm (G k - Re F) < B / 2\" \"B \\<le> G k\""], ["proof (prove)\nusing this:\n  kk \\<le> ?k \\<Longrightarrow> norm (G ?k - Re F) < B / 2\n  kk' \\<le> ?k \\<Longrightarrow> B \\<le> G ?k\n  k = max kk kk'\n\ngoal (1 subgoal):\n 1. norm (G k - Re F) < B / 2 &&& B \\<le> G k", "by auto"], ["proof (state)\nthis:\n  norm (G k - Re F) < B / 2\n  B \\<le> G k\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "with B"], ["proof (chain)\npicking this:\n  0 < B\n  norm (G k - Re F) < B / 2\n  B \\<le> G k", "have \"Re F > 0\""], ["proof (prove)\nusing this:\n  0 < B\n  norm (G k - Re F) < B / 2\n  B \\<le> G k\n\ngoal (1 subgoal):\n 1. 0 < Re F", "by (smt real_norm_def field_sum_of_halves)"], ["proof (state)\nthis:\n  0 < Re F\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "}"], ["proof (state)\nthis:\n  0 < Re (\\<Sum>ia\\<in>I. a ia * Lam ia ^ ?off2)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < Re (\\<Sum>ia\\<in>I. a ia * Lam ia ^ ?off2)\n\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_theorem: \"(m, 1) \\<in> set n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, 1) \\<in> set n_as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (m, 1) \\<in> set n_as", "from main_step"], ["proof (chain)\npicking this:\n  \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)", "obtain a where pos: \"\\<And> l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)\""], ["proof (prove)\nusing this:\n  \\<exists>a. \\<forall>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (\\<And>l. 0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ l)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < Re (\\<Sum>i\\<in>I. a i * Lam i ^ ?l)\n\ngoal (1 subgoal):\n 1. (m, 1) \\<in> set n_as", "have \"1 \\<in> Lam ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> Lam ` I", "proof (rule sum_root_unity_power_pos_implies_1[of a Lam I, OF pos])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       \\<exists>d. d \\<noteq> 0 \\<and> Lam i ^ d = 1", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       \\<exists>d. d \\<noteq> 0 \\<and> Lam i ^ d = 1", "assume \"i \\<in> I\""], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       \\<exists>d. d \\<noteq> 0 \\<and> Lam i ^ d = 1", "from d[OF I_Lam[OF this] cmod_Lam[OF this]]"], ["proof (chain)\npicking this:\n  Lam i ^ d (Lam i) = 1 \\<and> d (Lam i) \\<noteq> 0", "show \"\\<exists>d. d \\<noteq> 0 \\<and> Lam i ^ d = 1\""], ["proof (prove)\nusing this:\n  Lam i ^ d (Lam i) = 1 \\<and> d (Lam i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<noteq> 0 \\<and> Lam i ^ d = 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>d. d \\<noteq> 0 \\<and> Lam i ^ d = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<in> Lam ` I\n\ngoal (1 subgoal):\n 1. (m, 1) \\<in> set n_as", "then"], ["proof (chain)\npicking this:\n  1 \\<in> Lam ` I", "obtain i where i: \"i \\<in> I\" and \"Lam i = 1\""], ["proof (prove)\nusing this:\n  1 \\<in> Lam ` I\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; Lam i = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> I\n  Lam i = 1\n\ngoal (1 subgoal):\n 1. (m, 1) \\<in> set n_as", "with I_Lam[OF i]"], ["proof (chain)\npicking this:\n  (m, Lam i) \\<in> set n_as\n  i \\<in> I\n  Lam i = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (m, Lam i) \\<in> set n_as\n  i \\<in> I\n  Lam i = 1\n\ngoal (1 subgoal):\n 1. (m, 1) \\<in> set n_as", "by auto"], ["proof (state)\nthis:\n  (m, 1) \\<in> set n_as\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma nonneg_sr_1_largest_jb:\n  assumes nonneg: \"nonneg_mat A\" \n  and jnf: \"jordan_nf (map_mat complex_of_real A) n_as\" \n  and mem: \"(m, lam) \\<in> set n_as\" \n  and lam1: \"cmod lam = 1\"\n  and sr1: \"\\<And>x. poly (char_poly A) x = 0 \\<Longrightarrow> x \\<le> 1\" \n  shows \"\\<exists> M. M \\<ge> m \\<and> (M,1) \\<in> set n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "note jnf' = jnf[unfolded jordan_nf_def]"], ["proof (state)\nthis:\n  0 \\<notin> fst ` set n_as \\<and>\n  similar_mat (of_real_hom.mat_hom A) (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "from jnf' similar_matD[OF jnf'[THEN conjunct2]]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and>\n  similar_mat (of_real_hom.mat_hom A) (jordan_matrix n_as)\n  \\<exists>n P Q.\n     {of_real_hom.mat_hom A, jordan_matrix n_as, P, Q}\n     \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and>\n     of_real_hom.mat_hom A = P * jordan_matrix n_as * Q", "obtain n \n    where A: \"A \\<in> carrier_mat n n\" and n_as0: \"0 \\<notin> fst ` set n_as\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and>\n  similar_mat (of_real_hom.mat_hom A) (jordan_matrix n_as)\n  \\<exists>n P Q.\n     {of_real_hom.mat_hom A, jordan_matrix n_as, P, Q}\n     \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and>\n     of_real_hom.mat_hom A = P * jordan_matrix n_as * Q\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>A \\<in> carrier_mat n n; 0 \\<notin> fst ` set n_as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  0 \\<notin> fst ` set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "let ?M = \"{ m. \\<exists> lam. (m,lam) \\<in> set n_as \\<and> cmod lam = 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "have m: \"m \\<in> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "using mem lam1"], ["proof (prove)\nusing this:\n  (m, lam) \\<in> set n_as\n  cmod lam = 1\n\ngoal (1 subgoal):\n 1. m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "by auto"], ["proof (state)\nthis:\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "have fin: \"finite ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "by (rule finite_subset[OF _ finite_set[of \"map fst n_as\"]], force)"], ["proof (state)\nthis:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "define M where \"M = Max ?M\""], ["proof (state)\nthis:\n  M = Max {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "have \"M \\<in> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "using fin m"], ["proof (prove)\nusing this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. M \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "unfolding M_def"], ["proof (prove)\nusing this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. Max {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n    \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "using Max_in"], ["proof (prove)\nusing this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n\ngoal (1 subgoal):\n 1. Max {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n    \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "by blast"], ["proof (state)\nthis:\n  M \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "then"], ["proof (chain)\npicking this:\n  M \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "obtain Lam where M: \"(M,Lam) \\<in> set n_as\" \"cmod Lam = 1\""], ["proof (prove)\nusing this:\n  M \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. (\\<And>Lam.\n        \\<lbrakk>(M, Lam) \\<in> set n_as; cmod Lam = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (M, Lam) \\<in> set n_as\n  cmod Lam = 1\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "from m fin"], ["proof (chain)\npicking this:\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "have mM: \"m \\<le> M\""], ["proof (prove)\nusing this:\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. m \\<le> M", "unfolding M_def"], ["proof (prove)\nusing this:\n  m \\<in> {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n\ngoal (1 subgoal):\n 1. m \\<le> Max {m. \\<exists>lam.\n                       (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "by simp"], ["proof (state)\nthis:\n  m \\<le> M\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "interpret spectral_radius_1_jnf_max A n M Lam"], ["proof (prove)\ngoal (1 subgoal):\n 1. spectral_radius_1_jnf_max A n M Lam n_as", "proof (unfold_locales, rule A, rule nonneg, rule jnf, rule M, rule M, rule sr1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "fix k la"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "assume kla: \"(k, la) \\<in> set n_as\""], ["proof (state)\nthis:\n  (k, la) \\<in> set n_as\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "with fin"], ["proof (chain)\npicking this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  (k, la) \\<in> set n_as", "have 1: \"cmod la = 1 \\<longrightarrow> k \\<le> M\""], ["proof (prove)\nusing this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  (k, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<longrightarrow> k \\<le> M", "unfolding M_def"], ["proof (prove)\nusing this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  (k, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<longrightarrow>\n    k \\<le> Max {m. \\<exists>lam.\n                       (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "using Max_ge"], ["proof (prove)\nusing this:\n  finite {m. \\<exists>lam. (m, lam) \\<in> set n_as \\<and> cmod lam = 1}\n  (k, la) \\<in> set n_as\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> ?x \\<le> Max ?A\n\ngoal (1 subgoal):\n 1. cmod la = 1 \\<longrightarrow>\n    k \\<le> Max {m. \\<exists>lam.\n                       (m, lam) \\<in> set n_as \\<and> cmod lam = 1}", "by blast"], ["proof (state)\nthis:\n  cmod la = 1 \\<longrightarrow> k \\<le> M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "obtain ks f where decomp: \"decompose_prod_root_unity (char_poly A) = (ks, f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ks f.\n        decompose_prod_root_unity (char_poly A) = (ks, f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  decompose_prod_root_unity (char_poly A) = (ks, f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "from n_as0 kla"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as\n  (k, la) \\<in> set n_as", "have k0: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as\n  (k, la) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "let ?cA = \"map_mat complex_of_real A\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "from split_list[OF kla]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs", "obtain as bs where nas: \"n_as = as @ (k,la) # bs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (k, la) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        n_as = as @ (k, la) # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n_as = as @ (k, la) # bs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "have rt: \"poly (char_poly ?cA) la = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom A)) la = 0", "using k0"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom A)) la = 0", "unfolding jordan_nf_char_poly[OF jnf] nas poly_prod_list prod_list_zero_iff"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> set (map (\\<lambda>p. poly p la)\n                  (map (\\<lambda>(n, a). [:- a, 1:] ^ n)\n                    (as @ (k, la) # bs)))", "by auto"], ["proof (state)\nthis:\n  poly (char_poly (of_real_hom.mat_hom A)) la = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "have sumlist_nf: \"sum_list (map fst n_as) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "have \"sum_list (map fst n_as) = dim_row (jordan_matrix n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = dim_row (jordan_matrix n_as)", "by simp"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = dim_row (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "also"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = dim_row (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "have \"\\<dots> = dim_row ?cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (jordan_matrix n_as) = dim_row (of_real_hom.mat_hom A)", "using similar_matD[OF jnf'[THEN conjunct2]]"], ["proof (prove)\nusing this:\n  \\<exists>n P Q.\n     {of_real_hom.mat_hom A, jordan_matrix n_as, P, Q}\n     \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and>\n     of_real_hom.mat_hom A = P * jordan_matrix n_as * Q\n\ngoal (1 subgoal):\n 1. dim_row (jordan_matrix n_as) = dim_row (of_real_hom.mat_hom A)", "by auto"], ["proof (state)\nthis:\n  dim_row (jordan_matrix n_as) = dim_row (of_real_hom.mat_hom A)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "finally"], ["proof (chain)\npicking this:\n  sum_list (map fst n_as) = dim_row (of_real_hom.mat_hom A)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map fst n_as) = dim_row (of_real_hom.mat_hom A)\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "using A"], ["proof (prove)\nusing this:\n  sum_list (map fst n_as) = dim_row (of_real_hom.mat_hom A)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. sum_list (map fst n_as) = n", "by auto"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map fst n_as) = n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "from this[unfolded nas] k0"], ["proof (chain)\npicking this:\n  sum_list (map fst (as @ (k, la) # bs)) = n\n  k \\<noteq> 0", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sum_list (map fst (as @ (k, la) # bs)) = n\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "from perron_frobenius_for_complexity_jnf(4)[OF A n0 nonneg sr1 decomp rt]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      poly (char_poly A) x = 0 \\<Longrightarrow>\n      poly (char_poly A) x = 0) \\<Longrightarrow>\n  cmod la \\<le> 1", "have \"cmod la \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      poly (char_poly A) x = 0 \\<Longrightarrow>\n      poly (char_poly A) x = 0) \\<Longrightarrow>\n  cmod la \\<le> 1\n\ngoal (1 subgoal):\n 1. cmod la \\<le> 1", "."], ["proof (state)\nthis:\n  cmod la \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0\n 2. \\<And>k la.\n       (k, la) \\<in> set n_as \\<Longrightarrow>\n       cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "with 1"], ["proof (chain)\npicking this:\n  cmod la = 1 \\<longrightarrow> k \\<le> M\n  cmod la \\<le> 1", "show \"cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)\""], ["proof (prove)\nusing this:\n  cmod la = 1 \\<longrightarrow> k \\<le> M\n  cmod la \\<le> 1\n\ngoal (1 subgoal):\n 1. cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)", "by auto"], ["proof (state)\nthis:\n  cmod la \\<le> 1 \\<and> (cmod la = 1 \\<longrightarrow> k \\<le> M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (char_poly A) x = 0 \\<Longrightarrow> poly (char_poly A) x = 0", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "from main_theorem"], ["proof (chain)\npicking this:\n  (M, 1) \\<in> set n_as", "show ?thesis"], ["proof (prove)\nusing this:\n  (M, 1) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "using mM"], ["proof (prove)\nusing this:\n  (M, 1) \\<in> set n_as\n  m \\<le> M\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as", "by auto"], ["proof (state)\nthis:\n  \\<exists>M\\<ge>m. (M, 1) \\<in> set n_as\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const(open) spectral_radius"], ["", "lemma (in ring_hom) hom_smult_mat: \"mat\\<^sub>h (a \\<cdot>\\<^sub>m A) = hom a \\<cdot>\\<^sub>m mat\\<^sub>h A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat\\<^sub>h (a \\<cdot>\\<^sub>m A) = hom a \\<cdot>\\<^sub>m mat\\<^sub>h A", "by (rule eq_matI, auto simp: hom_mult)"], ["", "lemma root_char_poly_smult: fixes A :: \"complex mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and k: \"k \\<noteq> 0\" \nshows \"(poly (char_poly (k \\<cdot>\\<^sub>m A)) x = 0) = (poly (char_poly A) (x / k) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (char_poly (k \\<cdot>\\<^sub>m A)) x = 0) =\n    (poly (char_poly A) (x / k) = 0)", "using order_char_poly_smult[OF A k, of x]"], ["proof (prove)\nusing this:\n  Polynomial.order x (char_poly (k \\<cdot>\\<^sub>m A)) =\n  Polynomial.order (x / k) (char_poly A)\n\ngoal (1 subgoal):\n 1. (poly (char_poly (k \\<cdot>\\<^sub>m A)) x = 0) =\n    (poly (char_poly A) (x / k) = 0)", "by (metis A degree_0 degree_monic_char_poly monic_degree_0 order_root smult_carrier_mat)"], ["", "theorem real_nonneg_mat_spectral_radius_largest_jordan_block: \n  assumes \"real_nonneg_mat A\" \n  and \"jordan_nf A n_as\"\n  and \"(m, lam) \\<in> set n_as\" \n  and \"cmod lam = spectral_radius A\" \nshows \"\\<exists> M \\<ge> m. (M, of_real (spectral_radius A)) \\<in> set n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from similar_matD[OF assms(2)[unfolded jordan_nf_def, THEN conjunct2]]"], ["proof (chain)\npicking this:\n  \\<exists>n P Q.\n     {A, jordan_matrix n_as, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and> A = P * jordan_matrix n_as * Q", "obtain n where\n    A: \"A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  \\<exists>n P Q.\n     {A, jordan_matrix n_as, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and>\n     Q * P = 1\\<^sub>m n \\<and> A = P * jordan_matrix n_as * Q\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        A \\<in> carrier_mat n n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "let ?c = complex_of_real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "define B where \"B = map_mat Re A\""], ["proof (state)\nthis:\n  B = map_mat Re A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have B: \"B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat Re A \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. map_mat Re A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have AB: \"A = map_mat ?c B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = of_real_hom.mat_hom B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = of_real_hom.mat_hom (map_mat Re A)", "using assms(1)"], ["proof (prove)\nusing this:\n  real_nonneg_mat A\n\ngoal (1 subgoal):\n 1. A = of_real_hom.mat_hom (map_mat Re A)", "by (auto simp: real_nonneg_mat_def elements_mat_def)"], ["proof (state)\nthis:\n  A = of_real_hom.mat_hom B\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have nonneg: \"nonneg_mat B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_mat B", "using assms(1)"], ["proof (prove)\nusing this:\n  real_nonneg_mat A\n\ngoal (1 subgoal):\n 1. nonneg_mat B", "unfolding AB"], ["proof (prove)\nusing this:\n  real_nonneg_mat (of_real_hom.mat_hom B)\n\ngoal (1 subgoal):\n 1. nonneg_mat B", "by (auto simp: real_nonneg_mat_def elements_mat_def nonneg_mat_def)"], ["proof (state)\nthis:\n  nonneg_mat B\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "let ?sr = \"spectral_radius A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "proof (cases \"?sr = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "case False"], ["proof (state)\nthis:\n  spectral_radius A \\<noteq> 0\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "define isr where \"isr = inverse ?sr\""], ["proof (state)\nthis:\n  isr = inverse (spectral_radius A)\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "let ?nas = \"map (\\<lambda>(n, a). (n, ?c isr * a)) n_as\""], ["proof (state)\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from False"], ["proof (chain)\npicking this:\n  spectral_radius A \\<noteq> 0", "have isr0: \"isr \\<noteq> 0\""], ["proof (prove)\nusing this:\n  spectral_radius A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isr \\<noteq> 0", "unfolding isr_def"], ["proof (prove)\nusing this:\n  spectral_radius A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (spectral_radius A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  isr \\<noteq> 0\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence cisr0: \"?c isr \\<noteq> 0\""], ["proof (prove)\nusing this:\n  isr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. complex_of_real isr \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  complex_of_real isr \\<noteq> 0\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from False assms(4)"], ["proof (chain)\npicking this:\n  spectral_radius A \\<noteq> 0\n  cmod lam = spectral_radius A", "have isr_pos: \"isr > 0\""], ["proof (prove)\nusing this:\n  spectral_radius A \\<noteq> 0\n  cmod lam = spectral_radius A\n\ngoal (1 subgoal):\n 1. 0 < isr", "unfolding isr_def"], ["proof (prove)\nusing this:\n  spectral_radius A \\<noteq> 0\n  cmod lam = spectral_radius A\n\ngoal (1 subgoal):\n 1. 0 < inverse (spectral_radius A)", "by (smt norm_ge_zero positive_imp_inverse_positive)"], ["proof (state)\nthis:\n  0 < isr\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "define C where \"C = isr \\<cdot>\\<^sub>m B\""], ["proof (state)\nthis:\n  C = isr \\<cdot>\\<^sub>m B\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have C: \"C \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> carrier_mat n n", "using B"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. C \\<in> carrier_mat n n", "unfolding C_def"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. isr \\<cdot>\\<^sub>m B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  C \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have BC: \"B = ?sr \\<cdot>\\<^sub>m C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = spectral_radius A \\<cdot>\\<^sub>m C", "using isr0"], ["proof (prove)\nusing this:\n  isr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B = spectral_radius A \\<cdot>\\<^sub>m C", "unfolding C_def isr_def"], ["proof (prove)\nusing this:\n  inverse (spectral_radius A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B =\n    spectral_radius A \\<cdot>\\<^sub>m\n    (inverse (spectral_radius A) \\<cdot>\\<^sub>m B)", "by auto"], ["proof (state)\nthis:\n  B = spectral_radius A \\<cdot>\\<^sub>m C\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have nonneg: \"nonneg_mat C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_mat C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_mat (isr \\<cdot>\\<^sub>m B)", "using isr_pos nonneg"], ["proof (prove)\nusing this:\n  0 < isr\n  nonneg_mat B\n\ngoal (1 subgoal):\n 1. nonneg_mat (isr \\<cdot>\\<^sub>m B)", "unfolding nonneg_mat_def elements_mat_def"], ["proof (prove)\nusing this:\n  0 < isr\n  \\<forall>a\\<in>set (concat\n                       (map (\\<lambda>i.\n                                map (\\<lambda>j. B $$ (i, j))\n                                 [0..<dim_col B])\n                         [0..<dim_row B])).\n     0 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (concat\n                         (map (\\<lambda>i.\n                                  map (\\<lambda>j.\n    (isr \\<cdot>\\<^sub>m B) $$ (i, j))\n                                   [0..<dim_col (isr \\<cdot>\\<^sub>m B)])\n                           [0..<dim_row (isr \\<cdot>\\<^sub>m B)])).\n       0 \\<le> a", "by auto"], ["proof (state)\nthis:\n  nonneg_mat C\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from jordan_nf_smult[OF assms(2)[unfolded AB] cisr0]"], ["proof (chain)\npicking this:\n  jordan_nf (complex_of_real isr \\<cdot>\\<^sub>m of_real_hom.mat_hom B)\n   (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)", "have jnf: \"jordan_nf (map_mat ?c C) ?nas\""], ["proof (prove)\nusing this:\n  jordan_nf (complex_of_real isr \\<cdot>\\<^sub>m of_real_hom.mat_hom B)\n   (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (1 subgoal):\n 1. jordan_nf (of_real_hom.mat_hom C)\n     (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)", "unfolding C_def"], ["proof (prove)\nusing this:\n  jordan_nf (complex_of_real isr \\<cdot>\\<^sub>m of_real_hom.mat_hom B)\n   (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (1 subgoal):\n 1. jordan_nf (of_real_hom.mat_hom (isr \\<cdot>\\<^sub>m B))\n     (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)", "by (auto simp: of_real_hom.hom_smult_mat)"], ["proof (state)\nthis:\n  jordan_nf (of_real_hom.mat_hom C)\n   (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from assms(3)"], ["proof (chain)\npicking this:\n  (m, lam) \\<in> set n_as", "have mem: \"(m, ?c isr * lam) \\<in> set ?nas\""], ["proof (prove)\nusing this:\n  (m, lam) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. (m, complex_of_real isr * lam)\n    \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)", "by auto"], ["proof (state)\nthis:\n  (m, complex_of_real isr * lam)\n  \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have 1: \"cmod (?c isr * lam) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real isr * lam) = 1", "using False isr_pos"], ["proof (prove)\nusing this:\n  spectral_radius A \\<noteq> 0\n  0 < isr\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real isr * lam) = 1", "unfolding isr_def norm_mult assms(4)"], ["proof (prove)\nusing this:\n  spectral_radius A \\<noteq> 0\n  0 < inverse (spectral_radius A)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real (inverse (spectral_radius A))) *\n    spectral_radius A =\n    1", "by (smt mult.commute norm_of_real right_inverse)"], ["proof (state)\nthis:\n  cmod (complex_of_real isr * lam) = 1\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "{"], ["proof (state)\nthis:\n  cmod (complex_of_real isr * lam) = 1\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "have B': \"map_mat ?c B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom B \\<in> carrier_mat n n", "using B"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. of_real_hom.mat_hom B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  of_real_hom.mat_hom B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "assume \"poly (char_poly C) x = 0\""], ["proof (state)\nthis:\n  poly (char_poly C) x = 0\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence \"poly (char_poly (map_mat ?c C)) (?c x) = 0\""], ["proof (prove)\nusing this:\n  poly (char_poly C) x = 0\n\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom C)) (complex_of_real x) = 0", "unfolding of_real_hom.char_poly_hom[OF C]"], ["proof (prove)\nusing this:\n  poly (char_poly C) x = 0\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real (char_poly C)) (complex_of_real x) = 0", "by auto"], ["proof (state)\nthis:\n  poly (char_poly (of_real_hom.mat_hom C)) (complex_of_real x) = 0\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence \"poly (char_poly A) (?c x / ?c isr) = 0\""], ["proof (prove)\nusing this:\n  poly (char_poly (of_real_hom.mat_hom C)) (complex_of_real x) = 0\n\ngoal (1 subgoal):\n 1. poly (char_poly A) (complex_of_real x / complex_of_real isr) = 0", "unfolding C_def of_real_hom.hom_smult_mat AB"], ["proof (prove)\nusing this:\n  poly\n   (char_poly (complex_of_real isr \\<cdot>\\<^sub>m of_real_hom.mat_hom B))\n   (complex_of_real x) =\n  0\n\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom B))\n     (complex_of_real x / complex_of_real isr) =\n    0", "unfolding root_char_poly_smult[OF B' cisr0]"], ["proof (prove)\nusing this:\n  poly (char_poly (of_real_hom.mat_hom B))\n   (complex_of_real x / complex_of_real isr) =\n  0\n\ngoal (1 subgoal):\n 1. poly (char_poly (of_real_hom.mat_hom B))\n     (complex_of_real x / complex_of_real isr) =\n    0", "."], ["proof (state)\nthis:\n  poly (char_poly A) (complex_of_real x / complex_of_real isr) = 0\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence \"eigenvalue A (?c x / ?c isr)\""], ["proof (prove)\nusing this:\n  poly (char_poly A) (complex_of_real x / complex_of_real isr) = 0\n\ngoal (1 subgoal):\n 1. eigenvalue A (complex_of_real x / complex_of_real isr)", "unfolding eigenvalue_root_char_poly[OF A]"], ["proof (prove)\nusing this:\n  poly (char_poly A) (complex_of_real x / complex_of_real isr) = 0\n\ngoal (1 subgoal):\n 1. poly (char_poly A) (complex_of_real x / complex_of_real isr) = 0", "."], ["proof (state)\nthis:\n  eigenvalue A (complex_of_real x / complex_of_real isr)\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence mem: \"cmod (?c x / ?c isr) \\<in> cmod ` spectrum A\""], ["proof (prove)\nusing this:\n  eigenvalue A (complex_of_real x / complex_of_real isr)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x / complex_of_real isr) \\<in> cmod ` spectrum A", "unfolding spectrum_def"], ["proof (prove)\nusing this:\n  eigenvalue A (complex_of_real x / complex_of_real isr)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x / complex_of_real isr)\n    \\<in> cmod ` Collect (eigenvalue A)", "by auto"], ["proof (state)\nthis:\n  cmod (complex_of_real x / complex_of_real isr) \\<in> cmod ` spectrum A\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from Max_ge[OF finite_imageI this]"], ["proof (chain)\npicking this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod (complex_of_real x / complex_of_real isr)\n  \\<le> Max (cmod ` spectrum A)", "have \"cmod (?c x / ?c isr) \\<le> ?sr\""], ["proof (prove)\nusing this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod (complex_of_real x / complex_of_real isr)\n  \\<le> Max (cmod ` spectrum A)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x / complex_of_real isr) \\<le> spectral_radius A", "unfolding Spectral_Radius.spectral_radius_def"], ["proof (prove)\nusing this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod (complex_of_real x / complex_of_real isr)\n  \\<le> Max (cmod ` spectrum A)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x / complex_of_real isr)\n    \\<le> Max (cmod ` spectrum A)", "using A card_finite_spectrum(1)"], ["proof (prove)\nusing this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod (complex_of_real x / complex_of_real isr)\n  \\<le> Max (cmod ` spectrum A)\n  A \\<in> carrier_mat n n\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow> finite (spectrum ?A)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x / complex_of_real isr)\n    \\<le> Max (cmod ` spectrum A)", "by blast"], ["proof (state)\nthis:\n  cmod (complex_of_real x / complex_of_real isr) \\<le> spectral_radius A\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence \"cmod (?c x) \\<le> 1\""], ["proof (prove)\nusing this:\n  cmod (complex_of_real x / complex_of_real isr) \\<le> spectral_radius A\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x) \\<le> 1", "using isr0 isr_pos"], ["proof (prove)\nusing this:\n  cmod (complex_of_real x / complex_of_real isr) \\<le> spectral_radius A\n  isr \\<noteq> 0\n  0 < isr\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x) \\<le> 1", "unfolding isr_def"], ["proof (prove)\nusing this:\n  cmod (complex_of_real x / complex_of_real (inverse (spectral_radius A)))\n  \\<le> spectral_radius A\n  inverse (spectral_radius A) \\<noteq> 0\n  0 < inverse (spectral_radius A)\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real x) \\<le> 1", "by (auto simp: field_simps norm_divide norm_mult)"], ["proof (state)\nthis:\n  cmod (complex_of_real x) \\<le> 1\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence \"x \\<le> 1\""], ["proof (prove)\nusing this:\n  cmod (complex_of_real x) \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<le> 1", "by auto"], ["proof (state)\nthis:\n  x \\<le> 1\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "}"], ["proof (state)\nthis:\n  poly (char_poly C) ?x2 = 0 \\<Longrightarrow> ?x2 \\<le> 1\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "note sr = this"], ["proof (state)\nthis:\n  poly (char_poly C) ?x2 = 0 \\<Longrightarrow> ?x2 \\<le> 1\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from nonneg_sr_1_largest_jb[OF nonneg jnf mem 1 sr]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      poly (char_poly C) x = 0 \\<Longrightarrow>\n      poly (char_poly C) x = 0) \\<Longrightarrow>\n  \\<exists>M\\<ge>m.\n     (M, 1)\n     \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)", "obtain M where\n      M: \"M \\<ge> m\" \"(M,1) \\<in> set ?nas\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      poly (char_poly C) x = 0 \\<Longrightarrow>\n      poly (char_poly C) x = 0) \\<Longrightarrow>\n  \\<exists>M\\<ge>m.\n     (M, 1)\n     \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>m \\<le> M;\n         (M, 1)\n         \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a))\n                     n_as)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<le> M\n  (M, 1)\n  \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from M(2)"], ["proof (chain)\npicking this:\n  (M, 1)\n  \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)", "obtain a where mem: \"(M,a) \\<in> set n_as\" and \"1 = ?c isr * a\""], ["proof (prove)\nusing this:\n  (M, 1)\n  \\<in> set (map (\\<lambda>(n, a). (n, complex_of_real isr * a)) n_as)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(M, a) \\<in> set n_as; 1 = complex_of_real isr * a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (M, a) \\<in> set n_as\n  1 = complex_of_real isr * a\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from this(2)"], ["proof (chain)\npicking this:\n  1 = complex_of_real isr * a", "have a: \"a = ?c ?sr\""], ["proof (prove)\nusing this:\n  1 = complex_of_real isr * a\n\ngoal (1 subgoal):\n 1. a = complex_of_real (spectral_radius A)", "using isr0"], ["proof (prove)\nusing this:\n  1 = complex_of_real isr * a\n  isr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a = complex_of_real (spectral_radius A)", "unfolding isr_def"], ["proof (prove)\nusing this:\n  1 = complex_of_real (inverse (spectral_radius A)) * a\n  inverse (spectral_radius A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a = complex_of_real (spectral_radius A)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  a = complex_of_real (spectral_radius A)\n\ngoal (2 subgoals):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n 2. spectral_radius A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "by (intro exI[of _ M], insert mem a M(1), auto)"], ["proof (state)\nthis:\n  \\<exists>M\\<ge>m. (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "case True"], ["proof (state)\nthis:\n  spectral_radius A = 0\n\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from jordan_nf_root_char_poly[OF assms(2,3)]"], ["proof (chain)\npicking this:\n  poly (char_poly A) lam = 0", "have \"eigenvalue A lam\""], ["proof (prove)\nusing this:\n  poly (char_poly A) lam = 0\n\ngoal (1 subgoal):\n 1. eigenvalue A lam", "unfolding eigenvalue_root_char_poly[OF A]"], ["proof (prove)\nusing this:\n  poly (char_poly A) lam = 0\n\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = 0", "."], ["proof (state)\nthis:\n  eigenvalue A lam\n\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "hence \"cmod lam \\<in> cmod ` spectrum A\""], ["proof (prove)\nusing this:\n  eigenvalue A lam\n\ngoal (1 subgoal):\n 1. cmod lam \\<in> cmod ` spectrum A", "unfolding spectrum_def"], ["proof (prove)\nusing this:\n  eigenvalue A lam\n\ngoal (1 subgoal):\n 1. cmod lam \\<in> cmod ` Collect (eigenvalue A)", "by auto"], ["proof (state)\nthis:\n  cmod lam \\<in> cmod ` spectrum A\n\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from Max_ge[OF finite_imageI this]"], ["proof (chain)\npicking this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod lam \\<le> Max (cmod ` spectrum A)", "have \"cmod lam \\<le> ?sr\""], ["proof (prove)\nusing this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod lam \\<le> Max (cmod ` spectrum A)\n\ngoal (1 subgoal):\n 1. cmod lam \\<le> spectral_radius A", "unfolding Spectral_Radius.spectral_radius_def"], ["proof (prove)\nusing this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod lam \\<le> Max (cmod ` spectrum A)\n\ngoal (1 subgoal):\n 1. cmod lam \\<le> Max (cmod ` spectrum A)", "using A card_finite_spectrum(1)"], ["proof (prove)\nusing this:\n  finite (spectrum A) \\<Longrightarrow>\n  cmod lam \\<le> Max (cmod ` spectrum A)\n  A \\<in> carrier_mat n n\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow> finite (spectrum ?A)\n\ngoal (1 subgoal):\n 1. cmod lam \\<le> Max (cmod ` spectrum A)", "by blast"], ["proof (state)\nthis:\n  cmod lam \\<le> spectral_radius A\n\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "from this[unfolded True]"], ["proof (chain)\npicking this:\n  cmod lam \\<le> 0", "have lam0: \"lam = 0\""], ["proof (prove)\nusing this:\n  cmod lam \\<le> 0\n\ngoal (1 subgoal):\n 1. lam = 0", "by auto"], ["proof (state)\nthis:\n  lam = 0\n\ngoal (1 subgoal):\n 1. spectral_radius A = 0 \\<Longrightarrow>\n    \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m.\n       (M, complex_of_real (spectral_radius A)) \\<in> set n_as", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, complex_of_real 0) \\<in> set n_as", "using assms(3)[unfolded lam0]"], ["proof (prove)\nusing this:\n  (m, 0) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>m. (M, complex_of_real 0) \\<in> set n_as", "by auto"], ["proof (state)\nthis:\n  \\<exists>M\\<ge>m. (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M\\<ge>m. (M, complex_of_real (spectral_radius A)) \\<in> set n_as\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}