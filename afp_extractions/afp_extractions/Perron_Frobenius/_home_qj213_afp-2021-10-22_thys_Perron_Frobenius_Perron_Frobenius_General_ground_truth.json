{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Perron_Frobenius_General.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma HMA_irreducible[transfer_rule]: \"((HMA_M :: _ \\<Rightarrow> _ ^ 'n ^ 'n \\<Rightarrow> _) ===> (=)) \n  irreducible_mat fixed_mat.irreducible\"", "lemma HMA_nonneg_irreducible_mat[transfer_rule]: \"(HMA_M ===> (=)) nonneg_irreducible_mat perron_frobenius\"", "lemma perron_frobenius_irreducible: fixes A :: \"real Matrix.mat\" and cA :: \"complex Matrix.mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" and n: \"n \\<noteq> 0\" and nonneg: \"nonneg_mat A\" \n    and irr: \"irreducible_mat A\" \n    and cA: \"cA = map_mat of_real A\"\n    and sr: \"sr = Spectral_Radius.spectral_radius cA\" \n  shows \n    \"eigenvalue A sr\"\n    \"order sr (char_poly A) = 1\"\n    \"0 < sr\"\n    \"eigenvalue cA \\<alpha> \\<Longrightarrow> cmod \\<alpha> \\<le> sr\"\n    \"eigenvalue cA \\<alpha> \\<Longrightarrow> cmod \\<alpha> = sr \\<Longrightarrow> order \\<alpha> (char_poly cA) = 1\" \n    \"\\<exists> k f. k \\<noteq> 0 \\<and> k \\<le> n \\<and> char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\"", "lemma permutation_mat_dim[simp]: \"permutation_mat n p \\<in> carrier_mat n n\" \n  \"dim_row (permutation_mat n p) = n\"\n  \"dim_col (permutation_mat n p) = n\"", "lemma permutation_mat_row[simp]: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow>\n  Matrix.row (permutation_mat n p) i = unit_vec n (inv p i)\"", "lemma permutation_mat_col[simp]: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow>\n  Matrix.col (permutation_mat n p) i = unit_vec n (p i)\"", "lemma permutation_mat_left: assumes A: \"A \\<in> carrier_mat n nc\" and p: \"p permutes {..<n}\" \n  shows \"permutation_mat n p * A = Matrix.mat n nc (\\<lambda> (i,j). A $$ (inv p i, j))\"", "lemma permutation_mat_right: assumes A: \"A \\<in> carrier_mat nr n\" and p: \"p permutes {..<n}\" \n  shows \"A * permutation_mat n p = Matrix.mat nr n (\\<lambda> (i,j). A $$ (i, p j))\"", "lemma permutes_lt: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow> p i < n\"", "lemma permutes_iff: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow> j < n \\<Longrightarrow> p i = p j \\<longleftrightarrow> i = j\"", "lemma permutation_mat_id_1: assumes p: \"p permutes {..<n}\" \n  shows \"permutation_mat n p * permutation_mat n (inv p) = 1\\<^sub>m n\"", "lemma permutation_mat_id_2: assumes p: \"p permutes {..<n}\" \n  shows \"permutation_mat n (inv p) * permutation_mat n p = 1\\<^sub>m n\"", "lemma permutation_mat_both: assumes A: \"A \\<in> carrier_mat n n\" and p: \"p permutes {..<n}\" \n  shows \"permutation_mat n p * Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j)) * permutation_mat n (inv p) = A\"", "lemma permutation_similar_mat: assumes A: \"A \\<in> carrier_mat n n\" and p: \"p permutes {..<n}\"\n  shows \"similar_mat A (Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j)))\"", "lemma det_four_block_mat_lower_left_zero: fixes A1 :: \"'a :: idom mat\" \n  assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A2: \"A2 \\<in> carrier_mat n m\" and A30: \"A3 = 0\\<^sub>m m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"  \nshows \"Determinant.det (four_block_mat A1 A2 A3 A4) = Determinant.det A1 * Determinant.det A4\"", "lemma char_poly_matrix_four_block_mat: assumes \n      A1: \"A1 \\<in> carrier_mat n n\"\n  and A2: \"A2 \\<in> carrier_mat n m\" \n  and A3: \"A3 \\<in> carrier_mat m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"\nshows \"char_poly_matrix (four_block_mat A1 A2 A3 A4) = \n  four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda> x. [:-x:]) A2) \n    (map_mat (\\<lambda> x. [:-x:]) A3) (char_poly_matrix A4)\"", "lemma char_poly_four_block_mat_lower_left_zero: fixes A :: \"'a :: idom mat\"\n  assumes A: \"A = four_block_mat B C (0\\<^sub>m m n) D\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and C: \"C \\<in> carrier_mat n m\"\n  and D: \"D \\<in> carrier_mat m m\"\nshows \"char_poly A = char_poly B * char_poly D\"", "lemma elements_mat_permutes: assumes p: \"p permutes {..< n}\" \n  and A: \"A \\<in> carrier_mat n n\" \n  and B: \"B = Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j))\" \nshows \"elements_mat A = elements_mat B\"", "lemma elements_mat_four_block_mat_supseteq: \n  assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A2: \"A2 \\<in> carrier_mat n m\" \n  and A3: \"A3 \\<in> carrier_mat m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"\nshows \"elements_mat (four_block_mat A1 A2 A3 A4) \\<supseteq> \n  (elements_mat A1 \\<union> elements_mat A2 \\<union> elements_mat A3 \\<union> elements_mat A4)\"", "lemma non_irreducible_mat_split: \n  fixes A :: \"'a :: idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and not: \"\\<not> irreducible_mat A\" \n  and n: \"n > 1\" \nshows \"\\<exists> n1 n2 B B1 B2 B4. similar_mat A B \\<and> elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>  \n       B1 \\<in> carrier_mat n1 n1 \\<and> B2 \\<in> carrier_mat n1 n2 \\<and> B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\"", "lemma non_irreducible_nonneg_mat_split: \n  fixes A :: \"'a :: linordered_idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and nonneg: \"nonneg_mat A\" \n  and not: \"\\<not> irreducible_mat A\" \n  and n: \"n > 1\" \nshows \"\\<exists> n1 n2 A1 A2. char_poly A = char_poly A1 * char_poly A2 \n    \\<and> nonneg_mat A1 \\<and> nonneg_mat A2\n    \\<and> A1 \\<in> carrier_mat n1 n1 \\<and> A2 \\<in> carrier_mat n2 n2\n    \\<and> 0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\"", "theorem perron_frobenius_nonneg: fixes A :: \"real Matrix.mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" and pos: \"nonneg_mat A\" and n: \"n \\<noteq> 0\" \n  shows \"\\<exists> sr ks f. \n    sr \\<ge> 0 \\<and> \n    0 \\<notin> set ks \\<and> ks \\<noteq> [] \\<and>\n    char_poly A = prod_list (map (\\<lambda> k. monom 1 k - [:sr ^ k:]) ks) * f \\<and>\n    (\\<forall> x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\"", "theorem perron_frobenius_non_neg: fixes A :: \"real ^ 'n ^ 'n\"\n  assumes pos: \"non_neg_mat A\" \n  shows \"\\<exists> sr ks f. \n    sr \\<ge> 0 \\<and> \n    0 \\<notin> set ks \\<and> ks \\<noteq> [] \\<and>\n    charpoly A = prod_list (map (\\<lambda> k. monom 1 k - [:sr ^ k:]) ks) * f \\<and>\n    (\\<forall> x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\"", "lemma perron_frobenius_for_complexity: fixes A :: \"real ^ 'n ^ 'n\" and f :: \"real poly\" \n  defines \"cA \\<equiv> map_matrix complex_of_real A\" \n  defines \"cf \\<equiv> map_poly complex_of_real f\" \n  assumes pos: \"non_neg_mat A\" \n   and sr: \"\\<And> x. poly (charpoly A) x = 0 \\<Longrightarrow> x \\<le> 1\"\n   and decomp: \"decompose_prod_root_unity (charpoly A) = (ks, f)\" \n  shows \"0 \\<notin> set ks\" \n   \"charpoly A = prod_root_unity ks * f\"\n   \"charpoly cA = prod_root_unity ks * cf\"\n   \"\\<And> x. poly (charpoly cA) x = 0 \\<Longrightarrow> cmod x \\<le> 1\" \n   \"\\<And> x. poly cf x = 0 \\<Longrightarrow> cmod x < 1\" \n   \"\\<And> x. cmod x = 1 \\<Longrightarrow> order x (charpoly cA) = length [k\\<leftarrow>ks . x ^ k = 1]\" \n   \"\\<And> x. cmod x = 1 \\<Longrightarrow> poly (charpoly cA) x = 0 \\<Longrightarrow> \\<exists> k \\<in> set ks. x^k = 1\"", "lemmas perron_frobenius_for_complexity_jnf = \n  perron_frobenius_for_complexity[unfolded atomize_imp atomize_all, \n    untransferred, cancel_card_constraint, rule_format]"], "translations": [["", "lemma HMA_irreducible[transfer_rule]: \"((HMA_M :: _ \\<Rightarrow> _ ^ 'n ^ 'n \\<Rightarrow> _) ===> (=)) \n  irreducible_mat fixed_mat.irreducible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) irreducible_mat fixed_mat.irreducible", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "case (1 a A)"], ["proof (state)\nthis:\n  HMA_M a A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "interpret fixed_mat A"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "let ?t = \"Bij_Nat.to_nat :: 'n \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "let ?f = \"Bij_Nat.from_nat :: nat \\<Rightarrow> 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "from 1[unfolded HMA_M_def]"], ["proof (chain)\npicking this:\n  a = from_hma\\<^sub>m A", "have a: \"a = from_hma\\<^sub>m A\" (is \"_ = ?A\")"], ["proof (prove)\nusing this:\n  a = from_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. a = from_hma\\<^sub>m A", "by auto"], ["proof (state)\nthis:\n  a = from_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "let ?n = \"CARD('n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have dim: \"dim_row a = ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row a = CARD('n)", "unfolding a"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (from_hma\\<^sub>m A) = CARD('n)", "by simp"], ["proof (state)\nthis:\n  dim_row a = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have id: \"{..<?n} = {0..<?n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<CARD('n)} = {0..<CARD('n)}", "by auto"], ["proof (state)\nthis:\n  {..<CARD('n)} = {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have Aij: \"A $ i $ j = ?A $$ (?t i, ?t j)\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $h i $h j = from_hma\\<^sub>m A $$ (Bij_Nat.to_nat i, Bij_Nat.to_nat j)", "by (metis (no_types, lifting) to_hma\\<^sub>m_def to_hma_from_hma\\<^sub>m vec_lambda_beta)"], ["proof (state)\nthis:\n  A $h ?i $h ?j =\n  from_hma\\<^sub>m A $$ (Bij_Nat.to_nat ?i, Bij_Nat.to_nat ?j)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have graph: \"graph_of_mat a = \n    {(?t i,?t j) | i j. A $ i $ j \\<noteq> 0}\" (is \"?G = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_of_mat a =\n    {(Bij_Nat.to_nat i, Bij_Nat.to_nat j) |i j.\n     A $h i $h j \\<noteq> (0::'a)}", "unfolding graph_of_mat_def dim Let_def id range_to_nat[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr {ij. a $$ ij \\<noteq> (0::'a)} (range Bij_Nat.to_nat) =\n    {(Bij_Nat.to_nat i, Bij_Nat.to_nat j) |i j.\n     A $h i $h j \\<noteq> (0::'a)}", "unfolding a Aij"], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr {ij. from_hma\\<^sub>m A $$ ij \\<noteq> (0::'a)}\n     (range Bij_Nat.to_nat) =\n    {(Bij_Nat.to_nat i, Bij_Nat.to_nat j) |i j.\n     from_hma\\<^sub>m A $$ (Bij_Nat.to_nat i, Bij_Nat.to_nat j) \\<noteq>\n     (0::'a)}", "by auto"], ["proof (state)\nthis:\n  graph_of_mat a =\n  {(Bij_Nat.to_nat i, Bij_Nat.to_nat j) |i j. A $h i $h j \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have \"irreducible_mat a = (\\<forall>i j. i \\<in> range ?t \\<longrightarrow> j \\<in> range ?t \\<longrightarrow> (i,j) \\<in> ?G^+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible_mat a =\n    (\\<forall>i j.\n        i \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n        j \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n        (i, j) \\<in> (graph_of_mat a)\\<^sup>+)", "unfolding irreducible_mat_def dim Let_def range_to_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i < CARD('n) \\<longrightarrow>\n        j < CARD('n) \\<longrightarrow>\n        (i, j) \\<in> (graph_of_mat a)\\<^sup>+) =\n    (\\<forall>i j.\n        i \\<in> {0..<CARD('n)} \\<longrightarrow>\n        j \\<in> {0..<CARD('n)} \\<longrightarrow>\n        (i, j) \\<in> (graph_of_mat a)\\<^sup>+)", "by auto"], ["proof (state)\nthis:\n  irreducible_mat a =\n  (\\<forall>i j.\n      i \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      j \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      (i, j) \\<in> (graph_of_mat a)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "also"], ["proof (state)\nthis:\n  irreducible_mat a =\n  (\\<forall>i j.\n      i \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      j \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      (i, j) \\<in> (graph_of_mat a)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have \"\\<dots> = (\\<forall> i j. (?t i, ?t j) \\<in> ?G^+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n        j \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n        (i, j) \\<in> (graph_of_mat a)\\<^sup>+) =\n    (\\<forall>i j.\n        (Bij_Nat.to_nat i, Bij_Nat.to_nat j) \\<in> (graph_of_mat a)\\<^sup>+)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i j.\n      i \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      j \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      (i, j) \\<in> (graph_of_mat a)\\<^sup>+) =\n  (\\<forall>i j.\n      (Bij_Nat.to_nat i, Bij_Nat.to_nat j) \\<in> (graph_of_mat a)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "also"], ["proof (state)\nthis:\n  (\\<forall>i j.\n      i \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      j \\<in> range Bij_Nat.to_nat \\<longrightarrow>\n      (i, j) \\<in> (graph_of_mat a)\\<^sup>+) =\n  (\\<forall>i j.\n      (Bij_Nat.to_nat i, Bij_Nat.to_nat j) \\<in> (graph_of_mat a)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "note part1 = calculation"], ["proof (state)\nthis:\n  irreducible_mat a =\n  (\\<forall>i j.\n      (Bij_Nat.to_nat i, Bij_Nat.to_nat j) \\<in> (graph_of_mat a)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have G: \"?G = map_prod ?t ?t ` G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_of_mat a = map_prod Bij_Nat.to_nat Bij_Nat.to_nat ` G", "unfolding graph G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Bij_Nat.to_nat i, Bij_Nat.to_nat j) |i j.\n     A $h i $h j \\<noteq> (0::'a)} =\n    map_prod Bij_Nat.to_nat Bij_Nat.to_nat `\n    {(i, j). A $h i $h j \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  graph_of_mat a = map_prod Bij_Nat.to_nat Bij_Nat.to_nat ` G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "have part2: \"(?t i, ?t j) \\<in> ?G^+ \\<longleftrightarrow> (i,j) \\<in> G^+\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Bij_Nat.to_nat i, Bij_Nat.to_nat j) \\<in> (graph_of_mat a)\\<^sup>+) =\n    ((i, j) \\<in> G\\<^sup>+)", "unfolding G"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Bij_Nat.to_nat i, Bij_Nat.to_nat j)\n     \\<in> (map_prod Bij_Nat.to_nat Bij_Nat.to_nat ` G)\\<^sup>+) =\n    ((i, j) \\<in> G\\<^sup>+)", "by (rule inj_trancl_image, simp add: inj_on_def)"], ["proof (state)\nthis:\n  ((Bij_Nat.to_nat ?i, Bij_Nat.to_nat ?j) \\<in> (graph_of_mat a)\\<^sup>+) =\n  ((?i, ?j) \\<in> G\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       HMA_M x y \\<Longrightarrow>\n       irreducible_mat x = fixed_mat.irreducible y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible_mat a = local.irreducible", "unfolding part1 part2 irreducible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j. (i, j) \\<in> G\\<^sup>+) = (UNIV \\<subseteq> G\\<^sup>+)", "by auto"], ["proof (state)\nthis:\n  irreducible_mat a = local.irreducible\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_nonneg_irreducible_mat[transfer_rule]: \"(HMA_M ===> (=)) nonneg_irreducible_mat perron_frobenius\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) nonneg_irreducible_mat perron_frobenius", "unfolding perron_frobenius_def pf_nonneg_mat_def perron_frobenius_axioms_def \n    nonneg_irreducible_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) (\\<lambda>A. nonneg_mat A \\<and> irreducible_mat A)\n     (\\<lambda>A. non_neg_mat A \\<and> fixed_mat.irreducible A)", "by transfer_prover"], ["", "end"], ["", "text \\<open>The main statements of Perron-Frobenius can now be transferred to JNF-matrices\\<close>"], ["", "lemma perron_frobenius_irreducible: fixes A :: \"real Matrix.mat\" and cA :: \"complex Matrix.mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" and n: \"n \\<noteq> 0\" and nonneg: \"nonneg_mat A\" \n    and irr: \"irreducible_mat A\" \n    and cA: \"cA = map_mat of_real A\"\n    and sr: \"sr = Spectral_Radius.spectral_radius cA\" \n  shows \n    \"eigenvalue A sr\"\n    \"order sr (char_poly A) = 1\"\n    \"0 < sr\"\n    \"eigenvalue cA \\<alpha> \\<Longrightarrow> cmod \\<alpha> \\<le> sr\"\n    \"eigenvalue cA \\<alpha> \\<Longrightarrow> cmod \\<alpha> = sr \\<Longrightarrow> order \\<alpha> (char_poly cA) = 1\" \n    \"\\<exists> k f. k \\<noteq> 0 \\<and> k \\<le> n \\<and> char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eigenvalue A sr &&& order sr (char_poly A) = 1 &&& 0 < sr) &&&\n    (eigenvalue cA \\<alpha> \\<Longrightarrow> cmod \\<alpha> \\<le> sr) &&&\n    (\\<lbrakk>eigenvalue cA \\<alpha>; cmod \\<alpha> = sr\\<rbrakk>\n     \\<Longrightarrow> order \\<alpha> (char_poly cA) = 1) &&&\n    \\<exists>k f.\n       k \\<noteq> 0 \\<and>\n       k \\<le> n \\<and>\n       char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof (atomize (full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow>\n     cmod \\<alpha> = sr \\<longrightarrow>\n     order \\<alpha> (char_poly cA) = 1) \\<and>\n    (\\<exists>k f.\n        k \\<noteq> 0 \\<and>\n        k \\<le> n \\<and>\n        char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow>\n     cmod \\<alpha> = sr \\<longrightarrow>\n     order \\<alpha> (char_poly cA) = 1) \\<and>\n    (\\<exists>k f.\n        k \\<noteq> 0 \\<and>\n        k \\<le> n \\<and>\n        char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr))", "from nonneg irr"], ["proof (chain)\npicking this:\n  nonneg_mat A\n  irreducible_mat A", "have irr: \"nonneg_irreducible_mat A\""], ["proof (prove)\nusing this:\n  nonneg_mat A\n  irreducible_mat A\n\ngoal (1 subgoal):\n 1. nonneg_irreducible_mat A", "unfolding nonneg_irreducible_mat_def"], ["proof (prove)\nusing this:\n  nonneg_mat A\n  irreducible_mat A\n\ngoal (1 subgoal):\n 1. nonneg_mat A \\<and> irreducible_mat A", "by auto"], ["proof (state)\nthis:\n  nonneg_irreducible_mat A\n\ngoal (1 subgoal):\n 1. (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow>\n     cmod \\<alpha> = sr \\<longrightarrow>\n     order \\<alpha> (char_poly cA) = 1) \\<and>\n    (\\<exists>k f.\n        k \\<noteq> 0 \\<and>\n        k \\<le> n \\<and>\n        char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr))", "note main = perron_frobenius.pf_main_connect[untransferred, cancel_card_constraint, OF A irr, \n    folded sr cA]"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> eigenvalue A sr\n  \\<lbrakk>eigenvalue cA ?\\<alpha>; n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cmod ?\\<alpha> \\<le> sr\n  n \\<noteq> 0 \\<Longrightarrow> order sr (char_poly A) = 1\n  \\<lbrakk>eigenvalue cA ?\\<alpha>; cmod ?\\<alpha> = sr;\n   n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> order ?\\<alpha> (char_poly cA) = 1\n  \\<lbrakk>?M = {ev. eigenvalue cA ev \\<and> cmod ev = sr}; ?k = card ?M;\n   n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?k \\<noteq> 0\n  \\<lbrakk>?M = {ev. eigenvalue cA ev \\<and> cmod ev = sr}; ?k = card ?M;\n   n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?k \\<le> n\n  \\<lbrakk>?M = {ev. eigenvalue cA ev \\<and> cmod ev = sr}; ?k = card ?M;\n   n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       char_poly A = (monom 1 ?k - [:sr ^ ?k:]) * f \\<and>\n                       (\\<forall>x.\n                           poly (map_poly complex_of_real f) x =\n                           0 \\<longrightarrow>\n                           cmod x < sr)\n  n \\<noteq> 0 \\<Longrightarrow> 0 < sr\n\ngoal (1 subgoal):\n 1. (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow>\n     cmod \\<alpha> = sr \\<longrightarrow>\n     order \\<alpha> (char_poly cA) = 1) \\<and>\n    (\\<exists>k f.\n        k \\<noteq> 0 \\<and>\n        k \\<le> n \\<and>\n        char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr))", "from main(5,6,7)[OF refl refl n]"], ["proof (chain)\npicking this:\n  card {ev. eigenvalue cA ev \\<and> cmod ev = sr} \\<noteq> 0\n  card {ev. eigenvalue cA ev \\<and> cmod ev = sr} \\<le> n\n  \\<exists>f.\n     char_poly A =\n     (monom 1 (card {ev. eigenvalue cA ev \\<and> cmod ev = sr}) -\n      [:sr ^ card {ev. eigenvalue cA ev \\<and> cmod ev = sr}:]) *\n     f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "have \"\\<exists> k f. k \\<noteq> 0 \\<and> k \\<le> n \\<and> char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\""], ["proof (prove)\nusing this:\n  card {ev. eigenvalue cA ev \\<and> cmod ev = sr} \\<noteq> 0\n  card {ev. eigenvalue cA ev \\<and> cmod ev = sr} \\<le> n\n  \\<exists>f.\n     char_poly A =\n     (monom 1 (card {ev. eigenvalue cA ev \\<and> cmod ev = sr}) -\n      [:sr ^ card {ev. eigenvalue cA ev \\<and> cmod ev = sr}:]) *\n     f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>k f.\n       k \\<noteq> 0 \\<and>\n       k \\<le> n \\<and>\n       char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by blast"], ["proof (state)\nthis:\n  \\<exists>k f.\n     k \\<noteq> 0 \\<and>\n     k \\<le> n \\<and>\n     char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow>\n     cmod \\<alpha> = sr \\<longrightarrow>\n     order \\<alpha> (char_poly cA) = 1) \\<and>\n    (\\<exists>k f.\n        k \\<noteq> 0 \\<and>\n        k \\<le> n \\<and>\n        char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr))", "with main(1,3,8)[OF n] main(2)[OF _ n] main(4)[OF _ _ n]"], ["proof (chain)\npicking this:\n  eigenvalue A sr\n  order sr (char_poly A) = 1\n  0 < sr\n  eigenvalue cA ?\\<alpha> \\<Longrightarrow> cmod ?\\<alpha> \\<le> sr\n  \\<lbrakk>eigenvalue cA ?\\<alpha>; cmod ?\\<alpha> = sr\\<rbrakk>\n  \\<Longrightarrow> order ?\\<alpha> (char_poly cA) = 1\n  \\<exists>k f.\n     k \\<noteq> 0 \\<and>\n     k \\<le> n \\<and>\n     char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "show ?case"], ["proof (prove)\nusing this:\n  eigenvalue A sr\n  order sr (char_poly A) = 1\n  0 < sr\n  eigenvalue cA ?\\<alpha> \\<Longrightarrow> cmod ?\\<alpha> \\<le> sr\n  \\<lbrakk>eigenvalue cA ?\\<alpha>; cmod ?\\<alpha> = sr\\<rbrakk>\n  \\<Longrightarrow> order ?\\<alpha> (char_poly cA) = 1\n  \\<exists>k f.\n     k \\<noteq> 0 \\<and>\n     k \\<le> n \\<and>\n     char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n    (eigenvalue cA \\<alpha> \\<longrightarrow>\n     cmod \\<alpha> = sr \\<longrightarrow>\n     order \\<alpha> (char_poly cA) = 1) \\<and>\n    (\\<exists>k f.\n        k \\<noteq> 0 \\<and>\n        k \\<le> n \\<and>\n        char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr))", "by auto"], ["proof (state)\nthis:\n  (eigenvalue A sr \\<and> order sr (char_poly A) = 1 \\<and> 0 < sr) \\<and>\n  (eigenvalue cA \\<alpha> \\<longrightarrow> cmod \\<alpha> \\<le> sr) \\<and>\n  (eigenvalue cA \\<alpha> \\<longrightarrow>\n   cmod \\<alpha> = sr \\<longrightarrow>\n   order \\<alpha> (char_poly cA) = 1) \\<and>\n  (\\<exists>k f.\n      k \\<noteq> 0 \\<and>\n      k \\<le> n \\<and>\n      char_poly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n          cmod x < sr))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now need permutations on matrices to show that a matrix if a matrix is not irreducible,\n  then it can be turned into a four-block-matrix by a permutation, where the lower left block is 0.\\<close>"], ["", "definition permutation_mat :: \"nat \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> 'a :: semiring_1 mat\" where\n  \"permutation_mat n p = Matrix.mat n n (\\<lambda> (i,j). (if i = p j then 1 else 0))\""], ["", "no_notation m_inv (\"inv\\<index> _\" [81] 80)"], ["", "lemma permutation_mat_dim[simp]: \"permutation_mat n p \\<in> carrier_mat n n\" \n  \"dim_row (permutation_mat n p) = n\"\n  \"dim_col (permutation_mat n p) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_mat n p \\<in> carrier_mat n n &&&\n    dim_row (permutation_mat n p) = n &&& dim_col (permutation_mat n p) = n", "unfolding permutation_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat n n (\\<lambda>(i, j). if i = p j then 1::'a else (0::'a))\n    \\<in> carrier_mat n n &&&\n    dim_row\n     (Matrix.mat n n\n       (\\<lambda>(i, j). if i = p j then 1::'b else (0::'b))) =\n    n &&&\n    dim_col\n     (Matrix.mat n n\n       (\\<lambda>(i, j). if i = p j then 1::'c else (0::'c))) =\n    n", "by auto"], ["", "lemma permutation_mat_row[simp]: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow>\n  Matrix.row (permutation_mat n p) i = unit_vec n (inv p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p permutes {..<n}; i < n\\<rbrakk>\n    \\<Longrightarrow> Matrix.row (permutation_mat n p) i =\n                      unit_vec n (inv p i)", "unfolding permutation_mat_def unit_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p permutes {..<n}; i < n\\<rbrakk>\n    \\<Longrightarrow> Matrix.row\n                       (Matrix.mat n n\n                         (\\<lambda>(i, j).\n                             if i = p j then 1::'a else (0::'a)))\n                       i =\n                      Matrix.vec n\n                       (\\<lambda>j. if j = inv p i then 1::'a else (0::'a))", "by (intro eq_vecI, auto simp: permutes_inverses)"], ["", "lemma permutation_mat_col[simp]: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow>\n  Matrix.col (permutation_mat n p) i = unit_vec n (p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p permutes {..<n}; i < n\\<rbrakk>\n    \\<Longrightarrow> col (permutation_mat n p) i = unit_vec n (p i)", "unfolding permutation_mat_def unit_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p permutes {..<n}; i < n\\<rbrakk>\n    \\<Longrightarrow> col (Matrix.mat n n\n                            (\\<lambda>(i, j).\n                                if i = p j then 1::'a else (0::'a)))\n                       i =\n                      Matrix.vec n\n                       (\\<lambda>j. if j = p i then 1::'a else (0::'a))", "by (intro eq_vecI, auto simp: permutes_inverses)"], ["", "lemma permutation_mat_left: assumes A: \"A \\<in> carrier_mat n nc\" and p: \"p permutes {..<n}\" \n  shows \"permutation_mat n p * A = Matrix.mat n nc (\\<lambda> (i,j). A $$ (inv p i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "assume ij: \"i < n\" \"j < nc\""], ["proof (state)\nthis:\n  i < n\n  j < nc\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "from p ij(1)"], ["proof (chain)\npicking this:\n  p permutes {..<n}\n  i < n", "have i: \"inv p i < n\""], ["proof (prove)\nusing this:\n  p permutes {..<n}\n  i < n\n\ngoal (1 subgoal):\n 1. inv p i < n", "by (simp add: permutes_def)"], ["proof (state)\nthis:\n  inv p i < n\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "have \"(permutation_mat n p * A) $$ (i,j) = scalar_prod (unit_vec n (inv p i)) (col A j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (permutation_mat n p * A) $$ (i, j) =\n    unit_vec n (inv p i) \\<bullet> col A j", "by (subst index_mult_mat, insert ij A p, auto)"], ["proof (state)\nthis:\n  (permutation_mat n p * A) $$ (i, j) =\n  unit_vec n (inv p i) \\<bullet> col A j\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "also"], ["proof (state)\nthis:\n  (permutation_mat n p * A) $$ (i, j) =\n  unit_vec n (inv p i) \\<bullet> col A j\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "have \"\\<dots> = A $$ (inv p i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_vec n (inv p i) \\<bullet> col A j = A $$ (inv p i, j)", "by (subst scalar_prod_left_unit, insert A ij i, auto)"], ["proof (state)\nthis:\n  unit_vec n (inv p i) \\<bullet> col A j = A $$ (inv p i, j)\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "also"], ["proof (state)\nthis:\n  unit_vec n (inv p i) \\<bullet> col A j = A $$ (inv p i, j)\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "note calculation"], ["proof (state)\nthis:\n  (permutation_mat n p * A) $$ (i, j) = A $$ (inv p i, j)\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> (permutation_mat n p * A) $$ (?i2, ?j2) =\n                    A $$ (inv p ?i2, ?j2)\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> (permutation_mat n p * A) $$ (?i2, ?j2) =\n                    A $$ (inv p ?i2, ?j2)\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "using A"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> (permutation_mat n p * A) $$ (?i2, ?j2) =\n                    A $$ (inv p ?i2, ?j2)\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. permutation_mat n p * A =\n    Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  permutation_mat n p * A =\n  Matrix.mat n nc (\\<lambda>(i, j). A $$ (inv p i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_mat_right: assumes A: \"A \\<in> carrier_mat nr n\" and p: \"p permutes {..<n}\" \n  shows \"A * permutation_mat n p = Matrix.mat nr n (\\<lambda> (i,j). A $$ (i, p j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "assume ij: \"i < nr\" \"j < n\""], ["proof (state)\nthis:\n  i < nr\n  j < n\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "from p ij(2)"], ["proof (chain)\npicking this:\n  p permutes {..<n}\n  j < n", "have j: \"p j < n\""], ["proof (prove)\nusing this:\n  p permutes {..<n}\n  j < n\n\ngoal (1 subgoal):\n 1. p j < n", "by (simp add: permutes_def)"], ["proof (state)\nthis:\n  p j < n\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "have \"(A * permutation_mat n p) $$ (i,j) = scalar_prod (Matrix.row A i) (unit_vec n (p j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * permutation_mat n p) $$ (i, j) =\n    Matrix.row A i \\<bullet> unit_vec n (p j)", "by (subst index_mult_mat, insert ij A p, auto)"], ["proof (state)\nthis:\n  (A * permutation_mat n p) $$ (i, j) =\n  Matrix.row A i \\<bullet> unit_vec n (p j)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "also"], ["proof (state)\nthis:\n  (A * permutation_mat n p) $$ (i, j) =\n  Matrix.row A i \\<bullet> unit_vec n (p j)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "have \"\\<dots> = A $$ (i, p j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.row A i \\<bullet> unit_vec n (p j) = A $$ (i, p j)", "by (subst scalar_prod_right_unit, insert A ij j, auto)"], ["proof (state)\nthis:\n  Matrix.row A i \\<bullet> unit_vec n (p j) = A $$ (i, p j)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "also"], ["proof (state)\nthis:\n  Matrix.row A i \\<bullet> unit_vec n (p j) = A $$ (i, p j)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "note calculation"], ["proof (state)\nthis:\n  (A * permutation_mat n p) $$ (i, j) = A $$ (i, p j)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (A * permutation_mat n p) $$ (?i2, ?j2) =\n                    A $$ (?i2, p ?j2)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < nr; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (A * permutation_mat n p) $$ (?i2, ?j2) =\n                    A $$ (?i2, p ?j2)\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "using A"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < nr; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (A * permutation_mat n p) $$ (?i2, ?j2) =\n                    A $$ (?i2, p ?j2)\n  A \\<in> carrier_mat nr n\n\ngoal (1 subgoal):\n 1. A * permutation_mat n p =\n    Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  A * permutation_mat n p = Matrix.mat nr n (\\<lambda>(i, j). A $$ (i, p j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutes_lt: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow> p i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p permutes {..<n}; i < n\\<rbrakk> \\<Longrightarrow> p i < n", "by (meson lessThan_iff permutes_in_image)"], ["", "lemma permutes_iff: \"p permutes {..<n} \\<Longrightarrow> i < n \\<Longrightarrow> j < n \\<Longrightarrow> p i = p j \\<longleftrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p permutes {..<n}; i < n; j < n\\<rbrakk>\n    \\<Longrightarrow> (p i = p j) = (i = j)", "by (metis permutes_inverses(2))"], ["", "lemma permutation_mat_id_1: assumes p: \"p permutes {..<n}\" \n  shows \"permutation_mat n p * permutation_mat n (inv p) = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_mat n p * permutation_mat n (inv p) = 1\\<^sub>m n", "by (subst permutation_mat_left[OF _ p, of _ n], force, unfold permutation_mat_def, rule eq_matI, \n   auto simp: permutes_lt[OF permutes_inv[OF p]] permutes_iff[OF permutes_inv[OF p]])"], ["", "lemma permutation_mat_id_2: assumes p: \"p permutes {..<n}\" \n  shows \"permutation_mat n (inv p) * permutation_mat n p = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_mat n (inv p) * permutation_mat n p = 1\\<^sub>m n", "by (subst permutation_mat_right[OF _ p, of _ n], force, unfold permutation_mat_def, rule eq_matI, \n   insert p, auto simp: permutes_lt[OF p] permutes_inverses)"], ["", "lemma permutation_mat_both: assumes A: \"A \\<in> carrier_mat n n\" and p: \"p permutes {..<n}\" \n  shows \"permutation_mat n p * Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j)) * permutation_mat n (inv p) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation_mat n p *\n    Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)) *\n    permutation_mat n (inv p) =\n    A", "unfolding permutation_mat_left[OF mat_carrier p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat n n\n     (\\<lambda>(i, j).\n         Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)) $$\n         (inv p i, j)) *\n    permutation_mat n (inv p) =\n    A", "by (subst permutation_mat_right[OF _ permutes_inv[OF p], of _ n], force, insert A p, \n        auto intro!: eq_matI simp: permutes_inverses permutes_lt[OF permutes_inv[OF p]])"], ["", "lemma permutation_similar_mat: assumes A: \"A \\<in> carrier_mat n n\" and p: \"p permutes {..<n}\"\n  shows \"similar_mat A (Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat A (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)))", "by (rule similar_matI[OF _ permutation_mat_id_1[OF p] permutation_mat_id_2[OF p] \n  permutation_mat_both[symmetric, OF A p]], insert A, auto)"], ["", "lemma det_four_block_mat_lower_left_zero: fixes A1 :: \"'a :: idom mat\" \n  assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A2: \"A2 \\<in> carrier_mat n m\" and A30: \"A3 = 0\\<^sub>m m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"  \nshows \"Determinant.det (four_block_mat A1 A2 A3 A4) = Determinant.det A1 * Determinant.det A4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "let ?det = Determinant.det"], ["proof (state)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "let ?t = \"transpose_mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "let ?A = \"four_block_mat A1 A2 A3 A4\""], ["proof (state)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "let ?k = \"n + m\""], ["proof (state)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have A3: \"A3 \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A3 \\<in> carrier_mat m n", "unfolding A30"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m m n \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  A3 \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have A: \"?A \\<in> carrier_mat ?k ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 \\<in> carrier_mat (n + m) (n + m)", "by (rule four_block_carrier_mat[OF A1 A4])"], ["proof (state)\nthis:\n  four_block_mat A1 A2 A3 A4 \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have \"?det ?A = ?det (?t ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det (four_block_mat A1 A2 A3 A4)\\<^sup>T", "by (rule sym, rule Determinant.det_transpose[OF A])"], ["proof (state)\nthis:\n  Determinant.det (four_block_mat A1 A2 A3 A4) =\n  Determinant.det (four_block_mat A1 A2 A3 A4)\\<^sup>T\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "also"], ["proof (state)\nthis:\n  Determinant.det (four_block_mat A1 A2 A3 A4) =\n  Determinant.det (four_block_mat A1 A2 A3 A4)\\<^sup>T\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have \"?t ?A = four_block_mat (?t A1) (?t A3) (?t A2) (?t A4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (four_block_mat A1 A2 A3 A4)\\<^sup>T =\n    four_block_mat A1\\<^sup>T A3\\<^sup>T A2\\<^sup>T A4\\<^sup>T", "by (rule transpose_four_block_mat[OF A1 A2 A3 A4])"], ["proof (state)\nthis:\n  (four_block_mat A1 A2 A3 A4)\\<^sup>T =\n  four_block_mat A1\\<^sup>T A3\\<^sup>T A2\\<^sup>T A4\\<^sup>T\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "also"], ["proof (state)\nthis:\n  (four_block_mat A1 A2 A3 A4)\\<^sup>T =\n  four_block_mat A1\\<^sup>T A3\\<^sup>T A2\\<^sup>T A4\\<^sup>T\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have \"?det \\<dots> = ?det (?t A1) * ?det (?t A4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det\n     (four_block_mat A1\\<^sup>T A3\\<^sup>T A2\\<^sup>T A4\\<^sup>T) =\n    Determinant.det A1\\<^sup>T * Determinant.det A4\\<^sup>T", "by (rule det_four_block_mat_upper_right_zero[of _ n _ m], insert A1 A2 A30 A4, auto)"], ["proof (state)\nthis:\n  Determinant.det\n   (four_block_mat A1\\<^sup>T A3\\<^sup>T A2\\<^sup>T A4\\<^sup>T) =\n  Determinant.det A1\\<^sup>T * Determinant.det A4\\<^sup>T\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "also"], ["proof (state)\nthis:\n  Determinant.det\n   (four_block_mat A1\\<^sup>T A3\\<^sup>T A2\\<^sup>T A4\\<^sup>T) =\n  Determinant.det A1\\<^sup>T * Determinant.det A4\\<^sup>T\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have \"?det (?t A1) = ?det A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det A1\\<^sup>T = Determinant.det A1", "by (rule Determinant.det_transpose[OF A1])"], ["proof (state)\nthis:\n  Determinant.det A1\\<^sup>T = Determinant.det A1\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "also"], ["proof (state)\nthis:\n  Determinant.det A1\\<^sup>T = Determinant.det A1\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "have \"?det (?t A4) = ?det A4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det A4\\<^sup>T = Determinant.det A4", "by (rule Determinant.det_transpose[OF A4])"], ["proof (state)\nthis:\n  Determinant.det A4\\<^sup>T = Determinant.det A4\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "finally"], ["proof (chain)\npicking this:\n  Determinant.det (four_block_mat A1 A2 A3 A4) =\n  Determinant.det A1 * Determinant.det A4", "show ?thesis"], ["proof (prove)\nusing this:\n  Determinant.det (four_block_mat A1 A2 A3 A4) =\n  Determinant.det A1 * Determinant.det A4\n\ngoal (1 subgoal):\n 1. Determinant.det (four_block_mat A1 A2 A3 A4) =\n    Determinant.det A1 * Determinant.det A4", "."], ["proof (state)\nthis:\n  Determinant.det (four_block_mat A1 A2 A3 A4) =\n  Determinant.det A1 * Determinant.det A4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_matrix_four_block_mat: assumes \n      A1: \"A1 \\<in> carrier_mat n n\"\n  and A2: \"A2 \\<in> carrier_mat n m\" \n  and A3: \"A3 \\<in> carrier_mat m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"\nshows \"char_poly_matrix (four_block_mat A1 A2 A3 A4) = \n  four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda> x. [:-x:]) A2) \n    (map_mat (\\<lambda> x. [:-x:]) A3) (char_poly_matrix A4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly_matrix (four_block_mat A1 A2 A3 A4) =\n    four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda>x. [:- x:]) A2)\n     (map_mat (\\<lambda>x. [:- x:]) A3) (char_poly_matrix A4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly_matrix (four_block_mat A1 A2 A3 A4) =\n    four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda>x. [:- x:]) A2)\n     (map_mat (\\<lambda>x. [:- x:]) A3) (char_poly_matrix A4)", "from A1 A4"], ["proof (chain)\npicking this:\n  A1 \\<in> carrier_mat n n\n  A4 \\<in> carrier_mat m m", "have dim[simp]: \"dim_row A1 = n\" \"dim_col A1 = n\" \n      \"dim_row A4 = m\" \"dim_col A4 = m\""], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat n n\n  A4 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. (dim_row A1 = n &&& dim_col A1 = n) &&&\n    dim_row A4 = m &&& dim_col A4 = m", "by auto"], ["proof (state)\nthis:\n  dim_row A1 = n\n  dim_col A1 = n\n  dim_row A4 = m\n  dim_col A4 = m\n\ngoal (1 subgoal):\n 1. char_poly_matrix (four_block_mat A1 A2 A3 A4) =\n    four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda>x. [:- x:]) A2)\n     (map_mat (\\<lambda>x. [:- x:]) A3) (char_poly_matrix A4)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly_matrix (four_block_mat A1 A2 A3 A4) =\n    four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda>x. [:- x:]) A2)\n     (map_mat (\\<lambda>x. [:- x:]) A3) (char_poly_matrix A4)", "unfolding char_poly_matrix_def four_block_mat_def Let_def dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    1\\<^sub>m\n     (dim_row\n       (Matrix.mat (n + m) (n + m)\n         (\\<lambda>(i, j).\n             if i < n then if j < n then A1 $$ (i, j) else A2 $$ (i, j - n)\n             else if j < n then A3 $$ (i - n, j)\n                  else A4 $$ (i - n, j - n)))) +\n    map_mat (\\<lambda>a. [:- a:])\n     (Matrix.mat (n + m) (n + m)\n       (\\<lambda>(i, j).\n           if i < n then if j < n then A1 $$ (i, j) else A2 $$ (i, j - n)\n           else if j < n then A3 $$ (i - n, j) else A4 $$ (i - n, j - n))) =\n    Matrix.mat\n     (dim_row\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A1) +\n      dim_row\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m m +\n        map_mat (\\<lambda>a. [:- a:]) A4))\n     (dim_col\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A1) +\n      dim_col\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m m +\n        map_mat (\\<lambda>a. [:- a:]) A4))\n     (\\<lambda>(i, j).\n         if i < dim_row\n                 ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                  map_mat (\\<lambda>a. [:- a:]) A1)\n         then if j < dim_col\n                      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                       map_mat (\\<lambda>a. [:- a:]) A1)\n              then ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                    map_mat (\\<lambda>a. [:- a:]) A1) $$\n                   (i, j)\n              else map_mat (\\<lambda>x. [:- x:]) A2 $$\n                   (i, j -\n                       dim_col\n                        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                         map_mat (\\<lambda>a. [:- a:]) A1))\n         else if j < dim_col\n                      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                       map_mat (\\<lambda>a. [:- a:]) A1)\n              then map_mat (\\<lambda>x. [:- x:]) A3 $$\n                   (i -\n                    dim_row\n                     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                      map_mat (\\<lambda>a. [:- a:]) A1),\n                    j)\n              else ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m m +\n                    map_mat (\\<lambda>a. [:- a:]) A4) $$\n                   (i -\n                    dim_row\n                     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                      map_mat (\\<lambda>a. [:- a:]) A1),\n                    j -\n                    dim_col\n                     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n                      map_mat (\\<lambda>a. [:- a:]) A1)))", "by (rule eq_matI, insert A2 A3, auto)"], ["proof (state)\nthis:\n  char_poly_matrix (four_block_mat A1 A2 A3 A4) =\n  four_block_mat (char_poly_matrix A1) (map_mat (\\<lambda>x. [:- x:]) A2)\n   (map_mat (\\<lambda>x. [:- x:]) A3) (char_poly_matrix A4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_four_block_mat_lower_left_zero: fixes A :: \"'a :: idom mat\"\n  assumes A: \"A = four_block_mat B C (0\\<^sub>m m n) D\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and C: \"C \\<in> carrier_mat n m\"\n  and D: \"D \\<in> carrier_mat m m\"\nshows \"char_poly A = char_poly B * char_poly D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B * char_poly D", "unfolding A char_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det\n     (char_poly_matrix (four_block_mat B C (0\\<^sub>m m n) D)) =\n    Determinant.det (char_poly_matrix B) *\n    Determinant.det (char_poly_matrix D)", "by (subst char_poly_matrix_four_block_mat[OF B C _ D], force, \n     rule det_four_block_mat_lower_left_zero[of _ n _ m], insert B C D, auto)"], ["", "lemma elements_mat_permutes: assumes p: \"p permutes {..< n}\" \n  and A: \"A \\<in> carrier_mat n n\" \n  and B: \"B = Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j))\" \nshows \"elements_mat A = elements_mat B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  B = Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j))", "have [simp]: \"dim_row A = n\" \"dim_col A = n\" \"dim_row B = n\" \"dim_col B = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B = Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j))\n\ngoal (1 subgoal):\n 1. (dim_row A = n &&& dim_col A = n) &&& dim_row B = n &&& dim_col B = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n  dim_row B = n\n  dim_col B = n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "{"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n  dim_row B = n\n  dim_col B = n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "assume ij: \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "let ?p = \"inv p\""], ["proof (state)\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "from permutes_lt[OF p] ij"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> p ?i < n\n  i < n\n  j < n", "have *: \"p i < n\" \"p j < n\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> p ?i < n\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. p i < n &&& p j < n", "by auto"], ["proof (state)\nthis:\n  p i < n\n  p j < n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "from permutes_lt[OF permutes_inv[OF p]] ij"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> inv p ?i < n\n  i < n\n  j < n", "have **: \"?p i < n\" \"?p j < n\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> inv p ?i < n\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. inv p i < n &&& inv p j < n", "by auto"], ["proof (state)\nthis:\n  inv p i < n\n  inv p j < n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "have \"\\<exists> i' j'. B $$ (i,j) = A $$ (i',j') \\<and> i' < n \\<and> j' < n\" \n       \"\\<exists> i' j'. A $$ (i,j) = B $$ (i',j') \\<and> i' < n \\<and> j' < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i' j'.\n       B $$ (i, j) = A $$ (i', j') \\<and> i' < n \\<and> j' < n &&&\n    \\<exists>i' j'. A $$ (i, j) = B $$ (i', j') \\<and> i' < n \\<and> j' < n", "by (rule exI[of _ \"p i\"], rule exI[of _ \"p j\"], insert ij *, simp add: B,\n      rule exI[of _ \"?p i\"], rule exI[of _ \"?p j\"], insert ** p, simp add: B permutes_inverses)"], ["proof (state)\nthis:\n  \\<exists>i' j'. B $$ (i, j) = A $$ (i', j') \\<and> i' < n \\<and> j' < n\n  \\<exists>i' j'. A $$ (i, j) = B $$ (i', j') \\<and> i' < n \\<and> j' < n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i' j'.\n                       B $$ (?i2, ?j2) = A $$ (i', j') \\<and>\n                       i' < n \\<and> j' < n\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i' j'.\n                       A $$ (?i2, ?j2) = B $$ (i', j') \\<and>\n                       i' < n \\<and> j' < n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i' j'.\n                       B $$ (?i2, ?j2) = A $$ (i', j') \\<and>\n                       i' < n \\<and> j' < n\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i' j'.\n                       A $$ (?i2, ?j2) = B $$ (i', j') \\<and>\n                       i' < n \\<and> j' < n\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "unfolding elements_mat"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i' j'.\n                       B $$ (?i2, ?j2) = A $$ (i', j') \\<and>\n                       i' < n \\<and> j' < n\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i' j'.\n                       A $$ (?i2, ?j2) = B $$ (i', j') \\<and>\n                       i' < n \\<and> j' < n\n\ngoal (1 subgoal):\n 1. {A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A} =\n    {B $$ (i, j) |i j. i < dim_row B \\<and> j < dim_col B}", "by auto"], ["proof (state)\nthis:\n  elements_mat A = elements_mat B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elements_mat_four_block_mat_supseteq: \n  assumes A1: \"A1 \\<in> carrier_mat n n\"\n  and A2: \"A2 \\<in> carrier_mat n m\" \n  and A3: \"A3 \\<in> carrier_mat m n\"\n  and A4: \"A4 \\<in> carrier_mat m m\"\nshows \"elements_mat (four_block_mat A1 A2 A3 A4) \\<supseteq> \n  (elements_mat A1 \\<union> elements_mat A2 \\<union> elements_mat A3 \\<union> elements_mat A4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements_mat A1 \\<union> elements_mat A2 \\<union>\n    elements_mat A3 \\<union>\n    elements_mat A4\n    \\<subseteq> elements_mat (four_block_mat A1 A2 A3 A4)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "let ?A = \"four_block_mat A1 A2 A3 A4\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "have A: \"?A \\<in> carrier_mat (n + m) (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 \\<in> carrier_mat (n + m) (n + m)", "using A1 A2 A3 A4"], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat n n\n  A2 \\<in> carrier_mat n m\n  A3 \\<in> carrier_mat m n\n  A4 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. four_block_mat A1 A2 A3 A4 \\<in> carrier_mat (n + m) (n + m)", "by simp"], ["proof (state)\nthis:\n  four_block_mat A1 A2 A3 A4 \\<in> carrier_mat (n + m) (n + m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from A1 A4"], ["proof (chain)\npicking this:\n  A1 \\<in> carrier_mat n n\n  A4 \\<in> carrier_mat m m", "have dim[simp]: \"dim_row A1 = n\" \"dim_col A1 = n\" \n      \"dim_row A4 = m\" \"dim_col A4 = m\""], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat n n\n  A4 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. (dim_row A1 = n &&& dim_col A1 = n) &&&\n    dim_row A4 = m &&& dim_col A4 = m", "by auto"], ["proof (state)\nthis:\n  dim_row A1 = n\n  dim_col A1 = n\n  dim_row A4 = m\n  dim_col A4 = m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "assume x: \"x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union> elements_mat A3 \\<union> elements_mat A4\""], ["proof (state)\nthis:\n  x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n          elements_mat A3 \\<union>\n          elements_mat A4\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "{"], ["proof (state)\nthis:\n  x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n          elements_mat A3 \\<union>\n          elements_mat A4\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "assume \"x \\<in> elements_mat A1\""], ["proof (state)\nthis:\n  x \\<in> elements_mat A1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from this[unfolded elements_mat] A1"], ["proof (chain)\npicking this:\n  x \\<in> {A1 $$ (i, j) |i j. i < dim_row A1 \\<and> j < dim_col A1}\n  A1 \\<in> carrier_mat n n", "obtain i j where x: \"x = A1 $$ (i,j)\" and \n      ij: \"i < n\" \"j < n\""], ["proof (prove)\nusing this:\n  x \\<in> {A1 $$ (i, j) |i j. i < dim_row A1 \\<and> j < dim_col A1}\n  A1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>x = A1 $$ (i, j); i < n; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = A1 $$ (i, j)\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "have \"x = ?A $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i, j)", "using ij"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i, j)", "unfolding x four_block_mat_def Let_def"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. A1 $$ (i, j) =\n    Matrix.mat (dim_row A1 + dim_row A4) (dim_col A1 + dim_col A4)\n     (\\<lambda>(i, j).\n         if i < dim_row A1\n         then if j < dim_col A1 then A1 $$ (i, j)\n              else A2 $$ (i, j - dim_col A1)\n         else if j < dim_col A1 then A3 $$ (i - dim_row A1, j)\n              else A4 $$ (i - dim_row A1, j - dim_col A1)) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  x = four_block_mat A1 A2 A3 A4 $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from elements_matI[OF A _ _ this] ij"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < n\n  j < n", "have \"x \\<in> elements_mat ?A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < n + m; j < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "by auto"], ["proof (state)\nthis:\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "}"], ["proof (state)\nthis:\n  x \\<in> elements_mat A1 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "moreover"], ["proof (state)\nthis:\n  x \\<in> elements_mat A1 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "{"], ["proof (state)\nthis:\n  x \\<in> elements_mat A1 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "assume \"x \\<in> elements_mat A2\""], ["proof (state)\nthis:\n  x \\<in> elements_mat A2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from this[unfolded elements_mat] A2"], ["proof (chain)\npicking this:\n  x \\<in> {A2 $$ (i, j) |i j. i < dim_row A2 \\<and> j < dim_col A2}\n  A2 \\<in> carrier_mat n m", "obtain i j where x: \"x = A2 $$ (i,j)\" and \n      ij: \"i < n\" \"j < m\""], ["proof (prove)\nusing this:\n  x \\<in> {A2 $$ (i, j) |i j. i < dim_row A2 \\<and> j < dim_col A2}\n  A2 \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>x = A2 $$ (i, j); i < n; j < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = A2 $$ (i, j)\n  i < n\n  j < m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "have \"x = ?A $$ (i,j + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i, j + n)", "using ij"], ["proof (prove)\nusing this:\n  i < n\n  j < m\n\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i, j + n)", "unfolding x four_block_mat_def Let_def"], ["proof (prove)\nusing this:\n  i < n\n  j < m\n\ngoal (1 subgoal):\n 1. A2 $$ (i, j) =\n    Matrix.mat (dim_row A1 + dim_row A4) (dim_col A1 + dim_col A4)\n     (\\<lambda>(i, j).\n         if i < dim_row A1\n         then if j < dim_col A1 then A1 $$ (i, j)\n              else A2 $$ (i, j - dim_col A1)\n         else if j < dim_col A1 then A3 $$ (i - dim_row A1, j)\n              else A4 $$ (i - dim_row A1, j - dim_col A1)) $$\n    (i, j + n)", "by simp"], ["proof (state)\nthis:\n  x = four_block_mat A1 A2 A3 A4 $$ (i, j + n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from elements_matI[OF A _ _ this] ij"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < n + m; j + n < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < n\n  j < m", "have \"x \\<in> elements_mat ?A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < n + m; j + n < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < n\n  j < m\n\ngoal (1 subgoal):\n 1. x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "by auto"], ["proof (state)\nthis:\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "}"], ["proof (state)\nthis:\n  x \\<in> elements_mat A2 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "moreover"], ["proof (state)\nthis:\n  x \\<in> elements_mat A2 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "{"], ["proof (state)\nthis:\n  x \\<in> elements_mat A2 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "assume \"x \\<in> elements_mat A3\""], ["proof (state)\nthis:\n  x \\<in> elements_mat A3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from this[unfolded elements_mat] A3"], ["proof (chain)\npicking this:\n  x \\<in> {A3 $$ (i, j) |i j. i < dim_row A3 \\<and> j < dim_col A3}\n  A3 \\<in> carrier_mat m n", "obtain i j where x: \"x = A3 $$ (i,j)\" and \n      ij: \"i < m\" \"j < n\""], ["proof (prove)\nusing this:\n  x \\<in> {A3 $$ (i, j) |i j. i < dim_row A3 \\<and> j < dim_col A3}\n  A3 \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>x = A3 $$ (i, j); i < m; j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = A3 $$ (i, j)\n  i < m\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "have \"x = ?A $$ (i+n,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i + n, j)", "using ij"], ["proof (prove)\nusing this:\n  i < m\n  j < n\n\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i + n, j)", "unfolding x four_block_mat_def Let_def"], ["proof (prove)\nusing this:\n  i < m\n  j < n\n\ngoal (1 subgoal):\n 1. A3 $$ (i, j) =\n    Matrix.mat (dim_row A1 + dim_row A4) (dim_col A1 + dim_col A4)\n     (\\<lambda>(i, j).\n         if i < dim_row A1\n         then if j < dim_col A1 then A1 $$ (i, j)\n              else A2 $$ (i, j - dim_col A1)\n         else if j < dim_col A1 then A3 $$ (i - dim_row A1, j)\n              else A4 $$ (i - dim_row A1, j - dim_col A1)) $$\n    (i + n, j)", "by simp"], ["proof (state)\nthis:\n  x = four_block_mat A1 A2 A3 A4 $$ (i + n, j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from elements_matI[OF A _ _ this] ij"], ["proof (chain)\npicking this:\n  \\<lbrakk>i + n < n + m; j < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < m\n  j < n", "have \"x \\<in> elements_mat ?A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i + n < n + m; j < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < m\n  j < n\n\ngoal (1 subgoal):\n 1. x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "by auto"], ["proof (state)\nthis:\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "}"], ["proof (state)\nthis:\n  x \\<in> elements_mat A3 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "moreover"], ["proof (state)\nthis:\n  x \\<in> elements_mat A3 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "{"], ["proof (state)\nthis:\n  x \\<in> elements_mat A3 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "assume \"x \\<in> elements_mat A4\""], ["proof (state)\nthis:\n  x \\<in> elements_mat A4\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from this[unfolded elements_mat] A4"], ["proof (chain)\npicking this:\n  x \\<in> {A4 $$ (i, j) |i j. i < dim_row A4 \\<and> j < dim_col A4}\n  A4 \\<in> carrier_mat m m", "obtain i j where x: \"x = A4 $$ (i,j)\" and \n      ij: \"i < m\" \"j < m\""], ["proof (prove)\nusing this:\n  x \\<in> {A4 $$ (i, j) |i j. i < dim_row A4 \\<and> j < dim_col A4}\n  A4 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>x = A4 $$ (i, j); i < m; j < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = A4 $$ (i, j)\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "have \"x = ?A $$ (i+n,j + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i + n, j + n)", "using ij"], ["proof (prove)\nusing this:\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. x = four_block_mat A1 A2 A3 A4 $$ (i + n, j + n)", "unfolding x four_block_mat_def Let_def"], ["proof (prove)\nusing this:\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. A4 $$ (i, j) =\n    Matrix.mat (dim_row A1 + dim_row A4) (dim_col A1 + dim_col A4)\n     (\\<lambda>(i, j).\n         if i < dim_row A1\n         then if j < dim_col A1 then A1 $$ (i, j)\n              else A2 $$ (i, j - dim_col A1)\n         else if j < dim_col A1 then A3 $$ (i - dim_row A1, j)\n              else A4 $$ (i - dim_row A1, j - dim_col A1)) $$\n    (i + n, j + n)", "by simp"], ["proof (state)\nthis:\n  x = four_block_mat A1 A2 A3 A4 $$ (i + n, j + n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "from elements_matI[OF A _ _ this] ij"], ["proof (chain)\npicking this:\n  \\<lbrakk>i + n < n + m; j + n < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < m\n  j < m", "have \"x \\<in> elements_mat ?A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i + n < n + m; j + n < n + m\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "by auto"], ["proof (state)\nthis:\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "}"], ["proof (state)\nthis:\n  x \\<in> elements_mat A4 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n               elements_mat A3 \\<union>\n               elements_mat A4 \\<Longrightarrow>\n       x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> elements_mat A1 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A2 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A3 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A4 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "show \"x \\<in> elements_mat ?A\""], ["proof (prove)\nusing this:\n  x \\<in> elements_mat A1 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A2 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A3 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A4 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal (1 subgoal):\n 1. x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> elements_mat A1 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A2 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A3 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A4 \\<Longrightarrow>\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n  x \\<in> elements_mat A1 \\<union> elements_mat A2 \\<union>\n          elements_mat A3 \\<union>\n          elements_mat A4\n\ngoal (1 subgoal):\n 1. x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)", "by blast"], ["proof (state)\nthis:\n  x \\<in> elements_mat (four_block_mat A1 A2 A3 A4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_irreducible_mat_split: \n  fixes A :: \"'a :: idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and not: \"\\<not> irreducible_mat A\" \n  and n: \"n > 1\" \nshows \"\\<exists> n1 n2 B B1 B2 B4. similar_mat A B \\<and> elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>  \n       B1 \\<in> carrier_mat n1 n1 \\<and> B2 \\<in> carrier_mat n1 n2 \\<and> B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have [simp]: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?G = \"graph_of_mat A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?reachp = \"\\<lambda> i j. (i,j) \\<in> ?G^+\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?reach = \"\\<lambda> i j. (i,j) \\<in> ?G^*\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"\\<exists> i j. i < n \\<and> j < n \\<and> \\<not> ?reach i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       i < n \\<and> j < n \\<and> (i, j) \\<notin> (graph_of_mat A)\\<^sup>*", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>i j.\n     i < n \\<and> j < n \\<and> (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "hence reach: \"\\<And> i j. i < n \\<Longrightarrow> j < n \\<Longrightarrow> ?reach i j\""], ["proof (prove)\nusing this:\n  \\<nexists>i j.\n     i < n \\<and> j < n \\<and> (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (i, j) \\<in> (graph_of_mat A)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; ?j < n\\<rbrakk>\n  \\<Longrightarrow> (?i, ?j) \\<in> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "from not[unfolded irreducible_mat_def Let_def]"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i j.\n             i < dim_row A \\<longrightarrow>\n             j < dim_row A \\<longrightarrow>\n             (i, j) \\<in> (graph_of_mat A)\\<^sup>+)", "obtain i j where i: \"i < n\" and j: \"j < n\" and nreach: \"\\<not> ?reachp i j\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i j.\n             i < dim_row A \\<longrightarrow>\n             j < dim_row A \\<longrightarrow>\n             (i, j) \\<in> (graph_of_mat A)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < n; j < n;\n         (i, j) \\<notin> (graph_of_mat A)\\<^sup>+\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  j < n\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "from reach[OF i j] nreach"], ["proof (chain)\npicking this:\n  (i, j) \\<in> (graph_of_mat A)\\<^sup>*\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>+", "have ij: \"i = j\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> (graph_of_mat A)\\<^sup>*\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>+\n\ngoal (1 subgoal):\n 1. i = j", "by (simp add: rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "from n j"], ["proof (chain)\npicking this:\n  1 < n\n  j < n", "obtain k where k: \"k < n\" and diff: \"j \\<noteq> k\""], ["proof (prove)\nusing this:\n  1 < n\n  j < n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < n; j \\<noteq> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < n\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "from reach[OF j k] diff reach[OF k j]"], ["proof (chain)\npicking this:\n  (j, k) \\<in> (graph_of_mat A)\\<^sup>*\n  j \\<noteq> k\n  (k, j) \\<in> (graph_of_mat A)\\<^sup>*", "have \"?reachp j j\""], ["proof (prove)\nusing this:\n  (j, k) \\<in> (graph_of_mat A)\\<^sup>*\n  j \\<noteq> k\n  (k, j) \\<in> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (j, j) \\<in> (graph_of_mat A)\\<^sup>+", "by (simp add: rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  (j, j) \\<in> (graph_of_mat A)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < n \\<and>\n       j < n \\<and>\n       (i, j) \\<notin> (graph_of_mat A)\\<^sup>* \\<Longrightarrow>\n    False", "with nreach ij"], ["proof (chain)\npicking this:\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>+\n  i = j\n  (j, j) \\<in> (graph_of_mat A)\\<^sup>+", "show False"], ["proof (prove)\nusing this:\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>+\n  i = j\n  (j, j) \\<in> (graph_of_mat A)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i j.\n     i < n \\<and> j < n \\<and> (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "then"], ["proof (chain)\npicking this:\n  \\<exists>i j.\n     i < n \\<and> j < n \\<and> (i, j) \\<notin> (graph_of_mat A)\\<^sup>*", "obtain i j where i: \"i < n\" and j: \"j < n\" and nreach: \"\\<not> ?reach i j\""], ["proof (prove)\nusing this:\n  \\<exists>i j.\n     i < n \\<and> j < n \\<and> (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < n; j < n;\n         (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  j < n\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "define I where \"I = {k. k < n \\<and> ?reach i k}\""], ["proof (state)\nthis:\n  I = {k. k < n \\<and> (i, k) \\<in> (graph_of_mat A)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have iI: \"i \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> I", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {k. k < n \\<and> (i, k) \\<in> (graph_of_mat A)\\<^sup>*}", "using nreach i"], ["proof (prove)\nusing this:\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n  i < n\n\ngoal (1 subgoal):\n 1. i \\<in> {k. k < n \\<and> (i, k) \\<in> (graph_of_mat A)\\<^sup>*}", "by auto"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have jI: \"j \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<notin> I", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<notin> {k. k < n \\<and> (i, k) \\<in> (graph_of_mat A)\\<^sup>*}", "using nreach j"], ["proof (prove)\nusing this:\n  (i, j) \\<notin> (graph_of_mat A)\\<^sup>*\n  j < n\n\ngoal (1 subgoal):\n 1. j \\<notin> {k. k < n \\<and> (i, k) \\<in> (graph_of_mat A)\\<^sup>*}", "by auto"], ["proof (state)\nthis:\n  j \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "define f where \"f = (\\<lambda> i. if i \\<in> I then 1 else 0 :: nat)\""], ["proof (state)\nthis:\n  f = (\\<lambda>i. if i \\<in> I then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?xs = \"[0 ..< n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from mset_eq_permutation[OF mset_sort, of ?xs f]"], ["proof (chain)\npicking this:\n  (\\<And>p.\n      \\<lbrakk>p permutes {..<length [0..<n]};\n       permute_list p [0..<n] = sort_key f [0..<n]\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p where p: \"p permutes {..< n}\" \n    and perm: \"permute_list p ?xs = sort_key f ?xs\""], ["proof (prove)\nusing this:\n  (\\<And>p.\n      \\<lbrakk>p permutes {..<length [0..<n]};\n       permute_list p [0..<n] = sort_key f [0..<n]\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p permutes {..<n};\n         permute_list p [0..<n] = sort_key f [0..<n]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p permutes {..<n}\n  permute_list p [0..<n] = sort_key f [0..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from p"], ["proof (chain)\npicking this:\n  p permutes {..<n}", "have lt[simp]: \"i < n \\<Longrightarrow> p i < n\" for i"], ["proof (prove)\nusing this:\n  p permutes {..<n}\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> p i < n", "by (rule permutes_lt)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> p ?i < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?p = \"inv p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have ip: \"?p permutes {..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv p permutes {..<n}", "using permutes_inv[OF p]"], ["proof (prove)\nusing this:\n  inv p permutes {..<n}\n\ngoal (1 subgoal):\n 1. inv p permutes {..<n}", "."], ["proof (state)\nthis:\n  inv p permutes {..<n}\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from ip"], ["proof (chain)\npicking this:\n  inv p permutes {..<n}", "have ilt[simp]: \"i < n \\<Longrightarrow> ?p i < n\" for i"], ["proof (prove)\nusing this:\n  inv p permutes {..<n}\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> inv p i < n", "by (rule permutes_lt)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> inv p ?i < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?B = \"Matrix.mat n n (\\<lambda> (i,j). A $$ (p i, p j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "define B where \"B = ?B\""], ["proof (state)\nthis:\n  B = Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j))\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from permutation_similar_mat[OF A p]"], ["proof (chain)\npicking this:\n  similar_mat A (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)))", "have sim: \"similar_mat A B\""], ["proof (prove)\nusing this:\n  similar_mat A (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)))\n\ngoal (1 subgoal):\n 1. similar_mat A B", "unfolding B_def"], ["proof (prove)\nusing this:\n  similar_mat A (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)))\n\ngoal (1 subgoal):\n 1. similar_mat A (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)))", "."], ["proof (state)\nthis:\n  similar_mat A B\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?ys = \"permute_list p ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "define ys where \"ys = ?ys\""], ["proof (state)\nthis:\n  ys = permute_list p [0..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have len_ys: \"length ys = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = n", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (permute_list p [0..<n]) = n", "by simp"], ["proof (state)\nthis:\n  length ys = n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?k = \"length (filter (\\<lambda> i. f i = 0) ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "define k where \"k = ?k\""], ["proof (state)\nthis:\n  k = length (filter (\\<lambda>i. f i = 0) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have kn: \"k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>i. f i = 0) ys) \\<le> n", "using len_ys"], ["proof (prove)\nusing this:\n  length ys = n\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>i. f i = 0) ys) \\<le> n", "using length_filter_le[of _ ys]"], ["proof (prove)\nusing this:\n  length ys = n\n  length (filter ?P ys) \\<le> length ys\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>i. f i = 0) ys) \\<le> n", "by auto"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have ys_p: \"i < n \\<Longrightarrow> ys ! i = p i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> ys ! i = p i", "unfolding ys_def permute_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    map (\\<lambda>i. [0..<n] ! p i) [0..<length [0..<n]] ! i = p i", "by simp"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> ys ! ?i = p ?i\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have ys: \"ys = map (\\<lambda> i. ys ! i) [0 ..< n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map ((!) ys) [0..<n]", "unfolding len_ys[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map ((!) ys) [0..<length ys]", "by (simp add: map_nth)"], ["proof (state)\nthis:\n  ys = map ((!) ys) [0..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "also"], ["proof (state)\nthis:\n  ys = map ((!) ys) [0..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"\\<dots> = map p [0 ..< n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) ys) [0..<n] = map p [0..<n]", "by (rule map_cong, insert ys_p, auto)"], ["proof (state)\nthis:\n  map ((!) ys) [0..<n] = map p [0..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "also"], ["proof (state)\nthis:\n  map ((!) ys) [0..<n] = map p [0..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"[0 ..< n] = [0 ..< k] @ [k ..< n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<n] = [0..<k] @ [k..<n]", "using kn"], ["proof (prove)\nusing this:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. [0..<n] = [0..<k] @ [k..<n]", "using le_Suc_ex upt_add_eq_append"], ["proof (prove)\nusing this:\n  k \\<le> n\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n  ?i \\<le> ?j \\<Longrightarrow> [?i..<?j + ?k] = [?i..<?j] @ [?j..<?j + ?k]\n\ngoal (1 subgoal):\n 1. [0..<n] = [0..<k] @ [k..<n]", "by blast"], ["proof (state)\nthis:\n  [0..<n] = [0..<k] @ [k..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "finally"], ["proof (chain)\npicking this:\n  ys = map p ([0..<k] @ [k..<n])", "have ys: \"ys = map p [0 ..< k] @ map p [k ..< n]\""], ["proof (prove)\nusing this:\n  ys = map p ([0..<k] @ [k..<n])\n\ngoal (1 subgoal):\n 1. ys = map p [0..<k] @ map p [k..<n]", "by simp"], ["proof (state)\nthis:\n  ys = map p [0..<k] @ map p [k..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "{"], ["proof (state)\nthis:\n  ys = map p [0..<k] @ map p [k..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?g = \"(\\<lambda> i. f i = 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "let ?f = \"filter ?g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from i"], ["proof (chain)\npicking this:\n  i < n", "have pi: \"p i < n\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. p i < n", "using p"], ["proof (prove)\nusing this:\n  i < n\n  p permutes {..<n}\n\ngoal (1 subgoal):\n 1. p i < n", "by simp"], ["proof (state)\nthis:\n  p i < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"k = length (?f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = length (filter (\\<lambda>i. f i = 0) ys)", "by fact"], ["proof (state)\nthis:\n  k = length (filter (\\<lambda>i. f i = 0) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "also"], ["proof (state)\nthis:\n  k = length (filter (\\<lambda>i. f i = 0) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"?f ys = ?f (map p [0 ..< k]) @ ?f (map p [k ..< n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>i. f i = 0) ys =\n    filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n    filter (\\<lambda>i. f i = 0) (map p [k..<n])", "unfolding ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>i. f i = 0) (map p [0..<k] @ map p [k..<n]) =\n    filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n    filter (\\<lambda>i. f i = 0) (map p [k..<n])", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>i. f i = 0) ys =\n  filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n  filter (\\<lambda>i. f i = 0) (map p [k..<n])\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "also"], ["proof (state)\nthis:\n  filter (\\<lambda>i. f i = 0) ys =\n  filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n  filter (\\<lambda>i. f i = 0) (map p [k..<n])\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "note k = calculation"], ["proof (state)\nthis:\n  k =\n  length\n   (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n    filter (\\<lambda>i. f i = 0) (map p [k..<n]))\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "finally"], ["proof (chain)\npicking this:\n  length\n   (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n    filter (\\<lambda>i. f i = 0) (map p [k..<n])) =\n  length\n   (filter (\\<lambda>i. f i = 0)\n     (map p\n       [0..<\n        length\n         (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n          filter (\\<lambda>i. f i = 0) (map p [k..<n]))]) @\n    filter (\\<lambda>i. f i = 0)\n     (map p\n       [length\n         (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n          filter (\\<lambda>i. f i = 0) (map p [k..<n]))..<\n        n]))", "have True"], ["proof (prove)\nusing this:\n  length\n   (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n    filter (\\<lambda>i. f i = 0) (map p [k..<n])) =\n  length\n   (filter (\\<lambda>i. f i = 0)\n     (map p\n       [0..<\n        length\n         (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n          filter (\\<lambda>i. f i = 0) (map p [k..<n]))]) @\n    filter (\\<lambda>i. f i = 0)\n     (map p\n       [length\n         (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @\n          filter (\\<lambda>i. f i = 0) (map p [k..<n]))..<\n        n]))\n\ngoal (1 subgoal):\n 1. True", "by blast"], ["proof (state)\nthis:\n  True\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from perm[symmetric, folded ys_def]"], ["proof (chain)\npicking this:\n  sort_key f [0..<n] = ys", "have \"sorted (map f ys)\""], ["proof (prove)\nusing this:\n  sort_key f [0..<n] = ys\n\ngoal (1 subgoal):\n 1. sorted (map f ys)", "using sorted_sort_key"], ["proof (prove)\nusing this:\n  sort_key f [0..<n] = ys\n  sorted (map ?f (sort_key ?f ?xs))\n\ngoal (1 subgoal):\n 1. sorted (map f ys)", "by metis"], ["proof (state)\nthis:\n  sorted (map f ys)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from this[unfolded ys map_append sorted_append set_map]"], ["proof (chain)\npicking this:\n  sorted (map f (map p [0..<k])) \\<and>\n  sorted (map f (map p [k..<n])) \\<and>\n  (\\<forall>x\\<in>f ` p ` set [0..<k].\n      Ball (f ` p ` set [k..<n]) ((\\<le>) x))", "have sorted: \"\\<And> x y. x < k \\<Longrightarrow> y \\<in> {k..<n} \\<Longrightarrow> f (p x) \\<le> f (p y)\""], ["proof (prove)\nusing this:\n  sorted (map f (map p [0..<k])) \\<and>\n  sorted (map f (map p [k..<n])) \\<and>\n  (\\<forall>x\\<in>f ` p ` set [0..<k].\n      Ball (f ` p ` set [k..<n]) ((\\<le>) x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < k; y \\<in> {k..<n}\\<rbrakk>\n       \\<Longrightarrow> f (p x) \\<le> f (p y)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x < k; ?y \\<in> {k..<n}\\<rbrakk>\n  \\<Longrightarrow> f (p ?x) \\<le> f (p ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have 0: \"\\<forall> i < k. f (p i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<k. f (p i) = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>i<k. f (p i) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i<k. f (p i) = 0)", "obtain i where i: \"i < k\" and zero: \"f (p i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<k. f (p i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < k; f (p i) \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < k\n  f (p i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "hence \"f (p i) = 1\""], ["proof (prove)\nusing this:\n  i < k\n  f (p i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f (p i) = 1", "unfolding f_def"], ["proof (prove)\nusing this:\n  i < k\n  (if p i \\<in> I then 1 else 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p i \\<in> I then 1 else 0) = 1", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  f (p i) = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "from sorted[OF i, unfolded this]"], ["proof (chain)\npicking this:\n  ?y \\<in> {k..<n} \\<Longrightarrow> 1 \\<le> f (p ?y)", "have 1: \"j \\<in> {k..<n} \\<Longrightarrow> f (p j) \\<ge> 1\" for j"], ["proof (prove)\nusing this:\n  ?y \\<in> {k..<n} \\<Longrightarrow> 1 \\<le> f (p ?y)\n\ngoal (1 subgoal):\n 1. j \\<in> {k..<n} \\<Longrightarrow> 1 \\<le> f (p j)", "by auto"], ["proof (state)\nthis:\n  ?j \\<in> {k..<n} \\<Longrightarrow> 1 \\<le> f (p ?j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "have le: \"j \\<in> {k ..< n} \\<Longrightarrow> f (p j) = 1\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> {k..<n} \\<Longrightarrow> f (p j) = 1", "using 1[of j]"], ["proof (prove)\nusing this:\n  j \\<in> {k..<n} \\<Longrightarrow> 1 \\<le> f (p j)\n\ngoal (1 subgoal):\n 1. j \\<in> {k..<n} \\<Longrightarrow> f (p j) = 1", "unfolding f_def"], ["proof (prove)\nusing this:\n  j \\<in> {k..<n} \\<Longrightarrow> 1 \\<le> (if p j \\<in> I then 1 else 0)\n\ngoal (1 subgoal):\n 1. j \\<in> {k..<n} \\<Longrightarrow> (if p j \\<in> I then 1 else 0) = 1", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  ?j \\<in> {k..<n} \\<Longrightarrow> f (p ?j) = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ?j \\<in> {k..<n} \\<Longrightarrow> f (p ?j) = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "have \"?f (map p [k ..< n]) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>i. f i = 0) (map p [k..<n]) = []", "using le"], ["proof (prove)\nusing this:\n  ?j \\<in> {k..<n} \\<Longrightarrow> f (p ?j) = 1\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>i. f i = 0) (map p [k..<n]) = []", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>i. f i = 0) (map p [k..<n]) = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "from k[unfolded this]"], ["proof (chain)\npicking this:\n  k = length (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @ [])", "have \"length (?f (map p [0..<k])) = k\""], ["proof (prove)\nusing this:\n  k = length (filter (\\<lambda>i. f i = 0) (map p [0..<k]) @ [])\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>i. f i = 0) (map p [0..<k])) = k", "by simp"], ["proof (state)\nthis:\n  length (filter (\\<lambda>i. f i = 0) (map p [0..<k])) = k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<k. f (p i) = 0) \\<Longrightarrow> False", "from length_filter_less[of \"p i\" \"map p [0 ..< k]\" ?g, unfolded this] i zero"], ["proof (chain)\npicking this:\n  \\<lbrakk>p i \\<in> set (map p [0..<k]); f (p i) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> k < length (map p [0..<k])\n  i < k\n  f (p i) \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>p i \\<in> set (map p [0..<k]); f (p i) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> k < length (map p [0..<k])\n  i < k\n  f (p i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<k. f (p i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "hence \"?f (map p [0..<k]) = map p [0..<k]\""], ["proof (prove)\nusing this:\n  \\<forall>i<k. f (p i) = 0\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>i. f i = 0) (map p [0..<k]) = map p [0..<k]", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>i. f i = 0) (map p [0..<k]) = map p [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from arg_cong[OF k[unfolded this, simplified], of set]"], ["proof (chain)\npicking this:\n  set (filter ((\\<lambda>i. f i = 0) \\<circ> p) [k..<n]) = set []", "have 1: \"\\<And> i. i \\<in> {k ..< n} \\<Longrightarrow> f (p i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  set (filter ((\\<lambda>i. f i = 0) \\<circ> p) [k..<n]) = set []\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {k..<n} \\<Longrightarrow> f (p i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> {k..<n} \\<Longrightarrow> f (p ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have 1: \"i < n \\<Longrightarrow> \\<not> i < k \\<Longrightarrow> f (p i) \\<noteq> 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; \\<not> i < k\\<rbrakk>\n    \\<Longrightarrow> f (p i) \\<noteq> 0", "using 1[of i]"], ["proof (prove)\nusing this:\n  i \\<in> {k..<n} \\<Longrightarrow> f (p i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; \\<not> i < k\\<rbrakk>\n    \\<Longrightarrow> f (p i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; \\<not> ?i < k\\<rbrakk>\n  \\<Longrightarrow> f (p ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have 0: \"i < n \\<Longrightarrow> (f (p i) = 0) = (i < k)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> (f (p i) = 0) = (i < k)", "using 1[of i] 0[rule_format, of i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < n; \\<not> i < k\\<rbrakk> \\<Longrightarrow> f (p i) \\<noteq> 0\n  i < k \\<Longrightarrow> f (p i) = 0\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> (f (p i) = 0) = (i < k)", "by blast"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> (f (p ?i) = 0) = (?i < k)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have main: \"(f i = 0) = (?p i < k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f i = 0) = (inv p i < k)", "using 0[of \"?p i\"] i p"], ["proof (prove)\nusing this:\n  inv p i < n \\<Longrightarrow> (f (p (inv p i)) = 0) = (inv p i < k)\n  i < n\n  p permutes {..<n}\n\ngoal (1 subgoal):\n 1. (f i = 0) = (inv p i < k)", "by (auto simp: permutes_inverses)"], ["proof (state)\nthis:\n  (f i = 0) = (inv p i < k)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"i \\<in> I \\<longleftrightarrow> f i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> I) = (f i \\<noteq> 0)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> I) = ((if i \\<in> I then 1 else 0) \\<noteq> 0)", "by simp"], ["proof (state)\nthis:\n  (i \\<in> I) = (f i \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "also"], ["proof (state)\nthis:\n  (i \\<in> I) = (f i \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"(f i = 0) \\<longleftrightarrow> ?p i < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f i = 0) = (inv p i < k)", "using main"], ["proof (prove)\nusing this:\n  (f i = 0) = (inv p i < k)\n\ngoal (1 subgoal):\n 1. (f i = 0) = (inv p i < k)", "by auto"], ["proof (state)\nthis:\n  (f i = 0) = (inv p i < k)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "finally"], ["proof (chain)\npicking this:\n  (i \\<in> I) = (\\<not> inv p i < k)", "have \"i \\<in> I \\<longleftrightarrow> ?p i \\<ge> k\""], ["proof (prove)\nusing this:\n  (i \\<in> I) = (\\<not> inv p i < k)\n\ngoal (1 subgoal):\n 1. (i \\<in> I) = (k \\<le> inv p i)", "by auto"], ["proof (state)\nthis:\n  (i \\<in> I) = (k \\<le> inv p i)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "}"], ["proof (state)\nthis:\n  ?ia2 < n \\<Longrightarrow> (?ia2 \\<in> I) = (k \\<le> inv p ?ia2)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "note main = this"], ["proof (state)\nthis:\n  ?ia2 < n \\<Longrightarrow> (?ia2 \\<in> I) = (k \\<le> inv p ?ia2)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from main[OF j] jI"], ["proof (chain)\npicking this:\n  (j \\<in> I) = (k \\<le> inv p j)\n  j \\<notin> I", "have k0: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (j \\<in> I) = (k \\<le> inv p j)\n  j \\<notin> I\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from iI main[OF i]"], ["proof (chain)\npicking this:\n  i \\<in> I\n  (i \\<in> I) = (k \\<le> inv p i)", "have \"?p i \\<ge> k\""], ["proof (prove)\nusing this:\n  i \\<in> I\n  (i \\<in> I) = (k \\<le> inv p i)\n\ngoal (1 subgoal):\n 1. k \\<le> inv p i", "by auto"], ["proof (state)\nthis:\n  k \\<le> inv p i\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "with ilt[OF i]"], ["proof (chain)\npicking this:\n  inv p i < n\n  k \\<le> inv p i", "have kn: \"k < n\""], ["proof (prove)\nusing this:\n  inv p i < n\n  k \\<le> inv p i\n\ngoal (1 subgoal):\n 1. k < n", "by auto"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "{"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "assume i: \"i < n\" and ik: \"k \\<le> i\" and jk: \"j < k\""], ["proof (state)\nthis:\n  i < n\n  k \\<le> i\n  j < k\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "with kn"], ["proof (chain)\npicking this:\n  k < n\n  i < n\n  k \\<le> i\n  j < k", "have j: \"j < n\""], ["proof (prove)\nusing this:\n  k < n\n  i < n\n  k \\<le> i\n  j < k\n\ngoal (1 subgoal):\n 1. j < n", "by auto"], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have jI: \"p j \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p j \\<notin> I", "by (subst main, insert jk j p, auto simp: permutes_inverses)"], ["proof (state)\nthis:\n  p j \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have iI: \"p i \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p i \\<in> I", "by (subst main, insert i ik p, auto simp: permutes_inverses)"], ["proof (state)\nthis:\n  p i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from i j"], ["proof (chain)\npicking this:\n  i < n\n  j < n", "have \"B $$ (i,j) = A $$ (p i, p j)\""], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. B $$ (i, j) = A $$ (p i, p j)", "unfolding B_def"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j)) $$ (i, j) =\n    A $$ (p i, p j)", "by auto"], ["proof (state)\nthis:\n  B $$ (i, j) = A $$ (p i, p j)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "also"], ["proof (state)\nthis:\n  B $$ (i, j) = A $$ (p i, p j)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (p i, p j) = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (p i, p j) \\<noteq> (0::'a) \\<Longrightarrow> False", "assume \"A $$ (p i, p j) \\<noteq> 0\""], ["proof (state)\nthis:\n  A $$ (p i, p j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (p i, p j) \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"(p i, p j) \\<in> ?G\""], ["proof (prove)\nusing this:\n  A $$ (p i, p j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (p i, p j) \\<in> graph_of_mat A", "unfolding graph_of_mat_def Let_def"], ["proof (prove)\nusing this:\n  A $$ (p i, p j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (p i, p j) \\<in> Restr {ij. A $$ ij \\<noteq> (0::'a)} {..<dim_row A}", "using i j p"], ["proof (prove)\nusing this:\n  A $$ (p i, p j) \\<noteq> (0::'a)\n  i < n\n  j < n\n  p permutes {..<n}\n\ngoal (1 subgoal):\n 1. (p i, p j) \\<in> Restr {ij. A $$ ij \\<noteq> (0::'a)} {..<dim_row A}", "by auto"], ["proof (state)\nthis:\n  (p i, p j) \\<in> graph_of_mat A\n\ngoal (1 subgoal):\n 1. A $$ (p i, p j) \\<noteq> (0::'a) \\<Longrightarrow> False", "with iI j"], ["proof (chain)\npicking this:\n  p i \\<in> I\n  j < n\n  (p i, p j) \\<in> graph_of_mat A", "have \"p j \\<in> I\""], ["proof (prove)\nusing this:\n  p i \\<in> I\n  j < n\n  (p i, p j) \\<in> graph_of_mat A\n\ngoal (1 subgoal):\n 1. p j \\<in> I", "unfolding I_def"], ["proof (prove)\nusing this:\n  p i \\<in> {k. k < n \\<and> (i__, k) \\<in> (graph_of_mat A)\\<^sup>*}\n  j < n\n  (p i, p j) \\<in> graph_of_mat A\n\ngoal (1 subgoal):\n 1. p j \\<in> {k. k < n \\<and> (i__, k) \\<in> (graph_of_mat A)\\<^sup>*}", "by auto"], ["proof (state)\nthis:\n  p j \\<in> I\n\ngoal (1 subgoal):\n 1. A $$ (p i, p j) \\<noteq> (0::'a) \\<Longrightarrow> False", "with jI"], ["proof (chain)\npicking this:\n  p j \\<notin> I\n  p j \\<in> I", "show False"], ["proof (prove)\nusing this:\n  p j \\<notin> I\n  p j \\<in> I\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (p i, p j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "finally"], ["proof (chain)\npicking this:\n  B $$ (i, j) = (0::'a)", "have \"B $$ (i,j) = 0\""], ["proof (prove)\nusing this:\n  B $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. B $$ (i, j) = (0::'a)", "."], ["proof (state)\nthis:\n  B $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ia2 < n; k \\<le> ?ia2; ?ja2 < k\\<rbrakk>\n  \\<Longrightarrow> B $$ (?ia2, ?ja2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "note zero = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ia2 < n; k \\<le> ?ia2; ?ja2 < k\\<rbrakk>\n  \\<Longrightarrow> B $$ (?ia2, ?ja2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have dimB[simp]: \"dim_row B = n\" \"dim_col B = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row B = n &&& dim_col B = n", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j))) = n &&&\n    dim_col (Matrix.mat n n (\\<lambda>(i, j). A $$ (p i, p j))) = n", "by auto"], ["proof (state)\nthis:\n  dim_row B = n\n  dim_col B = n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have dim: \"dim_row B = k + (n - k)\" \"dim_col B = k + (n - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row B = k + (n - k) &&& dim_col B = k + (n - k)", "using kn"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. dim_row B = k + (n - k) &&& dim_col B = k + (n - k)", "by auto"], ["proof (state)\nthis:\n  dim_row B = k + (n - k)\n  dim_col B = k + (n - k)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "obtain B1 B2 B3 B4 where spl: \"split_block B k k = (B1,B2,B3,B4)\" (is \"?tmp = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B1 B2 B3 B4.\n        split_block B k k = (B1, B2, B3, B4) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?tmp, auto)"], ["proof (state)\nthis:\n  split_block B k k = (B1, B2, B3, B4)\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from split_block[OF this dim]"], ["proof (chain)\npicking this:\n  B1 \\<in> carrier_mat k k\n  B2 \\<in> carrier_mat k (n - k)\n  B3 \\<in> carrier_mat (n - k) k\n  B4 \\<in> carrier_mat (n - k) (n - k)\n  B = four_block_mat B1 B2 B3 B4", "have\n    Bs: \"B1 \\<in> carrier_mat k k\" \"B2 \\<in> carrier_mat k (n - k)\"\n      \"B3 \\<in> carrier_mat (n - k) k\" \"B4 \\<in> carrier_mat (n - k) (n - k)\"\n    and B: \"B = four_block_mat B1 B2 B3 B4\""], ["proof (prove)\nusing this:\n  B1 \\<in> carrier_mat k k\n  B2 \\<in> carrier_mat k (n - k)\n  B3 \\<in> carrier_mat (n - k) k\n  B4 \\<in> carrier_mat (n - k) (n - k)\n  B = four_block_mat B1 B2 B3 B4\n\ngoal (1 subgoal):\n 1. ((B1 \\<in> carrier_mat k k &&& B2 \\<in> carrier_mat k (n - k)) &&&\n     B3 \\<in> carrier_mat (n - k) k &&&\n     B4 \\<in> carrier_mat (n - k) (n - k)) &&&\n    B = four_block_mat B1 B2 B3 B4", "by auto"], ["proof (state)\nthis:\n  B1 \\<in> carrier_mat k k\n  B2 \\<in> carrier_mat k (n - k)\n  B3 \\<in> carrier_mat (n - k) k\n  B4 \\<in> carrier_mat (n - k) (n - k)\n  B = four_block_mat B1 B2 B3 B4\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have B3: \"B3 = 0\\<^sub>m (n - k) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B3 = 0\\<^sub>m (n - k) k", "unfolding arg_cong[OF spl[symmetric], of \"\\<lambda> (_,_,B,_). B\", unfolded split]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case split_block B k k of (uu_, uua_, B, uub_) \\<Rightarrow> B) =\n    0\\<^sub>m (n - k) k", "unfolding split_block_def Let_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat (dim_row B - k) k (\\<lambda>(i, j). B $$ (i + k, j)) =\n    0\\<^sub>m (n - k) k", "by (rule eq_matI, auto simp: kn zero)"], ["proof (state)\nthis:\n  B3 = 0\\<^sub>m (n - k) k\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from elements_mat_permutes[OF p A B_def]"], ["proof (chain)\npicking this:\n  elements_mat A = elements_mat B", "have elem: \"elements_mat A = elements_mat B\""], ["proof (prove)\nusing this:\n  elements_mat A = elements_mat B\n\ngoal (1 subgoal):\n 1. elements_mat A = elements_mat B", "."], ["proof (state)\nthis:\n  elements_mat A = elements_mat B\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 B B1 B2 B4.\n       similar_mat A B \\<and>\n       elements_mat A = elements_mat B \\<and>\n       B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n       B1 \\<in> carrier_mat n1 n1 \\<and>\n       B2 \\<in> carrier_mat n1 n2 \\<and>\n       B4 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "by (intro exI conjI, rule sim, rule elem, rule B[unfolded B3], insert Bs k0 kn, auto)"], ["proof (state)\nthis:\n  \\<exists>n1 n2 B B1 B2 B4.\n     similar_mat A B \\<and>\n     elements_mat A = elements_mat B \\<and>\n     B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n     B1 \\<in> carrier_mat n1 n1 \\<and>\n     B2 \\<in> carrier_mat n1 n2 \\<and>\n     B4 \\<in> carrier_mat n2 n2 \\<and>\n     0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_irreducible_nonneg_mat_split: \n  fixes A :: \"'a :: linordered_idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  and nonneg: \"nonneg_mat A\" \n  and not: \"\\<not> irreducible_mat A\" \n  and n: \"n > 1\" \nshows \"\\<exists> n1 n2 A1 A2. char_poly A = char_poly A1 * char_poly A2 \n    \\<and> nonneg_mat A1 \\<and> nonneg_mat A2\n    \\<and> A1 \\<in> carrier_mat n1 n1 \\<and> A2 \\<in> carrier_mat n2 n2\n    \\<and> 0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from non_irreducible_mat_split[OF A not n]"], ["proof (chain)\npicking this:\n  \\<exists>n1 n2 B B1 B2 B4.\n     similar_mat A B \\<and>\n     elements_mat A = elements_mat B \\<and>\n     B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n     B1 \\<in> carrier_mat n1 n1 \\<and>\n     B2 \\<in> carrier_mat n1 n2 \\<and>\n     B4 \\<in> carrier_mat n2 n2 \\<and>\n     0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "obtain n1 n2 B B1 B2 B4\n    where sim: \"similar_mat A B\" and elem: \"elements_mat A = elements_mat B\" \n     and B: \"B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4\"\n     and Bs: \"B1 \\<in> carrier_mat n1 n1\" \"B2 \\<in> carrier_mat n1 n2\" \"B4 \\<in> carrier_mat n2 n2\" \n     and n: \"0 < n1\" \"n1 < n\" \"0 < n2\" \"n2 < n\" \"n1 + n2 = n\""], ["proof (prove)\nusing this:\n  \\<exists>n1 n2 B B1 B2 B4.\n     similar_mat A B \\<and>\n     elements_mat A = elements_mat B \\<and>\n     B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4 \\<and>\n     B1 \\<in> carrier_mat n1 n1 \\<and>\n     B2 \\<in> carrier_mat n1 n2 \\<and>\n     B4 \\<in> carrier_mat n2 n2 \\<and>\n     0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\n\ngoal (1 subgoal):\n 1. (\\<And>B B1 B2 n2 n1 B4.\n        \\<lbrakk>similar_mat A B; elements_mat A = elements_mat B;\n         B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4;\n         B1 \\<in> carrier_mat n1 n1; B2 \\<in> carrier_mat n1 n2;\n         B4 \\<in> carrier_mat n2 n2; 0 < n1; n1 < n; 0 < n2; n2 < n;\n         n1 + n2 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  similar_mat A B\n  elements_mat A = elements_mat B\n  B = four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4\n  B1 \\<in> carrier_mat n1 n1\n  B2 \\<in> carrier_mat n1 n2\n  B4 \\<in> carrier_mat n2 n2\n  0 < n1\n  n1 < n\n  0 < n2\n  n2 < n\n  n1 + n2 = n\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from char_poly_similar[OF sim]"], ["proof (chain)\npicking this:\n  char_poly A = char_poly B", "have AB: \"char_poly A = char_poly B\""], ["proof (prove)\nusing this:\n  char_poly A = char_poly B\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "."], ["proof (state)\nthis:\n  char_poly A = char_poly B\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from nonneg"], ["proof (chain)\npicking this:\n  nonneg_mat A", "have nonneg: \"nonneg_mat B\""], ["proof (prove)\nusing this:\n  nonneg_mat A\n\ngoal (1 subgoal):\n 1. nonneg_mat B", "unfolding nonneg_mat_def elem"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>elements_mat B. (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>elements_mat B. (0::'a) \\<le> a", "by auto"], ["proof (state)\nthis:\n  nonneg_mat B\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "have cB: \"char_poly B = char_poly B1 * char_poly B4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly B = char_poly B1 * char_poly B4", "by (rule char_poly_four_block_mat_lower_left_zero[OF B Bs])"], ["proof (state)\nthis:\n  char_poly B = char_poly B1 * char_poly B4\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "from nonneg"], ["proof (chain)\npicking this:\n  nonneg_mat B", "have B1_B4: \"nonneg_mat B1\" \"nonneg_mat B4\""], ["proof (prove)\nusing this:\n  nonneg_mat B\n\ngoal (1 subgoal):\n 1. nonneg_mat B1 &&& nonneg_mat B4", "unfolding B nonneg_mat_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>elements_mat (four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4).\n     (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>elements_mat B1. (0::'a) \\<le> a &&&\n    \\<forall>a\\<in>elements_mat B4. (0::'a) \\<le> a", "using elements_mat_four_block_mat_supseteq[OF Bs(1-2) _ Bs(3), of \"0\\<^sub>m n2 n1\"]"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>elements_mat (four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4).\n     (0::'a) \\<le> a\n  0\\<^sub>m n2 n1 \\<in> carrier_mat n2 n1 \\<Longrightarrow>\n  elements_mat B1 \\<union> elements_mat B2 \\<union>\n  elements_mat (0\\<^sub>m n2 n1) \\<union>\n  elements_mat B4\n  \\<subseteq> elements_mat (four_block_mat B1 B2 (0\\<^sub>m n2 n1) B4)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>elements_mat B1. (0::'a) \\<le> a &&&\n    \\<forall>a\\<in>elements_mat B4. (0::'a) \\<le> a", "by auto"], ["proof (state)\nthis:\n  nonneg_mat B1\n  nonneg_mat B4\n\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n1 n2 A1 A2.\n       char_poly A = char_poly A1 * char_poly A2 \\<and>\n       nonneg_mat A1 \\<and>\n       nonneg_mat A2 \\<and>\n       A1 \\<in> carrier_mat n1 n1 \\<and>\n       A2 \\<in> carrier_mat n2 n2 \\<and>\n       0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "by (intro exI conjI, rule AB[unfolded cB], rule B1_B4, rule B1_B4, \n        rule Bs, rule Bs, insert n, auto)"], ["proof (state)\nthis:\n  \\<exists>n1 n2 A1 A2.\n     char_poly A = char_poly A1 * char_poly A2 \\<and>\n     nonneg_mat A1 \\<and>\n     nonneg_mat A2 \\<and>\n     A1 \\<in> carrier_mat n1 n1 \\<and>\n     A2 \\<in> carrier_mat n2 n2 \\<and>\n     0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The main generalized theorem. The characteristic polynomial of a non-negative\n  real matrix can be represented as a product of roots of unitys (scaled by the \n  the spectral radius sr) and a polynomial where all roots are smaller than the\n  spectral radius.\\<close>"], ["", "theorem perron_frobenius_nonneg: fixes A :: \"real Matrix.mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" and pos: \"nonneg_mat A\" and n: \"n \\<noteq> 0\" \n  shows \"\\<exists> sr ks f. \n    sr \\<ge> 0 \\<and> \n    0 \\<notin> set ks \\<and> ks \\<noteq> [] \\<and>\n    char_poly A = prod_list (map (\\<lambda> k. monom 1 k - [:sr ^ k:]) ks) * f \\<and>\n    (\\<forall> x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "define p where \"p = (\\<lambda> sr k. monom 1 k - [: (sr :: real) ^ k:])\""], ["proof (state)\nthis:\n  p = (\\<lambda>sr k. monom 1 k - [:sr ^ k:])\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?small = \"\\<lambda> f sr. (\\<forall> x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?wit = \"\\<lambda> A sr ks f. sr \\<ge> 0 \\<and> 0 \\<notin> set ks \\<and> ks \\<noteq> [] \\<and>\n    char_poly A = prod_list (map (p sr) ks) * f \\<and> ?small f sr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?c = \"complex_of_real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "interpret c: field_hom ?c"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "interpret p: map_poly_inj_idom_divide_hom ?c"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_divide_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have map_p: \"map_poly ?c (p sr k) = (monom 1 k - [:?c sr^k:])\" for sr k"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (p sr k) =\n    monom 1 k - [:complex_of_real sr ^ k:]", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (monom 1 k - [:sr ^ k:]) =\n    monom 1 k - [:complex_of_real sr ^ k:]", "by (simp add:  hom_distribs)"], ["proof (state)\nthis:\n  map_poly complex_of_real (p ?sr ?k) =\n  monom 1 ?k - [:complex_of_real ?sr ^ ?k:]\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "{"], ["proof (state)\nthis:\n  map_poly complex_of_real (p ?sr ?k) =\n  monom 1 ?k - [:complex_of_real ?sr ^ ?k:]\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "fix k x sr"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "assume 0: \"poly (map_poly ?c (p sr k)) x = 0\" and k: \"k \\<noteq> 0\" and sr: \"sr \\<ge> 0\""], ["proof (state)\nthis:\n  poly (map_poly complex_of_real (p sr k)) x = 0\n  k \\<noteq> 0\n  0 \\<le> sr\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "note 0"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real (p sr k)) x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "also"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real (p sr k)) x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "note map_p"], ["proof (state)\nthis:\n  map_poly complex_of_real (p ?sr ?k) =\n  monom 1 ?k - [:complex_of_real ?sr ^ ?k:]\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "finally"], ["proof (chain)\npicking this:\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0", "have \"x^k = (?c sr)^k\""], ["proof (prove)\nusing this:\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0\n\ngoal (1 subgoal):\n 1. x ^ k = complex_of_real sr ^ k", "by (simp add: poly_monom)"], ["proof (state)\nthis:\n  x ^ k = complex_of_real sr ^ k\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "from arg_cong[OF this, of \"\\<lambda> c. root k (cmod c)\", unfolded norm_power] k"], ["proof (chain)\npicking this:\n  root k (cmod x ^ k) = root k (cmod (complex_of_real sr) ^ k)\n  k \\<noteq> 0", "have \"cmod x = cmod (?c sr)\""], ["proof (prove)\nusing this:\n  root k (cmod x ^ k) = root k (cmod (complex_of_real sr) ^ k)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod x = cmod (complex_of_real sr)", "using real_root_pos2"], ["proof (prove)\nusing this:\n  root k (cmod x ^ k) = root k (cmod (complex_of_real sr) ^ k)\n  k \\<noteq> 0\n  \\<lbrakk>0 < ?n; 0 \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> root ?n (?x ^ ?n) = ?x\n\ngoal (1 subgoal):\n 1. cmod x = cmod (complex_of_real sr)", "by auto"], ["proof (state)\nthis:\n  cmod x = cmod (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "also"], ["proof (state)\nthis:\n  cmod x = cmod (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"\\<dots> = sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real sr) = sr", "using sr"], ["proof (prove)\nusing this:\n  0 \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real sr) = sr", "by auto"], ["proof (state)\nthis:\n  cmod (complex_of_real sr) = sr\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "finally"], ["proof (chain)\npicking this:\n  cmod x = sr", "have \"cmod x = sr\""], ["proof (prove)\nusing this:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. cmod x = sr", "."], ["proof (state)\nthis:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>poly (map_poly complex_of_real (p ?sr2 ?k2)) ?x2 = 0;\n   ?k2 \\<noteq> 0; 0 \\<le> ?sr2\\<rbrakk>\n  \\<Longrightarrow> cmod ?x2 = ?sr2\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "note p_conv = this"], ["proof (state)\nthis:\n  \\<lbrakk>poly (map_poly complex_of_real (p ?sr2 ?k2)) ?x2 = 0;\n   ?k2 \\<noteq> 0; 0 \\<le> ?sr2\\<rbrakk>\n  \\<Longrightarrow> cmod ?x2 = ?sr2\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"\\<exists> sr ks f. ?wit A sr ks f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "using A pos n"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  nonneg_mat A\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof (induct n arbitrary: A rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "case (less n A)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; ?A \\<in> carrier_mat ?y ?y; nonneg_mat ?A;\n   ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sr ks f.\n                       0 \\<le> sr \\<and>\n                       0 \\<notin> set ks \\<and>\n                       ks \\<noteq> [] \\<and>\n                       char_poly ?A = prod_list (map (p sr) ks) * f \\<and>\n                       (\\<forall>x.\n                           poly (map_poly complex_of_real f) x =\n                           0 \\<longrightarrow>\n                           cmod x < sr)\n  A \\<in> carrier_mat n n\n  nonneg_mat A\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "note pos = less(3)"], ["proof (state)\nthis:\n  nonneg_mat A\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "note A = less(2)"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; ?A \\<in> carrier_mat ?y ?y; nonneg_mat ?A;\n   ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sr ks f.\n                       0 \\<le> sr \\<and>\n                       0 \\<notin> set ks \\<and>\n                       ks \\<noteq> [] \\<and>\n                       char_poly ?A = prod_list (map (p sr) ks) * f \\<and>\n                       (\\<forall>x.\n                           poly (map_poly complex_of_real f) x =\n                           0 \\<longrightarrow>\n                           cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "note n = less(4)"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "consider (1) \"n = 1\"\n      | (irr) \"irreducible_mat A\" \n      | (red) \"\\<not> irreducible_mat A\" \"n > 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 1 \\<Longrightarrow> thesis;\n     irreducible_mat A \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   irreducible_mat A \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>y A.\n                   \\<lbrakk>y < x; A \\<in> carrier_mat y y; nonneg_mat A;\n                    y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>sr ks f.\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n      cmod x < sr);\n        A \\<in> carrier_mat x x; nonneg_mat A; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            prod_list (map (p sr) ks) * f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "thus \"\\<exists> sr ks f. ?wit A sr ks f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   irreducible_mat A \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. irreducible_mat A \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "case irr"], ["proof (state)\nthis:\n  irreducible_mat A\n\ngoal (3 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. irreducible_mat A \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "from perron_frobenius_irreducible(3,6)[OF A n pos irr refl refl]"], ["proof (chain)\npicking this:\n  0 < Spectral_Radius.spectral_radius (of_real_hom.mat_hom A)\n  \\<exists>k f.\n     k \\<noteq> 0 \\<and>\n     k \\<le> n \\<and>\n     char_poly A =\n     (monom 1 k -\n      [:Spectral_Radius.spectral_radius (of_real_hom.mat_hom A) ^ k:]) *\n     f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < Spectral_Radius.spectral_radius (of_real_hom.mat_hom A))", "obtain sr k f where \n        *: \"sr > 0\" \"k \\<noteq> 0\" \"char_poly A = p sr k * f\" \"?small f sr\""], ["proof (prove)\nusing this:\n  0 < Spectral_Radius.spectral_radius (of_real_hom.mat_hom A)\n  \\<exists>k f.\n     k \\<noteq> 0 \\<and>\n     k \\<le> n \\<and>\n     char_poly A =\n     (monom 1 k -\n      [:Spectral_Radius.spectral_radius (of_real_hom.mat_hom A) ^ k:]) *\n     f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < Spectral_Radius.spectral_radius (of_real_hom.mat_hom A))\n\ngoal (1 subgoal):\n 1. (\\<And>sr k f.\n        \\<lbrakk>0 < sr; k \\<noteq> 0; char_poly A = p sr k * f;\n         \\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding p_def"], ["proof (prove)\nusing this:\n  0 < Spectral_Radius.spectral_radius (of_real_hom.mat_hom A)\n  \\<exists>k f.\n     k \\<noteq> 0 \\<and>\n     k \\<le> n \\<and>\n     char_poly A =\n     (monom 1 k -\n      [:Spectral_Radius.spectral_radius (of_real_hom.mat_hom A) ^ k:]) *\n     f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < Spectral_Radius.spectral_radius (of_real_hom.mat_hom A))\n\ngoal (1 subgoal):\n 1. (\\<And>sr k f.\n        \\<lbrakk>0 < sr; k \\<noteq> 0;\n         char_poly A = (monom 1 k - [:sr ^ k:]) * f;\n         \\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < sr\n  k \\<noteq> 0\n  char_poly A = p sr k * f\n  \\<forall>x.\n     poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr\n\ngoal (3 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. irreducible_mat A \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "hence \"?wit A sr [k] f\""], ["proof (prove)\nusing this:\n  0 < sr\n  k \\<noteq> 0\n  char_poly A = p sr k * f\n  \\<forall>x.\n     poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr\n\ngoal (1 subgoal):\n 1. 0 \\<le> sr \\<and>\n    0 \\<notin> set [k] \\<and>\n    [k] \\<noteq> [] \\<and>\n    char_poly A = prod_list (map (p sr) [k]) * f \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n        cmod x < sr)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> sr \\<and>\n  0 \\<notin> set [k] \\<and>\n  [k] \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) [k]) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n\ngoal (3 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. irreducible_mat A \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> sr \\<and>\n  0 \\<notin> set [k] \\<and>\n  [k] \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) [k]) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by blast"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "case red"], ["proof (state)\nthis:\n  \\<not> irreducible_mat A\n  1 < n\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "from non_irreducible_nonneg_mat_split[OF A pos red]"], ["proof (chain)\npicking this:\n  \\<exists>n1 n2 A1 A2.\n     char_poly A = char_poly A1 * char_poly A2 \\<and>\n     nonneg_mat A1 \\<and>\n     nonneg_mat A2 \\<and>\n     A1 \\<in> carrier_mat n1 n1 \\<and>\n     A2 \\<in> carrier_mat n2 n2 \\<and>\n     0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n", "obtain n1 n2 A1 A2\n        where char:  \"char_poly A = char_poly A1 * char_poly A2\" \n          and pos: \"nonneg_mat A1\" \"nonneg_mat A2\" \n          and A: \"A1 \\<in> carrier_mat n1 n1\" \"A2 \\<in> carrier_mat n2 n2\" \n          and n: \"n1 < n\" \"n2 < n\" \n          and n0: \"n1 \\<noteq> 0\" \"n2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>n1 n2 A1 A2.\n     char_poly A = char_poly A1 * char_poly A2 \\<and>\n     nonneg_mat A1 \\<and>\n     nonneg_mat A2 \\<and>\n     A1 \\<in> carrier_mat n1 n1 \\<and>\n     A2 \\<in> carrier_mat n2 n2 \\<and>\n     0 < n1 \\<and> n1 < n \\<and> 0 < n2 \\<and> n2 < n \\<and> n1 + n2 = n\n\ngoal (1 subgoal):\n 1. (\\<And>A1 A2 n1 n2.\n        \\<lbrakk>char_poly A = char_poly A1 * char_poly A2; nonneg_mat A1;\n         nonneg_mat A2; A1 \\<in> carrier_mat n1 n1;\n         A2 \\<in> carrier_mat n2 n2; n1 < n; n2 < n; n1 \\<noteq> 0;\n         n2 \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly A = char_poly A1 * char_poly A2\n  nonneg_mat A1\n  nonneg_mat A2\n  A1 \\<in> carrier_mat n1 n1\n  A2 \\<in> carrier_mat n2 n2\n  n1 < n\n  n2 < n\n  n1 \\<noteq> 0\n  n2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "from IH[OF n(1) A(1) pos(1) n0(1)]"], ["proof (chain)\npicking this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A1 = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "obtain sr1 ks1 f1 where 1: \"?wit A1 sr1 ks1 f1\""], ["proof (prove)\nusing this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A1 = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. (\\<And>sr1 ks1 f1.\n        0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> sr1 \\<and>\n  0 \\<notin> set ks1 \\<and>\n  ks1 \\<noteq> [] \\<and>\n  char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n      cmod x < sr1)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "from IH[OF n(2) A(2) pos(2) n0(2)]"], ["proof (chain)\npicking this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A2 = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "obtain sr2 ks2 f2 where 2: \"?wit A2 sr2 ks2 f2\""], ["proof (prove)\nusing this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A2 = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. (\\<And>sr2 ks2 f2.\n        0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> sr2 \\<and>\n  0 \\<notin> set ks2 \\<and>\n  ks2 \\<noteq> [] \\<and>\n  char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n      cmod x < sr2)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "have \"\\<exists> A1 A2 sr1 ks1 f1 sr2 ks2 f2. ?wit A1 sr1 ks1 f1 \\<and> ?wit A2 sr2 ks2 f2 \\<and> \n         sr1 \\<ge> sr2 \\<and> char_poly A = char_poly A1 * char_poly A2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "proof (cases \"sr1 \\<ge> sr2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2\n 2. \\<not> sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "case True"], ["proof (state)\nthis:\n  sr2 \\<le> sr1\n\ngoal (2 subgoals):\n 1. sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2\n 2. \\<not> sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "unfolding char"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A1a A2a sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1a = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2a = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and>\n       char_poly A1 * char_poly A2 = char_poly A1a * char_poly A2a", "by (intro exI, rule conjI[OF 1 conjI[OF 2]], insert True, auto)"], ["proof (state)\nthis:\n  \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n     (0 \\<le> sr1 \\<and>\n      0 \\<notin> set ks1 \\<and>\n      ks1 \\<noteq> [] \\<and>\n      char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n          cmod x < sr1)) \\<and>\n     (0 \\<le> sr2 \\<and>\n      0 \\<notin> set ks2 \\<and>\n      ks2 \\<noteq> [] \\<and>\n      char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n          cmod x < sr2)) \\<and>\n     sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2\n\ngoal (1 subgoal):\n 1. \\<not> sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "case False"], ["proof (state)\nthis:\n  \\<not> sr2 \\<le> sr1\n\ngoal (1 subgoal):\n 1. \\<not> sr2 \\<le> sr1 \\<Longrightarrow>\n    \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "unfolding char"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A1a A2a sr1 ks1 f1 sr2 ks2 f2.\n       (0 \\<le> sr1 \\<and>\n        0 \\<notin> set ks1 \\<and>\n        ks1 \\<noteq> [] \\<and>\n        char_poly A1a = prod_list (map (p sr1) ks1) * f1 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n            cmod x < sr1)) \\<and>\n       (0 \\<le> sr2 \\<and>\n        0 \\<notin> set ks2 \\<and>\n        ks2 \\<noteq> [] \\<and>\n        char_poly A2a = prod_list (map (p sr2) ks2) * f2 \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n            cmod x < sr2)) \\<and>\n       sr2 \\<le> sr1 \\<and>\n       char_poly A1 * char_poly A2 = char_poly A1a * char_poly A2a", "by (intro exI, rule conjI[OF 2 conjI[OF 1]], insert False, auto)"], ["proof (state)\nthis:\n  \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n     (0 \\<le> sr1 \\<and>\n      0 \\<notin> set ks1 \\<and>\n      ks1 \\<noteq> [] \\<and>\n      char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n          cmod x < sr1)) \\<and>\n     (0 \\<le> sr2 \\<and>\n      0 \\<notin> set ks2 \\<and>\n      ks2 \\<noteq> [] \\<and>\n      char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n          cmod x < sr2)) \\<and>\n     sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n     (0 \\<le> sr1 \\<and>\n      0 \\<notin> set ks1 \\<and>\n      ks1 \\<noteq> [] \\<and>\n      char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n          cmod x < sr1)) \\<and>\n     (0 \\<le> sr2 \\<and>\n      0 \\<notin> set ks2 \\<and>\n      ks2 \\<noteq> [] \\<and>\n      char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n          cmod x < sr2)) \\<and>\n     sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "then"], ["proof (chain)\npicking this:\n  \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n     (0 \\<le> sr1 \\<and>\n      0 \\<notin> set ks1 \\<and>\n      ks1 \\<noteq> [] \\<and>\n      char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n          cmod x < sr1)) \\<and>\n     (0 \\<le> sr2 \\<and>\n      0 \\<notin> set ks2 \\<and>\n      ks2 \\<noteq> [] \\<and>\n      char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n          cmod x < sr2)) \\<and>\n     sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2", "obtain A1 A2 sr1 ks1 f1 sr2 ks2 f2 where \n        1: \"?wit A1 sr1 ks1 f1\" and 2: \"?wit A2 sr2 ks2 f2\" and \n        sr: \"sr1 \\<ge> sr2\" and char: \"char_poly A = char_poly A1 * char_poly A2\""], ["proof (prove)\nusing this:\n  \\<exists>A1 A2 sr1 ks1 f1 sr2 ks2 f2.\n     (0 \\<le> sr1 \\<and>\n      0 \\<notin> set ks1 \\<and>\n      ks1 \\<noteq> [] \\<and>\n      char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n          cmod x < sr1)) \\<and>\n     (0 \\<le> sr2 \\<and>\n      0 \\<notin> set ks2 \\<and>\n      ks2 \\<noteq> [] \\<and>\n      char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n      (\\<forall>x.\n          poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n          cmod x < sr2)) \\<and>\n     sr2 \\<le> sr1 \\<and> char_poly A = char_poly A1 * char_poly A2\n\ngoal (1 subgoal):\n 1. (\\<And>sr1 ks1 A1 f1 sr2 ks2 A2 f2.\n        \\<lbrakk>0 \\<le> sr1 \\<and>\n                 0 \\<notin> set ks1 \\<and>\n                 ks1 \\<noteq> [] \\<and>\n                 char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n                 (\\<forall>x.\n                     poly (map_poly complex_of_real f1) x =\n                     0 \\<longrightarrow>\n                     cmod x < sr1);\n         0 \\<le> sr2 \\<and>\n         0 \\<notin> set ks2 \\<and>\n         ks2 \\<noteq> [] \\<and>\n         char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n         (\\<forall>x.\n             poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n             cmod x < sr2);\n         sr2 \\<le> sr1; char_poly A = char_poly A1 * char_poly A2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> sr1 \\<and>\n  0 \\<notin> set ks1 \\<and>\n  ks1 \\<noteq> [] \\<and>\n  char_poly A1 = prod_list (map (p sr1) ks1) * f1 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f1) x = 0 \\<longrightarrow>\n      cmod x < sr1)\n  0 \\<le> sr2 \\<and>\n  0 \\<notin> set ks2 \\<and>\n  ks2 \\<noteq> [] \\<and>\n  char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n      cmod x < sr2)\n  sr2 \\<le> sr1\n  char_poly A = char_poly A1 * char_poly A2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. \\<lbrakk>\\<not> irreducible_mat A; 1 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sr ks f.\n                         0 \\<le> sr \\<and>\n                         0 \\<notin> set ks \\<and>\n                         ks \\<noteq> [] \\<and>\n                         char_poly A = prod_list (map (p sr) ks) * f \\<and>\n                         (\\<forall>x.\n                             poly (map_poly complex_of_real f) x =\n                             0 \\<longrightarrow>\n                             cmod x < sr)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof (cases \"sr1 = sr2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sr1 = sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "case True"], ["proof (state)\nthis:\n  sr1 = sr2\n\ngoal (2 subgoals):\n 1. sr1 = sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"?wit A sr2 (ks1 @ ks2) (f1 * f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sr2 \\<and>\n    0 \\<notin> set (ks1 @ ks2) \\<and>\n    ks1 @ ks2 \\<noteq> [] \\<and>\n    char_poly A = prod_list (map (p sr2) (ks1 @ ks2)) * (f1 * f2) \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real (f1 * f2)) x = 0 \\<longrightarrow>\n        cmod x < sr2)", "unfolding char"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sr2 \\<and>\n    0 \\<notin> set (ks1 @ ks2) \\<and>\n    ks1 @ ks2 \\<noteq> [] \\<and>\n    char_poly A1 * char_poly A2 =\n    prod_list (map (p sr2) (ks1 @ ks2)) * (f1 * f2) \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real (f1 * f2)) x = 0 \\<longrightarrow>\n        cmod x < sr2)", "by (insert 1 2 True, auto simp: True p.hom_mult)"], ["proof (state)\nthis:\n  0 \\<le> sr2 \\<and>\n  0 \\<notin> set (ks1 @ ks2) \\<and>\n  ks1 @ ks2 \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr2) (ks1 @ ks2)) * (f1 * f2) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real (f1 * f2)) x = 0 \\<longrightarrow>\n      cmod x < sr2)\n\ngoal (2 subgoals):\n 1. sr1 = sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> sr2 \\<and>\n  0 \\<notin> set (ks1 @ ks2) \\<and>\n  ks1 @ ks2 \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr2) (ks1 @ ks2)) * (f1 * f2) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real (f1 * f2)) x = 0 \\<longrightarrow>\n      cmod x < sr2)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by blast"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "case False"], ["proof (state)\nthis:\n  sr1 \\<noteq> sr2\n\ngoal (1 subgoal):\n 1. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "with sr"], ["proof (chain)\npicking this:\n  sr2 \\<le> sr1\n  sr1 \\<noteq> sr2", "have sr1: \"sr1 > sr2\""], ["proof (prove)\nusing this:\n  sr2 \\<le> sr1\n  sr1 \\<noteq> sr2\n\ngoal (1 subgoal):\n 1. sr2 < sr1", "by auto"], ["proof (state)\nthis:\n  sr2 < sr1\n\ngoal (1 subgoal):\n 1. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have lt: \"poly (map_poly ?c (p sr2 k)) x = 0 \\<Longrightarrow> k \\<in> set ks2 \\<Longrightarrow> cmod x < sr1\" for k x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly (map_poly complex_of_real (p sr2 k)) x = 0;\n     k \\<in> set ks2\\<rbrakk>\n    \\<Longrightarrow> cmod x < sr1", "using sr1 p_conv[of sr2 k x] 2"], ["proof (prove)\nusing this:\n  sr2 < sr1\n  \\<lbrakk>poly (map_poly complex_of_real (p sr2 k)) x = 0; k \\<noteq> 0;\n   0 \\<le> sr2\\<rbrakk>\n  \\<Longrightarrow> cmod x = sr2\n  0 \\<le> sr2 \\<and>\n  0 \\<notin> set ks2 \\<and>\n  ks2 \\<noteq> [] \\<and>\n  char_poly A2 = prod_list (map (p sr2) ks2) * f2 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f2) x = 0 \\<longrightarrow>\n      cmod x < sr2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly (map_poly complex_of_real (p sr2 k)) x = 0;\n     k \\<in> set ks2\\<rbrakk>\n    \\<Longrightarrow> cmod x < sr1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>poly (map_poly complex_of_real (p sr2 ?k)) ?x = 0;\n   ?k \\<in> set ks2\\<rbrakk>\n  \\<Longrightarrow> cmod ?x < sr1\n\ngoal (1 subgoal):\n 1. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"?wit A sr1 ks1 (f1 * f2 * prod_list (map (p sr2) ks2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sr1 \\<and>\n    0 \\<notin> set ks1 \\<and>\n    ks1 \\<noteq> [] \\<and>\n    char_poly A =\n    prod_list (map (p sr1) ks1) *\n    (f1 * f2 * prod_list (map (p sr2) ks2)) \\<and>\n    (\\<forall>x.\n        poly\n         (map_poly complex_of_real (f1 * f2 * prod_list (map (p sr2) ks2)))\n         x =\n        0 \\<longrightarrow>\n        cmod x < sr1)", "unfolding char"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sr1 \\<and>\n    0 \\<notin> set ks1 \\<and>\n    ks1 \\<noteq> [] \\<and>\n    char_poly A1 * char_poly A2 =\n    prod_list (map (p sr1) ks1) *\n    (f1 * f2 * prod_list (map (p sr2) ks2)) \\<and>\n    (\\<forall>x.\n        poly\n         (map_poly complex_of_real (f1 * f2 * prod_list (map (p sr2) ks2)))\n         x =\n        0 \\<longrightarrow>\n        cmod x < sr1)", "by (insert 1 2 sr1 lt, auto simp: p.hom_mult p.hom_prod_list \n          poly_prod_list prod_list_zero_iff)"], ["proof (state)\nthis:\n  0 \\<le> sr1 \\<and>\n  0 \\<notin> set ks1 \\<and>\n  ks1 \\<noteq> [] \\<and>\n  char_poly A =\n  prod_list (map (p sr1) ks1) *\n  (f1 * f2 * prod_list (map (p sr2) ks2)) \\<and>\n  (\\<forall>x.\n      poly\n       (map_poly complex_of_real (f1 * f2 * prod_list (map (p sr2) ks2)))\n       x =\n      0 \\<longrightarrow>\n      cmod x < sr1)\n\ngoal (1 subgoal):\n 1. sr1 \\<noteq> sr2 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> sr1 \\<and>\n  0 \\<notin> set ks1 \\<and>\n  ks1 \\<noteq> [] \\<and>\n  char_poly A =\n  prod_list (map (p sr1) ks1) *\n  (f1 * f2 * prod_list (map (p sr2) ks2)) \\<and>\n  (\\<forall>x.\n      poly\n       (map_poly complex_of_real (f1 * f2 * prod_list (map (p sr2) ks2)))\n       x =\n      0 \\<longrightarrow>\n      cmod x < sr1)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by blast"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "case 1"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "define a where \"a = A $$ (0,0)\""], ["proof (state)\nthis:\n  a = A $$ (0, 0)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have A: \"A = Matrix.mat 1 1 (\\<lambda> x. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Matrix.mat 1 1 (\\<lambda>x. a)", "by (rule eq_matI, unfold a_def, insert A 1(1), auto)"], ["proof (state)\nthis:\n  A = Matrix.mat 1 1 (\\<lambda>x. a)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have char: \"char_poly A = [: - a, 1 :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = [:- a, 1:]", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (Matrix.mat 1 1 (\\<lambda>x. a)) = [:- a, 1:]", "by (auto simp: Determinant.det_def char_poly_def char_poly_matrix_def)"], ["proof (state)\nthis:\n  char_poly A = [:- a, 1:]\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "from pos A"], ["proof (chain)\npicking this:\n  nonneg_mat A\n  A = Matrix.mat 1 1 (\\<lambda>x. a)", "have a: \"a \\<ge> 0\""], ["proof (prove)\nusing this:\n  nonneg_mat A\n  A = Matrix.mat 1 1 (\\<lambda>x. a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> a", "unfolding nonneg_mat_def elements_mat"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A}.\n     0 \\<le> a\n  A = Matrix.mat 1 1 (\\<lambda>x. a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> a", "by auto"], ["proof (state)\nthis:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"?wit A a [1] 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and>\n    0 \\<notin> set [1] \\<and>\n    [1] \\<noteq> [] \\<and>\n    char_poly A = prod_list (map (p a) [1]) * 1 \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real 1) x = 0 \\<longrightarrow>\n        cmod x < a)", "unfolding char"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and>\n    0 \\<notin> set [1] \\<and>\n    [1] \\<noteq> [] \\<and>\n    [:- a, 1:] = prod_list (map (p a) [1]) * 1 \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real 1) x = 0 \\<longrightarrow>\n        cmod x < a)", "using a"], ["proof (prove)\nusing this:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and>\n    0 \\<notin> set [1] \\<and>\n    [1] \\<noteq> [] \\<and>\n    [:- a, 1:] = prod_list (map (p a) [1]) * 1 \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real 1) x = 0 \\<longrightarrow>\n        cmod x < a)", "by (auto simp: p_def monom_Suc)"], ["proof (state)\nthis:\n  0 \\<le> a \\<and>\n  0 \\<notin> set [1] \\<and>\n  [1] \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p a) [1]) * 1 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real 1) x = 0 \\<longrightarrow> cmod x < a)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> a \\<and>\n  0 \\<notin> set [1] \\<and>\n  [1] \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p a) [1]) * 1 \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real 1) x = 0 \\<longrightarrow> cmod x < a)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A = prod_list (map (p sr) ks) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by blast"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "then"], ["proof (chain)\npicking this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "obtain sr ks f where wit: \"?wit A sr ks f\""], ["proof (prove)\nusing this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A = prod_list (map (p sr) ks) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. (\\<And>sr ks f.\n        0 \\<le> sr \\<and>\n        0 \\<notin> set ks \\<and>\n        ks \\<noteq> [] \\<and>\n        char_poly A = prod_list (map (p sr) ks) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "using wit"], ["proof (prove)\nusing this:\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = prod_list (map (p sr) ks) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "unfolding p_def"], ["proof (prove)\nusing this:\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n  0 \\<le> sr \\<and>\n  0 \\<notin> set ks \\<and>\n  ks \\<noteq> [] \\<and>\n  char_poly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by auto"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A =\n     (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>And back to HMA world via transfer.\\<close>"], ["", "theorem perron_frobenius_non_neg: fixes A :: \"real ^ 'n ^ 'n\"\n  assumes pos: \"non_neg_mat A\" \n  shows \"\\<exists> sr ks f. \n    sr \\<ge> 0 \\<and> \n    0 \\<notin> set ks \\<and> ks \\<noteq> [] \\<and>\n    charpoly A = prod_list (map (\\<lambda> k. monom 1 k - [:sr ^ k:]) ks) * f \\<and>\n    (\\<forall> x. poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       charpoly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "using pos"], ["proof (prove)\nusing this:\n  non_neg_mat A\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       charpoly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat CARD('n) CARD('n); nonneg_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            (\\<Prod>k\\<leftarrow>ks. monom 1 k -\n               [:sr ^ k:]) *\n                            f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "case (1 A)"], ["proof (state)\nthis:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  nonneg_mat A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat CARD('n) CARD('n); nonneg_mat A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sr ks f.\n                            0 \\<le> sr \\<and>\n                            0 \\<notin> set ks \\<and>\n                            ks \\<noteq> [] \\<and>\n                            char_poly A =\n                            (\\<Prod>k\\<leftarrow>ks. monom 1 k -\n               [:sr ^ k:]) *\n                            f \\<and>\n                            (\\<forall>x.\n                                poly (map_poly complex_of_real f) x =\n                                0 \\<longrightarrow>\n                                cmod x < sr)", "from perron_frobenius_nonneg[OF 1]"], ["proof (chain)\npicking this:\n  CARD('n) \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A =\n     (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "show ?case"], ["proof (prove)\nusing this:\n  CARD('n) \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A =\n     (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. \\<exists>sr ks f.\n       0 \\<le> sr \\<and>\n       0 \\<notin> set ks \\<and>\n       ks \\<noteq> [] \\<and>\n       char_poly A =\n       (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "by auto"], ["proof (state)\nthis:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     char_poly A =\n     (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now specialize the theorem for complexity analysis where\n  we are mainly interested in the case where the spectral radius is as most 1.\n  Note that this can be checked by tested that there are no real roots of the\n  characteristic polynomial which exceed 1.\n\n  Moreover, here the existential quantifier over the factorization is replaced\n  by @{const decompose_prod_root_unity}, an algorithm which computes this factorization \n  in an efficient way.\\<close>"], ["", "lemma perron_frobenius_for_complexity: fixes A :: \"real ^ 'n ^ 'n\" and f :: \"real poly\" \n  defines \"cA \\<equiv> map_matrix complex_of_real A\" \n  defines \"cf \\<equiv> map_poly complex_of_real f\" \n  assumes pos: \"non_neg_mat A\" \n   and sr: \"\\<And> x. poly (charpoly A) x = 0 \\<Longrightarrow> x \\<le> 1\"\n   and decomp: \"decompose_prod_root_unity (charpoly A) = (ks, f)\" \n  shows \"0 \\<notin> set ks\" \n   \"charpoly A = prod_root_unity ks * f\"\n   \"charpoly cA = prod_root_unity ks * cf\"\n   \"\\<And> x. poly (charpoly cA) x = 0 \\<Longrightarrow> cmod x \\<le> 1\" \n   \"\\<And> x. poly cf x = 0 \\<Longrightarrow> cmod x < 1\" \n   \"\\<And> x. cmod x = 1 \\<Longrightarrow> order x (charpoly cA) = length [k\\<leftarrow>ks . x ^ k = 1]\" \n   \"\\<And> x. cmod x = 1 \\<Longrightarrow> poly (charpoly cA) x = 0 \\<Longrightarrow> \\<exists> k \\<in> set ks. x^k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks &&&\n     charpoly A = prod_root_unity ks * f &&&\n     charpoly cA = prod_root_unity ks * cf) &&&\n    ((\\<And>x.\n         poly (charpoly cA) x = 0 \\<Longrightarrow> cmod x \\<le> 1) &&&\n     (\\<And>x. poly cf x = 0 \\<Longrightarrow> cmod x < 1)) &&&\n    (\\<And>x.\n        cmod x = 1 \\<Longrightarrow>\n        order x (charpoly cA) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) &&&\n    (\\<And>x.\n        \\<lbrakk>cmod x = 1; poly (charpoly cA) x = 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>k\\<in>set ks. x ^ k = 1)", "unfolding cf_def cA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks &&&\n     charpoly A = prod_root_unity ks * f &&&\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) &&&\n    ((\\<And>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<Longrightarrow>\n         cmod x \\<le> 1) &&&\n     (\\<And>x.\n         poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow>\n         cmod x < 1)) &&&\n    (\\<And>x.\n        cmod x = 1 \\<Longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) &&&\n    (\\<And>x.\n        \\<lbrakk>cmod x = 1;\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>k\\<in>set ks. x ^ k = 1)", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "let ?c = \"complex_of_real\""], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "let ?cp = \"map_poly ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "let ?A = \"map_matrix ?c A\""], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "let ?wit = \"\\<lambda> ks f. 0 \\<notin> set ks \\<and> \n    charpoly A = prod_root_unity ks * f \\<and>\n    charpoly ?A = prod_root_unity ks * map_poly of_real f \\<and>\n    (\\<forall> x. poly (charpoly ?A) x = 0 \\<longrightarrow> cmod x \\<le> 1) \\<and>\n    (\\<forall> x. poly (?cp f) x = 0 \\<longrightarrow> cmod x < 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "interpret field_hom ?c"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "interpret p: map_poly_inj_idom_divide_hom ?c"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_divide_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from perron_frobenius_non_neg[OF pos]"], ["proof (chain)\npicking this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     charpoly A =\n     (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)", "obtain sr ks f \n      where *: \"sr \\<ge> 0\" \"0 \\<notin> set ks\" \"ks \\<noteq> []\" \n       and cp: \"charpoly A = prod_list (map (\\<lambda> k. monom 1 k - [:sr ^ k:]) ks) * f\" \n       and small: \"\\<And> x. poly (?cp f) x = 0 \\<Longrightarrow> cmod x < sr\""], ["proof (prove)\nusing this:\n  \\<exists>sr ks f.\n     0 \\<le> sr \\<and>\n     0 \\<notin> set ks \\<and>\n     ks \\<noteq> [] \\<and>\n     charpoly A =\n     (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal (1 subgoal):\n 1. (\\<And>sr ks f.\n        \\<lbrakk>0 \\<le> sr; 0 \\<notin> set ks; ks \\<noteq> [];\n         charpoly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f;\n         \\<And>x.\n            poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow>\n            cmod x < sr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> sr\n  0 \\<notin> set ks\n  ks \\<noteq> []\n  charpoly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f\n  poly (map_poly complex_of_real f) ?x = 0 \\<Longrightarrow> cmod ?x < sr\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from arg_cong[OF cp, of \"map_poly ?c\"]"], ["proof (chain)\npicking this:\n  map_poly complex_of_real (charpoly A) =\n  map_poly complex_of_real\n   ((\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f)", "have cpc: \"charpoly ?A = prod_list (map (\\<lambda> k. monom 1 k - [:?c sr ^ k:]) ks) * map_poly ?c f\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real (charpoly A) =\n  map_poly complex_of_real\n   ((\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f)\n\ngoal (1 subgoal):\n 1. charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:complex_of_real sr ^ k:]) *\n    map_poly complex_of_real f", "by (simp add: charpoly_of_real hom_distribs p.prod_list_map_hom[symmetric] o_def)"], ["proof (state)\nthis:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:complex_of_real sr ^ k:]) *\n  map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have sr_le_1: \"sr \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr \\<le> 1", "by (rule sr, unfold cp, insert *, cases ks, auto simp: poly_monom)"], ["proof (state)\nthis:\n  sr \\<le> 1\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "{"], ["proof (state)\nthis:\n  sr \\<le> 1\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "note [simp] = prod_list_zero_iff o_def poly_monom"], ["proof (state)\nthis:\n  (prod_list ?xs = (0::?'a)) = ((0::?'a) \\<in> set ?xs)\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  poly (monom ?a ?n) ?x = ?a * ?x ^ ?n\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "assume \"poly (charpoly ?A) x = 0\""], ["proof (state)\nthis:\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x = 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from this[unfolded cpc poly_mult poly_prod_list] small[of x]"], ["proof (chain)\npicking this:\n  (\\<Prod>p\\<leftarrow>map (\\<lambda>k.\n                               monom 1 k - [:complex_of_real sr ^ k:])\n                        ks. poly p x) *\n  poly (map_poly complex_of_real f) x =\n  0\n  poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "consider (lt) \"cmod x < sr\" | (mem) k where \"k \\<in> set ks\" \"x ^ k = (?c sr) ^ k\""], ["proof (prove)\nusing this:\n  (\\<Prod>p\\<leftarrow>map (\\<lambda>k.\n                               monom 1 k - [:complex_of_real sr ^ k:])\n                        ks. poly p x) *\n  poly (map_poly complex_of_real f) x =\n  0\n  poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod x < sr \\<Longrightarrow> thesis;\n     \\<And>k.\n        \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>cmod x < sr \\<Longrightarrow> ?thesis;\n   \\<And>k.\n      \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "hence \"cmod x \\<le> sr\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cmod x < sr \\<Longrightarrow> ?thesis;\n   \\<And>k.\n      \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cmod x \\<le> sr", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. cmod x < sr \\<Longrightarrow> cmod x \\<le> sr\n 2. \\<And>k.\n       \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n       \\<Longrightarrow> cmod x \\<le> sr", "case (mem k)"], ["proof (state)\nthis:\n  k \\<in> set ks\n  x ^ k = complex_of_real sr ^ k\n\ngoal (2 subgoals):\n 1. cmod x < sr \\<Longrightarrow> cmod x \\<le> sr\n 2. \\<And>k.\n       \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n       \\<Longrightarrow> cmod x \\<le> sr", "with *"], ["proof (chain)\npicking this:\n  0 \\<le> sr\n  0 \\<notin> set ks\n  ks \\<noteq> []\n  k \\<in> set ks\n  x ^ k = complex_of_real sr ^ k", "have k: \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> sr\n  0 \\<notin> set ks\n  ks \\<noteq> []\n  k \\<in> set ks\n  x ^ k = complex_of_real sr ^ k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by metis"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. cmod x < sr \\<Longrightarrow> cmod x \\<le> sr\n 2. \\<And>k.\n       \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n       \\<Longrightarrow> cmod x \\<le> sr", "with arg_cong[OF mem(2), of \"\\<lambda> x. root k (cmod x)\", unfolded norm_power] \n          real_root_pos2[of k] *(1)"], ["proof (chain)\npicking this:\n  root k (cmod x ^ k) = root k (cmod (complex_of_real sr) ^ k)\n  \\<lbrakk>0 < k; 0 \\<le> ?x\\<rbrakk> \\<Longrightarrow> root k (?x ^ k) = ?x\n  0 \\<le> sr\n  k \\<noteq> 0", "have \"cmod x = sr\""], ["proof (prove)\nusing this:\n  root k (cmod x ^ k) = root k (cmod (complex_of_real sr) ^ k)\n  \\<lbrakk>0 < k; 0 \\<le> ?x\\<rbrakk> \\<Longrightarrow> root k (?x ^ k) = ?x\n  0 \\<le> sr\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod x = sr", "by auto"], ["proof (state)\nthis:\n  cmod x = sr\n\ngoal (2 subgoals):\n 1. cmod x < sr \\<Longrightarrow> cmod x \\<le> sr\n 2. \\<And>k.\n       \\<lbrakk>k \\<in> set ks; x ^ k = complex_of_real sr ^ k\\<rbrakk>\n       \\<Longrightarrow> cmod x \\<le> sr", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. cmod x \\<le> sr", "by auto"], ["proof (state)\nthis:\n  cmod x \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod x < sr \\<Longrightarrow> cmod x \\<le> sr", "qed simp"], ["proof (state)\nthis:\n  cmod x \\<le> sr\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "}"], ["proof (state)\nthis:\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n  0 \\<Longrightarrow>\n  cmod ?x2 \\<le> sr\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "note root = this"], ["proof (state)\nthis:\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n  0 \\<Longrightarrow>\n  cmod ?x2 \\<le> sr\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have \"\\<exists> ks f. ?wit ks f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "proof (cases \"sr = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sr = 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)\n 2. sr \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "case False"], ["proof (state)\nthis:\n  sr \\<noteq> 1\n\ngoal (2 subgoals):\n 1. sr = 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)\n 2. sr \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "with sr_le_1"], ["proof (chain)\npicking this:\n  sr \\<le> 1\n  sr \\<noteq> 1", "have *: \"cmod x \\<le> sr \\<Longrightarrow> cmod x < 1\" \"cmod x \\<le> sr \\<Longrightarrow> cmod x \\<le> 1\" for x"], ["proof (prove)\nusing this:\n  sr \\<le> 1\n  sr \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (cmod x \\<le> sr \\<Longrightarrow> cmod x < 1) &&&\n    (cmod x \\<le> sr \\<Longrightarrow> cmod x \\<le> 1)", "by auto"], ["proof (state)\nthis:\n  cmod ?x \\<le> sr \\<Longrightarrow> cmod ?x < 1\n  cmod ?x \\<le> sr \\<Longrightarrow> cmod ?x \\<le> 1\n\ngoal (2 subgoals):\n 1. sr = 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)\n 2. sr \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "by (rule exI[of _ Nil], rule exI[of _ \"charpoly A\"], insert * root,\n        auto simp: prod_root_unity_def charpoly_of_real)"], ["proof (state)\nthis:\n  \\<exists>ks f.\n     0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f \\<and>\n     (\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)\n\ngoal (1 subgoal):\n 1. sr = 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sr = 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "case sr: True"], ["proof (state)\nthis:\n  sr = 1\n\ngoal (1 subgoal):\n 1. sr = 1 \\<Longrightarrow>\n    \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "from * cp cpc small root"], ["proof (chain)\npicking this:\n  0 \\<le> sr\n  0 \\<notin> set ks\n  ks \\<noteq> []\n  charpoly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:complex_of_real sr ^ k:]) *\n  map_poly complex_of_real f\n  poly (map_poly complex_of_real f) ?x = 0 \\<Longrightarrow> cmod ?x < sr\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n  0 \\<Longrightarrow>\n  cmod ?x2 \\<le> sr", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> sr\n  0 \\<notin> set ks\n  ks \\<noteq> []\n  charpoly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:sr ^ k:]) * f\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:complex_of_real sr ^ k:]) *\n  map_poly complex_of_real f\n  poly (map_poly complex_of_real f) ?x = 0 \\<Longrightarrow> cmod ?x < sr\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n  0 \\<Longrightarrow>\n  cmod ?x2 \\<le> sr\n\ngoal (1 subgoal):\n 1. \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = prod_root_unity ks * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       prod_root_unity ks * map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "unfolding sr root_unity_def prod_root_unity_def"], ["proof (prove)\nusing this:\n  0 \\<le> 1\n  0 \\<notin> set ks\n  ks \\<noteq> []\n  charpoly A = (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:1 ^ k:]) * f\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  (\\<Prod>k\\<leftarrow>ks. monom 1 k - [:complex_of_real 1 ^ k:]) *\n  map_poly complex_of_real f\n  poly (map_poly complex_of_real f) ?x = 0 \\<Longrightarrow> cmod ?x < 1\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n  0 \\<Longrightarrow>\n  cmod ?x2 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>ks f.\n       0 \\<notin> set ks \\<and>\n       charpoly A = (\\<Prod>n\\<leftarrow>ks. monom 1 n - 1) * f \\<and>\n       charpoly (HMA_Connect.map_matrix complex_of_real A) =\n       (\\<Prod>n\\<leftarrow>ks. monom 1 n - 1) *\n       map_poly complex_of_real f \\<and>\n       (\\<forall>x.\n           poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n           0 \\<longrightarrow>\n           cmod x \\<le> 1) \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < 1)", "by (auto simp: pCons_one)"], ["proof (state)\nthis:\n  \\<exists>ks f.\n     0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f \\<and>\n     (\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ks f.\n     0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f \\<and>\n     (\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "}"], ["proof (state)\nthis:\n  \\<exists>ks f.\n     0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f \\<and>\n     (\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ks f.\n     0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f \\<and>\n     (\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)", "obtain Ks F where wit: \"?wit Ks F\""], ["proof (prove)\nusing this:\n  \\<exists>ks f.\n     0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f \\<and>\n     (\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)\n\ngoal (1 subgoal):\n 1. (\\<And>Ks F.\n        0 \\<notin> set Ks \\<and>\n        charpoly A = prod_root_unity Ks * F \\<and>\n        charpoly (HMA_Connect.map_matrix complex_of_real A) =\n        prod_root_unity Ks * map_poly complex_of_real F \\<and>\n        (\\<forall>x.\n            poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n            0 \\<longrightarrow>\n            cmod x \\<le> 1) \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real F) x = 0 \\<longrightarrow>\n            cmod x < 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<notin> set Ks \\<and>\n  charpoly A = prod_root_unity Ks * F \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real F) x = 0 \\<longrightarrow> cmod x < 1)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have cA0: \"charpoly ?A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. charpoly (HMA_Connect.map_matrix complex_of_real A) \\<noteq> 0", "using degree_monic_charpoly[of ?A]"], ["proof (prove)\nusing this:\n  degree (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  CARD('n) \\<and>\n  monic (charpoly (HMA_Connect.map_matrix complex_of_real A))\n\ngoal (1 subgoal):\n 1. charpoly (HMA_Connect.map_matrix complex_of_real A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from wit"], ["proof (chain)\npicking this:\n  0 \\<notin> set Ks \\<and>\n  charpoly A = prod_root_unity Ks * F \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real F) x = 0 \\<longrightarrow> cmod x < 1)", "have id: \"charpoly ?A = prod_root_unity Ks * ?cp F\""], ["proof (prove)\nusing this:\n  0 \\<notin> set Ks \\<and>\n  charpoly A = prod_root_unity Ks * F \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real F) x = 0 \\<longrightarrow> cmod x < 1)\n\ngoal (1 subgoal):\n 1. charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    prod_root_unity Ks * map_poly complex_of_real F", "by auto"], ["proof (state)\nthis:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from of_real_hom.hom_decompose_prod_root_unity[of \"charpoly A\", unfolded decomp]"], ["proof (chain)\npicking this:\n  decompose_prod_root_unity (map_poly of_real (charpoly A)) =\n  map_prod id (map_poly of_real) (ks, f)", "have decompc: \"decompose_prod_root_unity (charpoly ?A) = (ks, ?cp f)\""], ["proof (prove)\nusing this:\n  decompose_prod_root_unity (map_poly of_real (charpoly A)) =\n  map_prod id (map_poly of_real) (ks, f)\n\ngoal (1 subgoal):\n 1. decompose_prod_root_unity\n     (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n    (ks, map_poly complex_of_real f)", "by (auto simp: charpoly_of_real)"], ["proof (state)\nthis:\n  decompose_prod_root_unity\n   (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  (ks, map_poly complex_of_real f)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from wit"], ["proof (chain)\npicking this:\n  0 \\<notin> set Ks \\<and>\n  charpoly A = prod_root_unity Ks * F \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real F) x = 0 \\<longrightarrow> cmod x < 1)", "have small: \"cmod x = 1 \\<Longrightarrow> poly (?cp F) x \\<noteq> 0\" for x"], ["proof (prove)\nusing this:\n  0 \\<notin> set Ks \\<and>\n  charpoly A = prod_root_unity Ks * F \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real F) x = 0 \\<longrightarrow> cmod x < 1)\n\ngoal (1 subgoal):\n 1. cmod x = 1 \\<Longrightarrow>\n    poly (map_poly complex_of_real F) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  cmod ?x = 1 \\<Longrightarrow>\n  poly (map_poly complex_of_real F) ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from decompose_prod_root_unity[OF id decompc this cA0]"], ["proof (chain)\npicking this:\n  (\\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1) \\<Longrightarrow>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real F \\<and>\n  map_poly complex_of_real F = map_poly complex_of_real f \\<and>\n  set Ks = set ks", "have id: \"charpoly ?A = prod_root_unity ks * ?cp F\" \"F = f\" \"set Ks = set ks\""], ["proof (prove)\nusing this:\n  (\\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1) \\<Longrightarrow>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real F \\<and>\n  map_poly complex_of_real F = map_poly complex_of_real f \\<and>\n  set Ks = set ks\n\ngoal (1 subgoal):\n 1. charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    prod_root_unity ks * map_poly complex_of_real F &&&\n    F = f &&& set Ks = set ks", "by auto"], ["proof (state)\nthis:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real F\n  F = f\n  set Ks = set ks\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have \"?cp (charpoly A) = ?cp (prod_root_unity ks * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (charpoly A) =\n    map_poly complex_of_real (prod_root_unity ks * f)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (charpoly A) =\n    map_poly complex_of_real (prod_root_unity ks * f)", "unfolding charpoly_of_real[symmetric] id p.hom_mult of_real_hom.hom_prod_root_unity"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_root_unity ks * map_poly complex_of_real f =\n    prod_root_unity ks * map_poly complex_of_real f", ".."], ["proof (state)\nthis:\n  map_poly complex_of_real (charpoly A) =\n  map_poly complex_of_real (prod_root_unity ks * f)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "hence idr: \"charpoly A = prod_root_unity ks * f\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real (charpoly A) =\n  map_poly complex_of_real (prod_root_unity ks * f)\n\ngoal (1 subgoal):\n 1. charpoly A = prod_root_unity ks * f", "by auto"], ["proof (state)\nthis:\n  charpoly A = prod_root_unity ks * f\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have wit: \"?wit ks f\" and idc: \"charpoly ?A = prod_root_unity ks * ?cp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set ks \\<and>\n    charpoly A = prod_root_unity ks * f \\<and>\n    charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    prod_root_unity ks * map_poly complex_of_real f \\<and>\n    (\\<forall>x.\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        cmod x \\<le> 1) \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n        cmod x < 1) &&&\n    charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    prod_root_unity ks * map_poly complex_of_real f", "using wit"], ["proof (prove)\nusing this:\n  0 \\<notin> set Ks \\<and>\n  charpoly A = prod_root_unity Ks * F \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity Ks * map_poly complex_of_real F \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real F) x = 0 \\<longrightarrow> cmod x < 1)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set ks \\<and>\n    charpoly A = prod_root_unity ks * f \\<and>\n    charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    prod_root_unity ks * map_poly complex_of_real f \\<and>\n    (\\<forall>x.\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        cmod x \\<le> 1) \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n        cmod x < 1) &&&\n    charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    prod_root_unity ks * map_poly complex_of_real f", "unfolding id idr"], ["proof (prove)\nusing this:\n  0 \\<notin> set ks \\<and>\n  prod_root_unity ks * f = prod_root_unity Ks * f \\<and>\n  prod_root_unity ks * map_poly complex_of_real f =\n  prod_root_unity Ks * map_poly complex_of_real f \\<and>\n  (\\<forall>x.\n      poly (prod_root_unity ks * map_poly complex_of_real f) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < 1)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set ks \\<and>\n    prod_root_unity ks * f = prod_root_unity ks * f \\<and>\n    prod_root_unity ks * map_poly complex_of_real f =\n    prod_root_unity ks * map_poly complex_of_real f \\<and>\n    (\\<forall>x.\n        poly (prod_root_unity ks * map_poly complex_of_real f) x =\n        0 \\<longrightarrow>\n        cmod x \\<le> 1) \\<and>\n    (\\<forall>x.\n        poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n        cmod x < 1) &&&\n    prod_root_unity ks * map_poly complex_of_real f =\n    prod_root_unity ks * map_poly complex_of_real f", "by auto"], ["proof (state)\nthis:\n  0 \\<notin> set ks \\<and>\n  charpoly A = prod_root_unity ks * f \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real f \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < 1)\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "{"], ["proof (state)\nthis:\n  0 \\<notin> set ks \\<and>\n  charpoly A = prod_root_unity ks * f \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real f \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < 1)\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "assume \"cmod x = 1\""], ["proof (state)\nthis:\n  cmod x = 1\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from small[OF this, unfolded id]"], ["proof (chain)\npicking this:\n  poly (map_poly complex_of_real f) x \\<noteq> 0", "have \"poly (?cp f) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real f) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real f) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real f) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from order_0I[OF this] this"], ["proof (chain)\npicking this:\n  order x (map_poly complex_of_real f) = 0\n  poly (map_poly complex_of_real f) x \\<noteq> 0", "have ord: \"order x (?cp f) = 0\" and cf0: \"?cp f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  order x (map_poly complex_of_real f) = 0\n  poly (map_poly complex_of_real f) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (map_poly complex_of_real f) = 0 &&&\n    map_poly complex_of_real f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order x (map_poly complex_of_real f) = 0\n  map_poly complex_of_real f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have \"order x (charpoly ?A) = order x (prod_root_unity ks)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n    order x (prod_root_unity ks)", "unfolding idc"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks * map_poly complex_of_real f) =\n    order x (prod_root_unity ks)", "by (subst order_mult, insert cf0 wit ord, auto)"], ["proof (state)\nthis:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  order x (prod_root_unity ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "also"], ["proof (state)\nthis:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  order x (prod_root_unity ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "have \"\\<dots> = length [k\\<leftarrow>ks . x ^ k = 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "by (subst order_prod_root_unity, insert wit, auto)"], ["proof (state)\nthis:\n  order x (prod_root_unity ks) = length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "finally"], ["proof (chain)\npicking this:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. x ^ k = 1) ks)", "have ord: \"order x (charpoly ?A) = length [k\\<leftarrow>ks . x ^ k = 1]\""], ["proof (prove)\nusing this:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "."], ["proof (state)\nthis:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "{"], ["proof (state)\nthis:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "assume \"poly (charpoly ?A) x = 0\""], ["proof (state)\nthis:\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x = 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "with cA0"], ["proof (chain)\npicking this:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) \\<noteq> 0\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x = 0", "have \"order x (charpoly ?A) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) \\<noteq> 0\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x = 0\n\ngoal (1 subgoal):\n 1. order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) \\<noteq> 0", "unfolding order_root"], ["proof (prove)\nusing this:\n  charpoly (HMA_Connect.map_matrix complex_of_real A) \\<noteq> 0\n  charpoly (HMA_Connect.map_matrix complex_of_real A) = 0 \\<or>\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "from this[unfolded ord]"], ["proof (chain)\npicking this:\n  length (filter (\\<lambda>k. x ^ k = 1) ks) \\<noteq> 0", "have \"\\<exists> k \\<in> set ks. x ^ k = 1\""], ["proof (prove)\nusing this:\n  length (filter (\\<lambda>k. x ^ k = 1) ks) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set ks. x ^ k = 1", "by (cases \"[k\\<leftarrow>ks . x ^ k = 1]\", force+)"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set ks. x ^ k = 1\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "}"], ["proof (state)\nthis:\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n  0 \\<Longrightarrow>\n  \\<exists>k\\<in>set ks. x ^ k = 1\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "note this ord"], ["proof (state)\nthis:\n  poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n  0 \\<Longrightarrow>\n  \\<exists>k\\<in>set ks. x ^ k = 1\n  order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>cmod ?x2 = 1;\n   poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>set ks. ?x2 ^ k = 1\n  cmod ?x2 = 1 \\<Longrightarrow>\n  order ?x2 (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. ?x2 ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "with wit"], ["proof (chain)\npicking this:\n  0 \\<notin> set ks \\<and>\n  charpoly A = prod_root_unity ks * f \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real f \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < 1)\n  \\<lbrakk>cmod ?x2 = 1;\n   poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>set ks. ?x2 ^ k = 1\n  cmod ?x2 = 1 \\<Longrightarrow>\n  order ?x2 (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. ?x2 ^ k = 1) ks)", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<notin> set ks \\<and>\n  charpoly A = prod_root_unity ks * f \\<and>\n  charpoly (HMA_Connect.map_matrix complex_of_real A) =\n  prod_root_unity ks * map_poly complex_of_real f \\<and>\n  (\\<forall>x.\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      cmod x \\<le> 1) \\<and>\n  (\\<forall>x.\n      poly (map_poly complex_of_real f) x = 0 \\<longrightarrow> cmod x < 1)\n  \\<lbrakk>cmod ?x2 = 1;\n   poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) ?x2 =\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>set ks. ?x2 ^ k = 1\n  cmod ?x2 = 1 \\<Longrightarrow>\n  order ?x2 (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n  length (filter (\\<lambda>k. ?x2 ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. (0 \\<notin> set ks \\<and>\n     charpoly A = prod_root_unity ks * f \\<and>\n     charpoly (HMA_Connect.map_matrix complex_of_real A) =\n     prod_root_unity ks * map_poly complex_of_real f) \\<and>\n    ((\\<forall>x.\n         poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n         0 \\<longrightarrow>\n         cmod x \\<le> 1) \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < 1)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n        length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n    (\\<forall>x.\n        cmod x = 1 \\<longrightarrow>\n        poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n        0 \\<longrightarrow>\n        (\\<exists>k\\<in>set ks. x ^ k = 1))", "by blast"], ["proof (state)\nthis:\n  (0 \\<notin> set ks \\<and>\n   charpoly A = prod_root_unity ks * f \\<and>\n   charpoly (HMA_Connect.map_matrix complex_of_real A) =\n   prod_root_unity ks * map_poly complex_of_real f) \\<and>\n  ((\\<forall>x.\n       poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n       0 \\<longrightarrow>\n       cmod x \\<le> 1) \\<and>\n   (\\<forall>x.\n       poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n       cmod x < 1)) \\<and>\n  (\\<forall>x.\n      cmod x = 1 \\<longrightarrow>\n      order x (charpoly (HMA_Connect.map_matrix complex_of_real A)) =\n      length (filter (\\<lambda>k. x ^ k = 1) ks)) \\<and>\n  (\\<forall>x.\n      cmod x = 1 \\<longrightarrow>\n      poly (charpoly (HMA_Connect.map_matrix complex_of_real A)) x =\n      0 \\<longrightarrow>\n      (\\<exists>k\\<in>set ks. x ^ k = 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>and convert to JNF-world\\<close>"], ["", "lemmas perron_frobenius_for_complexity_jnf = \n  perron_frobenius_for_complexity[unfolded atomize_imp atomize_all, \n    untransferred, cancel_card_constraint, rule_format]"], ["", "end"]]}