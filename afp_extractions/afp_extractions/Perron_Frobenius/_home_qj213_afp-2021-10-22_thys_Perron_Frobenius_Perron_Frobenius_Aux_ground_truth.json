{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Perron_Frobenius_Aux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma real_non_neg_matD: assumes \"real_non_neg_mat A\"\n  shows \"A $h i $h j \\<in> \\<real>\" \"Re (A $h i $h j) \\<ge> 0\"", "lemma HMA_real_non_neg_mat [transfer_rule]:\n  \"((HMA_M :: complex mat \\<Rightarrow> complex ^ 'nc ^ 'nr \\<Rightarrow> bool) ===> (=)) \n  real_nonneg_mat real_non_neg_mat\"", "lemma HMA_real_non_neg_vec [transfer_rule]:\n  \"((HMA_V :: complex Matrix.vec \\<Rightarrow> complex ^ 'n \\<Rightarrow> bool) ===> (=)) \n  real_nonneg_vec real_non_neg_vec\"", "lemma HMA_non_neg_mat [transfer_rule]:\n  \"((HMA_M :: 'a :: linordered_idom mat \\<Rightarrow> 'a ^ 'nc ^ 'nr \\<Rightarrow> bool) ===> (=)) \n  nonneg_mat non_neg_mat\"", "lemma HMA_pow_mat[transfer_rule]:\n  \"((HMA_M ::'a::{semiring_1} mat \\<Rightarrow> 'a^'n^'n \\<Rightarrow> bool) ===> (=) ===> HMA_M) pow_mat matpow\"", "lemma trancl_image: \n  \"(i,j) \\<in> R\\<^sup>+ \\<Longrightarrow> (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\"", "lemma inj_trancl_image: assumes inj: \"inj f\" \n  shows \"(f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ = ((i,j) \\<in> R\\<^sup>+)\" (is \"?l = ?r\")", "lemma matrix_add_rdistrib: \"((B + C) ** A) = (B ** A) + (C ** A)\"", "lemma norm_smult: \"norm ((a :: real) *s x) = abs a * norm x\"", "lemma nonneg_mat_mult: \n  \"nonneg_mat A \\<Longrightarrow> nonneg_mat B \\<Longrightarrow> A \\<in> carrier_mat nr n\n  \\<Longrightarrow> B \\<in> carrier_mat n nc \\<Longrightarrow> nonneg_mat (A * B)\"", "lemma nonneg_mat_power: assumes \"A \\<in> carrier_mat n n\" \"nonneg_mat A\" \n  shows \"nonneg_mat (A ^\\<^sub>m k)\"", "lemma nonneg_matD: assumes \"nonneg_mat A\"\n  and \"i < dim_row A\" and \"j < dim_col A\"\nshows \"A $$ (i,j) \\<ge> 0\"", "lemma (in comm_ring_hom) similar_mat_wit_hom: assumes\n  \"similar_mat_wit A B C D\"\nshows \"similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C) (mat\\<^sub>h D)\"", "lemma (in comm_ring_hom) similar_mat_hom:\n  \"similar_mat A B \\<Longrightarrow> similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)\"", "lemma det_dim_1: assumes A: \"A \\<in> carrier_mat n n\"\n  and n: \"n = 1\"\nshows \"Determinant.det A = A $$ (0,0)\"", "lemma det_dim_2: assumes A: \"A \\<in> carrier_mat n n\"\n  and n: \"n = 2\"\nshows \"Determinant.det A = A $$ (0,0) * A $$ (1,1) - A $$ (0,1) * A $$ (1,0)\"", "lemma jordan_nf_root_char_poly: fixes A :: \"'a :: {semiring_no_zero_divisors, idom} mat\"\n  assumes \"jordan_nf A n_as\" \n  and \"(m, lam) \\<in> set n_as\" \nshows \"poly (char_poly A) lam = 0\"", "lemma inverse_power_tendsto_zero:\n  \"(\\<lambda>x. inverse ((of_nat x :: 'a :: real_normed_div_algebra) ^ Suc d)) \\<longlonglongrightarrow> 0\"", "lemma inverse_of_nat_tendsto_zero:\n  \"(\\<lambda>x. inverse (of_nat x :: 'a :: real_normed_div_algebra)) \\<longlonglongrightarrow> 0\"", "lemma poly_times_exp_tendsto_zero: assumes b: \"norm (b :: 'a :: real_normed_field) < 1\" \n  shows \"(\\<lambda> x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> 0\"", "lemma (in linorder_topology) tendsto_Min: assumes I: \"I \\<noteq> {}\" and fin: \"finite I\"\n  shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> (f i \\<longlongrightarrow> a i) F) \\<Longrightarrow> ((\\<lambda>x. Min ((\\<lambda> i. f i x) ` I)) \\<longlongrightarrow> \n    (Min (a ` I) :: 'a)) F\"", "lemma tendsto_mat_mult [tendsto_intros]: \n  \"(f \\<longlongrightarrow> a) F \\<Longrightarrow> (g \\<longlongrightarrow> b) F \\<Longrightarrow> ((\\<lambda>x. f x ** g x) \\<longlongrightarrow> a ** b) F\" \n  for f :: \"'a \\<Rightarrow> 'b :: {semiring_1, real_normed_algebra} ^ 'n1 ^ 'n2\"", "lemma tendsto_matpower [tendsto_intros]: \"(f \\<longlongrightarrow> a) F \\<Longrightarrow> ((\\<lambda>x. matpow (f x) n) \\<longlongrightarrow> matpow a n) F\"\n  for f :: \"'a \\<Rightarrow> 'b :: {semiring_1, real_normed_algebra} ^ 'n ^ 'n\"", "lemma continuous_matpow: \"continuous_on R (\\<lambda> A :: 'a :: {semiring_1, real_normed_algebra_1} ^ 'n ^ 'n. matpow A n)\"", "lemma vector_smult_distrib: \"(A *v ((a :: 'a :: comm_ring_1) *s x)) = a *s ((A *v x))\"", "lemma poly_tendsto_pinfty:  fixes p :: \"real poly\"\n  assumes \"lead_coeff p > 0\" \"degree p \\<noteq> 0\" \n  shows \"poly p \\<longlonglongrightarrow> \\<infinity>\"", "lemma div_lt_nat: \"(j :: nat) < x * y \\<Longrightarrow> j div x < y\"", "lemma diagvector_mult_vector[simp]: \"diagvector x *v y = (\\<chi> i. x i * y $ i)\"", "lemma diagvector_mult_left: \"diagvector x ** A = (\\<chi> i j. x i * A $ i $ j)\" (is \"?A = ?B\")", "lemma diagvector_mult_right: \"A ** diagvector x = (\\<chi> i j. A $ i $ j * x j)\" (is \"?A = ?B\")", "lemma diagvector_mult[simp]: \"diagvector x ** diagvector y = diagvector (\\<lambda> i. x i * y i)\"", "lemma diagvector_const[simp]: \"diagvector (\\<lambda> x. k) = mat k\"", "lemma diagvector_eq_mat: \"diagvector x = mat a \\<longleftrightarrow> x = (\\<lambda> x. a)\"", "lemma cmod_eq_Re: assumes \"cmod x = Re x\"\n  shows \"of_real (Re x) = x\"", "lemma spectral_radius_ev:\n  \"\\<exists> ev v. eigen_vector A v ev \\<and> norm ev = spectral_radius A\"", "lemma spectral_radius_max: assumes \"eigen_value A v\"\n  shows \"norm v \\<le> spectral_radius A\"", "lemma norm1_ge_0: \"norm1 v \\<ge> 0\"", "lemma norm1_0[simp]: \"norm1 0 = 0\"", "lemma norm1_nonzero: assumes \"v \\<noteq> 0\"\n  shows \"norm1 v > 0\"", "lemma norm1_0_iff[simp]: \"(norm1 v = 0) = (v = 0)\"", "lemma norm1_scaleR[simp]: \"norm1 (r *\\<^sub>R v) = abs r * norm1 v\"", "lemma abs_norm1[simp]: \"abs (norm1 v) = norm1 v\"", "lemma normalize_eigen_vector: assumes \"eigen_vector (A :: 'a :: real_normed_field ^ 'n ^ 'n) v ev\"\n  shows \"eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\" \"norm1 ((1 / norm1 v) *\\<^sub>R v) = 1\"", "lemma norm1_cont[simp]: \"isCont norm1 v\"", "lemma norm1_ge_norm: \"norm1 v \\<ge> norm v\"", "lemma tendsto_matrix_vector_mult[tendsto_intros]:\n  \"((*v) (A :: 'a :: real_normed_algebra_1 ^ 'n ^ 'k) \\<longlongrightarrow> A *v v) (at v within S)\"", "lemma tendsto_matrix_matrix_mult[tendsto_intros]:\n  \"((**) (A :: 'a :: real_normed_algebra_1 ^ 'n ^ 'k) \\<longlongrightarrow> A ** B) (at B within S)\"", "lemma matrix_vect_scaleR: \"(A :: 'a :: real_normed_algebra_1 ^ 'n ^ 'k) *v (a *\\<^sub>R v) = a *\\<^sub>R (A *v v)\"", "lemma (in inj_semiring_hom) map_vector_0: \"(map_vector hom v = 0) = (v = 0)\"", "lemma (in inj_semiring_hom) map_vector_inj: \"(map_vector hom v = map_vector hom w) = (v = w)\"", "lemma (in semiring_hom) matrix_vector_mult_hom:\n  \"(map_matrix hom A) *v (map_vector hom v) = map_vector hom (A *v v)\"", "lemma (in semiring_hom) vector_smult_hom:\n  \"hom x *s (map_vector hom v) = map_vector hom (x *s v)\"", "lemma (in inj_comm_ring_hom) eigen_vector_hom: \n  \"eigen_vector (map_matrix hom A) (map_vector hom v) (hom x) = eigen_vector A v x\""], "translations": [["", "lemma real_non_neg_matD: assumes \"real_non_neg_mat A\"\n  shows \"A $h i $h j \\<in> \\<real>\" \"Re (A $h i $h j) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $h i $h j \\<in> \\<real> &&& 0 \\<le> Re (A $h i $h j)", "using assms"], ["proof (prove)\nusing this:\n  real_non_neg_mat A\n\ngoal (1 subgoal):\n 1. A $h i $h j \\<in> \\<real> &&& 0 \\<le> Re (A $h i $h j)", "unfolding real_non_neg_mat_def elements_mat_h_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>range (\\<lambda>(i, y). A $h i $h y).\n     a \\<in> \\<real> \\<and> 0 \\<le> Re a\n\ngoal (1 subgoal):\n 1. A $h i $h j \\<in> \\<real> &&& 0 \\<le> Re (A $h i $h j)", "by auto"], ["", "definition nonneg_mat :: \"'a :: linordered_idom mat \\<Rightarrow> bool\" where\n  \"nonneg_mat A \\<equiv> \\<forall> a \\<in> elements_mat A. a \\<ge> 0\""], ["", "definition non_neg_mat :: \"'a :: linordered_idom ^ 'nr ^ 'nc \\<Rightarrow> bool\" where\n  \"non_neg_mat A \\<equiv> (\\<forall> a \\<in> elements_mat_h A. a \\<ge> 0)\""], ["", "context includes lifting_syntax\nbegin"], ["", "lemma HMA_real_non_neg_mat [transfer_rule]:\n  \"((HMA_M :: complex mat \\<Rightarrow> complex ^ 'nc ^ 'nr \\<Rightarrow> bool) ===> (=)) \n  real_nonneg_mat real_non_neg_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) real_nonneg_mat real_non_neg_mat", "unfolding real_nonneg_mat_def[abs_def] real_non_neg_mat_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=))\n     (\\<lambda>A.\n         \\<forall>a\\<in>elements_mat A. a \\<in> \\<real> \\<and> 0 \\<le> Re a)\n     (\\<lambda>A.\n         \\<forall>a\\<in>elements_mat_h A.\n            a \\<in> \\<real> \\<and> 0 \\<le> Re a)", "by transfer_prover"], ["", "lemma HMA_real_non_neg_vec [transfer_rule]:\n  \"((HMA_V :: complex Matrix.vec \\<Rightarrow> complex ^ 'n \\<Rightarrow> bool) ===> (=)) \n  real_nonneg_vec real_non_neg_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) real_nonneg_vec real_non_neg_vec", "unfolding real_nonneg_vec_def[abs_def] real_non_neg_vec_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=))\n     (\\<lambda>v.\n         \\<forall>a\\<in>vec_elements v. a \\<in> \\<real> \\<and> 0 \\<le> Re a)\n     (\\<lambda>v.\n         \\<forall>a\\<in>vec_elements_h v.\n            a \\<in> \\<real> \\<and> 0 \\<le> Re a)", "by transfer_prover"], ["", "lemma HMA_non_neg_mat [transfer_rule]:\n  \"((HMA_M :: 'a :: linordered_idom mat \\<Rightarrow> 'a ^ 'nc ^ 'nr \\<Rightarrow> bool) ===> (=)) \n  nonneg_mat non_neg_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) nonneg_mat non_neg_mat", "unfolding nonneg_mat_def[abs_def] non_neg_mat_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=))\n     (\\<lambda>A. \\<forall>a\\<in>elements_mat A. (0::'a) \\<le> a)\n     (\\<lambda>A. \\<forall>a\\<in>elements_mat_h A. (0::'a) \\<le> a)", "by transfer_prover"], ["", "end"], ["", "primrec matpow :: \"'a::semiring_1^'n^'n \\<Rightarrow> nat \\<Rightarrow> 'a^'n^'n\" where\n  matpow_0:   \"matpow A 0 = mat 1\" |\n  matpow_Suc: \"matpow A (Suc n) = (matpow A n) ** A\""], ["", "context includes lifting_syntax\nbegin"], ["", "lemma HMA_pow_mat[transfer_rule]:\n  \"((HMA_M ::'a::{semiring_1} mat \\<Rightarrow> 'a^'n^'n \\<Rightarrow> bool) ===> (=) ===> HMA_M) pow_mat matpow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "fix A :: \"'a mat\" and A' :: \"'a^'n^'n\" and n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "assume [transfer_rule]: \"HMA_M A A'\""], ["proof (state)\nthis:\n  HMA_M A A'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "hence [simp]: \"dim_row A = CARD('n)\""], ["proof (prove)\nusing this:\n  HMA_M A A'\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('n)", "unfolding HMA_M_def"], ["proof (prove)\nusing this:\n  A = from_hma\\<^sub>m A'\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('n)", "by simp"], ["proof (state)\nthis:\n  dim_row A = CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "have \"HMA_M (pow_mat A n) (matpow A' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M (A ^\\<^sub>m n) (matpow A' n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. HMA_M (A ^\\<^sub>m 0) (matpow A' 0)\n 2. \\<And>n.\n       HMA_M (A ^\\<^sub>m n) (matpow A' n) \\<Longrightarrow>\n       HMA_M (A ^\\<^sub>m Suc n) (matpow A' (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  HMA_M (A ^\\<^sub>m n) (matpow A' n)\n\ngoal (2 subgoals):\n 1. HMA_M (A ^\\<^sub>m 0) (matpow A' 0)\n 2. \\<And>n.\n       HMA_M (A ^\\<^sub>m n) (matpow A' n) \\<Longrightarrow>\n       HMA_M (A ^\\<^sub>m Suc n) (matpow A' (Suc n))", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  HMA_M (A ^\\<^sub>m n) (matpow A' n)\n\ngoal (2 subgoals):\n 1. HMA_M (A ^\\<^sub>m 0) (matpow A' 0)\n 2. \\<And>n.\n       HMA_M (A ^\\<^sub>m n) (matpow A' n) \\<Longrightarrow>\n       HMA_M (A ^\\<^sub>m Suc n) (matpow A' (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M (A ^\\<^sub>m Suc n) (matpow A' (Suc n))", "by (simp, transfer_prover)"], ["proof (state)\nthis:\n  HMA_M (A ^\\<^sub>m Suc n) (matpow A' (Suc n))\n\ngoal (1 subgoal):\n 1. HMA_M (A ^\\<^sub>m 0) (matpow A' 0)", "qed (simp, transfer_prover)"], ["proof (state)\nthis:\n  HMA_M (A ^\\<^sub>m n) (matpow A' n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "}"], ["proof (state)\nthis:\n  HMA_M ?A2 ?A'2 \\<Longrightarrow>\n  HMA_M (?A2 ^\\<^sub>m ?n2) (matpow ?A'2 ?n2)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "thus ?thesis"], ["proof (prove)\nusing this:\n  HMA_M ?A2 ?A'2 \\<Longrightarrow>\n  HMA_M (?A2 ^\\<^sub>m ?n2) (matpow ?A'2 ?n2)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow", "by blast"], ["proof (state)\nthis:\n  (HMA_M ===> (=) ===> HMA_M) (^\\<^sub>m) matpow\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma trancl_image: \n  \"(i,j) \\<in> R\\<^sup>+ \\<Longrightarrow> (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+", "proof (induct rule: trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (i, y) \\<in> R \\<Longrightarrow>\n       (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> R\\<^sup>+; (y, z) \\<in> R;\n        (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> (f i, f z) \\<in> (map_prod f f ` R)\\<^sup>+", "case (step j k)"], ["proof (state)\nthis:\n  (i, j) \\<in> R\\<^sup>+\n  (j, k) \\<in> R\n  (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (i, y) \\<in> R \\<Longrightarrow>\n       (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> R\\<^sup>+; (y, z) \\<in> R;\n        (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> (f i, f z) \\<in> (map_prod f f ` R)\\<^sup>+", "from step(2)"], ["proof (chain)\npicking this:\n  (j, k) \\<in> R", "have \"(f j, f k) \\<in> map_prod f f ` R\""], ["proof (prove)\nusing this:\n  (j, k) \\<in> R\n\ngoal (1 subgoal):\n 1. (f j, f k) \\<in> map_prod f f ` R", "by auto"], ["proof (state)\nthis:\n  (f j, f k) \\<in> map_prod f f ` R\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (i, y) \\<in> R \\<Longrightarrow>\n       (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(i, y) \\<in> R\\<^sup>+; (y, z) \\<in> R;\n        (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> (f i, f z) \\<in> (map_prod f f ` R)\\<^sup>+", "from step(3) this"], ["proof (chain)\npicking this:\n  (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\n  (f j, f k) \\<in> map_prod f f ` R", "show ?case"], ["proof (prove)\nusing this:\n  (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\n  (f j, f k) \\<in> map_prod f f ` R\n\ngoal (1 subgoal):\n 1. (f i, f k) \\<in> (map_prod f f ` R)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (f i, f k) \\<in> (map_prod f f ` R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (i, y) \\<in> R \\<Longrightarrow>\n       (f i, f y) \\<in> (map_prod f f ` R)\\<^sup>+", "qed auto"], ["", "lemma inj_trancl_image: assumes inj: \"inj f\" \n  shows \"(f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ = ((i,j) \\<in> R\\<^sup>+)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+) = ((i, j) \\<in> R\\<^sup>+)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ \\<Longrightarrow>\n    (i, j) \\<in> R\\<^sup>+\n 2. (i, j) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+", "assume ?r"], ["proof (state)\nthis:\n  (i, j) \\<in> R\\<^sup>+\n\ngoal (2 subgoals):\n 1. (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ \\<Longrightarrow>\n    (i, j) \\<in> R\\<^sup>+\n 2. (i, j) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+", "from trancl_image[OF this]"], ["proof (chain)\npicking this:\n  (?f i, ?f j) \\<in> (map_prod ?f ?f ` R)\\<^sup>+", "show ?l"], ["proof (prove)\nusing this:\n  (?f i, ?f j) \\<in> (map_prod ?f ?f ` R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+", "."], ["proof (state)\nthis:\n  (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ \\<Longrightarrow>\n    (i, j) \\<in> R\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ \\<Longrightarrow>\n    (i, j) \\<in> R\\<^sup>+", "assume ?l"], ["proof (state)\nthis:\n  (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (f i, f j) \\<in> (map_prod f f ` R)\\<^sup>+ \\<Longrightarrow>\n    (i, j) \\<in> R\\<^sup>+", "from trancl_image[OF this, of \"the_inv f\"]"], ["proof (chain)\npicking this:\n  (the_inv f (f i), the_inv f (f j))\n  \\<in> (map_prod (the_inv f) (the_inv f) ` map_prod f f ` R)\\<^sup>+", "show ?r"], ["proof (prove)\nusing this:\n  (the_inv f (f i), the_inv f (f j))\n  \\<in> (map_prod (the_inv f) (the_inv f) ` map_prod f f ` R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> R\\<^sup>+", "unfolding image_image prod.map_comp o_def the_inv_f_f[OF inj]"], ["proof (prove)\nusing this:\n  (i, j) \\<in> (map_prod (\\<lambda>x. x) (\\<lambda>x. x) ` R)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> R\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (i, j) \\<in> R\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_add_rdistrib: \"((B + C) ** A) = (B ** A) + (C ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B + C) ** A = B ** A + C ** A", "by (vector matrix_matrix_mult_def sum.distrib[symmetric] field_simps)"], ["", "lemma norm_smult: \"norm ((a :: real) *s x) = abs a * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a *s x) = \\<bar>a\\<bar> * norm x", "unfolding norm_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>i. norm ((a *s x) $h i)) UNIV =\n    \\<bar>a\\<bar> * L2_set (\\<lambda>i. norm (x $h i)) UNIV", "by (metis norm_scaleR norm_vec_def scalar_mult_eq_scaleR)"], ["", "lemma nonneg_mat_mult: \n  \"nonneg_mat A \\<Longrightarrow> nonneg_mat B \\<Longrightarrow> A \\<in> carrier_mat nr n\n  \\<Longrightarrow> B \\<in> carrier_mat n nc \\<Longrightarrow> nonneg_mat (A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nonneg_mat A; nonneg_mat B; A \\<in> carrier_mat nr n;\n     B \\<in> carrier_mat n nc\\<rbrakk>\n    \\<Longrightarrow> nonneg_mat (A * B)", "unfolding nonneg_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>elements_mat A. (0::'a) \\<le> a;\n     \\<forall>a\\<in>elements_mat B. (0::'a) \\<le> a;\n     A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>elements_mat (A * B). (0::'a) \\<le> a", "by (auto simp: elements_mat_def scalar_prod_def intro!: sum_nonneg)"], ["", "lemma nonneg_mat_power: assumes \"A \\<in> carrier_mat n n\" \"nonneg_mat A\" \n  shows \"nonneg_mat (A ^\\<^sub>m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_mat (A ^\\<^sub>m k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. nonneg_mat (A ^\\<^sub>m 0)\n 2. \\<And>k.\n       nonneg_mat (A ^\\<^sub>m k) \\<Longrightarrow>\n       nonneg_mat (A ^\\<^sub>m Suc k)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. nonneg_mat (A ^\\<^sub>m 0)\n 2. \\<And>k.\n       nonneg_mat (A ^\\<^sub>m k) \\<Longrightarrow>\n       nonneg_mat (A ^\\<^sub>m Suc k)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_mat (A ^\\<^sub>m 0)", "by (auto simp: nonneg_mat_def)"], ["proof (state)\nthis:\n  nonneg_mat (A ^\\<^sub>m 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       nonneg_mat (A ^\\<^sub>m k) \\<Longrightarrow>\n       nonneg_mat (A ^\\<^sub>m Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       nonneg_mat (A ^\\<^sub>m k) \\<Longrightarrow>\n       nonneg_mat (A ^\\<^sub>m Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  nonneg_mat (A ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       nonneg_mat (A ^\\<^sub>m k) \\<Longrightarrow>\n       nonneg_mat (A ^\\<^sub>m Suc k)", "from nonneg_mat_mult[OF this assms(2) _ assms(1), of n] assms(1)"], ["proof (chain)\npicking this:\n  A ^\\<^sub>m k \\<in> carrier_mat n n \\<Longrightarrow>\n  nonneg_mat (A ^\\<^sub>m k * A)\n  A \\<in> carrier_mat n n", "show ?case"], ["proof (prove)\nusing this:\n  A ^\\<^sub>m k \\<in> carrier_mat n n \\<Longrightarrow>\n  nonneg_mat (A ^\\<^sub>m k * A)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. nonneg_mat (A ^\\<^sub>m Suc k)", "by auto"], ["proof (state)\nthis:\n  nonneg_mat (A ^\\<^sub>m Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_matD: assumes \"nonneg_mat A\"\n  and \"i < dim_row A\" and \"j < dim_col A\"\nshows \"A $$ (i,j) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> A $$ (i, j)", "using assms"], ["proof (prove)\nusing this:\n  nonneg_mat A\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> A $$ (i, j)", "unfolding nonneg_mat_def elements_mat"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>{A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A}.\n     (0::'a) \\<le> a\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> A $$ (i, j)", "by auto"], ["", "lemma (in comm_ring_hom) similar_mat_wit_hom: assumes\n  \"similar_mat_wit A B C D\"\nshows \"similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C) (mat\\<^sub>h D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "obtain n where n: \"n = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = dim_row A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = dim_row A\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note * = similar_mat_witD[OF n assms]"], ["proof (state)\nthis:\n  C * D = 1\\<^sub>m n\n  D * C = 1\\<^sub>m n\n  A = C * B * D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "from *"], ["proof (chain)\npicking this:\n  C * D = 1\\<^sub>m n\n  D * C = 1\\<^sub>m n\n  A = C * B * D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n", "have [simp]: \"dim_row C = n\""], ["proof (prove)\nusing this:\n  C * D = 1\\<^sub>m n\n  D * C = 1\\<^sub>m n\n  A = C * B * D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row C = n", "by auto"], ["proof (state)\nthis:\n  dim_row C = n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note C = *(6)"], ["proof (state)\nthis:\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note D = *(7)"], ["proof (state)\nthis:\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note id = mat_hom_mult[OF C D] mat_hom_mult[OF D C]"], ["proof (state)\nthis:\n  mat\\<^sub>h (C * D) = mat\\<^sub>h C * mat\\<^sub>h D\n  mat\\<^sub>h (D * C) = mat\\<^sub>h D * mat\\<^sub>h C\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note ** = *(1-3)[THEN arg_cong[of _ _ \"mat\\<^sub>h\"], unfolded id]"], ["proof (state)\nthis:\n  mat\\<^sub>h C * mat\\<^sub>h D = mat\\<^sub>h (1\\<^sub>m n)\n  mat\\<^sub>h D * mat\\<^sub>h C = mat\\<^sub>h (1\\<^sub>m n)\n  mat\\<^sub>h A = mat\\<^sub>h (C * B * D)\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note mult = mult_carrier_mat[of _ n n]"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n n; ?B \\<in> carrier_mat n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> carrier_mat n ?nc\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note hom_mult = mat_hom_mult[of _ n n _ n]"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n n; ?B \\<in> carrier_mat n n\\<rbrakk>\n  \\<Longrightarrow> mat\\<^sub>h (?A * ?B) = mat\\<^sub>h ?A * mat\\<^sub>h ?B\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {mat\\<^sub>h A, mat\\<^sub>h B, mat\\<^sub>h C, mat\\<^sub>h D}\n    \\<subseteq> carrier_mat (dim_row (mat\\<^sub>h A))\n                 (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h C * mat\\<^sub>h D =\n    1\\<^sub>m (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h D * mat\\<^sub>h C =\n    1\\<^sub>m (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h A = mat\\<^sub>h C * mat\\<^sub>h B * mat\\<^sub>h D", "unfolding **(3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {mat\\<^sub>h (C * B * D), mat\\<^sub>h B, mat\\<^sub>h C, mat\\<^sub>h D}\n    \\<subseteq> carrier_mat (dim_row (mat\\<^sub>h (C * B * D)))\n                 (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h C * mat\\<^sub>h D =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h D * mat\\<^sub>h C =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h (C * B * D) = mat\\<^sub>h C * mat\\<^sub>h B * mat\\<^sub>h D", "using **(1,2)"], ["proof (prove)\nusing this:\n  mat\\<^sub>h C * mat\\<^sub>h D = mat\\<^sub>h (1\\<^sub>m n)\n  mat\\<^sub>h D * mat\\<^sub>h C = mat\\<^sub>h (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. {mat\\<^sub>h (C * B * D), mat\\<^sub>h B, mat\\<^sub>h C, mat\\<^sub>h D}\n    \\<subseteq> carrier_mat (dim_row (mat\\<^sub>h (C * B * D)))\n                 (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h C * mat\\<^sub>h D =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h D * mat\\<^sub>h C =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h (C * B * D) = mat\\<^sub>h C * mat\\<^sub>h B * mat\\<^sub>h D", "by (auto simp: n[symmetric] hom_mult simp: *(4-) mult)"], ["proof (state)\nthis:\n  similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n   (mat\\<^sub>h D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_ring_hom) similar_mat_hom:\n  \"similar_mat A B \\<Longrightarrow> similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat A B \\<Longrightarrow>\n    similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)", "using similar_mat_wit_hom[of A B C D for C D]"], ["proof (prove)\nusing this:\n  similar_mat_wit A B ?C2 ?D2 \\<Longrightarrow>\n  similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h ?C2)\n   (mat\\<^sub>h ?D2)\n\ngoal (1 subgoal):\n 1. similar_mat A B \\<Longrightarrow>\n    similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)", "by (smt similar_mat_def)"], ["", "lemma det_dim_1: assumes A: \"A \\<in> carrier_mat n n\"\n  and n: \"n = 1\"\nshows \"Determinant.det A = A $$ (0,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det A = A $$ (0, 0)", "by (subst laplace_expansion_column[OF A[unfolded n], of 0], insert A n,\n    auto simp: cofactor_def mat_delete_def)"], ["", "lemma det_dim_2: assumes A: \"A \\<in> carrier_mat n n\"\n  and n: \"n = 2\"\nshows \"Determinant.det A = A $$ (0,0) * A $$ (1,1) - A $$ (0,1) * A $$ (1,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det A =\n    A $$ (0, 0) * A $$ (1, 1) - A $$ (0, 1) * A $$ (1, 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Determinant.det A =\n    A $$ (0, 0) * A $$ (1, 1) - A $$ (0, 1) * A $$ (1, 0)", "have set: \"(\\<Sum>i<(2 :: nat). f i) = f 0 + f 1\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<2} = f 0 + f 1", "by (subst sum.cong[of _ \"{0,1}\" f f], auto)"], ["proof (state)\nthis:\n  sum ?f1 {..<2} = ?f1 0 + ?f1 1\n\ngoal (1 subgoal):\n 1. Determinant.det A =\n    A $$ (0, 0) * A $$ (1, 1) - A $$ (0, 1) * A $$ (1, 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det A =\n    A $$ (0, 0) * A $$ (1, 1) - A $$ (0, 1) * A $$ (1, 0)", "apply (subst laplace_expansion_column[OF A[unfolded n], of 0], insert A n,\n      auto simp: cofactor_def mat_delete_def set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat 2 2; n = 2\\<rbrakk>\n    \\<Longrightarrow> A $$ (0, 0) *\n                      Determinant.det\n                       (Matrix.mat (Suc 0) (Suc 0)\n                         (\\<lambda>(i', j'). A $$ (Suc i', Suc j'))) -\n                      A $$ (Suc 0, 0) *\n                      Determinant.det\n                       (Matrix.mat (Suc 0) (Suc 0)\n                         (\\<lambda>(i', j').\n                             A $$\n                             (if i' = 0 then i' else Suc i', Suc j'))) =\n                      A $$ (0, 0) * A $$ (Suc 0, Suc 0) -\n                      A $$ (0, Suc 0) * A $$ (Suc 0, 0)", "apply (subst (1 2) det_dim_1, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Determinant.det A = A $$ (0, 0) * A $$ (1, 1) - A $$ (0, 1) * A $$ (1, 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_nf_root_char_poly: fixes A :: \"'a :: {semiring_no_zero_divisors, idom} mat\"\n  assumes \"jordan_nf A n_as\" \n  and \"(m, lam) \\<in> set n_as\" \nshows \"poly (char_poly A) lam = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = (0::'a)", "from assms"], ["proof (chain)\npicking this:\n  jordan_nf A n_as\n  (m, lam) \\<in> set n_as", "have m0: \"m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  jordan_nf A n_as\n  (m, lam) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "unfolding jordan_nf_def"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n  (m, lam) \\<in> set n_as\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = (0::'a)", "from split_list[OF assms(2)]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. n_as = ys @ (m, lam) # zs", "obtain as bs where nas: \"n_as = as @ (m, lam) # bs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. n_as = ys @ (m, lam) # zs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        n_as = as @ (m, lam) # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n_as = as @ (m, lam) # bs\n\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = (0::'a)", "using m0"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (char_poly A) lam = (0::'a)", "unfolding jordan_nf_char_poly[OF assms(1)] nas poly_prod_list prod_list_zero_iff"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0::'a)\n    \\<in> set (map (\\<lambda>p. poly p lam)\n                (map (\\<lambda>(n, a). [:- a, 1::'a:] ^ n)\n                  (as @ (m, lam) # bs)))", "by (auto simp: o_def)"], ["proof (state)\nthis:\n  poly (char_poly A) lam = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_power_tendsto_zero:\n  \"(\\<lambda>x. inverse ((of_nat x :: 'a :: real_normed_div_algebra) ^ Suc d)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (of_nat x ^ Suc d))\n    \\<longlonglongrightarrow> (0::'a)", "proof (rule filterlim_compose[OF tendsto_inverse_0], \n  intro filterlim_at_infinity[THEN iffD2, of 0] allI impI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> 0\n 2. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially. r \\<le> norm (of_nat x ^ Suc d)", "case (2 r)"], ["proof (state)\nthis:\n  0 < r\n\ngoal (2 subgoals):\n 1. 0 \\<le> 0\n 2. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially. r \\<le> norm (of_nat x ^ Suc d)", "let ?r = \"nat (ceiling r) + 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> 0\n 2. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in sequentially. r \\<le> norm (of_nat x ^ Suc d)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially. r \\<le> norm (of_nat x ^ Suc d)", "proof (intro eventually_sequentiallyI[of ?r], unfold norm_power norm_of_nat)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "assume r: \"?r \\<le> x\""], ["proof (state)\nthis:\n  nat \\<lceil>r\\<rceil> + 1 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "hence x1: \"real x \\<ge> 1\""], ["proof (prove)\nusing this:\n  nat \\<lceil>r\\<rceil> + 1 \\<le> x\n\ngoal (1 subgoal):\n 1. 1 \\<le> real x", "by auto"], ["proof (state)\nthis:\n  1 \\<le> real x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "have \"r \\<le> real ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> real (nat \\<lceil>r\\<rceil> + 1)", "by linarith"], ["proof (state)\nthis:\n  r \\<le> real (nat \\<lceil>r\\<rceil> + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "also"], ["proof (state)\nthis:\n  r \\<le> real (nat \\<lceil>r\\<rceil> + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (nat \\<lceil>r\\<rceil> + 1) \\<le> real x", "using r"], ["proof (prove)\nusing this:\n  nat \\<lceil>r\\<rceil> + 1 \\<le> x\n\ngoal (1 subgoal):\n 1. real (nat \\<lceil>r\\<rceil> + 1) \\<le> real x", "by auto"], ["proof (state)\nthis:\n  real (nat \\<lceil>r\\<rceil> + 1) \\<le> real x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "also"], ["proof (state)\nthis:\n  real (nat \\<lceil>r\\<rceil> + 1) \\<le> real x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "have \"\\<dots> \\<le> real x ^ Suc d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real x \\<le> real x ^ Suc d", "using x1"], ["proof (prove)\nusing this:\n  1 \\<le> real x\n\ngoal (1 subgoal):\n 1. real x \\<le> real x ^ Suc d", "by simp"], ["proof (state)\nthis:\n  real x \\<le> real x ^ Suc d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nat \\<lceil>r\\<rceil> + 1 \\<le> x \\<Longrightarrow>\n       r \\<le> real x ^ Suc d", "finally"], ["proof (chain)\npicking this:\n  r \\<le> real x ^ Suc d", "show \"r \\<le> real x ^ Suc d\""], ["proof (prove)\nusing this:\n  r \\<le> real x ^ Suc d\n\ngoal (1 subgoal):\n 1. r \\<le> real x ^ Suc d", "."], ["proof (state)\nthis:\n  r \\<le> real x ^ Suc d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in sequentially. r \\<le> norm (of_nat x ^ Suc d)\n\ngoal (1 subgoal):\n 1. 0 \\<le> 0", "qed simp"], ["", "lemma inverse_of_nat_tendsto_zero:\n  \"(\\<lambda>x. inverse (of_nat x :: 'a :: real_normed_div_algebra)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (of_nat x)) \\<longlonglongrightarrow> (0::'a)", "using inverse_power_tendsto_zero[of 0]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. inverse (of_nat x ^ Suc 0))\n  \\<longlonglongrightarrow> (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (of_nat x)) \\<longlonglongrightarrow> (0::'a)", "by auto"], ["", "lemma poly_times_exp_tendsto_zero: assumes b: \"norm (b :: 'a :: real_normed_field) < 1\" \n  shows \"(\\<lambda> x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "define nla where \"nla = norm b\""], ["proof (state)\nthis:\n  nla = norm b\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "define s where \"s = sqrt nla\""], ["proof (state)\nthis:\n  s = sqrt nla\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "from b False"], ["proof (chain)\npicking this:\n  norm b < 1\n  b \\<noteq> (0::'a)", "have nla: \"0 < nla\" \"nla < 1\""], ["proof (prove)\nusing this:\n  norm b < 1\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < nla &&& nla < 1", "unfolding nla_def"], ["proof (prove)\nusing this:\n  norm b < 1\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < norm b &&& norm b < 1", "by auto"], ["proof (state)\nthis:\n  0 < nla\n  nla < 1\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "hence s: \"0 < s\" \"s < 1\""], ["proof (prove)\nusing this:\n  0 < nla\n  nla < 1\n\ngoal (1 subgoal):\n 1. 0 < s &&& s < 1", "unfolding s_def"], ["proof (prove)\nusing this:\n  0 < nla\n  nla < 1\n\ngoal (1 subgoal):\n 1. 0 < sqrt nla &&& sqrt nla < 1", "by auto"], ["proof (state)\nthis:\n  0 < s\n  s < 1\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "{"], ["proof (state)\nthis:\n  0 < s\n  s < 1\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "have \"s^x * s^x = sqrt (nla ^ (2 * x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s ^ x * s ^ x = sqrt (nla ^ (2 * x))", "unfolding s_def power_add[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt nla ^ (x + x) = sqrt (nla ^ (2 * x))", "unfolding real_sqrt_power[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (nla ^ (x + x)) = sqrt (nla ^ (2 * x))", "by (rule arg_cong[of _ _ \"\\<lambda> x. sqrt (nla ^ x)\"], simp)"], ["proof (state)\nthis:\n  s ^ x * s ^ x = sqrt (nla ^ (2 * x))\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "also"], ["proof (state)\nthis:\n  s ^ x * s ^ x = sqrt (nla ^ (2 * x))\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "have \"\\<dots> = nla^x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (nla ^ (2 * x)) = nla ^ x", "unfolding power_mult real_sqrt_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sqrt nla)\\<^sup>2 ^ x = nla ^ x", "using nla"], ["proof (prove)\nusing this:\n  0 < nla\n  nla < 1\n\ngoal (1 subgoal):\n 1. (sqrt nla)\\<^sup>2 ^ x = nla ^ x", "by simp"], ["proof (state)\nthis:\n  sqrt (nla ^ (2 * x)) = nla ^ x\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  s ^ x * s ^ x = nla ^ x", "have \"nla^x = s^x * s^x\""], ["proof (prove)\nusing this:\n  s ^ x * s ^ x = nla ^ x\n\ngoal (1 subgoal):\n 1. nla ^ x = s ^ x * s ^ x", "by simp"], ["proof (state)\nthis:\n  nla ^ x = s ^ x * s ^ x\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "}"], ["proof (state)\nthis:\n  nla ^ ?x2 = s ^ ?x2 * s ^ ?x2\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "note nla_s = this"], ["proof (state)\nthis:\n  nla ^ ?x2 = s ^ ?x2 * s ^ ?x2\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "show \"(\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "proof (rule tendsto_norm_zero_cancel, unfold norm_mult norm_power norm_of_nat nla_def[symmetric] nla_s\n       mult.assoc[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0", "from poly_exp_constant_bound[OF s, of 1 k]"], ["proof (chain)\npicking this:\n  \\<exists>p. \\<forall>x. 1 * s ^ x * real x ^ k \\<le> p", "obtain p where \n      p: \"real x ^ k * s^x \\<le> p\" for x"], ["proof (prove)\nusing this:\n  \\<exists>p. \\<forall>x. 1 * s ^ x * real x ^ k \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        (\\<And>x. real x ^ k * s ^ x \\<le> p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  real ?x ^ k * s ^ ?x \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0", "have \"norm (real x ^ k * s ^ x) = real x ^ k * s^x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (real x ^ k * s ^ x) = real x ^ k * s ^ x", "using s"], ["proof (prove)\nusing this:\n  0 < s\n  s < 1\n\ngoal (1 subgoal):\n 1. norm (real x ^ k * s ^ x) = real x ^ k * s ^ x", "by auto"], ["proof (state)\nthis:\n  norm (real ?x ^ k * s ^ ?x) = real ?x ^ k * s ^ ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0", "with p"], ["proof (chain)\npicking this:\n  real ?x ^ k * s ^ ?x \\<le> p\n  norm (real ?x ^ k * s ^ ?x) = real ?x ^ k * s ^ ?x", "have p: \"norm (real x ^ k * s ^ x) \\<le> p\" for x"], ["proof (prove)\nusing this:\n  real ?x ^ k * s ^ ?x \\<le> p\n  norm (real ?x ^ k * s ^ ?x) = real ?x ^ k * s ^ ?x\n\ngoal (1 subgoal):\n 1. norm (real x ^ k * s ^ x) \\<le> p", "by auto"], ["proof (state)\nthis:\n  norm (real ?x ^ k * s ^ ?x) \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0", "from s"], ["proof (chain)\npicking this:\n  0 < s\n  s < 1", "have s: \"norm s < 1\""], ["proof (prove)\nusing this:\n  0 < s\n  s < 1\n\ngoal (1 subgoal):\n 1. norm s < 1", "by auto"], ["proof (state)\nthis:\n  norm s < 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0", "show \"(\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0", "by (rule lim_null_mult_left_bounded[OF _ LIMSEQ_power_zero[OF s], of _ p], insert p, auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. real x ^ k * s ^ x * s ^ x) \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n\ngoal (1 subgoal):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "case True"], ["proof (state)\nthis:\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. b = (0::'a) \\<Longrightarrow>\n    (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_nat x ^ k * (0::'a) ^ x)\n    \\<longlonglongrightarrow> (0::'a)", "by (subst tendsto_cong[of _ \"\\<lambda> x. 0\"], rule eventually_sequentiallyI[of 1], auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. of_nat x ^ k * b ^ x) \\<longlonglongrightarrow> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder_topology) tendsto_Min: assumes I: \"I \\<noteq> {}\" and fin: \"finite I\"\n  shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> (f i \\<longlongrightarrow> a i) F) \\<Longrightarrow> ((\\<lambda>x. Min ((\\<lambda> i. f i x) ` I)) \\<longlongrightarrow> \n    (Min (a ` I) :: 'a)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow>\n        (f i \\<longlongrightarrow> a i) F) \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow> Min (a ` I)) F", "using fin I"], ["proof (prove)\nusing this:\n  finite I\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow>\n        (f i \\<longlongrightarrow> a i) F) \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow> Min (a ` I)) F", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i \\<in> {} \\<Longrightarrow>\n                (f i \\<longlongrightarrow> a i) F;\n     {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           MIN i\\<in>{}. f i x) \\<longlongrightarrow>\n                       Min (a ` {}))\n                       F\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>i.\n                    i \\<in> Fa \\<Longrightarrow>\n                    (f i \\<longlongrightarrow> a i) F;\n         Fa \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((\\<lambda>x.\n                               MIN i\\<in>Fa. f i x) \\<longlongrightarrow>\n                           Min (a ` Fa))\n                           F;\n        \\<And>i.\n           i \\<in> insert x Fa \\<Longrightarrow>\n           (f i \\<longlongrightarrow> a i) F;\n        insert x Fa \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>xa.\n                              MIN i\\<in>insert x Fa.\n                                 f i xa) \\<longlongrightarrow>\n                          Min (a ` insert x Fa))\n                          F", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  \\<lbrakk>\\<And>i.\n              i \\<in> I \\<Longrightarrow> (f i \\<longlongrightarrow> a i) F;\n   I \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow>\n                     Min (a ` I))\n                     F\n  ?i \\<in> insert i I \\<Longrightarrow> (f ?i \\<longlongrightarrow> a ?i) F\n  insert i I \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i \\<in> {} \\<Longrightarrow>\n                (f i \\<longlongrightarrow> a i) F;\n     {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           MIN i\\<in>{}. f i x) \\<longlongrightarrow>\n                       Min (a ` {}))\n                       F\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>i.\n                    i \\<in> Fa \\<Longrightarrow>\n                    (f i \\<longlongrightarrow> a i) F;\n         Fa \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((\\<lambda>x.\n                               MIN i\\<in>Fa. f i x) \\<longlongrightarrow>\n                           Min (a ` Fa))\n                           F;\n        \\<And>i.\n           i \\<in> insert x Fa \\<Longrightarrow>\n           (f i \\<longlongrightarrow> a i) F;\n        insert x Fa \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>xa.\n                              MIN i\\<in>insert x Fa.\n                                 f i xa) \\<longlongrightarrow>\n                          Min (a ` insert x Fa))\n                          F", "hence i: \"(f i \\<longlongrightarrow> a i) F\""], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  \\<lbrakk>\\<And>i.\n              i \\<in> I \\<Longrightarrow> (f i \\<longlongrightarrow> a i) F;\n   I \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow>\n                     Min (a ` I))\n                     F\n  ?i \\<in> insert i I \\<Longrightarrow> (f ?i \\<longlongrightarrow> a ?i) F\n  insert i I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (f i \\<longlongrightarrow> a i) F", "by auto"], ["proof (state)\nthis:\n  (f i \\<longlongrightarrow> a i) F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i \\<in> {} \\<Longrightarrow>\n                (f i \\<longlongrightarrow> a i) F;\n     {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           MIN i\\<in>{}. f i x) \\<longlongrightarrow>\n                       Min (a ` {}))\n                       F\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>i.\n                    i \\<in> Fa \\<Longrightarrow>\n                    (f i \\<longlongrightarrow> a i) F;\n         Fa \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((\\<lambda>x.\n                               MIN i\\<in>Fa. f i x) \\<longlongrightarrow>\n                           Min (a ` Fa))\n                           F;\n        \\<And>i.\n           i \\<in> insert x Fa \\<Longrightarrow>\n           (f i \\<longlongrightarrow> a i) F;\n        insert x Fa \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>xa.\n                              MIN i\\<in>insert x Fa.\n                                 f i xa) \\<longlongrightarrow>\n                          Min (a ` insert x Fa))\n                          F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "proof (cases \"I = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F\n 2. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "case True"], ["proof (state)\nthis:\n  I = {}\n\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F\n 2. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>{i}. f i x) \\<longlongrightarrow> Min (a ` {i}))\n     F", "using i"], ["proof (prove)\nusing this:\n  (f i \\<longlongrightarrow> a i) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>{i}. f i x) \\<longlongrightarrow> Min (a ` {i}))\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n   Min (a ` insert i I))\n   F\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "case False"], ["proof (state)\nthis:\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "have *: \"Min (a ` insert i I) = min (a i) (Min (a ` I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (a ` insert i I) = min (a i) (Min (a ` I))", "using False insert(1)"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  finite I\n\ngoal (1 subgoal):\n 1. Min (a ` insert i I) = min (a i) (Min (a ` I))", "by auto"], ["proof (state)\nthis:\n  Min (a ` insert i I) = min (a i) (Min (a ` I))\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "have **: \"(\\<lambda>x. Min ((\\<lambda>i. f i x) ` insert i I)) = (\\<lambda>x. min (f i x) (Min ((\\<lambda>i. f i x) ` I)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. MIN i\\<in>insert i I. f i x) =\n    (\\<lambda>x. min (f i x) (MIN i\\<in>I. f i x))", "using False insert(1)"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. MIN i\\<in>insert i I. f i x) =\n    (\\<lambda>x. min (f i x) (MIN i\\<in>I. f i x))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. MIN i\\<in>insert i I. f i x) =\n  (\\<lambda>x. min (f i x) (MIN i\\<in>I. f i x))\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "have IH: \"((\\<lambda>x. Min ((\\<lambda>i. f i x) ` I)) \\<longlongrightarrow> Min (a ` I)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow> Min (a ` I)) F", "using insert(3)[OF insert(4) False]"], ["proof (prove)\nusing this:\n  (\\<And>ia.\n      ia \\<in> I \\<Longrightarrow> ia \\<in> insert i I) \\<Longrightarrow>\n  ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow> Min (a ` I)) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow> Min (a ` I)) F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. MIN i\\<in>I. f i x) \\<longlongrightarrow> Min (a ` I)) F\n\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n     Min (a ` insert i I))\n     F", "unfolding * **"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. min (f i x) (MIN i\\<in>I. f i x)) \\<longlongrightarrow>\n     min (a i) (Min (a ` I)))\n     F", "by (auto intro!: tendsto_min i IH)"], ["proof (state)\nthis:\n  ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n   Min (a ` insert i I))\n   F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. MIN i\\<in>insert i I. f i x) \\<longlongrightarrow>\n   Min (a ` insert i I))\n   F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                i \\<in> {} \\<Longrightarrow>\n                (f i \\<longlongrightarrow> a i) F;\n     {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           MIN i\\<in>{}. f i x) \\<longlongrightarrow>\n                       Min (a ` {}))\n                       F", "qed simp"], ["", "lemma tendsto_mat_mult [tendsto_intros]: \n  \"(f \\<longlongrightarrow> a) F \\<Longrightarrow> (g \\<longlongrightarrow> b) F \\<Longrightarrow> ((\\<lambda>x. f x ** g x) \\<longlongrightarrow> a ** b) F\" \n  for f :: \"'a \\<Rightarrow> 'b :: {semiring_1, real_normed_algebra} ^ 'n1 ^ 'n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> a) F;\n     (g \\<longlongrightarrow> b) F\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x ** g x) \\<longlongrightarrow>\n                       a ** b)\n                       F", "unfolding matrix_matrix_mult_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> a) F;\n     (g \\<longlongrightarrow> b) F\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<chi>i j.\n                              \\<Sum>k\\<in>UNIV.\n                                f x $h i $h k *\n                                g x $h k $h j) \\<longlongrightarrow>\n                       (\\<chi>i j.\n                           \\<Sum>k\\<in>UNIV. a $h i $h k * b $h k $h j))\n                       F", "by (auto intro!: tendsto_intros)"], ["", "lemma tendsto_matpower [tendsto_intros]: \"(f \\<longlongrightarrow> a) F \\<Longrightarrow> ((\\<lambda>x. matpow (f x) n) \\<longlongrightarrow> matpow a n) F\"\n  for f :: \"'a \\<Rightarrow> 'b :: {semiring_1, real_normed_algebra} ^ 'n ^ 'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>x. matpow (f x) n) \\<longlongrightarrow> matpow a n) F", "by (induct n, simp_all add: tendsto_mat_mult)"], ["", "lemma continuous_matpow: \"continuous_on R (\\<lambda> A :: 'a :: {semiring_1, real_normed_algebra_1} ^ 'n ^ 'n. matpow A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on R (\\<lambda>A. matpow A n)", "unfolding continuous_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>R.\n       ((\\<lambda>A. matpow A n) \\<longlongrightarrow> matpow x n)\n        (at x within R)", "by (auto intro!: tendsto_intros)"], ["", "lemma vector_smult_distrib: \"(A *v ((a :: 'a :: comm_ring_1) *s x)) = a *s ((A *v x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (a *s x) = a *s (A *v x)", "unfolding matrix_vector_mult_def vector_scalar_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * (\\<chi>i. a * x $h i) $h j) =\n    (\\<chi>i. a * (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) $h i)", "by (simp add: ac_simps sum_distrib_left)"], ["", "instance real :: ordered_semiring_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, ordered_semiring_strict_class)", "by (intro_classes, auto)"], ["", "lemma poly_tendsto_pinfty:  fixes p :: \"real poly\"\n  assumes \"lead_coeff p > 0\" \"degree p \\<noteq> 0\" \n  shows \"poly p \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (poly p (real x)))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding Lim_PInfty"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B.\n       \\<exists>N. \\<forall>n\\<ge>N. ereal B \\<le> ereal (poly p (real n))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<exists>N. \\<forall>n\\<ge>N. ereal B \\<le> ereal (poly p (real n))", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<exists>N. \\<forall>n\\<ge>N. ereal B \\<le> ereal (poly p (real n))", "show \"\\<exists>N. \\<forall>n\\<ge>N. ereal b \\<le> ereal (poly p (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. ereal b \\<le> ereal (poly p (real n))", "unfolding ereal_less_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. b \\<le> poly p (real n)", "using poly_pinfty_ge[OF assms, of b]"], ["proof (prove)\nusing this:\n  \\<exists>n. \\<forall>x\\<ge>n. b \\<le> poly p x\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. b \\<le> poly p (real n)", "by (meson of_nat_le_iff order_trans real_arch_simple)"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. ereal b \\<le> ereal (poly p (real n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_lt_nat: \"(j :: nat) < x * y \\<Longrightarrow> j div x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < x * y \\<Longrightarrow> j div x < y", "by (simp add: less_mult_imp_div_less mult.commute)"], ["", "definition diagvector :: \"('n \\<Rightarrow> 'a :: semiring_0) \\<Rightarrow> 'a ^ 'n ^ 'n\" where\n  \"diagvector x = (\\<chi> i. \\<chi> j. if i = j then x i else 0)\""], ["", "lemma diagvector_mult_vector[simp]: \"diagvector x *v y = (\\<chi> i. x i * y $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagvector x *v y = (\\<chi>i. x i * y $h i)", "unfolding diagvector_def matrix_vector_mult_def vec_eq_iff vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<Sum>j\\<in>UNIV. (if i = j then x i else (0::'a)) * y $h j) =\n       x i * y $h i", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV. (if i = j then x i else (0::'a)) * y $h j) =\n       x i * y $h i", "case (1 i)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<Sum>j\\<in>UNIV. (if i = j then x i else (0::'a)) * y $h j) =\n       x i * y $h i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. (if i = j then x i else (0::'a)) * y $h j) =\n    x i * y $h i", "by (subst sum.remove[of _ i], auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. (if i = j then x i else (0::'a)) * y $h j) =\n  x i * y $h i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagvector_mult_left: \"diagvector x ** A = (\\<chi> i j. x i * A $ i $ j)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. diagvector x ** A = (\\<chi>i j. x i * A $h i $h j)", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (diagvector x ** A) $h i $h ia =\n       (\\<chi>i j. x i * A $h i $h j) $h i $h ia", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (diagvector x ** A) $h i $h ia =\n       (\\<chi>i j. x i * A $h i $h j) $h i $h ia", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (diagvector x ** A) $h i $h ia =\n       (\\<chi>i j. x i * A $h i $h j) $h i $h ia", "show \"?A $h i $h j = ?B $h i $h j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (diagvector x ** A) $h i $h j = (\\<chi>i j. x i * A $h i $h j) $h i $h j", "unfolding map_vector_def diagvector_def matrix_matrix_mult_def vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. (if i = k then x i else (0::'a)) * A $h k $h j) =\n    x i * A $h i $h j", "by (subst sum.remove[of _ i], auto)"], ["proof (state)\nthis:\n  (diagvector x ** A) $h i $h j = (\\<chi>i j. x i * A $h i $h j) $h i $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagvector_mult_right: \"A ** diagvector x = (\\<chi> i j. A $ i $ j * x j)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** diagvector x = (\\<chi>i j. A $h i $h j * x j)", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (A ** diagvector x) $h i $h ia =\n       (\\<chi>i j. A $h i $h j * x j) $h i $h ia", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (A ** diagvector x) $h i $h ia =\n       (\\<chi>i j. A $h i $h j * x j) $h i $h ia", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       (A ** diagvector x) $h i $h ia =\n       (\\<chi>i j. A $h i $h j * x j) $h i $h ia", "show \"?A $h i $h j = ?B $h i $h j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** diagvector x) $h i $h j = (\\<chi>i j. A $h i $h j * x j) $h i $h j", "unfolding map_vector_def diagvector_def matrix_matrix_mult_def vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. A $h i $h k * (if k = j then x k else (0::'a))) =\n    A $h i $h j * x j", "by (subst sum.remove[of _ j], auto)"], ["proof (state)\nthis:\n  (A ** diagvector x) $h i $h j = (\\<chi>i j. A $h i $h j * x j) $h i $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagvector_mult[simp]: \"diagvector x ** diagvector y = diagvector (\\<lambda> i. x i * y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagvector x ** diagvector y = diagvector (\\<lambda>i. x i * y i)", "unfolding diagvector_mult_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. x i * diagvector y $h i $h j) =\n    diagvector (\\<lambda>i. x i * y i)", "unfolding diagvector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        x i * (\\<chi>i j. if i = j then y i else (0::'a)) $h i $h j) =\n    (\\<chi>i j. if i = j then x i * y i else (0::'a))", "by (auto simp: vec_eq_iff)"], ["", "lemma diagvector_const[simp]: \"diagvector (\\<lambda> x. k) = mat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagvector (\\<lambda>x. k) = mat k", "unfolding diagvector_def mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. if i = j then k else (0::'a)) =\n    (\\<chi>i j. if i = j then k else (0::'a))", "by auto"], ["", "lemma diagvector_eq_mat: \"diagvector x = mat a \\<longleftrightarrow> x = (\\<lambda> x. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (diagvector x = mat a) = (x = (\\<lambda>x. a))", "unfolding diagvector_def mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<chi>i j. if i = j then x i else (0::'a)) =\n     (\\<chi>i j. if i = j then a else (0::'a))) =\n    (x = (\\<lambda>x. a))", "by (auto simp: vec_eq_iff)"], ["", "lemma cmod_eq_Re: assumes \"cmod x = Re x\"\n  shows \"of_real (Re x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (Re x) = x", "proof (cases \"Im x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Im x = 0 \\<Longrightarrow> complex_of_real (Re x) = x\n 2. Im x \\<noteq> 0 \\<Longrightarrow> complex_of_real (Re x) = x", "case False"], ["proof (state)\nthis:\n  Im x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Im x = 0 \\<Longrightarrow> complex_of_real (Re x) = x\n 2. Im x \\<noteq> 0 \\<Longrightarrow> complex_of_real (Re x) = x", "hence \"(cmod x)^2 \\<noteq> (Re x)^2\""], ["proof (prove)\nusing this:\n  Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod x)\\<^sup>2 \\<noteq> (Re x)\\<^sup>2", "unfolding norm_complex_def"], ["proof (prove)\nusing this:\n  Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sqrt ((Re x)\\<^sup>2 + (Im x)\\<^sup>2))\\<^sup>2 \\<noteq> (Re x)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (cmod x)\\<^sup>2 \\<noteq> (Re x)\\<^sup>2\n\ngoal (2 subgoals):\n 1. Im x = 0 \\<Longrightarrow> complex_of_real (Re x) = x\n 2. Im x \\<noteq> 0 \\<Longrightarrow> complex_of_real (Re x) = x", "from this[unfolded assms]"], ["proof (chain)\npicking this:\n  (Re x)\\<^sup>2 \\<noteq> (Re x)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (Re x)\\<^sup>2 \\<noteq> (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. complex_of_real (Re x) = x", "by auto"], ["proof (state)\nthis:\n  complex_of_real (Re x) = x\n\ngoal (1 subgoal):\n 1. Im x = 0 \\<Longrightarrow> complex_of_real (Re x) = x", "qed (cases x, auto simp: norm_complex_def complex_of_real_def)"], ["", "hide_fact (open) Matrix.vec_eq_iff"], ["", "no_notation\n  vec_index (infixl \"$\" 100)"], ["", "lemma spectral_radius_ev:\n  \"\\<exists> ev v. eigen_vector A v ev \\<and> norm ev = spectral_radius A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ev v.\n       eigen_vector A v ev \\<and> cmod ev = HMA_Connect.spectral_radius A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ev v.\n       eigen_vector A v ev \\<and> cmod ev = HMA_Connect.spectral_radius A", "from non_empty_spectrum[of A] finite_spectrum[of A]"], ["proof (chain)\npicking this:\n  Collect (eigen_value A) \\<noteq> {}\n  finite (Collect (eigen_value A))", "have\n    \"spectral_radius A \\<in> norm ` (Collect (eigen_value A))\""], ["proof (prove)\nusing this:\n  Collect (eigen_value A) \\<noteq> {}\n  finite (Collect (eigen_value A))\n\ngoal (1 subgoal):\n 1. HMA_Connect.spectral_radius A \\<in> cmod ` Collect (eigen_value A)", "unfolding spectral_radius_ev_def"], ["proof (prove)\nusing this:\n  Collect (eigen_value A) \\<noteq> {}\n  finite (Collect (eigen_value A))\n\ngoal (1 subgoal):\n 1. Max (cmod ` Collect (eigen_value A))\n    \\<in> cmod ` Collect (eigen_value A)", "by auto"], ["proof (state)\nthis:\n  HMA_Connect.spectral_radius A \\<in> cmod ` Collect (eigen_value A)\n\ngoal (1 subgoal):\n 1. \\<exists>ev v.\n       eigen_vector A v ev \\<and> cmod ev = HMA_Connect.spectral_radius A", "thus ?thesis"], ["proof (prove)\nusing this:\n  HMA_Connect.spectral_radius A \\<in> cmod ` Collect (eigen_value A)\n\ngoal (1 subgoal):\n 1. \\<exists>ev v.\n       eigen_vector A v ev \\<and> cmod ev = HMA_Connect.spectral_radius A", "unfolding eigen_value_def[abs_def]"], ["proof (prove)\nusing this:\n  HMA_Connect.spectral_radius A\n  \\<in> cmod ` {k. \\<exists>v. eigen_vector A v k}\n\ngoal (1 subgoal):\n 1. \\<exists>ev v.\n       eigen_vector A v ev \\<and> cmod ev = HMA_Connect.spectral_radius A", "by auto"], ["proof (state)\nthis:\n  \\<exists>ev v.\n     eigen_vector A v ev \\<and> cmod ev = HMA_Connect.spectral_radius A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spectral_radius_max: assumes \"eigen_value A v\"\n  shows \"norm v \\<le> spectral_radius A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod v \\<le> HMA_Connect.spectral_radius A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod v \\<le> HMA_Connect.spectral_radius A", "from assms"], ["proof (chain)\npicking this:\n  eigen_value A v", "have \"norm v \\<in> norm ` (Collect (eigen_value A))\""], ["proof (prove)\nusing this:\n  eigen_value A v\n\ngoal (1 subgoal):\n 1. cmod v \\<in> cmod ` Collect (eigen_value A)", "by auto"], ["proof (state)\nthis:\n  cmod v \\<in> cmod ` Collect (eigen_value A)\n\ngoal (1 subgoal):\n 1. cmod v \\<le> HMA_Connect.spectral_radius A", "from Max_ge[OF _ this, folded spectral_radius_ev_def]\n    finite_spectrum[of A]"], ["proof (chain)\npicking this:\n  finite (cmod ` Collect (eigen_value A)) \\<Longrightarrow>\n  cmod v \\<le> HMA_Connect.spectral_radius A\n  finite (Collect (eigen_value A))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (cmod ` Collect (eigen_value A)) \\<Longrightarrow>\n  cmod v \\<le> HMA_Connect.spectral_radius A\n  finite (Collect (eigen_value A))\n\ngoal (1 subgoal):\n 1. cmod v \\<le> HMA_Connect.spectral_radius A", "by auto"], ["proof (state)\nthis:\n  cmod v \\<le> HMA_Connect.spectral_radius A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For Perron-Frobenius it is useful to use the linear norm, and\n  not the Euclidean norm.\\<close>"], ["", "definition norm1 :: \"'a :: real_normed_field ^ 'n \\<Rightarrow> real\" where\n  \"norm1 v = (\\<Sum>i\\<in>UNIV. norm (v $ i))\""], ["", "lemma norm1_ge_0: \"norm1 v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm1 v", "unfolding norm1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>i\\<in>UNIV. norm (v $h i))", "by (rule sum_nonneg, auto)"], ["", "lemma norm1_0[simp]: \"norm1 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm1 0 = 0", "unfolding norm1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. norm (0 $h i)) = 0", "by auto"], ["", "lemma norm1_nonzero: assumes \"v \\<noteq> 0\"\n  shows \"norm1 v > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < norm1 v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < norm1 v", "from \\<open>v \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  v \\<noteq> 0", "obtain i where vi: \"v $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        v $h i \\<noteq> (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vec_eq_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. v $h i = 0 $h i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        v $h i \\<noteq> (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Finite_Cartesian_Product.vec_eq_iff zero_index"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. v $h i = 0 $h i)\n  (?x = ?y) = (\\<forall>i. ?x $h i = ?y $h i)\n  0 $h ?i = (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        v $h i \\<noteq> (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  v $h i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "have \"sum (\\<lambda> i. norm (v $ i)) (UNIV - {i}) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))", "by (rule sum_nonneg, auto)"], ["proof (state)\nthis:\n  0 \\<le> (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "moreover"], ["proof (state)\nthis:\n  0 \\<le> (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "have \"norm (v $ i) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < norm (v $h i)", "using vi"], ["proof (prove)\nusing this:\n  v $h i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < norm (v $h i)", "by auto"], ["proof (state)\nthis:\n  0 < norm (v $h i)\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))\n  0 < norm (v $h i)", "have \"0 < norm (v $ i) + sum (\\<lambda> i. norm (v $ i)) (UNIV - {i})\""], ["proof (prove)\nusing this:\n  0 \\<le> (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))\n  0 < norm (v $h i)\n\ngoal (1 subgoal):\n 1. 0 < norm (v $h i) + (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))", "by arith"], ["proof (state)\nthis:\n  0 < norm (v $h i) + (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "also"], ["proof (state)\nthis:\n  0 < norm (v $h i) + (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i))\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "have \"\\<dots> = norm1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v $h i) + (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i)) = norm1 v", "unfolding norm1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v $h i) + (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i)) =\n    (\\<Sum>i\\<in>UNIV. norm (v $h i))", "by (simp add: sum.remove)"], ["proof (state)\nthis:\n  norm (v $h i) + (\\<Sum>i\\<in>UNIV - {i}. norm (v $h i)) = norm1 v\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "finally"], ["proof (chain)\npicking this:\n  0 < norm1 v", "show \"norm1 v > 0\""], ["proof (prove)\nusing this:\n  0 < norm1 v\n\ngoal (1 subgoal):\n 1. 0 < norm1 v", "."], ["proof (state)\nthis:\n  0 < norm1 v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm1_0_iff[simp]: \"(norm1 v = 0) = (v = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm1 v = 0) = (v = 0)", "using norm1_0 norm1_nonzero"], ["proof (prove)\nusing this:\n  norm1 0 = 0\n  ?v \\<noteq> 0 \\<Longrightarrow> 0 < norm1 ?v\n\ngoal (1 subgoal):\n 1. (norm1 v = 0) = (v = 0)", "by (cases \"v = 0\", force+)"], ["", "lemma norm1_scaleR[simp]: \"norm1 (r *\\<^sub>R v) = abs r * norm1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm1 (r *\\<^sub>R v) = \\<bar>r\\<bar> * norm1 v", "unfolding norm1_def sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. norm ((r *\\<^sub>R v) $h i)) =\n    (\\<Sum>n\\<in>UNIV. \\<bar>r\\<bar> * norm (v $h n))", "by (rule sum.cong, auto)"], ["", "lemma abs_norm1[simp]: \"abs (norm1 v) = norm1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>norm1 v\\<bar> = norm1 v", "using norm1_ge_0[of v]"], ["proof (prove)\nusing this:\n  0 \\<le> norm1 v\n\ngoal (1 subgoal):\n 1. \\<bar>norm1 v\\<bar> = norm1 v", "by arith"], ["", "lemma normalize_eigen_vector: assumes \"eigen_vector (A :: 'a :: real_normed_field ^ 'n ^ 'n) v ev\"\n  shows \"eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\" \"norm1 ((1 / norm1 v) *\\<^sub>R v) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev &&&\n    norm1 ((1 / norm1 v) *\\<^sub>R v) = 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\n 2. norm1 ((1 / norm1 v) *\\<^sub>R v) = 1", "let ?v = \"(1 / norm1 v) *\\<^sub>R v\""], ["proof (state)\ngoal (2 subgoals):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\n 2. norm1 ((1 / norm1 v) *\\<^sub>R v) = 1", "from assms[unfolded eigen_vector_def]"], ["proof (chain)\npicking this:\n  v \\<noteq> 0 \\<and> A *v v = ev *s v", "have nz: \"v \\<noteq> 0\" and id: \"A *v v = ev *s v\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0 \\<and> A *v v = ev *s v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 &&& A *v v = ev *s v", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\n  A *v v = ev *s v\n\ngoal (2 subgoals):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\n 2. norm1 ((1 / norm1 v) *\\<^sub>R v) = 1", "from nz"], ["proof (chain)\npicking this:\n  v \\<noteq> 0", "have norm1: \"norm1 v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. norm1 v \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  norm1 v \\<noteq> 0\n\ngoal (2 subgoals):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\n 2. norm1 ((1 / norm1 v) *\\<^sub>R v) = 1", "thus \"norm1 ?v = 1\""], ["proof (prove)\nusing this:\n  norm1 v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. norm1 ((1 / norm1 v) *\\<^sub>R v) = 1", "by simp"], ["proof (state)\nthis:\n  norm1 ((1 / norm1 v) *\\<^sub>R v) = 1\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "from norm1 nz"], ["proof (chain)\npicking this:\n  norm1 v \\<noteq> 0\n  v \\<noteq> 0", "have nz: \"?v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  norm1 v \\<noteq> 0\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 / norm1 v) *\\<^sub>R v \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (1 / norm1 v) *\\<^sub>R v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "have \"A *v ?v = (1 / norm1 v) *\\<^sub>R (A *v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (1 / norm1 v) *\\<^sub>R v = (1 / norm1 v) *\\<^sub>R (A *v v)", "by (auto simp: vec_eq_iff matrix_vector_mult_def real_vector.scale_sum_right)"], ["proof (state)\nthis:\n  A *v (1 / norm1 v) *\\<^sub>R v = (1 / norm1 v) *\\<^sub>R (A *v v)\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "also"], ["proof (state)\nthis:\n  A *v (1 / norm1 v) *\\<^sub>R v = (1 / norm1 v) *\\<^sub>R (A *v v)\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "have \"A *v v = ev *s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v v = ev *s v", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev *s v = ev *s v", ".."], ["proof (state)\nthis:\n  A *v v = ev *s v\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "also"], ["proof (state)\nthis:\n  A *v v = ev *s v\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "have \"(1 / norm1 v) *\\<^sub>R (ev *s v) = ev *s ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / norm1 v) *\\<^sub>R (ev *s v) = ev *s (1 / norm1 v) *\\<^sub>R v", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  (1 / norm1 v) *\\<^sub>R (ev *s v) = ev *s (1 / norm1 v) *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "finally"], ["proof (chain)\npicking this:\n  A *v (1 / norm1 v) *\\<^sub>R v = ev *s (1 / norm1 v) *\\<^sub>R v", "show \"eigen_vector A ?v ev\""], ["proof (prove)\nusing this:\n  A *v (1 / norm1 v) *\\<^sub>R v = ev *s (1 / norm1 v) *\\<^sub>R v\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "using nz"], ["proof (prove)\nusing this:\n  A *v (1 / norm1 v) *\\<^sub>R v = ev *s (1 / norm1 v) *\\<^sub>R v\n  (1 / norm1 v) *\\<^sub>R v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev", "unfolding eigen_vector_def"], ["proof (prove)\nusing this:\n  A *v (1 / norm1 v) *\\<^sub>R v = ev *s (1 / norm1 v) *\\<^sub>R v\n  (1 / norm1 v) *\\<^sub>R v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 / norm1 v) *\\<^sub>R v \\<noteq> 0 \\<and>\n    A *v (1 / norm1 v) *\\<^sub>R v = ev *s (1 / norm1 v) *\\<^sub>R v", "by auto"], ["proof (state)\nthis:\n  eigen_vector A ((1 / norm1 v) *\\<^sub>R v) ev\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm1_cont[simp]: \"isCont norm1 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont norm1 v", "unfolding norm1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>v. \\<Sum>i\\<in>UNIV. norm (v $h i)) v", "by auto"], ["", "lemma norm1_ge_norm: \"norm1 v \\<ge> norm v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm v \\<le> norm1 v", "unfolding norm1_def norm_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>i. norm (v $h i)) UNIV\n    \\<le> (\\<Sum>i\\<in>UNIV. norm (v $h i))", "by (rule L2_set_le_sum, auto)"], ["", "text \\<open>The following continuity lemmas have been proven with hints from Fabian Immler.\\<close>"], ["", "lemma tendsto_matrix_vector_mult[tendsto_intros]:\n  \"((*v) (A :: 'a :: real_normed_algebra_1 ^ 'n ^ 'k) \\<longlongrightarrow> A *v v) (at v within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((*v) A \\<longlongrightarrow> A *v v) (at v within S)", "unfolding matrix_vector_mult_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<chi>i.\n            \\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) \\<longlongrightarrow>\n     (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * v $h j))\n     (at v within S)", "by (auto intro!: tendsto_intros)"], ["", "lemma tendsto_matrix_matrix_mult[tendsto_intros]:\n  \"((**) (A :: 'a :: real_normed_algebra_1 ^ 'n ^ 'k) \\<longlongrightarrow> A ** B) (at B within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((**) A \\<longlongrightarrow> A ** B) (at B within S)", "unfolding matrix_matrix_mult_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>m'.\n         \\<chi>i j.\n            \\<Sum>k\\<in>UNIV.\n              A $h i $h k * m' $h k $h j) \\<longlongrightarrow>\n     (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $h i $h k * B $h k $h j))\n     (at B within S)", "by (auto intro!: tendsto_intros)"], ["", "lemma matrix_vect_scaleR: \"(A :: 'a :: real_normed_algebra_1 ^ 'n ^ 'k) *v (a *\\<^sub>R v) = a *\\<^sub>R (A *v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v a *\\<^sub>R v = a *\\<^sub>R (A *v v)", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (A *v a *\\<^sub>R v) $h i = (a *\\<^sub>R (A *v v)) $h i", "by (auto simp: matrix_vector_mult_def scaleR_vec_def scaleR_sum_right\n  intro!: sum.cong)"], ["", "lemma (in inj_semiring_hom) map_vector_0: \"(map_vector hom v = 0) = (v = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_vector hom v = 0) = (v = 0)", "unfolding vec_eq_iff map_vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. (\\<chi>i. hom (v $h i)) $h i = 0 $h i) =\n    (\\<forall>i. v $h i = 0 $h i)", "by auto"], ["", "lemma (in inj_semiring_hom) map_vector_inj: \"(map_vector hom v = map_vector hom w) = (v = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_vector hom v = map_vector hom w) = (v = w)", "unfolding vec_eq_iff map_vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        (\\<chi>i. hom (v $h i)) $h i = (\\<chi>i. hom (w $h i)) $h i) =\n    (\\<forall>i. v $h i = w $h i)", "by auto"], ["", "lemma (in semiring_hom) matrix_vector_mult_hom:\n  \"(map_matrix hom A) *v (map_vector hom v) = map_vector hom (A *v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix hom A *v map_vector hom v =\n    map_vector hom (A *v v)", "by (transfer fixing: hom, auto simp: mult_mat_vec_hom)"], ["", "lemma (in semiring_hom) vector_smult_hom:\n  \"hom x *s (map_vector hom v) = map_vector hom (x *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom x *s map_vector hom v = map_vector hom (x *s v)", "by (transfer fixing: hom, auto simp: vec_hom_smult)"], ["", "lemma (in inj_comm_ring_hom) eigen_vector_hom: \n  \"eigen_vector (map_matrix hom A) (map_vector hom v) (hom x) = eigen_vector A v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector (HMA_Connect.map_matrix hom A) (map_vector hom v) (hom x) =\n    eigen_vector A v x", "unfolding eigen_vector_def matrix_vector_mult_hom vector_smult_hom map_vector_0 map_vector_inj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<noteq> 0 \\<and> A *v v = x *s v) =\n    (v \\<noteq> 0 \\<and> A *v v = x *s v)", "by auto"], ["", "end"]]}