{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Bij_Nat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma finite_set_to_list: \"\\<exists> xs :: 'a :: finite list. distinct xs \\<and> set xs = Y\"", "lemma univ_list: \"distinct (univ_list :: 'a list)\" \"set univ_list = (UNIV :: 'a :: finite set)\"", "lemma length_univ_list_card: \"length (univ_list :: 'a :: finite list) = CARD('a)\"", "lemma to_nat_ex: \"\\<exists>! i. univ_list ! i = (a :: 'a :: finite) \\<and> i < length (univ_list :: 'a list)\"", "lemma to_nat_less_card: \"to_nat (a :: 'a :: finite) < CARD('a)\"", "lemma to_nat_from_nat_id: \n  assumes i: \"i < CARD('a :: finite)\" \n  shows \"to_nat (from_nat i :: 'a) = i\"", "lemma from_nat_inj: assumes i: \"i < CARD('a :: finite)\"\n  and j: \"j < CARD('a :: finite)\"\n  and id: \"(from_nat i :: 'a) = from_nat j\"\n  shows \"i = j\"", "lemma from_nat_to_nat_id[simp]:\n  \"(from_nat (to_nat a)) = (a::'a :: finite)\"", "lemma to_nat_inj[simp]: assumes \"to_nat a = to_nat b\"\n  shows \"a = b\"", "lemma range_to_nat: \"range (to_nat :: 'a :: finite \\<Rightarrow> nat) = {0 ..< CARD('a)}\" (is \"?l = ?r\")", "lemma inj_to_nat: \"inj to_nat\"", "lemma bij_to_nat: \"bij_betw to_nat (UNIV :: 'a :: finite set) {0 ..< CARD('a)}\"", "lemma numeral_nat: \"(numeral m1 :: nat) * numeral n1 \\<equiv> numeral (m1 * n1)\" \n  \"(numeral m1 :: nat) + numeral n1 \\<equiv> numeral (m1 + n1)\"", "lemmas card_num_simps = \n  card_num1 card_bit0 card_bit1 \n  mult_num_simps\n  add_num_simps \n  eq_num_simps\n  mult_Suc_right mult_0_right One_nat_def add.right_neutral \n  numeral_nat Suc_numeral"], "translations": [["", "lemma finite_set_to_list: \"\\<exists> xs :: 'a :: finite list. distinct xs \\<and> set xs = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. distinct xs \\<and> set xs = Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs. distinct xs \\<and> set xs = Y", "have \"finite Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Y", "by simp"], ["proof (state)\nthis:\n  finite Y\n\ngoal (1 subgoal):\n 1. \\<exists>xs. distinct xs \\<and> set xs = Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. \\<exists>xs. distinct xs \\<and> set xs = Y", "proof (induct Y rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs. distinct xs \\<and> set xs = {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>xs. distinct xs \\<and> set xs = F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. distinct xs \\<and> set xs = insert x F", "case (insert y Y)"], ["proof (state)\nthis:\n  finite Y\n  y \\<notin> Y\n  \\<exists>xs. distinct xs \\<and> set xs = Y\n\ngoal (2 subgoals):\n 1. \\<exists>xs. distinct xs \\<and> set xs = {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>xs. distinct xs \\<and> set xs = F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. distinct xs \\<and> set xs = insert x F", "then"], ["proof (chain)\npicking this:\n  finite Y\n  y \\<notin> Y\n  \\<exists>xs. distinct xs \\<and> set xs = Y", "obtain xs where xs: \"distinct xs\" \"set xs = Y\""], ["proof (prove)\nusing this:\n  finite Y\n  y \\<notin> Y\n  \\<exists>xs. distinct xs \\<and> set xs = Y\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>distinct xs; set xs = Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  distinct xs\n  set xs = Y\n\ngoal (2 subgoals):\n 1. \\<exists>xs. distinct xs \\<and> set xs = {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>xs. distinct xs \\<and> set xs = F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. distinct xs \\<and> set xs = insert x F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. distinct xs \\<and> set xs = insert y Y", "by (rule exI[of _ \"y # xs\"], insert xs insert(2), auto)"], ["proof (state)\nthis:\n  \\<exists>xs. distinct xs \\<and> set xs = insert y Y\n\ngoal (1 subgoal):\n 1. \\<exists>xs. distinct xs \\<and> set xs = {}", "qed simp"], ["proof (state)\nthis:\n  \\<exists>xs. distinct xs \\<and> set xs = Y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition univ_list :: \"'a :: finite list\" where\n  \"univ_list = (SOME xs. distinct xs \\<and> set xs = UNIV)\""], ["", "lemma univ_list: \"distinct (univ_list :: 'a list)\" \"set univ_list = (UNIV :: 'a :: finite set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct univ_list &&& set univ_list = UNIV", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct univ_list\n 2. set univ_list = UNIV", "let ?xs = \"univ_list :: 'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. distinct univ_list\n 2. set univ_list = UNIV", "have \"distinct ?xs \\<and> set ?xs = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct univ_list \\<and> set univ_list = UNIV", "unfolding univ_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (SOME xs. distinct xs \\<and> set xs = UNIV) \\<and>\n    set (SOME xs. distinct xs \\<and> set xs = UNIV) = UNIV", "by (rule someI_ex, rule finite_set_to_list)"], ["proof (state)\nthis:\n  distinct univ_list \\<and> set univ_list = UNIV\n\ngoal (2 subgoals):\n 1. distinct univ_list\n 2. set univ_list = UNIV", "thus \"distinct ?xs\" \"set ?xs = UNIV\""], ["proof (prove)\nusing this:\n  distinct univ_list \\<and> set univ_list = UNIV\n\ngoal (1 subgoal):\n 1. distinct univ_list &&& set univ_list = UNIV", "by auto"], ["proof (state)\nthis:\n  distinct univ_list\n  set univ_list = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "definition to_nat :: \"'a :: finite \\<Rightarrow> nat\" where\n  \"to_nat a = (SOME i. univ_list ! i = a \\<and> i < length (univ_list :: 'a list))\""], ["", "definition from_nat :: \"nat \\<Rightarrow> 'a :: finite\" where\n  \"from_nat i = univ_list ! i\""], ["", "lemma length_univ_list_card: \"length (univ_list :: 'a :: finite list) = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length univ_list = CARD('a)", "using distinct_card[of \"univ_list :: 'a list\", symmetric]"], ["proof (prove)\nusing this:\n  distinct univ_list \\<Longrightarrow>\n  length univ_list = card (set univ_list)\n\ngoal (1 subgoal):\n 1. length univ_list = CARD('a)", "by (auto simp: univ_list)"], ["", "lemma to_nat_ex: \"\\<exists>! i. univ_list ! i = (a :: 'a :: finite) \\<and> i < length (univ_list :: 'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "let ?ul = \"univ_list :: 'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "have a_in_set: \"a \\<in> set ?ul\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set univ_list", "unfolding univ_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  a \\<in> set univ_list\n\ngoal (1 subgoal):\n 1. \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "from this [unfolded set_conv_nth]"], ["proof (chain)\npicking this:\n  a \\<in> {univ_list ! i |i. i < length univ_list}", "obtain i where i1: \"?ul ! i = a \\<and> i < length ?ul\""], ["proof (prove)\nusing this:\n  a \\<in> {univ_list ! i |i. i < length univ_list}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        univ_list ! i = a \\<and> i < length univ_list \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  univ_list ! i = a \\<and> i < length univ_list\n\ngoal (1 subgoal):\n 1. \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "proof (rule ex1I, rule i1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = a \\<and> ia < length univ_list \\<Longrightarrow>\n       ia = i", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = a \\<and> ia < length univ_list \\<Longrightarrow>\n       ia = i", "assume \"?ul ! j = a \\<and> j < length ?ul\""], ["proof (state)\nthis:\n  univ_list ! j = a \\<and> j < length univ_list\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = a \\<and> ia < length univ_list \\<Longrightarrow>\n       ia = i", "moreover"], ["proof (state)\nthis:\n  univ_list ! j = a \\<and> j < length univ_list\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = a \\<and> ia < length univ_list \\<Longrightarrow>\n       ia = i", "have \"distinct ?ul\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct univ_list", "by (simp add: univ_list)"], ["proof (state)\nthis:\n  distinct univ_list\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = a \\<and> ia < length univ_list \\<Longrightarrow>\n       ia = i", "ultimately"], ["proof (chain)\npicking this:\n  univ_list ! j = a \\<and> j < length univ_list\n  distinct univ_list", "show \"j = i\""], ["proof (prove)\nusing this:\n  univ_list ! j = a \\<and> j < length univ_list\n  distinct univ_list\n\ngoal (1 subgoal):\n 1. j = i", "using i1 nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  univ_list ! j = a \\<and> j < length univ_list\n  distinct univ_list\n  univ_list ! i = a \\<and> i < length univ_list\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. j = i", "by blast"], ["proof (state)\nthis:\n  j = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_less_card: \"to_nat (a :: 'a :: finite) < CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat a < CARD('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_nat a < CARD('a)", "let ?ul = \"univ_list :: 'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. to_nat a < CARD('a)", "from to_nat_ex[of a]"], ["proof (chain)\npicking this:\n  \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list", "obtain i where \n  i1: \"univ_list ! i = a \\<and> i<length (univ_list::'a list)\""], ["proof (prove)\nusing this:\n  \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        univ_list ! i = a \\<and> i < length univ_list \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  univ_list ! i = a \\<and> i < length univ_list\n\ngoal (1 subgoal):\n 1. to_nat a < CARD('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat a < CARD('a)", "unfolding to_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME i. univ_list ! i = a \\<and> i < length univ_list) < CARD('a)", "proof (rule someI2, rule i1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       univ_list ! x = a \\<and> x < length univ_list \\<Longrightarrow>\n       x < CARD('a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       univ_list ! x = a \\<and> x < length univ_list \\<Longrightarrow>\n       x < CARD('a)", "assume x: \"?ul ! x = a \\<and> x < length ?ul\""], ["proof (state)\nthis:\n  univ_list ! x = a \\<and> x < length univ_list\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       univ_list ! x = a \\<and> x < length univ_list \\<Longrightarrow>\n       x < CARD('a)", "thus \"x < CARD ('a)\""], ["proof (prove)\nusing this:\n  univ_list ! x = a \\<and> x < length univ_list\n\ngoal (1 subgoal):\n 1. x < CARD('a)", "using x"], ["proof (prove)\nusing this:\n  univ_list ! x = a \\<and> x < length univ_list\n  univ_list ! x = a \\<and> x < length univ_list\n\ngoal (1 subgoal):\n 1. x < CARD('a)", "by (simp add: univ_list length_univ_list_card)"], ["proof (state)\nthis:\n  x < CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  to_nat a < CARD('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_from_nat_id: \n  assumes i: \"i < CARD('a :: finite)\" \n  shows \"to_nat (from_nat i :: 'a) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat (from_nat i) = i", "unfolding to_nat_def from_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME ia. univ_list ! ia = univ_list ! i \\<and> ia < length univ_list) =\n    i", "proof (rule some_equality, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length univ_list\n 2. \\<And>ia.\n       univ_list ! ia = univ_list ! i \\<and>\n       ia < length univ_list \\<Longrightarrow>\n       ia = i", "have l: \"length (univ_list::'a list) = card (set (univ_list::'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length univ_list = card (set univ_list)", "by (rule distinct_card[symmetric], simp add: univ_list)"], ["proof (state)\nthis:\n  length univ_list = card (set univ_list)\n\ngoal (2 subgoals):\n 1. i < length univ_list\n 2. \\<And>ia.\n       univ_list ! ia = univ_list ! i \\<and>\n       ia < length univ_list \\<Longrightarrow>\n       ia = i", "thus i2: \"i < length (univ_list::'a list)\""], ["proof (prove)\nusing this:\n  length univ_list = card (set univ_list)\n\ngoal (1 subgoal):\n 1. i < length univ_list", "using i"], ["proof (prove)\nusing this:\n  length univ_list = card (set univ_list)\n  i < CARD('a)\n\ngoal (1 subgoal):\n 1. i < length univ_list", "unfolding univ_list"], ["proof (prove)\nusing this:\n  length univ_list = CARD('a)\n  i < CARD('a)\n\ngoal (1 subgoal):\n 1. i < length univ_list", "by simp"], ["proof (state)\nthis:\n  i < length univ_list\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = univ_list ! i \\<and>\n       ia < length univ_list \\<Longrightarrow>\n       ia = i", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = univ_list ! i \\<and>\n       ia < length univ_list \\<Longrightarrow>\n       ia = i", "assume n: \"(univ_list::'a list) ! n = (univ_list::'a list) ! i \\<and> n < length (univ_list::'a list)\""], ["proof (state)\nthis:\n  univ_list ! n = univ_list ! i \\<and> n < length univ_list\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = univ_list ! i \\<and>\n       ia < length univ_list \\<Longrightarrow>\n       ia = i", "have d: \"distinct (univ_list::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct univ_list", "using univ_list"], ["proof (prove)\nusing this:\n  distinct univ_list\n  set univ_list = UNIV\n\ngoal (1 subgoal):\n 1. distinct univ_list", "by simp"], ["proof (state)\nthis:\n  distinct univ_list\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       univ_list ! ia = univ_list ! i \\<and>\n       ia < length univ_list \\<Longrightarrow>\n       ia = i", "show \"n = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = i", "using nth_eq_iff_index_eq[OF d _ i2] n"], ["proof (prove)\nusing this:\n  ?i < length univ_list \\<Longrightarrow>\n  (univ_list ! ?i = univ_list ! i) = (?i = i)\n  univ_list ! n = univ_list ! i \\<and> n < length univ_list\n\ngoal (1 subgoal):\n 1. n = i", "by auto"], ["proof (state)\nthis:\n  n = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_inj: assumes i: \"i < CARD('a :: finite)\"\n  and j: \"j < CARD('a :: finite)\"\n  and id: \"(from_nat i :: 'a) = from_nat j\"\n  shows \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "from arg_cong[OF id, of to_nat]"], ["proof (chain)\npicking this:\n  to_nat (from_nat i) = to_nat (from_nat j)", "show ?thesis"], ["proof (prove)\nusing this:\n  to_nat (from_nat i) = to_nat (from_nat j)\n\ngoal (1 subgoal):\n 1. i = j", "using i j"], ["proof (prove)\nusing this:\n  to_nat (from_nat i) = to_nat (from_nat j)\n  i < CARD('a)\n  j < CARD('a)\n\ngoal (1 subgoal):\n 1. i = j", "by (simp add: to_nat_from_nat_id)"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_to_nat_id[simp]:\n  \"(from_nat (to_nat a)) = (a::'a :: finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_nat (to_nat a) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. from_nat (to_nat a) = a", "have a_in_set: \"a \\<in> set (univ_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set univ_list", "unfolding univ_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  a \\<in> set univ_list\n\ngoal (1 subgoal):\n 1. from_nat (to_nat a) = a", "from this [unfolded set_conv_nth]"], ["proof (chain)\npicking this:\n  a \\<in> {univ_list ! i |i. i < length univ_list}", "obtain i where i1: \"univ_list ! i = a \\<and> i<length (univ_list::'a list)\""], ["proof (prove)\nusing this:\n  a \\<in> {univ_list ! i |i. i < length univ_list}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        univ_list ! i = a \\<and> i < length univ_list \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  univ_list ! i = a \\<and> i < length univ_list\n\ngoal (1 subgoal):\n 1. from_nat (to_nat a) = a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_nat (to_nat a) = a", "unfolding to_nat_def from_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. univ_list ! (SOME i. univ_list ! i = a \\<and> i < length univ_list) = a", "by (rule someI2, rule i1, simp)"], ["proof (state)\nthis:\n  from_nat (to_nat a) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_nat_inj[simp]: assumes \"to_nat a = to_nat b\"\n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b", "from to_nat_ex[of a] to_nat_ex[of b]"], ["proof (chain)\npicking this:\n  \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list\n  \\<exists>!i. univ_list ! i = b \\<and> i < length univ_list", "show \"a = b\""], ["proof (prove)\nusing this:\n  \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list\n  \\<exists>!i. univ_list ! i = b \\<and> i < length univ_list\n\ngoal (1 subgoal):\n 1. a = b", "unfolding to_nat_def"], ["proof (prove)\nusing this:\n  \\<exists>!i. univ_list ! i = a \\<and> i < length univ_list\n  \\<exists>!i. univ_list ! i = b \\<and> i < length univ_list\n\ngoal (1 subgoal):\n 1. a = b", "by (metis assms from_nat_to_nat_id)"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma range_to_nat: \"range (to_nat :: 'a :: finite \\<Rightarrow> nat) = {0 ..< CARD('a)}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "assume \"i \\<in> ?l\""], ["proof (state)\nthis:\n  i \\<in> range to_nat\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "hence \"i \\<in> ?r\""], ["proof (prove)\nusing this:\n  i \\<in> range to_nat\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<CARD('a)}", "using to_nat_less_card[where 'a = 'a]"], ["proof (prove)\nusing this:\n  i \\<in> range to_nat\n  to_nat ?a < CARD('a)\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<CARD('a)}", "by auto"], ["proof (state)\nthis:\n  i \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> range to_nat \\<Longrightarrow> ?i2 \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "moreover"], ["proof (state)\nthis:\n  ?i2 \\<in> range to_nat \\<Longrightarrow> ?i2 \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "{"], ["proof (state)\nthis:\n  ?i2 \\<in> range to_nat \\<Longrightarrow> ?i2 \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "assume \"i \\<in> ?r\""], ["proof (state)\nthis:\n  i \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "hence \"i < CARD('a)\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. i < CARD('a)", "by auto"], ["proof (state)\nthis:\n  i < CARD('a)\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "from to_nat_from_nat_id[OF this]"], ["proof (chain)\npicking this:\n  to_nat (from_nat i) = i", "have \"i \\<in> ?l\""], ["proof (prove)\nusing this:\n  to_nat (from_nat i) = i\n\ngoal (1 subgoal):\n 1. i \\<in> range to_nat", "by (metis range_eqI)"], ["proof (state)\nthis:\n  i \\<in> range to_nat\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> {0..<CARD('a)} \\<Longrightarrow> ?i2 \\<in> range to_nat\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "ultimately"], ["proof (chain)\npicking this:\n  ?i2 \\<in> range to_nat \\<Longrightarrow> ?i2 \\<in> {0..<CARD('a)}\n  ?i2 \\<in> {0..<CARD('a)} \\<Longrightarrow> ?i2 \\<in> range to_nat", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i2 \\<in> range to_nat \\<Longrightarrow> ?i2 \\<in> {0..<CARD('a)}\n  ?i2 \\<in> {0..<CARD('a)} \\<Longrightarrow> ?i2 \\<in> range to_nat\n\ngoal (1 subgoal):\n 1. range to_nat = {0..<CARD('a)}", "by auto"], ["proof (state)\nthis:\n  range to_nat = {0..<CARD('a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_to_nat: \"inj to_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj to_nat", "by (simp add: inj_on_def)"], ["", "lemma bij_to_nat: \"bij_betw to_nat (UNIV :: 'a :: finite set) {0 ..< CARD('a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw to_nat UNIV {0..<CARD('a)}", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj to_nat \\<and> range to_nat = {0..<CARD('a)}", "by (auto simp: range_to_nat inj_to_nat)"], ["", "lemma numeral_nat: \"(numeral m1 :: nat) * numeral n1 \\<equiv> numeral (m1 * n1)\" \n  \"(numeral m1 :: nat) + numeral n1 \\<equiv> numeral (m1 + n1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral m1 * numeral n1 \\<equiv> numeral (m1 * n1)) &&&\n    numeral m1 + numeral n1 \\<equiv> numeral (m1 + n1)", "by simp_all"], ["", "lemmas card_num_simps = \n  card_num1 card_bit0 card_bit1 \n  mult_num_simps\n  add_num_simps \n  eq_num_simps\n  mult_Suc_right mult_0_right One_nat_def add.right_neutral \n  numeral_nat Suc_numeral"], ["", "end"]]}