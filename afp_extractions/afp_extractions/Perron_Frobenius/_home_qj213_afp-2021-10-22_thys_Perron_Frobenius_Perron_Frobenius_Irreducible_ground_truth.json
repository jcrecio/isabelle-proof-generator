{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Perron_Frobenius_Irreducible.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma charpoly_of_real: \"charpoly (map_matrix complex_of_real A) = map_poly of_real (charpoly A)\"", "lemma HMA_M_smult[transfer_rule]: \"((=) ===> HMA_M ===> HMA_M) (\\<cdot>\\<^sub>m) ((*k))\"", "lemma order_charpoly_smult: fixes A :: \"complex ^ 'n ^ 'n\" \n  assumes k: \"k \\<noteq> 0\" \n  shows \"order x (charpoly (k *k A)) = order (x / k) (charpoly A)\"", "lemma smult_eigen_vector: fixes a :: \"'a :: field\"  \n  assumes \"eigen_vector A v x\" \n  shows \"eigen_vector (a *k A) v (a * x)\"", "lemma smult_eigen_value: fixes a :: \"'a :: field\"  \n  assumes \"eigen_value A x\" \n  shows \"eigen_value (a *k A) (a * x)\"", "lemma G_transpose: \n  \"fixed_mat.G (transpose A) = ((fixed_mat.G A))^-1\"", "lemma G_transpose_trancl: \n  \"(fixed_mat.G (transpose A))^+ = ((fixed_mat.G A)^+)^-1\"", "lemma nonneg: \"A $ i $ j \\<ge> 0\"", "lemma nonneg_matpow: \"matpow A n $ i $ j \\<ge> 0\"", "lemma G_relpow_matpow_pos: \"(i,j) \\<in> G ^^ n \\<Longrightarrow> matpow A n $ i $ j > 0\"", "lemma matpow_mono: assumes B: \"\\<And> i j. B $ i $ j \\<ge> A $ i $ j\"\n  shows \"matpow B n $ i $ j \\<ge> matpow A n $ i $ j\"", "lemma matpow_sum_one_mono: \"matpow (A + mat 1) (n + k) $ i $ j \\<ge> matpow (A + mat 1) n $ i $ j\"", "lemma G_relpow_matpow_pos_ge: \n  assumes \"(i,j) \\<in> G ^^ m\" \"n \\<ge> m\"\n  shows \"matpow (A + mat 1) n $ i $ j > 0\"", "lemma N: \"\\<exists> n \\<le> N. ij \\<in> G ^^ n\"", "lemma irreducible_matpow_pos: assumes irreducible \n  shows \"matpow (A + mat 1) N $ i $ j > 0\"", "lemma pf_transpose: \"perron_frobenius (transpose A)\"", "lemmas A1n_pos = irreducible_matpow_pos[OF irr, folded A1n_def]", "lemma nonneg_Ax: \"x \\<in> X \\<Longrightarrow> le_vec 0 (A *v x)\"", "lemma A_nonzero_fixed_i: \"\\<exists> j. A $ i $ j \\<noteq> 0\"", "lemma A_nonzero_fixed_j: \"\\<exists> i. A $ i $ j \\<noteq> 0\"", "lemma Ax_pos: assumes x: \"lt_vec 0 x\" \n  shows \"lt_vec 0 (A *v x)\"", "lemma nonzero_Ax: assumes x: \"x \\<in> X\"\n  shows \"A *v x \\<noteq> 0\"", "lemma r_witness: assumes x: \"x \\<in> X\" \n  shows \"\\<exists> j. x $ j > 0 \\<and> r x = (A *v x) $ j / x $ j\"", "lemma rx_nonneg: assumes x: \"x \\<in> X\"\n  shows \"r x \\<ge> 0\"", "lemma rx_pos: assumes x: \"lt_vec 0 x\"\n  shows \"r x > 0\"", "lemma rx_le_Ax: assumes x: \"x \\<in> X\" \n  shows \"le_vec (r x *s x) (A *v x)\"", "lemma rho_le_x_Ax_imp_rho_le_rx: assumes x: \"x \\<in> X\"\n  and \\<rho>: \"le_vec (\\<rho> *s x) (A *v x)\"\nshows \"\\<rho> \\<le> r x\"", "lemma rx_Max: assumes x: \"x \\<in> X\"\n  shows \"r x = Sup { \\<rho> . le_vec (\\<rho> *s x) (A *v x) }\" (is \"_ = Sup ?S\")", "lemma r_smult: assumes x: \"x \\<in> X\" \n  and a: \"a > 0\" \nshows \"r (a *s x) = r x\"", "lemma bounded_X1: \"bounded X1\"", "lemma closed_X1: \"closed X1\"", "lemma compact_X1: \"compact X1\"", "lemma continuous_pow_A_1: \"continuous_on R pow_A_1\"", "lemma compact_Y: \"compact Y\"", "lemma Y_pos_main: assumes y: \"y \\<in> pow_A_1 ` X\" \n  shows \"y $ i > 0\"", "lemma Y_pos: assumes y: \"y \\<in> Y\" \n  shows \"y $ i > 0\"", "lemma Y_nonzero: assumes y: \"y \\<in> Y\" \n  shows \"y $ i \\<noteq> 0\"", "lemma r'_r: assumes x: \"x \\<in> Y\" shows \"r' x = r x\"", "lemma continuous_Y_r: \"continuous_on Y r\"", "lemma X1_nonempty: \"X1 \\<noteq> {}\"", "lemma Y_nonempty: \"Y \\<noteq> {}\"", "lemma z: \"z \\<in> Y\" and sr_max_Y: \"\\<And> y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr\"", "lemma Y_subset_X: \"Y \\<subseteq> X\"", "lemma zX: \"z \\<in> X\"", "lemma le_vec_mono_left: assumes B: \"\\<And> i j. B $ i $ j \\<ge> 0\" \n  and \"le_vec x y\" \nshows \"le_vec (B *v x) (B *v y)\"", "lemma matpow_1_commute: \"matpow (A + mat 1) n ** A = A ** matpow (A + mat 1) n\"", "lemma A1n_commute: \"A1n ** A = A ** A1n\"", "lemma le_vec_pow_A_1: assumes le: \"le_vec (rho *s x) (A *v x)\" \n  shows \"le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)\"", "lemma r_pow_A_1: assumes x: \"x \\<in> X\"\n  shows \"r x \\<le> r (pow_A_1 x)\"", "lemma sr_max: assumes x: \"x \\<in> X\" \n  shows \"r x \\<le> sr\"", "lemma z_pos: \"z $ i > 0\"", "lemma sr_pos: \"sr > 0\"", "lemma sr_imp_eigen_vector_main: \"sr *s u = A *v u\"", "lemma sr_imp_eigen_vector: \"eigen_vector A u sr\"", "lemma sr_u_pos: \"lt_vec 0 u\"", "lemma eigen_vector_z_sr: \"eigen_vector A z sr\"", "lemma eigen_value_sr: \"eigen_value A sr\"", "lemma norm_v_ge_0: \"le_vec 0 (norm_v v)\"", "lemma norm_v_eq_0: \"norm_v v = 0 \\<longleftrightarrow> v = 0\"", "lemma cA_index: \"cA $ i $ j = c (A $ i $ j)\"", "lemma norm_cA[simp]: \"norm (cA $ i $ j) = A $ i $ j\"", "lemma evD: \"\\<alpha> *s v = cA *v v\" \"v \\<noteq> 0\"", "lemma ev_alpha_norm_v: \"norm_v (\\<alpha> *s v) = (norm \\<alpha> *s norm_v v)\"", "lemma ev_A_norm_v: \"norm_v (cA *v v) $ j \\<le> (A *v norm_v v) $ j\"", "lemma ev_le_vec: \"le_vec (norm \\<alpha> *s norm_v v) (A *v norm_v v)\"", "lemma norm_v_X: \"norm_v v \\<in> X\"", "lemma ev_inequalities: \"norm \\<alpha> \\<le> r (norm_v v)\" \"r (norm_v v) \\<le> sr\"", "lemma eigen_vector_norm_sr: \"norm \\<alpha> \\<le> sr\"", "lemma eigen_value_norm_sr: assumes \"eigen_value cA \\<alpha>\" \n  shows \"norm \\<alpha> \\<le> sr\"", "lemma le_vec_trans: \"le_vec x y \\<Longrightarrow> le_vec y u \\<Longrightarrow> le_vec x u\"", "lemma eigen_vector_z_sr_c: \"eigen_vector cA (map_vector c z) (c sr)\"", "lemma eigen_value_sr_c: \"eigen_value cA (c sr)\"", "lemma w: \"transpose A *v w = sr *s w\" \"lt_vec 0 w\" \"perron_frobenius.sr (transpose A) = sr\"", "lemma c_cmod_id: \"a \\<in> \\<real> \\<Longrightarrow> Re a \\<ge> 0 \\<Longrightarrow> c (cmod a) = a\"", "lemma pos_rowvector_mult_0: assumes lt: \"lt_vec 0 x\" \n  and 0: \"(rowvector x :: real ^ 'n ^ 'n) *v y = 0\" (is \"?x *v _ = 0\") and le: \"le_vec 0 y\" \nshows \"y = 0\"", "lemma pos_matrix_mult_0: assumes le: \"\\<And> i j. B $ i $ j \\<ge> 0\" \n  and lt: \"lt_vec 0 x\" \n  and 0: \"B *v x = 0\" \nshows \"B = 0\"", "lemma eigen_value_smaller_matrix: assumes B: \"\\<And> i j. 0 \\<le> B $ i $ j \\<and> B $ i $ j \\<le> A $ i $ j\"\n  and AB: \"A \\<noteq> B\" \n  and ev: \"eigen_value (map_matrix c B) sigma\"\nshows \"cmod sigma < sr\"", "lemma charpoly_erase_mat_sr: \"0 < poly (charpoly (erase_mat A i i)) sr\"", "lemma multiplicity_sr_1: \"order sr (charpoly A) = 1\"", "lemma sr_spectral_radius: \"sr = spectral_radius cA\"", "lemma le_vec_A_mu: assumes y: \"y \\<in> X\" and le: \"le_vec (A *v y) (mu *s y)\" \n  shows \"sr \\<le> mu\" \"lt_vec 0 y\" \n  \"mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow> mu = sr \\<and> A *v y = mu *s y\"", "lemma nonnegative_eigenvector_has_ev_sr: assumes \"eigen_vector A v mu\" and le: \"le_vec 0 v\" \n  shows \"mu = sr\"", "lemma similar_matrix_rotation: assumes ev: \"eigen_value cA \\<alpha>\" and \\<alpha>: \"cmod \\<alpha> = sr\"\n  shows \"similar_matrix (cis (arg \\<alpha>) *k cA) cA\"", "lemma assumes ev: \"eigen_value cA \\<alpha>\" and \\<alpha>: \"cmod \\<alpha> = sr\"\n  shows maximal_eigen_value_order_1: \"order \\<alpha> (charpoly cA) = 1\" \n    and maximal_eigen_value_rotation: \"eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\"\n      \"eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x\"", "lemma maximal_eigen_values_group: assumes M: \"M = {ev :: complex. eigen_value cA ev \\<and> cmod ev = sr}\"\n  and a: \"rcis sr \\<alpha> \\<in> M\" \n  and b: \"rcis sr \\<beta> \\<in> M\" \nshows \"rcis sr (\\<alpha> + \\<beta>) \\<in> M\" \"rcis sr (\\<alpha> - \\<beta>) \\<in> M\" \"rcis sr 0 \\<in> M\"", "lemma maximal_eigen_value_roots_of_unity_rotation: \n  assumes M: \"M = {ev :: complex. eigen_value cA ev \\<and> cmod ev = sr}\" \n   and kM: \"k = card M\" \n shows \"k \\<noteq> 0\" \n    \"k \\<le> CARD('n)\"\n    \"\\<exists> f. charpoly A = (monom 1 k - [:sr^k:]) * f \n       \\<and> (\\<forall> x. poly (map_poly c f) x = 0 \\<longrightarrow> cmod x < sr)\"\n    \"M = (*) (c sr) ` (\\<lambda> i. (cis (of_nat i * 2 * pi / k))) ` {0 ..< k}\"\n    \"M = (*) (c sr) ` { x :: complex. x ^ k = 1}\"\n    \"(*) (cis (2 * pi / k)) ` Spectrum cA = Spectrum cA\"", "lemmas pf_main =\n  eigen_value_sr eigen_vector_z_sr (* sr is eigenvalue *)\n  eigen_value_norm_sr  (* it is maximal among all complex eigenvalues *)\n  z_pos    (* it's eigenvector is positive *)\n  multiplicity_sr_1 (* the algebr. multiplicity is 1 *)\n  nonnegative_eigenvector_has_ev_sr (* every non-negative real eigenvector has sr as eigenvalue *)\n  maximal_eigen_value_order_1 (* all maximal eigenvalues have order 1 *)\n  maximal_eigen_value_roots_of_unity_rotation", "lemmas pf_main_connect = pf_main(1,3,5,7,8-10)[unfolded sr_spectral_radius] \n  sr_pos[unfolded sr_spectral_radius]"], "translations": [["", "lemma charpoly_of_real: \"charpoly (map_matrix complex_of_real A) = map_poly of_real (charpoly A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. charpoly (HMA_Connect.map_matrix complex_of_real A) =\n    map_poly complex_of_real (charpoly A)", "by (transfer_hma rule: of_real_hom.char_poly_hom)"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma HMA_M_smult[transfer_rule]: \"((=) ===> HMA_M ===> HMA_M) (\\<cdot>\\<^sub>m) ((*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M ===> HMA_M) (\\<cdot>\\<^sub>m) (*k)", "unfolding smult_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M ===> HMA_M) (\\<lambda>a. map_mat ((*) a)) (*k)", "unfolding rel_fun_def HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa =\n           Matrix.mat CARD('c) CARD('b)\n            (\\<lambda>(i, j).\n                ya $h Bij_Nat.from_nat i $h\n                Bij_Nat.from_nat j) \\<longrightarrow>\n           map_mat ((*) x) xa =\n           Matrix.mat CARD('c) CARD('b)\n            (\\<lambda>(i, j).\n                (y *k ya) $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j))", "by (auto simp: matrix_scalar_mult_def)"], ["", "end"], ["", "lemma order_charpoly_smult: fixes A :: \"complex ^ 'n ^ 'n\" \n  assumes k: \"k \\<noteq> 0\" \n  shows \"order x (charpoly (k *k A)) = order (x / k) (charpoly A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (charpoly (k *k A)) = order (x / k) (charpoly A)", "by (transfer fixing: k, rule order_char_poly_smult[OF _ k])"], ["", "(* use field, since the *k-lemmas have been stated for fields *)"], ["", "lemma smult_eigen_vector: fixes a :: \"'a :: field\"  \n  assumes \"eigen_vector A v x\" \n  shows \"eigen_vector (a *k A) v (a * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector (a *k A) v (a * x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigen_vector (a *k A) v (a * x)", "from assms[unfolded eigen_vector_def]"], ["proof (chain)\npicking this:\n  v \\<noteq> 0 \\<and> A *v v = x *s v", "have v: \"v \\<noteq> 0\" and id: \"A *v v = x *s v\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0 \\<and> A *v v = x *s v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 &&& A *v v = x *s v", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\n  A *v v = x *s v\n\ngoal (1 subgoal):\n 1. eigen_vector (a *k A) v (a * x)", "from arg_cong[OF id, of \"(*s) a\"]"], ["proof (chain)\npicking this:\n  a *s (A *v v) = a *s (x *s v)", "have id: \"(a *k A) *v v = (a * x) *s v\""], ["proof (prove)\nusing this:\n  a *s (A *v v) = a *s (x *s v)\n\ngoal (1 subgoal):\n 1. a *k A *v v = a * x *s v", "unfolding scalar_matrix_vector_assoc"], ["proof (prove)\nusing this:\n  a *k A *v v = a *s (x *s v)\n\ngoal (1 subgoal):\n 1. a *k A *v v = a * x *s v", "by simp"], ["proof (state)\nthis:\n  a *k A *v v = a * x *s v\n\ngoal (1 subgoal):\n 1. eigen_vector (a *k A) v (a * x)", "thus \"eigen_vector (a *k A) v (a * x)\""], ["proof (prove)\nusing this:\n  a *k A *v v = a * x *s v\n\ngoal (1 subgoal):\n 1. eigen_vector (a *k A) v (a * x)", "using v"], ["proof (prove)\nusing this:\n  a *k A *v v = a * x *s v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eigen_vector (a *k A) v (a * x)", "unfolding eigen_vector_def"], ["proof (prove)\nusing this:\n  a *k A *v v = a * x *s v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 \\<and> a *k A *v v = a * x *s v", "by auto"], ["proof (state)\nthis:\n  eigen_vector (a *k A) v (a * x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_eigen_value: fixes a :: \"'a :: field\"  \n  assumes \"eigen_value A x\" \n  shows \"eigen_value (a *k A) (a * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value (a *k A) (a * x)", "using assms smult_eigen_vector[of A _ x a]"], ["proof (prove)\nusing this:\n  eigen_value A x\n  eigen_vector A ?v x \\<Longrightarrow> eigen_vector (a *k A) ?v (a * x)\n\ngoal (1 subgoal):\n 1. eigen_value (a *k A) (a * x)", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  \\<exists>v. eigen_vector A v x\n  eigen_vector A ?v x \\<Longrightarrow> eigen_vector (a *k A) ?v (a * x)\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigen_vector (a *k A) v (a * x)", "by blast"], ["", "locale fixed_mat = fixes A :: \"'a :: zero ^ 'n ^ 'n\"\nbegin"], ["", "definition G :: \"'n rel\" where\n  \"G = { (i,j). A $ i $ j \\<noteq> 0}\""], ["", "definition irreducible :: bool where\n  \"irreducible = (UNIV \\<subseteq> G^+)\""], ["", "end"], ["", "lemma G_transpose: \n  \"fixed_mat.G (transpose A) = ((fixed_mat.G A))^-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_mat.G (Finite_Cartesian_Product.transpose A) =\n    (fixed_mat.G A)\\<inverse>", "unfolding fixed_mat.G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, j).\n     Finite_Cartesian_Product.transpose A $h i $h j \\<noteq> (0::'b)} =\n    {(i, j). A $h i $h j \\<noteq> (0::'b)}\\<inverse>", "by (force simp: transpose_def)"], ["", "lemma G_transpose_trancl: \n  \"(fixed_mat.G (transpose A))^+ = ((fixed_mat.G A)^+)^-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fixed_mat.G (Finite_Cartesian_Product.transpose A))\\<^sup>+ =\n    ((fixed_mat.G A)\\<^sup>+)\\<inverse>", "unfolding G_transpose trancl_converse"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fixed_mat.G A)\\<^sup>+)\\<inverse> =\n    ((fixed_mat.G A)\\<^sup>+)\\<inverse>", "by auto"], ["", "locale pf_nonneg_mat = fixed_mat A for \n  A :: \"'a :: linordered_idom ^ 'n ^ 'n\" + \n  assumes non_neg_mat: \"non_neg_mat A\"  \nbegin"], ["", "lemma nonneg: \"A $ i $ j \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> A $h i $h j", "using non_neg_mat"], ["proof (prove)\nusing this:\n  non_neg_mat A\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> A $h i $h j", "unfolding non_neg_mat_def elements_mat_h_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>range (\\<lambda>(i, y). A $h i $h y). (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> A $h i $h j", "by auto"], ["", "lemma nonneg_matpow: \"matpow A n $ i $ j \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> matpow A n $h i $h j", "by (induct n arbitrary: i j, insert nonneg, \n    auto intro!: sum_nonneg simp: matrix_matrix_mult_def mat_def)"], ["", "lemma G_relpow_matpow_pos: \"(i,j) \\<in> G ^^ n \\<Longrightarrow> matpow A n $ i $ j > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j) \\<in> G ^^ n \\<Longrightarrow> (0::'a) < matpow A n $h i $h j", "proof (induct n arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       (i, j) \\<in> G ^^ 0 \\<Longrightarrow> (0::'a) < matpow A 0 $h i $h j\n 2. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "case (0 i)"], ["proof (state)\nthis:\n  (i, j) \\<in> G ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       (i, j) \\<in> G ^^ 0 \\<Longrightarrow> (0::'a) < matpow A 0 $h i $h j\n 2. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "thus ?case"], ["proof (prove)\nusing this:\n  (i, j) \\<in> G ^^ 0\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow A 0 $h i $h j", "by (auto simp: mat_def)"], ["proof (state)\nthis:\n  (0::'a) < matpow A 0 $h i $h j\n\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "case (Suc n i j)"], ["proof (state)\nthis:\n  (?i, ?j) \\<in> G ^^ n \\<Longrightarrow> (0::'a) < matpow A n $h ?i $h ?j\n  (i, j) \\<in> G ^^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "from Suc(2)"], ["proof (chain)\npicking this:\n  (i, j) \\<in> G ^^ Suc n", "have \"(i,j) \\<in> G ^^ n O G\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> G ^^ Suc n\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> G ^^ n O G", "by (simp add: relpow_commute)"], ["proof (state)\nthis:\n  (i, j) \\<in> G ^^ n O G\n\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "then"], ["proof (chain)\npicking this:\n  (i, j) \\<in> G ^^ n O G", "obtain k where\n    ik: \"A $ k $ j \\<noteq> 0\" and kj: \"(i, k) \\<in> G ^^ n\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> G ^^ n O G\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>A $h k $h j \\<noteq> (0::'a); (i, k) \\<in> G ^^ n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: G_def)"], ["proof (state)\nthis:\n  A $h k $h j \\<noteq> (0::'a)\n  (i, k) \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "from ik nonneg[of k j]"], ["proof (chain)\npicking this:\n  A $h k $h j \\<noteq> (0::'a)\n  (0::'a) \\<le> A $h k $h j", "have ik: \"A $ k $ j > 0\""], ["proof (prove)\nusing this:\n  A $h k $h j \\<noteq> (0::'a)\n  (0::'a) \\<le> A $h k $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < A $h k $h j", "by auto"], ["proof (state)\nthis:\n  (0::'a) < A $h k $h j\n\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "from Suc(1)[OF kj]"], ["proof (chain)\npicking this:\n  (0::'a) < matpow A n $h i $h k", "have IH: \"matpow A n $h i $h k > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < matpow A n $h i $h k\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow A n $h i $h k", "."], ["proof (state)\nthis:\n  (0::'a) < matpow A n $h i $h k\n\ngoal (1 subgoal):\n 1. \\<And>n i j.\n       \\<lbrakk>\\<And>i j.\n                   (i, j) \\<in> G ^^ n \\<Longrightarrow>\n                   (0::'a) < matpow A n $h i $h j;\n        (i, j) \\<in> G ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> (0::'a) < matpow A (Suc n) $h i $h j", "thus ?case"], ["proof (prove)\nusing this:\n  (0::'a) < matpow A n $h i $h k\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow A (Suc n) $h i $h j", "using ik"], ["proof (prove)\nusing this:\n  (0::'a) < matpow A n $h i $h k\n  (0::'a) < A $h k $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow A (Suc n) $h i $h j", "by (auto simp: nonneg_matpow nonneg matrix_matrix_mult_def \n    intro!: sum_pos2[of _ k] mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  (0::'a) < matpow A (Suc n) $h i $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matpow_mono: assumes B: \"\\<And> i j. B $ i $ j \\<ge> A $ i $ j\"\n  shows \"matpow B n $ i $ j \\<ge> matpow A n $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow A n $h i $h j \\<le> matpow B n $h i $h j", "proof (induct n arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j. matpow A 0 $h i $h j \\<le> matpow B 0 $h i $h j\n 2. \\<And>n i j.\n       (\\<And>i j.\n           matpow A n $h i $h j\n           \\<le> matpow B n $h i $h j) \\<Longrightarrow>\n       matpow A (Suc n) $h i $h j \\<le> matpow B (Suc n) $h i $h j", "case (Suc n i j)"], ["proof (state)\nthis:\n  matpow A n $h ?i $h ?j \\<le> matpow B n $h ?i $h ?j\n\ngoal (2 subgoals):\n 1. \\<And>i j. matpow A 0 $h i $h j \\<le> matpow B 0 $h i $h j\n 2. \\<And>n i j.\n       (\\<And>i j.\n           matpow A n $h i $h j\n           \\<le> matpow B n $h i $h j) \\<Longrightarrow>\n       matpow A (Suc n) $h i $h j \\<le> matpow B (Suc n) $h i $h j", "thus ?case"], ["proof (prove)\nusing this:\n  matpow A n $h ?i $h ?j \\<le> matpow B n $h ?i $h ?j\n\ngoal (1 subgoal):\n 1. matpow A (Suc n) $h i $h j \\<le> matpow B (Suc n) $h i $h j", "using B nonneg_matpow[of n] nonneg"], ["proof (prove)\nusing this:\n  matpow A n $h ?i $h ?j \\<le> matpow B n $h ?i $h ?j\n  A $h ?i $h ?j \\<le> B $h ?i $h ?j\n  (0::'a) \\<le> matpow A n $h ?i $h ?j\n  (0::'a) \\<le> A $h ?i $h ?j\n\ngoal (1 subgoal):\n 1. matpow A (Suc n) $h i $h j \\<le> matpow B (Suc n) $h i $h j", "by (auto simp: matrix_matrix_mult_def intro!: sum_mono mult_mono')"], ["proof (state)\nthis:\n  matpow A (Suc n) $h i $h j \\<le> matpow B (Suc n) $h i $h j\n\ngoal (1 subgoal):\n 1. \\<And>i j. matpow A 0 $h i $h j \\<le> matpow B 0 $h i $h j", "qed simp"], ["", "lemma matpow_sum_one_mono: \"matpow (A + mat 1) (n + k) $ i $ j \\<ge> matpow (A + mat 1) n $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + k) $h i $h j", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + 0) $h i $h j\n 2. \\<And>k.\n       matpow (A + mat (1::'a)) n $h i $h j\n       \\<le> matpow (A + mat (1::'a)) (n + k) $h i $h j \\<Longrightarrow>\n       matpow (A + mat (1::'a)) n $h i $h j\n       \\<le> matpow (A + mat (1::'a)) (n + Suc k) $h i $h j", "case (Suc k)"], ["proof (state)\nthis:\n  matpow (A + mat (1::'a)) n $h i $h j\n  \\<le> matpow (A + mat (1::'a)) (n + k) $h i $h j\n\ngoal (2 subgoals):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + 0) $h i $h j\n 2. \\<And>k.\n       matpow (A + mat (1::'a)) n $h i $h j\n       \\<le> matpow (A + mat (1::'a)) (n + k) $h i $h j \\<Longrightarrow>\n       matpow (A + mat (1::'a)) n $h i $h j\n       \\<le> matpow (A + mat (1::'a)) (n + Suc k) $h i $h j", "have \"(matpow (A + mat 1) (n + k) ** A) $h i $h j \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (matpow (A + mat (1::'a)) (n + k) ** A) $h i $h j", "unfolding matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a)\n    \\<le> (\\<chi>i j.\n              \\<Sum>k\\<in>UNIV.\n                matpow (A + mat (1::'a)) (n + k) $h i $h k * A $h k $h j) $h\n          i $h\n          j", "using order.trans[OF nonneg_matpow matpow_mono[of \"A + mat 1\" \"n + k\"]]"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      A $h i $h j \\<le> (A + mat (1::'a)) $h i $h j) \\<Longrightarrow>\n  (0::'a) \\<le> matpow (A + mat (1::'a)) (n + k) $h ?i1 $h ?j1\n\ngoal (1 subgoal):\n 1. (0::'a)\n    \\<le> (\\<chi>i j.\n              \\<Sum>k\\<in>UNIV.\n                matpow (A + mat (1::'a)) (n + k) $h i $h k * A $h k $h j) $h\n          i $h\n          j", "by (auto intro!: sum_nonneg mult_nonneg_nonneg nonneg simp: mat_def)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (matpow (A + mat (1::'a)) (n + k) ** A) $h i $h j\n\ngoal (2 subgoals):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + 0) $h i $h j\n 2. \\<And>k.\n       matpow (A + mat (1::'a)) n $h i $h j\n       \\<le> matpow (A + mat (1::'a)) (n + k) $h i $h j \\<Longrightarrow>\n       matpow (A + mat (1::'a)) n $h i $h j\n       \\<le> matpow (A + mat (1::'a)) (n + Suc k) $h i $h j", "thus ?case"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (matpow (A + mat (1::'a)) (n + k) ** A) $h i $h j\n\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + Suc k) $h i $h j", "using Suc"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (matpow (A + mat (1::'a)) (n + k) ** A) $h i $h j\n  matpow (A + mat (1::'a)) n $h i $h j\n  \\<le> matpow (A + mat (1::'a)) (n + k) $h i $h j\n\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + Suc k) $h i $h j", "by (simp add: matrix_add_ldistrib matrix_mul_rid)"], ["proof (state)\nthis:\n  matpow (A + mat (1::'a)) n $h i $h j\n  \\<le> matpow (A + mat (1::'a)) (n + Suc k) $h i $h j\n\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) n $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (n + 0) $h i $h j", "qed simp"], ["", "lemma G_relpow_matpow_pos_ge: \n  assumes \"(i,j) \\<in> G ^^ m\" \"n \\<ge> m\"\n  shows \"matpow (A + mat 1) n $ i $ j > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "from assms(2)"], ["proof (chain)\npicking this:\n  m \\<le> n", "obtain k where n: \"n = m + k\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = m + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  m \\<le> n\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = m + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  n = m + k\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "have \"0 < matpow A m $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < matpow A m $h i $h j", "by (rule G_relpow_matpow_pos[OF assms(1)])"], ["proof (state)\nthis:\n  (0::'a) < matpow A m $h i $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "also"], ["proof (state)\nthis:\n  (0::'a) < matpow A m $h i $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "have \"\\<dots> \\<le> matpow (A + mat 1) m $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow A m $h i $h j \\<le> matpow (A + mat (1::'a)) m $h i $h j", "by (rule matpow_mono, auto simp: mat_def)"], ["proof (state)\nthis:\n  matpow A m $h i $h j \\<le> matpow (A + mat (1::'a)) m $h i $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "also"], ["proof (state)\nthis:\n  matpow A m $h i $h j \\<le> matpow (A + mat (1::'a)) m $h i $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "have \"\\<dots> \\<le> matpow (A + mat 1) n $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) m $h i $h j\n    \\<le> matpow (A + mat (1::'a)) n $h i $h j", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) m $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (m + k) $h i $h j", "using matpow_sum_one_mono"], ["proof (prove)\nusing this:\n  matpow (A + mat (1::'a)) ?n $h ?i $h ?j\n  \\<le> matpow (A + mat (1::'a)) (?n + ?k) $h ?i $h ?j\n\ngoal (1 subgoal):\n 1. matpow (A + mat (1::'a)) m $h i $h j\n    \\<le> matpow (A + mat (1::'a)) (m + k) $h i $h j", "."], ["proof (state)\nthis:\n  matpow (A + mat (1::'a)) m $h i $h j\n  \\<le> matpow (A + mat (1::'a)) n $h i $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "finally"], ["proof (chain)\npicking this:\n  (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < matpow (A + mat (1::'a)) n $h i $h j\n\ngoal (1 subgoal):\n 1. (0::'a) < matpow (A + mat (1::'a)) n $h i $h j", "."], ["proof (state)\nthis:\n  (0::'a) < matpow (A + mat (1::'a)) n $h i $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale perron_frobenius = pf_nonneg_mat A \n  for A :: \"real ^ 'n ^ 'n\" +\n  assumes irr: irreducible\nbegin"], ["", "definition N where \"N = (SOME N. \\<forall> ij. \\<exists> n \\<le> N. ij \\<in> G ^^ n)\""], ["", "lemma N: \"\\<exists> n \\<le> N. ij \\<in> G ^^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "fix ij"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "have \"ij \\<in> G^+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ij \\<in> G\\<^sup>+", "using irr[unfolded irreducible_def]"], ["proof (prove)\nusing this:\n  UNIV \\<subseteq> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. ij \\<in> G\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  ij \\<in> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "from this[unfolded trancl_power]"], ["proof (chain)\npicking this:\n  \\<exists>n>0. ij \\<in> G ^^ n", "have \"\\<exists> n. ij \\<in> G ^^ n\""], ["proof (prove)\nusing this:\n  \\<exists>n>0. ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n. ij \\<in> G ^^ n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "}"], ["proof (state)\nthis:\n  \\<exists>n. ?ija2 \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "hence \"\\<forall> ij. \\<exists> n. ij \\<in> G ^^ n\""], ["proof (prove)\nusing this:\n  \\<exists>n. ?ija2 \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<forall>ij. \\<exists>n. ij \\<in> G ^^ n", "by auto"], ["proof (state)\nthis:\n  \\<forall>ij. \\<exists>n. ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x. x \\<in> G ^^ f x", "obtain f where f: \"\\<And> ij. ij \\<in> G ^^ (f ij)\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x. x \\<in> G ^^ f x\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>ij. ij \\<in> G ^^ f ij) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?ij \\<in> G ^^ f ?ij\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "define N where N: \"N = Max (range f)\""], ["proof (state)\nthis:\n  N = Max (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "{"], ["proof (state)\nthis:\n  N = Max (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "fix ij"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "from f[of ij]"], ["proof (chain)\npicking this:\n  ij \\<in> G ^^ f ij", "have \"ij \\<in> G ^^ f ij\""], ["proof (prove)\nusing this:\n  ij \\<in> G ^^ f ij\n\ngoal (1 subgoal):\n 1. ij \\<in> G ^^ f ij", "."], ["proof (state)\nthis:\n  ij \\<in> G ^^ f ij\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "moreover"], ["proof (state)\nthis:\n  ij \\<in> G ^^ f ij\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "have \"f ij \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ij \\<le> N", "unfolding N"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ij \\<le> Max (range f)", "by (rule Max_ge, auto)"], ["proof (state)\nthis:\n  f ij \\<le> N\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "ultimately"], ["proof (chain)\npicking this:\n  ij \\<in> G ^^ f ij\n  f ij \\<le> N", "have \"\\<exists> n \\<le> N. ij \\<in> G ^^ n\""], ["proof (prove)\nusing this:\n  ij \\<in> G ^^ f ij\n  f ij \\<le> N\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n\\<le>N. ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "}"], ["proof (state)\nthis:\n  \\<exists>n\\<le>N. ?ija2 \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "note main = this"], ["proof (state)\nthis:\n  \\<exists>n\\<le>N. ?ija2 \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "let ?P = \"\\<lambda> N. \\<forall> ij. \\<exists> n \\<le> N. ij \\<in> G ^^ n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "from main"], ["proof (chain)\npicking this:\n  \\<exists>n\\<le>N. ?ija2 \\<in> G ^^ n", "have \"?P N\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<le>N. ?ija2 \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<forall>ij. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "by blast"], ["proof (state)\nthis:\n  \\<forall>ij. \\<exists>n\\<le>N. ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "from someI[of ?P, OF this, folded N_def]"], ["proof (chain)\npicking this:\n  \\<forall>ij. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ij. \\<exists>n\\<le>N. ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>N. ij \\<in> G ^^ n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n\\<le>N. ij \\<in> G ^^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_matpow_pos: assumes irreducible \n  shows \"matpow (A + mat 1) N $ i $ j > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < matpow (A + mat 1) N $h i $h j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < matpow (A + mat 1) N $h i $h j", "from N"], ["proof (chain)\npicking this:\n  \\<exists>n\\<le>N. ?ij \\<in> G ^^ n", "obtain n where n: \"n \\<le> N\" and reach: \"(i,j) \\<in> G ^^ n\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<le>N. ?ij \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<le> N; (i, j) \\<in> G ^^ n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<le> N\n  (i, j) \\<in> G ^^ n\n\ngoal (1 subgoal):\n 1. 0 < matpow (A + mat 1) N $h i $h j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < matpow (A + mat 1) N $h i $h j", "by (rule G_relpow_matpow_pos_ge[OF reach n])"], ["proof (state)\nthis:\n  0 < matpow (A + mat 1) N $h i $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pf_transpose: \"perron_frobenius (transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perron_frobenius (Finite_Cartesian_Product.transpose A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. non_neg_mat (Finite_Cartesian_Product.transpose A)\n 2. fixed_mat.irreducible (Finite_Cartesian_Product.transpose A)", "show \"fixed_mat.irreducible (transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_mat.irreducible (Finite_Cartesian_Product.transpose A)", "unfolding fixed_mat.irreducible_def G_transpose_trancl"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> (G\\<^sup>+)\\<inverse>", "using irr[unfolded irreducible_def]"], ["proof (prove)\nusing this:\n  UNIV \\<subseteq> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> (G\\<^sup>+)\\<inverse>", "by auto"], ["proof (state)\nthis:\n  fixed_mat.irreducible (Finite_Cartesian_Product.transpose A)\n\ngoal (1 subgoal):\n 1. non_neg_mat (Finite_Cartesian_Product.transpose A)", "qed (insert nonneg, auto simp: transpose_def non_neg_mat_def elements_mat_h_def)"], ["", "abbreviation le_vec :: \"real ^ 'n \\<Rightarrow> real ^ 'n \\<Rightarrow> bool\" where\n  \"le_vec x y \\<equiv> (\\<forall> i. x $ i \\<le> y $ i)\""], ["", "abbreviation lt_vec :: \"real ^ 'n \\<Rightarrow> real ^ 'n \\<Rightarrow> bool\" where\n  \"lt_vec x y \\<equiv> (\\<forall> i. x $ i < y $ i)\""], ["", "definition \"A1n = matpow (A + mat 1) N\""], ["", "lemmas A1n_pos = irreducible_matpow_pos[OF irr, folded A1n_def]"], ["", "definition r :: \"real ^ 'n \\<Rightarrow> real\" where\n  \"r x = Min { (A *v x) $ j / x $ j | j. x $ j \\<noteq> 0 }\""], ["", "definition X :: \"(real ^ 'n )set\" where\n  \"X = { x . le_vec 0 x \\<and> x \\<noteq> 0 }\""], ["", "lemma nonneg_Ax: \"x \\<in> X \\<Longrightarrow> le_vec 0 (A *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> le_vec 0 (A *v x)", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0} \\<Longrightarrow>\n    le_vec 0 (A *v x)", "using nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> A $h ?i $h ?j\n\ngoal (1 subgoal):\n 1. x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0} \\<Longrightarrow>\n    le_vec 0 (A *v x)", "by (auto simp: matrix_vector_mult_def intro!: sum_nonneg)"], ["", "lemma A_nonzero_fixed_i: \"\\<exists> j. A $ i $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. A $h i $h j \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. A $h i $h j \\<noteq> 0", "from irr[unfolded irreducible_def]"], ["proof (chain)\npicking this:\n  UNIV \\<subseteq> G\\<^sup>+", "have \"(i,i) \\<in> G^+\""], ["proof (prove)\nusing this:\n  UNIV \\<subseteq> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. (i, i) \\<in> G\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (i, i) \\<in> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>j. A $h i $h j \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (i, i) \\<in> G\\<^sup>+", "obtain j where \"(i,j) \\<in> G\""], ["proof (prove)\nusing this:\n  (i, i) \\<in> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>j. (i, j) \\<in> G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis converse_tranclE)"], ["proof (state)\nthis:\n  (i, j) \\<in> G\n\ngoal (1 subgoal):\n 1. \\<exists>j. A $h i $h j \\<noteq> 0", "hence Aij: \"A $ i $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> G\n\ngoal (1 subgoal):\n 1. A $h i $h j \\<noteq> 0", "unfolding G_def"], ["proof (prove)\nusing this:\n  (i, j) \\<in> {(i, j). A $h i $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. A $h i $h j \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>j. A $h i $h j \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>j. A $h i $h j \\<noteq> 0", ".."], ["proof (state)\nthis:\n  \\<exists>j. A $h i $h j \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma A_nonzero_fixed_j: \"\\<exists> i. A $ i $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. A $h i $h j \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. A $h i $h j \\<noteq> 0", "from irr[unfolded irreducible_def]"], ["proof (chain)\npicking this:\n  UNIV \\<subseteq> G\\<^sup>+", "have \"(j,j) \\<in> G^+\""], ["proof (prove)\nusing this:\n  UNIV \\<subseteq> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. (j, j) \\<in> G\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (j, j) \\<in> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>i. A $h i $h j \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (j, j) \\<in> G\\<^sup>+", "obtain i where \"(i,j) \\<in> G\""], ["proof (prove)\nusing this:\n  (j, j) \\<in> G\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>i. (i, j) \\<in> G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases, auto)"], ["proof (state)\nthis:\n  (i, j) \\<in> G\n\ngoal (1 subgoal):\n 1. \\<exists>i. A $h i $h j \\<noteq> 0", "hence Aij: \"A $ i $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> G\n\ngoal (1 subgoal):\n 1. A $h i $h j \\<noteq> 0", "unfolding G_def"], ["proof (prove)\nusing this:\n  (i, j) \\<in> {(i, j). A $h i $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. A $h i $h j \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i. A $h i $h j \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i. A $h i $h j \\<noteq> 0", ".."], ["proof (state)\nthis:\n  \\<exists>i. A $h i $h j \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ax_pos: assumes x: \"lt_vec 0 x\" \n  shows \"lt_vec 0 (A *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_vec 0 (A *v x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "from A_nonzero_fixed_i[of i]"], ["proof (chain)\npicking this:\n  \\<exists>j. A $h i $h j \\<noteq> 0", "obtain j where \"A $ i $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>j. A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        A $h i $h j \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "with nonneg[of i j]"], ["proof (chain)\npicking this:\n  0 \\<le> A $h i $h j\n  A $h i $h j \\<noteq> 0", "have A: \"A $ i $ j > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> A $h i $h j\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < A $h i $h j", "by simp"], ["proof (state)\nthis:\n  0 < A $h i $h j\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "from x"], ["proof (chain)\npicking this:\n  lt_vec 0 x", "have \"x $ j \\<ge> 0\" for j"], ["proof (prove)\nusing this:\n  lt_vec 0 x\n\ngoal (1 subgoal):\n 1. 0 \\<le> x $h j", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  0 \\<le> x $h ?j\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "note nonneg = mult_nonneg_nonneg[OF nonneg[of i] this]"], ["proof (state)\nthis:\n  0 \\<le> A $h i $h ?j2 * x $h ?j1\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "have \"(A *v x) $ i = (\\<Sum>j\\<in>UNIV. A $ i $ j * x $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *v x) $h i = (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j)", "unfolding matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) $h i =\n    (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j)", "by simp"], ["proof (state)\nthis:\n  (A *v x) $h i = (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "also"], ["proof (state)\nthis:\n  (A *v x) $h i = (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "have \"\\<dots> = A $ i $ j * x $ j + (\\<Sum>j\\<in>UNIV - {j}. A $ i $ j * x $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) =\n    A $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A $h i $h j * x $h j)", "by (subst sum.remove, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) =\n  A $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) =\n  A $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "have \"\\<dots> > 0 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 0\n    < A $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A $h i $h j * x $h j)", "by (rule add_less_le_mono, insert A x[rule_format] nonneg,\n    auto intro!: sum_nonneg mult_pos_pos)"], ["proof (state)\nthis:\n  0 + 0\n  < A $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 $h i < (A *v x) $h i", "finally"], ["proof (chain)\npicking this:\n  0 + 0 < (A *v x) $h i", "show \"0 $ i < (A *v x) $ i\""], ["proof (prove)\nusing this:\n  0 + 0 < (A *v x) $h i\n\ngoal (1 subgoal):\n 1. 0 $h i < (A *v x) $h i", "by simp"], ["proof (state)\nthis:\n  0 $h i < (A *v x) $h i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonzero_Ax: assumes x: \"x \\<in> X\"\n  shows \"A *v x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "assume 0: \"A *v x = 0\""], ["proof (state)\nthis:\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "from x[unfolded X_def]"], ["proof (chain)\npicking this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "have x: \"le_vec 0 x\" \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. le_vec 0 x &&& x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  le_vec 0 x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "from x(2)"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "obtain j where xj: \"x $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j. x $h j \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis vec_eq_iff zero_index)"], ["proof (state)\nthis:\n  x $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "from A_nonzero_fixed_j[of j]"], ["proof (chain)\npicking this:\n  \\<exists>i. A $h i $h j \\<noteq> 0", "obtain i where Aij: \"A $ i $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>i. A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        A $h i $h j \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "from arg_cong[OF 0, of \"\\<lambda> v. v $ i\", unfolded matrix_vector_mult_def]"], ["proof (chain)\npicking this:\n  (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) $h i = 0 $h i", "have \"0 = (\\<Sum> k \\<in> UNIV. A $h i $h k * x $h k)\""], ["proof (prove)\nusing this:\n  (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * x $h j) $h i = 0 $h i\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>k\\<in>UNIV. A $h i $h k * x $h k)", "by auto"], ["proof (state)\nthis:\n  0 = (\\<Sum>k\\<in>UNIV. A $h i $h k * x $h k)\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>k\\<in>UNIV. A $h i $h k * x $h k)\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "have \"\\<dots> = A $h i $h j * x $h j + (\\<Sum> k \\<in> UNIV - {j}. A $h i $h k * x $h k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. A $h i $h k * x $h k) =\n    A $h i $h j * x $h j + (\\<Sum>k\\<in>UNIV - {j}. A $h i $h k * x $h k)", "by (subst sum.remove[of _ j], auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. A $h i $h k * x $h k) =\n  A $h i $h j * x $h j + (\\<Sum>k\\<in>UNIV - {j}. A $h i $h k * x $h k)\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. A $h i $h k * x $h k) =\n  A $h i $h j * x $h j + (\\<Sum>k\\<in>UNIV - {j}. A $h i $h k * x $h k)\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "have \"\\<dots> > 0 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 0\n    < A $h i $h j * x $h j + (\\<Sum>k\\<in>UNIV - {j}. A $h i $h k * x $h k)", "by (rule add_less_le_mono, insert nonneg[of i] Aij x(1) xj, \n    auto intro!: sum_nonneg mult_pos_pos simp: dual_order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  0 + 0\n  < A $h i $h j * x $h j + (\\<Sum>k\\<in>UNIV - {j}. A $h i $h k * x $h k)\n\ngoal (1 subgoal):\n 1. A *v x = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 + 0 < 0", "show False"], ["proof (prove)\nusing this:\n  0 + 0 < 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_witness: assumes x: \"x \\<in> X\" \n  shows \"\\<exists> j. x $ j > 0 \\<and> r x = (A *v x) $ j / x $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "from x[unfolded X_def]"], ["proof (chain)\npicking this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "have x: \"le_vec 0 x\" \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. le_vec 0 x &&& x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  le_vec 0 x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "let ?A = \"{ (A *v x) $ j / x $ j | j. x $ j \\<noteq> 0 }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "from x(2)"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "obtain j where \"x $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>j. x $h j \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis vec_eq_iff zero_index)"], ["proof (state)\nthis:\n  x $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "hence empty: \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  x $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "from Min_in[OF _ this, folded r_def]"], ["proof (chain)\npicking this:\n  finite {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<Longrightarrow>\n  r x \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "obtain j where \"x $ j \\<noteq> 0\" and rx: \"r x = (A *v x) $ j / x $ j\""], ["proof (prove)\nusing this:\n  finite {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<Longrightarrow>\n  r x \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x $h j \\<noteq> 0; r x = (A *v x) $h j / x $h j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x $h j \\<noteq> 0\n  r x = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "with x"], ["proof (chain)\npicking this:\n  le_vec 0 x\n  x \\<noteq> 0\n  x $h j \\<noteq> 0\n  r x = (A *v x) $h j / x $h j", "have \"x $ j > 0\""], ["proof (prove)\nusing this:\n  le_vec 0 x\n  x \\<noteq> 0\n  x $h j \\<noteq> 0\n  r x = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. 0 < x $h j", "by (auto simp: dual_order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  0 < x $h j\n\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "with rx"], ["proof (chain)\npicking this:\n  r x = (A *v x) $h j / x $h j\n  0 < x $h j", "show ?thesis"], ["proof (prove)\nusing this:\n  r x = (A *v x) $h j / x $h j\n  0 < x $h j\n\ngoal (1 subgoal):\n 1. \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "by auto"], ["proof (state)\nthis:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rx_nonneg: assumes x: \"x \\<in> X\"\n  shows \"r x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> r x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> r x", "from x[unfolded X_def]"], ["proof (chain)\npicking this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "have x: \"le_vec 0 x\" \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. le_vec 0 x &&& x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  le_vec 0 x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> r x", "let ?A = \"{ (A *v x) $ j / x $ j | j. x $ j \\<noteq> 0 }\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> r x", "from r_witness[OF \\<open>x \\<in> X\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "have empty: \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 \\<le> r x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> r x", "unfolding r_def X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Min {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "proof (subst Min_ge_iff, force, use empty in force, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 \\<le> xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 \\<le> xa", "assume \"y \\<in> ?A\""], ["proof (state)\nthis:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 \\<le> xa", "then"], ["proof (chain)\npicking this:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "obtain j where \"y = (A *v x) $ j / x $ j\" and \"x $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>y = (A *v x) $h j / x $h j; x $h j \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = (A *v x) $h j / x $h j\n  x $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 \\<le> xa", "from nonneg_Ax[OF \\<open>x \\<in> X\\<close>] this x"], ["proof (chain)\npicking this:\n  le_vec 0 (A *v x)\n  y = (A *v x) $h j / x $h j\n  x $h j \\<noteq> 0\n  le_vec 0 x\n  x \\<noteq> 0", "show \"0 \\<le> y\""], ["proof (prove)\nusing this:\n  le_vec 0 (A *v x)\n  y = (A *v x) $h j / x $h j\n  x $h j \\<noteq> 0\n  le_vec 0 x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "by simp"], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rx_pos: assumes x: \"lt_vec 0 x\"\n  shows \"r x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < r x", "from Ax_pos[OF x]"], ["proof (chain)\npicking this:\n  lt_vec 0 (A *v x)", "have lt: \"lt_vec 0 (A *v x)\""], ["proof (prove)\nusing this:\n  lt_vec 0 (A *v x)\n\ngoal (1 subgoal):\n 1. lt_vec 0 (A *v x)", "."], ["proof (state)\nthis:\n  lt_vec 0 (A *v x)\n\ngoal (1 subgoal):\n 1. 0 < r x", "from x"], ["proof (chain)\npicking this:\n  lt_vec 0 x", "have x': \"x \\<in> X\""], ["proof (prove)\nusing this:\n  lt_vec 0 x\n\ngoal (1 subgoal):\n 1. x \\<in> X", "unfolding X_def order.strict_iff_order"], ["proof (prove)\nusing this:\n  \\<forall>i. 0 $h i \\<le> x $h i \\<and> 0 $h i \\<noteq> x $h i\n\ngoal (1 subgoal):\n 1. x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. 0 < r x", "let ?A = \"{ (A *v x) $ j / x $ j | j. x $ j \\<noteq> 0 }\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < r x", "from r_witness[OF \\<open>x \\<in> X\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "have empty: \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < r x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r x", "unfolding r_def X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "proof (subst Min_gr_iff, force, use empty in force, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 < xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 < xa", "assume \"y \\<in> ?A\""], ["proof (state)\nthis:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 < xa", "then"], ["proof (chain)\npicking this:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "obtain j where \"y = (A *v x) $ j / x $ j\" and \"x $ j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>y = (A *v x) $h j / x $h j; x $h j \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = (A *v x) $h j / x $h j\n  x $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(A *v x) $h j / x $h j |j.\n                 x $h j \\<noteq> 0} \\<Longrightarrow>\n       0 < xa", "from lt this x"], ["proof (chain)\npicking this:\n  lt_vec 0 (A *v x)\n  y = (A *v x) $h j / x $h j\n  x $h j \\<noteq> 0\n  lt_vec 0 x", "show \"0 < y\""], ["proof (prove)\nusing this:\n  lt_vec 0 (A *v x)\n  y = (A *v x) $h j / x $h j\n  x $h j \\<noteq> 0\n  lt_vec 0 x\n\ngoal (1 subgoal):\n 1. 0 < y", "by simp"], ["proof (state)\nthis:\n  0 < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rx_le_Ax: assumes x: \"x \\<in> X\" \n  shows \"le_vec (r x *s x) (A *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (r x *s x) (A *v x)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (r x *s x) $h i \\<le> (A *v x) $h i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (r x *s x) $h i \\<le> (A *v x) $h i", "show \"(r x *s x) $h i \\<le> (A *v x) $h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r x *s x) $h i \\<le> (A *v x) $h i", "proof (cases \"x $ i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x $h i = 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i\n 2. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "case True"], ["proof (state)\nthis:\n  x $h i = 0\n\ngoal (2 subgoals):\n 1. x $h i = 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i\n 2. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "with nonneg_Ax[OF x]"], ["proof (chain)\npicking this:\n  le_vec 0 (A *v x)\n  x $h i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  le_vec 0 (A *v x)\n  x $h i = 0\n\ngoal (1 subgoal):\n 1. (r x *s x) $h i \\<le> (A *v x) $h i", "by auto"], ["proof (state)\nthis:\n  (r x *s x) $h i \\<le> (A *v x) $h i\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "case False"], ["proof (state)\nthis:\n  x $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "with x[unfolded X_def]"], ["proof (chain)\npicking this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n  x $h i \\<noteq> 0", "have pos: \"x $ i > 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n  x $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < x $h i", "by (auto simp: dual_order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  0 < x $h i\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "from False"], ["proof (chain)\npicking this:\n  x $h i \\<noteq> 0", "have \"(A *v x) $h i / x $ i \\<in> { (A *v x) $ j / x $ j | j. x $ j \\<noteq> 0 }\""], ["proof (prove)\nusing this:\n  x $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (A *v x) $h i / x $h i\n    \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  (A *v x) $h i / x $h i\n  \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "hence \"(A *v x) $h i / x $ i \\<ge> r x\""], ["proof (prove)\nusing this:\n  (A *v x) $h i / x $h i\n  \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. r x \\<le> (A *v x) $h i / x $h i", "unfolding r_def"], ["proof (prove)\nusing this:\n  (A *v x) $h i / x $h i\n  \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. Min {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n    \\<le> (A *v x) $h i / x $h i", "by simp"], ["proof (state)\nthis:\n  r x \\<le> (A *v x) $h i / x $h i\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "hence \"x $ i * r x \\<le> x $ i * ((A *v x) $h i / x $ i)\""], ["proof (prove)\nusing this:\n  r x \\<le> (A *v x) $h i / x $h i\n\ngoal (1 subgoal):\n 1. x $h i * r x \\<le> x $h i * ((A *v x) $h i / x $h i)", "unfolding mult_le_cancel_left_pos[OF pos]"], ["proof (prove)\nusing this:\n  r x \\<le> (A *v x) $h i / x $h i\n\ngoal (1 subgoal):\n 1. r x \\<le> (A *v x) $h i / x $h i", "."], ["proof (state)\nthis:\n  x $h i * r x \\<le> x $h i * ((A *v x) $h i / x $h i)\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "also"], ["proof (state)\nthis:\n  x $h i * r x \\<le> x $h i * ((A *v x) $h i / x $h i)\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "have \"\\<dots> = (A *v x) $h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $h i * ((A *v x) $h i / x $h i) = (A *v x) $h i", "using pos"], ["proof (prove)\nusing this:\n  0 < x $h i\n\ngoal (1 subgoal):\n 1. x $h i * ((A *v x) $h i / x $h i) = (A *v x) $h i", "by simp"], ["proof (state)\nthis:\n  x $h i * ((A *v x) $h i / x $h i) = (A *v x) $h i\n\ngoal (1 subgoal):\n 1. x $h i \\<noteq> 0 \\<Longrightarrow> (r x *s x) $h i \\<le> (A *v x) $h i", "finally"], ["proof (chain)\npicking this:\n  x $h i * r x \\<le> (A *v x) $h i", "show ?thesis"], ["proof (prove)\nusing this:\n  x $h i * r x \\<le> (A *v x) $h i\n\ngoal (1 subgoal):\n 1. (r x *s x) $h i \\<le> (A *v x) $h i", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (r x *s x) $h i \\<le> (A *v x) $h i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (r x *s x) $h i \\<le> (A *v x) $h i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rho_le_x_Ax_imp_rho_le_rx: assumes x: \"x \\<in> X\"\n  and \\<rho>: \"le_vec (\\<rho> *s x) (A *v x)\"\nshows \"\\<rho> \\<le> r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<le> r x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<rho> \\<le> r x", "from r_witness[OF x]"], ["proof (chain)\npicking this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "obtain j where \n    rx: \"r x = (A *v x) $ j / x $ j\" and xj: \"x $ j > 0\" \"x $ j \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>r x = (A *v x) $h j / x $h j; 0 < x $h j;\n         0 \\<le> x $h j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r x = (A *v x) $h j / x $h j\n  0 < x $h j\n  0 \\<le> x $h j\n\ngoal (1 subgoal):\n 1. \\<rho> \\<le> r x", "from divide_right_mono[OF \\<rho>[rule_format, of j] xj(2)]"], ["proof (chain)\npicking this:\n  (\\<rho> *s x) $h j / x $h j \\<le> (A *v x) $h j / x $h j", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<rho> *s x) $h j / x $h j \\<le> (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. \\<rho> \\<le> r x", "unfolding rx"], ["proof (prove)\nusing this:\n  (\\<rho> *s x) $h j / x $h j \\<le> (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. \\<rho> \\<le> (A *v x) $h j / x $h j", "using xj"], ["proof (prove)\nusing this:\n  (\\<rho> *s x) $h j / x $h j \\<le> (A *v x) $h j / x $h j\n  0 < x $h j\n  0 \\<le> x $h j\n\ngoal (1 subgoal):\n 1. \\<rho> \\<le> (A *v x) $h j / x $h j", "by simp"], ["proof (state)\nthis:\n  \\<rho> \\<le> r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rx_Max: assumes x: \"x \\<in> X\"\n  shows \"r x = Sup { \\<rho> . le_vec (\\<rho> *s x) (A *v x) }\" (is \"_ = Sup ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "have \"r x \\<in> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "using rx_le_Ax[OF x]"], ["proof (prove)\nusing this:\n  le_vec (r x *s x) (A *v x)\n\ngoal (1 subgoal):\n 1. r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "by auto"], ["proof (state)\nthis:\n  r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "moreover"], ["proof (state)\nthis:\n  r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "{"], ["proof (state)\nthis:\n  r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "assume \"y \\<in> ?S\""], ["proof (state)\nthis:\n  y \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "hence y: \"le_vec (y *s x) (A *v x)\""], ["proof (prove)\nusing this:\n  y \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. le_vec (y *s x) (A *v x)", "by auto"], ["proof (state)\nthis:\n  le_vec (y *s x) (A *v x)\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "from rho_le_x_Ax_imp_rho_le_rx[OF x this]"], ["proof (chain)\npicking this:\n  y \\<le> r x", "have \"y \\<le> r x\""], ["proof (prove)\nusing this:\n  y \\<le> r x\n\ngoal (1 subgoal):\n 1. y \\<le> r x", "."], ["proof (state)\nthis:\n  y \\<le> r x\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n  ?y2 \\<le> r x\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "ultimately"], ["proof (chain)\npicking this:\n  r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n  ?y2 \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n  ?y2 \\<le> r x", "show ?thesis"], ["proof (prove)\nusing this:\n  r x \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n  ?y2 \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n  ?y2 \\<le> r x\n\ngoal (1 subgoal):\n 1. r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}", "by (metis (mono_tags, lifting) cSup_eq_maximum)"], ["proof (state)\nthis:\n  r x = Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_smult: assumes x: \"x \\<in> X\" \n  and a: \"a > 0\" \nshows \"r (a *s x) = r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (a *s x) = r x", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {(A *v (a *s x)) $h j / (a *s x) $h j |j.\n         (a *s x) $h j \\<noteq> 0} =\n    Min {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "by (rule arg_cong[of _ _ Min], unfold vector_smult_distrib, insert a, simp)"], ["", "definition \"X1 = (X \\<inter> {x. norm x = 1})\""], ["", "lemma bounded_X1: \"bounded X1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded X1", "unfolding bounded_iff X1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. \\<forall>x\\<in>X \\<inter> {x. norm x = 1}. norm x \\<le> a", "by auto"], ["", "lemma closed_X1: \"closed X1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed X1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed X1", "have X1: \"X1 = {x. le_vec 0 x \\<and> norm x = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 = {x. le_vec 0 x \\<and> norm x = 1}", "unfolding X1_def X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. le_vec 0 x \\<and> x \\<noteq> 0} \\<inter> {x. norm x = 1} =\n    {x. le_vec 0 x \\<and> norm x = 1}", "by auto"], ["proof (state)\nthis:\n  X1 = {x. le_vec 0 x \\<and> norm x = 1}\n\ngoal (1 subgoal):\n 1. closed X1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed X1", "unfolding X1"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. le_vec 0 x \\<and> norm x = 1}", "by (intro closed_Collect_conj closed_Collect_all  closed_Collect_le closed_Collect_eq,\n      auto intro: continuous_intros)"], ["proof (state)\nthis:\n  closed X1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compact_X1: \"compact X1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact X1", "using bounded_X1 closed_X1"], ["proof (prove)\nusing this:\n  bounded X1\n  closed X1\n\ngoal (1 subgoal):\n 1. compact X1", "by (simp add: compact_eq_bounded_closed)"], ["", "definition \"pow_A_1 x = A1n *v x\""], ["", "lemma continuous_pow_A_1: \"continuous_on R pow_A_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on R pow_A_1", "unfolding pow_A_1_def continuous_on"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>R.\n       ((*v) A1n \\<longlongrightarrow> A1n *v x) (at x within R)", "by (auto intro: tendsto_intros)"], ["", "definition \"Y = pow_A_1 ` X1\""], ["", "lemma compact_Y: \"compact Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact Y", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. compact (pow_A_1 ` X1)", "using compact_X1 continuous_pow_A_1[of X1]"], ["proof (prove)\nusing this:\n  compact X1\n  continuous_on X1 pow_A_1\n\ngoal (1 subgoal):\n 1. compact (pow_A_1 ` X1)", "by (metis compact_continuous_image)"], ["", "lemma Y_pos_main: assumes y: \"y \\<in> pow_A_1 ` X\" \n  shows \"y $ i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y $h i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < y $h i", "from y"], ["proof (chain)\npicking this:\n  y \\<in> pow_A_1 ` X", "obtain x where x: \"x \\<in> X\" and y: \"y = pow_A_1 x\""], ["proof (prove)\nusing this:\n  y \\<in> pow_A_1 ` X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> X; y = pow_A_1 x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Y_def X1_def"], ["proof (prove)\nusing this:\n  y \\<in> pow_A_1 ` X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> X; y = pow_A_1 x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n  y = pow_A_1 x\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "from r_witness[OF x]"], ["proof (chain)\npicking this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j", "obtain j where xj: \"x $ j > 0\""], ["proof (prove)\nusing this:\n  \\<exists>j. 0 < x $h j \\<and> r x = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. (\\<And>j. 0 < x $h j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  0 < x $h j\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "from x[unfolded X_def]"], ["proof (chain)\npicking this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "have xi: \"x $ i \\<ge> 0\" for i"], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. 0 \\<le> x $h i", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x $h ?i\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "have nonneg: \"0 \\<le> A1n $ i $ k * x $ k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> A1n $h i $h k * x $h k", "using A1n_pos[of i k] xi[of k]"], ["proof (prove)\nusing this:\n  0 < A1n $h i $h k\n  0 \\<le> x $h k\n\ngoal (1 subgoal):\n 1. 0 \\<le> A1n $h i $h k * x $h k", "by auto"], ["proof (state)\nthis:\n  0 \\<le> A1n $h i $h ?k * x $h ?k\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "have \"y $ i = (\\<Sum>j\\<in>UNIV. A1n $ i $ j * x $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y $h i = (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j)", "unfolding y pow_A_1_def matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j) $h i =\n    (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j)", "by simp"], ["proof (state)\nthis:\n  y $h i = (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "also"], ["proof (state)\nthis:\n  y $h i = (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "have \"\\<dots> = A1n $ i $ j * x $ j + (\\<Sum>j\\<in>UNIV - {j}. A1n $ i $ j * x $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j) =\n    A1n $h i $h j * x $h j +\n    (\\<Sum>j\\<in>UNIV - {j}. A1n $h i $h j * x $h j)", "by (subst sum.remove, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j) =\n  A1n $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A1n $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. A1n $h i $h j * x $h j) =\n  A1n $h i $h j * x $h j + (\\<Sum>j\\<in>UNIV - {j}. A1n $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "have \"\\<dots> > 0 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 0\n    < A1n $h i $h j * x $h j +\n      (\\<Sum>j\\<in>UNIV - {j}. A1n $h i $h j * x $h j)", "by (rule add_less_le_mono, insert xj A1n_pos nonneg, \n    auto intro!: sum_nonneg mult_pos_pos simp: dual_order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  0 + 0\n  < A1n $h i $h j * x $h j +\n    (\\<Sum>j\\<in>UNIV - {j}. A1n $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "finally"], ["proof (chain)\npicking this:\n  0 + 0 < y $h i", "show ?thesis"], ["proof (prove)\nusing this:\n  0 + 0 < y $h i\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "by simp"], ["proof (state)\nthis:\n  0 < y $h i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Y_pos: assumes y: \"y \\<in> Y\" \n  shows \"y $ i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y $h i", "using Y_pos_main[of y i] y"], ["proof (prove)\nusing this:\n  y \\<in> pow_A_1 ` X \\<Longrightarrow> 0 < y $h i\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "unfolding Y_def X1_def"], ["proof (prove)\nusing this:\n  y \\<in> pow_A_1 ` X \\<Longrightarrow> 0 < y $h i\n  y \\<in> pow_A_1 ` (X \\<inter> {x. norm x = 1})\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "by auto"], ["", "lemma Y_nonzero: assumes y: \"y \\<in> Y\" \n  shows \"y $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y $h i \\<noteq> 0", "using Y_pos[OF y, of i]"], ["proof (prove)\nusing this:\n  0 < y $h i\n\ngoal (1 subgoal):\n 1. y $h i \\<noteq> 0", "by auto"], ["", "definition r' :: \"real ^ 'n \\<Rightarrow> real\" where\n  \"r' x = Min (range (\\<lambda> j. (A *v x) $ j / x $ j))\""], ["", "lemma r'_r: assumes x: \"x \\<in> Y\" shows \"r' x = r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' x = r x", "unfolding r'_def r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN j. (A *v x) $h j / x $h j) =\n    Min {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "proof (rule arg_cong[of _ _ Min])"], ["proof (state)\ngoal (1 subgoal):\n 1. range (\\<lambda>j. (A *v x) $h j / x $h j) =\n    {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "have \"range (\\<lambda>j. (A *v x) $ j / x $ j) \\<subseteq> {(A *v x) $ j / x $ j |j. x $ j \\<noteq> 0}\" (is \"?L \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>j. (A *v x) $h j / x $h j)\n    \\<subseteq> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j) \\<Longrightarrow>\n       xa \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j) \\<Longrightarrow>\n       xa \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "assume \"y \\<in> ?L\""], ["proof (state)\nthis:\n  y \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j) \\<Longrightarrow>\n       xa \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "then"], ["proof (chain)\npicking this:\n  y \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j)", "obtain j where \"y = (A *v x) $ j / x $ j\""], ["proof (prove)\nusing this:\n  y \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        y = (A *v x) $h j / x $h j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> range (\\<lambda>j. (A *v x) $h j / x $h j) \\<Longrightarrow>\n       xa \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "with Y_pos[OF x, of j]"], ["proof (chain)\npicking this:\n  0 < x $h j\n  y = (A *v x) $h j / x $h j", "show \"y \\<in> ?R\""], ["proof (prove)\nusing this:\n  0 < x $h j\n  y = (A *v x) $h j / x $h j\n\ngoal (1 subgoal):\n 1. y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (\\<lambda>j. (A *v x) $h j / x $h j)\n  \\<subseteq> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. range (\\<lambda>j. (A *v x) $h j / x $h j) =\n    {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "moreover"], ["proof (state)\nthis:\n  range (\\<lambda>j. (A *v x) $h j / x $h j)\n  \\<subseteq> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. range (\\<lambda>j. (A *v x) $h j / x $h j) =\n    {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "have \"?L \\<supseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n    \\<subseteq> range (\\<lambda>j. (A *v x) $h j / x $h j)", "by auto"], ["proof (state)\nthis:\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n  \\<subseteq> range (\\<lambda>j. (A *v x) $h j / x $h j)\n\ngoal (1 subgoal):\n 1. range (\\<lambda>j. (A *v x) $h j / x $h j) =\n    {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "ultimately"], ["proof (chain)\npicking this:\n  range (\\<lambda>j. (A *v x) $h j / x $h j)\n  \\<subseteq> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n  \\<subseteq> range (\\<lambda>j. (A *v x) $h j / x $h j)", "show \"?L = ?R\""], ["proof (prove)\nusing this:\n  range (\\<lambda>j. (A *v x) $h j / x $h j)\n  \\<subseteq> {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n  \\<subseteq> range (\\<lambda>j. (A *v x) $h j / x $h j)\n\ngoal (1 subgoal):\n 1. range (\\<lambda>j. (A *v x) $h j / x $h j) =\n    {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}", "by blast"], ["proof (state)\nthis:\n  range (\\<lambda>j. (A *v x) $h j / x $h j) =\n  {(A *v x) $h j / x $h j |j. x $h j \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_Y_r: \"continuous_on Y r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on Y r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on Y r", "have *: \"(\\<forall> y \\<in> Y. P y (r y)) = (\\<forall> y \\<in> Y. P y (r' y))\" for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>Y. P y (r y)) = (\\<forall>y\\<in>Y. P y (r' y))", "using r'_r"], ["proof (prove)\nusing this:\n  ?x \\<in> Y \\<Longrightarrow> r' ?x = r ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>Y. P y (r y)) = (\\<forall>y\\<in>Y. P y (r' y))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>y\\<in>Y. ?P y (r y)) = (\\<forall>y\\<in>Y. ?P y (r' y))\n\ngoal (1 subgoal):\n 1. continuous_on Y r", "have \"continuous_on Y r = continuous_on Y r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on Y r = continuous_on Y r'", "by (rule continuous_on_cong[OF refl r'_r[symmetric]])"], ["proof (state)\nthis:\n  continuous_on Y r = continuous_on Y r'\n\ngoal (1 subgoal):\n 1. continuous_on Y r", "also"], ["proof (state)\nthis:\n  continuous_on Y r = continuous_on Y r'\n\ngoal (1 subgoal):\n 1. continuous_on Y r", "have \\<dots>"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on Y r'", "unfolding continuous_on r'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Y.\n       ((\\<lambda>x. MIN j. (A *v x) $h j / x $h j) \\<longlongrightarrow>\n        (MIN j. (A *v x) $h j / x $h j))\n        (at x within Y)", "using Y_nonzero"], ["proof (prove)\nusing this:\n  ?y \\<in> Y \\<Longrightarrow> ?y $h ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Y.\n       ((\\<lambda>x. MIN j. (A *v x) $h j / x $h j) \\<longlongrightarrow>\n        (MIN j. (A *v x) $h j / x $h j))\n        (at x within Y)", "by (auto intro!: tendsto_Min tendsto_intros)"], ["proof (state)\nthis:\n  continuous_on Y r'\n\ngoal (1 subgoal):\n 1. continuous_on Y r", "finally"], ["proof (chain)\npicking this:\n  continuous_on Y r", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_on Y r\n\ngoal (1 subgoal):\n 1. continuous_on Y r", "."], ["proof (state)\nthis:\n  continuous_on Y r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma X1_nonempty: \"X1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "define x where \"x = ((\\<chi> i. if i = undefined then 1 else 0) :: real ^ 'n)\""], ["proof (state)\nthis:\n  x = (\\<chi>i. if i = undefined then 1 else 0)\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "{"], ["proof (state)\nthis:\n  x = (\\<chi>i. if i = undefined then 1 else 0)\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "from arg_cong[OF this, of \"\\<lambda> x. x $ undefined\"]"], ["proof (chain)\npicking this:\n  x $h undefined = 0 $h undefined", "have False"], ["proof (prove)\nusing this:\n  x $h undefined = 0 $h undefined\n\ngoal (1 subgoal):\n 1. False", "unfolding x_def"], ["proof (prove)\nusing this:\n  (\\<chi>i. if i = undefined then 1 else 0) $h undefined = 0 $h undefined\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "}"], ["proof (state)\nthis:\n  x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "hence x: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "have \"le_vec 0 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec 0 x", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec 0 (\\<chi>i. if i = undefined then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  le_vec 0 x\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  le_vec 0 x\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "have \"norm x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = 1", "unfolding norm_vec_def L2_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>UNIV. (norm (x $h i))\\<^sup>2) = 1", "by (auto, subst sum.remove[of _ undefined], auto simp: x_def)"], ["proof (state)\nthis:\n  norm x = 1\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> 0\n  le_vec 0 x\n  norm x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  le_vec 0 x\n  norm x = 1\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "unfolding X1_def X_def"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  le_vec 0 x\n  norm x = 1\n\ngoal (1 subgoal):\n 1. {x. le_vec 0 x \\<and> x \\<noteq> 0} \\<inter> {x. norm x = 1} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  X1 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Y_nonempty: \"Y \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {}", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_A_1 ` X1 \\<noteq> {}", "using X1_nonempty"], ["proof (prove)\nusing this:\n  X1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pow_A_1 ` X1 \\<noteq> {}", "by auto"], ["", "definition z where \"z = (SOME z. z \\<in> Y \\<and> (\\<forall> y \\<in> Y. r y \\<le> r z))\""], ["", "abbreviation \"sr \\<equiv> r z\""], ["", "lemma z: \"z \\<in> Y\" and sr_max_Y: \"\\<And> y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> Y &&& (\\<And>y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> Y\n 2. \\<And>y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr", "let ?P = \"\\<lambda> z. z \\<in> Y \\<and> (\\<forall> y \\<in> Y. r y \\<le> r z)\""], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> Y\n 2. \\<And>y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr", "from continuous_attains_sup[OF compact_Y Y_nonempty continuous_Y_r]"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>Y. \\<forall>y\\<in>Y. r y \\<le> r x", "obtain y where \"?P y\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>Y. \\<forall>y\\<in>Y. r y \\<le> r x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<in> Y \\<and>\n        (\\<forall>ya\\<in>Y. r ya \\<le> r y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> Y \\<and> (\\<forall>ya\\<in>Y. r ya \\<le> r y)\n\ngoal (2 subgoals):\n 1. z \\<in> Y\n 2. \\<And>y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr", "from someI[of ?P, OF this, folded z_def]"], ["proof (chain)\npicking this:\n  z \\<in> Y \\<and> (\\<forall>y\\<in>Y. r y \\<le> sr)", "show \"z \\<in> Y\" \"\\<And> y. y \\<in> Y \\<Longrightarrow> r y \\<le> r z\""], ["proof (prove)\nusing this:\n  z \\<in> Y \\<and> (\\<forall>y\\<in>Y. r y \\<le> sr)\n\ngoal (1 subgoal):\n 1. z \\<in> Y &&& (\\<And>y. y \\<in> Y \\<Longrightarrow> r y \\<le> sr)", "by blast+"], ["proof (state)\nthis:\n  z \\<in> Y\n  ?y \\<in> Y \\<Longrightarrow> r ?y \\<le> sr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Y_subset_X: \"Y \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> X", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> X", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> X", "assume \"y \\<in> Y\""], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> X", "from Y_pos[OF this]"], ["proof (chain)\npicking this:\n  0 < y $h ?i", "show \"y \\<in> X\""], ["proof (prove)\nusing this:\n  0 < y $h ?i\n\ngoal (1 subgoal):\n 1. y \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  0 < y $h ?i\n\ngoal (1 subgoal):\n 1. y \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zX: \"z \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> X", "using z(1) Y_subset_X"], ["proof (prove)\nusing this:\n  z \\<in> Y\n  Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. z \\<in> X", "by auto"], ["", "lemma le_vec_mono_left: assumes B: \"\\<And> i j. B $ i $ j \\<ge> 0\" \n  and \"le_vec x y\" \nshows \"le_vec (B *v x) (B *v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (B *v x) (B *v y)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (B *v x) $h i \\<le> (B *v y) $h i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (B *v x) $h i \\<le> (B *v y) $h i", "show \"(B *v x) $ i \\<le> (B *v y) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B *v x) $h i \\<le> (B *v y) $h i", "unfolding matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. B $h i $h j * x $h j) $h i\n    \\<le> (\\<chi>i. \\<Sum>j\\<in>UNIV. B $h i $h j * y $h j) $h i", "using B[of i] assms(2)"], ["proof (prove)\nusing this:\n  0 \\<le> B $h i $h ?j\n  le_vec x y\n\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. B $h i $h j * x $h j) $h i\n    \\<le> (\\<chi>i. \\<Sum>j\\<in>UNIV. B $h i $h j * y $h j) $h i", "by (auto intro!: sum_mono mult_left_mono)"], ["proof (state)\nthis:\n  (B *v x) $h i \\<le> (B *v y) $h i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matpow_1_commute: \"matpow (A + mat 1) n ** A = A ** matpow (A + mat 1) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat 1) n ** A = A ** matpow (A + mat 1) n", "by (induct n, auto simp: matrix_add_rdistrib matrix_add_ldistrib matrix_mul_rid matrix_mul_lid\n  matrix_mul_assoc[symmetric])"], ["", "lemma A1n_commute: \"A1n ** A = A ** A1n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1n ** A = A ** A1n", "unfolding A1n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat 1) N ** A = A ** matpow (A + mat 1) N", "by (rule matpow_1_commute)"], ["", "lemma le_vec_pow_A_1: assumes le: \"le_vec (rho *s x) (A *v x)\" \n  shows \"le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"A1n $ i $ j \\<ge> 0\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> A1n $h i $h j", "using A1n_pos[of i j]"], ["proof (prove)\nusing this:\n  0 < A1n $h i $h j\n\ngoal (1 subgoal):\n 1. 0 \\<le> A1n $h i $h j", "by auto"], ["proof (state)\nthis:\n  0 \\<le> A1n $h ?i $h ?j\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "from le_vec_mono_left[OF this le]"], ["proof (chain)\npicking this:\n  le_vec (A1n *v (rho *s x)) (A1n *v (A *v x))", "have \"le_vec (A1n *v (rho *s x)) (A1n *v (A *v x))\""], ["proof (prove)\nusing this:\n  le_vec (A1n *v (rho *s x)) (A1n *v (A *v x))\n\ngoal (1 subgoal):\n 1. le_vec (A1n *v (rho *s x)) (A1n *v (A *v x))", "."], ["proof (state)\nthis:\n  le_vec (A1n *v (rho *s x)) (A1n *v (A *v x))\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "also"], ["proof (state)\nthis:\n  le_vec (A1n *v (rho *s x)) (A1n *v (A *v x))\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"A1n *v (A *v x) = (A1n ** A) *v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1n *v (A *v x) = A1n ** A *v x", "by (simp add: matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  A1n *v (A *v x) = A1n ** A *v x\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "also"], ["proof (state)\nthis:\n  A1n *v (A *v x) = A1n ** A *v x\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"\\<dots> = A *v (A1n *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1n ** A *v x = A *v (A1n *v x)", "unfolding A1n_commute"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** A1n *v x = A *v (A1n *v x)", "by (simp add: matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  A1n ** A *v x = A *v (A1n *v x)\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "also"], ["proof (state)\nthis:\n  A1n ** A *v x = A *v (A1n *v x)\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"\\<dots> = A *v (pow_A_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (A1n *v x) = A *v pow_A_1 x", "unfolding pow_A_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (A1n *v x) = A *v (A1n *v x)", ".."], ["proof (state)\nthis:\n  A *v (A1n *v x) = A *v pow_A_1 x\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "also"], ["proof (state)\nthis:\n  A *v (A1n *v x) = A *v pow_A_1 x\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"A1n *v (rho *s x) = rho *s (A1n *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1n *v (rho *s x) = rho *s (A1n *v x)", "unfolding vector_smult_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. rho *s (A1n *v x) = rho *s (A1n *v x)", ".."], ["proof (state)\nthis:\n  A1n *v (rho *s x) = rho *s (A1n *v x)\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "also"], ["proof (state)\nthis:\n  A1n *v (rho *s x) = rho *s (A1n *v x)\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"\\<dots> = rho *s pow_A_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rho *s (A1n *v x) = rho *s pow_A_1 x", "unfolding pow_A_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rho *s (A1n *v x) = rho *s (A1n *v x)", ".."], ["proof (state)\nthis:\n  rho *s (A1n *v x) = rho *s pow_A_1 x\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "finally"], ["proof (chain)\npicking this:\n  le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "show \"le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)\""], ["proof (prove)\nusing this:\n  le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)\n\ngoal (1 subgoal):\n 1. le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "."], ["proof (state)\nthis:\n  le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_pow_A_1: assumes x: \"x \\<in> X\"\n  shows \"r x \\<le> r (pow_A_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "let ?y = \"pow_A_1 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "have \"?y \\<in> pow_A_1 ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_A_1 x \\<in> pow_A_1 ` X", "using x"], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. pow_A_1 x \\<in> pow_A_1 ` X", "by auto"], ["proof (state)\nthis:\n  pow_A_1 x \\<in> pow_A_1 ` X\n\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "from Y_pos_main[OF this]"], ["proof (chain)\npicking this:\n  0 < pow_A_1 x $h ?i", "have y: \"?y \\<in> X\""], ["proof (prove)\nusing this:\n  0 < pow_A_1 x $h ?i\n\ngoal (1 subgoal):\n 1. pow_A_1 x \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  0 < pow_A_1 x $h ?i\n\ngoal (1 subgoal):\n 1. pow_A_1 x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  pow_A_1 x \\<in> X\n\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "let ?A = \"{\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "let ?B = \"{\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r x \\<le> r (pow_A_1 x)", "unfolding rx_Max[OF x] rx_Max[OF y]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n    \\<le> Sup {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}", "proof (rule cSup_mono)"], ["proof (state)\ngoal (3 subgoals):\n 1. {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<noteq> {}\n 2. bdd_above {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}\n 3. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "show \"bdd_above ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}", "using rho_le_x_Ax_imp_rho_le_rx[OF y]"], ["proof (prove)\nusing this:\n  le_vec (?\\<rho> *s pow_A_1 x) (A *v pow_A_1 x) \\<Longrightarrow>\n  ?\\<rho> \\<le> r (pow_A_1 x)\n\ngoal (1 subgoal):\n 1. bdd_above {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}", "by fast"], ["proof (state)\nthis:\n  bdd_above {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}\n\ngoal (2 subgoals):\n 1. {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<noteq> {}\n 2. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "show \"?A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<noteq> {}", "using rx_le_Ax[OF x]"], ["proof (prove)\nusing this:\n  le_vec (r x *s x) (A *v x)\n\ngoal (1 subgoal):\n 1. {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "fix rho"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "assume \"rho \\<in> ?A\""], ["proof (state)\nthis:\n  rho \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "hence \"le_vec (rho *s x) (A *v x)\""], ["proof (prove)\nusing this:\n  rho \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)}\n\ngoal (1 subgoal):\n 1. le_vec (rho *s x) (A *v x)", "by auto"], ["proof (state)\nthis:\n  le_vec (rho *s x) (A *v x)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "from le_vec_pow_A_1[OF this]"], ["proof (chain)\npicking this:\n  le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)", "have \"rho \\<in> ?B\""], ["proof (prove)\nusing this:\n  le_vec (rho *s pow_A_1 x) (A *v pow_A_1 x)\n\ngoal (1 subgoal):\n 1. rho \\<in> {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}", "by auto"], ["proof (state)\nthis:\n  rho \\<in> {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> {\\<rho>. le_vec (\\<rho> *s x) (A *v x)} \\<Longrightarrow>\n       \\<exists>a\\<in>{\\<rho>.\n                       le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n          b \\<le> a", "thus \"\\<exists> rho' \\<in> ?B. rho \\<le> rho'\""], ["proof (prove)\nusing this:\n  rho \\<in> {\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}\n\ngoal (1 subgoal):\n 1. \\<exists>rho'\n             \\<in>{\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n       rho \\<le> rho'", "by auto"], ["proof (state)\nthis:\n  \\<exists>rho'\\<in>{\\<rho>. le_vec (\\<rho> *s pow_A_1 x) (A *v pow_A_1 x)}.\n     rho \\<le> rho'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r x \\<le> r (pow_A_1 x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sr_max: assumes x: \"x \\<in> X\" \n  shows \"r x \\<le> sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x \\<le> sr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r x \\<le> sr", "let ?n = \"norm x\""], ["proof (state)\ngoal (1 subgoal):\n 1. r x \\<le> sr", "define x' where \"x' = inverse ?n *s x\""], ["proof (state)\nthis:\n  x' = inverse (norm x) *s x\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "from x[unfolded X_def]"], ["proof (chain)\npicking this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "have x0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "hence n: \"?n > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < norm x", "by auto"], ["proof (state)\nthis:\n  0 < norm x\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "have x': \"x' \\<in> X1\" \"x' \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> X1 &&& x' \\<in> X", "using x n"], ["proof (prove)\nusing this:\n  x \\<in> X\n  0 < norm x\n\ngoal (1 subgoal):\n 1. x' \\<in> X1 &&& x' \\<in> X", "unfolding X1_def X_def x'_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n  0 < norm x\n\ngoal (1 subgoal):\n 1. inverse (norm x) *s x\n    \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0} \\<inter> {x. norm x = 1} &&&\n    inverse (norm x) *s x \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by (auto simp: norm_smult)"], ["proof (state)\nthis:\n  x' \\<in> X1\n  x' \\<in> X\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "have id: \"r x = r x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x = r x'", "unfolding x'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r x = r (inverse (norm x) *s x)", "by (rule sym, rule r_smult[OF x], insert n, auto)"], ["proof (state)\nthis:\n  r x = r x'\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "define y where \"y = pow_A_1 x'\""], ["proof (state)\nthis:\n  y = pow_A_1 x'\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "from x'"], ["proof (chain)\npicking this:\n  x' \\<in> X1\n  x' \\<in> X", "have y: \"y \\<in> Y\""], ["proof (prove)\nusing this:\n  x' \\<in> X1\n  x' \\<in> X\n\ngoal (1 subgoal):\n 1. y \\<in> Y", "unfolding Y_def y_def"], ["proof (prove)\nusing this:\n  x' \\<in> X1\n  x' \\<in> X\n\ngoal (1 subgoal):\n 1. pow_A_1 x' \\<in> pow_A_1 ` X1", "by auto"], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "note id"], ["proof (state)\nthis:\n  r x = r x'\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "also"], ["proof (state)\nthis:\n  r x = r x'\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "have \"r x' \\<le> r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x' \\<le> r y", "using r_pow_A_1[OF x'(2)]"], ["proof (prove)\nusing this:\n  r x' \\<le> r (pow_A_1 x')\n\ngoal (1 subgoal):\n 1. r x' \\<le> r y", "unfolding y_def"], ["proof (prove)\nusing this:\n  r x' \\<le> r (pow_A_1 x')\n\ngoal (1 subgoal):\n 1. r x' \\<le> r (pow_A_1 x')", "."], ["proof (state)\nthis:\n  r x' \\<le> r y\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "also"], ["proof (state)\nthis:\n  r x' \\<le> r y\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "have \"\\<dots> \\<le> r z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r y \\<le> sr", "using sr_max_Y[OF y]"], ["proof (prove)\nusing this:\n  r y \\<le> sr\n\ngoal (1 subgoal):\n 1. r y \\<le> sr", "."], ["proof (state)\nthis:\n  r y \\<le> sr\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "finally"], ["proof (chain)\npicking this:\n  r x \\<le> sr", "show \"r x \\<le> r z\""], ["proof (prove)\nusing this:\n  r x \\<le> sr\n\ngoal (1 subgoal):\n 1. r x \\<le> sr", "."], ["proof (state)\nthis:\n  r x \\<le> sr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma z_pos: \"z $ i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < z $h i", "using Y_pos[OF z(1)]"], ["proof (prove)\nusing this:\n  0 < z $h ?i\n\ngoal (1 subgoal):\n 1. 0 < z $h i", "by auto"], ["", "lemma sr_pos: \"sr > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sr", "by (rule rx_pos, insert z_pos, auto)"], ["", "context fixes u\n  assumes u: \"u \\<in> X\" and ru: \"r u = sr\" \nbegin"], ["", "lemma sr_imp_eigen_vector_main: \"sr *s u = A *v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr *s u = A *v u", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "assume *: \"sr *s u \\<noteq> A *v u\""], ["proof (state)\nthis:\n  sr *s u \\<noteq> A *v u\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "let ?x = \"A *v u - sr *s u\""], ["proof (state)\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  sr *s u \\<noteq> A *v u", "have 0: \"?x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sr *s u \\<noteq> A *v u\n\ngoal (1 subgoal):\n 1. A *v u - sr *s u \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  A *v u - sr *s u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "let ?y = \"pow_A_1 u\""], ["proof (state)\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "have \"le_vec (sr *s u) (A *v u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (sr *s u) (A *v u)", "using rx_le_Ax[OF u]"], ["proof (prove)\nusing this:\n  le_vec (r u *s u) (A *v u)\n\ngoal (1 subgoal):\n 1. le_vec (sr *s u) (A *v u)", "unfolding ru"], ["proof (prove)\nusing this:\n  le_vec (sr *s u) (A *v u)\n\ngoal (1 subgoal):\n 1. le_vec (sr *s u) (A *v u)", "."], ["proof (state)\nthis:\n  le_vec (sr *s u) (A *v u)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "hence le: \"le_vec 0 ?x\""], ["proof (prove)\nusing this:\n  le_vec (sr *s u) (A *v u)\n\ngoal (1 subgoal):\n 1. le_vec 0 (A *v u - sr *s u)", "by auto"], ["proof (state)\nthis:\n  le_vec 0 (A *v u - sr *s u)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "from 0 le"], ["proof (chain)\npicking this:\n  A *v u - sr *s u \\<noteq> 0\n  le_vec 0 (A *v u - sr *s u)", "have x: \"?x \\<in> X\""], ["proof (prove)\nusing this:\n  A *v u - sr *s u \\<noteq> 0\n  le_vec 0 (A *v u - sr *s u)\n\ngoal (1 subgoal):\n 1. A *v u - sr *s u \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  A *v u - sr *s u \\<noteq> 0\n  le_vec 0 (A *v u - sr *s u)\n\ngoal (1 subgoal):\n 1. A *v u - sr *s u \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  A *v u - sr *s u \\<in> X\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "have y_pos: \"lt_vec 0 ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_vec 0 (pow_A_1 u)", "using Y_pos_main[of ?y] u"], ["proof (prove)\nusing this:\n  pow_A_1 u \\<in> pow_A_1 ` X \\<Longrightarrow> 0 < pow_A_1 u $h ?i\n  u \\<in> X\n\ngoal (1 subgoal):\n 1. lt_vec 0 (pow_A_1 u)", "by auto"], ["proof (state)\nthis:\n  lt_vec 0 (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "hence y: \"?y \\<in> X\""], ["proof (prove)\nusing this:\n  lt_vec 0 (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. pow_A_1 u \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  lt_vec 0 (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. pow_A_1 u \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  pow_A_1 u \\<in> X\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "from Y_pos_main[of \"pow_A_1 ?x\"] x"], ["proof (chain)\npicking this:\n  pow_A_1 (A *v u - sr *s u) \\<in> pow_A_1 ` X \\<Longrightarrow>\n  0 < pow_A_1 (A *v u - sr *s u) $h ?i\n  A *v u - sr *s u \\<in> X", "have \"lt_vec 0 (pow_A_1 ?x)\""], ["proof (prove)\nusing this:\n  pow_A_1 (A *v u - sr *s u) \\<in> pow_A_1 ` X \\<Longrightarrow>\n  0 < pow_A_1 (A *v u - sr *s u) $h ?i\n  A *v u - sr *s u \\<in> X\n\ngoal (1 subgoal):\n 1. lt_vec 0 (pow_A_1 (A *v u - sr *s u))", "by auto"], ["proof (state)\nthis:\n  lt_vec 0 (pow_A_1 (A *v u - sr *s u))\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "hence lt: \"lt_vec (sr *s ?y) (A *v ?y)\""], ["proof (prove)\nusing this:\n  lt_vec 0 (pow_A_1 (A *v u - sr *s u))\n\ngoal (1 subgoal):\n 1. lt_vec (sr *s pow_A_1 u) (A *v pow_A_1 u)", "unfolding pow_A_1_def matrix_vector_right_distrib_diff\n    matrix_vector_mul_assoc A1n_commute vector_smult_distrib"], ["proof (prove)\nusing this:\n  lt_vec 0 (A ** A1n *v u - sr *s (A1n *v u))\n\ngoal (1 subgoal):\n 1. lt_vec (sr *s (A1n *v u)) (A ** A1n *v u)", "by simp"], ["proof (state)\nthis:\n  lt_vec (sr *s pow_A_1 u) (A *v pow_A_1 u)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "let ?f = \"(\\<lambda> i. (A *v ?y - sr *s ?y) $ i / ?y $ i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "let ?U = \"UNIV :: 'n set\""], ["proof (state)\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "define eps where \"eps = Min (?f ` ?U)\""], ["proof (state)\nthis:\n  eps = (MIN i. (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "have U: \"finite (?f ` ?U)\" \"?f ` ?U \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (range\n       (\\<lambda>i.\n           (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i)) &&&\n    range\n     (\\<lambda>i.\n         (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i) \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  finite\n   (range\n     (\\<lambda>i. (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i))\n  range\n   (\\<lambda>i.\n       (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "have eps: \"eps > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eps", "unfolding eps_def Min_gr_iff[OF U]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball\n     (range\n       (\\<lambda>i.\n           (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i))\n     ((<) 0)", "using lt sr_pos y_pos"], ["proof (prove)\nusing this:\n  lt_vec (sr *s pow_A_1 u) (A *v pow_A_1 u)\n  0 < sr\n  lt_vec 0 (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. Ball\n     (range\n       (\\<lambda>i.\n           (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i))\n     ((<) 0)", "by auto"], ["proof (state)\nthis:\n  0 < eps\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "have le: \"le_vec ((sr + eps) *s ?y) (A *v ?y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec ((sr + eps) *s pow_A_1 u) (A *v pow_A_1 u)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "have \"((sr + eps) *s ?y) $ i = sr * ?y $ i + eps * ?y $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sr + eps) *s pow_A_1 u) $h i =\n    sr * pow_A_1 u $h i + eps * pow_A_1 u $h i", "by (simp add: comm_semiring_class.distrib)"], ["proof (state)\nthis:\n  ((sr + eps) *s pow_A_1 u) $h i =\n  sr * pow_A_1 u $h i + eps * pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "also"], ["proof (state)\nthis:\n  ((sr + eps) *s pow_A_1 u) $h i =\n  sr * pow_A_1 u $h i + eps * pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "have \"\\<dots> \\<le> sr * ?y $ i + ?f i * ?y $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr * pow_A_1 u $h i + eps * pow_A_1 u $h i\n    \\<le> sr * pow_A_1 u $h i +\n          (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i *\n          pow_A_1 u $h i", "proof (rule add_left_mono[OF mult_right_mono])"], ["proof (state)\ngoal (2 subgoals):\n 1. eps \\<le> (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i\n 2. 0 \\<le> pow_A_1 u $h i", "show \"0 \\<le> ?y $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> pow_A_1 u $h i", "using y_pos[rule_format, of i]"], ["proof (prove)\nusing this:\n  0 $h i < pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. 0 \\<le> pow_A_1 u $h i", "by auto"], ["proof (state)\nthis:\n  0 \\<le> pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. eps \\<le> (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i", "show \"eps \\<le> ?f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eps \\<le> (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i", "unfolding eps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN i. (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i)\n    \\<le> (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i", "by (rule Min_le, auto)"], ["proof (state)\nthis:\n  eps \\<le> (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sr * pow_A_1 u $h i + eps * pow_A_1 u $h i\n  \\<le> sr * pow_A_1 u $h i +\n        (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i *\n        pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "also"], ["proof (state)\nthis:\n  sr * pow_A_1 u $h i + eps * pow_A_1 u $h i\n  \\<le> sr * pow_A_1 u $h i +\n        (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i *\n        pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "have \"\\<dots> = (A *v ?y) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr * pow_A_1 u $h i +\n    (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i *\n    pow_A_1 u $h i =\n    (A *v pow_A_1 u) $h i", "using sr_pos y_pos[rule_format, of i]"], ["proof (prove)\nusing this:\n  0 < sr\n  0 $h i < pow_A_1 u $h i\n\ngoal (1 subgoal):\n 1. sr * pow_A_1 u $h i +\n    (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i *\n    pow_A_1 u $h i =\n    (A *v pow_A_1 u) $h i", "by simp"], ["proof (state)\nthis:\n  sr * pow_A_1 u $h i +\n  (A *v pow_A_1 u - sr *s pow_A_1 u) $h i / pow_A_1 u $h i *\n  pow_A_1 u $h i =\n  (A *v pow_A_1 u) $h i\n\ngoal (1 subgoal):\n 1. \\<And>i. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "finally"], ["proof (chain)\npicking this:\n  ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "show \"((sr + eps) *s ?y) $ i \\<le> (A *v ?y) $ i\""], ["proof (prove)\nusing this:\n  ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i\n\ngoal (1 subgoal):\n 1. ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i", "."], ["proof (state)\nthis:\n  ((sr + eps) *s pow_A_1 u) $h i \\<le> (A *v pow_A_1 u) $h i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  le_vec ((sr + eps) *s pow_A_1 u) (A *v pow_A_1 u)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "from rho_le_x_Ax_imp_rho_le_rx[OF y le]"], ["proof (chain)\npicking this:\n  sr + eps \\<le> r (pow_A_1 u)", "have \"r ?y \\<ge> sr + eps\""], ["proof (prove)\nusing this:\n  sr + eps \\<le> r (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. sr + eps \\<le> r (pow_A_1 u)", "."], ["proof (state)\nthis:\n  sr + eps \\<le> r (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. sr *s u \\<noteq> A *v u \\<Longrightarrow> False", "with sr_max[OF y] eps"], ["proof (chain)\npicking this:\n  r (pow_A_1 u) \\<le> sr\n  0 < eps\n  sr + eps \\<le> r (pow_A_1 u)", "show False"], ["proof (prove)\nusing this:\n  r (pow_A_1 u) \\<le> sr\n  0 < eps\n  sr + eps \\<le> r (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sr_imp_eigen_vector: \"eigen_vector A u sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector A u sr", "unfolding eigen_vector_def sr_imp_eigen_vector_main"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> 0 \\<and> A *v u = A *v u", "using u"], ["proof (prove)\nusing this:\n  u \\<in> X\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0 \\<and> A *v u = A *v u", "unfolding X_def"], ["proof (prove)\nusing this:\n  u \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. u \\<noteq> 0 \\<and> A *v u = A *v u", "by auto"], ["", "lemma sr_u_pos: \"lt_vec 0 u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_vec 0 u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lt_vec 0 u", "let ?y = \"pow_A_1 u\""], ["proof (state)\ngoal (1 subgoal):\n 1. lt_vec 0 u", "define n where \"n = N\""], ["proof (state)\nthis:\n  n = N\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "define c where \"c = (sr + 1)^N\""], ["proof (state)\nthis:\n  c = (sr + 1) ^ N\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "have c: \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c", "using sr_pos"], ["proof (prove)\nusing this:\n  0 < sr\n\ngoal (1 subgoal):\n 1. 0 < c", "unfolding c_def"], ["proof (prove)\nusing this:\n  0 < sr\n\ngoal (1 subgoal):\n 1. 0 < (sr + 1) ^ N", "by auto"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "have \"lt_vec 0 ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_vec 0 (pow_A_1 u)", "using Y_pos_main[of ?y] u"], ["proof (prove)\nusing this:\n  pow_A_1 u \\<in> pow_A_1 ` X \\<Longrightarrow> 0 < pow_A_1 u $h ?i\n  u \\<in> X\n\ngoal (1 subgoal):\n 1. lt_vec 0 (pow_A_1 u)", "by auto"], ["proof (state)\nthis:\n  lt_vec 0 (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "also"], ["proof (state)\nthis:\n  lt_vec 0 (pow_A_1 u)\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "have \"?y = A1n *v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow_A_1 u = A1n *v u", "unfolding pow_A_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A1n *v u = A1n *v u", ".."], ["proof (state)\nthis:\n  pow_A_1 u = A1n *v u\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "also"], ["proof (state)\nthis:\n  pow_A_1 u = A1n *v u\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "have \"\\<dots> = c *s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1n *v u = c *s u", "unfolding c_def A1n_def n_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat 1) n *v u = (sr + 1) ^ n *s u", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. matpow (A + mat 1) 0 *v u = (sr + 1) ^ 0 *s u\n 2. \\<And>n.\n       matpow (A + mat 1) n *v u = (sr + 1) ^ n *s u \\<Longrightarrow>\n       matpow (A + mat 1) (Suc n) *v u = (sr + 1) ^ Suc n *s u", "case (Suc n)"], ["proof (state)\nthis:\n  matpow (A + mat 1) n *v u = (sr + 1) ^ n *s u\n\ngoal (2 subgoals):\n 1. matpow (A + mat 1) 0 *v u = (sr + 1) ^ 0 *s u\n 2. \\<And>n.\n       matpow (A + mat 1) n *v u = (sr + 1) ^ n *s u \\<Longrightarrow>\n       matpow (A + mat 1) (Suc n) *v u = (sr + 1) ^ Suc n *s u", "then"], ["proof (chain)\npicking this:\n  matpow (A + mat 1) n *v u = (sr + 1) ^ n *s u", "show ?case"], ["proof (prove)\nusing this:\n  matpow (A + mat 1) n *v u = (sr + 1) ^ n *s u\n\ngoal (1 subgoal):\n 1. matpow (A + mat 1) (Suc n) *v u = (sr + 1) ^ Suc n *s u", "by (simp add: matrix_vector_mul_assoc[symmetric] algebra_simps vec.scale\n          sr_imp_eigen_vector_main[symmetric])"], ["proof (state)\nthis:\n  matpow (A + mat 1) (Suc n) *v u = (sr + 1) ^ Suc n *s u\n\ngoal (1 subgoal):\n 1. matpow (A + mat 1) 0 *v u = (sr + 1) ^ 0 *s u", "qed auto"], ["proof (state)\nthis:\n  A1n *v u = c *s u\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "finally"], ["proof (chain)\npicking this:\n  lt_vec 0 (c *s u)", "have lt: \"lt_vec 0 (c *s u)\""], ["proof (prove)\nusing this:\n  lt_vec 0 (c *s u)\n\ngoal (1 subgoal):\n 1. lt_vec 0 (c *s u)", "."], ["proof (state)\nthis:\n  lt_vec 0 (c *s u)\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "have \"0 < u $ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < u $h i", "using lt[rule_format, of i] c"], ["proof (prove)\nusing this:\n  0 $h i < (c *s u) $h i\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < u $h i", "by simp (metis zero_less_mult_pos)"], ["proof (state)\nthis:\n  0 < u $h ?i\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "thus \"lt_vec 0 u\""], ["proof (prove)\nusing this:\n  0 < u $h ?i\n\ngoal (1 subgoal):\n 1. lt_vec 0 u", "by simp"], ["proof (state)\nthis:\n  lt_vec 0 u\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma eigen_vector_z_sr: \"eigen_vector A z sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector A z sr", "using sr_imp_eigen_vector[OF zX refl]"], ["proof (prove)\nusing this:\n  eigen_vector A z sr\n\ngoal (1 subgoal):\n 1. eigen_vector A z sr", "by auto"], ["", "lemma eigen_value_sr: \"eigen_value A sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value A sr", "using eigen_vector_z_sr"], ["proof (prove)\nusing this:\n  eigen_vector A z sr\n\ngoal (1 subgoal):\n 1. eigen_value A sr", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  eigen_vector A z sr\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigen_vector A v sr", "by auto"], ["", "abbreviation \"c \\<equiv> complex_of_real\""], ["", "abbreviation \"cA \\<equiv> map_matrix c A\""], ["", "abbreviation \"norm_v \\<equiv> map_vector (norm :: complex \\<Rightarrow> real)\""], ["", "lemma norm_v_ge_0: \"le_vec 0 (norm_v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec 0 (map_vector cmod v)", "by (auto simp: map_vector_def)"], ["", "lemma norm_v_eq_0: \"norm_v v = 0 \\<longleftrightarrow> v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_vector cmod v = 0) = (v = 0)", "by (auto simp: map_vector_def vec_eq_iff)"], ["", "lemma cA_index: \"cA $ i $ j = c (A $ i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cA $h i $h j = complex_of_real (A $h i $h j)", "unfolding map_matrix_def map_vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i ia. complex_of_real (A $h i $h ia)) $h i $h j =\n    complex_of_real (A $h i $h j)", "by simp"], ["", "lemma norm_cA[simp]: \"norm (cA $ i $ j) = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (cA $h i $h j) = A $h i $h j", "using nonneg[of i j]"], ["proof (prove)\nusing this:\n  0 \\<le> A $h i $h j\n\ngoal (1 subgoal):\n 1. cmod (cA $h i $h j) = A $h i $h j", "by (simp add: cA_index)"], ["", "context fixes \\<alpha> v\n  assumes ev: \"eigen_vector cA v \\<alpha>\" \nbegin"], ["", "lemma evD: \"\\<alpha> *s v = cA *v v\" \"v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> *s v = cA *v v &&& v \\<noteq> 0", "using ev[unfolded eigen_vector_def]"], ["proof (prove)\nusing this:\n  v \\<noteq> 0 \\<and> cA *v v = \\<alpha> *s v\n\ngoal (1 subgoal):\n 1. \\<alpha> *s v = cA *v v &&& v \\<noteq> 0", "by auto"], ["", "lemma ev_alpha_norm_v: \"norm_v (\\<alpha> *s v) = (norm \\<alpha> *s norm_v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector cmod (\\<alpha> *s v) = cmod \\<alpha> *s map_vector cmod v", "by (auto simp: map_vector_def norm_mult vec_eq_iff)"], ["", "lemma ev_A_norm_v: \"norm_v (cA *v v) $ j \\<le> (A *v norm_v v) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "have \"norm_v (cA *v v) $ j = norm (\\<Sum>i\\<in>UNIV. cA $ j $ i * v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j =\n    cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)", "unfolding map_vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. cmod ((cA *v v) $h i)) $h j =\n    cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)", "by (simp add: matrix_vector_mult_def)"], ["proof (state)\nthis:\n  map_vector cmod (cA *v v) $h j =\n  cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "also"], ["proof (state)\nthis:\n  map_vector cmod (cA *v v) $h j =\n  cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "have \"\\<dots> \\<le> (\\<Sum>i\\<in>UNIV. norm (cA $ j $ i * v $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)\n    \\<le> (\\<Sum>i\\<in>UNIV. cmod (cA $h j $h i * v $h i))", "by (rule norm_sum)"], ["proof (state)\nthis:\n  cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)\n  \\<le> (\\<Sum>i\\<in>UNIV. cmod (cA $h j $h i * v $h i))\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "also"], ["proof (state)\nthis:\n  cmod (\\<Sum>i\\<in>UNIV. cA $h j $h i * v $h i)\n  \\<le> (\\<Sum>i\\<in>UNIV. cmod (cA $h j $h i * v $h i))\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "have \"\\<dots> = (\\<Sum>i\\<in>UNIV. A $ j $ i * norm_v v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. cmod (cA $h j $h i * v $h i)) =\n    (\\<Sum>i\\<in>UNIV. A $h j $h i * map_vector cmod v $h i)", "by (rule sum.cong[OF refl], auto simp: norm_mult map_vector_def)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. cmod (cA $h j $h i * v $h i)) =\n  (\\<Sum>i\\<in>UNIV. A $h j $h i * map_vector cmod v $h i)\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. cmod (cA $h j $h i * v $h i)) =\n  (\\<Sum>i\\<in>UNIV. A $h j $h i * map_vector cmod v $h i)\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "have \"\\<dots> = (A *v norm_v v) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. A $h j $h i * map_vector cmod v $h i) =\n    (A *v map_vector cmod v) $h j", "by (simp add: matrix_vector_mult_def)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. A $h j $h i * map_vector cmod v $h i) =\n  (A *v map_vector cmod v) $h j\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "finally"], ["proof (chain)\npicking this:\n  map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "show ?thesis"], ["proof (prove)\nusing this:\n  map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j\n\ngoal (1 subgoal):\n 1. map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j", "."], ["proof (state)\nthis:\n  map_vector cmod (cA *v v) $h j \\<le> (A *v map_vector cmod v) $h j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ev_le_vec: \"le_vec (norm \\<alpha> *s norm_v v) (A *v norm_v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (cmod \\<alpha> *s map_vector cmod v) (A *v map_vector cmod v)", "using arg_cong[OF evD(1), of norm_v, unfolded ev_alpha_norm_v] ev_A_norm_v"], ["proof (prove)\nusing this:\n  cmod \\<alpha> *s map_vector cmod v = map_vector cmod (cA *v v)\n  map_vector cmod (cA *v v) $h ?j \\<le> (A *v map_vector cmod v) $h ?j\n\ngoal (1 subgoal):\n 1. le_vec (cmod \\<alpha> *s map_vector cmod v) (A *v map_vector cmod v)", "by auto"], ["", "lemma norm_v_X: \"norm_v v \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector cmod v \\<in> X", "using norm_v_ge_0[of v] evD(2) norm_v_eq_0[of v]"], ["proof (prove)\nusing this:\n  le_vec 0 (map_vector cmod v)\n  v \\<noteq> 0\n  (map_vector cmod v = 0) = (v = 0)\n\ngoal (1 subgoal):\n 1. map_vector cmod v \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  le_vec 0 (map_vector cmod v)\n  v \\<noteq> 0\n  (map_vector cmod v = 0) = (v = 0)\n\ngoal (1 subgoal):\n 1. map_vector cmod v \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by auto"], ["", "lemma ev_inequalities: \"norm \\<alpha> \\<le> r (norm_v v)\" \"r (norm_v v) \\<le> sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> r (map_vector cmod v) &&&\n    r (map_vector cmod v) \\<le> sr", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. cmod \\<alpha> \\<le> r (map_vector cmod v)\n 2. r (map_vector cmod v) \\<le> sr", "have v: \"norm_v v \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector cmod v \\<in> X", "by (rule norm_v_X)"], ["proof (state)\nthis:\n  map_vector cmod v \\<in> X\n\ngoal (2 subgoals):\n 1. cmod \\<alpha> \\<le> r (map_vector cmod v)\n 2. r (map_vector cmod v) \\<le> sr", "from rho_le_x_Ax_imp_rho_le_rx[OF v ev_le_vec]"], ["proof (chain)\npicking this:\n  cmod \\<alpha> \\<le> r (map_vector cmod v)", "show \"norm \\<alpha> \\<le> r (norm_v v)\""], ["proof (prove)\nusing this:\n  cmod \\<alpha> \\<le> r (map_vector cmod v)\n\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> r (map_vector cmod v)", "."], ["proof (state)\nthis:\n  cmod \\<alpha> \\<le> r (map_vector cmod v)\n\ngoal (1 subgoal):\n 1. r (map_vector cmod v) \\<le> sr", "from sr_max[OF v]"], ["proof (chain)\npicking this:\n  r (map_vector cmod v) \\<le> sr", "show \"r (norm_v v) \\<le> sr\""], ["proof (prove)\nusing this:\n  r (map_vector cmod v) \\<le> sr\n\ngoal (1 subgoal):\n 1. r (map_vector cmod v) \\<le> sr", "."], ["proof (state)\nthis:\n  r (map_vector cmod v) \\<le> sr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eigen_vector_norm_sr: \"norm \\<alpha> \\<le> sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> sr", "using ev_inequalities"], ["proof (prove)\nusing this:\n  cmod \\<alpha> \\<le> r (map_vector cmod v)\n  r (map_vector cmod v) \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> sr", "by auto"], ["", "end"], ["", "lemma eigen_value_norm_sr: assumes \"eigen_value cA \\<alpha>\" \n  shows \"norm \\<alpha> \\<le> sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> sr", "using eigen_vector_norm_sr[of _ \\<alpha>] assms"], ["proof (prove)\nusing this:\n  eigen_vector cA ?v \\<alpha> \\<Longrightarrow> cmod \\<alpha> \\<le> sr\n  eigen_value cA \\<alpha>\n\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> sr", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  eigen_vector cA ?v \\<alpha> \\<Longrightarrow> cmod \\<alpha> \\<le> sr\n  \\<exists>v. eigen_vector cA v \\<alpha>\n\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> sr", "by auto"], ["", "lemma le_vec_trans: \"le_vec x y \\<Longrightarrow> le_vec y u \\<Longrightarrow> le_vec x u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_vec x y; le_vec y u\\<rbrakk> \\<Longrightarrow> le_vec x u", "using order.trans[of \"x $ i\" \"y $ i\" \"u $ i\" for i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x $h ?i2 \\<le> y $h ?i2; y $h ?i2 \\<le> u $h ?i2\\<rbrakk>\n  \\<Longrightarrow> x $h ?i2 \\<le> u $h ?i2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>le_vec x y; le_vec y u\\<rbrakk> \\<Longrightarrow> le_vec x u", "by auto"], ["", "lemma eigen_vector_z_sr_c: \"eigen_vector cA (map_vector c z) (c sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)", "unfolding of_real_hom.eigen_vector_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_vector A z sr", "by (rule eigen_vector_z_sr)"], ["", "lemma eigen_value_sr_c: \"eigen_value cA (c sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value cA (complex_of_real sr)", "using eigen_vector_z_sr_c"], ["proof (prove)\nusing this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. eigen_value cA (complex_of_real sr)", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigen_vector cA v (complex_of_real sr)", "by auto"], ["", "definition \"w = perron_frobenius.z (transpose A)\""], ["", "lemma w: \"transpose A *v w = sr *s w\" \"lt_vec 0 w\" \"perron_frobenius.sr (transpose A) = sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w &&&\n    lt_vec 0 w &&&\n    perron_frobenius.r (Finite_Cartesian_Product.transpose A)\n     (perron_frobenius.z (Finite_Cartesian_Product.transpose A)) =\n    sr", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. lt_vec 0 w\n 3. perron_frobenius.r (Finite_Cartesian_Product.transpose A)\n     (perron_frobenius.z (Finite_Cartesian_Product.transpose A)) =\n    sr", "interpret t: perron_frobenius \"transpose A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perron_frobenius (Finite_Cartesian_Product.transpose A)", "by (rule pf_transpose)"], ["proof (state)\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "from eigen_vector_z_sr_c t.eigen_vector_z_sr_c"], ["proof (chain)\npicking this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n  eigen_vector t.cA (map_vector complex_of_real t.z) (complex_of_real t.sr)", "have ev: \"eigen_value cA (c sr)\" \"eigen_value t.cA (c t.sr)\""], ["proof (prove)\nusing this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n  eigen_vector t.cA (map_vector complex_of_real t.z) (complex_of_real t.sr)\n\ngoal (1 subgoal):\n 1. eigen_value cA (complex_of_real sr) &&&\n    eigen_value t.cA (complex_of_real t.sr)", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n  eigen_vector t.cA (map_vector complex_of_real t.z) (complex_of_real t.sr)\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigen_vector cA v (complex_of_real sr) &&&\n    \\<exists>v. eigen_vector t.cA v (complex_of_real t.sr)", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (complex_of_real sr)\n  eigen_value t.cA (complex_of_real t.sr)\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "{"], ["proof (state)\nthis:\n  eigen_value cA (complex_of_real sr)\n  eigen_value t.cA (complex_of_real t.sr)\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "have \"eigen_value (t.cA) x = eigen_value (transpose cA) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value t.cA x =\n    eigen_value (Finite_Cartesian_Product.transpose cA) x", "unfolding map_matrix_def map_vector_def transpose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value\n     (\\<chi>i ia. complex_of_real ((\\<chi>i j. A $h j $h i) $h i $h ia)) x =\n    eigen_value\n     (\\<chi>i j. (\\<chi>i ia. complex_of_real (A $h i $h ia)) $h j $h i) x", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  eigen_value t.cA x = eigen_value (Finite_Cartesian_Product.transpose cA) x\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "also"], ["proof (state)\nthis:\n  eigen_value t.cA x = eigen_value (Finite_Cartesian_Product.transpose cA) x\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "have \"\\<dots> = eigen_value cA x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value (Finite_Cartesian_Product.transpose cA) x = eigen_value cA x", "by (rule eigen_value_transpose)"], ["proof (state)\nthis:\n  eigen_value (Finite_Cartesian_Product.transpose cA) x = eigen_value cA x\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "finally"], ["proof (chain)\npicking this:\n  eigen_value t.cA x = eigen_value cA x", "have \"eigen_value (t.cA) x = eigen_value cA x\""], ["proof (prove)\nusing this:\n  eigen_value t.cA x = eigen_value cA x\n\ngoal (1 subgoal):\n 1. eigen_value t.cA x = eigen_value cA x", "."], ["proof (state)\nthis:\n  eigen_value t.cA x = eigen_value cA x\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "}"], ["proof (state)\nthis:\n  eigen_value t.cA ?x2 = eigen_value cA ?x2\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "note ev_id = this"], ["proof (state)\nthis:\n  eigen_value t.cA ?x2 = eigen_value cA ?x2\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "with ev"], ["proof (chain)\npicking this:\n  eigen_value cA (complex_of_real sr)\n  eigen_value t.cA (complex_of_real t.sr)\n  eigen_value t.cA ?x2 = eigen_value cA ?x2", "have ev: \"eigen_value t.cA (c sr)\" \"eigen_value cA (c t.sr)\""], ["proof (prove)\nusing this:\n  eigen_value cA (complex_of_real sr)\n  eigen_value t.cA (complex_of_real t.sr)\n  eigen_value t.cA ?x2 = eigen_value cA ?x2\n\ngoal (1 subgoal):\n 1. eigen_value t.cA (complex_of_real sr) &&&\n    eigen_value cA (complex_of_real t.sr)", "by auto"], ["proof (state)\nthis:\n  eigen_value t.cA (complex_of_real sr)\n  eigen_value cA (complex_of_real t.sr)\n\ngoal (3 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w\n 3. t.sr = sr", "from eigen_value_norm_sr[OF ev(2)] t.eigen_value_norm_sr[OF ev(1)]"], ["proof (chain)\npicking this:\n  cmod (complex_of_real t.sr) \\<le> sr\n  cmod (complex_of_real sr) \\<le> t.sr", "show id: \"t.sr = sr\""], ["proof (prove)\nusing this:\n  cmod (complex_of_real t.sr) \\<le> sr\n  cmod (complex_of_real sr) \\<le> t.sr\n\ngoal (1 subgoal):\n 1. t.sr = sr", "by auto"], ["proof (state)\nthis:\n  t.sr = sr\n\ngoal (2 subgoals):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w\n 2. t.lt_vec 0 w", "from t.eigen_vector_z_sr[unfolded id, folded w_def]"], ["proof (chain)\npicking this:\n  eigen_vector (Finite_Cartesian_Product.transpose A) w sr", "show \"transpose A *v w = sr *s w\""], ["proof (prove)\nusing this:\n  eigen_vector (Finite_Cartesian_Product.transpose A) w sr\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w", "unfolding eigen_vector_def"], ["proof (prove)\nusing this:\n  w \\<noteq> 0 \\<and> Finite_Cartesian_Product.transpose A *v w = sr *s w\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w", "by auto"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A *v w = sr *s w\n\ngoal (1 subgoal):\n 1. t.lt_vec 0 w", "from t.z_pos[folded w_def]"], ["proof (chain)\npicking this:\n  0 < w $h ?i", "show \"lt_vec 0 w\""], ["proof (prove)\nusing this:\n  0 < w $h ?i\n\ngoal (1 subgoal):\n 1. t.lt_vec 0 w", "by auto"], ["proof (state)\nthis:\n  t.lt_vec 0 w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_cmod_id: \"a \\<in> \\<real> \\<Longrightarrow> Re a \\<ge> 0 \\<Longrightarrow> c (cmod a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<real>; 0 \\<le> Re a\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (cmod a) = a", "by (auto simp: Reals_def)"], ["", "lemma pos_rowvector_mult_0: assumes lt: \"lt_vec 0 x\" \n  and 0: \"(rowvector x :: real ^ 'n ^ 'n) *v y = 0\" (is \"?x *v _ = 0\") and le: \"le_vec 0 y\" \nshows \"y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. y = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. y = 0", "assume \"y $ i \\<noteq> 0\""], ["proof (state)\nthis:\n  y $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y = 0", "with le"], ["proof (chain)\npicking this:\n  le_vec 0 y\n  y $h i \\<noteq> 0", "have yi: \"y $ i > 0\""], ["proof (prove)\nusing this:\n  le_vec 0 y\n  y $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  0 < y $h i\n\ngoal (1 subgoal):\n 1. y = 0", "have \"0 = (?x *v y) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (rowvector x *v y) $h i", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 $h i", "by simp"], ["proof (state)\nthis:\n  0 = (rowvector x *v y) $h i\n\ngoal (1 subgoal):\n 1. y = 0", "also"], ["proof (state)\nthis:\n  0 = (rowvector x *v y) $h i\n\ngoal (1 subgoal):\n 1. y = 0", "have \"\\<dots> = (\\<Sum>j\\<in>UNIV. x $ j * y $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rowvector x *v y) $h i = (\\<Sum>j\\<in>UNIV. x $h j * y $h j)", "unfolding rowvector_def matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        \\<Sum>j\\<in>UNIV.\n          (\\<chi>i. vec_lambda (($h) x)) $h i $h j * y $h j) $h\n    i =\n    (\\<Sum>j\\<in>UNIV. x $h j * y $h j)", "by simp"], ["proof (state)\nthis:\n  (rowvector x *v y) $h i = (\\<Sum>j\\<in>UNIV. x $h j * y $h j)\n\ngoal (1 subgoal):\n 1. y = 0", "also"], ["proof (state)\nthis:\n  (rowvector x *v y) $h i = (\\<Sum>j\\<in>UNIV. x $h j * y $h j)\n\ngoal (1 subgoal):\n 1. y = 0", "have \"\\<dots> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>j\\<in>UNIV. x $h j * y $h j)", "by (rule sum_pos2[of _ i], insert yi lt le, auto intro!: mult_nonneg_nonneg \n        simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  0 < (\\<Sum>j\\<in>UNIV. x $h j * y $h j)\n\ngoal (1 subgoal):\n 1. y = 0", "finally"], ["proof (chain)\npicking this:\n  0 < 0", "have False"], ["proof (prove)\nusing this:\n  0 < 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. y = 0", "}"], ["proof (state)\nthis:\n  y $h ?i2 \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. y = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  y $h ?i2 \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. y = 0", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  y = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_matrix_mult_0: assumes le: \"\\<And> i j. B $ i $ j \\<ge> 0\" \n  and lt: \"lt_vec 0 x\" \n  and 0: \"B *v x = 0\" \nshows \"B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 0", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 0", "assume \"B $ i $ j \\<noteq> 0\""], ["proof (state)\nthis:\n  B $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B = 0", "with le"], ["proof (chain)\npicking this:\n  0 \\<le> B $h ?i $h ?j\n  B $h i $h j \\<noteq> 0", "have gt: \"B $ i $ j > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> B $h ?i $h ?j\n  B $h i $h j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < B $h i $h j", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  0 < B $h i $h j\n\ngoal (1 subgoal):\n 1. B = 0", "have \"0 = (B *v x) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (B *v x) $h i", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 $h i", "by simp"], ["proof (state)\nthis:\n  0 = (B *v x) $h i\n\ngoal (1 subgoal):\n 1. B = 0", "also"], ["proof (state)\nthis:\n  0 = (B *v x) $h i\n\ngoal (1 subgoal):\n 1. B = 0", "have \"\\<dots> = (\\<Sum>j\\<in>UNIV. B $ i $ j * x $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B *v x) $h i = (\\<Sum>j\\<in>UNIV. B $h i $h j * x $h j)", "unfolding matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. B $h i $h j * x $h j) $h i =\n    (\\<Sum>j\\<in>UNIV. B $h i $h j * x $h j)", "by simp"], ["proof (state)\nthis:\n  (B *v x) $h i = (\\<Sum>j\\<in>UNIV. B $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. B = 0", "also"], ["proof (state)\nthis:\n  (B *v x) $h i = (\\<Sum>j\\<in>UNIV. B $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. B = 0", "have \"\\<dots> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>j\\<in>UNIV. B $h i $h j * x $h j)", "by (rule sum_pos2[of _ j], insert gt lt le, auto intro!: mult_nonneg_nonneg \n        simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  0 < (\\<Sum>j\\<in>UNIV. B $h i $h j * x $h j)\n\ngoal (1 subgoal):\n 1. B = 0", "finally"], ["proof (chain)\npicking this:\n  0 < 0", "have False"], ["proof (prove)\nusing this:\n  0 < 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. B = 0", "}"], ["proof (state)\nthis:\n  B $h ?i2 $h ?j2 \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. B = 0", "thus \"B = 0\""], ["proof (prove)\nusing this:\n  B $h ?i2 $h ?j2 \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. B = 0", "unfolding vec_eq_iff"], ["proof (prove)\nusing this:\n  B $h ?i2 $h ?j2 \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>i ia. B $h i $h ia = 0 $h i $h ia", "by auto"], ["proof (state)\nthis:\n  B = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eigen_value_smaller_matrix: assumes B: \"\\<And> i j. 0 \\<le> B $ i $ j \\<and> B $ i $ j \\<le> A $ i $ j\"\n  and AB: \"A \\<noteq> B\" \n  and ev: \"eigen_value (map_matrix c B) sigma\"\nshows \"cmod sigma < sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod sigma < sr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod sigma < sr", "let ?B = \"map_matrix c B\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod sigma < sr", "let ?sr = \"spectral_radius ?B\""], ["proof (state)\ngoal (1 subgoal):\n 1. cmod sigma < sr", "define \\<sigma> where \"\\<sigma> = ?sr\""], ["proof (state)\nthis:\n  \\<sigma> =\n  HMA_Connect.spectral_radius (HMA_Connect.map_matrix complex_of_real B)\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have \"real_non_neg_mat ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_non_neg_mat (HMA_Connect.map_matrix complex_of_real B)", "unfolding real_non_neg_mat_def elements_mat_h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>range\n                    (\\<lambda>(i, y).\n                        HMA_Connect.map_matrix complex_of_real B $h i $h y).\n       a \\<in> \\<real> \\<and> 0 \\<le> Re a", "by (auto simp: map_matrix_def map_vector_def B)"], ["proof (state)\nthis:\n  real_non_neg_mat (HMA_Connect.map_matrix complex_of_real B)\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from perron_frobenius[OF this, folded \\<sigma>_def]"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     eigen_vector (HMA_Connect.map_matrix complex_of_real B) v\n      (complex_of_real \\<sigma>) \\<and>\n     real_non_neg_vec v", "obtain x where ev_sr: \"eigen_vector ?B x (c \\<sigma>)\" \n    and rnn: \"real_non_neg_vec x\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     eigen_vector (HMA_Connect.map_matrix complex_of_real B) v\n      (complex_of_real \\<sigma>) \\<and>\n     real_non_neg_vec v\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>eigen_vector (HMA_Connect.map_matrix complex_of_real B) x\n                  (complex_of_real \\<sigma>);\n         real_non_neg_vec x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eigen_vector (HMA_Connect.map_matrix complex_of_real B) x\n   (complex_of_real \\<sigma>)\n  real_non_neg_vec x\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "define y where \"y = norm_v x\""], ["proof (state)\nthis:\n  y = map_vector cmod x\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from rnn"], ["proof (chain)\npicking this:\n  real_non_neg_vec x", "have xy: \"x = map_vector c y\""], ["proof (prove)\nusing this:\n  real_non_neg_vec x\n\ngoal (1 subgoal):\n 1. x = map_vector complex_of_real y", "unfolding real_non_neg_vec_def vec_elements_h_def y_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>range (($h) x). a \\<in> \\<real> \\<and> 0 \\<le> Re a\n\ngoal (1 subgoal):\n 1. x = map_vector complex_of_real (map_vector cmod x)", "by (auto simp: map_vector_def vec_eq_iff c_cmod_id)"], ["proof (state)\nthis:\n  x = map_vector complex_of_real y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from spectral_radius_max[OF ev, folded \\<sigma>_def]"], ["proof (chain)\npicking this:\n  cmod sigma \\<le> \\<sigma>", "have sigma_sigma: \"cmod sigma \\<le> \\<sigma>\""], ["proof (prove)\nusing this:\n  cmod sigma \\<le> \\<sigma>\n\ngoal (1 subgoal):\n 1. cmod sigma \\<le> \\<sigma>", "."], ["proof (state)\nthis:\n  cmod sigma \\<le> \\<sigma>\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from ev_sr[unfolded xy of_real_hom.eigen_vector_hom]"], ["proof (chain)\npicking this:\n  eigen_vector B y \\<sigma>", "have ev_B: \"eigen_vector B y \\<sigma>\""], ["proof (prove)\nusing this:\n  eigen_vector B y \\<sigma>\n\ngoal (1 subgoal):\n 1. eigen_vector B y \\<sigma>", "."], ["proof (state)\nthis:\n  eigen_vector B y \\<sigma>\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from ev_B[unfolded eigen_vector_def]"], ["proof (chain)\npicking this:\n  y \\<noteq> 0 \\<and> B *v y = \\<sigma> *s y", "have ev_B': \"B *v y = \\<sigma> *s y\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0 \\<and> B *v y = \\<sigma> *s y\n\ngoal (1 subgoal):\n 1. B *v y = \\<sigma> *s y", "by auto"], ["proof (state)\nthis:\n  B *v y = \\<sigma> *s y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have ypos: \"y $ i \\<ge> 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> y $h i", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> map_vector cmod x $h i", "by (auto simp: map_vector_def)"], ["proof (state)\nthis:\n  0 \\<le> y $h ?i\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from ev_B this"], ["proof (chain)\npicking this:\n  eigen_vector B y \\<sigma>\n  0 \\<le> y $h ?i", "have y: \"y \\<in> X\""], ["proof (prove)\nusing this:\n  eigen_vector B y \\<sigma>\n  0 \\<le> y $h ?i\n\ngoal (1 subgoal):\n 1. y \\<in> X", "unfolding eigen_vector_def X_def"], ["proof (prove)\nusing this:\n  y \\<noteq> 0 \\<and> B *v y = \\<sigma> *s y\n  0 \\<le> y $h ?i\n\ngoal (1 subgoal):\n 1. y \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have BA: \"(B *v y) $ i \\<le> (A *v y) $ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (B *v y) $h i \\<le> (A *v y) $h i", "unfolding matrix_vector_mult_def vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. B $h i $h j * y $h j)\n    \\<le> (\\<Sum>j\\<in>UNIV. A $h i $h j * y $h j)", "by (rule sum_mono, rule mult_right_mono, insert B ypos, auto)"], ["proof (state)\nthis:\n  (B *v y) $h ?i \\<le> (A *v y) $h ?i\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "hence le_vec: \"le_vec (\\<sigma> *s y) (A *v y)\""], ["proof (prove)\nusing this:\n  (B *v y) $h ?i \\<le> (A *v y) $h ?i\n\ngoal (1 subgoal):\n 1. le_vec (\\<sigma> *s y) (A *v y)", "unfolding ev_B'"], ["proof (prove)\nusing this:\n  (\\<sigma> *s y) $h ?i \\<le> (A *v y) $h ?i\n\ngoal (1 subgoal):\n 1. le_vec (\\<sigma> *s y) (A *v y)", "by auto"], ["proof (state)\nthis:\n  le_vec (\\<sigma> *s y) (A *v y)\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from rho_le_x_Ax_imp_rho_le_rx[OF y le_vec]"], ["proof (chain)\npicking this:\n  \\<sigma> \\<le> r y", "have \"\\<sigma> \\<le> r y\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<le> r y\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<le> r y", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<le> r y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "also"], ["proof (state)\nthis:\n  \\<sigma> \\<le> r y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have \"\\<dots> \\<le> sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r y \\<le> sr", "using y"], ["proof (prove)\nusing this:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. r y \\<le> sr", "by (rule sr_max)"], ["proof (state)\nthis:\n  r y \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "finally"], ["proof (chain)\npicking this:\n  \\<sigma> \\<le> sr", "have sig_le_sr: \"\\<sigma> \\<le> sr\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<le> sr\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<le> sr", "."], ["proof (state)\nthis:\n  \\<sigma> \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "{"], ["proof (state)\nthis:\n  \\<sigma> \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "assume \"\\<sigma> = sr\""], ["proof (state)\nthis:\n  \\<sigma> = sr\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "hence r_sr: \"r y = sr\" and sr_sig: \"sr = \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<sigma> = sr\n\ngoal (1 subgoal):\n 1. r y = sr &&& sr = \\<sigma>", "using \\<open>\\<sigma> \\<le> r y\\<close> \\<open>r y \\<le> sr\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> = sr\n  \\<sigma> \\<le> r y\n  r y \\<le> sr\n\ngoal (1 subgoal):\n 1. r y = sr &&& sr = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  r y = sr\n  sr = \\<sigma>\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from sr_u_pos[OF y r_sr]"], ["proof (chain)\npicking this:\n  lt_vec 0 y", "have pos: \"lt_vec 0 y\""], ["proof (prove)\nusing this:\n  lt_vec 0 y\n\ngoal (1 subgoal):\n 1. lt_vec 0 y", "."], ["proof (state)\nthis:\n  lt_vec 0 y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from sr_imp_eigen_vector[OF y r_sr]"], ["proof (chain)\npicking this:\n  eigen_vector A y sr", "have ev': \"eigen_vector A y sr\""], ["proof (prove)\nusing this:\n  eigen_vector A y sr\n\ngoal (1 subgoal):\n 1. eigen_vector A y sr", "."], ["proof (state)\nthis:\n  eigen_vector A y sr\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have \"(A - B) *v y = A *v y - B *v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) *v y = A *v y - B *v y", "unfolding matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. \\<Sum>j\\<in>UNIV. (A - B) $h i $h j * y $h j) =\n    (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * y $h j) -\n    (\\<chi>i. \\<Sum>j\\<in>UNIV. B $h i $h j * y $h j)", "by (auto simp: vec_eq_iff field_simps sum_subtractf)"], ["proof (state)\nthis:\n  (A - B) *v y = A *v y - B *v y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "also"], ["proof (state)\nthis:\n  (A - B) *v y = A *v y - B *v y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have \"A *v y = sr *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v y = sr *s y", "using ev'[unfolded eigen_vector_def]"], ["proof (prove)\nusing this:\n  y \\<noteq> 0 \\<and> A *v y = sr *s y\n\ngoal (1 subgoal):\n 1. A *v y = sr *s y", "by auto"], ["proof (state)\nthis:\n  A *v y = sr *s y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "also"], ["proof (state)\nthis:\n  A *v y = sr *s y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "have \"B *v y = sr *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *v y = sr *s y", "unfolding ev_B' sr_sig"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> *s y = \\<sigma> *s y", ".."], ["proof (state)\nthis:\n  B *v y = sr *s y\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "finally"], ["proof (chain)\npicking this:\n  (A - B) *v y = sr *s y - sr *s y", "have id: \"(A - B) *v y = 0\""], ["proof (prove)\nusing this:\n  (A - B) *v y = sr *s y - sr *s y\n\ngoal (1 subgoal):\n 1. (A - B) *v y = 0", "by simp"], ["proof (state)\nthis:\n  (A - B) *v y = 0\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "from pos_matrix_mult_0[OF _ pos id] assms(1-2)"], ["proof (chain)\npicking this:\n  (\\<And>i j. 0 \\<le> (A - B) $h i $h j) \\<Longrightarrow> A - B = 0\n  0 \\<le> B $h ?i $h ?j \\<and> B $h ?i $h ?j \\<le> A $h ?i $h ?j\n  A \\<noteq> B", "have False"], ["proof (prove)\nusing this:\n  (\\<And>i j. 0 \\<le> (A - B) $h i $h j) \\<Longrightarrow> A - B = 0\n  0 \\<le> B $h ?i $h ?j \\<and> B $h ?i $h ?j \\<le> A $h ?i $h ?j\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "}"], ["proof (state)\nthis:\n  \\<sigma> = sr \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "with sig_le_sr sigma_sigma"], ["proof (chain)\npicking this:\n  \\<sigma> \\<le> sr\n  cmod sigma \\<le> \\<sigma>\n  \\<sigma> = sr \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> \\<le> sr\n  cmod sigma \\<le> \\<sigma>\n  \\<sigma> = sr \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cmod sigma < sr", "by argo"], ["proof (state)\nthis:\n  cmod sigma < sr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma charpoly_erase_mat_sr: \"0 < poly (charpoly (erase_mat A i i)) sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "let ?A = \"erase_mat A i i\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "let ?pos = \"poly (charpoly ?A) sr\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from A_nonzero_fixed_j[of i]"], ["proof (chain)\npicking this:\n  \\<exists>ia. A $h ia $h i \\<noteq> 0", "obtain k where \"A $ k $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>ia. A $h ia $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        A $h k $h i \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $h k $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "assume \"A = ?A\""], ["proof (state)\nthis:\n  A = erase_mat A i i\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "hence \"A $ k $ i = ?A $ k $ i\""], ["proof (prove)\nusing this:\n  A = erase_mat A i i\n\ngoal (1 subgoal):\n 1. A $h k $h i = erase_mat A i i $h k $h i", "by simp"], ["proof (state)\nthis:\n  A $h k $h i = erase_mat A i i $h k $h i\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "also"], ["proof (state)\nthis:\n  A $h k $h i = erase_mat A i i $h k $h i\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "have \"?A $ k $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erase_mat A i i $h k $h i = 0", "by (auto simp: erase_mat_def)"], ["proof (state)\nthis:\n  erase_mat A i i $h k $h i = 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "also"], ["proof (state)\nthis:\n  erase_mat A i i $h k $h i = 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "have \"A $ k $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $h k $h i \\<noteq> 0", "by fact"], ["proof (state)\nthis:\n  A $h k $h i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "finally"], ["proof (chain)\npicking this:\n  A $h k $h i \\<noteq> A $h k $h i", "have False"], ["proof (prove)\nusing this:\n  A $h k $h i \\<noteq> A $h k $h i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "}"], ["proof (state)\nthis:\n  A = erase_mat A i i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "hence AA: \"A \\<noteq> ?A\""], ["proof (prove)\nusing this:\n  A = erase_mat A i i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. A \\<noteq> erase_mat A i i", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> erase_mat A i i\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "have le: \"0 \\<le> ?A $ i $ j \\<and> ?A $ i $ j \\<le> A $ i $ j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> erase_mat A i i $h i $h j \\<and>\n    erase_mat A i i $h i $h j \\<le> A $h i $h j", "by (auto simp: erase_mat_def nonneg)"], ["proof (state)\nthis:\n  0 \\<le> erase_mat A i i $h ?i $h ?j \\<and>\n  erase_mat A i i $h ?i $h ?j \\<le> A $h ?i $h ?j\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "note ev_small = eigen_value_smaller_matrix[OF le AA]"], ["proof (state)\nthis:\n  eigen_value (HMA_Connect.map_matrix complex_of_real (erase_mat A i i))\n   ?sigma \\<Longrightarrow>\n  cmod ?sigma < sr\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "{"], ["proof (state)\nthis:\n  eigen_value (HMA_Connect.map_matrix complex_of_real (erase_mat A i i))\n   ?sigma \\<Longrightarrow>\n  cmod ?sigma < sr\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "fix rho :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "assume \"eigen_value ?A rho\""], ["proof (state)\nthis:\n  eigen_value (erase_mat A i i) rho\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "hence ev: \"eigen_value (map_matrix c ?A) (c rho)\""], ["proof (prove)\nusing this:\n  eigen_value (erase_mat A i i) rho\n\ngoal (1 subgoal):\n 1. eigen_value (HMA_Connect.map_matrix complex_of_real (erase_mat A i i))\n     (complex_of_real rho)", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  \\<exists>v. eigen_vector (erase_mat A i i) v rho\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       eigen_vector\n        (HMA_Connect.map_matrix complex_of_real (erase_mat A i i)) v\n        (complex_of_real rho)", "using of_real_hom.eigen_vector_hom[of ?A _ rho]"], ["proof (prove)\nusing this:\n  \\<exists>v. eigen_vector (erase_mat A i i) v rho\n  eigen_vector (HMA_Connect.map_matrix of_real (erase_mat A i i))\n   (map_vector of_real ?v) (of_real rho) =\n  eigen_vector (erase_mat A i i) ?v rho\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       eigen_vector\n        (HMA_Connect.map_matrix complex_of_real (erase_mat A i i)) v\n        (complex_of_real rho)", "by auto"], ["proof (state)\nthis:\n  eigen_value (HMA_Connect.map_matrix complex_of_real (erase_mat A i i))\n   (complex_of_real rho)\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from ev_small[OF this]"], ["proof (chain)\npicking this:\n  cmod (complex_of_real rho) < sr", "have \"abs rho < sr\""], ["proof (prove)\nusing this:\n  cmod (complex_of_real rho) < sr\n\ngoal (1 subgoal):\n 1. \\<bar>rho\\<bar> < sr", "by auto"], ["proof (state)\nthis:\n  \\<bar>rho\\<bar> < sr\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "}"], ["proof (state)\nthis:\n  eigen_value (erase_mat A i i) ?rho2 \\<Longrightarrow>\n  \\<bar>?rho2\\<bar> < sr\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "note ev_small_real = this"], ["proof (state)\nthis:\n  eigen_value (erase_mat A i i) ?rho2 \\<Longrightarrow>\n  \\<bar>?rho2\\<bar> < sr\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "have pos0: \"?pos \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (charpoly (erase_mat A i i)) sr \\<noteq> 0", "using ev_small_real[of sr]"], ["proof (prove)\nusing this:\n  eigen_value (erase_mat A i i) sr \\<Longrightarrow> \\<bar>sr\\<bar> < sr\n\ngoal (1 subgoal):\n 1. poly (charpoly (erase_mat A i i)) sr \\<noteq> 0", "by (auto simp: eigen_value_root_charpoly)"], ["proof (state)\nthis:\n  poly (charpoly (erase_mat A i i)) sr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "{"], ["proof (state)\nthis:\n  poly (charpoly (erase_mat A i i)) sr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "define p where \"p = charpoly ?A\""], ["proof (state)\nthis:\n  p = charpoly (erase_mat A i i)\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "assume pos: \"?pos < 0\""], ["proof (state)\nthis:\n  poly (charpoly (erase_mat A i i)) sr < 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "hence neg: \"poly p sr < 0\""], ["proof (prove)\nusing this:\n  poly (charpoly (erase_mat A i i)) sr < 0\n\ngoal (1 subgoal):\n 1. poly p sr < 0", "unfolding p_def"], ["proof (prove)\nusing this:\n  poly (charpoly (erase_mat A i i)) sr < 0\n\ngoal (1 subgoal):\n 1. poly (charpoly (erase_mat A i i)) sr < 0", "by auto"], ["proof (state)\nthis:\n  poly p sr < 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from degree_monic_charpoly[of ?A]"], ["proof (chain)\npicking this:\n  degree (charpoly (erase_mat A i i)) = CARD('n) \\<and>\n  monic (charpoly (erase_mat A i i))", "have mon: \"monic p\" and deg: \"degree p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (charpoly (erase_mat A i i)) = CARD('n) \\<and>\n  monic (charpoly (erase_mat A i i))\n\ngoal (1 subgoal):\n 1. monic p &&& degree p \\<noteq> 0", "unfolding p_def"], ["proof (prove)\nusing this:\n  degree (charpoly (erase_mat A i i)) = CARD('n) \\<and>\n  monic (charpoly (erase_mat A i i))\n\ngoal (1 subgoal):\n 1. monic (charpoly (erase_mat A i i)) &&&\n    degree (charpoly (erase_mat A i i)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monic p\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "let ?f = \"poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "have cont: \"continuous_on {a..b} ?f\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (poly p)", "by (auto intro: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {?a..?b} (poly p)\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from pos"], ["proof (chain)\npicking this:\n  poly (charpoly (erase_mat A i i)) sr < 0", "have le: \"?f sr \\<le> 0\""], ["proof (prove)\nusing this:\n  poly (charpoly (erase_mat A i i)) sr < 0\n\ngoal (1 subgoal):\n 1. poly p sr \\<le> 0", "by (auto simp: p_def)"], ["proof (state)\nthis:\n  poly p sr \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from mon"], ["proof (chain)\npicking this:\n  monic p", "have lc: \"lead_coeff p > 0\""], ["proof (prove)\nusing this:\n  monic p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff p", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from poly_pinfty_ge[OF this deg, of 0]"], ["proof (chain)\npicking this:\n  \\<exists>n. \\<forall>x\\<ge>n. 0 \\<le> poly p x", "obtain z where lez: \"\\<And> x. z \\<le> x \\<Longrightarrow> 0 \\<le> ?f x\""], ["proof (prove)\nusing this:\n  \\<exists>n. \\<forall>x\\<ge>n. 0 \\<le> poly p x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        (\\<And>x.\n            z \\<le> x \\<Longrightarrow> 0 \\<le> poly p x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<le> ?x \\<Longrightarrow> 0 \\<le> poly p ?x\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "define y where \"y = max z sr\""], ["proof (state)\nthis:\n  y = max z sr\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "have yr: \"y \\<ge> sr\" and \"y \\<ge> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr \\<le> y &&& z \\<le> y", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sr \\<le> max z sr &&& z \\<le> max z sr", "by auto"], ["proof (state)\nthis:\n  sr \\<le> y\n  z \\<le> y\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from lez[OF this(2)]"], ["proof (chain)\npicking this:\n  0 \\<le> poly p y", "have y0: \"?f y \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> poly p y\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly p y", "."], ["proof (state)\nthis:\n  0 \\<le> poly p y\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from IVT'[of ?f, OF le y0 yr cont]"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>sr. x \\<le> y \\<and> poly p x = 0", "obtain x where ge: \"x \\<ge> sr\" and rt: \"?f x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>sr. x \\<le> y \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>sr \\<le> x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding p_def"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>sr.\n     x \\<le> y \\<and> poly (charpoly (erase_mat A i i)) x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>sr \\<le> x;\n         poly (charpoly (erase_mat A i i)) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sr \\<le> x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "hence \"eigen_value ?A x\""], ["proof (prove)\nusing this:\n  sr \\<le> x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. eigen_value (erase_mat A i i) x", "unfolding p_def"], ["proof (prove)\nusing this:\n  sr \\<le> x\n  poly (charpoly (erase_mat A i i)) x = 0\n\ngoal (1 subgoal):\n 1. eigen_value (erase_mat A i i) x", "by (simp add: eigen_value_root_charpoly)"], ["proof (state)\nthis:\n  eigen_value (erase_mat A i i) x\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "from ev_small_real[OF this] ge"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> < sr\n  sr \\<le> x", "have False"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < sr\n  sr \\<le> x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "}"], ["proof (state)\nthis:\n  poly (charpoly (erase_mat A i i)) sr < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "with pos0"], ["proof (chain)\npicking this:\n  poly (charpoly (erase_mat A i i)) sr \\<noteq> 0\n  poly (charpoly (erase_mat A i i)) sr < 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (charpoly (erase_mat A i i)) sr \\<noteq> 0\n  poly (charpoly (erase_mat A i i)) sr < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < poly (charpoly (erase_mat A i i)) sr", "by argo"], ["proof (state)\nthis:\n  0 < poly (charpoly (erase_mat A i i)) sr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiplicity_sr_1: \"order sr (charpoly A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "assume \"poly (pderiv (charpoly A)) sr = 0\""], ["proof (state)\nthis:\n  poly (pderiv (charpoly A)) sr = 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "hence \"0 = poly (monom 1 1 * pderiv (charpoly A)) sr\""], ["proof (prove)\nusing this:\n  poly (pderiv (charpoly A)) sr = 0\n\ngoal (1 subgoal):\n 1. 0 = poly (monom 1 1 * pderiv (charpoly A)) sr", "by simp"], ["proof (state)\nthis:\n  0 = poly (monom 1 1 * pderiv (charpoly A)) sr\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "also"], ["proof (state)\nthis:\n  0 = poly (monom 1 1 * pderiv (charpoly A)) sr\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "have \"\\<dots> = sum (\\<lambda> i. poly (charpoly (erase_mat A i i)) sr) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (monom 1 1 * pderiv (charpoly A)) sr =\n    (\\<Sum>i\\<in>UNIV. poly (charpoly (erase_mat A i i)) sr)", "unfolding pderiv_char_poly_erase_mat poly_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. poly (charpoly (erase_mat A k k)) sr) =\n    (\\<Sum>i\\<in>UNIV. poly (charpoly (erase_mat A i i)) sr)", ".."], ["proof (state)\nthis:\n  poly (monom 1 1 * pderiv (charpoly A)) sr =\n  (\\<Sum>i\\<in>UNIV. poly (charpoly (erase_mat A i i)) sr)\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "also"], ["proof (state)\nthis:\n  poly (monom 1 1 * pderiv (charpoly A)) sr =\n  (\\<Sum>i\\<in>UNIV. poly (charpoly (erase_mat A i i)) sr)\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "have \"\\<dots> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>i\\<in>UNIV. poly (charpoly (erase_mat A i i)) sr)", "by (rule sum_pos, (force simp: charpoly_erase_mat_sr)+)"], ["proof (state)\nthis:\n  0 < (\\<Sum>i\\<in>UNIV. poly (charpoly (erase_mat A i i)) sr)\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "finally"], ["proof (chain)\npicking this:\n  0 < 0", "have False"], ["proof (prove)\nusing this:\n  0 < 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "}"], ["proof (state)\nthis:\n  poly (pderiv (charpoly A)) sr = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "hence nZ: \"poly (pderiv (charpoly A)) sr \\<noteq> 0\" and nZ': \"pderiv (charpoly A) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (pderiv (charpoly A)) sr = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly (pderiv (charpoly A)) sr \\<noteq> 0 &&&\n    pderiv (charpoly A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (pderiv (charpoly A)) sr \\<noteq> 0\n  pderiv (charpoly A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "from eigen_vector_z_sr"], ["proof (chain)\npicking this:\n  eigen_vector A z sr", "have \"eigen_value A sr\""], ["proof (prove)\nusing this:\n  eigen_vector A z sr\n\ngoal (1 subgoal):\n 1. eigen_value A sr", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  eigen_vector A z sr\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigen_vector A v sr", ".."], ["proof (state)\nthis:\n  eigen_value A sr\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "from this[unfolded eigen_value_root_charpoly]"], ["proof (chain)\npicking this:\n  poly (charpoly A) sr = 0", "have \"poly (charpoly A) sr = 0\""], ["proof (prove)\nusing this:\n  poly (charpoly A) sr = 0\n\ngoal (1 subgoal):\n 1. poly (charpoly A) sr = 0", "."], ["proof (state)\nthis:\n  poly (charpoly A) sr = 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "hence \"order sr (charpoly A) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (charpoly A) sr = 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) \\<noteq> 0", "unfolding order_root"], ["proof (prove)\nusing this:\n  charpoly A = 0 \\<or> order sr (charpoly A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) \\<noteq> 0", "using nZ'"], ["proof (prove)\nusing this:\n  charpoly A = 0 \\<or> order sr (charpoly A) \\<noteq> 0\n  pderiv (charpoly A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order sr (charpoly A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "from order_pderiv[OF nZ' this] order_0I[OF nZ]"], ["proof (chain)\npicking this:\n  order sr (charpoly A) = Suc (order sr (pderiv (charpoly A)))\n  order sr (pderiv (charpoly A)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order sr (charpoly A) = Suc (order sr (pderiv (charpoly A)))\n  order sr (pderiv (charpoly A)) = 0\n\ngoal (1 subgoal):\n 1. order sr (charpoly A) = 1", "by simp"], ["proof (state)\nthis:\n  order sr (charpoly A) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sr_spectral_radius: \"sr = spectral_radius cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr = HMA_Connect.spectral_radius cA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sr = HMA_Connect.spectral_radius cA", "from eigen_vector_z_sr_c"], ["proof (chain)\npicking this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)", "have \"eigen_value cA (c sr)\""], ["proof (prove)\nusing this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. eigen_value cA (complex_of_real sr)", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  eigen_vector cA (map_vector complex_of_real z) (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigen_vector cA v (complex_of_real sr)", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (complex_of_real sr)\n\ngoal (1 subgoal):\n 1. sr = HMA_Connect.spectral_radius cA", "from spectral_radius_max[OF this]"], ["proof (chain)\npicking this:\n  cmod (complex_of_real sr) \\<le> HMA_Connect.spectral_radius cA", "have sr: \"sr \\<le> spectral_radius cA\""], ["proof (prove)\nusing this:\n  cmod (complex_of_real sr) \\<le> HMA_Connect.spectral_radius cA\n\ngoal (1 subgoal):\n 1. sr \\<le> HMA_Connect.spectral_radius cA", "by auto"], ["proof (state)\nthis:\n  sr \\<le> HMA_Connect.spectral_radius cA\n\ngoal (1 subgoal):\n 1. sr = HMA_Connect.spectral_radius cA", "with spectral_radius_ev[of cA] eigen_vector_norm_sr"], ["proof (chain)\npicking this:\n  \\<exists>ev v.\n     eigen_vector cA v ev \\<and> cmod ev = HMA_Connect.spectral_radius cA\n  eigen_vector cA ?v ?\\<alpha> \\<Longrightarrow> cmod ?\\<alpha> \\<le> sr\n  sr \\<le> HMA_Connect.spectral_radius cA", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ev v.\n     eigen_vector cA v ev \\<and> cmod ev = HMA_Connect.spectral_radius cA\n  eigen_vector cA ?v ?\\<alpha> \\<Longrightarrow> cmod ?\\<alpha> \\<le> sr\n  sr \\<le> HMA_Connect.spectral_radius cA\n\ngoal (1 subgoal):\n 1. sr = HMA_Connect.spectral_radius cA", "by force"], ["proof (state)\nthis:\n  sr = HMA_Connect.spectral_radius cA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_vec_A_mu: assumes y: \"y \\<in> X\" and le: \"le_vec (A *v y) (mu *s y)\" \n  shows \"sr \\<le> mu\" \"lt_vec 0 y\" \n  \"mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow> mu = sr \\<and> A *v y = mu *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr \\<le> mu &&&\n    lt_vec 0 y &&&\n    (mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n     mu = sr \\<and> A *v y = mu *s y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "let ?w = \"rowvector w\""], ["proof (state)\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "let ?w' = \"columnvector w\""], ["proof (state)\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"?w ** A = transpose (transpose (?w ** A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rowvector w ** A =\n    Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (rowvector w ** A))", "unfolding transpose_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. rowvector w ** A =\n    Finite_Cartesian_Product.transpose\n     (Finite_Cartesian_Product.transpose (rowvector w ** A))", "by simp"], ["proof (state)\nthis:\n  rowvector w ** A =\n  Finite_Cartesian_Product.transpose\n   (Finite_Cartesian_Product.transpose (rowvector w ** A))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  rowvector w ** A =\n  Finite_Cartesian_Product.transpose\n   (Finite_Cartesian_Product.transpose (rowvector w ** A))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"transpose (?w ** A) = transpose A ** transpose ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose (rowvector w ** A) =\n    Finite_Cartesian_Product.transpose A **\n    Finite_Cartesian_Product.transpose (rowvector w)", "by (rule matrix_transpose_mul)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose (rowvector w ** A) =\n  Finite_Cartesian_Product.transpose A **\n  Finite_Cartesian_Product.transpose (rowvector w)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose (rowvector w ** A) =\n  Finite_Cartesian_Product.transpose A **\n  Finite_Cartesian_Product.transpose (rowvector w)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"transpose ?w = columnvector w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose (rowvector w) = columnvector w", "by (rule transpose_rowvector)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose (rowvector w) = columnvector w\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose (rowvector w) = columnvector w\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"transpose A ** \\<dots> = columnvector (transpose A *v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** columnvector w =\n    columnvector (Finite_Cartesian_Product.transpose A *v w)", "unfolding dot_rowvector_columnvector[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. columnvector (Finite_Cartesian_Product.transpose A *v w) =\n    columnvector (Finite_Cartesian_Product.transpose A *v w)", ".."], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A ** columnvector w =\n  columnvector (Finite_Cartesian_Product.transpose A *v w)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A ** columnvector w =\n  columnvector (Finite_Cartesian_Product.transpose A *v w)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"transpose A *v w = sr *s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v w = sr *s w", "unfolding w"], ["proof (prove)\ngoal (1 subgoal):\n 1. sr *s w = sr *s w", "by simp"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A *v w = sr *s w\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A *v w = sr *s w\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"transpose (columnvector \\<dots>) = rowvector (sr *s w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose (columnvector (sr *s w)) =\n    rowvector (sr *s w)", "unfolding transpose_def columnvector_def rowvector_def vector_scalar_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. (\\<chi>i j. (\\<chi>i. sr * w $h i) $h i) $h j $h i) =\n    (\\<chi>i. vec_lambda (($h) (\\<chi>i. sr * w $h i)))", "by auto"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose (columnvector (sr *s w)) =\n  rowvector (sr *s w)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "finally"], ["proof (chain)\npicking this:\n  rowvector w ** A = rowvector (sr *s w)", "have 1: \"?w ** A = rowvector (sr *s w)\""], ["proof (prove)\nusing this:\n  rowvector w ** A = rowvector (sr *s w)\n\ngoal (1 subgoal):\n 1. rowvector w ** A = rowvector (sr *s w)", "."], ["proof (state)\nthis:\n  rowvector w ** A = rowvector (sr *s w)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"sr *s (?w *v y) = ?w ** A *v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr *s (rowvector w *v y) = rowvector w ** A *v y", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. sr *s (rowvector w *v y) = rowvector (sr *s w) *v y", "by (auto simp: rowvector_def vector_scalar_mult_def matrix_vector_mult_def vec_eq_iff\n       sum_distrib_left mult.assoc)"], ["proof (state)\nthis:\n  sr *s (rowvector w *v y) = rowvector w ** A *v y\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  sr *s (rowvector w *v y) = rowvector w ** A *v y\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"\\<dots> = ?w *v (A *v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rowvector w ** A *v y = rowvector w *v (A *v y)", "by (simp add: matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  rowvector w ** A *v y = rowvector w *v (A *v y)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "finally"], ["proof (chain)\npicking this:\n  sr *s (rowvector w *v y) = rowvector w *v (A *v y)", "have eq1: \"sr *s (rowvector w *v y) = rowvector w *v (A *v y)\""], ["proof (prove)\nusing this:\n  sr *s (rowvector w *v y) = rowvector w *v (A *v y)\n\ngoal (1 subgoal):\n 1. sr *s (rowvector w *v y) = rowvector w *v (A *v y)", "."], ["proof (state)\nthis:\n  sr *s (rowvector w *v y) = rowvector w *v (A *v y)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"le_vec (rowvector w *v (A *v y)) (?w *v (mu *s y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (rowvector w *v (A *v y)) (rowvector w *v (mu *s y))", "by (rule le_vec_mono_left[OF _ le], insert w(2), auto simp: rowvector_def order.strict_iff_order)"], ["proof (state)\nthis:\n  le_vec (rowvector w *v (A *v y)) (rowvector w *v (mu *s y))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "also"], ["proof (state)\nthis:\n  le_vec (rowvector w *v (A *v y)) (rowvector w *v (mu *s y))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"?w *v (mu *s y) = mu *s (?w *v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rowvector w *v (mu *s y) = mu *s (rowvector w *v y)", "by (simp add: algebra_simps vec.scale)"], ["proof (state)\nthis:\n  rowvector w *v (mu *s y) = mu *s (rowvector w *v y)\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "finally"], ["proof (chain)\npicking this:\n  le_vec (rowvector w *v (A *v y)) (mu *s (rowvector w *v y))", "have le1: \"le_vec (rowvector w *v (A *v y)) (mu *s (?w *v y))\""], ["proof (prove)\nusing this:\n  le_vec (rowvector w *v (A *v y)) (mu *s (rowvector w *v y))\n\ngoal (1 subgoal):\n 1. le_vec (rowvector w *v (A *v y)) (mu *s (rowvector w *v y))", "."], ["proof (state)\nthis:\n  le_vec (rowvector w *v (A *v y)) (mu *s (rowvector w *v y))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from le1[unfolded eq1[symmetric]]"], ["proof (chain)\npicking this:\n  le_vec (sr *s (rowvector w *v y)) (mu *s (rowvector w *v y))", "have 2: \"le_vec (sr *s (?w *v y)) (mu *s (?w *v y))\""], ["proof (prove)\nusing this:\n  le_vec (sr *s (rowvector w *v y)) (mu *s (rowvector w *v y))\n\ngoal (1 subgoal):\n 1. le_vec (sr *s (rowvector w *v y)) (mu *s (rowvector w *v y))", "."], ["proof (state)\nthis:\n  le_vec (sr *s (rowvector w *v y)) (mu *s (rowvector w *v y))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "{"], ["proof (state)\nthis:\n  le_vec (sr *s (rowvector w *v y)) (mu *s (rowvector w *v y))\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from y"], ["proof (chain)\npicking this:\n  y \\<in> X", "obtain i where yi: \"y $ i > 0\" and y: \"\\<And> j. y $ j \\<ge> 0\""], ["proof (prove)\nusing this:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>0 < y $h i; \\<And>j. 0 \\<le> y $h j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding X_def"], ["proof (prove)\nusing this:\n  y \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>0 < y $h i; \\<And>j. 0 \\<le> y $h j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: order.strict_iff_order vec_eq_iff)"], ["proof (state)\nthis:\n  0 < y $h i\n  0 \\<le> y $h ?j12\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from w(2)"], ["proof (chain)\npicking this:\n  lt_vec 0 w", "have wi: \"w $ i > 0\" and w: \"\\<And> j. w $ j \\<ge> 0\""], ["proof (prove)\nusing this:\n  lt_vec 0 w\n\ngoal (1 subgoal):\n 1. 0 < w $h i &&& (\\<And>j. 0 \\<le> w $h j)", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  0 < w $h i\n  0 \\<le> w $h ?j12\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"(?w *v y) $ i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (rowvector w *v y) $h i", "using yi y wi w"], ["proof (prove)\nusing this:\n  0 < y $h i\n  0 \\<le> y $h ?j12\n  0 < w $h i\n  0 \\<le> w $h ?j12\n\ngoal (1 subgoal):\n 1. 0 < (rowvector w *v y) $h i", "by (auto simp: matrix_vector_mult_def rowvector_def \n        intro!: sum_pos2[of _ i] mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  0 < (rowvector w *v y) $h i\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "moreover"], ["proof (state)\nthis:\n  0 < (rowvector w *v y) $h i\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from 2[rule_format, of i]"], ["proof (chain)\npicking this:\n  (sr *s (rowvector w *v y)) $h i \\<le> (mu *s (rowvector w *v y)) $h i", "have \"sr * (?w *v y) $ i \\<le> mu * (?w *v y) $ i\""], ["proof (prove)\nusing this:\n  (sr *s (rowvector w *v y)) $h i \\<le> (mu *s (rowvector w *v y)) $h i\n\ngoal (1 subgoal):\n 1. sr * (rowvector w *v y) $h i \\<le> mu * (rowvector w *v y) $h i", "by simp"], ["proof (state)\nthis:\n  sr * (rowvector w *v y) $h i \\<le> mu * (rowvector w *v y) $h i\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "ultimately"], ["proof (chain)\npicking this:\n  0 < (rowvector w *v y) $h i\n  sr * (rowvector w *v y) $h i \\<le> mu * (rowvector w *v y) $h i", "have \"sr \\<le> mu\""], ["proof (prove)\nusing this:\n  0 < (rowvector w *v y) $h i\n  sr * (rowvector w *v y) $h i \\<le> mu * (rowvector w *v y) $h i\n\ngoal (1 subgoal):\n 1. sr \\<le> mu", "by simp"], ["proof (state)\nthis:\n  sr \\<le> mu\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "}"], ["proof (state)\nthis:\n  sr \\<le> mu\n\ngoal (3 subgoals):\n 1. sr \\<le> mu\n 2. lt_vec 0 y\n 3. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "thus *: \"sr \\<le> mu\""], ["proof (prove)\nusing this:\n  sr \\<le> mu\n\ngoal (1 subgoal):\n 1. sr \\<le> mu", "."], ["proof (state)\nthis:\n  sr \\<le> mu\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "define cc where \"cc = (mu + 1)^ N\""], ["proof (state)\nthis:\n  cc = (mu + 1) ^ N\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "define n where \"n = N\""], ["proof (state)\nthis:\n  n = N\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from * sr_pos"], ["proof (chain)\npicking this:\n  sr \\<le> mu\n  0 < sr", "have mu: \"mu \\<ge> 0\" \"mu > 0\""], ["proof (prove)\nusing this:\n  sr \\<le> mu\n  0 < sr\n\ngoal (1 subgoal):\n 1. 0 \\<le> mu &&& 0 < mu", "by auto"], ["proof (state)\nthis:\n  0 \\<le> mu\n  0 < mu\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "hence cc: \"cc > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> mu\n  0 < mu\n\ngoal (1 subgoal):\n 1. 0 < cc", "unfolding cc_def"], ["proof (prove)\nusing this:\n  0 \\<le> mu\n  0 < mu\n\ngoal (1 subgoal):\n 1. 0 < (mu + 1) ^ N", "by simp"], ["proof (state)\nthis:\n  0 < cc\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from y"], ["proof (chain)\npicking this:\n  y \\<in> X", "have \"pow_A_1 y \\<in> pow_A_1 ` X\""], ["proof (prove)\nusing this:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. pow_A_1 y \\<in> pow_A_1 ` X", "by auto"], ["proof (state)\nthis:\n  pow_A_1 y \\<in> pow_A_1 ` X\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from Y_pos_main[OF this]"], ["proof (chain)\npicking this:\n  0 < pow_A_1 y $h ?i", "have lt: \"0 < (A1n *v y) $ i\" for i"], ["proof (prove)\nusing this:\n  0 < pow_A_1 y $h ?i\n\ngoal (1 subgoal):\n 1. 0 < (A1n *v y) $h i", "by (simp add: pow_A_1_def)"], ["proof (state)\nthis:\n  0 < (A1n *v y) $h ?i12\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have le: \"le_vec (A1n *v y) (cc *s y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (A1n *v y) (cc *s y)", "unfolding cc_def A1n_def n_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) n *v y) ((mu + 1) ^ n *s y)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "case (Suc n)"], ["proof (state)\nthis:\n  le_vec (matpow (A + mat 1) n *v y) ((mu + 1) ^ n *s y)\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "let ?An = \"matpow (A + mat 1) n\""], ["proof (state)\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "let ?mu = \"(mu + 1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "have id': \"matpow (A + mat 1) (Suc n) *v y = A *v (?An *v y) + ?An *v y\" (is \"?a = ?b + ?c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. matpow (A + mat 1) (Suc n) *v y =\n    A *v (matpow (A + mat 1) n *v y) + matpow (A + mat 1) n *v y", "by (simp add: matrix_add_ldistrib matrix_mul_rid matrix_add_vect_distrib matpow_1_commute\n       matrix_vector_mul_assoc[symmetric])"], ["proof (state)\nthis:\n  matpow (A + mat 1) (Suc n) *v y =\n  A *v (matpow (A + mat 1) n *v y) + matpow (A + mat 1) n *v y\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "have \"le_vec ?b (?mu^n *s (A *v y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n *s (A *v y))", "using le_vec_mono_left[OF nonneg Suc]"], ["proof (prove)\nusing this:\n  le_vec (A *v (matpow (A + mat 1) n *v y)) (A *v ((mu + 1) ^ n *s y))\n\ngoal (1 subgoal):\n 1. le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n *s (A *v y))", "by (simp add: algebra_simps vec.scale)"], ["proof (state)\nthis:\n  le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n *s (A *v y))\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "moreover"], ["proof (state)\nthis:\n  le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n *s (A *v y))\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "have \"le_vec (?mu^n *s (A *v y)) (?mu^n *s (mu *s y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec ((mu + 1) ^ n *s (A *v y)) ((mu + 1) ^ n *s (mu *s y))", "using le mu"], ["proof (prove)\nusing this:\n  le_vec (A *v y) (mu *s y)\n  0 \\<le> mu\n  0 < mu\n\ngoal (1 subgoal):\n 1. le_vec ((mu + 1) ^ n *s (A *v y)) ((mu + 1) ^ n *s (mu *s y))", "by auto"], ["proof (state)\nthis:\n  le_vec ((mu + 1) ^ n *s (A *v y)) ((mu + 1) ^ n *s (mu *s y))\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "moreover"], ["proof (state)\nthis:\n  le_vec ((mu + 1) ^ n *s (A *v y)) ((mu + 1) ^ n *s (mu *s y))\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "have id: \"?mu^n *s (mu *s y) = (?mu^n * mu) *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mu + 1) ^ n *s (mu *s y) = (mu + 1) ^ n * mu *s y", "by simp"], ["proof (state)\nthis:\n  (mu + 1) ^ n *s (mu *s y) = (mu + 1) ^ n * mu *s y\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "from le_vec_trans[OF calculation[unfolded id]]"], ["proof (chain)\npicking this:\n  le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n * mu *s y)", "have le1: \"le_vec ?b ((?mu^n * mu) *s y)\""], ["proof (prove)\nusing this:\n  le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n * mu *s y)\n\ngoal (1 subgoal):\n 1. le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n * mu *s y)", "."], ["proof (state)\nthis:\n  le_vec (A *v (matpow (A + mat 1) n *v y)) ((mu + 1) ^ n * mu *s y)\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "from Suc"], ["proof (chain)\npicking this:\n  le_vec (matpow (A + mat 1) n *v y) ((mu + 1) ^ n *s y)", "have le2: \"le_vec ?c ((mu + 1) ^ n *s y)\""], ["proof (prove)\nusing this:\n  le_vec (matpow (A + mat 1) n *v y) ((mu + 1) ^ n *s y)\n\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) n *v y) ((mu + 1) ^ n *s y)", "."], ["proof (state)\nthis:\n  le_vec (matpow (A + mat 1) n *v y) ((mu + 1) ^ n *s y)\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "have le: \"le_vec ?a ((?mu^n * mu) *s y + ?mu^n *s y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) (Suc n) *v y)\n     ((mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y)", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (A *v (matpow (A + mat 1) n *v y) + matpow (A + mat 1) n *v y)\n     ((mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y)", "using add_mono[OF le1[rule_format] le2[rule_format]]"], ["proof (prove)\nusing this:\n  (A *v (matpow (A + mat 1) n *v y)) $h ?i2 +\n  (matpow (A + mat 1) n *v y) $h ?i1\n  \\<le> ((mu + 1) ^ n * mu *s y) $h ?i2 + ((mu + 1) ^ n *s y) $h ?i1\n\ngoal (1 subgoal):\n 1. le_vec (A *v (matpow (A + mat 1) n *v y) + matpow (A + mat 1) n *v y)\n     ((mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y)", "by auto"], ["proof (state)\nthis:\n  le_vec (matpow (A + mat 1) (Suc n) *v y)\n   ((mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y)\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "have id'': \"(?mu^n * mu) *s y + ?mu^n *s y = ?mu^Suc n *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y = (mu + 1) ^ Suc n *s y", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y = (mu + 1) ^ Suc n *s y\n\ngoal (2 subgoals):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)\n 2. \\<And>n.\n       le_vec (matpow (A + mat 1) n *v y)\n        ((mu + 1) ^ n *s y) \\<Longrightarrow>\n       le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "using le"], ["proof (prove)\nusing this:\n  le_vec (matpow (A + mat 1) (Suc n) *v y)\n   ((mu + 1) ^ n * mu *s y + (mu + 1) ^ n *s y)\n\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "unfolding id''"], ["proof (prove)\nusing this:\n  le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)\n\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)", "."], ["proof (state)\nthis:\n  le_vec (matpow (A + mat 1) (Suc n) *v y) ((mu + 1) ^ Suc n *s y)\n\ngoal (1 subgoal):\n 1. le_vec (matpow (A + mat 1) 0 *v y) ((mu + 1) ^ 0 *s y)", "qed (simp add: matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  le_vec (A1n *v y) (cc *s y)\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have lt: \"0 < cc * y $ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cc * y $h i", "using lt[of i] le[rule_format, of i]"], ["proof (prove)\nusing this:\n  0 < (A1n *v y) $h i\n  (A1n *v y) $h i \\<le> (cc *s y) $h i\n\ngoal (1 subgoal):\n 1. 0 < cc * y $h i", "by auto"], ["proof (state)\nthis:\n  0 < cc * y $h ?i12\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"y $ i > 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y $h i", "using lt[of i] cc"], ["proof (prove)\nusing this:\n  0 < cc * y $h i\n  0 < cc\n\ngoal (1 subgoal):\n 1. 0 < y $h i", "by (rule zero_less_mult_pos)"], ["proof (state)\nthis:\n  0 < y $h ?i12\n\ngoal (2 subgoals):\n 1. lt_vec 0 y\n 2. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "thus \"lt_vec 0 y\""], ["proof (prove)\nusing this:\n  0 < y $h ?i12\n\ngoal (1 subgoal):\n 1. lt_vec 0 y", "by auto"], ["proof (state)\nthis:\n  lt_vec 0 y\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "assume **: \"mu = sr \\<or> A *v y = mu *s y\""], ["proof (state)\nthis:\n  mu = sr \\<or> A *v y = mu *s y\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "{"], ["proof (state)\nthis:\n  mu = sr \\<or> A *v y = mu *s y\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "assume \"A *v y = mu *s y\""], ["proof (state)\nthis:\n  A *v y = mu *s y\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "with y"], ["proof (chain)\npicking this:\n  y \\<in> X\n  A *v y = mu *s y", "have \"eigen_vector A y mu\""], ["proof (prove)\nusing this:\n  y \\<in> X\n  A *v y = mu *s y\n\ngoal (1 subgoal):\n 1. eigen_vector A y mu", "unfolding X_def eigen_vector_def"], ["proof (prove)\nusing this:\n  y \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}\n  A *v y = mu *s y\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<and> A *v y = mu *s y", "by auto"], ["proof (state)\nthis:\n  eigen_vector A y mu\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "hence \"eigen_vector cA (map_vector c y) (c mu)\""], ["proof (prove)\nusing this:\n  eigen_vector A y mu\n\ngoal (1 subgoal):\n 1. eigen_vector cA (map_vector complex_of_real y) (complex_of_real mu)", "unfolding of_real_hom.eigen_vector_hom"], ["proof (prove)\nusing this:\n  eigen_vector A y mu\n\ngoal (1 subgoal):\n 1. eigen_vector A y mu", "."], ["proof (state)\nthis:\n  eigen_vector cA (map_vector complex_of_real y) (complex_of_real mu)\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from eigen_vector_norm_sr[OF this] *"], ["proof (chain)\npicking this:\n  cmod (complex_of_real mu) \\<le> sr\n  sr \\<le> mu", "have \"mu = sr\""], ["proof (prove)\nusing this:\n  cmod (complex_of_real mu) \\<le> sr\n  sr \\<le> mu\n\ngoal (1 subgoal):\n 1. mu = sr", "by auto"], ["proof (state)\nthis:\n  mu = sr\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "}"], ["proof (state)\nthis:\n  A *v y = mu *s y \\<Longrightarrow> mu = sr\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "with **"], ["proof (chain)\npicking this:\n  mu = sr \\<or> A *v y = mu *s y\n  A *v y = mu *s y \\<Longrightarrow> mu = sr", "have mu_sr: \"mu = sr\""], ["proof (prove)\nusing this:\n  mu = sr \\<or> A *v y = mu *s y\n  A *v y = mu *s y \\<Longrightarrow> mu = sr\n\ngoal (1 subgoal):\n 1. mu = sr", "by auto"], ["proof (state)\nthis:\n  mu = sr\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "from eq1[folded vector_smult_distrib]"], ["proof (chain)\npicking this:\n  rowvector w *v (sr *s y) = rowvector w *v (A *v y)", "have 0: \"?w *v (sr *s y - A *v y) = 0\""], ["proof (prove)\nusing this:\n  rowvector w *v (sr *s y) = rowvector w *v (A *v y)\n\ngoal (1 subgoal):\n 1. rowvector w *v (sr *s y - A *v y) = 0", "unfolding matrix_vector_right_distrib_diff"], ["proof (prove)\nusing this:\n  rowvector w *v (sr *s y) = rowvector w *v (A *v y)\n\ngoal (1 subgoal):\n 1. rowvector w *v (sr *s y) - rowvector w *v (A *v y) = 0", "by simp"], ["proof (state)\nthis:\n  rowvector w *v (sr *s y - A *v y) = 0\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have le0: \"le_vec 0 (sr *s y - A *v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_vec 0 (sr *s y - A *v y)", "using assms(2)[unfolded mu_sr]"], ["proof (prove)\nusing this:\n  le_vec (A *v y) (sr *s y)\n\ngoal (1 subgoal):\n 1. le_vec 0 (sr *s y - A *v y)", "by auto"], ["proof (state)\nthis:\n  le_vec 0 (sr *s y - A *v y)\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "have \"sr *s y - A *v y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sr *s y - A *v y = 0", "using pos_rowvector_mult_0[OF w(2) 0 le0]"], ["proof (prove)\nusing this:\n  sr *s y - A *v y = 0\n\ngoal (1 subgoal):\n 1. sr *s y - A *v y = 0", "."], ["proof (state)\nthis:\n  sr *s y - A *v y = 0\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "hence ev_y: \"A *v y = sr *s y\""], ["proof (prove)\nusing this:\n  sr *s y - A *v y = 0\n\ngoal (1 subgoal):\n 1. A *v y = sr *s y", "by auto"], ["proof (state)\nthis:\n  A *v y = sr *s y\n\ngoal (1 subgoal):\n 1. mu = sr \\<or> A *v y = mu *s y \\<Longrightarrow>\n    mu = sr \\<and> A *v y = mu *s y", "show \"mu = sr \\<and> A *v y = mu *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu = sr \\<and> A *v y = mu *s y", "using ev_y mu_sr"], ["proof (prove)\nusing this:\n  A *v y = sr *s y\n  mu = sr\n\ngoal (1 subgoal):\n 1. mu = sr \\<and> A *v y = mu *s y", "by auto"], ["proof (state)\nthis:\n  mu = sr \\<and> A *v y = mu *s y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonnegative_eigenvector_has_ev_sr: assumes \"eigen_vector A v mu\" and le: \"le_vec 0 v\" \n  shows \"mu = sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu = sr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mu = sr", "from assms(1)[unfolded eigen_vector_def]"], ["proof (chain)\npicking this:\n  v \\<noteq> 0 \\<and> A *v v = mu *s v", "have v: \"v \\<noteq> 0\" and ev: \"A *v v = mu *s v\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0 \\<and> A *v v = mu *s v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0 &&& A *v v = mu *s v", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\n  A *v v = mu *s v\n\ngoal (1 subgoal):\n 1. mu = sr", "from le v"], ["proof (chain)\npicking this:\n  le_vec 0 v\n  v \\<noteq> 0", "have v: \"v \\<in> X\""], ["proof (prove)\nusing this:\n  le_vec 0 v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  le_vec 0 v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> {x. le_vec 0 x \\<and> x \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  v \\<in> X\n\ngoal (1 subgoal):\n 1. mu = sr", "from ev"], ["proof (chain)\npicking this:\n  A *v v = mu *s v", "have \"le_vec (A *v v) (mu *s v)\""], ["proof (prove)\nusing this:\n  A *v v = mu *s v\n\ngoal (1 subgoal):\n 1. le_vec (A *v v) (mu *s v)", "by auto"], ["proof (state)\nthis:\n  le_vec (A *v v) (mu *s v)\n\ngoal (1 subgoal):\n 1. mu = sr", "from le_vec_A_mu[OF v this] ev"], ["proof (chain)\npicking this:\n  sr \\<le> mu\n  lt_vec 0 v\n  mu = sr \\<or> A *v v = mu *s v \\<Longrightarrow>\n  mu = sr \\<and> A *v v = mu *s v\n  A *v v = mu *s v", "show ?thesis"], ["proof (prove)\nusing this:\n  sr \\<le> mu\n  lt_vec 0 v\n  mu = sr \\<or> A *v v = mu *s v \\<Longrightarrow>\n  mu = sr \\<and> A *v v = mu *s v\n  A *v v = mu *s v\n\ngoal (1 subgoal):\n 1. mu = sr", "by auto"], ["proof (state)\nthis:\n  mu = sr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma similar_matrix_rotation: assumes ev: \"eigen_value cA \\<alpha>\" and \\<alpha>: \"cmod \\<alpha> = sr\"\n  shows \"similar_matrix (cis (arg \\<alpha>) *k cA) cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "from ev"], ["proof (chain)\npicking this:\n  eigen_value cA \\<alpha>", "obtain y where ev: \"eigen_vector cA y \\<alpha>\""], ["proof (prove)\nusing this:\n  eigen_value cA \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        eigen_vector cA y \\<alpha> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eigen_value_def"], ["proof (prove)\nusing this:\n  \\<exists>v. eigen_vector cA v \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        eigen_vector cA y \\<alpha> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eigen_vector cA y \\<alpha>\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "let ?y = \"norm_v y\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "note maps = map_vector_def map_matrix_def"], ["proof (state)\nthis:\n  map_vector ?f ?v \\<equiv> \\<chi>i. ?f (?v $h i)\n  HMA_Connect.map_matrix ?f ?A \\<equiv> \\<chi>i. map_vector ?f (?A $h i)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "define yp where \"yp = norm_v y\""], ["proof (state)\nthis:\n  yp = map_vector cmod y\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "let ?yp = \"map_vector c yp\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have yp: \"yp \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yp \\<in> X", "unfolding yp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector cmod y \\<in> X", "by (rule norm_v_X[OF ev])"], ["proof (state)\nthis:\n  yp \\<in> X\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "from ev[unfolded eigen_vector_def]"], ["proof (chain)\npicking this:\n  y \\<noteq> 0 \\<and> cA *v y = \\<alpha> *s y", "have ev_y: \"cA *v y = \\<alpha> *s y\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0 \\<and> cA *v y = \\<alpha> *s y\n\ngoal (1 subgoal):\n 1. cA *v y = \\<alpha> *s y", "by auto"], ["proof (state)\nthis:\n  cA *v y = \\<alpha> *s y\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "from ev_le_vec[OF ev, unfolded \\<alpha>, folded yp_def]"], ["proof (chain)\npicking this:\n  le_vec (sr *s yp) (A *v yp)", "have 1: \"le_vec (sr *s yp) (A *v yp)\""], ["proof (prove)\nusing this:\n  le_vec (sr *s yp) (A *v yp)\n\ngoal (1 subgoal):\n 1. le_vec (sr *s yp) (A *v yp)", "by simp"], ["proof (state)\nthis:\n  le_vec (sr *s yp) (A *v yp)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "from rho_le_x_Ax_imp_rho_le_rx[OF yp 1]"], ["proof (chain)\npicking this:\n  sr \\<le> r yp", "have \"sr \\<le> r yp\""], ["proof (prove)\nusing this:\n  sr \\<le> r yp\n\ngoal (1 subgoal):\n 1. sr \\<le> r yp", "by auto"], ["proof (state)\nthis:\n  sr \\<le> r yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "with ev_inequalities[OF ev, folded yp_def]"], ["proof (chain)\npicking this:\n  cmod \\<alpha> \\<le> r yp\n  r yp \\<le> sr\n  sr \\<le> r yp", "have 2: \"r yp = sr\""], ["proof (prove)\nusing this:\n  cmod \\<alpha> \\<le> r yp\n  r yp \\<le> sr\n  sr \\<le> r yp\n\ngoal (1 subgoal):\n 1. r yp = sr", "by auto"], ["proof (state)\nthis:\n  r yp = sr\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have ev_yp: \"A *v yp = sr *s yp\" \n    and pos_yp: \"lt_vec 0 yp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v yp = sr *s yp &&& lt_vec 0 yp", "using sr_imp_eigen_vector_main[OF yp 2] sr_u_pos[OF yp 2]"], ["proof (prove)\nusing this:\n  sr *s yp = A *v yp\n  lt_vec 0 yp\n\ngoal (1 subgoal):\n 1. A *v yp = sr *s yp &&& lt_vec 0 yp", "by auto"], ["proof (state)\nthis:\n  A *v yp = sr *s yp\n  lt_vec 0 yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "define D where \"D = diagvector (\\<lambda> j. cis (arg (y $ j)))\""], ["proof (state)\nthis:\n  D = diagvector (\\<lambda>j. cis (arg (y $h j)))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "define inv_D where \"inv_D = diagvector (\\<lambda> j. cis (- arg (y $ j)))\""], ["proof (state)\nthis:\n  inv_D = diagvector (\\<lambda>j. cis (- arg (y $h j)))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have DD: \"inv_D ** D = mat 1\" \"D ** inv_D = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_D ** D = mat 1 &&& D ** inv_D = mat 1", "unfolding D_def inv_D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diagvector (\\<lambda>j. cis (- arg (y $h j))) **\n    diagvector (\\<lambda>j. cis (arg (y $h j))) =\n    mat 1 &&&\n    diagvector (\\<lambda>j. cis (arg (y $h j))) **\n    diagvector (\\<lambda>j. cis (- arg (y $h j))) =\n    mat 1", "by (auto simp add: diagvector_eq_mat cis_mult)"], ["proof (state)\nthis:\n  inv_D ** D = mat 1\n  D ** inv_D = mat 1\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "{"], ["proof (state)\nthis:\n  inv_D ** D = mat 1\n  D ** inv_D = mat 1\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"(D *v ?yp) $ i = cis (arg (y $ i)) * c (cmod (y $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D *v map_vector complex_of_real yp) $h i =\n    cis (arg (y $h i)) * complex_of_real (cmod (y $h i))", "unfolding D_def yp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (diagvector (\\<lambda>j. cis (arg (y $h j))) *v\n     map_vector complex_of_real (map_vector cmod y)) $h\n    i =\n    cis (arg (y $h i)) * complex_of_real (cmod (y $h i))", "by (simp add: maps)"], ["proof (state)\nthis:\n  (D *v map_vector complex_of_real yp) $h i =\n  cis (arg (y $h i)) * complex_of_real (cmod (y $h i))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  (D *v map_vector complex_of_real yp) $h i =\n  cis (arg (y $h i)) * complex_of_real (cmod (y $h i))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"\\<dots> = y $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (y $h i)) * complex_of_real (cmod (y $h i)) = y $h i", "by (simp add: cis_mult_cmod_id)"], ["proof (state)\nthis:\n  cis (arg (y $h i)) * complex_of_real (cmod (y $h i)) = y $h i\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  cis (arg (y $h i)) * complex_of_real (cmod (y $h i)) = y $h i\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "note calculation"], ["proof (state)\nthis:\n  (D *v map_vector complex_of_real yp) $h i = y $h i\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "}"], ["proof (state)\nthis:\n  (D *v map_vector complex_of_real yp) $h ?i2 = y $h ?i2\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "hence y_D_yp: \"y = D *v ?yp\""], ["proof (prove)\nusing this:\n  (D *v map_vector complex_of_real yp) $h ?i2 = y $h ?i2\n\ngoal (1 subgoal):\n 1. y = D *v map_vector complex_of_real yp", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  y = D *v map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "define \\<phi> where \"\\<phi> = arg \\<alpha>\""], ["proof (state)\nthis:\n  \\<phi> = arg \\<alpha>\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "let ?\\<phi> = \"cis (- \\<phi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have [simp]: \"cis (- \\<phi>) * rcis sr \\<phi> = sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- \\<phi>) * rcis sr \\<phi> = complex_of_real sr", "unfolding cis_rcis_eq rcis_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis (1 * sr) (- \\<phi> + \\<phi>) = complex_of_real sr", "by simp"], ["proof (state)\nthis:\n  cis (- \\<phi>) * rcis sr \\<phi> = complex_of_real sr\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \\<alpha>: \"\\<alpha> = rcis sr \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = rcis sr \\<phi>", "unfolding \\<phi>_def \\<alpha>[symmetric] rcis_cmod_arg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>", ".."], ["proof (state)\nthis:\n  \\<alpha> = rcis sr \\<phi>\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "define F where \"F = ?\\<phi> *k (inv_D ** cA ** D)\""], ["proof (state)\nthis:\n  F = cis (- \\<phi>) *k (inv_D ** cA ** D)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"cA *v (D *v ?yp) = \\<alpha> *s y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cA *v (D *v map_vector complex_of_real yp) = \\<alpha> *s y", "unfolding y_D_yp[symmetric] ev_y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> *s y = \\<alpha> *s y", "by simp"], ["proof (state)\nthis:\n  cA *v (D *v map_vector complex_of_real yp) = \\<alpha> *s y\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  cA *v (D *v map_vector complex_of_real yp) = \\<alpha> *s y\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"inv_D *v \\<dots> = \\<alpha> *s ?yp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_D *v (\\<alpha> *s y) = \\<alpha> *s map_vector complex_of_real yp", "unfolding vector_smult_distrib y_D_yp matrix_vector_mul_assoc DD matrix_vector_mul_lid"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> *s map_vector complex_of_real yp =\n    \\<alpha> *s map_vector complex_of_real yp", ".."], ["proof (state)\nthis:\n  inv_D *v (\\<alpha> *s y) = \\<alpha> *s map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  inv_D *v (\\<alpha> *s y) = \\<alpha> *s map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"?\\<phi> *s \\<dots> = sr *s ?yp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- \\<phi>) *s (\\<alpha> *s map_vector complex_of_real yp) =\n    complex_of_real sr *s map_vector complex_of_real yp", "unfolding \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- \\<phi>) *s (rcis sr \\<phi> *s map_vector complex_of_real yp) =\n    complex_of_real sr *s map_vector complex_of_real yp", "by simp"], ["proof (state)\nthis:\n  cis (- \\<phi>) *s (\\<alpha> *s map_vector complex_of_real yp) =\n  complex_of_real sr *s map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  cis (- \\<phi>) *s (\\<alpha> *s map_vector complex_of_real yp) =\n  complex_of_real sr *s map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"\\<dots> = map_vector c (sr *s yp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real sr *s map_vector complex_of_real yp =\n    map_vector complex_of_real (sr *s yp)", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (complex_of_real sr *s map_vector complex_of_real yp) $h i =\n       map_vector complex_of_real (sr *s yp) $h i", "by (auto simp: maps)"], ["proof (state)\nthis:\n  complex_of_real sr *s map_vector complex_of_real yp =\n  map_vector complex_of_real (sr *s yp)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  complex_of_real sr *s map_vector complex_of_real yp =\n  map_vector complex_of_real (sr *s yp)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"\\<dots> = cA *v ?yp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector complex_of_real (sr *s yp) =\n    cA *v map_vector complex_of_real yp", "unfolding ev_yp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector complex_of_real (A *v yp) =\n    cA *v map_vector complex_of_real yp", "by (auto simp: maps matrix_vector_mult_def)"], ["proof (state)\nthis:\n  map_vector complex_of_real (sr *s yp) =\n  cA *v map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "finally"], ["proof (chain)\npicking this:\n  cis (- \\<phi>) *s\n  (inv_D *v (cA *v (D *v map_vector complex_of_real yp))) =\n  cA *v map_vector complex_of_real yp", "have F: \"F *v ?yp = cA *v ?yp\""], ["proof (prove)\nusing this:\n  cis (- \\<phi>) *s\n  (inv_D *v (cA *v (D *v map_vector complex_of_real yp))) =\n  cA *v map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. F *v map_vector complex_of_real yp = cA *v map_vector complex_of_real yp", "unfolding F_def matrix_scalar_vector_ac[symmetric]"], ["proof (prove)\nusing this:\n  cis (- \\<phi>) *s\n  (inv_D *v (cA *v (D *v map_vector complex_of_real yp))) =\n  cA *v map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. inv_D ** cA ** D *v (cis (- \\<phi>) *s map_vector complex_of_real yp) =\n    cA *v map_vector complex_of_real yp", "unfolding matrix_vector_mul_assoc[symmetric] vector_smult_distrib"], ["proof (prove)\nusing this:\n  cis (- \\<phi>) *s\n  (inv_D *v (cA *v (D *v map_vector complex_of_real yp))) =\n  cA *v map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. cis (- \\<phi>) *s\n    (inv_D *v (cA *v (D *v map_vector complex_of_real yp))) =\n    cA *v map_vector complex_of_real yp", "."], ["proof (state)\nthis:\n  F *v map_vector complex_of_real yp = cA *v map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have prod: \"inv_D ** cA ** D = (\\<chi> i j. cis (- arg (y $ i)) * cA $ i $ j * cis (arg (y $ j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_D ** cA ** D =\n    (\\<chi>i j. cis (- arg (y $h i)) * cA $h i $h j * cis (arg (y $h j)))", "unfolding inv_D_def D_def diagvector_mult_right diagvector_mult_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        (\\<chi>i j. cis (- arg (y $h i)) * cA $h i $h j) $h i $h j *\n        cis (arg (y $h j))) =\n    (\\<chi>i j. cis (- arg (y $h i)) * cA $h i $h j * cis (arg (y $h j)))", "by simp"], ["proof (state)\nthis:\n  inv_D ** cA ** D =\n  (\\<chi>i j. cis (- arg (y $h i)) * cA $h i $h j * cis (arg (y $h j)))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "{"], ["proof (state)\nthis:\n  inv_D ** cA ** D =\n  (\\<chi>i j. cis (- arg (y $h i)) * cA $h i $h j * cis (arg (y $h j)))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"cmod (F $ i $ j) = cmod (?\\<phi> * cA $h i $h j * (cis (- arg (y $h i)) * cis (arg (y $h j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (F $h i $h j) =\n    cmod\n     (cis (- \\<phi>) * cA $h i $h j *\n      (cis (- arg (y $h i)) * cis (arg (y $h j))))", "unfolding F_def prod vec_lambda_beta matrix_scalar_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (cis (- \\<phi>) *\n      (cis (- arg (y $h i)) * cA $h i $h j * cis (arg (y $h j)))) =\n    cmod\n     (cis (- \\<phi>) * cA $h i $h j *\n      (cis (- arg (y $h i)) * cis (arg (y $h j))))", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  cmod (F $h i $h j) =\n  cmod\n   (cis (- \\<phi>) * cA $h i $h j *\n    (cis (- arg (y $h i)) * cis (arg (y $h j))))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  cmod (F $h i $h j) =\n  cmod\n   (cis (- \\<phi>) * cA $h i $h j *\n    (cis (- arg (y $h i)) * cis (arg (y $h j))))\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"\\<dots> = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (cis (- \\<phi>) * cA $h i $h j *\n      (cis (- arg (y $h i)) * cis (arg (y $h j)))) =\n    A $h i $h j", "unfolding cis_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (cis (- \\<phi>) * cA $h i $h j * cis (- arg (y $h i) + arg (y $h j))) =\n    A $h i $h j", "unfolding norm_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (cis (- \\<phi>)) * cmod (cA $h i $h j) *\n    cmod (cis (- arg (y $h i) + arg (y $h j))) =\n    A $h i $h j", "by simp"], ["proof (state)\nthis:\n  cmod\n   (cis (- \\<phi>) * cA $h i $h j *\n    (cis (- arg (y $h i)) * cis (arg (y $h j)))) =\n  A $h i $h j\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  cmod\n   (cis (- \\<phi>) * cA $h i $h j *\n    (cis (- arg (y $h i)) * cis (arg (y $h j)))) =\n  A $h i $h j\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "note calculation"], ["proof (state)\nthis:\n  cmod (F $h i $h j) = A $h i $h j\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "}"], ["proof (state)\nthis:\n  cmod (F $h ?i2 $h ?j2) = A $h ?i2 $h ?j2\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "hence FA: \"map_matrix norm F = A\""], ["proof (prove)\nusing this:\n  cmod (F $h ?i2 $h ?j2) = A $h ?i2 $h ?j2\n\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix cmod F = A", "unfolding maps"], ["proof (prove)\nusing this:\n  cmod (F $h ?i2 $h ?j2) = A $h ?i2 $h ?j2\n\ngoal (1 subgoal):\n 1. (\\<chi>i ia. cmod (F $h i $h ia)) = A", "by auto"], ["proof (state)\nthis:\n  HMA_Connect.map_matrix cmod F = A\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "let ?F = \"map_matrix c (map_matrix norm F)\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "let ?G = \"?F - F\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "let ?Re = \"map_matrix Re\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "from F[folded FA]"], ["proof (chain)\npicking this:\n  F *v map_vector complex_of_real yp =\n  HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) *v\n  map_vector complex_of_real yp", "have 0: \"?G *v ?yp = 0\""], ["proof (prove)\nusing this:\n  F *v map_vector complex_of_real yp =\n  HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) *v\n  map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. (HMA_Connect.map_matrix complex_of_real\n      (HMA_Connect.map_matrix cmod F) -\n     F) *v\n    map_vector complex_of_real yp =\n    0", "unfolding matrix_diff_vect_distrib"], ["proof (prove)\nusing this:\n  F *v map_vector complex_of_real yp =\n  HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) *v\n  map_vector complex_of_real yp\n\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix complex_of_real\n     (HMA_Connect.map_matrix cmod F) *v\n    map_vector complex_of_real yp -\n    F *v map_vector complex_of_real yp =\n    0", "by simp"], ["proof (state)\nthis:\n  (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n   F) *v\n  map_vector complex_of_real yp =\n  0\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"?Re ?G *v yp = map_vector Re (?G *v ?yp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix Re\n     (HMA_Connect.map_matrix complex_of_real\n       (HMA_Connect.map_matrix cmod F) -\n      F) *v\n    yp =\n    map_vector Re\n     ((HMA_Connect.map_matrix complex_of_real\n        (HMA_Connect.map_matrix cmod F) -\n       F) *v\n      map_vector complex_of_real yp)", "unfolding maps matrix_vector_mult_def vec_lambda_beta Re_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        \\<Sum>j\\<in>UNIV.\n          Re (((\\<chi>i ia. complex_of_real (cmod (F $h i $h ia))) - F) $h\n              i $h\n              j) *\n          yp $h j) =\n    (\\<chi>i.\n        \\<Sum>x\\<in>UNIV.\n          Re (((\\<chi>i ia. complex_of_real (cmod (F $h i $h ia))) - F) $h\n              i $h\n              x *\n              complex_of_real (yp $h x)))", "by auto"], ["proof (state)\nthis:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) *v\n  yp =\n  map_vector Re\n   ((HMA_Connect.map_matrix complex_of_real\n      (HMA_Connect.map_matrix cmod F) -\n     F) *v\n    map_vector complex_of_real yp)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "also"], ["proof (state)\nthis:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) *v\n  yp =\n  map_vector Re\n   ((HMA_Connect.map_matrix complex_of_real\n      (HMA_Connect.map_matrix cmod F) -\n     F) *v\n    map_vector complex_of_real yp)\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector Re\n     ((HMA_Connect.map_matrix complex_of_real\n        (HMA_Connect.map_matrix cmod F) -\n       F) *v\n      map_vector complex_of_real yp) =\n    0", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vector Re 0 = 0", "by (simp add: vec_eq_iff maps)"], ["proof (state)\nthis:\n  map_vector Re\n   ((HMA_Connect.map_matrix complex_of_real\n      (HMA_Connect.map_matrix cmod F) -\n     F) *v\n    map_vector complex_of_real yp) =\n  0\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "finally"], ["proof (chain)\npicking this:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) *v\n  yp =\n  0", "have 0: \"?Re ?G *v yp = 0\""], ["proof (prove)\nusing this:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) *v\n  yp =\n  0\n\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix Re\n     (HMA_Connect.map_matrix complex_of_real\n       (HMA_Connect.map_matrix cmod F) -\n      F) *v\n    yp =\n    0", "."], ["proof (state)\nthis:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) *v\n  yp =\n  0\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"?Re ?G = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix Re\n     (HMA_Connect.map_matrix complex_of_real\n       (HMA_Connect.map_matrix cmod F) -\n      F) =\n    0", "by (rule pos_matrix_mult_0[OF _ pos_yp 0], auto simp: maps complex_Re_le_cmod)"], ["proof (state)\nthis:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) =\n  0\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "hence \"?F = F\""], ["proof (prove)\nusing this:\n  HMA_Connect.map_matrix Re\n   (HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) -\n    F) =\n  0\n\ngoal (1 subgoal):\n 1. HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) =\n    F", "by (auto simp: maps vec_eq_iff cmod_eq_Re)"], ["proof (state)\nthis:\n  HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) = F\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "with FA"], ["proof (chain)\npicking this:\n  HMA_Connect.map_matrix cmod F = A\n  HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) = F", "have AF: \"cA = F\""], ["proof (prove)\nusing this:\n  HMA_Connect.map_matrix cmod F = A\n  HMA_Connect.map_matrix complex_of_real (HMA_Connect.map_matrix cmod F) = F\n\ngoal (1 subgoal):\n 1. cA = F", "by simp"], ["proof (state)\nthis:\n  cA = F\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "from arg_cong[OF this, of \"\\<lambda> A. cis \\<phi> *k A\"]"], ["proof (chain)\npicking this:\n  cis \\<phi> *k cA = cis \\<phi> *k F", "have sim: \"cis \\<phi> *k cA = inv_D ** cA ** D\""], ["proof (prove)\nusing this:\n  cis \\<phi> *k cA = cis \\<phi> *k F\n\ngoal (1 subgoal):\n 1. cis \\<phi> *k cA = inv_D ** cA ** D", "unfolding F_def matrix.scale_scale cis_mult"], ["proof (prove)\nusing this:\n  cis \\<phi> *k cA = cis (\\<phi> + - \\<phi>) *k (inv_D ** cA ** D)\n\ngoal (1 subgoal):\n 1. cis \\<phi> *k cA = inv_D ** cA ** D", "by simp"], ["proof (state)\nthis:\n  cis \\<phi> *k cA = inv_D ** cA ** D\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"similar_matrix (cis \\<phi> *k cA) cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_matrix (cis \\<phi> *k cA) cA", "unfolding similar_matrix_def similar_matrix_wit_def\n     sim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P Q.\n       P ** Q = mat 1 \\<and>\n       Q ** P = mat 1 \\<and> inv_D ** cA ** D = P ** cA ** Q", "by (rule exI[of _ inv_D], rule exI[of _ D], auto simp: DD)"], ["proof (state)\nthis:\n  similar_matrix (cis \\<phi> *k cA) cA\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "thus ?thesis"], ["proof (prove)\nusing this:\n  similar_matrix (cis \\<phi> *k cA) cA\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  similar_matrix (cis (arg \\<alpha>) *k cA) cA\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "."], ["proof (state)\nthis:\n  similar_matrix (cis (arg \\<alpha>) *k cA) cA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes ev: \"eigen_value cA \\<alpha>\" and \\<alpha>: \"cmod \\<alpha> = sr\"\n  shows maximal_eigen_value_order_1: \"order \\<alpha> (charpoly cA) = 1\" \n    and maximal_eigen_value_rotation: \"eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\"\n      \"eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order \\<alpha> (charpoly cA) = 1 &&&\n    eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x &&&\n    eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "let ?a = \"cis (arg \\<alpha>)\""], ["proof (state)\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "let ?p = \"charpoly cA\""], ["proof (state)\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "from similar_matrix_rotation[OF ev \\<alpha>]"], ["proof (chain)\npicking this:\n  similar_matrix (cis (arg \\<alpha>) *k cA) cA", "have \"similar_matrix (?a *k cA) cA\""], ["proof (prove)\nusing this:\n  similar_matrix (cis (arg \\<alpha>) *k cA) cA\n\ngoal (1 subgoal):\n 1. similar_matrix (cis (arg \\<alpha>) *k cA) cA", "."], ["proof (state)\nthis:\n  similar_matrix (cis (arg \\<alpha>) *k cA) cA\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "from similar_matrix_charpoly[OF this]"], ["proof (chain)\npicking this:\n  charpoly (cis (arg \\<alpha>) *k cA) = charpoly cA", "have id: \"charpoly (?a *k cA) = ?p\""], ["proof (prove)\nusing this:\n  charpoly (cis (arg \\<alpha>) *k cA) = charpoly cA\n\ngoal (1 subgoal):\n 1. charpoly (cis (arg \\<alpha>) *k cA) = charpoly cA", "."], ["proof (state)\nthis:\n  charpoly (cis (arg \\<alpha>) *k cA) = charpoly cA\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "have a: \"?a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg \\<alpha>) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  cis (arg \\<alpha>) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "from order_charpoly_smult[OF this, of _ cA, unfolded id]"], ["proof (chain)\npicking this:\n  order ?x (charpoly cA) = order (?x / cis (arg \\<alpha>)) (charpoly cA)", "have order_neg: \"order x ?p = order (x / ?a) ?p\" for x"], ["proof (prove)\nusing this:\n  order ?x (charpoly cA) = order (?x / cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (1 subgoal):\n 1. order x (charpoly cA) = order (x / cis (arg \\<alpha>)) (charpoly cA)", "."], ["proof (state)\nthis:\n  order ?x (charpoly cA) = order (?x / cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "have order_pos: \"order x ?p = order (x * ?a) ?p\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (charpoly cA) = order (x * cis (arg \\<alpha>)) (charpoly cA)", "using order_neg[symmetric, of \"x * ?a\"]"], ["proof (prove)\nusing this:\n  order (x * cis (arg \\<alpha>) / cis (arg \\<alpha>)) (charpoly cA) =\n  order (x * cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (1 subgoal):\n 1. order x (charpoly cA) = order (x * cis (arg \\<alpha>)) (charpoly cA)", "by simp"], ["proof (state)\nthis:\n  order ?x (charpoly cA) = order (?x * cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "note order_neg[of \\<alpha>]"], ["proof (state)\nthis:\n  order \\<alpha> (charpoly cA) =\n  order (\\<alpha> / cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "also"], ["proof (state)\nthis:\n  order \\<alpha> (charpoly cA) =\n  order (\\<alpha> / cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "have id: \"\\<alpha> / ?a = sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> / cis (arg \\<alpha>) = complex_of_real sr", "unfolding \\<alpha>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> / cis (arg \\<alpha>) = complex_of_real (cmod \\<alpha>)", "by (metis a cis_mult_cmod_id nonzero_mult_div_cancel_left)"], ["proof (state)\nthis:\n  \\<alpha> / cis (arg \\<alpha>) = complex_of_real sr\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "also"], ["proof (state)\nthis:\n  \\<alpha> / cis (arg \\<alpha>) = complex_of_real sr\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "have sr: \"order \\<dots> ?p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real sr) (charpoly cA) = 1", "unfolding multiplicity_sr_1[symmetric] charpoly_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real sr) (map_poly complex_of_real (charpoly A)) =\n    order sr (charpoly A)", "by (rule map_poly_inj_idom_divide_hom.order_hom, unfold_locales)"], ["proof (state)\nthis:\n  order (complex_of_real sr) (charpoly cA) = 1\n\ngoal (3 subgoals):\n 1. order \\<alpha> (charpoly cA) = 1\n 2. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 3. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "finally"], ["proof (chain)\npicking this:\n  order \\<alpha> (charpoly cA) = 1", "show *: \"order \\<alpha> ?p = 1\""], ["proof (prove)\nusing this:\n  order \\<alpha> (charpoly cA) = 1\n\ngoal (1 subgoal):\n 1. order \\<alpha> (charpoly cA) = 1", "."], ["proof (state)\nthis:\n  order \\<alpha> (charpoly cA) = 1\n\ngoal (2 subgoals):\n 1. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n 2. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "show \"eigen_value cA (x * ?a) = eigen_value cA x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x", "using order_pos"], ["proof (prove)\nusing this:\n  order ?x (charpoly cA) = order (?x * cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (1 subgoal):\n 1. eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x", "unfolding eigen_value_root_charpoly order_root"], ["proof (prove)\nusing this:\n  order ?x (charpoly cA) = order (?x * cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (1 subgoal):\n 1. (charpoly cA = 0 \\<or>\n     order (x * cis (arg \\<alpha>)) (charpoly cA) \\<noteq> 0) =\n    (charpoly cA = 0 \\<or> order x (charpoly cA) \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (x * cis (arg \\<alpha>)) = eigen_value cA x\n\ngoal (1 subgoal):\n 1. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "show \"eigen_value cA (x / ?a) = eigen_value cA x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "using order_neg"], ["proof (prove)\nusing this:\n  order ?x (charpoly cA) = order (?x / cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (1 subgoal):\n 1. eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x", "unfolding eigen_value_root_charpoly order_root"], ["proof (prove)\nusing this:\n  order ?x (charpoly cA) = order (?x / cis (arg \\<alpha>)) (charpoly cA)\n\ngoal (1 subgoal):\n 1. (charpoly cA = 0 \\<or>\n     order (x / cis (arg \\<alpha>)) (charpoly cA) \\<noteq> 0) =\n    (charpoly cA = 0 \\<or> order x (charpoly cA) \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (x / cis (arg \\<alpha>)) = eigen_value cA x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maximal_eigen_values_group: assumes M: \"M = {ev :: complex. eigen_value cA ev \\<and> cmod ev = sr}\"\n  and a: \"rcis sr \\<alpha> \\<in> M\" \n  and b: \"rcis sr \\<beta> \\<in> M\" \nshows \"rcis sr (\\<alpha> + \\<beta>) \\<in> M\" \"rcis sr (\\<alpha> - \\<beta>) \\<in> M\" \"rcis sr 0 \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M &&&\n    rcis sr (\\<alpha> - \\<beta>) \\<in> M &&& rcis sr 0 \\<in> M", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "fix a"], ["proof (state)\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "assume *: \"rcis sr a \\<in> M\""], ["proof (state)\nthis:\n  rcis sr a \\<in> M\n\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "have id: \"cis (arg (rcis sr a)) = cis a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (rcis sr a)) = cis a", "by (smt * M mem_Collect_eq nonzero_mult_div_cancel_left of_real_eq_0_iff \n         rcis_cmod_arg rcis_def sr_pos)"], ["proof (state)\nthis:\n  cis (arg (rcis sr a)) = cis a\n\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "from *[unfolded assms]"], ["proof (chain)\npicking this:\n  rcis sr a \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "have \"eigen_value cA (rcis sr a)\" \"cmod (rcis sr a) = sr\""], ["proof (prove)\nusing this:\n  rcis sr a \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. eigen_value cA (rcis sr a) &&& cmod (rcis sr a) = sr", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (rcis sr a)\n  cmod (rcis sr a) = sr\n\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "from maximal_eigen_value_rotation[OF this, unfolded id]"], ["proof (chain)\npicking this:\n  eigen_value cA (?x * cis a) = eigen_value cA ?x\n  eigen_value cA (?x / cis a) = eigen_value cA ?x", "have \"eigen_value cA (x * cis a) = eigen_value cA x\" \n      \"eigen_value cA (x / cis a) = eigen_value cA x\" for x"], ["proof (prove)\nusing this:\n  eigen_value cA (?x * cis a) = eigen_value cA ?x\n  eigen_value cA (?x / cis a) = eigen_value cA ?x\n\ngoal (1 subgoal):\n 1. eigen_value cA (x * cis a) = eigen_value cA x &&&\n    eigen_value cA (x / cis a) = eigen_value cA x", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (?x * cis a) = eigen_value cA ?x\n  eigen_value cA (?x / cis a) = eigen_value cA ?x\n\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "}"], ["proof (state)\nthis:\n  rcis sr ?a3 \\<in> M \\<Longrightarrow>\n  eigen_value cA (?x * cis ?a3) = eigen_value cA ?x\n  rcis sr ?a3 \\<in> M \\<Longrightarrow>\n  eigen_value cA (?x / cis ?a3) = eigen_value cA ?x\n\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "note * = this"], ["proof (state)\nthis:\n  rcis sr ?a3 \\<in> M \\<Longrightarrow>\n  eigen_value cA (?x * cis ?a3) = eigen_value cA ?x\n  rcis sr ?a3 \\<in> M \\<Longrightarrow>\n  eigen_value cA (?x / cis ?a3) = eigen_value cA ?x\n\ngoal (3 subgoals):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M\n 2. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 3. rcis sr 0 \\<in> M", "from *(1)[OF b, of \"rcis sr \\<alpha>\"] a"], ["proof (chain)\npicking this:\n  eigen_value cA (rcis sr \\<alpha> * cis \\<beta>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> M", "show \"rcis sr (\\<alpha> + \\<beta>) \\<in> M\""], ["proof (prove)\nusing this:\n  eigen_value cA (rcis sr \\<alpha> * cis \\<beta>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (\\<alpha> + \\<beta>) \\<in> M", "unfolding M"], ["proof (prove)\nusing this:\n  eigen_value cA (rcis sr \\<alpha> * cis \\<beta>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. rcis sr (\\<alpha> + \\<beta>)\n    \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "by auto"], ["proof (state)\nthis:\n  rcis sr (\\<alpha> + \\<beta>) \\<in> M\n\ngoal (2 subgoals):\n 1. rcis sr (\\<alpha> - \\<beta>) \\<in> M\n 2. rcis sr 0 \\<in> M", "from *(2)[OF a, of \"rcis sr \\<alpha>\"] a"], ["proof (chain)\npicking this:\n  eigen_value cA (rcis sr \\<alpha> / cis \\<alpha>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> M", "show \"rcis sr 0 \\<in> M\""], ["proof (prove)\nusing this:\n  eigen_value cA (rcis sr \\<alpha> / cis \\<alpha>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr 0 \\<in> M", "unfolding M"], ["proof (prove)\nusing this:\n  eigen_value cA (rcis sr \\<alpha> / cis \\<alpha>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. rcis sr 0 \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "by auto"], ["proof (state)\nthis:\n  rcis sr 0 \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (\\<alpha> - \\<beta>) \\<in> M", "from *(2)[OF b, of \"rcis sr \\<alpha>\"] a"], ["proof (chain)\npicking this:\n  eigen_value cA (rcis sr \\<alpha> / cis \\<beta>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> M", "show \"rcis sr (\\<alpha> - \\<beta>) \\<in> M\""], ["proof (prove)\nusing this:\n  eigen_value cA (rcis sr \\<alpha> / cis \\<beta>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (\\<alpha> - \\<beta>) \\<in> M", "unfolding M"], ["proof (prove)\nusing this:\n  eigen_value cA (rcis sr \\<alpha> / cis \\<beta>) =\n  eigen_value cA (rcis sr \\<alpha>)\n  rcis sr \\<alpha> \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. rcis sr (\\<alpha> - \\<beta>)\n    \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "by auto"], ["proof (state)\nthis:\n  rcis sr (\\<alpha> - \\<beta>) \\<in> M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maximal_eigen_value_roots_of_unity_rotation: \n  assumes M: \"M = {ev :: complex. eigen_value cA ev \\<and> cmod ev = sr}\" \n   and kM: \"k = card M\" \n shows \"k \\<noteq> 0\" \n    \"k \\<le> CARD('n)\"\n    \"\\<exists> f. charpoly A = (monom 1 k - [:sr^k:]) * f \n       \\<and> (\\<forall> x. poly (map_poly c f) x = 0 \\<longrightarrow> cmod x < sr)\"\n    \"M = (*) (c sr) ` (\\<lambda> i. (cis (of_nat i * 2 * pi / k))) ` {0 ..< k}\"\n    \"M = (*) (c sr) ` { x :: complex. x ^ k = 1}\"\n    \"(*) (cis (2 * pi / k)) ` Spectrum cA = Spectrum cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<noteq> 0 &&&\n     k \\<le> CARD('n) &&&\n     \\<exists>f.\n        charpoly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr)) &&&\n    M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real k)) ` {0..<k} &&&\n    M = (*) (complex_of_real sr) ` {x. x ^ k = 1} &&&\n    (*) (cis (2 * pi / real k)) ` Spectrum cA = Spectrum cA", "unfolding kM"], ["proof (prove)\ngoal (1 subgoal):\n 1. (card M \\<noteq> 0 &&&\n     card M \\<le> CARD('n) &&&\n     \\<exists>f.\n        charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n        (\\<forall>x.\n            poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n            cmod x < sr)) &&&\n    M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M} &&&\n    M = (*) (complex_of_real sr) ` {x. x ^ card M = 1} &&&\n    (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?M = \"card M\""], ["proof (state)\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note fin = finite_spectrum[of cA]"], ["proof (state)\nthis:\n  finite (Collect (eigen_value cA))\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note char = degree_monic_charpoly[of cA]"], ["proof (state)\nthis:\n  degree (charpoly cA) = CARD('n) \\<and> monic (charpoly cA)\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"?M \\<le> card (Collect (eigen_value cA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card M \\<le> card (Collect (eigen_value cA))", "by (rule card_mono[OF fin], unfold M, auto)"], ["proof (state)\nthis:\n  card M \\<le> card (Collect (eigen_value cA))\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  card M \\<le> card (Collect (eigen_value cA))\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"Collect (eigen_value cA) = {x. poly (charpoly cA) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (eigen_value cA) = {x. poly (charpoly cA) x = 0}", "unfolding eigen_value_root_charpoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. poly (charpoly cA) k = 0} = {x. poly (charpoly cA) x = 0}", "by auto"], ["proof (state)\nthis:\n  Collect (eigen_value cA) = {x. poly (charpoly cA) x = 0}\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  Collect (eigen_value cA) = {x. poly (charpoly cA) x = 0}\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"card \\<dots> \\<le> degree (charpoly cA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (charpoly cA) x = 0} \\<le> degree (charpoly cA)", "by (rule poly_roots_degree, insert char, auto)"], ["proof (state)\nthis:\n  card {x. poly (charpoly cA) x = 0} \\<le> degree (charpoly cA)\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  card {x. poly (charpoly cA) x = 0} \\<le> degree (charpoly cA)\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (charpoly cA) = CARD('n)", "using char"], ["proof (prove)\nusing this:\n  degree (charpoly cA) = CARD('n) \\<and> monic (charpoly cA)\n\ngoal (1 subgoal):\n 1. degree (charpoly cA) = CARD('n)", "by simp"], ["proof (state)\nthis:\n  degree (charpoly cA) = CARD('n)\n\ngoal (6 subgoals):\n 1. card M \\<noteq> 0\n 2. card M \\<le> CARD('n)\n 3. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 4. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 5. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 6. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "finally"], ["proof (chain)\npicking this:\n  card M \\<le> CARD('n)", "show \"?M \\<le> CARD ('n)\""], ["proof (prove)\nusing this:\n  card M \\<le> CARD('n)\n\ngoal (1 subgoal):\n 1. card M \\<le> CARD('n)", "."], ["proof (state)\nthis:\n  card M \\<le> CARD('n)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from finite_subset[OF _ fin, of M]"], ["proof (chain)\npicking this:\n  M \\<subseteq> Collect (eigen_value cA) \\<Longrightarrow> finite M", "have finM: \"finite M\""], ["proof (prove)\nusing this:\n  M \\<subseteq> Collect (eigen_value cA) \\<Longrightarrow> finite M\n\ngoal (1 subgoal):\n 1. finite M", "unfolding M"], ["proof (prove)\nusing this:\n  {ev. eigen_value cA ev \\<and> cmod ev = sr}\n  \\<subseteq> Collect (eigen_value cA) \\<Longrightarrow>\n  finite {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. finite {ev. eigen_value cA ev \\<and> cmod ev = sr}", "by blast"], ["proof (state)\nthis:\n  finite M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from finite_distinct_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = M \\<and> distinct xs", "obtain m where Mm: \"M = set m\" and dist: \"distinct m\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = M \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>M = set m; distinct m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = set m\n  distinct m\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from Mm dist"], ["proof (chain)\npicking this:\n  M = set m\n  distinct m", "have card: \"?M = length m\""], ["proof (prove)\nusing this:\n  M = set m\n  distinct m\n\ngoal (1 subgoal):\n 1. card M = length m", "by (auto simp: distinct_card)"], ["proof (state)\nthis:\n  card M = length m\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have sr: \"sr \\<in> set m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real sr \\<in> set m", "using eigen_value_sr_c sr_pos"], ["proof (prove)\nusing this:\n  eigen_value cA (complex_of_real sr)\n  0 < sr\n\ngoal (1 subgoal):\n 1. complex_of_real sr \\<in> set m", "unfolding Mm[symmetric] M"], ["proof (prove)\nusing this:\n  eigen_value cA (complex_of_real sr)\n  0 < sr\n\ngoal (1 subgoal):\n 1. complex_of_real sr \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "by auto"], ["proof (state)\nthis:\n  complex_of_real sr \\<in> set m\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "define s where \"s = sort_key arg m\""], ["proof (state)\nthis:\n  s = sort_key arg m\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "define a where \"a = map arg s\""], ["proof (state)\nthis:\n  a = map arg s\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?k = \"length a\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from dist Mm card sr"], ["proof (chain)\npicking this:\n  distinct m\n  M = set m\n  card M = length m\n  complex_of_real sr \\<in> set m", "have s: \"M = set s\" \"distinct s\"  \"sr \\<in> set s\" \n    and card: \"?M = ?k\"\n    and sorted: \"sorted a\""], ["proof (prove)\nusing this:\n  distinct m\n  M = set m\n  card M = length m\n  complex_of_real sr \\<in> set m\n\ngoal (1 subgoal):\n 1. (M = set s &&& distinct s &&& complex_of_real sr \\<in> set s) &&&\n    card M = length a &&& sorted a", "unfolding s_def a_def"], ["proof (prove)\nusing this:\n  distinct m\n  M = set m\n  card M = length m\n  complex_of_real sr \\<in> set m\n\ngoal (1 subgoal):\n 1. (M = set (sort_key arg m) &&&\n     distinct (sort_key arg m) &&&\n     complex_of_real sr \\<in> set (sort_key arg m)) &&&\n    card M = length (map arg (sort_key arg m)) &&&\n    sorted (map arg (sort_key arg m))", "by auto"], ["proof (state)\nthis:\n  M = set s\n  distinct s\n  complex_of_real sr \\<in> set s\n  card M = length a\n  sorted a\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have map_s: \"map ((*) (c sr)) (map cis a) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((*) (complex_of_real sr)) (map cis a) = s", "unfolding map_map o_def a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. complex_of_real sr * cis (arg x)) s = s", "proof (rule map_idI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set s \\<Longrightarrow> complex_of_real sr * cis (arg x) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set s \\<Longrightarrow> complex_of_real sr * cis (arg x) = x", "assume \"x \\<in> set s\""], ["proof (state)\nthis:\n  x \\<in> set s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set s \\<Longrightarrow> complex_of_real sr * cis (arg x) = x", "from this[folded s(1), unfolded M]"], ["proof (chain)\npicking this:\n  x \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "have id: \"cmod x = sr\""], ["proof (prove)\nusing this:\n  x \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. cmod x = sr", "by auto"], ["proof (state)\nthis:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set s \\<Longrightarrow> complex_of_real sr * cis (arg x) = x", "show \"sr * cis (arg x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real sr * cis (arg x) = x", "by (subst (5) rcis_cmod_arg[symmetric], unfold id[symmetric] rcis_def, simp)"], ["proof (state)\nthis:\n  complex_of_real sr * cis (arg x) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((*) (complex_of_real sr)) (map cis a) = s\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from s(2)[folded map_s, unfolded distinct_map]"], ["proof (chain)\npicking this:\n  (distinct a \\<and> inj_on cis (set a)) \\<and>\n  inj_on ((*) (complex_of_real sr)) (set (map cis a))", "have a: \"distinct a\" \"inj_on cis (set a)\""], ["proof (prove)\nusing this:\n  (distinct a \\<and> inj_on cis (set a)) \\<and>\n  inj_on ((*) (complex_of_real sr)) (set (map cis a))\n\ngoal (1 subgoal):\n 1. distinct a &&& inj_on cis (set a)", "by auto"], ["proof (state)\nthis:\n  distinct a\n  inj_on cis (set a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from s(3)"], ["proof (chain)\npicking this:\n  complex_of_real sr \\<in> set s", "obtain aa a' where a_split: \"a = aa # a'\""], ["proof (prove)\nusing this:\n  complex_of_real sr \\<in> set s\n\ngoal (1 subgoal):\n 1. (\\<And>aa a'. a = aa # a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding a_def"], ["proof (prove)\nusing this:\n  complex_of_real sr \\<in> set s\n\ngoal (1 subgoal):\n 1. (\\<And>aa a'.\n        map arg s = aa # a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s, auto)"], ["proof (state)\nthis:\n  a = aa # a'\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from arg_bounded"], ["proof (chain)\npicking this:\n  - pi < arg ?z \\<and> arg ?z \\<le> pi", "have bounded: \"x \\<in> set a \\<Longrightarrow> - pi < x \\<and> x \\<le> pi\" for x"], ["proof (prove)\nusing this:\n  - pi < arg ?z \\<and> arg ?z \\<le> pi\n\ngoal (1 subgoal):\n 1. x \\<in> set a \\<Longrightarrow> - pi < x \\<and> x \\<le> pi", "unfolding a_def"], ["proof (prove)\nusing this:\n  - pi < arg ?z \\<and> arg ?z \\<le> pi\n\ngoal (1 subgoal):\n 1. x \\<in> set (map arg s) \\<Longrightarrow> - pi < x \\<and> x \\<le> pi", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set a \\<Longrightarrow> - pi < ?x \\<and> ?x \\<le> pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from bounded[of aa, unfolded a_split]"], ["proof (chain)\npicking this:\n  aa \\<in> set (aa # a') \\<Longrightarrow> - pi < aa \\<and> aa \\<le> pi", "have aa: \"- pi < aa \\<and> aa \\<le> pi\""], ["proof (prove)\nusing this:\n  aa \\<in> set (aa # a') \\<Longrightarrow> - pi < aa \\<and> aa \\<le> pi\n\ngoal (1 subgoal):\n 1. - pi < aa \\<and> aa \\<le> pi", "by auto"], ["proof (state)\nthis:\n  - pi < aa \\<and> aa \\<le> pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?aa = \"aa + 2 * pi\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "define args where \"args = a @ [?aa]\""], ["proof (state)\nthis:\n  args = a @ [aa + 2 * pi]\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?diff = \"\\<lambda> i. args ! Suc i - args ! i\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have bnd: \"x \\<in> set a \\<Longrightarrow> x < ?aa\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set a \\<Longrightarrow> x < aa + 2 * pi", "using aa bounded[of x]"], ["proof (prove)\nusing this:\n  - pi < aa \\<and> aa \\<le> pi\n  x \\<in> set a \\<Longrightarrow> - pi < x \\<and> x \\<le> pi\n\ngoal (1 subgoal):\n 1. x \\<in> set a \\<Longrightarrow> x < aa + 2 * pi", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set a \\<Longrightarrow> ?x < aa + 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "hence aa_a: \"?aa \\<notin> set a\""], ["proof (prove)\nusing this:\n  ?x \\<in> set a \\<Longrightarrow> ?x < aa + 2 * pi\n\ngoal (1 subgoal):\n 1. aa + 2 * pi \\<notin> set a", "by fast"], ["proof (state)\nthis:\n  aa + 2 * pi \\<notin> set a\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have sorted: \"sorted args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted args", "unfolding args_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (a @ [aa + 2 * pi])", "using sorted"], ["proof (prove)\nusing this:\n  sorted a\n\ngoal (1 subgoal):\n 1. sorted (a @ [aa + 2 * pi])", "unfolding sorted_append"], ["proof (prove)\nusing this:\n  sorted a\n\ngoal (1 subgoal):\n 1. sorted a \\<and>\n    sorted [aa + 2 * pi] \\<and>\n    (\\<forall>x\\<in>set a. Ball (set [aa + 2 * pi]) ((\\<le>) x))", "by (insert bnd, auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  sorted args\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have dist: \"distinct args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct args", "using a aa_a"], ["proof (prove)\nusing this:\n  distinct a\n  inj_on cis (set a)\n  aa + 2 * pi \\<notin> set a\n\ngoal (1 subgoal):\n 1. distinct args", "unfolding args_def distinct_append"], ["proof (prove)\nusing this:\n  distinct a\n  inj_on cis (set a)\n  aa + 2 * pi \\<notin> set a\n\ngoal (1 subgoal):\n 1. distinct a \\<and>\n    distinct [aa + 2 * pi] \\<and> set a \\<inter> set [aa + 2 * pi] = {}", "by auto"], ["proof (state)\nthis:\n  distinct args\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have sum: \"(\\<Sum> i < ?k. ?diff i) = 2 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length a. args ! Suc i - args ! i) = 2 * pi", "unfolding sum_lessThan_telescope args_def a_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((aa # a') @ [aa + 2 * pi]) ! length (aa # a') -\n    ((aa # a') @ [aa + 2 * pi]) ! 0 =\n    2 * pi", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length a. args ! Suc i - args ! i) = 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have k: \"?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length a \\<noteq> 0", "unfolding a_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (aa # a') \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length a \\<noteq> 0\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?A = \"?diff ` {..< ?k}\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?Min = \"Min ?A\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "define Min where \"Min = ?Min\""], ["proof (state)\nthis:\n  Min = (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"?Min = (?k * ?Min) / ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n    real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n    real (length a)", "using k"], ["proof (prove)\nusing this:\n  length a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n    real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n    real (length a)", "by auto"], ["proof (state)\nthis:\n  (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n  real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n  real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n  real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n  real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"?k * ?Min = (\\<Sum> i < ?k. ?Min)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n    (\\<Sum>i<length a. MIN i\\<in>{..<length a}. args ! Suc i - args ! i)", "by auto"], ["proof (state)\nthis:\n  real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n  (\\<Sum>i<length a. MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  real (length a) * (MIN i\\<in>{..<length a}. args ! Suc i - args ! i) =\n  (\\<Sum>i<length a. MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> / ?k \\<le> (\\<Sum> i < ?k. ?diff i) / ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length a. MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n    real (length a)\n    \\<le> (\\<Sum>i<length a. args ! Suc i - args ! i) / real (length a)", "by (rule divide_right_mono[OF sum_mono[OF Min_le]], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i<length a. MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n  real (length a)\n  \\<le> (\\<Sum>i<length a. args ! Suc i - args ! i) / real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length a. MIN i\\<in>{..<length a}. args ! Suc i - args ! i) /\n  real (length a)\n  \\<le> (\\<Sum>i<length a. args ! Suc i - args ! i) / real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> = 2 * pi / ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length a. args ! Suc i - args ! i) / real (length a) =\n    2 * pi / real (length a)", "unfolding sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi / real (length a) = 2 * pi / real (length a)", ".."], ["proof (state)\nthis:\n  (\\<Sum>i<length a. args ! Suc i - args ! i) / real (length a) =\n  2 * pi / real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "finally"], ["proof (chain)\npicking this:\n  (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n  \\<le> 2 * pi / real (length a)", "have Min: \"Min \\<le> 2 * pi / ?k\""], ["proof (prove)\nusing this:\n  (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n  \\<le> 2 * pi / real (length a)\n\ngoal (1 subgoal):\n 1. Min \\<le> 2 * pi / real (length a)", "unfolding Min_def"], ["proof (prove)\nusing this:\n  (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n  \\<le> 2 * pi / real (length a)\n\ngoal (1 subgoal):\n 1. (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n    \\<le> 2 * pi / real (length a)", "by auto"], ["proof (state)\nthis:\n  Min \\<le> 2 * pi / real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have lt: \"i < ?k \\<Longrightarrow> args ! i < args ! (Suc i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length a \\<Longrightarrow> args ! i < args ! Suc i", "using sorted[unfolded sorted_iff_nth_mono, rule_format, of i \"Suc i\"]\n    dist[unfolded distinct_conv_nth, rule_format, of \"Suc i\" i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> Suc i; Suc i < length args\\<rbrakk>\n  \\<Longrightarrow> args ! i \\<le> args ! Suc i\n  \\<lbrakk>Suc i < length args; i < length args; Suc i \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> args ! Suc i \\<noteq> args ! i\n\ngoal (1 subgoal):\n 1. i < length a \\<Longrightarrow> args ! i < args ! Suc i", "by (auto simp: args_def)"], ["proof (state)\nthis:\n  ?i < length a \\<Longrightarrow> args ! ?i < args ! Suc ?i\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?c = \"\\<lambda> i. rcis sr (args ! i)\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have hda[simp]: \"hd a = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd a = aa", "unfolding a_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (aa # a') = aa", "by simp"], ["proof (state)\nthis:\n  hd a = aa\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have Min0: \"Min > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min", "using lt"], ["proof (prove)\nusing this:\n  ?i < length a \\<Longrightarrow> args ! ?i < args ! Suc ?i\n\ngoal (1 subgoal):\n 1. 0 < Min", "unfolding Min_def"], ["proof (prove)\nusing this:\n  ?i < length a \\<Longrightarrow> args ! ?i < args ! Suc ?i\n\ngoal (1 subgoal):\n 1. 0 < (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)", "by (subst Min_gr_iff, insert k, auto)"], ["proof (state)\nthis:\n  0 < Min\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have Min_A: \"Min \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min \\<in> (\\<lambda>i. args ! Suc i - args ! i) ` {..<length a}", "unfolding Min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MIN i\\<in>{..<length a}. args ! Suc i - args ! i)\n    \\<in> (\\<lambda>i. args ! Suc i - args ! i) ` {..<length a}", "by (rule Min_in, insert k, auto)"], ["proof (state)\nthis:\n  Min \\<in> (\\<lambda>i. args ! Suc i - args ! i) ` {..<length a}\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "{"], ["proof (state)\nthis:\n  Min \\<in> (\\<lambda>i. args ! Suc i - args ! i) ` {..<length a}\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "fix i :: nat"], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "assume i: \"i < length args\""], ["proof (state)\nthis:\n  i < length args\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "hence \"?c i = rcis sr ((a @ [hd a]) ! i)\""], ["proof (prove)\nusing this:\n  i < length args\n\ngoal (1 subgoal):\n 1. rcis sr (args ! i) = rcis sr ((a @ [hd a]) ! i)", "by (cases \"i = ?k\", auto simp: args_def nth_append rcis_def)"], ["proof (state)\nthis:\n  rcis sr (args ! i) = rcis sr ((a @ [hd a]) ! i)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  rcis sr (args ! i) = rcis sr ((a @ [hd a]) ! i)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> \\<in> set (map (rcis sr) (a @ [hd a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr ((a @ [hd a]) ! i) \\<in> set (map (rcis sr) (a @ [hd a]))", "using i"], ["proof (prove)\nusing this:\n  i < length args\n\ngoal (1 subgoal):\n 1. rcis sr ((a @ [hd a]) ! i) \\<in> set (map (rcis sr) (a @ [hd a]))", "unfolding args_def set_map"], ["proof (prove)\nusing this:\n  i < length (a @ [aa + 2 * pi])\n\ngoal (1 subgoal):\n 1. rcis sr ((a @ [hd a]) ! i) \\<in> rcis sr ` set (a @ [hd a])", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  i < length (a @ [aa + 2 * pi])\n\ngoal (1 subgoal):\n 1. rcis sr ((a @ [hd a]) ! i)\n    \\<in> rcis sr ` {(a @ [hd a]) ! i |i. i < length (a @ [hd a])}", "by auto"], ["proof (state)\nthis:\n  rcis sr ((a @ [hd a]) ! i) \\<in> set (map (rcis sr) (a @ [hd a]))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  rcis sr ((a @ [hd a]) ! i) \\<in> set (map (rcis sr) (a @ [hd a]))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> = rcis sr ` set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (rcis sr) (a @ [hd a])) = rcis sr ` set a", "unfolding a_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (rcis sr) ((aa # a') @ [hd (aa # a')])) =\n    rcis sr ` set (aa # a')", "by auto"], ["proof (state)\nthis:\n  set (map (rcis sr) (a @ [hd a])) = rcis sr ` set a\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  set (map (rcis sr) (a @ [hd a])) = rcis sr ` set a\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr ` set a = M", "unfolding s(1) map_s[symmetric] set_map image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr ` set a = (\\<lambda>x. complex_of_real sr * cis x) ` set a", "by (rule image_cong[OF refl], auto simp: rcis_def)"], ["proof (state)\nthis:\n  rcis sr ` set a = M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "finally"], ["proof (chain)\npicking this:\n  rcis sr (args ! i) \\<in> M", "have \"?c i \\<in> M\""], ["proof (prove)\nusing this:\n  rcis sr (args ! i) \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (args ! i) \\<in> M", "by auto"], ["proof (state)\nthis:\n  rcis sr (args ! i) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "}"], ["proof (state)\nthis:\n  ?i2 < length args \\<Longrightarrow> rcis sr (args ! ?i2) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note ciM = this"], ["proof (state)\nthis:\n  ?i2 < length args \\<Longrightarrow> rcis sr (args ! ?i2) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "{"], ["proof (state)\nthis:\n  ?i2 < length args \\<Longrightarrow> rcis sr (args ! ?i2) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "fix i :: nat"], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "assume i: \"i < ?k\""], ["proof (state)\nthis:\n  i < length a\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "hence \"i < length args\" \"Suc i < length args\""], ["proof (prove)\nusing this:\n  i < length a\n\ngoal (1 subgoal):\n 1. i < length args &&& Suc i < length args", "unfolding args_def"], ["proof (prove)\nusing this:\n  i < length a\n\ngoal (1 subgoal):\n 1. i < length (a @ [aa + 2 * pi]) &&& Suc i < length (a @ [aa + 2 * pi])", "by auto"], ["proof (state)\nthis:\n  i < length args\n  Suc i < length args\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from maximal_eigen_values_group[OF M ciM[OF this(2)] ciM[OF this(1)]]"], ["proof (chain)\npicking this:\n  rcis sr (args ! Suc i + args ! i) \\<in> M\n  rcis sr (args ! Suc i - args ! i) \\<in> M\n  rcis sr 0 \\<in> M", "have \"rcis sr (?diff i) \\<in> M\""], ["proof (prove)\nusing this:\n  rcis sr (args ! Suc i + args ! i) \\<in> M\n  rcis sr (args ! Suc i - args ! i) \\<in> M\n  rcis sr 0 \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (args ! Suc i - args ! i) \\<in> M", "by simp"], ["proof (state)\nthis:\n  rcis sr (args ! Suc i - args ! i) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "}"], ["proof (state)\nthis:\n  ?i2 < length a \\<Longrightarrow>\n  rcis sr (args ! Suc ?i2 - args ! ?i2) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "hence Min_M: \"rcis sr Min \\<in> M\""], ["proof (prove)\nusing this:\n  ?i2 < length a \\<Longrightarrow>\n  rcis sr (args ! Suc ?i2 - args ! ?i2) \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr Min \\<in> M", "using Min_A"], ["proof (prove)\nusing this:\n  ?i2 < length a \\<Longrightarrow>\n  rcis sr (args ! Suc ?i2 - args ! ?i2) \\<in> M\n  Min \\<in> (\\<lambda>i. args ! Suc i - args ! i) ` {..<length a}\n\ngoal (1 subgoal):\n 1. rcis sr Min \\<in> M", "by force"], ["proof (state)\nthis:\n  rcis sr Min \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have rcisM: \"rcis sr (of_nat n * Min) \\<in> M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr (real n * Min) \\<in> M", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. rcis sr (real 0 * Min) \\<in> M\n 2. \\<And>n.\n       rcis sr (real n * Min) \\<in> M \\<Longrightarrow>\n       rcis sr (real (Suc n) * Min) \\<in> M", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rcis sr (real 0 * Min) \\<in> M\n 2. \\<And>n.\n       rcis sr (real n * Min) \\<in> M \\<Longrightarrow>\n       rcis sr (real (Suc n) * Min) \\<in> M", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr (real 0 * Min) \\<in> M", "using sr Mm"], ["proof (prove)\nusing this:\n  complex_of_real sr \\<in> set m\n  M = set m\n\ngoal (1 subgoal):\n 1. rcis sr (real 0 * Min) \\<in> M", "by auto"], ["proof (state)\nthis:\n  rcis sr (real 0 * Min) \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       rcis sr (real n * Min) \\<in> M \\<Longrightarrow>\n       rcis sr (real (Suc n) * Min) \\<in> M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       rcis sr (real n * Min) \\<in> M \\<Longrightarrow>\n       rcis sr (real (Suc n) * Min) \\<in> M", "case (Suc n)"], ["proof (state)\nthis:\n  rcis sr (real n * Min) \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       rcis sr (real n * Min) \\<in> M \\<Longrightarrow>\n       rcis sr (real (Suc n) * Min) \\<in> M", "have *: \"rcis sr (of_nat (Suc n) * Min) = rcis sr (of_nat n * Min) * cis Min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis sr (real (Suc n) * Min) = rcis sr (real n * Min) * cis Min", "by (simp add: rcis_mult ring_distribs add.commute)"], ["proof (state)\nthis:\n  rcis sr (real (Suc n) * Min) = rcis sr (real n * Min) * cis Min\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       rcis sr (real n * Min) \\<in> M \\<Longrightarrow>\n       rcis sr (real (Suc n) * Min) \\<in> M", "from maximal_eigen_values_group(1)[OF M Suc Min_M]"], ["proof (chain)\npicking this:\n  rcis sr (real n * Min + Min) \\<in> M", "show ?case"], ["proof (prove)\nusing this:\n  rcis sr (real n * Min + Min) \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (real (Suc n) * Min) \\<in> M", "unfolding *"], ["proof (prove)\nusing this:\n  rcis sr (real n * Min + Min) \\<in> M\n\ngoal (1 subgoal):\n 1. rcis sr (real n * Min) * cis Min \\<in> M", "by simp"], ["proof (state)\nthis:\n  rcis sr (real (Suc n) * Min) \\<in> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rcis sr (real ?n * Min) \\<in> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?list = \"map (rcis sr) (map (\\<lambda> i. of_nat i * Min) [0 ..< ?k])\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "define list where \"list = ?list\""], ["proof (state)\nthis:\n  list = map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have len: \"length ?list = ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n    card M", "unfolding card"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n    length a", "by simp"], ["proof (state)\nthis:\n  length (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n  card M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from sr_pos"], ["proof (chain)\npicking this:\n  0 < sr", "have sr0: \"sr \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < sr\n\ngoal (1 subgoal):\n 1. sr \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  sr \\<noteq> 0\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "{"], ["proof (state)\nthis:\n  sr \\<noteq> 0\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "fix i"], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "assume i: \"i < ?k\""], ["proof (state)\nthis:\n  i < length a\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "hence *: \"0 \\<le> real i * Min\""], ["proof (prove)\nusing this:\n  i < length a\n\ngoal (1 subgoal):\n 1. 0 \\<le> real i * Min", "using Min0"], ["proof (prove)\nusing this:\n  i < length a\n  0 < Min\n\ngoal (1 subgoal):\n 1. 0 \\<le> real i * Min", "by auto"], ["proof (state)\nthis:\n  0 \\<le> real i * Min\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from i"], ["proof (chain)\npicking this:\n  i < length a", "have \"real i < real ?k\""], ["proof (prove)\nusing this:\n  i < length a\n\ngoal (1 subgoal):\n 1. real i < real (length a)", "by auto"], ["proof (state)\nthis:\n  real i < real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from mult_strict_right_mono[OF this Min0]"], ["proof (chain)\npicking this:\n  real i * Min < real (length a) * Min", "have \"real i * Min < real ?k * Min\""], ["proof (prove)\nusing this:\n  real i * Min < real (length a) * Min\n\ngoal (1 subgoal):\n 1. real i * Min < real (length a) * Min", "by simp"], ["proof (state)\nthis:\n  real i * Min < real (length a) * Min\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  real i * Min < real (length a) * Min\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> \\<le> real ?k * (2 * pi / real ?k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length a) * Min \\<le> real (length a) * (2 * pi / real (length a))", "by (rule mult_left_mono[OF Min], auto)"], ["proof (state)\nthis:\n  real (length a) * Min \\<le> real (length a) * (2 * pi / real (length a))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  real (length a) * Min \\<le> real (length a) * (2 * pi / real (length a))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> = 2 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (length a) * (2 * pi / real (length a)) = 2 * pi", "using k"], ["proof (prove)\nusing this:\n  length a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real (length a) * (2 * pi / real (length a)) = 2 * pi", "by simp"], ["proof (state)\nthis:\n  real (length a) * (2 * pi / real (length a)) = 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "finally"], ["proof (chain)\npicking this:\n  real i * Min < 2 * pi", "have \"real i * Min < 2 * pi\""], ["proof (prove)\nusing this:\n  real i * Min < 2 * pi\n\ngoal (1 subgoal):\n 1. real i * Min < 2 * pi", "."], ["proof (state)\nthis:\n  real i * Min < 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note * this"], ["proof (state)\nthis:\n  0 \\<le> real i * Min\n  real i * Min < 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "}"], ["proof (state)\nthis:\n  ?i2 < length a \\<Longrightarrow> 0 \\<le> real ?i2 * Min\n  ?i2 < length a \\<Longrightarrow> real ?i2 * Min < 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note prod_pi = this"], ["proof (state)\nthis:\n  ?i2 < length a \\<Longrightarrow> 0 \\<le> real ?i2 * Min\n  ?i2 < length a \\<Longrightarrow> real ?i2 * Min < 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have dist: \"distinct ?list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))", "unfolding distinct_map[of \"rcis sr\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>i. real i * Min) [0..<length a]) \\<and>\n    inj_on (rcis sr) (set (map (\\<lambda>i. real i * Min) [0..<length a]))", "proof (rule conjI[OF _ inj_on_subset[OF rcis_inj_on[OF sr0]]])"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>i. real i * Min) [0..<length a])\n 2. set (map (\\<lambda>i. real i * Min) [0..<length a])\n    \\<subseteq> {0..<2 * pi}", "show \"distinct (map (\\<lambda> i. of_nat i * Min) [0 ..< ?k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>i. real i * Min) [0..<length a])", "using Min0"], ["proof (prove)\nusing this:\n  0 < Min\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>i. real i * Min) [0..<length a])", "by (auto simp: distinct_map inj_on_def)"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>i. real i * Min) [0..<length a])\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. real i * Min) [0..<length a])\n    \\<subseteq> {0..<2 * pi}", "show \"set (map (\\<lambda>i. real i * Min) [0..<?k]) \\<subseteq> {0..<2 * pi}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. real i * Min) [0..<length a])\n    \\<subseteq> {0..<2 * pi}", "using prod_pi"], ["proof (prove)\nusing this:\n  ?i2 < length a \\<Longrightarrow> 0 \\<le> real ?i2 * Min\n  ?i2 < length a \\<Longrightarrow> real ?i2 * Min < 2 * pi\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. real i * Min) [0..<length a])\n    \\<subseteq> {0..<2 * pi}", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>i. real i * Min) [0..<length a])\n  \\<subseteq> {0..<2 * pi}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "with len"], ["proof (chain)\npicking this:\n  length (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n  card M\n  distinct (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))", "have card': \"card (set ?list) = ?M\""], ["proof (prove)\nusing this:\n  length (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n  card M\n  distinct (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (1 subgoal):\n 1. card\n     (set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))) =\n    card M", "using distinct_card"], ["proof (prove)\nusing this:\n  length (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n  card M\n  distinct (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. card\n     (set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))) =\n    card M", "by fastforce"], ["proof (state)\nthis:\n  card\n   (set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))) =\n  card M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have listM: \"set ?list \\<subseteq> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n    \\<subseteq> M", "using rcisM"], ["proof (prove)\nusing this:\n  rcis sr (real ?n * Min) \\<in> M\n\ngoal (1 subgoal):\n 1. set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n    \\<subseteq> M", "by auto"], ["proof (state)\nthis:\n  set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n  \\<subseteq> M\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from card_subset_eq[OF finM listM card']"], ["proof (chain)\npicking this:\n  set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) = M", "have M_list: \"M = set ?list\""], ["proof (prove)\nusing this:\n  set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) = M\n\ngoal (1 subgoal):\n 1. M = set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))", ".."], ["proof (state)\nthis:\n  M = set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?piM = \"2 * pi / ?M\""], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "assume \"Min \\<noteq> ?piM\""], ["proof (state)\nthis:\n  Min \\<noteq> 2 * pi / real (card M)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "with Min"], ["proof (chain)\npicking this:\n  Min \\<le> 2 * pi / real (length a)\n  Min \\<noteq> 2 * pi / real (card M)", "have lt: \"Min < 2 * pi / ?k\""], ["proof (prove)\nusing this:\n  Min \\<le> 2 * pi / real (length a)\n  Min \\<noteq> 2 * pi / real (card M)\n\ngoal (1 subgoal):\n 1. Min < 2 * pi / real (length a)", "unfolding card"], ["proof (prove)\nusing this:\n  Min \\<le> 2 * pi / real (length a)\n  Min \\<noteq> 2 * pi / real (length a)\n\ngoal (1 subgoal):\n 1. Min < 2 * pi / real (length a)", "by simp"], ["proof (state)\nthis:\n  Min < 2 * pi / real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from k"], ["proof (chain)\npicking this:\n  length a \\<noteq> 0", "have \"0 < real ?k\""], ["proof (prove)\nusing this:\n  length a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < real (length a)", "by auto"], ["proof (state)\nthis:\n  0 < real (length a)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from mult_strict_left_mono[OF lt this] k Min0"], ["proof (chain)\npicking this:\n  real (length a) * Min < real (length a) * (2 * pi / real (length a))\n  length a \\<noteq> 0\n  0 < Min", "have k: \"0 \\<le> ?k * Min\" \"?k * Min < 2 * pi\""], ["proof (prove)\nusing this:\n  real (length a) * Min < real (length a) * (2 * pi / real (length a))\n  length a \\<noteq> 0\n  0 < Min\n\ngoal (1 subgoal):\n 1. 0 \\<le> real (length a) * Min &&& real (length a) * Min < 2 * pi", "by auto"], ["proof (state)\nthis:\n  0 \\<le> real (length a) * Min\n  real (length a) * Min < 2 * pi\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from rcisM[of ?k, unfolded M_list]"], ["proof (chain)\npicking this:\n  rcis sr (real (length a) * Min)\n  \\<in> set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))", "have \"rcis sr (?k * Min) \\<in> set ?list\""], ["proof (prove)\nusing this:\n  rcis sr (real (length a) * Min)\n  \\<in> set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (1 subgoal):\n 1. rcis sr (real (length a) * Min)\n    \\<in> set (map (rcis sr)\n                (map (\\<lambda>i. real i * Min) [0..<length a]))", "by auto"], ["proof (state)\nthis:\n  rcis sr (real (length a) * Min)\n  \\<in> set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "then"], ["proof (chain)\npicking this:\n  rcis sr (real (length a) * Min)\n  \\<in> set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))", "obtain i where i: \"i < ?k\" and id: \"rcis sr (?k * Min) = rcis sr (i * Min)\""], ["proof (prove)\nusing this:\n  rcis sr (real (length a) * Min)\n  \\<in> set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length a;\n         rcis sr (real (length a) * Min) = rcis sr (real i * Min)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length a\n  rcis sr (real (length a) * Min) = rcis sr (real i * Min)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from inj_onD[OF inj_on_subset[OF rcis_inj_on[OF sr0], of \"{?k * Min, i * Min}\"] id] \n      prod_pi[OF i] k"], ["proof (chain)\npicking this:\n  \\<lbrakk>{real (length a) * Min, real i * Min} \\<subseteq> {0..<2 * pi};\n   real (length a) * Min \\<in> {real (length a) * Min, real i * Min};\n   real i * Min \\<in> {real (length a) * Min, real i * Min}\\<rbrakk>\n  \\<Longrightarrow> real (length a) * Min = real i * Min\n  0 \\<le> real i * Min\n  real i * Min < 2 * pi\n  0 \\<le> real (length a) * Min\n  real (length a) * Min < 2 * pi", "have \"?k * Min = i * Min\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{real (length a) * Min, real i * Min} \\<subseteq> {0..<2 * pi};\n   real (length a) * Min \\<in> {real (length a) * Min, real i * Min};\n   real i * Min \\<in> {real (length a) * Min, real i * Min}\\<rbrakk>\n  \\<Longrightarrow> real (length a) * Min = real i * Min\n  0 \\<le> real i * Min\n  real i * Min < 2 * pi\n  0 \\<le> real (length a) * Min\n  real (length a) * Min < 2 * pi\n\ngoal (1 subgoal):\n 1. real (length a) * Min = real i * Min", "by auto"], ["proof (state)\nthis:\n  real (length a) * Min = real i * Min\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "with Min0 i"], ["proof (chain)\npicking this:\n  0 < Min\n  i < length a\n  real (length a) * Min = real i * Min", "have False"], ["proof (prove)\nusing this:\n  0 < Min\n  i < length a\n  real (length a) * Min = real i * Min\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "}"], ["proof (state)\nthis:\n  Min \\<noteq> 2 * pi / real (card M) \\<Longrightarrow> False\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "hence Min: \"Min = ?piM\""], ["proof (prove)\nusing this:\n  Min \\<noteq> 2 * pi / real (card M) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Min = 2 * pi / real (card M)", "by auto"], ["proof (state)\nthis:\n  Min = 2 * pi / real (card M)\n\ngoal (5 subgoals):\n 1. card M \\<noteq> 0\n 2. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 3. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 4. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 5. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "show cM: \"?M \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card M \\<noteq> 0", "unfolding card"], ["proof (prove)\ngoal (1 subgoal):\n 1. length a \\<noteq> 0", "using k"], ["proof (prove)\nusing this:\n  length a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card M \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 3. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 4. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?f = \"(\\<lambda> i. cis (of_nat i * 2 * pi / ?M))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 3. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 4. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note M_list"], ["proof (state)\nthis:\n  M = set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (4 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 3. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 4. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  M = set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a]))\n\ngoal (4 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 3. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 4. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"set ?list = (*) (c sr) ` (\\<lambda> i. cis (of_nat i * Min)) ` {0 ..< ?k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * Min)) ` {0..<length a}", "unfolding set_map image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. rcis sr (real x * Min)) ` set [0..<length a] =\n    (\\<lambda>x. complex_of_real sr * cis (real x * Min)) ` {0..<length a}", "by (rule image_cong, insert sr_pos, auto simp: rcis_mult rcis_def)"], ["proof (state)\nthis:\n  set (map (rcis sr) (map (\\<lambda>i. real i * Min) [0..<length a])) =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * Min)) ` {0..<length a}\n\ngoal (4 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n 3. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 4. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "finally"], ["proof (chain)\npicking this:\n  M =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * Min)) ` {0..<length a}", "show M_cis: \"M = (*) (c sr) ` ?f ` {0 ..< ?M}\""], ["proof (prove)\nusing this:\n  M =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * Min)) ` {0..<length a}\n\ngoal (1 subgoal):\n 1. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}", "unfolding card Min"], ["proof (prove)\nusing this:\n  M =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * (2 * pi / real (length a)))) ` {0..<length a}\n\ngoal (1 subgoal):\n 1. M =\n    (*) (complex_of_real sr) `\n    (\\<lambda>i. cis (real i * 2 * pi / real (length a))) ` {0..<length a}", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  M =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n\ngoal (3 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n 3. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "thus M_pow: \"M = (*) (c sr) ` { x :: complex. x ^ ?M = 1}\""], ["proof (prove)\nusing this:\n  M =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n\ngoal (1 subgoal):\n 1. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}", "using roots_of_unity[OF cM]"], ["proof (prove)\nusing this:\n  M =\n  (*) (complex_of_real sr) `\n  (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M}\n  (\\<lambda>i. cis (real i * 2 * pi / real (card M))) ` {0..<card M} =\n  {x. x ^ card M = 1}\n  {x. poly (root_unity (card M)) x = 0} = {x. x ^ card M = 1}\n  card {x. x ^ card M = 1} = card M\n\ngoal (1 subgoal):\n 1. M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}", "by simp"], ["proof (state)\nthis:\n  M = (*) (complex_of_real sr) ` {x. x ^ card M = 1}\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?rphi = \"rcis sr (2 * pi / ?M)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "let ?phi = \"cis (2 * pi / ?M)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from Min_M[unfolded Min]"], ["proof (chain)\npicking this:\n  rcis sr (2 * pi / real (card M)) \\<in> M", "have ev: \"eigen_value cA ?rphi\""], ["proof (prove)\nusing this:\n  rcis sr (2 * pi / real (card M)) \\<in> M\n\ngoal (1 subgoal):\n 1. eigen_value cA (rcis sr (2 * pi / real (card M)))", "unfolding M"], ["proof (prove)\nusing this:\n  rcis sr (2 * pi / real (card {ev. eigen_value cA ev \\<and> cmod ev = sr}))\n  \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. eigen_value cA\n     (rcis sr\n       (2 * pi / real (card {ev. eigen_value cA ev \\<and> cmod ev = sr})))", "by auto"], ["proof (state)\nthis:\n  eigen_value cA (rcis sr (2 * pi / real (card M)))\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have cm: \"cmod ?rphi = sr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (rcis sr (2 * pi / real (card M))) = sr", "using sr_pos"], ["proof (prove)\nusing this:\n  0 < sr\n\ngoal (1 subgoal):\n 1. cmod (rcis sr (2 * pi / real (card M))) = sr", "by simp"], ["proof (state)\nthis:\n  cmod (rcis sr (2 * pi / real (card M))) = sr\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have id: \"cis (arg ?rphi) = cis (arg ?phi) * cmod ?phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (rcis sr (2 * pi / real (card M)))) =\n    cis (arg (cis (2 * pi / real (card M)))) *\n    complex_of_real (cmod (cis (2 * pi / real (card M))))", "unfolding arg_rcis_cis[OF sr_pos]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (cis (2 * pi / real (card M)))) =\n    cis (arg (cis (2 * pi / real (card M)))) *\n    complex_of_real (cmod (cis (2 * pi / real (card M))))", "by simp"], ["proof (state)\nthis:\n  cis (arg (rcis sr (2 * pi / real (card M)))) =\n  cis (arg (cis (2 * pi / real (card M)))) *\n  complex_of_real (cmod (cis (2 * pi / real (card M))))\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "also"], ["proof (state)\nthis:\n  cis (arg (rcis sr (2 * pi / real (card M)))) =\n  cis (arg (cis (2 * pi / real (card M)))) *\n  complex_of_real (cmod (cis (2 * pi / real (card M))))\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"\\<dots> = ?phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (cis (2 * pi / real (card M)))) *\n    complex_of_real (cmod (cis (2 * pi / real (card M)))) =\n    cis (2 * pi / real (card M))", "unfolding cis_mult_cmod_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (2 * pi / real (card M)) = cis (2 * pi / real (card M))", ".."], ["proof (state)\nthis:\n  cis (arg (cis (2 * pi / real (card M)))) *\n  complex_of_real (cmod (cis (2 * pi / real (card M)))) =\n  cis (2 * pi / real (card M))\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "finally"], ["proof (chain)\npicking this:\n  cis (arg (rcis sr (2 * pi / real (card M)))) =\n  cis (2 * pi / real (card M))", "have id: \"cis (arg ?rphi) = ?phi\""], ["proof (prove)\nusing this:\n  cis (arg (rcis sr (2 * pi / real (card M)))) =\n  cis (2 * pi / real (card M))\n\ngoal (1 subgoal):\n 1. cis (arg (rcis sr (2 * pi / real (card M)))) =\n    cis (2 * pi / real (card M))", "."], ["proof (state)\nthis:\n  cis (arg (rcis sr (2 * pi / real (card M)))) =\n  cis (2 * pi / real (card M))\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "define phi where \"phi = ?phi\""], ["proof (state)\nthis:\n  phi = cis (2 * pi / real (card M))\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have phi: \"phi \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi \\<noteq> 0", "unfolding phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (2 * pi / real (card M)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  phi \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "note max = maximal_eigen_value_rotation[OF ev cm, unfolded id phi_def[symmetric]]"], ["proof (state)\nthis:\n  eigen_value cA (?x * phi) = eigen_value cA ?x\n  eigen_value cA (?x / phi) = eigen_value cA ?x\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "have \"((*) phi) ` Spectrum cA = Spectrum cA\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "have *: \"x \\<in> ?L \\<Longrightarrow> x \\<in> ?R\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> x \\<in> Spectrum cA", "using max(2)[of x] phi"], ["proof (prove)\nusing this:\n  eigen_value cA (x / phi) = eigen_value cA x\n  phi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> x \\<in> Spectrum cA", "unfolding Spectrum_def"], ["proof (prove)\nusing this:\n  eigen_value cA (x / phi) = eigen_value cA x\n  phi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> (*) phi ` Collect (eigen_value cA) \\<Longrightarrow>\n    x \\<in> Collect (eigen_value cA)", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> ?x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> ?x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "{"], ["proof (state)\nthis:\n  ?x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> ?x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "assume \"x \\<in> ?R\""], ["proof (state)\nthis:\n  x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "hence \"eigen_value cA x\""], ["proof (prove)\nusing this:\n  x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. eigen_value cA x", "unfolding Spectrum_def"], ["proof (prove)\nusing this:\n  x \\<in> Collect (eigen_value cA)\n\ngoal (1 subgoal):\n 1. eigen_value cA x", "by auto"], ["proof (state)\nthis:\n  eigen_value cA x\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "from this[folded max(2)[of x]]"], ["proof (chain)\npicking this:\n  eigen_value cA (x / phi)", "have \"x / phi \\<in> ?R\""], ["proof (prove)\nusing this:\n  eigen_value cA (x / phi)\n\ngoal (1 subgoal):\n 1. x / phi \\<in> Spectrum cA", "unfolding Spectrum_def"], ["proof (prove)\nusing this:\n  eigen_value cA (x / phi)\n\ngoal (1 subgoal):\n 1. x / phi \\<in> Collect (eigen_value cA)", "by auto"], ["proof (state)\nthis:\n  x / phi \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "from imageI[OF this, of \"(*) phi\"]"], ["proof (chain)\npicking this:\n  phi * (x / phi) \\<in> (*) phi ` Spectrum cA", "have \"x \\<in> ?L\""], ["proof (prove)\nusing this:\n  phi * (x / phi) \\<in> (*) phi ` Spectrum cA\n\ngoal (1 subgoal):\n 1. x \\<in> (*) phi ` Spectrum cA", "using phi"], ["proof (prove)\nusing this:\n  phi * (x / phi) \\<in> (*) phi ` Spectrum cA\n  phi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> (*) phi ` Spectrum cA", "by auto"], ["proof (state)\nthis:\n  x \\<in> (*) phi ` Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "}"], ["proof (state)\nthis:\n  x \\<in> Spectrum cA \\<Longrightarrow> x \\<in> (*) phi ` Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "note this *"], ["proof (state)\nthis:\n  x \\<in> Spectrum cA \\<Longrightarrow> x \\<in> (*) phi ` Spectrum cA\n  ?x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> ?x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "}"], ["proof (state)\nthis:\n  ?x3 \\<in> Spectrum cA \\<Longrightarrow> ?x3 \\<in> (*) phi ` Spectrum cA\n  ?x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> ?x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x3 \\<in> Spectrum cA \\<Longrightarrow> ?x3 \\<in> (*) phi ` Spectrum cA\n  ?x \\<in> (*) phi ` Spectrum cA \\<Longrightarrow> ?x \\<in> Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) phi ` Spectrum cA = Spectrum cA", "by blast"], ["proof (state)\nthis:\n  (*) phi ` Spectrum cA = Spectrum cA\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (*) phi ` Spectrum cA = Spectrum cA\n\ngoal (2 subgoals):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)\n 2. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "from this[unfolded phi_def]"], ["proof (chain)\npicking this:\n  (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "show \"(*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA\""], ["proof (prove)\nusing this:\n  (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA\n\ngoal (1 subgoal):\n 1. (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA", "."], ["proof (state)\nthis:\n  (*) (cis (2 * pi / real (card M))) ` Spectrum cA = Spectrum cA\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?p = \"monom 1 k - [:sr^k:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?cp = \"monom 1 k - [:(c sr)^k:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?one = \"1 :: complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?list = \"map (rcis sr) (map (\\<lambda> i. of_nat i * ?piM) [0 ..< card M])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "interpret c: field_hom c"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "interpret p: map_poly_inj_idom_divide_hom c"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_divide_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have cp: \"?cp = map_poly c ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 k - [:complex_of_real sr ^ k:] =\n    map_poly complex_of_real (monom 1 k - [:sr ^ k:])", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  monom 1 k - [:complex_of_real sr ^ k:] =\n  map_poly complex_of_real (monom 1 k - [:sr ^ k:])\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have M_list: \"M = set ?list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M =\n    set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))", "using M_list[unfolded Min card[symmetric]]"], ["proof (prove)\nusing this:\n  M =\n  set (map (rcis sr)\n        (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))\n\ngoal (1 subgoal):\n 1. M =\n    set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))", "."], ["proof (state)\nthis:\n  M =\n  set (map (rcis sr)\n        (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have dist: \"distinct ?list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (rcis sr)\n       (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))", "using dist[unfolded Min card[symmetric]]"], ["proof (prove)\nusing this:\n  distinct\n   (map (rcis sr)\n     (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (rcis sr)\n       (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))", "."], ["proof (state)\nthis:\n  distinct\n   (map (rcis sr)\n     (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have k0: \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "using k[folded card] assms"], ["proof (prove)\nusing this:\n  card M \\<noteq> 0\n  M = {ev. eigen_value cA ev \\<and> cmod ev = sr}\n  k = card M\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"?cp = (monom 1 k + (- [:(c sr)^k:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 k - [:complex_of_real sr ^ k:] =\n    monom 1 k + - [:complex_of_real sr ^ k:]", "by simp"], ["proof (state)\nthis:\n  monom 1 k - [:complex_of_real sr ^ k:] =\n  monom 1 k + - [:complex_of_real sr ^ k:]\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "also"], ["proof (state)\nthis:\n  monom 1 k - [:complex_of_real sr ^ k:] =\n  monom 1 k + - [:complex_of_real sr ^ k:]\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"degree \\<dots> = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 k + - [:complex_of_real sr ^ k:]) = k", "by (subst degree_add_eq_left, insert k0, auto simp: degree_monom_eq)"], ["proof (state)\nthis:\n  degree (monom 1 k + - [:complex_of_real sr ^ k:]) = k\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "finally"], ["proof (chain)\npicking this:\n  degree (monom 1 k - [:complex_of_real sr ^ k:]) = k", "have deg: \"degree ?cp = k\""], ["proof (prove)\nusing this:\n  degree (monom 1 k - [:complex_of_real sr ^ k:]) = k\n\ngoal (1 subgoal):\n 1. degree (monom 1 k - [:complex_of_real sr ^ k:]) = k", "."], ["proof (state)\nthis:\n  degree (monom 1 k - [:complex_of_real sr ^ k:]) = k\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "from deg k0"], ["proof (chain)\npicking this:\n  degree (monom 1 k - [:complex_of_real sr ^ k:]) = k\n  k \\<noteq> 0", "have cp0: \"?cp \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (monom 1 k - [:complex_of_real sr ^ k:]) = k\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monom 1 k - [:complex_of_real sr ^ k:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monom 1 k - [:complex_of_real sr ^ k:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"{x. poly ?cp x = 0} = {x. x^k = (c sr)^k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} =\n    {x. x ^ k = complex_of_real sr ^ k}", "unfolding poly_diff poly_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 * x ^ k - poly [:complex_of_real sr ^ k:] x = 0} =\n    {x. x ^ k = complex_of_real sr ^ k}", "by simp"], ["proof (state)\nthis:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} =\n  {x. x ^ k = complex_of_real sr ^ k}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "also"], ["proof (state)\nthis:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} =\n  {x. x ^ k = complex_of_real sr ^ k}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"\\<dots> \\<subseteq> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "assume id: \"x^k = (c sr)^k\""], ["proof (state)\nthis:\n  x ^ k = complex_of_real sr ^ k\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "from sr_pos k0"], ["proof (chain)\npicking this:\n  0 < sr\n  k \\<noteq> 0", "have \"(c sr)^k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < sr\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. complex_of_real sr ^ k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  complex_of_real sr ^ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "with arg_cong[OF id, of \"\\<lambda> x. x / (c sr)^k\"]"], ["proof (chain)\npicking this:\n  x ^ k / complex_of_real sr ^ k =\n  complex_of_real sr ^ k / complex_of_real sr ^ k\n  complex_of_real sr ^ k \\<noteq> 0", "have \"(x / c sr)^k = 1\""], ["proof (prove)\nusing this:\n  x ^ k / complex_of_real sr ^ k =\n  complex_of_real sr ^ k / complex_of_real sr ^ k\n  complex_of_real sr ^ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x / complex_of_real sr) ^ k = 1", "unfolding power_divide"], ["proof (prove)\nusing this:\n  x ^ k / complex_of_real sr ^ k =\n  complex_of_real sr ^ k / complex_of_real sr ^ k\n  complex_of_real sr ^ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x ^ k / complex_of_real sr ^ k = 1", "by auto"], ["proof (state)\nthis:\n  (x / complex_of_real sr) ^ k = 1\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "hence \"c sr * (x / c sr) \\<in> M\""], ["proof (prove)\nusing this:\n  (x / complex_of_real sr) ^ k = 1\n\ngoal (1 subgoal):\n 1. complex_of_real sr * (x / complex_of_real sr) \\<in> M", "by (subst M_pow, unfold kM[symmetric], blast)"], ["proof (state)\nthis:\n  complex_of_real sr * (x / complex_of_real sr) \\<in> M\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "also"], ["proof (state)\nthis:\n  complex_of_real sr * (x / complex_of_real sr) \\<in> M\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "have \"c sr * (x / c sr) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real sr * (x / complex_of_real sr) = x", "using sr_pos"], ["proof (prove)\nusing this:\n  0 < sr\n\ngoal (1 subgoal):\n 1. complex_of_real sr * (x / complex_of_real sr) = x", "by auto"], ["proof (state)\nthis:\n  complex_of_real sr * (x / complex_of_real sr) = x\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "finally"], ["proof (chain)\npicking this:\n  x \\<in> M", "have \"x \\<in> M\""], ["proof (prove)\nusing this:\n  x \\<in> M\n\ngoal (1 subgoal):\n 1. x \\<in> M", "."], ["proof (state)\nthis:\n  x \\<in> M\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "}"], ["proof (state)\nthis:\n  ?x2 ^ k = complex_of_real sr ^ k \\<Longrightarrow> ?x2 \\<in> M\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x2 ^ k = complex_of_real sr ^ k \\<Longrightarrow> ?x2 \\<in> M\n\ngoal (1 subgoal):\n 1. {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M", "by auto"], ["proof (state)\nthis:\n  {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. x ^ k = complex_of_real sr ^ k} \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "finally"], ["proof (chain)\npicking this:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M", "have cp_M: \"{x. poly ?cp x = 0} \\<subseteq> M\""], ["proof (prove)\nusing this:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M\n\ngoal (1 subgoal):\n 1. {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M", "."], ["proof (state)\nthis:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"k = card (set ?list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k =\n    card\n     (set (map (rcis sr)\n            (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n              [0..<card M])))", "unfolding distinct_card[OF dist]"], ["proof (prove)\ngoal (1 subgoal):\n 1. k =\n    length\n     (map (rcis sr)\n       (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))", "by (simp add: kM)"], ["proof (state)\nthis:\n  k =\n  card\n   (set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M])))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "also"], ["proof (state)\nthis:\n  k =\n  card\n   (set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M])))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have \"\\<dots> \\<le> card {x. poly ?cp x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (map (rcis sr)\n            (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n              [0..<card M])))\n    \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "proof (rule card_mono[OF poly_roots_finite[OF cp0]])"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "assume \"x \\<in> set ?list\""], ["proof (state)\nthis:\n  x \\<in> set (map (rcis sr)\n                (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n                  [0..<card M]))\n\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (map (rcis sr)\n                (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n                  [0..<card M]))", "obtain i where x: \"x = rcis sr (real i * ?piM)\""], ["proof (prove)\nusing this:\n  x \\<in> set (map (rcis sr)\n                (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n                  [0..<card M]))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        x = rcis sr (real i * (2 * pi / real (card M))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = rcis sr (real i * (2 * pi / real (card M)))\n\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "have \"x^k = (c sr)^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ k = complex_of_real sr ^ k", "unfolding x DeMoivre2 kM"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis (sr ^ card M)\n     (real (card M) * (real i * (2 * pi / real (card M)))) =\n    complex_of_real sr ^ card M", "by simp (metis mult.assoc of_real_power rcis_times_2pi)"], ["proof (state)\nthis:\n  x ^ k = complex_of_real sr ^ k\n\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "hence \"poly ?cp x = 0\""], ["proof (prove)\nusing this:\n  x ^ k = complex_of_real sr ^ k\n\ngoal (1 subgoal):\n 1. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0", "unfolding poly_diff poly_monom"], ["proof (prove)\nusing this:\n  x ^ k = complex_of_real sr ^ k\n\ngoal (1 subgoal):\n 1. 1 * x ^ k - poly [:complex_of_real sr ^ k:] x = 0", "by simp"], ["proof (state)\nthis:\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0\n\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> set (map (rcis sr)\n              (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n                [0..<card M])) \\<Longrightarrow>\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) ?x2 = 0\n\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "thus \"set ?list \\<subseteq> {x. poly ?cp x = 0}\""], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> set (map (rcis sr)\n              (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n                [0..<card M])) \\<Longrightarrow>\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) ?x2 = 0\n\ngoal (1 subgoal):\n 1. set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M]))\n    \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "by auto"], ["proof (state)\nthis:\n  set (map (rcis sr)\n        (map (\\<lambda>i. real i * (2 * pi / real (card M))) [0..<card M]))\n  \\<subseteq> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   (set (map (rcis sr)\n          (map (\\<lambda>i. real i * (2 * pi / real (card M)))\n            [0..<card M])))\n  \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "finally"], ["proof (chain)\npicking this:\n  k \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "have k_card: \"k \\<le> card {x. poly ?cp x = 0}\""], ["proof (prove)\nusing this:\n  k \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n\ngoal (1 subgoal):\n 1. k \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "."], ["proof (state)\nthis:\n  k \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "from k_card cp_M finM"], ["proof (chain)\npicking this:\n  k \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M\n  finite M", "have M_id: \"M = {x. poly ?cp x = 0}\""], ["proof (prove)\nusing this:\n  k \\<le> card {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M\n  finite M\n\ngoal (1 subgoal):\n 1. M = {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}", "unfolding kM"], ["proof (prove)\nusing this:\n  card M\n  \\<le> card\n         {x. poly (monom 1 (card M) - [:complex_of_real sr ^ card M:]) x =\n             0}\n  {x. poly (monom 1 (card M) - [:complex_of_real sr ^ card M:]) x = 0}\n  \\<subseteq> M\n  finite M\n\ngoal (1 subgoal):\n 1. M = {x. poly (monom 1 (card M) - [:complex_of_real sr ^ card M:]) x = 0}", "by (metis card_seteq)"], ["proof (state)\nthis:\n  M = {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have dvdc: \"?cp dvd charpoly cA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 k - [:complex_of_real sr ^ k:] dvd charpoly cA", "proof (rule poly_roots_dvd[OF cp0 deg k_card])"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n    \\<subseteq> {x. poly (charpoly cA) x = 0}", "from cp_M"], ["proof (chain)\npicking this:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M", "show \"{x. poly ?cp x = 0} \\<subseteq> {x. poly (charpoly cA) x = 0}\""], ["proof (prove)\nusing this:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0} \\<subseteq> M\n\ngoal (1 subgoal):\n 1. {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n    \\<subseteq> {x. poly (charpoly cA) x = 0}", "unfolding M eigen_value_root_charpoly"], ["proof (prove)\nusing this:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n  \\<subseteq> {ev. poly (charpoly cA) ev = 0 \\<and> cmod ev = sr}\n\ngoal (1 subgoal):\n 1. {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n    \\<subseteq> {x. poly (charpoly cA) x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n  \\<subseteq> {x. poly (charpoly cA) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom 1 k - [:complex_of_real sr ^ k:] dvd charpoly cA\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "from this[unfolded charpoly_of_real cp p.hom_dvd_iff]"], ["proof (chain)\npicking this:\n  monom 1 k - [:sr ^ k:] dvd charpoly A", "have dvd: \"?p dvd charpoly A\""], ["proof (prove)\nusing this:\n  monom 1 k - [:sr ^ k:] dvd charpoly A\n\ngoal (1 subgoal):\n 1. monom 1 k - [:sr ^ k:] dvd charpoly A", "."], ["proof (state)\nthis:\n  monom 1 k - [:sr ^ k:] dvd charpoly A\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "from this[unfolded dvd_def]"], ["proof (chain)\npicking this:\n  \\<exists>ka. charpoly A = (monom 1 k - [:sr ^ k:]) * ka", "obtain f where \n    decomp: \"charpoly A = ?p * f\""], ["proof (prove)\nusing this:\n  \\<exists>ka. charpoly A = (monom 1 k - [:sr ^ k:]) * ka\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        charpoly A = (monom 1 k - [:sr ^ k:]) * f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  charpoly A = (monom 1 k - [:sr ^ k:]) * f\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "let ?f = \"map_poly c f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "have decompc: \"charpoly cA = ?cp * ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. charpoly cA =\n    (monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f", "unfolding charpoly_of_real decomp p.hom_mult cp"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (monom 1 k - [:sr ^ k:]) *\n    map_poly complex_of_real f =\n    map_poly complex_of_real (monom 1 k - [:sr ^ k:]) *\n    map_poly complex_of_real f", ".."], ["proof (state)\nthis:\n  charpoly cA =\n  (monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "show \"\\<exists> f. charpoly A = (monom 1 ?M - [:sr^?M:]) * f \\<and> (\\<forall> x. poly (map_poly c f) x = 0 \\<longrightarrow> cmod x < sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "unfolding kM[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       charpoly A = (monom 1 k - [:sr ^ k:]) * f \\<and>\n       (\\<forall>x.\n           poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n           cmod x < sr)", "proof (intro exI conjI allI impI, rule decomp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "assume f: \"poly ?f x = 0\""], ["proof (state)\nthis:\n  poly (map_poly complex_of_real f) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "hence ev: \"eigen_value cA x\""], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real f) x = 0\n\ngoal (1 subgoal):\n 1. eigen_value cA x", "unfolding decompc p.hom_mult eigen_value_root_charpoly"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real f) x = 0\n\ngoal (1 subgoal):\n 1. poly\n     ((monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f)\n     x =\n    0", "by auto"], ["proof (state)\nthis:\n  eigen_value cA x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "hence le: \"cmod x \\<le> sr\""], ["proof (prove)\nusing this:\n  eigen_value cA x\n\ngoal (1 subgoal):\n 1. cmod x \\<le> sr", "using eigen_value_norm_sr"], ["proof (prove)\nusing this:\n  eigen_value cA x\n  eigen_value cA ?\\<alpha> \\<Longrightarrow> cmod ?\\<alpha> \\<le> sr\n\ngoal (1 subgoal):\n 1. cmod x \\<le> sr", "by auto"], ["proof (state)\nthis:\n  cmod x \\<le> sr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "{"], ["proof (state)\nthis:\n  cmod x \\<le> sr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "assume max: \"cmod x = sr\""], ["proof (state)\nthis:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "hence \"x \\<in> M\""], ["proof (prove)\nusing this:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. x \\<in> M", "unfolding M"], ["proof (prove)\nusing this:\n  cmod x = sr\n\ngoal (1 subgoal):\n 1. x \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "using ev"], ["proof (prove)\nusing this:\n  cmod x = sr\n  eigen_value cA x\n\ngoal (1 subgoal):\n 1. x \\<in> {ev. eigen_value cA ev \\<and> cmod ev = sr}", "by auto"], ["proof (state)\nthis:\n  x \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "hence \"poly ?cp x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> M\n\ngoal (1 subgoal):\n 1. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0", "unfolding M_id"], ["proof (prove)\nusing this:\n  x \\<in> {x. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0}\n\ngoal (1 subgoal):\n 1. poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "hence dvd1: \"[: -x, 1 :] dvd ?cp\""], ["proof (prove)\nusing this:\n  poly (monom 1 k - [:complex_of_real sr ^ k:]) x = 0\n\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd monom 1 k - [:complex_of_real sr ^ k:]", "unfolding poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  [:- x, 1:] dvd monom 1 k - [:complex_of_real sr ^ k:]\n\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd monom 1 k - [:complex_of_real sr ^ k:]", "by auto"], ["proof (state)\nthis:\n  [:- x, 1:] dvd monom 1 k - [:complex_of_real sr ^ k:]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "from f[unfolded poly_eq_0_iff_dvd]"], ["proof (chain)\npicking this:\n  [:- x, 1:] dvd map_poly complex_of_real f", "have dvd2: \"[: -x, 1 :] dvd ?f\""], ["proof (prove)\nusing this:\n  [:- x, 1:] dvd map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd map_poly complex_of_real f", "by auto"], ["proof (state)\nthis:\n  [:- x, 1:] dvd map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "from char"], ["proof (chain)\npicking this:\n  degree (charpoly cA) = CARD('n) \\<and> monic (charpoly cA)", "have 0: \"charpoly cA \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (charpoly cA) = CARD('n) \\<and> monic (charpoly cA)\n\ngoal (1 subgoal):\n 1. charpoly cA \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  charpoly cA \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "from mult_dvd_mono[OF dvd1 dvd2]"], ["proof (chain)\npicking this:\n  [:- x, 1:] * [:- x, 1:] dvd\n  (monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f", "have \"[: -x, 1 :]^2 dvd (charpoly cA)\""], ["proof (prove)\nusing this:\n  [:- x, 1:] * [:- x, 1:] dvd\n  (monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. [:- x, 1:]\\<^sup>2 dvd charpoly cA", "unfolding decompc power2_eq_square"], ["proof (prove)\nusing this:\n  [:- x, 1:] * [:- x, 1:] dvd\n  (monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f\n\ngoal (1 subgoal):\n 1. [:- x, 1:] * [:- x, 1:] dvd\n    (monom 1 k - [:complex_of_real sr ^ k:]) * map_poly complex_of_real f", "."], ["proof (state)\nthis:\n  [:- x, 1:]\\<^sup>2 dvd charpoly cA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "from order_max[OF this 0] maximal_eigen_value_order_1[OF ev max]"], ["proof (chain)\npicking this:\n  2 \\<le> order x (charpoly cA)\n  order x (charpoly cA) = 1", "have False"], ["proof (prove)\nusing this:\n  2 \\<le> order x (charpoly cA)\n  order x (charpoly cA) = 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "}"], ["proof (state)\nthis:\n  cmod x = sr \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly (map_poly complex_of_real f) x = 0 \\<Longrightarrow> cmod x < sr", "with le"], ["proof (chain)\npicking this:\n  cmod x \\<le> sr\n  cmod x = sr \\<Longrightarrow> False", "show \"cmod x < sr\""], ["proof (prove)\nusing this:\n  cmod x \\<le> sr\n  cmod x = sr \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cmod x < sr", "by argo"], ["proof (state)\nthis:\n  cmod x < sr\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     charpoly A = (monom 1 (card M) - [:sr ^ card M:]) * f \\<and>\n     (\\<forall>x.\n         poly (map_poly complex_of_real f) x = 0 \\<longrightarrow>\n         cmod x < sr)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas pf_main =\n  eigen_value_sr eigen_vector_z_sr (* sr is eigenvalue *)\n  eigen_value_norm_sr  (* it is maximal among all complex eigenvalues *)\n  z_pos    (* it's eigenvector is positive *)\n  multiplicity_sr_1 (* the algebr. multiplicity is 1 *)\n  nonnegative_eigenvector_has_ev_sr (* every non-negative real eigenvector has sr as eigenvalue *)\n  maximal_eigen_value_order_1 (* all maximal eigenvalues have order 1 *)\n  maximal_eigen_value_roots_of_unity_rotation"], ["", "(* the maximal eigenvalues are precisely the k-th roots of unity for some k \\<le> dim A *)"], ["", "lemmas pf_main_connect = pf_main(1,3,5,7,8-10)[unfolded sr_spectral_radius] \n  sr_pos[unfolded sr_spectral_radius]"], ["", "end"], ["", "end"]]}