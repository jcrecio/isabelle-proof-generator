{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Cancel_Card_Constraint.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma n_zero_nonempty: \"n \\<noteq> 0 \\<Longrightarrow> {0 ..< n :: nat} \\<noteq> {}\"", "lemma type_impl_card_n: assumes \"\\<exists>(Rep :: 'a \\<Rightarrow> nat) Abs. type_definition Rep Abs {0 ..< n :: nat}\"\n  shows \"class.finite (TYPE('a)) \\<and> CARD('a) = n\""], "translations": [["", "lemma n_zero_nonempty: \"n \\<noteq> 0 \\<Longrightarrow> {0 ..< n :: nat} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> {0..<n} \\<noteq> {}", "by auto"], ["", "lemma type_impl_card_n: assumes \"\\<exists>(Rep :: 'a \\<Rightarrow> nat) Abs. type_definition Rep Abs {0 ..< n :: nat}\"\n  shows \"class.finite (TYPE('a)) \\<and> CARD('a) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<n}", "obtain rep :: \"'a \\<Rightarrow> nat\" and abs :: \"nat \\<Rightarrow> 'a\" where t: \"type_definition rep abs {0 ..< n}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>rep abs.\n        type_definition rep abs {0..<n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition rep abs {0..<n}\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "have \"card (UNIV :: 'a set) = card {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = card {0..<n}", "using t"], ["proof (prove)\nusing this:\n  type_definition rep abs {0..<n}\n\ngoal (1 subgoal):\n 1. CARD('a) = card {0..<n}", "by (rule type_definition.card)"], ["proof (state)\nthis:\n  CARD('a) = card {0..<n}\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "also"], ["proof (state)\nthis:\n  CARD('a) = card {0..<n}\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n} = n", "by auto"], ["proof (state)\nthis:\n  card {0..<n} = n\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "finally"], ["proof (chain)\npicking this:\n  CARD('a) = n", "have bn: \"CARD ('a) = n\""], ["proof (prove)\nusing this:\n  CARD('a) = n\n\ngoal (1 subgoal):\n 1. CARD('a) = n", "."], ["proof (state)\nthis:\n  CARD('a) = n\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "have \"finite (abs ` {0 ..< n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (abs ` {0..<n})", "by auto"], ["proof (state)\nthis:\n  finite (abs ` {0..<n})\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "also"], ["proof (state)\nthis:\n  finite (abs ` {0..<n})\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "have \"abs ` {0 ..< n} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs ` {0..<n} = UNIV", "using t"], ["proof (prove)\nusing this:\n  type_definition rep abs {0..<n}\n\ngoal (1 subgoal):\n 1. abs ` {0..<n} = UNIV", "by (rule type_definition.Abs_image)"], ["proof (state)\nthis:\n  abs ` {0..<n} = UNIV\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "finally"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"class.finite (TYPE('a))\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a)", "unfolding class.finite_def"], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV", "."], ["proof (state)\nthis:\n  class.finite TYPE('a)\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "with bn"], ["proof (chain)\npicking this:\n  CARD('a) = n\n  class.finite TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  CARD('a) = n\n  class.finite TYPE('a)\n\ngoal (1 subgoal):\n 1. class.finite TYPE('a) \\<and> CARD('a) = n", "by blast"], ["proof (state)\nthis:\n  class.finite TYPE('a) \\<and> CARD('a) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "ML_file \\<open>cancel_card_constraint.ML\\<close>"], ["", "(* below you find an example what the attribute cancel_card_constraint can do and how\n   it works internally *)\n\n(*\n(* input: some type based lemma with CARD inside, like t0 *)\nconsts P :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" \naxiomatization where t0: \"P (CARD ('a :: finite)) (CARD('a) * m)\"\n\n(* t0 is converted into a property without the cardinality constraint via the new attribute *)\nlemma t_1_to_6: \"n \\<noteq> 0 \\<Longrightarrow> P n (n * m)\"\n  by (rule t0[cancel_card_constraint])\n\n(* The internal steps are as follows. *)\n\n(* 1st step: pull out CARD and introduce new variable n *)\nlemma t1: \"CARD('a :: finite) = n \\<Longrightarrow> P n (n * m)\" \n  using t0[where 'a = 'a] by blast\n\n(* 2nd step: get rid of sorts *)\nlemma t2: \"class.finite TYPE('a) \\<Longrightarrow> CARD('a) = n \\<Longrightarrow> P n (n * m)\"\n  by (rule t1[internalize_sort \"?'a::finite\"])\n\n(* 3rd step: restructure thm so that first two assumptions are merged into one *)\nlemma t3: \"class.finite TYPE('a) \\<and> CARD('a) = n \\<Longrightarrow> P n (n * m)\" \n  using t2 by blast\n\n(* 4th step: choose an appropriate carrier set *)\nlemma t4: \"\\<exists>Rep Abs. type_definition Rep Abs {0..<n} \\<Longrightarrow> P n (n * m)\"\n  by (rule t3[OF type_impl_card_n])\n\n(* 5th step: cancel type definition *)\nlemma t5: \"{0..<n} \\<noteq> {} \\<Longrightarrow> P n (n * m)\"\n  by (rule t4[cancel_type_definition])\n\n(* 6th step: simplify non-empty assumption to obtain final theorem *)\nlemma t6: \"n \\<noteq> 0 \\<Longrightarrow> P n (n * m)\" \n  by (rule t5[OF n_zero_nonempty])\n*)"], ["", "end"]]}