{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Hom_Gauss_Jordan.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma (in comm_ring_hom) similar_mat_wit_hom: assumes\n  \"similar_mat_wit A B C D\"\nshows \"similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C) (mat\\<^sub>h D)\"", "lemma (in comm_ring_hom) similar_mat_hom:\n  \"similar_mat A B \\<Longrightarrow> similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)\"", "lemma hom_swaprows: \"i < dim_row A \\<Longrightarrow> j < dim_row A \\<Longrightarrow>\n  swaprows i j (mat\\<^sub>h A) = mat\\<^sub>h (swaprows i j A)\"", "lemma hom_gauss_jordan_main: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc2 \\<Longrightarrow>\n  gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i j =\n  map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan_main A B i j)\"", "lemma hom_gauss_jordan: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc2 \\<Longrightarrow>\n  gauss_jordan (mat\\<^sub>h A) (mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan A B)\"", "lemma hom_gauss_jordan_single[simp]: \"gauss_jordan_single (mat\\<^sub>h A) = mat\\<^sub>h (gauss_jordan_single A)\"", "lemma hom_pivot_positions_main_gen: assumes A: \"A \\<in> carrier_mat nr nc\"\n  shows \"pivot_positions_main_gen 0 (mat\\<^sub>h A) nr nc i j = pivot_positions_main_gen 0 A nr nc i j\"", "lemma hom_pivot_positions[simp]: \"pivot_positions (mat\\<^sub>h A) = pivot_positions A\"", "lemma hom_kernel_dim[simp]: \"kernel_dim (mat\\<^sub>h A) = kernel_dim A\"", "lemma hom_char_matrix: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_matrix (mat\\<^sub>h A) (hom x) = mat\\<^sub>h (char_matrix A x)\"", "lemma hom_dim_gen_eigenspace: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"dim_gen_eigenspace (mat\\<^sub>h A) (hom x) = dim_gen_eigenspace A x\""], "translations": [["", "lemma (in comm_ring_hom) similar_mat_wit_hom: assumes\n  \"similar_mat_wit A B C D\"\nshows \"similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C) (mat\\<^sub>h D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "obtain n where n: \"n = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = dim_row A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = dim_row A\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note * = similar_mat_witD[OF n assms]"], ["proof (state)\nthis:\n  C * D = 1\\<^sub>m n\n  D * C = 1\\<^sub>m n\n  A = C * B * D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "from *"], ["proof (chain)\npicking this:\n  C * D = 1\\<^sub>m n\n  D * C = 1\\<^sub>m n\n  A = C * B * D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n", "have [simp]: \"dim_row C = n\""], ["proof (prove)\nusing this:\n  C * D = 1\\<^sub>m n\n  D * C = 1\\<^sub>m n\n  A = C * B * D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row C = n", "by auto"], ["proof (state)\nthis:\n  dim_row C = n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note C = *(6)"], ["proof (state)\nthis:\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note D = *(7)"], ["proof (state)\nthis:\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note id = mat_hom_mult[OF C D] mat_hom_mult[OF D C]"], ["proof (state)\nthis:\n  mat\\<^sub>h (C * D) = mat\\<^sub>h C * mat\\<^sub>h D\n  mat\\<^sub>h (D * C) = mat\\<^sub>h D * mat\\<^sub>h C\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note ** = *(1-3)[THEN arg_cong[of _ _ \"mat\\<^sub>h\"], unfolded id]"], ["proof (state)\nthis:\n  mat\\<^sub>h C * mat\\<^sub>h D = mat\\<^sub>h (1\\<^sub>m n)\n  mat\\<^sub>h D * mat\\<^sub>h C = mat\\<^sub>h (1\\<^sub>m n)\n  mat\\<^sub>h A = mat\\<^sub>h (C * B * D)\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note mult = mult_carrier_mat[of _ n n]"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n n; ?B \\<in> carrier_mat n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> carrier_mat n ?nc\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "note hom_mult = mat_hom_mult[of _ n n _ n]"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n n; ?B \\<in> carrier_mat n n\\<rbrakk>\n  \\<Longrightarrow> mat\\<^sub>h (?A * ?B) = mat\\<^sub>h ?A * mat\\<^sub>h ?B\n\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n     (mat\\<^sub>h D)", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {mat\\<^sub>h A, mat\\<^sub>h B, mat\\<^sub>h C, mat\\<^sub>h D}\n    \\<subseteq> carrier_mat (dim_row (mat\\<^sub>h A))\n                 (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h C * mat\\<^sub>h D =\n    1\\<^sub>m (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h D * mat\\<^sub>h C =\n    1\\<^sub>m (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h A = mat\\<^sub>h C * mat\\<^sub>h B * mat\\<^sub>h D", "unfolding **(3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {mat\\<^sub>h (C * B * D), mat\\<^sub>h B, mat\\<^sub>h C, mat\\<^sub>h D}\n    \\<subseteq> carrier_mat (dim_row (mat\\<^sub>h (C * B * D)))\n                 (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h C * mat\\<^sub>h D =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h D * mat\\<^sub>h C =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h (C * B * D) = mat\\<^sub>h C * mat\\<^sub>h B * mat\\<^sub>h D", "using **(1,2)"], ["proof (prove)\nusing this:\n  mat\\<^sub>h C * mat\\<^sub>h D = mat\\<^sub>h (1\\<^sub>m n)\n  mat\\<^sub>h D * mat\\<^sub>h C = mat\\<^sub>h (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. {mat\\<^sub>h (C * B * D), mat\\<^sub>h B, mat\\<^sub>h C, mat\\<^sub>h D}\n    \\<subseteq> carrier_mat (dim_row (mat\\<^sub>h (C * B * D)))\n                 (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h C * mat\\<^sub>h D =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h D * mat\\<^sub>h C =\n    1\\<^sub>m (dim_row (mat\\<^sub>h (C * B * D))) \\<and>\n    mat\\<^sub>h (C * B * D) = mat\\<^sub>h C * mat\\<^sub>h B * mat\\<^sub>h D", "by (auto simp: n[symmetric] hom_mult simp: *(4-) mult)"], ["proof (state)\nthis:\n  similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h C)\n   (mat\\<^sub>h D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_ring_hom) similar_mat_hom:\n  \"similar_mat A B \\<Longrightarrow> similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat A B \\<Longrightarrow>\n    similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)", "using similar_mat_wit_hom[of A B C D for C D]"], ["proof (prove)\nusing this:\n  similar_mat_wit A B ?C2 ?D2 \\<Longrightarrow>\n  similar_mat_wit (mat\\<^sub>h A) (mat\\<^sub>h B) (mat\\<^sub>h ?C2)\n   (mat\\<^sub>h ?D2)\n\ngoal (1 subgoal):\n 1. similar_mat A B \\<Longrightarrow>\n    similar_mat (mat\\<^sub>h A) (mat\\<^sub>h B)", "by (smt similar_mat_def)"], ["", "context field_hom\nbegin"], ["", "lemma hom_swaprows: \"i < dim_row A \\<Longrightarrow> j < dim_row A \\<Longrightarrow>\n  swaprows i j (mat\\<^sub>h A) = mat\\<^sub>h (swaprows i j A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; j < dim_row A\\<rbrakk>\n    \\<Longrightarrow> swaprows i j (mat\\<^sub>h A) =\n                      mat\\<^sub>h (swaprows i j A)", "unfolding mat_swaprows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; j < dim_row A\\<rbrakk>\n    \\<Longrightarrow> mat (dim_row (mat\\<^sub>h A))\n                       (dim_col (mat\\<^sub>h A))\n                       (\\<lambda>(ia, ja).\n                           if i = ia then mat\\<^sub>h A $$ (j, ja)\n                           else if j = ia then mat\\<^sub>h A $$ (i, ja)\n                                else mat\\<^sub>h A $$ (ia, ja)) =\n                      mat\\<^sub>h\n                       (mat (dim_row A) (dim_col A)\n                         (\\<lambda>(ia, ja).\n                             if i = ia then A $$ (j, ja)\n                             else if j = ia then A $$ (i, ja)\n                                  else A $$ (ia, ja)))", "by (rule eq_matI, auto)"], ["", "lemma hom_gauss_jordan_main: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc2 \\<Longrightarrow>\n  gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i j =\n  map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan_main A B i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                       j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main A B i j)", "proof (induct A B i j rule: gauss_jordan_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "case (1 A B i j)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main A B i (Suc j))\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (swaprows i ?x21.0 A))\n                     (mat\\<^sub>h (swaprows i ?x21.0 B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (swaprows i ?x21.0 A)\n                       (swaprows i ?x21.0 B) i j)\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main\n                     (mat\\<^sub>h (eliminate_entries ?xb A i j))\n                     (mat\\<^sub>h (eliminate_entries ?xb B i j)) (Suc i)\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (eliminate_entries ?xb A i j)\n                       (eliminate_entries ?xb B i j) (Suc i) (Suc j))\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa \\<noteq> (1::'a);\n   ?xb = inverse ?xaa; multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (multrow i ?xb A))\n                     (mat\\<^sub>h (multrow i ?xb B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B)\n                       i j)\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "note IH = 1(1-4)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main A B i (Suc j))\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (swaprows i ?x21.0 A))\n                     (mat\\<^sub>h (swaprows i ?x21.0 B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (swaprows i ?x21.0 A)\n                       (swaprows i ?x21.0 B) i j)\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main\n                     (mat\\<^sub>h (eliminate_entries ?xb A i j))\n                     (mat\\<^sub>h (eliminate_entries ?xb B i j)) (Suc i)\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (eliminate_entries ?xb A i j)\n                       (eliminate_entries ?xb B i j) (Suc i) (Suc j))\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa \\<noteq> (1::'a);\n   ?xb = inverse ?xaa; multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (multrow i ?xb A))\n                     (mat\\<^sub>h (multrow i ?xb B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B)\n                       i j)\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "note AB = 1(5-6)"], ["proof (state)\nthis:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "from AB"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2", "have dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "let ?h = \"mat\\<^sub>h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "let ?hp = \"map_prod mat\\<^sub>h mat\\<^sub>h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    B \\<in> carrier_mat nr nc2\\<rbrakk>\n                   \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A)\n(mat\\<^sub>h B) i (Suc j) =\n                                     map_prod mat\\<^sub>h mat\\<^sub>h\n(gauss_jordan_main A B i (Suc j));\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (swaprows i x21 A))\n                              (mat\\<^sub>h (swaprows i x21 B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (swaprows i x21 A)\n                                (swaprows i x21 B) i j);\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (eliminate_entries xb A i j))\n                              (mat\\<^sub>h (eliminate_entries xb B i j))\n                              (Suc i) (Suc j) =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main\n                                (eliminate_entries xb A i j)\n                                (eliminate_entries xb B i j) (Suc i)\n                                (Suc j));\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n           \\<Longrightarrow> gauss_jordan_main\n                              (mat\\<^sub>h (multrow i xb A))\n                              (mat\\<^sub>h (multrow i xb B)) i j =\n                             map_prod mat\\<^sub>h mat\\<^sub>h\n                              (gauss_jordan_main (multrow i xb A)\n                                (multrow i xb B) i j);\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n       \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                          j =\n                         map_prod mat\\<^sub>h mat\\<^sub>h\n                          (gauss_jordan_main A B i j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i j =\n    map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan_main A B i j)", "unfolding gauss_jordan_main.simps[of A B i j] gauss_jordan_main.simps[of \"?h A\" _ i j]\n    index_map_mat Let_def if_distrib[of ?hp] dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < nr \\<and> j < nc\n     then if mat\\<^sub>h A $$ (i, j) = (0::'b)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                              then [i'] else [])\n                       [Suc i..<nr]) of\n               [] \\<Rightarrow>\n                 gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n                    (swaprows i i' (mat\\<^sub>h B)) i j\n          else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n               then gauss_jordan_main\n                     (eliminate_entries\n                       (\\<lambda>i. mat\\<^sub>h A $$ (i, j)) (mat\\<^sub>h A)\n                       i j)\n                     (eliminate_entries\n                       (\\<lambda>i. mat\\<^sub>h A $$ (i, j)) (mat\\<^sub>h B)\n                       i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main\n                     (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                       (mat\\<^sub>h A))\n                     (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                       (mat\\<^sub>h B))\n                     i j\n     else (mat\\<^sub>h A, mat\\<^sub>h B)) =\n    (if i < nr \\<and> j < nc\n     then if A $$ (i, j) = (0::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (case concat\n                       (map (\\<lambda>i'.\n                                if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                else [])\n                         [Suc i..<nr]) of\n                 [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                 | i' # x \\<Rightarrow>\n                     gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i\n                      j)\n          else if A $$ (i, j) = (1::'a)\n               then map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main\n                       (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                       (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                       (Suc i) (Suc j))\n               else map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main\n                       (multrow i (inverse (A $$ (i, j))) A)\n                       (multrow i (inverse (A $$ (i, j))) B) i j)\n     else map_prod mat\\<^sub>h mat\\<^sub>h (A, B))", "proof (rule if_cong[OF refl], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "case 1"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "note IH = IH[OF dim[symmetric] 1 refl]"], ["proof (state)\nthis:\n  \\<lbrakk>A $$ (i, j) = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main A B i (Suc j))\n  \\<lbrakk>A $$ (i, j) = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (swaprows i ?x21.0 A))\n                     (mat\\<^sub>h (swaprows i ?x21.0 B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (swaprows i ?x21.0 A)\n                       (swaprows i ?x21.0 B) i j)\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main\n                     (mat\\<^sub>h (eliminate_entries ?xb A i j))\n                     (mat\\<^sub>h (eliminate_entries ?xb B i j)) (Suc i)\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (eliminate_entries ?xb A i j)\n                       (eliminate_entries ?xb B i j) (Suc i) (Suc j))\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) \\<noteq> (1::'a);\n   ?xb = inverse (A $$ (i, j)); multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (multrow i ?xb A))\n                     (mat\\<^sub>h (multrow i ?xb B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B)\n                       i j)\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "from 1"], ["proof (chain)\npicking this:\n  i < nr \\<and> j < nc", "have ij: \"i < nr\" \"j < nc\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr &&& j < nc", "by auto"], ["proof (state)\nthis:\n  i < nr\n  j < nc\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "hence hij: \"(?h A) $$ (i,j) = hom (A $$ (i,j))\""], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. mat\\<^sub>h A $$ (i, j) = hom (A $$ (i, j))", "using AB"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. mat\\<^sub>h A $$ (i, j) = hom (A $$ (i, j))", "by auto"], ["proof (state)\nthis:\n  mat\\<^sub>h A $$ (i, j) = hom (A $$ (i, j))\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "define ixs where \"ixs = concat (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> 0 then [i'] else []) [Suc i..<nr])\""], ["proof (state)\nthis:\n  ixs =\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr])\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "have id: \"map (\\<lambda>i'. if mat\\<^sub>h A $$ (i', j) \\<noteq> 0 then [i'] else []) [Suc i..<nr] =\n       map (\\<lambda>i'. if A $$ (i', j) \\<noteq> 0 then [i'] else []) [Suc i..<nr]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i'.\n            if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b) then [i'] else [])\n     [Suc i..<nr] =\n    map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]", "by (rule map_cong[OF refl], insert ij AB, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i'.\n          if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b) then [i'] else [])\n   [Suc i..<nr] =\n  map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n   [Suc i..<nr]\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then case concat\n                (map (\\<lambda>i'.\n                         if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                         then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h A))\n                (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                  (mat\\<^sub>h B))\n                i j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case concat\n                  (map (\\<lambda>i'.\n                           if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                           else [])\n                    [Suc i..<nr]) of\n            [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))", "unfolding hij hom_0_iff hom_1_iff id ixs_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if A $$ (i, j) = (0::'a)\n     then case ixs of\n          [] \\<Rightarrow>\n            gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n               (swaprows i i' (mat\\<^sub>h B)) i j\n     else if A $$ (i, j) = (1::'a)\n          then gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h A) i j)\n                (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                  (mat\\<^sub>h B) i j)\n                (Suc i) (Suc j)\n          else gauss_jordan_main\n                (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h A))\n                (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h B)) i\n                j) =\n    (if A $$ (i, j) = (0::'a)\n     then map_prod mat\\<^sub>h mat\\<^sub>h\n           (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n            | i' # x \\<Rightarrow>\n                gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n     else if A $$ (i, j) = (1::'a)\n          then map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                  (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                  (Suc i) (Suc j))\n          else map_prod mat\\<^sub>h mat\\<^sub>h\n                (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i j))", "proof (rule if_cong[OF refl _ if_cong[OF refl]], goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 3. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "case 1"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (3 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 3. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "note IH = IH(1,2)[OF 1, folded ixs_def]"], ["proof (state)\nthis:\n  \\<lbrakk>ixs = []; A \\<in> carrier_mat nr nc;\n   B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i\n                     (Suc j) =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main A B i (Suc j))\n  \\<lbrakk>ixs = ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc2\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h (swaprows i ?x21.0 A))\n                     (mat\\<^sub>h (swaprows i ?x21.0 B)) i j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main (swaprows i ?x21.0 A)\n                       (swaprows i ?x21.0 B) i j)\n\ngoal (3 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 3. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "proof (cases ixs)"], ["proof (state)\ngoal (2 subgoals):\n 1. ixs = [] \\<Longrightarrow>\n    (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n 2. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "case Nil"], ["proof (state)\nthis:\n  ixs = []\n\ngoal (2 subgoals):\n 1. ixs = [] \\<Longrightarrow>\n    (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n 2. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "unfolding Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case [] of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case [] of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "using IH(1)[OF Nil AB]"], ["proof (prove)\nusing this:\n  gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j) =\n  map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan_main A B i (Suc j))\n\ngoal (1 subgoal):\n 1. (case [] of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case [] of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "by auto"], ["proof (state)\nthis:\n  (case ixs of\n   [] \\<Rightarrow>\n     gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n   | i' # x \\<Rightarrow>\n       gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n        (swaprows i i' (mat\\<^sub>h B)) i j) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n    | i' # x \\<Rightarrow>\n        gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "case (Cons I ix)"], ["proof (state)\nthis:\n  ixs = I # ix\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "hence \"I \\<in> set ixs\""], ["proof (prove)\nusing this:\n  ixs = I # ix\n\ngoal (1 subgoal):\n 1. I \\<in> set ixs", "by auto"], ["proof (state)\nthis:\n  I \\<in> set ixs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "hence I: \"I < nr\""], ["proof (prove)\nusing this:\n  I \\<in> set ixs\n\ngoal (1 subgoal):\n 1. I < nr", "unfolding ixs_def"], ["proof (prove)\nusing this:\n  I \\<in> set (concat\n                (map (\\<lambda>i'.\n                         if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n                  [Suc i..<nr]))\n\ngoal (1 subgoal):\n 1. I < nr", "by auto"], ["proof (state)\nthis:\n  I < nr\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "from AB"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2", "have swap: \"swaprows i I A \\<in> carrier_mat nr nc\" \"swaprows i I B \\<in> carrier_mat nr nc2\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. swaprows i I A \\<in> carrier_mat nr nc &&&\n    swaprows i I B \\<in> carrier_mat nr nc2", "by auto"], ["proof (state)\nthis:\n  swaprows i I A \\<in> carrier_mat nr nc\n  swaprows i I B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ixs = a # list \\<Longrightarrow>\n       (case ixs of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j) =\n       map_prod mat\\<^sub>h mat\\<^sub>h\n        (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | i' # x \\<Rightarrow>\n             gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ixs of\n     [] \\<Rightarrow>\n       gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n     | i' # x \\<Rightarrow>\n         gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n          (swaprows i i' (mat\\<^sub>h B)) i j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n      | i' # x \\<Rightarrow>\n          gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)", "unfolding Cons list.simps IH(2)[OF Cons swap,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main (swaprows i I (mat\\<^sub>h A))\n     (swaprows i I (mat\\<^sub>h B)) i j =\n    gauss_jordan_main (mat\\<^sub>h (swaprows i I A))\n     (mat\\<^sub>h (swaprows i I B)) i j", "using AB ij I"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n  i < nr\n  j < nc\n  I < nr\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (swaprows i I (mat\\<^sub>h A))\n     (swaprows i I (mat\\<^sub>h B)) i j =\n    gauss_jordan_main (mat\\<^sub>h (swaprows i I A))\n     (mat\\<^sub>h (swaprows i I B)) i j", "by (auto simp: hom_swaprows)"], ["proof (state)\nthis:\n  (case ixs of\n   [] \\<Rightarrow>\n     gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n   | i' # x \\<Rightarrow>\n       gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n        (swaprows i i' (mat\\<^sub>h B)) i j) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n    | i' # x \\<Rightarrow>\n        gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case ixs of\n   [] \\<Rightarrow>\n     gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n   | i' # x \\<Rightarrow>\n       gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n        (swaprows i i' (mat\\<^sub>h B)) i j) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (case ixs of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n    | i' # x \\<Rightarrow>\n        gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "case 2"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n  A $$ (i, j) = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "from AB"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2", "have elim: \"eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j \\<in> carrier_mat nr nc\"\n          \"eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j \\<in> carrier_mat nr nc2\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j\n    \\<in> carrier_mat nr nc &&&\n    eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j\n    \\<in> carrier_mat nr nc2", "unfolding eliminate_entries_gen_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if i \\<noteq> i then A $$ (i, j) - A $$ (i, j) * A $$ (i, j)\n         else A $$ (i, j))\n    \\<in> carrier_mat nr nc &&&\n    mat (dim_row B) (dim_col B)\n     (\\<lambda>(i, j).\n         if i \\<noteq> i then B $$ (i, j) - A $$ (i, j) * B $$ (i, j)\n         else B $$ (i, j))\n    \\<in> carrier_mat nr nc2", "by auto"], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j \\<in> carrier_mat nr nc\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j \\<in> carrier_mat nr nc2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h A) i j)\n                       (eliminate_entries\n                         (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                         (mat\\<^sub>h B) i j)\n                       (Suc i) (Suc j) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                         (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                         (Suc i) (Suc j))\n 2. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main\n     (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n       (mat\\<^sub>h A) i j)\n     (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n       (mat\\<^sub>h B) i j)\n     (Suc i) (Suc j) =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (gauss_jordan_main (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n       (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i) (Suc j))", "unfolding IH(3)[OF 2 refl elim, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main\n     (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n       (mat\\<^sub>h A) i j)\n     (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n       (mat\\<^sub>h B) i j)\n     (Suc i) (Suc j) =\n    gauss_jordan_main\n     (mat\\<^sub>h (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j))\n     (mat\\<^sub>h (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j))\n     (Suc i) (Suc j)", "by (rule arg_cong2[of _ _ _ _ \"\\<lambda> x y. gauss_jordan_main x y (Suc i) (Suc j)\"];\n        intro eq_matI, insert AB ij, auto simp: eliminate_entries_gen_def hom_minus hom_mult)"], ["proof (state)\nthis:\n  gauss_jordan_main\n   (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j)) (mat\\<^sub>h A)\n     i j)\n   (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j)) (mat\\<^sub>h B)\n     i j)\n   (Suc i) (Suc j) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (gauss_jordan_main (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i) (Suc j))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "case 3"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n  A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "from AB"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2", "have mult: \"multrow i (inverse (A $$ (i, j))) A \\<in> carrier_mat nr nc\"\n        \"multrow i (inverse (A $$ (i, j))) B \\<in> carrier_mat nr nc2\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. multrow i (inverse (A $$ (i, j))) A \\<in> carrier_mat nr nc &&&\n    multrow i (inverse (A $$ (i, j))) B \\<in> carrier_mat nr nc2", "by auto"], ["proof (state)\nthis:\n  multrow i (inverse (A $$ (i, j))) A \\<in> carrier_mat nr nc\n  multrow i (inverse (A $$ (i, j))) B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n     A $$ (i, j) \\<noteq> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h A))\n                       (multrow i (inverse (hom (A $$ (i, j))))\n                         (mat\\<^sub>h B))\n                       i j =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main\n                         (multrow i (inverse (A $$ (i, j))) A)\n                         (multrow i (inverse (A $$ (i, j))) B) i j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main\n     (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h A))\n     (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h B)) i j =\n    map_prod mat\\<^sub>h mat\\<^sub>h\n     (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n       (multrow i (inverse (A $$ (i, j))) B) i j)", "unfolding IH(4)[OF 3 refl mult, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main\n     (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h A))\n     (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h B)) i j =\n    gauss_jordan_main (mat\\<^sub>h (multrow i (inverse (A $$ (i, j))) A))\n     (mat\\<^sub>h (multrow i (inverse (A $$ (i, j))) B)) i j", "by (rule arg_cong2[of _ _ _ _ \"\\<lambda> x y. gauss_jordan_main x y i j\"];\n        intro eq_matI, insert AB ij, auto simp: hom_inverse hom_mult)"], ["proof (state)\nthis:\n  gauss_jordan_main\n   (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h A))\n   (multrow i (inverse (hom (A $$ (i, j)))) (mat\\<^sub>h B)) i j =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n   then case concat\n              (map (\\<lambda>i'.\n                       if mat\\<^sub>h A $$ (i', j) \\<noteq> (0::'b)\n                       then [i'] else [])\n                [Suc i..<nr]) of\n        [] \\<Rightarrow>\n          gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i (Suc j)\n        | i' # x \\<Rightarrow>\n            gauss_jordan_main (swaprows i i' (mat\\<^sub>h A))\n             (swaprows i i' (mat\\<^sub>h B)) i j\n   else if mat\\<^sub>h A $$ (i, j) = (1::'b)\n        then gauss_jordan_main\n              (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                (mat\\<^sub>h A) i j)\n              (eliminate_entries (\\<lambda>i. mat\\<^sub>h A $$ (i, j))\n                (mat\\<^sub>h B) i j)\n              (Suc i) (Suc j)\n        else gauss_jordan_main\n              (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                (mat\\<^sub>h A))\n              (multrow i (inverse (mat\\<^sub>h A $$ (i, j)))\n                (mat\\<^sub>h B))\n              i j) =\n  (if A $$ (i, j) = (0::'a)\n   then map_prod mat\\<^sub>h mat\\<^sub>h\n         (case concat\n                (map (\\<lambda>i'.\n                         if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n                  [Suc i..<nr]) of\n          [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n          | i' # x \\<Rightarrow>\n              gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n   else if A $$ (i, j) = (1::'a)\n        then map_prod mat\\<^sub>h mat\\<^sub>h\n              (gauss_jordan_main\n                (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i)\n                (Suc j))\n        else map_prod mat\\<^sub>h mat\\<^sub>h\n              (gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                (multrow i (inverse (A $$ (i, j))) B) i j))\n\ngoal (1 subgoal):\n 1. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    (mat\\<^sub>h A, mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (A, B)", "qed auto"], ["proof (state)\nthis:\n  gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) i j =\n  map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan_main A B i j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_gauss_jordan: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc2 \\<Longrightarrow>\n  gauss_jordan (mat\\<^sub>h A) (mat\\<^sub>h B) = map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan (mat\\<^sub>h A) (mat\\<^sub>h B) =\n                      map_prod mat\\<^sub>h mat\\<^sub>h (gauss_jordan A B)", "unfolding gauss_jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) 0\n                       0 =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main A B 0 0)", "using hom_gauss_jordan_main"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   ?B \\<in> carrier_mat ?nr ?nc2.0\\<rbrakk>\n  \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h ?A) (mat\\<^sub>h ?B) ?i\n                     ?j =\n                    map_prod mat\\<^sub>h mat\\<^sub>h\n                     (gauss_jordan_main ?A ?B ?i ?j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc2\\<rbrakk>\n    \\<Longrightarrow> gauss_jordan_main (mat\\<^sub>h A) (mat\\<^sub>h B) 0\n                       0 =\n                      map_prod mat\\<^sub>h mat\\<^sub>h\n                       (gauss_jordan_main A B 0 0)", "by blast"], ["", "lemma hom_gauss_jordan_single[simp]: \"gauss_jordan_single (mat\\<^sub>h A) = mat\\<^sub>h (gauss_jordan_single A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "let ?nr = \"dim_row A\""], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "let ?nc = \"dim_col A\""], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "have 0: \"0\\<^sub>m ?nr 0 \\<in> carrier_mat ?nr 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m (dim_row A) 0 \\<in> carrier_mat (dim_row A) 0", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>m (dim_row A) 0 \\<in> carrier_mat (dim_row A) 0\n\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "have dim: \"dim_row (mat\\<^sub>h A) = ?nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat\\<^sub>h A) = dim_row A", "by auto"], ["proof (state)\nthis:\n  dim_row (mat\\<^sub>h A) = dim_row A\n\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "have hom0: \"mat\\<^sub>h (0\\<^sub>m ?nr 0) = 0\\<^sub>m ?nr 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat\\<^sub>h (0\\<^sub>m (dim_row A) 0) = 0\\<^sub>m (dim_row A) 0", "by auto"], ["proof (state)\nthis:\n  mat\\<^sub>h (0\\<^sub>m (dim_row A) 0) = 0\\<^sub>m (dim_row A) 0\n\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "have A: \"A \\<in> carrier_mat ?nr ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_row A) (dim_col A)", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "from hom_gauss_jordan[OF A 0] A"], ["proof (chain)\npicking this:\n  gauss_jordan (mat\\<^sub>h A) (mat\\<^sub>h (0\\<^sub>m (dim_row A) 0)) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (gauss_jordan A (0\\<^sub>m (dim_row A) 0))\n  A \\<in> carrier_mat (dim_row A) (dim_col A)", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_jordan (mat\\<^sub>h A) (mat\\<^sub>h (0\\<^sub>m (dim_row A) 0)) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (gauss_jordan A (0\\<^sub>m (dim_row A) 0))\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. gauss_jordan_single (mat\\<^sub>h A) =\n    mat\\<^sub>h (gauss_jordan_single A)", "unfolding gauss_jordan_single_def dim hom0"], ["proof (prove)\nusing this:\n  gauss_jordan (mat\\<^sub>h A) (0\\<^sub>m (dim_row A) 0) =\n  map_prod mat\\<^sub>h mat\\<^sub>h\n   (gauss_jordan A (0\\<^sub>m (dim_row A) 0))\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan (mat\\<^sub>h A) (0\\<^sub>m (dim_row A) 0)) =\n    mat\\<^sub>h (fst (gauss_jordan A (0\\<^sub>m (dim_row A) 0)))", "by (metis fst_map_prod)"], ["proof (state)\nthis:\n  gauss_jordan_single (mat\\<^sub>h A) = mat\\<^sub>h (gauss_jordan_single A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_pivot_positions_main_gen: assumes A: \"A \\<in> carrier_mat nr nc\"\n  shows \"pivot_positions_main_gen 0 (mat\\<^sub>h A) nr nc i j = pivot_positions_main_gen 0 A nr nc i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_main (mat\\<^sub>h A) nr nc i j =\n    pivot_positions_main A nr nc i j", "proof (induct rule: pivot_positions_main_gen.induct[of nr nc A 0])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc\n                                   i (Suc j) =\n                                  pivot_positions_main A nr nc i (Suc j);\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i)\n                           (Suc j) =\n                          pivot_positions_main A nr nc (Suc i)\n                           (Suc j)\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc i j =\n                         pivot_positions_main A nr nc i j", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j) =\n                    pivot_positions_main A nr nc i (Suc j)\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i)\n                     (Suc j) =\n                    pivot_positions_main A nr nc (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc\n                                   i (Suc j) =\n                                  pivot_positions_main A nr nc i (Suc j);\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i)\n                           (Suc j) =\n                          pivot_positions_main A nr nc (Suc i)\n                           (Suc j)\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc i j =\n                         pivot_positions_main A nr nc i j", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j) =\n                    pivot_positions_main A nr nc i (Suc j)\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i)\n                     (Suc j) =\n                    pivot_positions_main A nr nc (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc\n                                   i (Suc j) =\n                                  pivot_positions_main A nr nc i (Suc j);\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i)\n                           (Suc j) =\n                          pivot_positions_main A nr nc (Suc i)\n                           (Suc j)\\<rbrakk>\n       \\<Longrightarrow> pivot_positions_main (mat\\<^sub>h A) nr nc i j =\n                         pivot_positions_main A nr nc i j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_main (mat\\<^sub>h A) nr nc i j =\n    pivot_positions_main A nr nc i j", "unfolding pivot_positions_main_gen.simps[of _ _ nr nc i j]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < nr\n     then if j < nc\n          then if mat\\<^sub>h A $$ (i, j) = (0::'b)\n               then pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j)\n               else (i, j) #\n                    pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i)\n                     (Suc j)\n          else []\n     else []) =\n    (if i < nr\n     then if j < nc\n          then if A $$ (i, j) = (0::'a)\n               then pivot_positions_main A nr nc i (Suc j)\n               else (i, j) # pivot_positions_main A nr nc (Suc i) (Suc j)\n          else []\n     else [])", "proof (rule if_cong[OF refl if_cong[OF refl _ refl] refl], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n                       then pivot_positions_main (mat\\<^sub>h A) nr nc i\n                             (Suc j)\n                       else (i, j) #\n                            pivot_positions_main (mat\\<^sub>h A) nr nc\n                             (Suc i) (Suc j)) =\n                      (if A $$ (i, j) = (0::'a)\n                       then pivot_positions_main A nr nc i (Suc j)\n                       else (i, j) #\n                            pivot_positions_main A nr nc (Suc i) (Suc j))", "case 1"], ["proof (state)\nthis:\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n                       then pivot_positions_main (mat\\<^sub>h A) nr nc i\n                             (Suc j)\n                       else (i, j) #\n                            pivot_positions_main (mat\\<^sub>h A) nr nc\n                             (Suc i) (Suc j)) =\n                      (if A $$ (i, j) = (0::'a)\n                       then pivot_positions_main A nr nc i (Suc j)\n                       else (i, j) #\n                            pivot_positions_main A nr nc (Suc i) (Suc j))", "with A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  i < nr\n  j < nc", "have id: \"(mat\\<^sub>h A) $$ (i,j) = hom (A $$ (i,j))\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. mat\\<^sub>h A $$ (i, j) = hom (A $$ (i, j))", "by simp"], ["proof (state)\nthis:\n  mat\\<^sub>h A $$ (i, j) = hom (A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n                       then pivot_positions_main (mat\\<^sub>h A) nr nc i\n                             (Suc j)\n                       else (i, j) #\n                            pivot_positions_main (mat\\<^sub>h A) nr nc\n                             (Suc i) (Suc j)) =\n                      (if A $$ (i, j) = (0::'a)\n                       then pivot_positions_main A nr nc i (Suc j)\n                       else (i, j) #\n                            pivot_positions_main A nr nc (Suc i) (Suc j))", "note IH = IH[OF 1]"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a) \\<Longrightarrow>\n  pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j) =\n  pivot_positions_main A nr nc i (Suc j)\n  A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n  pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i) (Suc j) =\n  pivot_positions_main A nr nc (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n                       then pivot_positions_main (mat\\<^sub>h A) nr nc i\n                             (Suc j)\n                       else (i, j) #\n                            pivot_positions_main (mat\\<^sub>h A) nr nc\n                             (Suc i) (Suc j)) =\n                      (if A $$ (i, j) = (0::'a)\n                       then pivot_positions_main A nr nc i (Suc j)\n                       else (i, j) #\n                            pivot_positions_main A nr nc (Suc i) (Suc j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n     then pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j)\n     else (i, j) #\n          pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i) (Suc j)) =\n    (if A $$ (i, j) = (0::'a) then pivot_positions_main A nr nc i (Suc j)\n     else (i, j) # pivot_positions_main A nr nc (Suc i) (Suc j))", "unfolding id hom_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if A $$ (i, j) = (0::'a)\n     then pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j)\n     else (i, j) #\n          pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i) (Suc j)) =\n    (if A $$ (i, j) = (0::'a) then pivot_positions_main A nr nc i (Suc j)\n     else (i, j) # pivot_positions_main A nr nc (Suc i) (Suc j))", "by (rule if_cong[OF refl IH(1)], force, subst IH(2), auto)"], ["proof (state)\nthis:\n  (if mat\\<^sub>h A $$ (i, j) = (0::'b)\n   then pivot_positions_main (mat\\<^sub>h A) nr nc i (Suc j)\n   else (i, j) #\n        pivot_positions_main (mat\\<^sub>h A) nr nc (Suc i) (Suc j)) =\n  (if A $$ (i, j) = (0::'a) then pivot_positions_main A nr nc i (Suc j)\n   else (i, j) # pivot_positions_main A nr nc (Suc i) (Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_positions_main (mat\\<^sub>h A) nr nc i j =\n  pivot_positions_main A nr nc i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_pivot_positions[simp]: \"pivot_positions (mat\\<^sub>h A) = pivot_positions A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions (mat\\<^sub>h A) = pivot_positions A", "unfolding pivot_positions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions_main (mat\\<^sub>h A) (dim_row (mat\\<^sub>h A))\n     (dim_col (mat\\<^sub>h A)) 0 0 =\n    pivot_positions_main A (dim_row A) (dim_col A) 0 0", "by (subst hom_pivot_positions_main_gen, auto)"], ["", "lemma hom_kernel_dim[simp]: \"kernel_dim (mat\\<^sub>h A) = kernel_dim A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim (mat\\<^sub>h A) = kernel_dim A", "unfolding kernel_dim_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mat\\<^sub>h A) -\n    length (pivot_positions (gauss_jordan_single (mat\\<^sub>h A))) =\n    dim_col A - length (pivot_positions (gauss_jordan_single A))", "by simp"], ["", "lemma hom_char_matrix: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_matrix (mat\\<^sub>h A) (hom x) = mat\\<^sub>h (char_matrix A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix (mat\\<^sub>h A) (hom x) = mat\\<^sub>h (char_matrix A x)", "unfolding char_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat\\<^sub>h A +\n    - hom x \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row (mat\\<^sub>h A)) =\n    mat\\<^sub>h (A + - x \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A))", "by (rule eq_matI, insert A, auto simp: hom_minus)"], ["", "lemma hom_dim_gen_eigenspace: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"dim_gen_eigenspace (mat\\<^sub>h A) (hom x) = dim_gen_eigenspace A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_gen_eigenspace (mat\\<^sub>h A) (hom x) = dim_gen_eigenspace A x", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dim_gen_eigenspace (mat\\<^sub>h A) (hom x) xa =\n       dim_gen_eigenspace A x xa", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dim_gen_eigenspace (mat\\<^sub>h A) (hom x) xa =\n       dim_gen_eigenspace A x xa", "show \"dim_gen_eigenspace (mat\\<^sub>h A) (hom x) k = dim_gen_eigenspace A x k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_gen_eigenspace (mat\\<^sub>h A) (hom x) k = dim_gen_eigenspace A x k", "unfolding dim_gen_eigenspace_def hom_char_matrix[OF A]\n      mat_hom_pow[OF char_matrix_closed[OF A], symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim (mat\\<^sub>h (char_matrix A x ^\\<^sub>m k)) =\n    kernel_dim (char_matrix A x ^\\<^sub>m k)", "by simp"], ["proof (state)\nthis:\n  dim_gen_eigenspace (mat\\<^sub>h A) (hom x) k = dim_gen_eigenspace A x k\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}