{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/Roots_Unity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemma cis_mult_cmod_id: \"cis (arg x) * of_real (cmod x) = x\"", "lemma rcis_mult_cis[simp]: \"rcis n a * cis b = rcis n (a + b)\"", "lemma rcis_div_cis[simp]: \"rcis n a / cis b = rcis n (a - b)\"", "lemma cis_plus_2pi[simp]: \"cis (x + 2 * pi) = cis x\"", "lemma cis_plus_2pi_neq_1: assumes x: \"0 < x\" \"x < 2 * pi\"\n  shows \"cis x \\<noteq> 1\"", "lemma cis_times_2pi[simp]: \"cis (of_nat n * 2 * pi) = 1\"", "lemma cis_pi_2[simp]: \"cis (pi / 2) = \\<i>\"", "lemma cis_add_pi[simp]: \"cis (pi + x) = - cis x\"", "lemma cis_3_pi_2[simp]: \"cis (pi * 3 / 2) = - \\<i>\"", "lemma rcis_plus_2pi[simp]: \"rcis y (x + 2 * pi) = rcis y x\"", "lemma rcis_times_2pi[simp]: \"rcis r (of_nat n * 2 * pi) = of_real r\"", "lemma arg_rcis_cis: assumes n: \"n > 0\" shows \"arg (rcis n x) = arg (cis x)\"", "lemma arg_eqD: assumes \"arg (cis x) = arg (cis y)\" \"-pi < x\" \"x \\<le> pi\" \"-pi < y\" \"y \\<le> pi\"\n  shows \"x = y\"", "lemma rcis_inj_on: assumes r: \"r \\<noteq> 0\" shows \"inj_on (rcis r) {0 ..< 2 * pi}\"", "lemma cis_inj_on: \"inj_on cis {0 ..< 2 * pi}\"", "lemma poly_root_unity: \"poly (root_unity n) x = 0 \\<longleftrightarrow> x^n = 1\"", "lemma degree_root_unity[simp]: \"degree (root_unity n) = n\" (is \"degree ?p = _\")", "lemma zero_root_unit[simp]: \"root_unity n = 0 \\<longleftrightarrow> n = 0\" (is \"?p = 0 \\<longleftrightarrow> _\")", "lemma poly_prod_root_unity: \"poly (prod_root_unity ns) x = 0 \\<longleftrightarrow> (\\<exists>k\\<in>set ns. x ^ k = 1)\"", "lemma degree_prod_root_unity[simp]: \"0 \\<notin> set ns \\<Longrightarrow> degree (prod_root_unity ns) = sum_list ns\"", "lemma zero_prod_root_unit[simp]: \"prod_root_unity ns = 0 \\<longleftrightarrow> 0 \\<in> set ns\"", "lemma roots_of_unity: assumes n: \"n \\<noteq> 0\"\n  shows \"(\\<lambda> i. (cis (of_nat i * 2 * pi / n))) ` {0 ..< n} = { x :: complex. x ^ n = 1}\" (is \"?prod = ?Roots\")\n     \"{x. poly (root_unity n) x = 0} = { x :: complex. x ^ n = 1}\"\n     \"card { x :: complex. x ^ n = 1} = n\"", "lemma poly_roots_dvd: fixes p :: \"'a :: field poly\"\n  assumes \"p \\<noteq> 0\" and \"degree p = n\"\n  and \"card {x. poly p x = 0} \\<ge> n\" and \"{x. poly p x = 0} \\<subseteq> {x. poly q x = 0}\"\nshows \"p dvd q\"", "lemma root_unity_decomp: assumes n: \"n \\<noteq> 0\"\n  shows \"root_unity n =\n    prod_list (map (\\<lambda> i. [:-cis (of_nat i * 2 * pi / n), 1:]) [0 ..< n])\" (is \"?u = ?p\")", "lemma order_monic_linear: \"order x [:y,1:] = (if y + x = 0 then 1 else 0)\"", "lemma order_root_unity: fixes x :: complex assumes n: \"n \\<noteq> 0\"\n  shows \"order x (root_unity n) = (if x^n = 1 then 1 else 0)\"\n  (is \"order _ ?u = _\")", "lemma order_prod_root_unity: assumes 0: \"0 \\<notin> set ks\"\n  shows \"order (x :: complex) (prod_root_unity ks) = length (filter (\\<lambda> k. x^k = 1) ks)\"", "lemma root_unity_witness: fixes xs :: \"complex list\"\n  assumes \"prod_list (map (\\<lambda> x. [:-x,1:]) xs) = monom 1 n - 1\"\n  shows \"x^n = 1 \\<longleftrightarrow> x \\<in> set xs\"", "lemma root_unity_explicit: fixes x :: complex\n  shows\n    \"(x ^ 1 = 1) \\<longleftrightarrow> x = 1\"\n    \"(x ^ 2 = 1) \\<longleftrightarrow> (x \\<in> {1, -1})\"\n    \"(x ^ 3 = 1) \\<longleftrightarrow> (x \\<in> {1, Complex (-1/2) (sqrt 3 / 2), Complex (-1/2) (- sqrt 3 / 2)})\"\n    \"(x ^ 4 = 1) \\<longleftrightarrow> (x \\<in> {1, -1, \\<i>, - \\<i>})\"", "lemma primitive_root_unityD: assumes \"primitive_root_unity k x\"\n  shows \"k \\<noteq> 0\" \"x^k = 1\" \"k' \\<noteq> 0 \\<Longrightarrow> x^k' = 1 \\<Longrightarrow> k \\<le> k'\"", "lemma primitive_root_unity_exists: assumes \"k \\<noteq> 0\" \"x ^ k = 1\"\n  shows \"\\<exists> k'. k' \\<le> k \\<and> primitive_root_unity k' x\"", "lemma primitive_root_unity_dvd: fixes x :: \"complex\"\n  assumes k: \"primitive_root_unity k x\"\n  shows \"x ^ n = 1 \\<longleftrightarrow> k dvd n\"", "lemma primitive_root_unity_simple_computation:\n  \"primitive_root_unity k x  = (if k = 0 then False else\n     x ^ k = 1 \\<and> (\\<forall> i \\<in> {1 ..< k}. x ^ i \\<noteq> 1))\"", "lemma primitive_root_unity_explicit: fixes x :: complex\n  shows \"primitive_root_unity 1 x \\<longleftrightarrow> x = 1\"\n    \"primitive_root_unity 2 x \\<longleftrightarrow> x = -1\"\n    \"primitive_root_unity 3 x \\<longleftrightarrow> (x \\<in> {Complex (-1/2) (sqrt 3 / 2), Complex (-1/2) (- sqrt 3 / 2)})\"\n    \"primitive_root_unity 4 x \\<longleftrightarrow> (x \\<in> {\\<i>, - \\<i>})\"", "lemma decompose_prod_root_unity_main: fixes p :: \"complex poly\"\n  assumes p: \"p = prod_root_unity ks * f\"\n  and d: \"decompose_prod_root_unity_main p k = (ks',g)\"\n  and f: \"\\<And> x. cmod x = 1 \\<Longrightarrow> poly f x \\<noteq> 0\"\n  and k: \"\\<And> k'. k' > k \\<Longrightarrow> \\<not> root_unity k' dvd p\"\nshows \"p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\"", "lemma decompose_prod_root_unity: fixes p :: \"complex poly\"\n  assumes p: \"p = prod_root_unity ks * f\"\n  and d: \"decompose_prod_root_unity p = (ks',g)\"\n  and f: \"\\<And> x. cmod x = 1 \\<Longrightarrow> poly f x \\<noteq> 0\"\n  and p0: \"p \\<noteq> 0\"\nshows \"p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\"", "lemma (in comm_ring_hom) hom_root_unity: \"map_poly hom (root_unity n) = root_unity n\"", "lemma (in idom_hom) hom_prod_root_unity: \"map_poly hom (prod_root_unity n) = prod_root_unity n\"", "lemma (in field_hom) hom_decompose_prod_root_unity_main:\n  \"decompose_prod_root_unity_main (map_poly hom p) k = map_prod id (map_poly hom)\n    (decompose_prod_root_unity_main p k)\"", "lemma (in field_hom) hom_decompose_prod_root_unity:\n  \"decompose_prod_root_unity (map_poly hom p) = map_prod id (map_poly hom)\n    (decompose_prod_root_unity p)\""], "translations": [["", "lemma cis_mult_cmod_id: \"cis (arg x) * of_real (cmod x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg x) * complex_of_real (cmod x) = x", "using rcis_cmod_arg[unfolded rcis_def]"], ["proof (prove)\nusing this:\n  complex_of_real (cmod ?z) * cis (arg ?z) = ?z\n\ngoal (1 subgoal):\n 1. cis (arg x) * complex_of_real (cmod x) = x", "by (simp add: ac_simps)"], ["", "lemma rcis_mult_cis[simp]: \"rcis n a * cis b = rcis n (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis n a * cis b = rcis n (a + b)", "unfolding cis_rcis_eq rcis_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis (n * 1) (a + b) = rcis n (a + b)", "by simp"], ["", "lemma rcis_div_cis[simp]: \"rcis n a / cis b = rcis n (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis n a / cis b = rcis n (a - b)", "unfolding cis_rcis_eq rcis_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis (n / 1) (a - b) = rcis n (a - b)", "by simp"], ["", "lemma cis_plus_2pi[simp]: \"cis (x + 2 * pi) = cis x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (x + 2 * pi) = cis x", "by (auto simp: complex_eq_iff)"], ["", "lemma cis_plus_2pi_neq_1: assumes x: \"0 < x\" \"x < 2 * pi\"\n  shows \"cis x \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis x \\<noteq> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cis x \\<noteq> 1", "from x"], ["proof (chain)\npicking this:\n  0 < x\n  x < 2 * pi", "have \"cos x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  0 < x\n  x < 2 * pi\n\ngoal (1 subgoal):\n 1. cos x \\<noteq> 1", "by (smt cos_2pi_minus cos_monotone_0_pi cos_zero)"], ["proof (state)\nthis:\n  cos x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. cis x \\<noteq> 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  cos x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. cis x \\<noteq> 1", "by (auto simp: complex_eq_iff)"], ["proof (state)\nthis:\n  cis x \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cis_times_2pi[simp]: \"cis (of_nat n * 2 * pi) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (real n * 2 * pi) = 1", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. cis (real 0 * 2 * pi) = 1\n 2. \\<And>n.\n       cis (real n * 2 * pi) = 1 \\<Longrightarrow>\n       cis (real (Suc n) * 2 * pi) = 1", "case (Suc n)"], ["proof (state)\nthis:\n  cis (real n * 2 * pi) = 1\n\ngoal (2 subgoals):\n 1. cis (real 0 * 2 * pi) = 1\n 2. \\<And>n.\n       cis (real n * 2 * pi) = 1 \\<Longrightarrow>\n       cis (real (Suc n) * 2 * pi) = 1", "have \"of_nat (Suc n) * 2 * pi = of_nat n * 2 * pi + 2 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Suc n) * 2 * pi = real n * 2 * pi + 2 * pi", "by (simp add: distrib_right)"], ["proof (state)\nthis:\n  real (Suc n) * 2 * pi = real n * 2 * pi + 2 * pi\n\ngoal (2 subgoals):\n 1. cis (real 0 * 2 * pi) = 1\n 2. \\<And>n.\n       cis (real n * 2 * pi) = 1 \\<Longrightarrow>\n       cis (real (Suc n) * 2 * pi) = 1", "also"], ["proof (state)\nthis:\n  real (Suc n) * 2 * pi = real n * 2 * pi + 2 * pi\n\ngoal (2 subgoals):\n 1. cis (real 0 * 2 * pi) = 1\n 2. \\<And>n.\n       cis (real n * 2 * pi) = 1 \\<Longrightarrow>\n       cis (real (Suc n) * 2 * pi) = 1", "have \"cis \\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (real n * 2 * pi + 2 * pi) = 1", "unfolding cis_plus_2pi Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 1", ".."], ["proof (state)\nthis:\n  cis (real n * 2 * pi + 2 * pi) = 1\n\ngoal (2 subgoals):\n 1. cis (real 0 * 2 * pi) = 1\n 2. \\<And>n.\n       cis (real n * 2 * pi) = 1 \\<Longrightarrow>\n       cis (real (Suc n) * 2 * pi) = 1", "finally"], ["proof (chain)\npicking this:\n  cis (real (Suc n) * 2 * pi) = 1", "show ?case"], ["proof (prove)\nusing this:\n  cis (real (Suc n) * 2 * pi) = 1\n\ngoal (1 subgoal):\n 1. cis (real (Suc n) * 2 * pi) = 1", "."], ["proof (state)\nthis:\n  cis (real (Suc n) * 2 * pi) = 1\n\ngoal (1 subgoal):\n 1. cis (real 0 * 2 * pi) = 1", "qed simp"], ["", "declare cis_pi[simp]"], ["", "lemma cis_pi_2[simp]: \"cis (pi / 2) = \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi / 2) = \\<i>", "by (auto simp: complex_eq_iff)"], ["", "lemma cis_add_pi[simp]: \"cis (pi + x) = - cis x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi + x) = - cis x", "by (auto simp: complex_eq_iff)"], ["", "lemma cis_3_pi_2[simp]: \"cis (pi * 3 / 2) = - \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = - \\<i>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = - \\<i>", "have \"cis (pi * 3 / 2) = cis (pi + pi / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = cis (pi + pi / 2)", "by (rule arg_cong[of _ _ cis], simp)"], ["proof (state)\nthis:\n  cis (pi * 3 / 2) = cis (pi + pi / 2)\n\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = - \\<i>", "also"], ["proof (state)\nthis:\n  cis (pi * 3 / 2) = cis (pi + pi / 2)\n\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = - \\<i>", "have \"\\<dots> = - \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi + pi / 2) = - \\<i>", "unfolding cis_add_pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. - cis (pi / 2) = - \\<i>", "by simp"], ["proof (state)\nthis:\n  cis (pi + pi / 2) = - \\<i>\n\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = - \\<i>", "finally"], ["proof (chain)\npicking this:\n  cis (pi * 3 / 2) = - \\<i>", "show ?thesis"], ["proof (prove)\nusing this:\n  cis (pi * 3 / 2) = - \\<i>\n\ngoal (1 subgoal):\n 1. cis (pi * 3 / 2) = - \\<i>", "."], ["proof (state)\nthis:\n  cis (pi * 3 / 2) = - \\<i>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rcis_plus_2pi[simp]: \"rcis y (x + 2 * pi) = rcis y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis y (x + 2 * pi) = rcis y x", "unfolding rcis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real y * cis (x + 2 * pi) = complex_of_real y * cis x", "by simp"], ["", "lemma rcis_times_2pi[simp]: \"rcis r (of_nat n * 2 * pi) = of_real r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis r (real n * 2 * pi) = complex_of_real r", "unfolding rcis_def cis_times_2pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real r * 1 = complex_of_real r", "by simp"], ["", "lemma arg_rcis_cis: assumes n: \"n > 0\" shows \"arg (rcis n x) = arg (cis x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (rcis n x) = arg (cis x)", "using arg_bounded arg_unique cis_arg complex_mod_rcis n rcis_def sgn_eq"], ["proof (prove)\nusing this:\n  - pi < arg ?z \\<and> arg ?z \\<le> pi\n  \\<lbrakk>sgn ?z = cis ?x; - pi < ?x; ?x \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg ?z = ?x\n  ?z \\<noteq> 0 \\<Longrightarrow> cis (arg ?z) = sgn ?z\n  cmod (rcis ?r ?a) = \\<bar>?r\\<bar>\n  0 < n\n  rcis ?r ?a = complex_of_real ?r * cis ?a\n  sgn ?z = ?z / complex_of_real (cmod ?z)\n\ngoal (1 subgoal):\n 1. arg (rcis n x) = arg (cis x)", "by auto"], ["", "lemma arg_eqD: assumes \"arg (cis x) = arg (cis y)\" \"-pi < x\" \"x \\<le> pi\" \"-pi < y\" \"y \\<le> pi\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms(1)"], ["proof (prove)\nusing this:\n  arg (cis x) = arg (cis y)\n\ngoal (1 subgoal):\n 1. x = y", "unfolding arg_unique[OF sgn_cis assms(2-3)] arg_unique[OF sgn_cis assms(4-5)]"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["", "lemma rcis_inj_on: assumes r: \"r \\<noteq> 0\" shows \"inj_on (rcis r) {0 ..< 2 * pi}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (rcis r) {0..<2 * pi}", "proof (rule inj_onI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<2 * pi}; y \\<in> {0..<2 * pi};\n        rcis r x = rcis r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> {0..<2 * pi}\n  y \\<in> {0..<2 * pi}\n  rcis r x = rcis r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<2 * pi}; y \\<in> {0..<2 * pi};\n        rcis r x = rcis r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from arg_cong[OF 1(3), of \"\\<lambda> x. x / r\"]"], ["proof (chain)\npicking this:\n  rcis r x / complex_of_real r = rcis r y / complex_of_real r", "have \"cis x = cis y\""], ["proof (prove)\nusing this:\n  rcis r x / complex_of_real r = rcis r y / complex_of_real r\n\ngoal (1 subgoal):\n 1. cis x = cis y", "using r"], ["proof (prove)\nusing this:\n  rcis r x / complex_of_real r = rcis r y / complex_of_real r\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cis x = cis y", "by (simp add: rcis_def)"], ["proof (state)\nthis:\n  cis x = cis y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<2 * pi}; y \\<in> {0..<2 * pi};\n        rcis r x = rcis r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from arg_cong[OF this, of \"\\<lambda> x. inverse x\"]"], ["proof (chain)\npicking this:\n  inverse (cis x) = inverse (cis y)", "have \"cis (-x) = cis (-y)\""], ["proof (prove)\nusing this:\n  inverse (cis x) = inverse (cis y)\n\ngoal (1 subgoal):\n 1. cis (- x) = cis (- y)", "by simp"], ["proof (state)\nthis:\n  cis (- x) = cis (- y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<2 * pi}; y \\<in> {0..<2 * pi};\n        rcis r x = rcis r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from arg_cong[OF this, of uminus]"], ["proof (chain)\npicking this:\n  - cis (- x) = - cis (- y)", "have *: \"cis (-x + pi) = cis (-y + pi)\""], ["proof (prove)\nusing this:\n  - cis (- x) = - cis (- y)\n\ngoal (1 subgoal):\n 1. cis (- x + pi) = cis (- y + pi)", "by (auto simp: complex_eq_iff)"], ["proof (state)\nthis:\n  cis (- x + pi) = cis (- y + pi)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<2 * pi}; y \\<in> {0..<2 * pi};\n        rcis r x = rcis r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"- x + pi = - y + pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x + pi = - y + pi", "by (rule arg_eqD[OF arg_cong[OF *, of arg]], insert 1(1-2), auto)"], ["proof (state)\nthis:\n  - x + pi = - y + pi\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<2 * pi}; y \\<in> {0..<2 * pi};\n        rcis r x = rcis r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus ?case"], ["proof (prove)\nusing this:\n  - x + pi = - y + pi\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cis_inj_on: \"inj_on cis {0 ..< 2 * pi}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on cis {0..<2 * pi}", "using rcis_inj_on[of 1]"], ["proof (prove)\nusing this:\n  1 \\<noteq> 0 \\<Longrightarrow> inj_on (rcis 1) {0..<2 * pi}\n\ngoal (1 subgoal):\n 1. inj_on cis {0..<2 * pi}", "unfolding rcis_def"], ["proof (prove)\nusing this:\n  1 \\<noteq> 0 \\<Longrightarrow>\n  inj_on (\\<lambda>a. complex_of_real 1 * cis a) {0..<2 * pi}\n\ngoal (1 subgoal):\n 1. inj_on cis {0..<2 * pi}", "by auto"], ["", "definition root_unity :: \"nat \\<Rightarrow> 'a :: comm_ring_1 poly\" where\n  \"root_unity n = monom 1 n - 1\""], ["", "lemma poly_root_unity: \"poly (root_unity n) x = 0 \\<longleftrightarrow> x^n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (root_unity n) x = (0::'a)) = (x ^ n = (1::'a))", "unfolding root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (monom (1::'a) n - 1) x = (0::'a)) = (x ^ n = (1::'a))", "by (simp add: poly_monom)"], ["", "lemma degree_root_unity[simp]: \"degree (root_unity n) = n\" (is \"degree ?p = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "have p: \"?p = monom 1 n + (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity n = monom (1::'a) n + - 1", "unfolding root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) n - 1 = monom (1::'a) n + - 1", "by auto"], ["proof (state)\nthis:\n  root_unity n = monom (1::'a) n + - 1\n\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> degree (root_unity n) = n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> degree (root_unity n) = n", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> degree (root_unity n) = n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> degree (root_unity n) = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "unfolding p"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) n + - 1) = n", "by simp"], ["proof (state)\nthis:\n  degree (root_unity n) = n\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> degree (root_unity n) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> degree (root_unity n) = n", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> degree (root_unity n) = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) n + - 1) = n", "unfolding Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (Suc m) + - 1) = Suc m", "by (subst degree_add_eq_left, auto simp: degree_monom_eq)"], ["proof (state)\nthis:\n  degree (root_unity n) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (root_unity n) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_root_unit[simp]: \"root_unity n = 0 \\<longleftrightarrow> n = 0\" (is \"?p = 0 \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (root_unity n = 0) = (n = 0)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)\n 2. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)\n 2. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (root_unity n = 0) = (n = 0)", "unfolding root_unity_def"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (monom (1::'a) n - 1 = 0) = (n = 0)", "by simp"], ["proof (state)\nthis:\n  (root_unity n = 0) = (n = 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "from degree_root_unity[of n] False"], ["proof (chain)\npicking this:\n  degree (root_unity n) = n\n  n \\<noteq> 0", "have \"degree ?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (root_unity n) = n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (root_unity n) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree (root_unity n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "hence \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (root_unity n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_unity n \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  root_unity n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> (root_unity n = 0) = (n = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  root_unity n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (root_unity n = 0) = (n = 0)", "using False"], ["proof (prove)\nusing this:\n  root_unity n \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (root_unity n = 0) = (n = 0)", "by auto"], ["proof (state)\nthis:\n  (root_unity n = 0) = (n = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition prod_root_unity :: \"nat list \\<Rightarrow> 'a :: idom poly\" where\n  \"prod_root_unity ns = prod_list (map root_unity ns)\""], ["", "lemma poly_prod_root_unity: \"poly (prod_root_unity ns) x = 0 \\<longleftrightarrow> (\\<exists>k\\<in>set ns. x ^ k = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (prod_root_unity ns) x = (0::'a)) =\n    (\\<exists>k\\<in>set ns. x ^ k = (1::'a))", "unfolding prod_root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (prod_list (map root_unity ns)) x = (0::'a)) =\n    (\\<exists>k\\<in>set ns. x ^ k = (1::'a))", "by (simp add: poly_prod_list prod_list_zero_iff o_def image_def poly_root_unity)"], ["", "lemma degree_prod_root_unity[simp]: \"0 \\<notin> set ns \\<Longrightarrow> degree (prod_root_unity ns) = sum_list ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set ns \\<Longrightarrow>\n    degree (prod_root_unity ns) = sum_list ns", "unfolding prod_root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set ns \\<Longrightarrow>\n    degree (prod_list (map root_unity ns)) = sum_list ns", "by (subst degree_prod_list_eq, auto simp: o_def)"], ["", "lemma zero_prod_root_unit[simp]: \"prod_root_unity ns = 0 \\<longleftrightarrow> 0 \\<in> set ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod_root_unity ns = 0) = (0 \\<in> set ns)", "unfolding prod_root_unity_def prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<in> set (map root_unity ns)) = (0 \\<in> set ns)", "by auto"], ["", "lemma roots_of_unity: assumes n: \"n \\<noteq> 0\"\n  shows \"(\\<lambda> i. (cis (of_nat i * 2 * pi / n))) ` {0 ..< n} = { x :: complex. x ^ n = 1}\" (is \"?prod = ?Roots\")\n     \"{x. poly (root_unity n) x = 0} = { x :: complex. x ^ n = 1}\"\n     \"card { x :: complex. x ^ n = 1} = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} &&&\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} &&&\n    card {x. x ^ n = 1} = n", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "let ?one = \"1 :: complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "let ?p = \"monom ?one n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have degM: \"degree (monom ?one n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 n) = n", "by (rule degree_monom_eq, simp)"], ["proof (state)\nthis:\n  degree (monom 1 n) = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have \"degree ?p = degree (monom ?one n + (-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 n - 1) = degree (monom 1 n + - 1)", "by simp"], ["proof (state)\nthis:\n  degree (monom 1 n - 1) = degree (monom 1 n + - 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "also"], ["proof (state)\nthis:\n  degree (monom 1 n - 1) = degree (monom 1 n + - 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have \"\\<dots> = degree (monom ?one n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom 1 n + - 1) = degree (monom 1 n)", "by (rule degree_add_eq_left, insert n, simp add: degM)"], ["proof (state)\nthis:\n  degree (monom 1 n + - 1) = degree (monom 1 n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "finally"], ["proof (chain)\npicking this:\n  degree (monom 1 n - 1) = degree (monom 1 n)", "have degp: \"degree ?p = n\""], ["proof (prove)\nusing this:\n  degree (monom 1 n - 1) = degree (monom 1 n)\n\ngoal (1 subgoal):\n 1. degree (monom 1 n - 1) = n", "unfolding degM"], ["proof (prove)\nusing this:\n  degree (monom 1 n - 1) = n\n\ngoal (1 subgoal):\n 1. degree (monom 1 n - 1) = n", "."], ["proof (state)\nthis:\n  degree (monom 1 n - 1) = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "with n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  degree (monom 1 n - 1) = n", "have p: \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  degree (monom 1 n - 1) = n\n\ngoal (1 subgoal):\n 1. monom 1 n - 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  monom 1 n - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have roots: \"?Roots = {x. poly ?p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x ^ n = 1} = {x. poly (monom 1 n - 1) x = 0}", "unfolding poly_diff poly_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x ^ n = 1} = {x. 1 * x ^ n - poly 1 x = 0}", "by simp"], ["proof (state)\nthis:\n  {x. x ^ n = 1} = {x. poly (monom 1 n - 1) x = 0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "also"], ["proof (state)\nthis:\n  {x. x ^ n = 1} = {x. poly (monom 1 n - 1) x = 0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly (monom 1 n - 1) x = 0}", "by (rule poly_roots_finite[OF p])"], ["proof (state)\nthis:\n  finite {x. poly (monom 1 n - 1) x = 0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "finally"], ["proof (chain)\npicking this:\n  finite {x. x ^ n = 1}", "have fin: \"finite ?Roots\""], ["proof (prove)\nusing this:\n  finite {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. finite {x. x ^ n = 1}", "."], ["proof (state)\nthis:\n  finite {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have sub: \"?prod \\<subseteq> ?Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}\n    \\<subseteq> {x. x ^ n = 1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "assume \"x \\<in> ?prod\""], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}", "obtain i where x: \"x = cis (real i * 2 * pi / n)\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        x = cis (real i * 2 * pi / real n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = cis (real i * 2 * pi / real n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "have \"x ^ n = cis (real i * 2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ n = cis (real i * 2 * pi)", "unfolding x DeMoivre"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (real n * (real i * 2 * pi / real n)) = cis (real i * 2 * pi)", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cis (real n * (real i * 2 * pi / real n)) = cis (real i * 2 * pi)", "by simp"], ["proof (state)\nthis:\n  x ^ n = cis (real i * 2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "also"], ["proof (state)\nthis:\n  x ^ n = cis (real i * 2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (real i * 2 * pi) = 1", "by simp"], ["proof (state)\nthis:\n  cis (real i * 2 * pi) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>i. cis (real i * 2 * pi / real n)) `\n               {0..<n} \\<Longrightarrow>\n       x \\<in> {x. x ^ n = 1}", "finally"], ["proof (chain)\npicking this:\n  x ^ n = 1", "show \"x \\<in> ?Roots\""], ["proof (prove)\nusing this:\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. x \\<in> {x. x ^ n = 1}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {x. x ^ n = 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}\n  \\<subseteq> {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have Rn: \"card ?Roots \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. x ^ n = 1} \\<le> n", "unfolding roots"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (monom 1 n - 1) x = 0} \\<le> n", "by (rule poly_roots_degree[of ?p, unfolded degp, OF p])"], ["proof (state)\nthis:\n  card {x. x ^ n = 1} \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have \"\\<dots> = card {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = card {0..<n}", "by simp"], ["proof (state)\nthis:\n  n = card {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "also"], ["proof (state)\nthis:\n  n = card {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have \"\\<dots> = card ?prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n} =\n    card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})", "proof (rule card_image[symmetric], rule inj_onI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> {0..<n}\n  y \\<in> {0..<n}\n  cis (real x * 2 * pi / real n) = cis (real y * 2 * pi / real n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "{"], ["proof (state)\nthis:\n  x \\<in> {0..<n}\n  y \\<in> {0..<n}\n  cis (real x * 2 * pi / real n) = cis (real y * 2 * pi / real n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"real m < real n\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. real m < real n", "by simp"], ["proof (state)\nthis:\n  real m < real n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "from mult_strict_right_mono[OF this, of \"2 * pi / real n\"] n"], ["proof (chain)\npicking this:\n  0 < 2 * pi / real n \\<Longrightarrow>\n  real m * (2 * pi / real n) < real n * (2 * pi / real n)\n  n \\<noteq> 0", "have \"real m * 2 * pi / real n < real n * 2 * pi / real n\""], ["proof (prove)\nusing this:\n  0 < 2 * pi / real n \\<Longrightarrow>\n  real m * (2 * pi / real n) < real n * (2 * pi / real n)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real m * 2 * pi / real n < real n * 2 * pi / real n", "by simp"], ["proof (state)\nthis:\n  real m * 2 * pi / real n < real n * 2 * pi / real n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"real m * 2 * pi / real n < 2 * pi\""], ["proof (prove)\nusing this:\n  real m * 2 * pi / real n < real n * 2 * pi / real n\n\ngoal (1 subgoal):\n 1. real m * 2 * pi / real n < 2 * pi", "using n"], ["proof (prove)\nusing this:\n  real m * 2 * pi / real n < real n * 2 * pi / real n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real m * 2 * pi / real n < 2 * pi", "by simp"], ["proof (state)\nthis:\n  real m * 2 * pi / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "}"], ["proof (state)\nthis:\n  ?m2 < n \\<Longrightarrow> real ?m2 * 2 * pi / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "note [simp] = this"], ["proof (state)\nthis:\n  ?m2 < n \\<Longrightarrow> real ?m2 * 2 * pi / real n < 2 * pi\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "have 0: \"(1 :: real) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"real x * 2 * pi / real n = real y * 2 * pi / real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real x * 2 * pi / real n = real y * 2 * pi / real n", "by (rule inj_onD[OF rcis_inj_on 1(3)[unfolded cis_rcis_eq]], insert 1(1-2), auto)"], ["proof (state)\nthis:\n  real x * 2 * pi / real n = real y * 2 * pi / real n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n};\n        cis (real x * 2 * pi / real n) =\n        cis (real y * 2 * pi / real n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "with n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  real x * 2 * pi / real n = real y * 2 * pi / real n", "show \"x = y\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  real x * 2 * pi / real n = real y * 2 * pi / real n\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {0..<n} =\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "finally"], ["proof (chain)\npicking this:\n  n = card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})", "have cn:  \"card ?prod = n\""], ["proof (prove)\nusing this:\n  n = card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}) = n", ".."], ["proof (state)\nthis:\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}) = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "with Rn"], ["proof (chain)\npicking this:\n  card {x. x ^ n = 1} \\<le> n\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}) = n", "have \"card ?prod \\<ge> card ?Roots\""], ["proof (prove)\nusing this:\n  card {x. x ^ n = 1} \\<le> n\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}) = n\n\ngoal (1 subgoal):\n 1. card {x. x ^ n = 1}\n    \\<le> card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})", "by auto"], ["proof (state)\nthis:\n  card {x. x ^ n = 1}\n  \\<le> card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "with card_mono[OF fin sub]"], ["proof (chain)\npicking this:\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})\n  \\<le> card {x. x ^ n = 1}\n  card {x. x ^ n = 1}\n  \\<le> card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})", "have card: \"card ?prod = card ?Roots\""], ["proof (prove)\nusing this:\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})\n  \\<le> card {x. x ^ n = 1}\n  card {x. x ^ n = 1}\n  \\<le> card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n})\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}) =\n    card {x. x ^ n = 1}", "by auto"], ["proof (state)\nthis:\n  card ((\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}) =\n  card {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "have \"?prod = ?Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}", "by (rule card_subset_eq[OF fin sub card])"], ["proof (state)\nthis:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "from this roots[symmetric] cn[unfolded this]"], ["proof (chain)\npicking this:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (monom 1 n - 1) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n", "show ?case"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (monom 1 n - 1) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "unfolding root_unity_def"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (monom 1 n - 1) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n    {x. x ^ n = 1} \\<and>\n    {x. poly (monom 1 n - 1) x = 0} = {x. x ^ n = 1} \\<and>\n    card {x. x ^ n = 1} = n", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} =\n  {x. x ^ n = 1} \\<and>\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1} \\<and>\n  card {x. x ^ n = 1} = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_roots_dvd: fixes p :: \"'a :: field poly\"\n  assumes \"p \\<noteq> 0\" and \"degree p = n\"\n  and \"card {x. poly p x = 0} \\<ge> n\" and \"{x. poly p x = 0} \\<subseteq> {x. poly q x = 0}\"\nshows \"p dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd q", "from poly_roots_degree[OF assms(1)] assms(2-3)"], ["proof (chain)\npicking this:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n  degree p = n\n  n \\<le> card {x. poly p x = (0::'a)}", "have \"card {x. poly p x = 0} = n\""], ["proof (prove)\nusing this:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n  degree p = n\n  n \\<le> card {x. poly p x = (0::'a)}\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} = n", "by auto"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} = n\n\ngoal (1 subgoal):\n 1. p dvd q", "from assms(1-2) this assms(4)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  degree p = n\n  card {x. poly p x = (0::'a)} = n\n  {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p = n\n  card {x. poly p x = (0::'a)} = n\n  {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p dvd q", "proof (induct n arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<noteq> 0; degree p = 0;\n        card {x. poly p x = (0::'a)} = 0;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q\n 2. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "case (0 p q)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  degree p = 0\n  card {x. poly p x = (0::'a)} = 0\n  {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<noteq> 0; degree p = 0;\n        card {x. poly p x = (0::'a)} = 0;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q\n 2. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from is_unit_iff_degree[OF 0(1)] 0(2)"], ["proof (chain)\npicking this:\n  is_unit p = (degree p = 0)\n  degree p = 0", "show ?case"], ["proof (prove)\nusing this:\n  is_unit p = (degree p = 0)\n  degree p = 0\n\ngoal (1 subgoal):\n 1. p dvd q", "by blast"], ["proof (state)\nthis:\n  p dvd q\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "case (Suc n p q)"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<noteq> 0; degree ?p = n; card {x. poly ?p x = (0::'a)} = n;\n   {x. poly ?p x = (0::'a)} \\<subseteq> {x. poly ?q x = (0::'a)}\\<rbrakk>\n  \\<Longrightarrow> ?p dvd ?q\n  p \\<noteq> 0\n  degree p = Suc n\n  card {x. poly p x = (0::'a)} = Suc n\n  {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "let ?P = \"{x. poly p x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "let ?Q = \"{x. poly q x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from Suc(4-5) card_gt_0_iff[of ?P]"], ["proof (chain)\npicking this:\n  card {x. poly p x = (0::'a)} = Suc n\n  {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\n  (0 < card {x. poly p x = (0::'a)}) =\n  ({x. poly p x = (0::'a)} \\<noteq> {} \\<and>\n   finite {x. poly p x = (0::'a)})", "obtain x where\n      x: \"poly p x = 0\" \"poly q x = 0\" and fin: \"finite ?P\""], ["proof (prove)\nusing this:\n  card {x. poly p x = (0::'a)} = Suc n\n  {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\n  (0 < card {x. poly p x = (0::'a)}) =\n  ({x. poly p x = (0::'a)} \\<noteq> {} \\<and>\n   finite {x. poly p x = (0::'a)})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>poly p x = (0::'a); poly q x = (0::'a);\n         finite {x. poly p x = (0::'a)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n  poly q x = (0::'a)\n  finite {x. poly p x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "define r where \"r = [:-x, 1:]\""], ["proof (state)\nthis:\n  r = [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from x[unfolded poly_eq_0_iff_dvd r_def[symmetric]]"], ["proof (chain)\npicking this:\n  r dvd p\n  r dvd q", "obtain p' q' where\n      p: \"p = r * p'\" and q: \"q = r * q'\""], ["proof (prove)\nusing this:\n  r dvd p\n  r dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p = r * p'; q = r * q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. p = r * k\n  \\<exists>k. q = r * k\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p = r * p'; q = r * q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = r * p'\n  q = r * q'\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from Suc(2)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"degree p = degree r + degree p'\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = degree r + degree p'", "unfolding p"], ["proof (prove)\nusing this:\n  r * p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (r * p') = degree r + degree p'", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree p = degree r + degree p'\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "with Suc(3)"], ["proof (chain)\npicking this:\n  degree p = Suc n\n  degree p = degree r + degree p'", "have deg: \"degree p' = n\""], ["proof (prove)\nusing this:\n  degree p = Suc n\n  degree p = degree r + degree p'\n\ngoal (1 subgoal):\n 1. degree p' = n", "unfolding r_def"], ["proof (prove)\nusing this:\n  degree p = Suc n\n  degree p = degree [:- x, 1::'a:] + degree p'\n\ngoal (1 subgoal):\n 1. degree p' = n", "by auto"], ["proof (state)\nthis:\n  degree p' = n\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from Suc(2) p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = r * p'", "have p'0: \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = r * p'\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "let ?P' = \"{x. poly p' x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "let ?Q' = \"{x. poly q' x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "have P: \"?P = insert x ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = insert x {x. poly p' x = (0::'a)}", "unfolding p poly_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly r x * poly p' x = (0::'a)} = insert x {x. poly p' x = (0::'a)}", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa. poly [:- x, 1::'a:] xa * poly p' xa = (0::'a)} =\n    insert x {x. poly p' x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = (0::'a)} = insert x {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "have Q: \"?Q = insert x ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly q x = (0::'a)} = insert x {x. poly q' x = (0::'a)}", "unfolding q poly_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly r x * poly q' x = (0::'a)} = insert x {x. poly q' x = (0::'a)}", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa. poly [:- x, 1::'a:] xa * poly q' xa = (0::'a)} =\n    insert x {x. poly q' x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. poly q x = (0::'a)} = insert x {x. poly q' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "{"], ["proof (state)\nthis:\n  {x. poly q x = (0::'a)} = insert x {x. poly q' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "assume \"x \\<in> ?P'\""], ["proof (state)\nthis:\n  x \\<in> {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "hence \"?P = ?P'\""], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {x. poly p' x = (0::'a)}", "unfolding P"], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. insert x {x. poly p' x = (0::'a)} = {x. poly p' x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = (0::'a)} = {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from arg_cong[OF this, of card, unfolded Suc(4)] deg"], ["proof (chain)\npicking this:\n  Suc n = card {x. poly p' x = (0::'a)}\n  degree p' = n", "have False"], ["proof (prove)\nusing this:\n  Suc n = card {x. poly p' x = (0::'a)}\n  degree p' = n\n\ngoal (1 subgoal):\n 1. False", "using poly_roots_degree[OF p'0]"], ["proof (prove)\nusing this:\n  Suc n = card {x. poly p' x = (0::'a)}\n  degree p' = n\n  card {x. poly p' x = (0::'a)} \\<le> degree p'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "}"], ["proof (state)\nthis:\n  x \\<in> {x. poly p' x = (0::'a)} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "note xp' = this"], ["proof (state)\nthis:\n  x \\<in> {x. poly p' x = (0::'a)} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "hence xP': \"x \\<notin> ?P'\""], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p' x = (0::'a)} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. x \\<notin> {x. poly p' x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "have \"card ?P = Suc (card ?P')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} = Suc (card {x. poly p' x = (0::'a)})", "unfolding P"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x {x. poly p' x = (0::'a)}) =\n    Suc (card {x. poly p' x = (0::'a)})", "by (rule card_insert_disjoint[OF _ xP'], insert fin[unfolded P], auto)"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} = Suc (card {x. poly p' x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "with Suc(4)"], ["proof (chain)\npicking this:\n  card {x. poly p x = (0::'a)} = Suc n\n  card {x. poly p x = (0::'a)} = Suc (card {x. poly p' x = (0::'a)})", "have card: \"card ?P' = n\""], ["proof (prove)\nusing this:\n  card {x. poly p x = (0::'a)} = Suc n\n  card {x. poly p x = (0::'a)} = Suc (card {x. poly p' x = (0::'a)})\n\ngoal (1 subgoal):\n 1. card {x. poly p' x = (0::'a)} = n", "by auto"], ["proof (state)\nthis:\n  card {x. poly p' x = (0::'a)} = n\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from Suc(5)[unfolded P Q] xP'"], ["proof (chain)\npicking this:\n  insert x {x. poly p' x = (0::'a)}\n  \\<subseteq> insert x {x. poly q' x = (0::'a)}\n  x \\<notin> {x. poly p' x = (0::'a)}", "have \"?P' \\<subseteq> ?Q'\""], ["proof (prove)\nusing this:\n  insert x {x. poly p' x = (0::'a)}\n  \\<subseteq> insert x {x. poly q' x = (0::'a)}\n  x \\<notin> {x. poly p' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. {x. poly p' x = (0::'a)} \\<subseteq> {x. poly q' x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. poly p' x = (0::'a)} \\<subseteq> {x. poly q' x = (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "from Suc(1)[OF p'0 deg card this]"], ["proof (chain)\npicking this:\n  p' dvd q'", "have IH: \"p' dvd q'\""], ["proof (prove)\nusing this:\n  p' dvd q'\n\ngoal (1 subgoal):\n 1. p' dvd q'", "."], ["proof (state)\nthis:\n  p' dvd q'\n\ngoal (1 subgoal):\n 1. \\<And>n p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>p \\<noteq> 0; degree p = n;\n                    card {x. poly p x = (0::'a)} = n;\n                    {x. poly p x = (0::'a)}\n                    \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n                   \\<Longrightarrow> p dvd q;\n        p \\<noteq> 0; degree p = Suc n;\n        card {x. poly p x = (0::'a)} = Suc n;\n        {x. poly p x = (0::'a)} \\<subseteq> {x. poly q x = (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> p dvd q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd q", "unfolding p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. r * p' dvd r * q'", "using IH"], ["proof (prove)\nusing this:\n  p' dvd q'\n\ngoal (1 subgoal):\n 1. r * p' dvd r * q'", "by simp"], ["proof (state)\nthis:\n  p dvd q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p dvd q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_unity_decomp: assumes n: \"n \\<noteq> 0\"\n  shows \"root_unity n =\n    prod_list (map (\\<lambda> i. [:-cis (of_nat i * 2 * pi / n), 1:]) [0 ..< n])\" (is \"?u = ?p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have deg: \"degree ?u = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (root_unity n) = n", "by simp"], ["proof (state)\nthis:\n  degree (root_unity n) = n\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "note main = roots_of_unity[OF n]"], ["proof (state)\nthis:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have dvd: \"?u dvd ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity n dvd\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "proof (rule poly_roots_dvd[OF _ deg])"], ["proof (state)\ngoal (3 subgoals):\n 1. root_unity n \\<noteq> 0\n 2. n \\<le> card {x. poly (root_unity n) x = 0}\n 3. {x. poly (root_unity n) x = 0}\n    \\<subseteq> {x. poly\n                     (\\<Prod>i\\<leftarrow>[0..<\n     n]. [:- cis (real i * 2 * pi / real n), 1:])\n                     x =\n                    0}", "show \"n \\<le> card {x. poly ?u x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> card {x. poly (root_unity n) x = 0}", "using main"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n\n\ngoal (1 subgoal):\n 1. n \\<le> card {x. poly (root_unity n) x = 0}", "by auto"], ["proof (state)\nthis:\n  n \\<le> card {x. poly (root_unity n) x = 0}\n\ngoal (2 subgoals):\n 1. root_unity n \\<noteq> 0\n 2. {x. poly (root_unity n) x = 0}\n    \\<subseteq> {x. poly\n                     (\\<Prod>i\\<leftarrow>[0..<\n     n]. [:- cis (real i * 2 * pi / real n), 1:])\n                     x =\n                    0}", "show \"?u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity n \\<noteq> 0", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_unity n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  root_unity n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly (root_unity n) x = 0}\n    \\<subseteq> {x. poly\n                     (\\<Prod>i\\<leftarrow>[0..<\n     n]. [:- cis (real i * 2 * pi / real n), 1:])\n                     x =\n                    0}", "show \"{x. poly ?u x = 0} \\<subseteq> {x. poly ?p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (root_unity n) x = 0}\n    \\<subseteq> {x. poly\n                     (\\<Prod>i\\<leftarrow>[0..<\n     n]. [:- cis (real i * 2 * pi / real n), 1:])\n                     x =\n                    0}", "unfolding main(2) main(1)[symmetric] poly_prod_list prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n}\n    \\<subseteq> {x. 0 \\<in> set (map (\\<lambda>p. poly p x)\n                                  (map (\\<lambda>i.\n     [:- cis (real i * 2 * pi / real n), 1:])\n                                    [0..<n]))}", "by auto"], ["proof (state)\nthis:\n  {x. poly (root_unity n) x = 0}\n  \\<subseteq> {x. poly\n                   (\\<Prod>i\\<leftarrow>[0..<\n   n]. [:- cis (real i * 2 * pi / real n), 1:])\n                   x =\n                  0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_unity n dvd\n  (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have deg': \"degree ?p = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<leftarrow>[0..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n    n", "by (subst degree_prod_list_eq, auto simp: o_def sum_list_triv)"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  n\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have mon: \"monic ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (root_unity n)", "using deg"], ["proof (prove)\nusing this:\n  degree (root_unity n) = n\n\ngoal (1 subgoal):\n 1. monic (root_unity n)", "unfolding root_unity_def"], ["proof (prove)\nusing this:\n  degree (monom 1 n - 1) = n\n\ngoal (1 subgoal):\n 1. monic (monom 1 n - 1)", "using n"], ["proof (prove)\nusing this:\n  degree (monom 1 n - 1) = n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (monom 1 n - 1)", "by auto"], ["proof (state)\nthis:\n  monic (root_unity n)\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have mon': \"monic ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic\n     (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "by (rule monic_prod_list, auto)"], ["proof (state)\nthis:\n  monic\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "from dvd[unfolded dvd_def]"], ["proof (chain)\npicking this:\n  \\<exists>k.\n     (\\<Prod>i\\<leftarrow>[0..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n     root_unity n * k", "obtain f where puf: \"?p = ?u * f\""], ["proof (prove)\nusing this:\n  \\<exists>k.\n     (\\<Prod>i\\<leftarrow>[0..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n     root_unity n * k\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<Prod>i\\<leftarrow>[0..<\n                              n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n        root_unity n * f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  root_unity n * f\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have \"degree ?p = degree ?u + degree f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<leftarrow>[0..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n    degree (root_unity n) + degree f", "using mon' n"], ["proof (prove)\nusing this:\n  monic\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<leftarrow>[0..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n    degree (root_unity n) + degree f", "unfolding puf"], ["proof (prove)\nusing this:\n  monic (root_unity n * f)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (root_unity n * f) = degree (root_unity n) + degree f", "by (subst degree_mult_eq, auto)"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  degree (root_unity n) + degree f\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "with deg deg'"], ["proof (chain)\npicking this:\n  degree (root_unity n) = n\n  degree\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  n\n  degree\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  degree (root_unity n) + degree f", "have \"degree f = 0\""], ["proof (prove)\nusing this:\n  degree (root_unity n) = n\n  degree\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  n\n  degree\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  degree (root_unity n) + degree f\n\ngoal (1 subgoal):\n 1. degree f = 0", "by auto"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "from degree0_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a. f = [:a:]", "obtain a where f: \"f = [:a:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. f = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>a. f = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  f = [:a:]\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "from arg_cong[OF puf, of lead_coeff] mon mon'"], ["proof (chain)\npicking this:\n  lead_coeff\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  lead_coeff (root_unity n * f)\n  monic (root_unity n)\n  monic\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "have \"a = 1\""], ["proof (prove)\nusing this:\n  lead_coeff\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  lead_coeff (root_unity n * f)\n  monic (root_unity n)\n  monic\n   (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])\n\ngoal (1 subgoal):\n 1. a = 1", "unfolding puf f"], ["proof (prove)\nusing this:\n  lead_coeff (root_unity n * [:a:]) = lead_coeff (root_unity n * [:a:])\n  monic (root_unity n)\n  monic (root_unity n * [:a:])\n\ngoal (1 subgoal):\n 1. a = 1", "by (cases \"a = 0\", auto)"], ["proof (state)\nthis:\n  a = 1\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "with f"], ["proof (chain)\npicking this:\n  f = [:a:]\n  a = 1", "have f: \"f = 1\""], ["proof (prove)\nusing this:\n  f = [:a:]\n  a = 1\n\ngoal (1 subgoal):\n 1. f = 1", "by auto"], ["proof (state)\nthis:\n  f = 1\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "with puf"], ["proof (chain)\npicking this:\n  (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  root_unity n * f\n  f = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n  root_unity n * f\n  f = 1\n\ngoal (1 subgoal):\n 1. root_unity n =\n    (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])", "by auto"], ["proof (state)\nthis:\n  root_unity n =\n  (\\<Prod>i\\<leftarrow>[0..<n]. [:- cis (real i * 2 * pi / real n), 1:])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_monic_linear: \"order x [:y,1:] = (if y + x = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "proof (cases \"y + x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y + x = (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n 2. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "case True"], ["proof (state)\nthis:\n  y + x = (0::'a)\n\ngoal (2 subgoals):\n 1. y + x = (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n 2. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "hence \"poly [:y,1:] x = 0\""], ["proof (prove)\nusing this:\n  y + x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly [:y, 1::'a:] x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly [:y, 1::'a:] x = (0::'a)\n\ngoal (2 subgoals):\n 1. y + x = (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n 2. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "from this[unfolded order_root]"], ["proof (chain)\npicking this:\n  [:y, 1::'a:] = 0 \\<or> order x [:y, 1::'a:] \\<noteq> 0", "have \"order x [:y,1:] \\<noteq> 0\""], ["proof (prove)\nusing this:\n  [:y, 1::'a:] = 0 \\<or> order x [:y, 1::'a:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x [:y, 1::'a:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order x [:y, 1::'a:] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y + x = (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n 2. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  order x [:y, 1::'a:] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y + x = (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n 2. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "from order_degree[of \"[:y,1:]\" x]"], ["proof (chain)\npicking this:\n  [:y, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n  order x [:y, 1::'a:] \\<le> degree [:y, 1::'a:]", "have \"order x [:y,1:] \\<le> 1\""], ["proof (prove)\nusing this:\n  [:y, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n  order x [:y, 1::'a:] \\<le> degree [:y, 1::'a:]\n\ngoal (1 subgoal):\n 1. order x [:y, 1::'a:] \\<le> 1", "by auto"], ["proof (state)\nthis:\n  order x [:y, 1::'a:] \\<le> 1\n\ngoal (2 subgoals):\n 1. y + x = (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n 2. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  order x [:y, 1::'a:] \\<noteq> 0\n  order x [:y, 1::'a:] \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order x [:y, 1::'a:] \\<noteq> 0\n  order x [:y, 1::'a:] \\<le> 1\n\ngoal (1 subgoal):\n 1. order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "unfolding True"], ["proof (prove)\nusing this:\n  order x [:y, 1::'a:] \\<noteq> 0\n  order x [:y, 1::'a:] \\<le> 1\n\ngoal (1 subgoal):\n 1. order x [:y, 1::'a:] = (if (0::'a) = (0::'a) then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n\ngoal (1 subgoal):\n 1. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "case False"], ["proof (state)\nthis:\n  y + x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "hence \"poly [:y,1:] x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y + x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly [:y, 1::'a:] x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly [:y, 1::'a:] x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y + x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "from order_0I[OF this] False"], ["proof (chain)\npicking this:\n  order x [:y, 1::'a:] = 0\n  y + x \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  order x [:y, 1::'a:] = 0\n  y + x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  order x [:y, 1::'a:] = (if y + x = (0::'a) then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_root_unity: fixes x :: complex assumes n: \"n \\<noteq> 0\"\n  shows \"order x (root_unity n) = (if x^n = 1 then 1 else 0)\"\n  (is \"order _ ?u = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "proof (cases \"x^n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)\n 2. x ^ n \\<noteq> 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "case False"], ["proof (state)\nthis:\n  x ^ n \\<noteq> 1\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)\n 2. x ^ n \\<noteq> 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "with roots_of_unity(2)[OF n]"], ["proof (chain)\npicking this:\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n  x ^ n \\<noteq> 1", "have \"poly ?u x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n  x ^ n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. poly (root_unity n) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (root_unity n) x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)\n 2. x ^ n \\<noteq> 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "from False order_0I[OF this]"], ["proof (chain)\npicking this:\n  x ^ n \\<noteq> 1\n  order x (root_unity n) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x ^ n \\<noteq> 1\n  order x (root_unity n) = 0\n\ngoal (1 subgoal):\n 1. order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  order x (root_unity n) = (if x ^ n = 1 then 1 else 0)\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "case True"], ["proof (state)\nthis:\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "let ?phi = \"\\<lambda> i :: nat. i * 2 * pi / n\""], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "from True roots_of_unity(1)[OF n]"], ["proof (chain)\npicking this:\n  x ^ n = 1\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}", "obtain i where i: \"i < n\"\n    and x: \"x = cis (?phi i)\""], ["proof (prove)\nusing this:\n  x ^ n = 1\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; x = cis (real i * 2 * pi / real n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  i < n\n  x = cis (real i * 2 * pi / real n)\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "from i"], ["proof (chain)\npicking this:\n  i < n", "have n_split: \"[0 ..< n] = [0 ..< i] @ i # [Suc i ..< n]\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. [0..<n] = [0..<i] @ i # [Suc i..<n]", "by (metis le_Suc_ex less_imp_le_nat not_le_imp_less not_less0 upt_add_eq_append upt_conv_Cons)"], ["proof (state)\nthis:\n  [0..<n] = [0..<i] @ i # [Suc i..<n]\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "{"], ["proof (state)\nthis:\n  [0..<n] = [0..<i] @ i # [Suc i..<n]\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "assume j: \"j < n \\<or> j < i\" and eq: \"cis (?phi i) = cis (?phi j)\""], ["proof (state)\nthis:\n  j < n \\<or> j < i\n  cis (real i * 2 * pi / real n) = cis (real j * 2 * pi / real n)\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "from inj_onD[OF cis_inj_on eq] i j n"], ["proof (chain)\npicking this:\n  \\<lbrakk>real i * 2 * pi / real n \\<in> {0..<2 * pi};\n   real j * 2 * pi / real n \\<in> {0..<2 * pi}\\<rbrakk>\n  \\<Longrightarrow> real i * 2 * pi / real n = real j * 2 * pi / real n\n  i < n\n  j < n \\<or> j < i\n  n \\<noteq> 0", "have \"i = j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>real i * 2 * pi / real n \\<in> {0..<2 * pi};\n   real j * 2 * pi / real n \\<in> {0..<2 * pi}\\<rbrakk>\n  \\<Longrightarrow> real i * 2 * pi / real n = real j * 2 * pi / real n\n  i < n\n  j < n \\<or> j < i\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = j", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < n \\<or> ?j2 < i;\n   cis (real i * 2 * pi / real n) =\n   cis (real ?j2 * 2 * pi / real n)\\<rbrakk>\n  \\<Longrightarrow> i = ?j2\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "note inj = this"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < n \\<or> ?j2 < i;\n   cis (real i * 2 * pi / real n) =\n   cis (real ?j2 * 2 * pi / real n)\\<rbrakk>\n  \\<Longrightarrow> i = ?j2\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "have \"order x ?u = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (root_unity n) = 1", "unfolding root_unity_decomp[OF n]"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x\n     (\\<Prod>i\\<leftarrow>[0..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n    1", "unfolding x n_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (cis (real i * 2 * pi / real n))\n     (\\<Prod>i\\<leftarrow>[0..<i] @\n                          i #\n                          [Suc i..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n    1", "using inj"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < n \\<or> ?j2 < i;\n   cis (real i * 2 * pi / real n) =\n   cis (real ?j2 * 2 * pi / real n)\\<rbrakk>\n  \\<Longrightarrow> i = ?j2\n\ngoal (1 subgoal):\n 1. order (cis (real i * 2 * pi / real n))\n     (\\<Prod>i\\<leftarrow>[0..<i] @\n                          i #\n                          [Suc i..<\n                           n]. [:- cis (real i * 2 * pi / real n), 1:]) =\n    1", "by (subst order_prod_list, force, fastforce simp: order_monic_linear)"], ["proof (state)\nthis:\n  order x (root_unity n) = 1\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow>\n    order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "with True"], ["proof (chain)\npicking this:\n  x ^ n = 1\n  order x (root_unity n) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x ^ n = 1\n  order x (root_unity n) = 1\n\ngoal (1 subgoal):\n 1. order x (root_unity n) = (if x ^ n = 1 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  order x (root_unity n) = (if x ^ n = 1 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_prod_root_unity: assumes 0: \"0 \\<notin> set ks\"\n  shows \"order (x :: complex) (prod_root_unity ks) = length (filter (\\<lambda> k. x^k = 1) ks)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "have \"order x (prod_root_unity ks) = (\\<Sum>k\\<leftarrow>ks. order x (root_unity k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    (\\<Sum>k\\<leftarrow>ks. order x (root_unity k))", "unfolding prod_root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod_list (map root_unity ks)) =\n    (\\<Sum>k\\<leftarrow>ks. order x (root_unity k))", "by (subst order_prod_list, insert 0, auto simp: o_def)"], ["proof (state)\nthis:\n  order x (prod_root_unity ks) =\n  (\\<Sum>k\\<leftarrow>ks. order x (root_unity k))\n\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "also"], ["proof (state)\nthis:\n  order x (prod_root_unity ks) =\n  (\\<Sum>k\\<leftarrow>ks. order x (root_unity k))\n\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "have \"\\<dots> = (\\<Sum>k\\<leftarrow>ks. (if x^k = 1 then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>ks. order x (root_unity k)) =\n    (\\<Sum>k\\<leftarrow>ks. if x ^ k = 1 then 1 else 0)", "by (rule arg_cong, rule map_cong, insert 0, force, intro order_root_unity, metis)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>ks. order x (root_unity k)) =\n  (\\<Sum>k\\<leftarrow>ks. if x ^ k = 1 then 1 else 0)\n\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>ks. order x (root_unity k)) =\n  (\\<Sum>k\\<leftarrow>ks. if x ^ k = 1 then 1 else 0)\n\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "have \"\\<dots> = length (filter (\\<lambda> k. x^k = 1) ks)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>ks. if x ^ k = 1 then 1 else 0) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "by (subst sum_list_map_filter'[symmetric], simp add: sum_list_triv)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>ks. if x ^ k = 1 then 1 else 0) =\n  length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "finally"], ["proof (chain)\npicking this:\n  order x (prod_root_unity ks) = length (filter (\\<lambda>k. x ^ k = 1) ks)", "show ?thesis"], ["proof (prove)\nusing this:\n  order x (prod_root_unity ks) = length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal (1 subgoal):\n 1. order x (prod_root_unity ks) =\n    length (filter (\\<lambda>k. x ^ k = 1) ks)", "."], ["proof (state)\nthis:\n  order x (prod_root_unity ks) = length (filter (\\<lambda>k. x ^ k = 1) ks)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_unity_witness: fixes xs :: \"complex list\"\n  assumes \"prod_list (map (\\<lambda> x. [:-x,1:]) xs) = monom 1 n - 1\"\n  shows \"x^n = 1 \\<longleftrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "from assms"], ["proof (chain)\npicking this:\n  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) = monom 1 n - 1", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) = monom 1 n - 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by (cases \"n = 0\", auto simp: prod_list_zero_iff)"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "have \"x \\<in> set xs \\<longleftrightarrow> poly (prod_list (map (\\<lambda> x. [:-x,1:]) xs)) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set xs) = (poly (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) x = 0)", "unfolding poly_prod_list prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set xs) =\n    (0 \\<in> set (map (\\<lambda>p. poly p x)\n                   (map (\\<lambda>x. [:- x, 1:]) xs)))", "by auto"], ["proof (state)\nthis:\n  (x \\<in> set xs) = (poly (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) x = 0)\n\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "also"], ["proof (state)\nthis:\n  (x \\<in> set xs) = (poly (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) x = 0)\n\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "have \"\\<dots> \\<longleftrightarrow> x^n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) x = 0) = (x ^ n = 1)", "using roots_of_unity(2)[OF n0]"], ["proof (prove)\nusing this:\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (poly (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) x = 0) = (x ^ n = 1)", "unfolding assms root_unity_def"], ["proof (prove)\nusing this:\n  {x. poly (monom 1 n - 1) x = 0} = {x. x ^ n = 1}\n\ngoal (1 subgoal):\n 1. (poly (monom 1 n - 1) x = 0) = (x ^ n = 1)", "by auto"], ["proof (state)\nthis:\n  (poly (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) x = 0) = (x ^ n = 1)\n\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> set xs) = (x ^ n = 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<in> set xs) = (x ^ n = 1)\n\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (x \\<in> set xs)", "by auto"], ["proof (state)\nthis:\n  (x ^ n = 1) = (x \\<in> set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_unity_explicit: fixes x :: complex\n  shows\n    \"(x ^ 1 = 1) \\<longleftrightarrow> x = 1\"\n    \"(x ^ 2 = 1) \\<longleftrightarrow> (x \\<in> {1, -1})\"\n    \"(x ^ 3 = 1) \\<longleftrightarrow> (x \\<in> {1, Complex (-1/2) (sqrt 3 / 2), Complex (-1/2) (- sqrt 3 / 2)})\"\n    \"(x ^ 4 = 1) \\<longleftrightarrow> (x \\<in> {1, -1, \\<i>, - \\<i>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x ^ 1 = 1) = (x = 1) &&& (x\\<^sup>2 = 1) = (x \\<in> {1, - 1})) &&&\n    (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) &&&\n    (x ^ 4 = 1) = (x \\<in> {1, - 1, \\<i>, - \\<i>})", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. (x ^ 1 = 1) = (x = 1)\n 2. (x\\<^sup>2 = 1) = (x \\<in> {1, - 1})\n 3. (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)})\n 4. (x ^ 4 = 1) = (x \\<in> {1, - 1, \\<i>, - \\<i>})", "show \"(x ^ 1 = 1) \\<longleftrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ 1 = 1) = (x = 1)", "by (subst root_unity_witness[of \"[1]\"], code_simp, auto)"], ["proof (state)\nthis:\n  (x ^ 1 = 1) = (x = 1)\n\ngoal (3 subgoals):\n 1. (x\\<^sup>2 = 1) = (x \\<in> {1, - 1})\n 2. (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)})\n 3. (x ^ 4 = 1) = (x \\<in> {1, - 1, \\<i>, - \\<i>})", "show \"(x ^ 2 = 1) \\<longleftrightarrow> (x \\<in> {1, -1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 = 1) = (x \\<in> {1, - 1})", "by (subst root_unity_witness[of \"[1,-1]\"], code_simp, auto)"], ["proof (state)\nthis:\n  (x\\<^sup>2 = 1) = (x \\<in> {1, - 1})\n\ngoal (2 subgoals):\n 1. (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)})\n 2. (x ^ 4 = 1) = (x \\<in> {1, - 1, \\<i>, - \\<i>})", "show \"(x ^ 4 = 1) \\<longleftrightarrow> (x \\<in> {1, -1, \\<i>, - \\<i>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ 4 = 1) = (x \\<in> {1, - 1, \\<i>, - \\<i>})", "by (subst root_unity_witness[of \"[1,-1, \\<i>, - \\<i>]\"], code_simp, auto)"], ["proof (state)\nthis:\n  (x ^ 4 = 1) = (x \\<in> {1, - 1, \\<i>, - \\<i>})\n\ngoal (1 subgoal):\n 1. (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)})", "have 3: \"3 = Suc (Suc (Suc 0))\" \"1 = [:1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 = Suc (Suc (Suc 0)) &&& 1 = [:1::'a:]", "by auto"], ["proof (state)\nthis:\n  3 = Suc (Suc (Suc 0))\n  1 = [:1::?'a1:]\n\ngoal (1 subgoal):\n 1. (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)})", "show \"(x ^ 3 = 1) \\<longleftrightarrow> (x \\<in> {1, Complex (-1/2) (sqrt 3 / 2), Complex (-1/2) (- sqrt 3 / 2)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ 3 = 1) =\n    (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)})", "by (subst root_unity_witness[of\n      \"[1, Complex (-1/2) (sqrt 3 / 2), Complex (-1/2) (- sqrt 3 / 2)]\"],\n      auto simp: 3 monom_altdef complex_mult complex_eq_iff)"], ["proof (state)\nthis:\n  (x ^ 3 = 1) =\n  (x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n            Complex (- 1 / 2) (- sqrt 3 / 2)})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition primitive_root_unity :: \"nat \\<Rightarrow> 'a :: power \\<Rightarrow> bool\" where\n  \"primitive_root_unity k x = (k \\<noteq> 0 \\<and> x^k = 1 \\<and> (\\<forall> k' < k. k' \\<noteq> 0 \\<longrightarrow> x^k' \\<noteq> 1))\""], ["", "lemma primitive_root_unityD: assumes \"primitive_root_unity k x\"\n  shows \"k \\<noteq> 0\" \"x^k = 1\" \"k' \\<noteq> 0 \\<Longrightarrow> x^k' = 1 \\<Longrightarrow> k \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 &&&\n    x ^ k = (1::'a) &&&\n    (\\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n     \\<Longrightarrow> k \\<le> k')", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<noteq> 0\n 2. x ^ k = (1::'a)\n 3. \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "note * = assms[unfolded primitive_root_unity_def]"], ["proof (state)\nthis:\n  k \\<noteq> 0 \\<and>\n  x ^ k = (1::'a) \\<and>\n  (\\<forall>k'<k. k' \\<noteq> 0 \\<longrightarrow> x ^ k' \\<noteq> (1::'a))\n\ngoal (3 subgoals):\n 1. k \\<noteq> 0\n 2. x ^ k = (1::'a)\n 3. \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "from *"], ["proof (chain)\npicking this:\n  k \\<noteq> 0 \\<and>\n  x ^ k = (1::'a) \\<and>\n  (\\<forall>k'<k. k' \\<noteq> 0 \\<longrightarrow> x ^ k' \\<noteq> (1::'a))", "have **: \"k' < k \\<Longrightarrow> k' \\<noteq> 0 \\<Longrightarrow> x ^ k' \\<noteq> 1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0 \\<and>\n  x ^ k = (1::'a) \\<and>\n  (\\<forall>k'<k. k' \\<noteq> 0 \\<longrightarrow> x ^ k' \\<noteq> (1::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k' < k; k' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x ^ k' \\<noteq> (1::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>k' < k; k' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> x ^ k' \\<noteq> (1::'a)\n\ngoal (3 subgoals):\n 1. k \\<noteq> 0\n 2. x ^ k = (1::'a)\n 3. \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "show \"k \\<noteq> 0\" \"x^k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 &&& x ^ k = (1::'a)", "using *"], ["proof (prove)\nusing this:\n  k \\<noteq> 0 \\<and>\n  x ^ k = (1::'a) \\<and>\n  (\\<forall>k'<k. k' \\<noteq> 0 \\<longrightarrow> x ^ k' \\<noteq> (1::'a))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 &&& x ^ k = (1::'a)", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  x ^ k = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "show \"k' \\<noteq> 0 \\<Longrightarrow> x^k' = 1 \\<Longrightarrow> k \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "using **"], ["proof (prove)\nusing this:\n  \\<lbrakk>k' < k; k' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> x ^ k' \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>k' \\<noteq> 0; x ^ k' = (1::'a)\\<rbrakk>\n  \\<Longrightarrow> k \\<le> k'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_root_unity_exists: assumes \"k \\<noteq> 0\" \"x ^ k = 1\"\n  shows \"\\<exists> k'. k' \\<le> k \\<and> primitive_root_unity k' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "let ?P = \"\\<lambda> k. x ^ k = 1 \\<and> k \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "define k' where \"k' = (LEAST k. ?P k)\""], ["proof (state)\nthis:\n  k' = (LEAST k. x ^ k = (1::'a) \\<and> k \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "from assms"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  x ^ k = (1::'a)", "have Pk: \"\\<exists> k. ?P k\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  x ^ k = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>k. x ^ k = (1::'a) \\<and> k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. x ^ k = (1::'a) \\<and> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "from LeastI_ex[OF Pk, folded k'_def]"], ["proof (chain)\npicking this:\n  x ^ k' = (1::'a) \\<and> k' \\<noteq> 0", "have \"k' \\<noteq> 0\" \"x ^ k' = 1\""], ["proof (prove)\nusing this:\n  x ^ k' = (1::'a) \\<and> k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 0 &&& x ^ k' = (1::'a)", "by auto"], ["proof (state)\nthis:\n  k' \\<noteq> 0\n  x ^ k' = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "with not_less_Least[of _ ?P, folded k'_def]"], ["proof (chain)\npicking this:\n  ?k < k' \\<Longrightarrow> \\<not> (x ^ ?k = (1::'a) \\<and> ?k \\<noteq> 0)\n  k' \\<noteq> 0\n  x ^ k' = (1::'a)", "have \"primitive_root_unity k' x\""], ["proof (prove)\nusing this:\n  ?k < k' \\<Longrightarrow> \\<not> (x ^ ?k = (1::'a) \\<and> ?k \\<noteq> 0)\n  k' \\<noteq> 0\n  x ^ k' = (1::'a)\n\ngoal (1 subgoal):\n 1. primitive_root_unity k' x", "unfolding primitive_root_unity_def"], ["proof (prove)\nusing this:\n  ?k < k' \\<Longrightarrow> \\<not> (x ^ ?k = (1::'a) \\<and> ?k \\<noteq> 0)\n  k' \\<noteq> 0\n  x ^ k' = (1::'a)\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 0 \\<and>\n    x ^ k' = (1::'a) \\<and>\n    (\\<forall>k'a<k'.\n        k'a \\<noteq> 0 \\<longrightarrow> x ^ k'a \\<noteq> (1::'a))", "by auto"], ["proof (state)\nthis:\n  primitive_root_unity k' x\n\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "with primitive_root_unityD(3)[OF this assms]"], ["proof (chain)\npicking this:\n  k' \\<le> k\n  primitive_root_unity k' x", "show ?thesis"], ["proof (prove)\nusing this:\n  k' \\<le> k\n  primitive_root_unity k' x\n\ngoal (1 subgoal):\n 1. \\<exists>k'\\<le>k. primitive_root_unity k' x", "by auto"], ["proof (state)\nthis:\n  \\<exists>k'\\<le>k. primitive_root_unity k' x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_root_unity_dvd: fixes x :: \"complex\"\n  assumes k: \"primitive_root_unity k x\"\n  shows \"x ^ n = 1 \\<longleftrightarrow> k dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ n = 1) = (k dvd n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n\n 2. k dvd n \\<Longrightarrow> x ^ n = 1", "assume \"k dvd n\""], ["proof (state)\nthis:\n  k dvd n\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n\n 2. k dvd n \\<Longrightarrow> x ^ n = 1", "then"], ["proof (chain)\npicking this:\n  k dvd n", "obtain j where n: \"n = k * j\""], ["proof (prove)\nusing this:\n  k dvd n\n\ngoal (1 subgoal):\n 1. (\\<And>j. n = k * j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>ka. n = k * ka\n\ngoal (1 subgoal):\n 1. (\\<And>j. n = k * j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  n = k * j\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n\n 2. k dvd n \\<Longrightarrow> x ^ n = 1", "have \"x ^ n = (x ^ k) ^ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ n = (x ^ k) ^ j", "unfolding n power_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ k) ^ j = (x ^ k) ^ j", "by simp"], ["proof (state)\nthis:\n  x ^ n = (x ^ k) ^ j\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n\n 2. k dvd n \\<Longrightarrow> x ^ n = 1", "also"], ["proof (state)\nthis:\n  x ^ n = (x ^ k) ^ j\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n\n 2. k dvd n \\<Longrightarrow> x ^ n = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ k) ^ j = 1", "unfolding primitive_root_unityD[OF k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ^ j = 1", "by simp"], ["proof (state)\nthis:\n  (x ^ k) ^ j = 1\n\ngoal (2 subgoals):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n\n 2. k dvd n \\<Longrightarrow> x ^ n = 1", "finally"], ["proof (chain)\npicking this:\n  x ^ n = 1", "show \"x ^ n = 1\""], ["proof (prove)\nusing this:\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. x ^ n = 1", "."], ["proof (state)\nthis:\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n", "assume n: \"x ^ n = 1\""], ["proof (state)\nthis:\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n", "note k = primitive_root_unityD[OF k]"], ["proof (state)\nthis:\n  k \\<noteq> 0\n  x ^ k = 1\n  \\<lbrakk>?k' \\<noteq> 0; x ^ ?k' = 1\\<rbrakk>\n  \\<Longrightarrow> k \\<le> ?k'\n\ngoal (1 subgoal):\n 1. x ^ n = 1 \\<Longrightarrow> k dvd n", "show \"k dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k dvd n", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "case n0: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "from k(3)[OF n0] n"], ["proof (chain)\npicking this:\n  x ^ n = 1 \\<Longrightarrow> k \\<le> n\n  x ^ n = 1", "have nk: \"n \\<ge> k\""], ["proof (prove)\nusing this:\n  x ^ n = 1 \\<Longrightarrow> k \\<le> n\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. k \\<le> n", "by force"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "from roots_of_unity[OF k(1)] k(2)"], ["proof (chain)\npicking this:\n  (\\<lambda>i. cis (real i * 2 * pi / real k)) ` {0..<k} = {x. x ^ k = 1}\n  {x. poly (root_unity k) x = 0} = {x. x ^ k = 1}\n  card {x. x ^ k = 1} = k\n  x ^ k = 1", "obtain i :: nat where xk: \"x = cis (i * 2 * pi / k)\"\n      and ik: \"i < k\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cis (real i * 2 * pi / real k)) ` {0..<k} = {x. x ^ k = 1}\n  {x. poly (root_unity k) x = 0} = {x. x ^ k = 1}\n  card {x. x ^ k = 1} = k\n  x ^ k = 1\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = cis (real (i * 2) * pi / real k); i < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = cis (real (i * 2) * pi / real k)\n  i < k\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "from roots_of_unity[OF n0] n"], ["proof (chain)\npicking this:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n\n  x ^ n = 1", "obtain j :: nat where xn: \"x = cis (j * 2 * pi / n)\"\n      and jn: \"j < n\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cis (real i * 2 * pi / real n)) ` {0..<n} = {x. x ^ n = 1}\n  {x. poly (root_unity n) x = 0} = {x. x ^ n = 1}\n  card {x. x ^ n = 1} = n\n  x ^ n = 1\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = cis (real (j * 2) * pi / real n); j < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = cis (real (j * 2) * pi / real n)\n  j < n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "have cop: \"coprime i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime i k", "proof (rule gcd_eq_1_imp_coprime)"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd i k = 1", "from k(1)"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "have \"gcd i k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd i k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gcd i k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "from gcd_coprime_exists[OF this] this"], ["proof (chain)\npicking this:\n  \\<exists>a' b'.\n     i = a' * gcd i k \\<and> k = b' * gcd i k \\<and> coprime a' b'\n  gcd i k \\<noteq> 0", "obtain i' k' g where\n        *: \"i = i' * g\" \"k = k' * g\" \"g \\<noteq> 0\" and g: \"g = gcd i k\""], ["proof (prove)\nusing this:\n  \\<exists>a' b'.\n     i = a' * gcd i k \\<and> k = b' * gcd i k \\<and> coprime a' b'\n  gcd i k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i' g k'.\n        \\<lbrakk>i = i' * g; k = k' * g; g \\<noteq> 0; g = gcd i k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i = i' * g\n  k = k' * g\n  g \\<noteq> 0\n  g = gcd i k\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "from *(2) k(1)"], ["proof (chain)\npicking this:\n  k = k' * g\n  k \\<noteq> 0", "have k': \"k' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k = k' * g\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "have \"x = cis (i * 2 * pi / k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = cis (real (i * 2) * pi / real k)", "by fact"], ["proof (state)\nthis:\n  x = cis (real (i * 2) * pi / real k)\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "also"], ["proof (state)\nthis:\n  x = cis (real (i * 2) * pi / real k)\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "have \"i * 2 * pi / k = i' * 2 * pi / k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (i * 2) * pi / real k = real (i' * 2) * pi / real k'", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (i' * g * 2) * pi / real (k' * g) = real (i' * 2) * pi / real k'", "using *(3)"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real (i' * g * 2) * pi / real (k' * g) = real (i' * 2) * pi / real k'", "by auto"], ["proof (state)\nthis:\n  real (i * 2) * pi / real k = real (i' * 2) * pi / real k'\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "finally"], ["proof (chain)\npicking this:\n  x = cis (real (i' * 2) * pi / real k')", "have \"x ^ k' = 1\""], ["proof (prove)\nusing this:\n  x = cis (real (i' * 2) * pi / real k')\n\ngoal (1 subgoal):\n 1. x ^ k' = 1", "by (simp add: DeMoivre k')"], ["proof (state)\nthis:\n  x ^ k' = 1\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "with k(3)[OF k']"], ["proof (chain)\npicking this:\n  x ^ k' = 1 \\<Longrightarrow> k \\<le> k'\n  x ^ k' = 1", "have \"k' \\<ge> k\""], ["proof (prove)\nusing this:\n  x ^ k' = 1 \\<Longrightarrow> k \\<le> k'\n  x ^ k' = 1\n\ngoal (1 subgoal):\n 1. k \\<le> k'", "by linarith"], ["proof (state)\nthis:\n  k \\<le> k'\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "moreover"], ["proof (state)\nthis:\n  k \\<le> k'\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "with * k(1)"], ["proof (chain)\npicking this:\n  i = i' * g\n  k = k' * g\n  g \\<noteq> 0\n  k \\<noteq> 0\n  k \\<le> k'", "have \"g = 1\""], ["proof (prove)\nusing this:\n  i = i' * g\n  k = k' * g\n  g \\<noteq> 0\n  k \\<noteq> 0\n  k \\<le> k'\n\ngoal (1 subgoal):\n 1. g = 1", "by auto"], ["proof (state)\nthis:\n  g = 1\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "then"], ["proof (chain)\npicking this:\n  g = 1", "show \"gcd i k = 1\""], ["proof (prove)\nusing this:\n  g = 1\n\ngoal (1 subgoal):\n 1. gcd i k = 1", "by (simp add: g)"], ["proof (state)\nthis:\n  gcd i k = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coprime i k\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "from inj_onD[OF cis_inj_on xk[unfolded xn]] n0 k(1) ik jn"], ["proof (chain)\npicking this:\n  \\<lbrakk>real (j * 2) * pi / real n \\<in> {0..<2 * pi};\n   real (i * 2) * pi / real k \\<in> {0..<2 * pi}\\<rbrakk>\n  \\<Longrightarrow> real (j * 2) * pi / real n = real (i * 2) * pi / real k\n  n \\<noteq> 0\n  k \\<noteq> 0\n  i < k\n  j < n", "have \"j * real k = i * real n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>real (j * 2) * pi / real n \\<in> {0..<2 * pi};\n   real (i * 2) * pi / real k \\<in> {0..<2 * pi}\\<rbrakk>\n  \\<Longrightarrow> real (j * 2) * pi / real n = real (i * 2) * pi / real k\n  n \\<noteq> 0\n  k \\<noteq> 0\n  i < k\n  j < n\n\ngoal (1 subgoal):\n 1. real j * real k = real i * real n", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  real j * real k = real i * real n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "hence \"real (j * k) = real (i * n)\""], ["proof (prove)\nusing this:\n  real j * real k = real i * real n\n\ngoal (1 subgoal):\n 1. real (j * k) = real (i * n)", "by simp"], ["proof (state)\nthis:\n  real (j * k) = real (i * n)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "hence eq: \"j * k = i * n\""], ["proof (prove)\nusing this:\n  real (j * k) = real (i * n)\n\ngoal (1 subgoal):\n 1. j * k = i * n", "by linarith"], ["proof (state)\nthis:\n  j * k = i * n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> k dvd n\n 2. n \\<noteq> 0 \\<Longrightarrow> k dvd n", "with cop"], ["proof (chain)\npicking this:\n  coprime i k\n  j * k = i * n", "show \"k dvd n\""], ["proof (prove)\nusing this:\n  coprime i k\n  j * k = i * n\n\ngoal (1 subgoal):\n 1. k dvd n", "by (metis coprime_commute coprime_dvd_mult_right_iff dvd_triv_right)"], ["proof (state)\nthis:\n  k dvd n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> k dvd n", "qed auto"], ["proof (state)\nthis:\n  k dvd n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_root_unity_simple_computation:\n  \"primitive_root_unity k x  = (if k = 0 then False else\n     x ^ k = 1 \\<and> (\\<forall> i \\<in> {1 ..< k}. x ^ i \\<noteq> 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_root_unity k x =\n    (if k = 0 then False\n     else x ^ k = (1::'a) \\<and>\n          (\\<forall>i\\<in>{1..<k}. x ^ i \\<noteq> (1::'a)))", "unfolding primitive_root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<noteq> 0 \\<and>\n     x ^ k = (1::'a) \\<and>\n     (\\<forall>k'<k.\n         k' \\<noteq> 0 \\<longrightarrow> x ^ k' \\<noteq> (1::'a))) =\n    (if k = 0 then False\n     else x ^ k = (1::'a) \\<and>\n          (\\<forall>i\\<in>{1..<k}. x ^ i \\<noteq> (1::'a)))", "by auto"], ["", "lemma primitive_root_unity_explicit: fixes x :: complex\n  shows \"primitive_root_unity 1 x \\<longleftrightarrow> x = 1\"\n    \"primitive_root_unity 2 x \\<longleftrightarrow> x = -1\"\n    \"primitive_root_unity 3 x \\<longleftrightarrow> (x \\<in> {Complex (-1/2) (sqrt 3 / 2), Complex (-1/2) (- sqrt 3 / 2)})\"\n    \"primitive_root_unity 4 x \\<longleftrightarrow> (x \\<in> {\\<i>, - \\<i>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) &&&\n     primitive_root_unity 2 x = (x = - 1)) &&&\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) &&&\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "{"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "fix P :: \"nat \\<Rightarrow> bool\""], ["proof (state)\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "have *: \"{1 ..< 2 :: nat} = {1}\" \"{1 ..< 3 :: nat} = {1,2}\" \"{1 ..< 4 :: nat} = {1,2,3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..<2} = {1} &&& {1..<3} = {1, 2} &&& {1..<4} = {1, 2, 3}", "by code_simp+"], ["proof (state)\nthis:\n  {1..<2} = {1}\n  {1..<3} = {1, 2}\n  {1..<4} = {1, 2, 3}\n\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "have \"(\\<forall>i\\<in> {1 ..< 2}. P i) = P 1\" \"(\\<forall>i\\<in> {1 ..< 3}. P i) \\<longleftrightarrow> P 1 \\<and> P 2\"\n      \"(\\<forall>i\\<in> {1 ..< 4}. P i) \\<longleftrightarrow> P 1 \\<and> P 2 \\<and> P 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{1..<2}. P i) = P 1 &&&\n    (\\<forall>i\\<in>{1..<3}. P i) = (P 1 \\<and> P 2) &&&\n    (\\<forall>i\\<in>{1..<4}. P i) = (P 1 \\<and> P 2 \\<and> P 3)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{1}. P i) = P 1 &&&\n    (\\<forall>i\\<in>{1, 2}. P i) = (P 1 \\<and> P 2) &&&\n    (\\<forall>i\\<in>{1, 2, 3}. P i) = (P 1 \\<and> P 2 \\<and> P 3)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{1..<2}. P i) = P 1\n  (\\<forall>i\\<in>{1..<3}. P i) = (P 1 \\<and> P 2)\n  (\\<forall>i\\<in>{1..<4}. P i) = (P 1 \\<and> P 2 \\<and> P 3)\n\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "}"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{1..<2}. ?P2 i) = ?P2 1\n  (\\<forall>i\\<in>{1..<3}. ?P2 i) = (?P2 1 \\<and> ?P2 2)\n  (\\<forall>i\\<in>{1..<4}. ?P2 i) = (?P2 1 \\<and> ?P2 2 \\<and> ?P2 3)\n\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "note * = this"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{1..<2}. ?P2 i) = ?P2 1\n  (\\<forall>i\\<in>{1..<3}. ?P2 i) = (?P2 1 \\<and> ?P2 2)\n  (\\<forall>i\\<in>{1..<4}. ?P2 i) = (?P2 1 \\<and> ?P2 2 \\<and> ?P2 3)\n\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (primitive_root_unity 1 x = (x = 1) \\<and>\n     primitive_root_unity 2 x = (x = - 1)) \\<and>\n    primitive_root_unity 3 x =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})", "unfolding primitive_root_unity_simple_computation root_unity_explicit *"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if 1 = 0 then False\n      else x = 1 \\<and> (\\<forall>i\\<in>{1..<1}. x ^ i \\<noteq> 1)) =\n     (x = 1) \\<and>\n     (if 2 = 0 then False else x \\<in> {1, - 1} \\<and> x \\<noteq> 1) =\n     (x = - 1)) \\<and>\n    (if 3 = 0 then False\n     else x \\<in> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n                   Complex (- 1 / 2) (- sqrt 3 / 2)} \\<and>\n          x \\<noteq> 1 \\<and> x \\<notin> {1, - 1}) =\n    (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n              Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n    (if 4 = 0 then False\n     else x \\<in> {1, - 1, \\<i>, - \\<i>} \\<and>\n          x \\<noteq> 1 \\<and>\n          x \\<notin> {1, - 1} \\<and>\n          x \\<notin> {1, Complex (- 1 / 2) (sqrt 3 / 2),\n                      Complex (- 1 / 2) (- sqrt 3 / 2)}) =\n    (x \\<in> {\\<i>, - \\<i>})", "by (auto simp: complex_eq_iff)"], ["proof (state)\nthis:\n  (primitive_root_unity 1 x = (x = 1) \\<and>\n   primitive_root_unity 2 x = (x = - 1)) \\<and>\n  primitive_root_unity 3 x =\n  (x \\<in> {Complex (- 1 / 2) (sqrt 3 / 2),\n            Complex (- 1 / 2) (- sqrt 3 / 2)}) \\<and>\n  primitive_root_unity 4 x = (x \\<in> {\\<i>, - \\<i>})\n\ngoal:\nNo subgoals!", "qed"], ["", "function decompose_prod_root_unity_main ::\n  \"'a :: field poly \\<Rightarrow> nat \\<Rightarrow> nat list \\<times> 'a poly\" where\n  \"decompose_prod_root_unity_main p k = (\n    if k = 0 then ([], p) else\n   let q = root_unity k in if q dvd p then if p = 0 then ([],0) else\n     map_prod (Cons k) id (decompose_prod_root_unity_main (p div q) k) else\n     decompose_prod_root_unity_main p (k - 1))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>p k. x = (p, k) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p k pa ka.\n       (p, k) = (pa, ka) \\<Longrightarrow>\n       (if k = 0 then ([], p)\n        else let q = root_unity k\n             in if q dvd p\n                then if p = 0 then ([], 0)\n                     else map_prod ((#) k) id\n                           (decompose_prod_root_unity_main_sumC\n                             (p div q, k))\n                else decompose_prod_root_unity_main_sumC (p, k - 1)) =\n       (if ka = 0 then ([], pa)\n        else let q = root_unity ka\n             in if q dvd pa\n                then if pa = 0 then ([], 0)\n                     else map_prod ((#) ka) id\n                           (decompose_prod_root_unity_main_sumC\n                             (pa div q, ka))\n                else decompose_prod_root_unity_main_sumC (pa, ka - 1))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All decompose_prod_root_unity_main_dom", "by (relation \"measure (\\<lambda> (p,k). degree p + k)\", auto simp: degree_div_less)"], ["", "declare decompose_prod_root_unity_main.simps[simp del]"], ["", "lemma decompose_prod_root_unity_main: fixes p :: \"complex poly\"\n  assumes p: \"p = prod_root_unity ks * f\"\n  and d: \"decompose_prod_root_unity_main p k = (ks',g)\"\n  and f: \"\\<And> x. cmod x = 1 \\<Longrightarrow> poly f x \\<noteq> 0\"\n  and k: \"\\<And> k'. k' > k \\<Longrightarrow> \\<not> root_unity k' dvd p\"\nshows \"p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "using d p k"], ["proof (prove)\nusing this:\n  decompose_prod_root_unity_main p k = (ks', g)\n  p = prod_root_unity ks * f\n  k < ?k' \\<Longrightarrow> \\<not> root_unity ?k' dvd p\n\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "proof (induct p k arbitrary: ks ks' rule: decompose_prod_root_unity_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "case (1 p k ks ks')"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<noteq> 0; ?x = root_unity k; ?x dvd p; p \\<noteq> 0;\n   decompose_prod_root_unity_main (p div ?x) k = (?ks', g);\n   p div ?x = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p div ?x\\<rbrakk>\n  \\<Longrightarrow> p div ?x = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n  \\<lbrakk>k \\<noteq> 0; ?x = root_unity k; \\<not> ?x dvd p;\n   decompose_prod_root_unity_main p (k - 1) = (?ks', g);\n   p = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k - 1 < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n  \\<Longrightarrow> p = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n  decompose_prod_root_unity_main p k = (ks', g)\n  p = prod_root_unity ks * f\n  k < ?k' \\<Longrightarrow> \\<not> root_unity ?k' dvd p\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "note p = 1(4)"], ["proof (state)\nthis:\n  p = prod_root_unity ks * f\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "note k = 1(5)"], ["proof (state)\nthis:\n  k < ?k' \\<Longrightarrow> \\<not> root_unity ?k' dvd p\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "from k[of \"Suc k\"]"], ["proof (chain)\npicking this:\n  k < Suc k \\<Longrightarrow> \\<not> root_unity (Suc k) dvd p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k < Suc k \\<Longrightarrow> \\<not> root_unity (Suc k) dvd p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "hence \"p = 0 \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p = 0) = False", "by auto"], ["proof (state)\nthis:\n  (p = 0) = False\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "note d = 1(3)[unfolded decompose_prod_root_unity_main.simps[of p k] this if_False Let_def]"], ["proof (state)\nthis:\n  (if k = 0 then ([], p)\n   else if root_unity k dvd p\n        then map_prod ((#) k) id\n              (decompose_prod_root_unity_main (p div root_unity k) k)\n        else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "from p0[unfolded p]"], ["proof (chain)\npicking this:\n  prod_root_unity ks * f \\<noteq> 0", "have ks0: \"0 \\<notin> set ks\""], ["proof (prove)\nusing this:\n  prod_root_unity ks * f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set ks", "by simp"], ["proof (state)\nthis:\n  0 \\<notin> set ks\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "from f[of 1]"], ["proof (chain)\npicking this:\n  cmod 1 = 1 \\<Longrightarrow> poly f 1 \\<noteq> 0", "have f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cmod 1 = 1 \\<Longrightarrow> poly f 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "note IH = 1(1)[OF _ refl _ p0] 1(2)[OF _ refl]"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<noteq> 0; root_unity k dvd p;\n   decompose_prod_root_unity_main (p div root_unity k) k = (?ks', g);\n   p div root_unity k = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k < k' \\<Longrightarrow>\n      \\<not> root_unity k' dvd p div root_unity k\\<rbrakk>\n  \\<Longrightarrow> p div root_unity k = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n  \\<lbrakk>k \\<noteq> 0; \\<not> root_unity k dvd p;\n   decompose_prod_root_unity_main p (k - 1) = (?ks', g);\n   p = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k - 1 < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n  \\<Longrightarrow> p = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n\ngoal (1 subgoal):\n 1. \\<And>p k ks ks'.\n       \\<lbrakk>\\<And>x ks ks'.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0;\n                    decompose_prod_root_unity_main (p div x) k = (ks', g);\n                    p div x = prod_root_unity ks * f;\n                    \\<And>k'.\n                       k < k' \\<Longrightarrow>\n                       \\<not> root_unity k' dvd p div x\\<rbrakk>\n                   \\<Longrightarrow> p div x =\n                                     prod_root_unity ks' * f \\<and>\n                                     f = g \\<and> set ks = set ks';\n        \\<And>x ks ks'.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p;\n            decompose_prod_root_unity_main p (k - 1) = (ks', g);\n            p = prod_root_unity ks * f;\n            \\<And>k'.\n               k - 1 < k' \\<Longrightarrow>\n               \\<not> root_unity k' dvd p\\<rbrakk>\n           \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                             f = g \\<and> set ks = set ks';\n        decompose_prod_root_unity_main p k = (ks', g);\n        p = prod_root_unity ks * f;\n        \\<And>k'.\n           k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n       \\<Longrightarrow> p = prod_root_unity ks' * f \\<and>\n                         f = g \\<and> set ks = set ks'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "with p k[unfolded this, of \"hd ks\"] p0"], ["proof (chain)\npicking this:\n  p = prod_root_unity ks * f\n  0 < hd ks \\<Longrightarrow> \\<not> root_unity (hd ks) dvd p\n  p \\<noteq> 0\n  k = 0", "have \"ks = []\""], ["proof (prove)\nusing this:\n  p = prod_root_unity ks * f\n  0 < hd ks \\<Longrightarrow> \\<not> root_unity (hd ks) dvd p\n  p \\<noteq> 0\n  k = 0\n\ngoal (1 subgoal):\n 1. ks = []", "by (cases ks, auto simp: prod_root_unity_def)"], ["proof (state)\nthis:\n  ks = []\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "with d p True"], ["proof (chain)\npicking this:\n  (if k = 0 then ([], p)\n   else if root_unity k dvd p\n        then map_prod ((#) k) id\n              (decompose_prod_root_unity_main (p div root_unity k) k)\n        else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n  p = prod_root_unity ks * f\n  k = 0\n  ks = []", "show ?thesis"], ["proof (prove)\nusing this:\n  (if k = 0 then ([], p)\n   else if root_unity k dvd p\n        then map_prod ((#) k) id\n              (decompose_prod_root_unity_main (p div root_unity k) k)\n        else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n  p = prod_root_unity ks * f\n  k = 0\n  ks = []\n\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "by (auto simp: prod_root_unity_def)"], ["proof (state)\nthis:\n  p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "case k0: False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "note IH = IH[OF k0]"], ["proof (state)\nthis:\n  \\<lbrakk>root_unity k dvd p;\n   decompose_prod_root_unity_main (p div root_unity k) k = (?ks', g);\n   p div root_unity k = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k < k' \\<Longrightarrow>\n      \\<not> root_unity k' dvd p div root_unity k\\<rbrakk>\n  \\<Longrightarrow> p div root_unity k = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n  \\<lbrakk>\\<not> root_unity k dvd p;\n   decompose_prod_root_unity_main p (k - 1) = (?ks', g);\n   p = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k - 1 < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\\<rbrakk>\n  \\<Longrightarrow> p = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from k0"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "have \"k = 0 \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (k = 0) = False", "by auto"], ["proof (state)\nthis:\n  (k = 0) = False\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "note d = d[unfolded this if_False]"], ["proof (state)\nthis:\n  (if root_unity k dvd p\n   then map_prod ((#) k) id\n         (decompose_prod_root_unity_main (p div root_unity k) k)\n   else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "let ?u = \"root_unity k :: complex poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "proof (cases \"?u dvd p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "case True"], ["proof (state)\nthis:\n  root_unity k dvd p\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "note IH = IH(1)[OF True]"], ["proof (state)\nthis:\n  \\<lbrakk>decompose_prod_root_unity_main (p div root_unity k) k =\n           (?ks', g);\n   p div root_unity k = prod_root_unity ?ks * f;\n   \\<And>k'.\n      k < k' \\<Longrightarrow>\n      \\<not> root_unity k' dvd p div root_unity k\\<rbrakk>\n  \\<Longrightarrow> p div root_unity k = prod_root_unity ?ks' * f \\<and>\n                    f = g \\<and> set ?ks = set ?ks'\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "let ?call = \"decompose_prod_root_unity_main (p div ?u) k\""], ["proof (state)\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from True d"], ["proof (chain)\npicking this:\n  root_unity k dvd p\n  (if root_unity k dvd p\n   then map_prod ((#) k) id\n         (decompose_prod_root_unity_main (p div root_unity k) k)\n   else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)", "obtain Ks where rec: \"?call = (Ks,g)\" and ks': \"ks' = (k # Ks)\""], ["proof (prove)\nusing this:\n  root_unity k dvd p\n  (if root_unity k dvd p\n   then map_prod ((#) k) id\n         (decompose_prod_root_unity_main (p div root_unity k) k)\n   else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n\ngoal (1 subgoal):\n 1. (\\<And>Ks.\n        \\<lbrakk>decompose_prod_root_unity_main (p div root_unity k) k =\n                 (Ks, g);\n         ks' = k # Ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ?call, auto)"], ["proof (state)\nthis:\n  decompose_prod_root_unity_main (p div root_unity k) k = (Ks, g)\n  ks' = k # Ks\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from True"], ["proof (chain)\npicking this:\n  root_unity k dvd p", "have \"?u dvd p \\<longleftrightarrow> True\""], ["proof (prove)\nusing this:\n  root_unity k dvd p\n\ngoal (1 subgoal):\n 1. (root_unity k dvd p) = True", "by simp"], ["proof (state)\nthis:\n  (root_unity k dvd p) = True\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "note d = d[unfolded this if_True rec]"], ["proof (state)\nthis:\n  map_prod ((#) k) id (Ks, g) = (ks', g)\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "let ?x = \"cis (2 * pi / k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "have rt: \"poly ?u ?x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (root_unity k) (cis (2 * pi / real k)) = 0", "unfolding poly_root_unity"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (2 * pi / real k) ^ k = 1", "using cis_times_2pi[of 1]"], ["proof (prove)\nusing this:\n  cis (real 1 * 2 * pi) = 1\n\ngoal (1 subgoal):\n 1. cis (2 * pi / real k) ^ k = 1", "by (simp add: DeMoivre)"], ["proof (state)\nthis:\n  poly (root_unity k) (cis (2 * pi / real k)) = 0\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "with True"], ["proof (chain)\npicking this:\n  root_unity k dvd p\n  poly (root_unity k) (cis (2 * pi / real k)) = 0", "have \"poly p ?x = 0\""], ["proof (prove)\nusing this:\n  root_unity k dvd p\n  poly (root_unity k) (cis (2 * pi / real k)) = 0\n\ngoal (1 subgoal):\n 1. poly p (cis (2 * pi / real k)) = 0", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. p = root_unity k * k\n  poly (root_unity k) (cis (2 * pi / real k)) = 0\n\ngoal (1 subgoal):\n 1. poly p (cis (2 * pi / real k)) = 0", "by auto"], ["proof (state)\nthis:\n  poly p (cis (2 * pi / real k)) = 0\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from this[unfolded p] f[of ?x] rt"], ["proof (chain)\npicking this:\n  poly (prod_root_unity ks * f) (cis (2 * pi / real k)) = 0\n  cmod (cis (2 * pi / real k)) = 1 \\<Longrightarrow>\n  poly f (cis (2 * pi / real k)) \\<noteq> 0\n  poly (root_unity k) (cis (2 * pi / real k)) = 0", "have \"poly (prod_root_unity ks) ?x = 0\""], ["proof (prove)\nusing this:\n  poly (prod_root_unity ks * f) (cis (2 * pi / real k)) = 0\n  cmod (cis (2 * pi / real k)) = 1 \\<Longrightarrow>\n  poly f (cis (2 * pi / real k)) \\<noteq> 0\n  poly (root_unity k) (cis (2 * pi / real k)) = 0\n\ngoal (1 subgoal):\n 1. poly (prod_root_unity ks) (cis (2 * pi / real k)) = 0", "unfolding poly_root_unity"], ["proof (prove)\nusing this:\n  poly (prod_root_unity ks * f) (cis (2 * pi / real k)) = 0\n  cmod (cis (2 * pi / real k)) = 1 \\<Longrightarrow>\n  poly f (cis (2 * pi / real k)) \\<noteq> 0\n  cis (2 * pi / real k) ^ k = 1\n\ngoal (1 subgoal):\n 1. poly (prod_root_unity ks) (cis (2 * pi / real k)) = 0", "by auto"], ["proof (state)\nthis:\n  poly (prod_root_unity ks) (cis (2 * pi / real k)) = 0\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from this[unfolded poly_prod_root_unity] ks0"], ["proof (chain)\npicking this:\n  \\<exists>k\\<in>set ks. cis (2 * pi / real k) ^ k = 1\n  0 \\<notin> set ks", "obtain k' where k': \"k' \\<in> set ks\"\n        and rt: \"?x ^ k' = 1\" and k'0: \"k' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>k\\<in>set ks. cis (2 * pi / real k) ^ k = 1\n  0 \\<notin> set ks\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>k' \\<in> set ks; cis (2 * pi / real k) ^ k' = 1;\n         k' \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k' \\<in> set ks\n  cis (2 * pi / real k) ^ k' = 1\n  k' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "let ?u' = \"root_unity k' :: complex poly\""], ["proof (state)\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from k' rt k'0"], ["proof (chain)\npicking this:\n  k' \\<in> set ks\n  cis (2 * pi / real k) ^ k' = 1\n  k' \\<noteq> 0", "have rtk': \"poly ?u' ?x = 0\""], ["proof (prove)\nusing this:\n  k' \\<in> set ks\n  cis (2 * pi / real k) ^ k' = 1\n  k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (root_unity k') (cis (2 * pi / real k)) = 0", "unfolding poly_root_unity"], ["proof (prove)\nusing this:\n  k' \\<in> set ks\n  cis (2 * pi / real k) ^ k' = 1\n  k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cis (2 * pi / real k) ^ k' = 1", "by auto"], ["proof (state)\nthis:\n  poly (root_unity k') (cis (2 * pi / real k)) = 0\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "{"], ["proof (state)\nthis:\n  poly (root_unity k') (cis (2 * pi / real k)) = 0\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "let ?phi = \" k' * (2 * pi / k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "assume \"k' < k\""], ["proof (state)\nthis:\n  k' < k\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "hence \"0 < ?phi\" \"?phi < 2 * pi\""], ["proof (prove)\nusing this:\n  k' < k\n\ngoal (1 subgoal):\n 1. 0 < real k' * (2 * pi / real k) &&& real k' * (2 * pi / real k) < 2 * pi", "using k0 k'0"], ["proof (prove)\nusing this:\n  k' < k\n  k \\<noteq> 0\n  k' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < real k' * (2 * pi / real k) &&& real k' * (2 * pi / real k) < 2 * pi", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  0 < real k' * (2 * pi / real k)\n  real k' * (2 * pi / real k) < 2 * pi\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from cis_plus_2pi_neq_1[OF this] rtk'"], ["proof (chain)\npicking this:\n  cis (real k' * (2 * pi / real k)) \\<noteq> 1\n  poly (root_unity k') (cis (2 * pi / real k)) = 0", "have False"], ["proof (prove)\nusing this:\n  cis (real k' * (2 * pi / real k)) \\<noteq> 1\n  poly (root_unity k') (cis (2 * pi / real k)) = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding poly_root_unity DeMoivre"], ["proof (prove)\nusing this:\n  cis (real k' * (2 * pi / real k)) \\<noteq> 1\n  cis (real k' * (2 * pi / real k)) = 1\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "}"], ["proof (state)\nthis:\n  k' < k \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "hence kk': \"k \\<le> k'\""], ["proof (prove)\nusing this:\n  k' < k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. k \\<le> k'", "by presburger"], ["proof (state)\nthis:\n  k \\<le> k'\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "{"], ["proof (state)\nthis:\n  k \\<le> k'\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "assume \"k' > k\""], ["proof (state)\nthis:\n  k < k'\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from k[OF this, unfolded p]"], ["proof (chain)\npicking this:\n  \\<not> root_unity k' dvd prod_root_unity ks * f", "have \"\\<not> ?u' dvd prod_root_unity ks\""], ["proof (prove)\nusing this:\n  \\<not> root_unity k' dvd prod_root_unity ks * f\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k' dvd prod_root_unity ks", "using dvd_mult2"], ["proof (prove)\nusing this:\n  \\<not> root_unity k' dvd prod_root_unity ks * f\n  ?a dvd ?b \\<Longrightarrow> ?a dvd ?b * ?c\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k' dvd prod_root_unity ks", "by auto"], ["proof (state)\nthis:\n  \\<not> root_unity k' dvd prod_root_unity ks\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "with k'"], ["proof (chain)\npicking this:\n  k' \\<in> set ks\n  \\<not> root_unity k' dvd prod_root_unity ks", "have False"], ["proof (prove)\nusing this:\n  k' \\<in> set ks\n  \\<not> root_unity k' dvd prod_root_unity ks\n\ngoal (1 subgoal):\n 1. False", "unfolding prod_root_unity_def"], ["proof (prove)\nusing this:\n  k' \\<in> set ks\n  \\<not> root_unity k' dvd prod_list (map root_unity ks)\n\ngoal (1 subgoal):\n 1. False", "using prod_list_dvd[of ?u' \"map root_unity ks\"]"], ["proof (prove)\nusing this:\n  k' \\<in> set ks\n  \\<not> root_unity k' dvd prod_list (map root_unity ks)\n  root_unity k' \\<in> set (map root_unity ks) \\<Longrightarrow>\n  root_unity k' dvd prod_list (map root_unity ks)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "}"], ["proof (state)\nthis:\n  k < k' \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "with kk'"], ["proof (chain)\npicking this:\n  k \\<le> k'\n  k < k' \\<Longrightarrow> False", "have kk': \"k' = k\""], ["proof (prove)\nusing this:\n  k \\<le> k'\n  k < k' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. k' = k", "by presburger"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "with k'"], ["proof (chain)\npicking this:\n  k' \\<in> set ks\n  k' = k", "have \"k \\<in> set ks\""], ["proof (prove)\nusing this:\n  k' \\<in> set ks\n  k' = k\n\ngoal (1 subgoal):\n 1. k \\<in> set ks", "by auto"], ["proof (state)\nthis:\n  k \\<in> set ks\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. ks = ys @ k # zs", "obtain ks1 ks2 where ks: \"ks = ks1 @ k # ks2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. ks = ys @ k # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ks1 ks2.\n        ks = ks1 @ k # ks2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ks = ks1 @ k # ks2\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "hence \"p div ?u = (?u * (prod_root_unity (ks1 @ ks2) * f)) div ?u\""], ["proof (prove)\nusing this:\n  ks = ks1 @ k # ks2\n\ngoal (1 subgoal):\n 1. p div root_unity k =\n    root_unity k * (prod_root_unity (ks1 @ ks2) * f) div root_unity k", "by (simp add: ac_simps p prod_root_unity_def)"], ["proof (state)\nthis:\n  p div root_unity k =\n  root_unity k * (prod_root_unity (ks1 @ ks2) * f) div root_unity k\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "also"], ["proof (state)\nthis:\n  p div root_unity k =\n  root_unity k * (prod_root_unity (ks1 @ ks2) * f) div root_unity k\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "have \"\\<dots> = prod_root_unity (ks1 @ ks2) * f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity k * (prod_root_unity (ks1 @ ks2) * f) div root_unity k =\n    prod_root_unity (ks1 @ ks2) * f", "by (rule nonzero_mult_div_cancel_left, insert k0, auto)"], ["proof (state)\nthis:\n  root_unity k * (prod_root_unity (ks1 @ ks2) * f) div root_unity k =\n  prod_root_unity (ks1 @ ks2) * f\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "finally"], ["proof (chain)\npicking this:\n  p div root_unity k = prod_root_unity (ks1 @ ks2) * f", "have id: \"p div ?u = prod_root_unity (ks1 @ ks2) * f\""], ["proof (prove)\nusing this:\n  p div root_unity k = prod_root_unity (ks1 @ ks2) * f\n\ngoal (1 subgoal):\n 1. p div root_unity k = prod_root_unity (ks1 @ ks2) * f", "."], ["proof (state)\nthis:\n  p div root_unity k = prod_root_unity (ks1 @ ks2) * f\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from d"], ["proof (chain)\npicking this:\n  map_prod ((#) k) id (Ks, g) = (ks', g)", "have ks': \"ks' = k # Ks\""], ["proof (prove)\nusing this:\n  map_prod ((#) k) id (Ks, g) = (ks', g)\n\ngoal (1 subgoal):\n 1. ks' = k # Ks", "by auto"], ["proof (state)\nthis:\n  ks' = k # Ks\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "have \"k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p div ?u\" for k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p div root_unity k", "using k[of k'] True"], ["proof (prove)\nusing this:\n  k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\n  root_unity k dvd p\n\ngoal (1 subgoal):\n 1. k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p div root_unity k", "by (metis dvd_div_mult_self dvd_mult2)"], ["proof (state)\nthis:\n  k < ?k' \\<Longrightarrow> \\<not> root_unity ?k' dvd p div root_unity k\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from IH[OF rec id this]"], ["proof (chain)\npicking this:\n  (\\<And>k'. k < k' \\<Longrightarrow> k < k') \\<Longrightarrow>\n  p div root_unity k = prod_root_unity Ks * f \\<and>\n  f = g \\<and> set (ks1 @ ks2) = set Ks", "have id: \"p div root_unity k = prod_root_unity Ks * f\" and\n        *: \"f = g \\<and> set (ks1 @ ks2) = set Ks\""], ["proof (prove)\nusing this:\n  (\\<And>k'. k < k' \\<Longrightarrow> k < k') \\<Longrightarrow>\n  p div root_unity k = prod_root_unity Ks * f \\<and>\n  f = g \\<and> set (ks1 @ ks2) = set Ks\n\ngoal (1 subgoal):\n 1. p div root_unity k = prod_root_unity Ks * f &&&\n    f = g \\<and> set (ks1 @ ks2) = set Ks", "by auto"], ["proof (state)\nthis:\n  p div root_unity k = prod_root_unity Ks * f\n  f = g \\<and> set (ks1 @ ks2) = set Ks\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from arg_cong[OF id, of \"\\<lambda> x. x * ?u\"] True"], ["proof (chain)\npicking this:\n  p div root_unity k * root_unity k = prod_root_unity Ks * f * root_unity k\n  root_unity k dvd p", "have \"p = prod_root_unity Ks * f * root_unity k\""], ["proof (prove)\nusing this:\n  p div root_unity k * root_unity k = prod_root_unity Ks * f * root_unity k\n  root_unity k dvd p\n\ngoal (1 subgoal):\n 1. p = prod_root_unity Ks * f * root_unity k", "by auto"], ["proof (state)\nthis:\n  p = prod_root_unity Ks * f * root_unity k\n\ngoal (2 subgoals):\n 1. root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n 2. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = prod_root_unity Ks * f * root_unity k\n\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "using *"], ["proof (prove)\nusing this:\n  p = prod_root_unity Ks * f * root_unity k\n  f = g \\<and> set (ks1 @ ks2) = set Ks\n\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "unfolding ks ks'"], ["proof (prove)\nusing this:\n  p = prod_root_unity Ks * f * root_unity k\n  f = g \\<and> set (ks1 @ ks2) = set Ks\n\ngoal (1 subgoal):\n 1. p = prod_root_unity (k # Ks) * f \\<and>\n    f = g \\<and> set (ks1 @ k # ks2) = set (k # Ks)", "by (auto simp: prod_root_unity_def)"], ["proof (state)\nthis:\n  p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "case False"], ["proof (state)\nthis:\n  \\<not> root_unity k dvd p\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "from d False"], ["proof (chain)\npicking this:\n  (if root_unity k dvd p\n   then map_prod ((#) k) id\n         (decompose_prod_root_unity_main (p div root_unity k) k)\n   else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n  \\<not> root_unity k dvd p", "have \"decompose_prod_root_unity_main p (k - 1) = (ks',g)\""], ["proof (prove)\nusing this:\n  (if root_unity k dvd p\n   then map_prod ((#) k) id\n         (decompose_prod_root_unity_main (p div root_unity k) k)\n   else decompose_prod_root_unity_main p (k - 1)) =\n  (ks', g)\n  \\<not> root_unity k dvd p\n\ngoal (1 subgoal):\n 1. decompose_prod_root_unity_main p (k - 1) = (ks', g)", "by auto"], ["proof (state)\nthis:\n  decompose_prod_root_unity_main p (k - 1) = (ks', g)\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "note IH = IH(2)[OF False this p]"], ["proof (state)\nthis:\n  (\\<And>k'.\n      k - 1 < k' \\<Longrightarrow>\n      \\<not> root_unity k' dvd p) \\<Longrightarrow>\n  p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "have k: \"k - 1 < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\" for k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. k - 1 < k' \\<Longrightarrow> \\<not> root_unity k' dvd p", "using False k[of k'] k0"], ["proof (prove)\nusing this:\n  \\<not> root_unity k dvd p\n  k < k' \\<Longrightarrow> \\<not> root_unity k' dvd p\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k - 1 < k' \\<Longrightarrow> \\<not> root_unity k' dvd p", "by (cases \"k' = k\", auto)"], ["proof (state)\nthis:\n  k - 1 < ?k' \\<Longrightarrow> \\<not> root_unity ?k' dvd p\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p \\<Longrightarrow>\n    p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "by (rule IH, insert False k, auto)"], ["proof (state)\nthis:\n  p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"decompose_prod_root_unity p = decompose_prod_root_unity_main p (degree p)\""], ["", "lemma decompose_prod_root_unity: fixes p :: \"complex poly\"\n  assumes p: \"p = prod_root_unity ks * f\"\n  and d: \"decompose_prod_root_unity p = (ks',g)\"\n  and f: \"\\<And> x. cmod x = 1 \\<Longrightarrow> poly f x \\<noteq> 0\"\n  and p0: \"p \\<noteq> 0\"\nshows \"p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = prod_root_unity ks' * f \\<and> f = g \\<and> set ks = set ks'", "proof (rule decompose_prod_root_unity_main[OF p d[unfolded decompose_prod_root_unity_def] f])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1\n 2. \\<And>k'. degree p < k' \\<Longrightarrow> \\<not> root_unity k' dvd p", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1\n 2. \\<And>k'. degree p < k' \\<Longrightarrow> \\<not> root_unity k' dvd p", "assume deg: \"degree p < k\""], ["proof (state)\nthis:\n  degree p < k\n\ngoal (2 subgoals):\n 1. \\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1\n 2. \\<And>k'. degree p < k' \\<Longrightarrow> \\<not> root_unity k' dvd p", "hence \"degree p < degree (root_unity k)\""], ["proof (prove)\nusing this:\n  degree p < k\n\ngoal (1 subgoal):\n 1. degree p < degree (root_unity k)", "by simp"], ["proof (state)\nthis:\n  degree p < degree (root_unity k)\n\ngoal (2 subgoals):\n 1. \\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1\n 2. \\<And>k'. degree p < k' \\<Longrightarrow> \\<not> root_unity k' dvd p", "with p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  degree p < degree (root_unity k)", "show \"\\<not> root_unity k dvd p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree p < degree (root_unity k)\n\ngoal (1 subgoal):\n 1. \\<not> root_unity k dvd p", "by (simp add: poly_divides_conv0)"], ["proof (state)\nthis:\n  \\<not> root_unity k dvd p\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod x = 1 \\<Longrightarrow> cmod x = 1", "qed"], ["", "lemma (in comm_ring_hom) hom_root_unity: \"map_poly hom (root_unity n) = root_unity n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (root_unity n) = root_unity n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (root_unity n) = root_unity n", "interpret p: map_poly_comm_ring_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (root_unity n) = root_unity n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (root_unity n) = root_unity n", "unfolding root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (monom (1::'a) n - 1) = monom (1::'b) n - 1", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  map_poly hom (root_unity n) = root_unity n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in idom_hom) hom_prod_root_unity: \"map_poly hom (prod_root_unity n) = prod_root_unity n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (prod_root_unity n) = prod_root_unity n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (prod_root_unity n) = prod_root_unity n", "interpret p: map_poly_comm_ring_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (prod_root_unity n) = prod_root_unity n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (prod_root_unity n) = prod_root_unity n", "unfolding prod_root_unity_def p.hom_prod_list map_map o_def hom_root_unity"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map root_unity n) = prod_list (map root_unity n)", ".."], ["proof (state)\nthis:\n  map_poly hom (prod_root_unity n) = prod_root_unity n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in field_hom) hom_decompose_prod_root_unity_main:\n  \"decompose_prod_root_unity_main (map_poly hom p) k = map_prod id (map_poly hom)\n    (decompose_prod_root_unity_main p k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_prod_root_unity_main (map_poly hom p) k =\n    map_prod id (map_poly hom) (decompose_prod_root_unity_main p k)", "proof (induct p k rule: decompose_prod_root_unity_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "case (1 p k)"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<noteq> 0; ?x = root_unity k; ?x dvd p; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom (p div ?x))\n                     k =\n                    map_prod id (map_poly hom)\n                     (decompose_prod_root_unity_main (p div ?x) k)\n  \\<lbrakk>k \\<noteq> 0; ?x = root_unity k; \\<not> ?x dvd p\\<rbrakk>\n  \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                     (k - 1) =\n                    map_prod id (map_poly hom)\n                     (decompose_prod_root_unity_main p (k - 1))\n\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "let ?h = \"map_poly hom\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "let ?p = \"?h p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "let ?u = \"root_unity k :: 'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "let ?u' = \"root_unity k :: 'b poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "interpret p: map_poly_inj_idom_divide_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_divide_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "have u': \"?u' = ?h ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity k = map_poly hom (root_unity k)", "unfolding hom_root_unity"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_unity k = root_unity k", ".."], ["proof (state)\nthis:\n  root_unity k = map_poly hom (root_unity k)\n\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "note simp = decompose_prod_root_unity_main.simps"], ["proof (state)\nthis:\n  decompose_prod_root_unity_main ?p ?k =\n  (if ?k = 0 then ([], ?p)\n   else let q = root_unity ?k\n        in if q dvd ?p\n           then if ?p = 0 then ([], 0)\n                else map_prod ((#) ?k) id\n                      (decompose_prod_root_unity_main (?p div q) ?k)\n           else decompose_prod_root_unity_main ?p (?k - 1))\n\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "let ?rec1 = \"decompose_prod_root_unity_main (p div ?u) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "have 0: \"?p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_poly hom p = 0) = (p = 0)", "by simp"], ["proof (state)\nthis:\n  (map_poly hom p = 0) = (p = 0)\n\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>k \\<noteq> 0; x = root_unity k; x dvd p;\n                    p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> decompose_prod_root_unity_main\n(map_poly hom (p div x)) k =\n                                     map_prod id (map_poly hom)\n(decompose_prod_root_unity_main (p div x) k);\n        \\<And>x.\n           \\<lbrakk>k \\<noteq> 0; x = root_unity k; \\<not> x dvd p\\<rbrakk>\n           \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p)\n                              (k - 1) =\n                             map_prod id (map_poly hom)\n                              (decompose_prod_root_unity_main p\n                                (k - 1))\\<rbrakk>\n       \\<Longrightarrow> decompose_prod_root_unity_main (map_poly hom p) k =\n                         map_prod id (map_poly hom)\n                          (decompose_prod_root_unity_main p k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_prod_root_unity_main (map_poly hom p) k =\n    map_prod id (map_poly hom) (decompose_prod_root_unity_main p k)", "unfolding simp[of ?p k] simp[of p k] if_distrib[of \"map_prod id ?h\"] Let_def u'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = 0 then ([], map_poly hom p)\n     else if map_poly hom (root_unity k) dvd map_poly hom p\n          then if map_poly hom p = 0 then ([], 0)\n               else map_prod ((#) k) id\n                     (decompose_prod_root_unity_main\n                       (map_poly hom p div map_poly hom (root_unity k)) k)\n          else decompose_prod_root_unity_main (map_poly hom p) (k - 1)) =\n    (if k = 0 then map_prod id (map_poly hom) ([], p)\n     else if root_unity k dvd p\n          then if p = 0 then map_prod id (map_poly hom) ([], 0)\n               else map_prod id (map_poly hom)\n                     (map_prod ((#) k) id\n                       (decompose_prod_root_unity_main (p div root_unity k)\n                         k))\n          else map_prod id (map_poly hom)\n                (decompose_prod_root_unity_main p (k - 1)))", "unfolding 0 p.hom_div[symmetric] p.hom_dvd_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = 0 then ([], map_poly hom p)\n     else if root_unity k dvd p\n          then if p = 0 then ([], 0)\n               else map_prod ((#) k) id\n                     (decompose_prod_root_unity_main\n                       (map_poly hom (p div root_unity k)) k)\n          else decompose_prod_root_unity_main (map_poly hom p) (k - 1)) =\n    (if k = 0 then map_prod id (map_poly hom) ([], p)\n     else if root_unity k dvd p\n          then if p = 0 then map_prod id (map_poly hom) ([], 0)\n               else map_prod id (map_poly hom)\n                     (map_prod ((#) k) id\n                       (decompose_prod_root_unity_main (p div root_unity k)\n                         k))\n          else map_prod id (map_poly hom)\n                (decompose_prod_root_unity_main p (k - 1)))", "by (rule if_cong[OF refl], force, rule if_cong[OF refl if_cong[OF refl]], force,\n     (subst 1(1), auto, cases ?rec1, auto)[1],\n     (subst 1(2), auto))"], ["proof (state)\nthis:\n  decompose_prod_root_unity_main (map_poly hom p) k =\n  map_prod id (map_poly hom) (decompose_prod_root_unity_main p k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in field_hom) hom_decompose_prod_root_unity:\n  \"decompose_prod_root_unity (map_poly hom p) = map_prod id (map_poly hom)\n    (decompose_prod_root_unity p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_prod_root_unity (map_poly hom p) =\n    map_prod id (map_poly hom) (decompose_prod_root_unity p)", "unfolding decompose_prod_root_unity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_prod_root_unity_main (map_poly hom p)\n     (degree (map_poly hom p)) =\n    map_prod id (map_poly hom) (decompose_prod_root_unity_main p (degree p))", "by (subst hom_decompose_prod_root_unity_main, simp)"], ["", "end"]]}