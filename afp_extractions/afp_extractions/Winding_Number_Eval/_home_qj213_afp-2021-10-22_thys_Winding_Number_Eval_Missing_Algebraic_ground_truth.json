{"file_name": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval/Missing_Algebraic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval", "problem_names": ["lemma poly_holomorphic_on[simp]:\n  \"(poly p) holomorphic_on s\"", "lemma order_zorder:\n  fixes p::\"complex poly\" and z::complex\n  assumes \"p\\<noteq>0\"\n  shows \"order z p = nat (zorder (poly p) z)\"", "lemma pcompose_pCons_0:\"pcompose p [:a:] = [:poly p a:]\"", "lemma pcompose_coeff_0:\n  \"coeff (pcompose p q) 0 = poly p (coeff q 0)\"", "lemma poly_field_differentiable_at[simp]:\n  \"poly p field_differentiable (at x within s)\"", "lemma deriv_pderiv:\n  \"deriv (poly p) = poly (pderiv p)\"", "lemma lead_coeff_map_poly_nz:\n  assumes \"f (lead_coeff p) \\<noteq>0\" \"f 0=0\"\n  shows \"lead_coeff (map_poly f p) = f (lead_coeff p) \"", "lemma filterlim_poly_at_infinity:\n  fixes p::\"'a::real_normed_field poly\"\n  assumes \"degree p>0\"\n  shows \"filterlim (poly p) at_infinity at_infinity\"", "lemma poly_divide_tendsto_aux:\n  fixes p::\"'a::real_normed_field poly\"\n  shows \"((\\<lambda>x. poly p x/x^(degree p)) \\<longlongrightarrow> lead_coeff p) at_infinity\"", "lemma filterlim_power_at_infinity:\n  assumes \"n\\<noteq>0\"\n  shows \"filterlim (\\<lambda>x::'a::real_normed_field. x^n) at_infinity at_infinity\"", "lemma poly_divide_tendsto_0_at_infinity: \n  fixes p::\"'a::real_normed_field poly\"\n  assumes \"degree p > degree q\" \n  shows \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0 ) at_infinity\"", "lemma lead_coeff_list_def:\n  \"lead_coeff p= (if coeffs p=[] then 0 else last (coeffs p))\"", "lemma poly_linepath_comp: \n  fixes a::\"'a::{real_normed_vector,comm_semiring_0,real_algebra_1}\"\n  shows \"poly p o (linepath a b) = poly (p \\<circ>\\<^sub>p [:a, b-a:]) o of_real\"", "lemma poly_eventually_not_zero:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"eventually (\\<lambda>x. poly p x\\<noteq>0) at_infinity\"", "lemma degree_div_less:\n  fixes x y::\"'a::field poly\"\n  assumes \"degree x\\<noteq>0\" \"degree y\\<noteq>0\"\n  shows \"degree (x div y) < degree x\"", "lemma map_poly_degree_eq:\n  assumes \"f (lead_coeff p) \\<noteq>0\"\n  shows \"degree (map_poly f p) = degree p\"", "lemma map_poly_degree_less:\n  assumes \"f (lead_coeff p) =0\" \"degree p\\<noteq>0\"\n  shows \"degree (map_poly f p) < degree p\"", "lemma map_poly_degree_leq[simp]:\n  shows \"degree (map_poly f p) \\<le> degree p\"", "lemma argument_principle_poly:\n  assumes \"p\\<noteq>0\" and valid:\"valid_path g\" and loop: \"pathfinish g = pathstart g\" \n    and no_proots:\"path_image g \\<subseteq> - proots p\"  \n  shows \"contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) = 2 * of_real pi * \\<i> * \n            (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\""], "translations": [["", "lemma poly_holomorphic_on[simp]:\n  \"(poly p) holomorphic_on s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p holomorphic_on s", "apply (rule holomorphic_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> s \\<Longrightarrow> poly p field_differentiable at x within s", "apply (unfold field_differentiable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> s \\<Longrightarrow>\n       \\<exists>f'. (poly p has_field_derivative f') (at x within s)", "apply (rule_tac x=\"poly (pderiv p) x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> s \\<Longrightarrow>\n       (poly p has_field_derivative poly (pderiv p) x) (at x within s)", "by (simp add:has_field_derivative_at_within)"], ["", "lemma order_zorder:\n  fixes p::\"complex poly\" and z::complex\n  assumes \"p\\<noteq>0\"\n  shows \"order z p = nat (zorder (poly p) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "define n where \"n=nat (zorder (poly p) z)\""], ["proof (state)\nthis:\n  n = nat (zorder (poly p) z)\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "define h where \"h=zor_poly (poly p) z\""], ["proof (state)\nthis:\n  h = zor_poly (poly p) z\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "have \"\\<exists>w. poly p w \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. poly p w \\<noteq> 0", "using assms poly_all_0_iff_0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (\\<forall>x. poly ?p x = (0::?'a)) = (?p = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>w. poly p w \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. poly p w \\<noteq> 0", "obtain r where \"0 < r\" \"cball z r \\<subseteq> UNIV\" and \n      h_holo: \"h holomorphic_on cball z r\" and\n      poly_prod:\"(\\<forall>w\\<in>cball z r. poly p w = h w * (w - z) ^ n \\<and> h w \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  \\<exists>w. poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; cball z r \\<subseteq> UNIV;\n         h holomorphic_on cball z r;\n         \\<forall>w\\<in>cball z r.\n            poly p w = h w * (w - z) ^ n \\<and> h w \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using zorder_exist_zero[of \"poly p\" UNIV z,folded h_def] poly_holomorphic_on"], ["proof (prove)\nusing this:\n  \\<exists>w. poly p w \\<noteq> 0\n  \\<lbrakk>poly p holomorphic_on UNIV; open UNIV; connected UNIV;\n   z \\<in> UNIV; \\<exists>w\\<in>UNIV. poly p w \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (if poly p z = 0 then 0 < zorder (poly p) z\n                     else zorder (poly p) z = 0) \\<and>\n                    (\\<exists>r>0.\n                        cball z r \\<subseteq> UNIV \\<and>\n                        h holomorphic_on cball z r \\<and>\n                        (\\<forall>w\\<in>cball z r.\n                            poly p w =\n                            h w * (w - z) ^ nat (zorder (poly p) z) \\<and>\n                            h w \\<noteq> 0))\n  poly ?p holomorphic_on ?s\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; cball z r \\<subseteq> UNIV;\n         h holomorphic_on cball z r;\n         \\<forall>w\\<in>cball z r.\n            poly p w = h w * (w - z) ^ n \\<and> h w \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding n_def"], ["proof (prove)\nusing this:\n  \\<exists>w. poly p w \\<noteq> 0\n  \\<lbrakk>poly p holomorphic_on UNIV; open UNIV; connected UNIV;\n   z \\<in> UNIV; \\<exists>w\\<in>UNIV. poly p w \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (if poly p z = 0 then 0 < zorder (poly p) z\n                     else zorder (poly p) z = 0) \\<and>\n                    (\\<exists>r>0.\n                        cball z r \\<subseteq> UNIV \\<and>\n                        h holomorphic_on cball z r \\<and>\n                        (\\<forall>w\\<in>cball z r.\n                            poly p w =\n                            h w * (w - z) ^ nat (zorder (poly p) z) \\<and>\n                            h w \\<noteq> 0))\n  poly ?p holomorphic_on ?s\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; cball z r \\<subseteq> UNIV;\n         h holomorphic_on cball z r;\n         \\<forall>w\\<in>cball z r.\n            poly p w = h w * (w - z) ^ nat (zorder (poly p) z) \\<and>\n            h w \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < r\n  cball z r \\<subseteq> UNIV\n  h holomorphic_on cball z r\n  \\<forall>w\\<in>cball z r.\n     poly p w = h w * (w - z) ^ n \\<and> h w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "then"], ["proof (chain)\npicking this:\n  0 < r\n  cball z r \\<subseteq> UNIV\n  h holomorphic_on cball z r\n  \\<forall>w\\<in>cball z r.\n     poly p w = h w * (w - z) ^ n \\<and> h w \\<noteq> 0", "have \"h holomorphic_on ball z r\"\n    and \"(\\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n)\" \n    and \"h z\\<noteq>0\""], ["proof (prove)\nusing this:\n  0 < r\n  cball z r \\<subseteq> UNIV\n  h holomorphic_on cball z r\n  \\<forall>w\\<in>cball z r.\n     poly p w = h w * (w - z) ^ n \\<and> h w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h holomorphic_on ball z r &&&\n    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n &&& h z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n\n  h z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "then"], ["proof (chain)\npicking this:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n\n  h z \\<noteq> 0", "have \"order z p = n\""], ["proof (prove)\nusing this:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n\n  h z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = n", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n\n  h z \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = n", "proof (induct n arbitrary:p h)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p h.\n       \\<lbrakk>h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = 0\n 2. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "case 0"], ["proof (state)\nthis:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0\n  h z \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p h.\n       \\<lbrakk>h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = 0\n 2. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "then"], ["proof (chain)\npicking this:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0\n  h z \\<noteq> 0\n  p \\<noteq> 0", "have \"poly p z=h z\""], ["proof (prove)\nusing this:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0\n  h z \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p z = h z", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0\n  h z \\<noteq> 0\n  p \\<noteq> 0\n  0 < r\n\ngoal (1 subgoal):\n 1. poly p z = h z", "by auto"], ["proof (state)\nthis:\n  poly p z = h z\n\ngoal (2 subgoals):\n 1. \\<And>p h.\n       \\<lbrakk>h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = 0\n 2. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "then"], ["proof (chain)\npicking this:\n  poly p z = h z", "have \"poly p z\\<noteq>0\""], ["proof (prove)\nusing this:\n  poly p z = h z\n\ngoal (1 subgoal):\n 1. poly p z \\<noteq> 0", "using \\<open>h z\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p z = h z\n  h z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p h.\n       \\<lbrakk>h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ 0;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = 0\n 2. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "then"], ["proof (chain)\npicking this:\n  poly p z \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  poly p z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = 0", "using order_root"], ["proof (prove)\nusing this:\n  poly p z \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order z p = 0", "by blast"], ["proof (state)\nthis:\n  order z p = 0\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?h holomorphic_on ball z r;\n   \\<forall>w\\<in>ball z r. poly ?p w = ?h w * (w - z) ^ n; ?h z \\<noteq> 0;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> order z ?p = n\n  h holomorphic_on ball z r\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n\n  h z \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "define sn where \"sn=Suc n\""], ["proof (state)\nthis:\n  sn = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "define h' where \"h'\\<equiv> \\<lambda>w. deriv h w * (w-z)+ sn * h w\""], ["proof (state)\nthis:\n  h' \\<equiv> \\<lambda>w. deriv h w * (w - z) + of_nat sn * h w\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "have \"(poly p has_field_derivative poly (pderiv p) w) (at w)\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_field_derivative poly (pderiv p) w) (at w)", "using poly_DERIV[of p w]"], ["proof (prove)\nusing this:\n  (poly p has_field_derivative poly (pderiv p) w) (at w)\n\ngoal (1 subgoal):\n 1. (poly p has_field_derivative poly (pderiv p) w) (at w)", "."], ["proof (state)\nthis:\n  (poly p has_field_derivative poly (pderiv p) ?w) (at ?w)\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "moreover"], ["proof (state)\nthis:\n  (poly p has_field_derivative poly (pderiv p) ?w) (at ?w)\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "have \"(poly p has_field_derivative (h' w)*(w-z)^n ) (at w)\" when \"w\\<in>ball z r\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_field_derivative h' w * (w - z) ^ n) (at w)", "proof (subst DERIV_cong_ev[of w w \"poly p\" \"\\<lambda>w.  h w * (w - z) ^ Suc n\" ],simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in nhds w. poly p x = h x * ((x - z) * (x - z) ^ n)\n 2. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "show \"\\<forall>\\<^sub>F x in nhds w. poly p x = h x * ((x - z) * (x - z) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in nhds w. poly p x = h x * ((x - z) * (x - z) ^ n)", "unfolding eventually_nhds"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S.\n       open S \\<and>\n       w \\<in> S \\<and>\n       (\\<forall>x\\<in>S. poly p x = h x * ((x - z) * (x - z) ^ n))", "using Suc(3) \\<open>w\\<in>ball z r\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n\n  w \\<in> ball z r\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       open S \\<and>\n       w \\<in> S \\<and>\n       (\\<forall>x\\<in>S. poly p x = h x * ((x - z) * (x - z) ^ n))", "apply (intro exI[where x=\"ball z r\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n     w \\<in> ball z r\\<rbrakk>\n    \\<Longrightarrow> open (ball z r) \\<and>\n                      w \\<in> ball z r \\<and>\n                      (\\<forall>x\\<in>ball z r.\n                          poly p x = h x * ((x - z) * (x - z) ^ n))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in nhds w. poly p x = h x * ((x - z) * (x - z) ^ n)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "have \"(h has_field_derivative deriv h w) (at w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h has_field_derivative deriv h w) (at w)", "using \\<open>h holomorphic_on ball z r\\<close> \\<open>w\\<in>ball z r\\<close> holomorphic_on_imp_differentiable_at"], ["proof (prove)\nusing this:\n  h holomorphic_on ball z r\n  w \\<in> ball z r\n  \\<lbrakk>?f holomorphic_on ?s; open ?s; ?x \\<in> ?s\\<rbrakk>\n  \\<Longrightarrow> ?f field_differentiable at ?x\n\ngoal (1 subgoal):\n 1. (h has_field_derivative deriv h w) (at w)", "by (simp add: holomorphic_derivI)"], ["proof (state)\nthis:\n  (h has_field_derivative deriv h w) (at w)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "then"], ["proof (chain)\npicking this:\n  (h has_field_derivative deriv h w) (at w)", "have \"((\\<lambda>w. h w * ((w - z) ^ sn)) \n                      has_field_derivative h' w * (w - z) ^ (sn - 1)) (at w)\""], ["proof (prove)\nusing this:\n  (h has_field_derivative deriv h w) (at w)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * (w - z) ^ sn) has_field_derivative\n     h' w * (w - z) ^ (sn - 1))\n     (at w)", "unfolding h'_def"], ["proof (prove)\nusing this:\n  (h has_field_derivative deriv h w) (at w)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * (w - z) ^ sn) has_field_derivative\n     (deriv h w * (w - z) + of_nat sn * h w) * (w - z) ^ (sn - 1))\n     (at w)", "apply (auto intro!: derivative_eq_intros simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h has_field_derivative deriv h w) (at w) \\<Longrightarrow>\n    deriv h w * (w - z) ^ sn + z * (deriv h w * (w - z) ^ (sn - Suc 0)) =\n    w * (deriv h w * (w - z) ^ (sn - Suc 0))", "by (auto simp add:field_simps sn_def)"], ["proof (state)\nthis:\n  ((\\<lambda>w. h w * (w - z) ^ sn) has_field_derivative\n   h' w * (w - z) ^ (sn - 1))\n   (at w)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>w. h w * (w - z) ^ sn) has_field_derivative\n   h' w * (w - z) ^ (sn - 1))\n   (at w)", "show \"((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) \n                      has_field_derivative h' w * (w - z) ^ n) (at w)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>w. h w * (w - z) ^ sn) has_field_derivative\n   h' w * (w - z) ^ (sn - 1))\n   (at w)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "unfolding sn_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>w. h w * (w - z) ^ Suc n) has_field_derivative\n   h' w * (w - z) ^ (Suc n - 1))\n   (at w)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n     h' w * (w - z) ^ n)\n     (at w)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>w. h w * ((w - z) * (w - z) ^ n)) has_field_derivative\n   h' w * (w - z) ^ n)\n   (at w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w \\<in> ball z r \\<Longrightarrow>\n  (poly p has_field_derivative h' ?w * (?w - z) ^ n) (at ?w)\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "ultimately"], ["proof (chain)\npicking this:\n  (poly p has_field_derivative poly (pderiv p) ?w) (at ?w)\n  ?w \\<in> ball z r \\<Longrightarrow>\n  (poly p has_field_derivative h' ?w * (?w - z) ^ n) (at ?w)", "have \"\\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n\""], ["proof (prove)\nusing this:\n  (poly p has_field_derivative poly (pderiv p) ?w) (at ?w)\n  ?w \\<in> ball z r \\<Longrightarrow>\n  (poly p has_field_derivative h' ?w * (?w - z) ^ n) (at ?w)\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n", "using DERIV_unique"], ["proof (prove)\nusing this:\n  (poly p has_field_derivative poly (pderiv p) ?w) (at ?w)\n  ?w \\<in> ball z r \\<Longrightarrow>\n  (poly p has_field_derivative h' ?w * (?w - z) ^ n) (at ?w)\n  \\<lbrakk>(?f has_field_derivative ?D) (at ?x);\n   (?f has_field_derivative ?E) (at ?x)\\<rbrakk>\n  \\<Longrightarrow> ?D = ?E\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n", "by blast"], ["proof (state)\nthis:\n  \\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "moreover"], ["proof (state)\nthis:\n  \\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "have \"h' holomorphic_on ball z r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' holomorphic_on ball z r", "unfolding h'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. deriv h w * (w - z) + of_nat sn * h w) holomorphic_on\n    ball z r", "using \\<open>h holomorphic_on ball z r\\<close>"], ["proof (prove)\nusing this:\n  h holomorphic_on ball z r\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. deriv h w * (w - z) + of_nat sn * h w) holomorphic_on\n    ball z r", "by (auto intro!: holomorphic_intros)"], ["proof (state)\nthis:\n  h' holomorphic_on ball z r\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "moreover"], ["proof (state)\nthis:\n  h' holomorphic_on ball z r\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "have \"h' z\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' z \\<noteq> 0", "unfolding h'_def sn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv h z * (z - z) + of_nat (Suc n) * h z \\<noteq> 0", "using \\<open>h z \\<noteq> 0\\<close> of_nat_neq_0"], ["proof (prove)\nusing this:\n  h z \\<noteq> 0\n  of_nat (Suc ?n) \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. deriv h z * (z - z) + of_nat (Suc n) * h z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  h' z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "moreover"], ["proof (state)\nthis:\n  h' z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "have \"pderiv p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv p = 0 \\<Longrightarrow> False", "assume \"pderiv p = 0\""], ["proof (state)\nthis:\n  pderiv p = 0\n\ngoal (1 subgoal):\n 1. pderiv p = 0 \\<Longrightarrow> False", "obtain c where \"p=[:c:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>pderiv p = 0\\<close>"], ["proof (prove)\nusing this:\n  pderiv p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using pderiv_iszero"], ["proof (prove)\nusing this:\n  pderiv p = 0\n  pderiv ?p = 0 \\<Longrightarrow> \\<exists>h. ?p = [:h:]\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. pderiv p = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = [:c:]", "have \"c=0\""], ["proof (prove)\nusing this:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. c = 0", "using Suc(3)[rule_format,of z] \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  p = [:c:]\n  z \\<in> ball z r \\<Longrightarrow> poly p z = h z * (z - z) ^ Suc n\n  0 < r\n\ngoal (1 subgoal):\n 1. c = 0", "by auto"], ["proof (state)\nthis:\n  c = 0\n\ngoal (1 subgoal):\n 1. pderiv p = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c = 0", "show False"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p=[:c:]\\<close>"], ["proof (prove)\nusing this:\n  c = 0\n  p \\<noteq> 0\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n\n  h' holomorphic_on ball z r\n  h' z \\<noteq> 0\n  pderiv p \\<noteq> 0", "have \"order z (pderiv p) = n\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>ball z r. poly (pderiv p) w = h' w * (w - z) ^ n\n  h' holomorphic_on ball z r\n  h' z \\<noteq> 0\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z (pderiv p) = n", "by (auto elim: Suc.hyps)"], ["proof (state)\nthis:\n  order z (pderiv p) = n\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "moreover"], ["proof (state)\nthis:\n  order z (pderiv p) = n\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "have \"order z p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order z p \\<noteq> 0", "using Suc(3)[rule_format,of z] \\<open>r>0\\<close> order_root \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> ball z r \\<Longrightarrow> poly p z = h z * (z - z) ^ Suc n\n  0 < r\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order z p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n p h.\n       \\<lbrakk>\\<And>p h.\n                   \\<lbrakk>h holomorphic_on ball z r;\n                    \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ n;\n                    h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> order z p = n;\n        h holomorphic_on ball z r;\n        \\<forall>w\\<in>ball z r. poly p w = h w * (w - z) ^ Suc n;\n        h z \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order z p = Suc n", "ultimately"], ["proof (chain)\npicking this:\n  order z (pderiv p) = n\n  order z p \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  order z (pderiv p) = n\n  order z p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p = Suc n", "using order_pderiv[OF \\<open>pderiv p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  order z (pderiv p) = n\n  order z p \\<noteq> 0\n  order ?a p \\<noteq> 0 \\<Longrightarrow>\n  order ?a p = Suc (order ?a (pderiv p))\n\ngoal (1 subgoal):\n 1. order z p = Suc n", "by auto"], ["proof (state)\nthis:\n  order z p = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order z p = n\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "then"], ["proof (chain)\npicking this:\n  order z p = n", "show ?thesis"], ["proof (prove)\nusing this:\n  order z p = n\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "unfolding n_def"], ["proof (prove)\nusing this:\n  order z p = nat (zorder (poly p) z)\n\ngoal (1 subgoal):\n 1. order z p = nat (zorder (poly p) z)", "."], ["proof (state)\nthis:\n  order z p = nat (zorder (poly p) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pcompose_pCons_0:\"pcompose p [:a:] = [:poly p a:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:a:] = [:poly p a:]", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<circ>\\<^sub>p [:a:] = [:poly 0 a:]\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        p \\<circ>\\<^sub>p [:a:] = [:poly p a:]\\<rbrakk>\n       \\<Longrightarrow> pCons aa p \\<circ>\\<^sub>p [:a:] =\n                         [:poly (pCons aa p) a:]", "by (auto simp add:pcompose_pCons algebra_simps)"], ["", "lemma pcompose_coeff_0:\n  \"coeff (pcompose p q) 0 = poly p (coeff q 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p q) 0 = poly p (coeff q 0)", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. coeff (0 \\<circ>\\<^sub>p q) 0 = poly 0 (coeff q 0)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        coeff (p \\<circ>\\<^sub>p q) 0 = poly p (coeff q 0)\\<rbrakk>\n       \\<Longrightarrow> coeff (pCons a p \\<circ>\\<^sub>p q) 0 =\n                         poly (pCons a p) (coeff q 0)", "by (auto simp add:pcompose_pCons coeff_mult)"], ["", "lemma poly_field_differentiable_at[simp]:\n  \"poly p field_differentiable (at x within s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p field_differentiable at x within s", "apply (unfold field_differentiable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'. (poly p has_field_derivative f') (at x within s)", "apply (rule_tac x=\"poly (pderiv p) x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_field_derivative poly (pderiv p) x) (at x within s)", "by (simp add:has_field_derivative_at_within)"], ["", "lemma deriv_pderiv:\n  \"deriv (poly p) = poly (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (poly p) = poly (pderiv p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. deriv (poly p) x = poly (pderiv p) x", "apply (rule DERIV_imp_deriv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (poly p has_field_derivative poly (pderiv p) x) (at x)", "using poly_DERIV"], ["proof (prove)\nusing this:\n  (poly ?p has_field_derivative poly (pderiv ?p) ?x) (at ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x. (poly p has_field_derivative poly (pderiv p) x) (at x)", "."], ["", "lemma lead_coeff_map_poly_nz:\n  assumes \"f (lead_coeff p) \\<noteq>0\" \"f 0=0\"\n  shows \"lead_coeff (map_poly f p) = f (lead_coeff p) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (map_poly f p) = f (lead_coeff p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff (map_poly f p) = f (lead_coeff p)", "have \"lead_coeff (Poly (map f (coeffs p))) = f (lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (Poly (map f (coeffs p))) = f (lead_coeff p)", "by (metis (mono_tags, lifting) antisym assms(1) assms(2) coeff_0_degree_minus_1 coeff_map_poly \n        degree_Poly degree_eq_length_coeffs le_degree length_map map_poly_def)"], ["proof (state)\nthis:\n  lead_coeff (Poly (map f (coeffs p))) = f (lead_coeff p)\n\ngoal (1 subgoal):\n 1. lead_coeff (map_poly f p) = f (lead_coeff p)", "then"], ["proof (chain)\npicking this:\n  lead_coeff (Poly (map f (coeffs p))) = f (lead_coeff p)", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (Poly (map f (coeffs p))) = f (lead_coeff p)\n\ngoal (1 subgoal):\n 1. lead_coeff (map_poly f p) = f (lead_coeff p)", "by (simp add: map_poly_def)"], ["proof (state)\nthis:\n  lead_coeff (map_poly f p) = f (lead_coeff p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filterlim_poly_at_infinity:\n  fixes p::\"'a::real_normed_field poly\"\n  assumes \"degree p>0\"\n  shows \"filterlim (poly p) at_infinity at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (poly p) at_infinity at_infinity", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. filterlim (poly p) at_infinity at_infinity", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree 0 \\<Longrightarrow>\n    filterlim (poly 0) at_infinity at_infinity\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "case 0"], ["proof (state)\nthis:\n  0 < degree 0\n\ngoal (2 subgoals):\n 1. 0 < degree 0 \\<Longrightarrow>\n    filterlim (poly 0) at_infinity at_infinity\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "then"], ["proof (chain)\npicking this:\n  0 < degree 0", "show ?case"], ["proof (prove)\nusing this:\n  0 < degree 0\n\ngoal (1 subgoal):\n 1. filterlim (poly 0) at_infinity at_infinity", "by auto"], ["proof (state)\nthis:\n  filterlim (poly 0) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  0 < degree p \\<Longrightarrow> filterlim (poly p) at_infinity at_infinity\n  0 < degree (pCons a p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "have ?case when \"degree p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "obtain c where c_def:\"p=[:c:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>degree p = 0\\<close> degree_eq_zeroE"], ["proof (prove)\nusing this:\n  degree p = 0\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "then"], ["proof (chain)\npicking this:\n  p = [:c:]", "have \"c\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "using \\<open>0 < degree (pCons a p)\\<close>"], ["proof (prove)\nusing this:\n  p = [:c:]\n  0 < degree (pCons a p)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "unfolding c_def"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. filterlim (poly [:a, c:]) at_infinity at_infinity", "apply (auto intro!:tendsto_add_filterlim_at_infinity)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    LIM x at_infinity. x * c :> at_infinity", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    filterlim ((*) c) at_infinity at_infinity", "by (auto intro!:tendsto_mult_filterlim_at_infinity filterlim_ident)"], ["proof (state)\nthis:\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "moreover"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "have ?case when \"degree p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "have \"filterlim (poly p) at_infinity at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (poly p) at_infinity at_infinity", "using that"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. filterlim (poly p) at_infinity at_infinity", "by (auto intro:pCons)"], ["proof (state)\nthis:\n  filterlim (poly p) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "then"], ["proof (chain)\npicking this:\n  filterlim (poly p) at_infinity at_infinity", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim (poly p) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "by (auto intro!:tendsto_add_filterlim_at_infinity filterlim_at_infinity_times filterlim_ident)"], ["proof (state)\nthis:\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree p \\<noteq> 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        0 < degree p \\<Longrightarrow>\n        filterlim (poly p) at_infinity at_infinity;\n        0 < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> filterlim (poly (pCons a p)) at_infinity\n                          at_infinity", "ultimately"], ["proof (chain)\npicking this:\n  degree p = 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n  degree p \\<noteq> 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity", "show ?case"], ["proof (prove)\nusing this:\n  degree p = 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n  degree p \\<noteq> 0 \\<Longrightarrow>\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal (1 subgoal):\n 1. filterlim (poly (pCons a p)) at_infinity at_infinity", "by auto"], ["proof (state)\nthis:\n  filterlim (poly (pCons a p)) at_infinity at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_divide_tendsto_aux:\n  fixes p::\"'a::real_normed_field poly\"\n  shows \"((\\<lambda>x. poly p x/x^(degree p)) \\<longlongrightarrow> lead_coeff p) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n     lead_coeff p)\n     at_infinity", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. poly 0 x / x ^ degree 0) \\<longlongrightarrow>\n     lead_coeff 0)\n     at_infinity\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. poly 0 x / x ^ degree 0) \\<longlongrightarrow>\n     lead_coeff 0)\n     at_infinity\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly 0 x / x ^ degree 0) \\<longlongrightarrow>\n     lead_coeff 0)\n     at_infinity", "by (auto intro:tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly 0 x / x ^ degree 0) \\<longlongrightarrow> lead_coeff 0)\n   at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow> lead_coeff p)\n   at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "have ?case when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "using that"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "by auto"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "have ?case when \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "define g where \"g=(\\<lambda>x. a/(x*x^degree p))\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. a / (x * x ^ degree p))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "define f where \"f=(\\<lambda>x. poly p x/x^degree p)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. poly p x / x ^ degree p)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "have \"\\<forall>\\<^sub>Fx in at_infinity. poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_infinity.\n       poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "proof (rule eventually_at_infinityI[of 1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "assume \"norm x\\<ge>1\""], ["proof (state)\nthis:\n  1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "then"], ["proof (chain)\npicking this:\n  1 \\<le> norm x", "have \"x\\<noteq>0\""], ["proof (prove)\nusing this:\n  1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)", "show \"poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (pCons a p) x / x ^ degree (pCons a p) =\n    a / (x * x ^ degree p) + poly p x / x ^ degree p", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "have \"((\\<lambda>x. g x+f x) \\<longlongrightarrow>  lead_coeff (pCons a p)) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n     at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n     at_infinity", "have \"(g \\<longlongrightarrow>  0) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> (0::'a)) at_infinity", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. a / (x * x ^ degree p)) \\<longlongrightarrow> (0::'a))\n     at_infinity", "using filterlim_poly_at_infinity[of \"monom 1 (Suc (degree p))\"]"], ["proof (prove)\nusing this:\n  0 < degree (monom (1::?'b1) (Suc (degree p))) \\<Longrightarrow>\n  filterlim (poly (monom (1::?'b1) (Suc (degree p)))) at_infinity\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. a / (x * x ^ degree p)) \\<longlongrightarrow> (0::'a))\n     at_infinity", "apply (auto intro!:tendsto_intros tendsto_divide_0 simp add: degree_monom_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim (poly (monom (1::?'b1) (Suc (degree p)))) at_infinity\n     at_infinity \\<Longrightarrow>\n    LIM x at_infinity. x * x ^ degree p :> at_infinity", "apply (subst filterlim_cong[where g=\"poly (monom 1 (Suc (degree p)))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. filterlim (poly (monom (1::?'b1) (Suc (degree p)))) at_infinity\n     at_infinity \\<Longrightarrow>\n    at_infinity = ?F1'7\n 2. filterlim (poly (monom (1::?'b1) (Suc (degree p)))) at_infinity\n     at_infinity \\<Longrightarrow>\n    at_infinity = ?F2'7\n 3. filterlim (poly (monom (1::?'b1) (Suc (degree p)))) at_infinity\n     at_infinity \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_infinity.\n       x * x ^ degree p = poly (monom (1::'a) (Suc (degree p))) x\n 4. filterlim (poly (monom (1::?'b1) (Suc (degree p)))) at_infinity\n     at_infinity \\<Longrightarrow>\n    filterlim (poly (monom (1::'a) (Suc (degree p)))) ?F1'7 ?F2'7", "by (auto simp add:poly_monom)"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> (0::'a)) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n     at_infinity", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> (0::'a)) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n     at_infinity", "have \"(f \\<longlongrightarrow>  lead_coeff (pCons a p)) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> lead_coeff (pCons a p)) at_infinity", "using pCons \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow> lead_coeff p)\n   at_infinity\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> lead_coeff (pCons a p)) at_infinity", "unfolding f_def"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow> lead_coeff p)\n   at_infinity\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "by auto"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> lead_coeff (pCons a p)) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n     at_infinity", "ultimately"], ["proof (chain)\npicking this:\n  (g \\<longlongrightarrow> (0::'a)) at_infinity\n  (f \\<longlongrightarrow> lead_coeff (pCons a p)) at_infinity", "show ?thesis"], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> (0::'a)) at_infinity\n  (f \\<longlongrightarrow> lead_coeff (pCons a p)) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n     at_infinity", "by (auto intro:tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n   at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\n  ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n   at_infinity", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly (pCons a p) x / x ^ degree (pCons a p) = g x + f x\n  ((\\<lambda>x. g x + f x) \\<longlongrightarrow> lead_coeff (pCons a p))\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n         lead_coeff p)\n         at_infinity\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              poly (pCons a p) x /\n                              x ^ degree (pCons a p)) \\<longlongrightarrow>\n                          lead_coeff (pCons a p))\n                          at_infinity", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n  p \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity", "show ?case"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n  p \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n     lead_coeff (pCons a p))\n     at_infinity", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       poly (pCons a p) x / x ^ degree (pCons a p)) \\<longlongrightarrow>\n   lead_coeff (pCons a p))\n   at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filterlim_power_at_infinity:\n  assumes \"n\\<noteq>0\"\n  shows \"filterlim (\\<lambda>x::'a::real_normed_field. x^n) at_infinity at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_infinity. x ^ n :> at_infinity", "using filterlim_poly_at_infinity[of \"monom 1 n\"] assms"], ["proof (prove)\nusing this:\n  0 < degree (monom (1::?'b1) n) \\<Longrightarrow>\n  filterlim (poly (monom (1::?'b1) n)) at_infinity at_infinity\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x at_infinity. x ^ n :> at_infinity", "apply (subst filterlim_cong[where g=\"poly (monom 1 n)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < degree (monom (1::?'b1) n) \\<Longrightarrow>\n             filterlim (poly (monom (1::?'b1) n)) at_infinity at_infinity;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> at_infinity = ?F1'4\n 2. \\<lbrakk>0 < degree (monom (1::?'b1) n) \\<Longrightarrow>\n             filterlim (poly (monom (1::?'b1) n)) at_infinity at_infinity;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> at_infinity = ?F2'4\n 3. \\<lbrakk>0 < degree (monom (1::?'b1) n) \\<Longrightarrow>\n             filterlim (poly (monom (1::?'b1) n)) at_infinity at_infinity;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_infinity.\n                         x ^ n = poly (monom (1::'a) n) x\n 4. \\<lbrakk>0 < degree (monom (1::?'b1) n) \\<Longrightarrow>\n             filterlim (poly (monom (1::?'b1) n)) at_infinity at_infinity;\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> filterlim (poly (monom (1::'a) n)) ?F1'4 ?F2'4", "by (auto simp add:poly_monom degree_monom_eq)"], ["", "lemma poly_divide_tendsto_0_at_infinity: \n  fixes p::\"'a::real_normed_field poly\"\n  assumes \"degree p > degree q\" \n  shows \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0 ) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "define pp where \"pp=(\\<lambda>x. x^(degree p) / poly p x)\""], ["proof (state)\nthis:\n  pp = (\\<lambda>x. x ^ degree p / poly p x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "define qq where \"qq=(\\<lambda>x. poly q x/x^(degree q))\""], ["proof (state)\nthis:\n  qq = (\\<lambda>x. poly q x / x ^ degree q)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "define dd where \"dd=(\\<lambda>x::'a. 1/x^(degree p - degree q))\""], ["proof (state)\nthis:\n  dd = (\\<lambda>x. (1::'a) / x ^ (degree p - degree q))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "have \"\\<forall>\\<^sub>Fx in at_infinity.  poly q x / poly p x = qq x * pp x * dd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_infinity.\n       poly q x / poly p x = qq x * pp x * dd x", "proof (rule eventually_at_infinityI[of 1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly q x / poly p x = qq x * pp x * dd x", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly q x / poly p x = qq x * pp x * dd x", "assume \"norm x\\<ge>1\""], ["proof (state)\nthis:\n  1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly q x / poly p x = qq x * pp x * dd x", "then"], ["proof (chain)\npicking this:\n  1 \\<le> norm x", "have \"x\\<noteq>0\""], ["proof (prove)\nusing this:\n  1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> norm x \\<Longrightarrow>\n       poly q x / poly p x = qq x * pp x * dd x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)", "show \"poly q x / poly p x = qq x * pp x * dd x\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly q x / poly p x = qq x * pp x * dd x", "unfolding qq_def pp_def dd_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    poly q x / x ^ degree q * (x ^ degree p / poly p x) *\n    ((1::'a) / x ^ (degree p - degree q))", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    poly q x / x ^ degree q * (x ^ degree p / poly p x) *\n    ((1::'a) / x ^ (degree p - degree q))", "by (auto simp add:field_simps divide_simps power_diff)"], ["proof (state)\nthis:\n  poly q x / poly p x = qq x * pp x * dd x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly q x / poly p x = qq x * pp x * dd x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly q x / poly p x = qq x * pp x * dd x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "have \"((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> 0) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "have \"(qq \\<longlongrightarrow> lead_coeff q) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qq \\<longlongrightarrow> lead_coeff q) at_infinity", "unfolding qq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow>\n     lead_coeff q)\n     at_infinity", "using poly_divide_tendsto_aux[of q]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow> lead_coeff q)\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow>\n     lead_coeff q)\n     at_infinity", "."], ["proof (state)\nthis:\n  (qq \\<longlongrightarrow> lead_coeff q) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "moreover"], ["proof (state)\nthis:\n  (qq \\<longlongrightarrow> lead_coeff q) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "have \"(pp \\<longlongrightarrow> 1/lead_coeff p) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity", "unfolding pp_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x ^ degree p / poly p x) \\<longlongrightarrow>\n     (1::'a) / lead_coeff p)\n     at_infinity", "using poly_divide_tendsto_aux[of p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow> lead_coeff p)\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x ^ degree p / poly p x) \\<longlongrightarrow>\n     (1::'a) / lead_coeff p)\n     at_infinity", "apply (drule_tac tendsto_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow> lead_coeff p \\<noteq> (0::'a)\n 2. \\<lbrakk>p \\<noteq> 0;\n     ((\\<lambda>x. inverse (poly p x / x ^ degree p)) \\<longlongrightarrow>\n      inverse (lead_coeff p))\n      at_infinity\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           x ^ degree p / poly p x) \\<longlongrightarrow>\n                       (1::'a) / lead_coeff p)\n                       at_infinity", "by (auto simp add:inverse_eq_divide)"], ["proof (state)\nthis:\n  (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "moreover"], ["proof (state)\nthis:\n  (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "have \"(dd \\<longlongrightarrow> 0) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dd \\<longlongrightarrow> (0::'a)) at_infinity", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (1::'a) / x ^ (degree p - degree q)) \\<longlongrightarrow>\n     (0::'a))\n     at_infinity", "apply (rule tendsto_divide_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. 1::'a) \\<longlongrightarrow> ?c) at_infinity\n 2. LIM x at_infinity. x ^ (degree p - degree q) :> at_infinity", "by (auto intro!: filterlim_power_at_infinity simp add:assms)"], ["proof (state)\nthis:\n  (dd \\<longlongrightarrow> (0::'a)) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "ultimately"], ["proof (chain)\npicking this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_infinity\n  (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity\n  (dd \\<longlongrightarrow> (0::'a)) at_infinity", "show ?thesis"], ["proof (prove)\nusing this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_infinity\n  (pp \\<longlongrightarrow> (1::'a) / lead_coeff p) at_infinity\n  (dd \\<longlongrightarrow> (0::'a)) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "by (auto intro:tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n   at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly q x / poly p x = qq x * pp x * dd x\n  ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n   at_infinity", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_infinity.\n     poly q x / poly p x = qq x * pp x * dd x\n  ((\\<lambda>x. qq x * pp x * dd x) \\<longlongrightarrow> (0::'a))\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n     at_infinity", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> (0::'a))\n   at_infinity\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_list_def:\n  \"lead_coeff p= (if coeffs p=[] then 0 else last (coeffs p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff p = (if coeffs p = [] then 0::'a else last (coeffs p))", "by (simp add: last_coeffs_eq_coeff_degree)"], ["", "lemma poly_linepath_comp: \n  fixes a::\"'a::{real_normed_vector,comm_semiring_0,real_algebra_1}\"\n  shows \"poly p o (linepath a b) = poly (p \\<circ>\\<^sub>p [:a, b-a:]) o of_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p \\<circ> linepath a b =\n    poly (p \\<circ>\\<^sub>p [:a, b - a:]) \\<circ> of_real", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly p \\<circ> linepath a b) x =\n       (poly (p \\<circ>\\<^sub>p [:a, b - a:]) \\<circ> of_real) x", "by (auto simp add:poly_pcompose linepath_def scaleR_conv_of_real algebra_simps)"], ["", "lemma poly_eventually_not_zero:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"eventually (\\<lambda>x. poly p x\\<noteq>0) at_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_infinity. poly p x \\<noteq> 0", "proof (rule eventually_at_infinityI[of \"Max (norm ` {x. poly p x=0}) + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x \\<Longrightarrow>\n       poly p x \\<noteq> 0", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x \\<Longrightarrow>\n       poly p x \\<noteq> 0", "assume asm:\"Max (norm ` {x. poly p x=0}) + 1 \\<le> norm x\""], ["proof (state)\nthis:\n  Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x \\<Longrightarrow>\n       poly p x \\<noteq> 0", "have False when \"poly p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define S where \"S=norm `{x. poly p x = 0}\""], ["proof (state)\nthis:\n  S = norm ` {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. False", "have \"norm x\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x \\<in> S", "using that"], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. norm x \\<in> S", "unfolding S_def"], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. norm x \\<in> norm ` {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  norm x \\<in> S\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  norm x \\<in> S\n\ngoal (1 subgoal):\n 1. False", "have \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "using \\<open>p\\<noteq>0\\<close> poly_roots_finite"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite S", "unfolding S_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite (norm ` {x. poly p x = 0})", "by blast"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  norm x \\<in> S\n  finite S", "have \"norm x\\<le>Max S\""], ["proof (prove)\nusing this:\n  norm x \\<in> S\n  finite S\n\ngoal (1 subgoal):\n 1. norm x \\<le> Max S", "by simp"], ["proof (state)\nthis:\n  norm x \\<le> Max S\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  norm x \\<le> Max S\n\ngoal (1 subgoal):\n 1. False", "have \"Max S + 1 \\<le> norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max S + 1 \\<le> norm x", "using asm"], ["proof (prove)\nusing this:\n  Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. Max S + 1 \\<le> norm x", "unfolding S_def"], ["proof (prove)\nusing this:\n  Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x", "by simp"], ["proof (state)\nthis:\n  Max S + 1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  norm x \\<le> Max S\n  Max S + 1 \\<le> norm x", "show False"], ["proof (prove)\nusing this:\n  norm x \\<le> Max S\n  Max S + 1 \\<le> norm x\n\ngoal (1 subgoal):\n 1. False", "by argo"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Max (norm ` {x. poly p x = 0}) + 1 \\<le> norm x \\<Longrightarrow>\n       poly p x \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  poly p x = 0 \\<Longrightarrow> False", "show \"poly p x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More about @{term degree}\\<close>"], ["", "lemma degree_div_less:\n  fixes x y::\"'a::field poly\"\n  assumes \"degree x\\<noteq>0\" \"degree y\\<noteq>0\"\n  shows \"degree (x div y) < degree x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "have \"x\\<noteq>0\" \"y\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 &&& y \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  degree x \\<noteq> 0\n  degree y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 &&& y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "define q r where \"q=x div y\" and \"r=x mod y\""], ["proof (state)\nthis:\n  q = x div y\n  r = x mod y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "have *:\"eucl_rel_poly x y (q, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_rel_poly x y (q, r)", "unfolding q_def r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eucl_rel_poly x y (x div y, x mod y)", "by (simp add: eucl_rel_poly)"], ["proof (state)\nthis:\n  eucl_rel_poly x y (q, r)\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  eucl_rel_poly x y (q, r)", "have \"r = 0 \\<or> degree r < degree y\""], ["proof (prove)\nusing this:\n  eucl_rel_poly x y (q, r)\n\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree y", "using \\<open>y\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  eucl_rel_poly x y (q, r)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree y", "unfolding eucl_rel_poly_iff"], ["proof (prove)\nusing this:\n  x = q * y + r \\<and>\n  (if y = 0 then q = 0 else r = 0 \\<or> degree r < degree y)\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree y", "by auto"], ["proof (state)\nthis:\n  r = 0 \\<or> degree r < degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "moreover"], ["proof (state)\nthis:\n  r = 0 \\<or> degree r < degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "have ?thesis when \"r=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "have \"x = q * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = q * y", "using * that"], ["proof (prove)\nusing this:\n  eucl_rel_poly x y (q, r)\n  r = 0\n\ngoal (1 subgoal):\n 1. x = q * y", "unfolding eucl_rel_poly_iff"], ["proof (prove)\nusing this:\n  x = q * y + r \\<and>\n  (if y = 0 then q = 0 else r = 0 \\<or> degree r < degree y)\n  r = 0\n\ngoal (1 subgoal):\n 1. x = q * y", "by auto"], ["proof (state)\nthis:\n  x = q * y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  x = q * y", "have \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  x = q * y\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using \\<open>x\\<noteq>0\\<close> \\<open>y\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  x = q * y\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "from degree_mult_eq[OF this \\<open>y\\<noteq>0\\<close>] \\<open>x = q * y\\<close>"], ["proof (chain)\npicking this:\n  degree (q * y) = degree q + degree y\n  x = q * y", "have \"degree x = degree q +degree y\""], ["proof (prove)\nusing this:\n  degree (q * y) = degree q + degree y\n  x = q * y\n\ngoal (1 subgoal):\n 1. degree x = degree q + degree y", "by auto"], ["proof (state)\nthis:\n  degree x = degree q + degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  degree x = degree q + degree y", "show ?thesis"], ["proof (prove)\nusing this:\n  degree x = degree q + degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "unfolding q_def"], ["proof (prove)\nusing this:\n  degree x = degree (x div y) + degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "using assms"], ["proof (prove)\nusing this:\n  degree x = degree (x div y) + degree y\n  degree x \\<noteq> 0\n  degree y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "by auto"], ["proof (state)\nthis:\n  degree (x div y) < degree x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r = 0 \\<Longrightarrow> degree (x div y) < degree x\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "moreover"], ["proof (state)\nthis:\n  r = 0 \\<Longrightarrow> degree (x div y) < degree x\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "have ?thesis when \"degree r<degree y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "proof (cases \"degree y>degree x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree x < degree y \\<Longrightarrow> degree (x div y) < degree x\n 2. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "case True"], ["proof (state)\nthis:\n  degree x < degree y\n\ngoal (2 subgoals):\n 1. degree x < degree y \\<Longrightarrow> degree (x div y) < degree x\n 2. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  degree x < degree y", "have \"q=0\""], ["proof (prove)\nusing this:\n  degree x < degree y\n\ngoal (1 subgoal):\n 1. q = 0", "unfolding q_def"], ["proof (prove)\nusing this:\n  degree x < degree y\n\ngoal (1 subgoal):\n 1. x div y = 0", "using div_poly_less"], ["proof (prove)\nusing this:\n  degree x < degree y\n  degree ?x < degree ?y \\<Longrightarrow> ?x div ?y = 0\n\ngoal (1 subgoal):\n 1. x div y = 0", "by auto"], ["proof (state)\nthis:\n  q = 0\n\ngoal (2 subgoals):\n 1. degree x < degree y \\<Longrightarrow> degree (x div y) < degree x\n 2. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q = 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "unfolding q_def"], ["proof (prove)\nusing this:\n  x div y = 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "using assms(1)"], ["proof (prove)\nusing this:\n  x div y = 0\n  degree x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "by auto"], ["proof (state)\nthis:\n  degree (x div y) < degree x\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "case False"], ["proof (state)\nthis:\n  \\<not> degree x < degree y\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  \\<not> degree x < degree y", "have \"degree x>degree r\""], ["proof (prove)\nusing this:\n  \\<not> degree x < degree y\n\ngoal (1 subgoal):\n 1. degree r < degree x", "using that"], ["proof (prove)\nusing this:\n  \\<not> degree x < degree y\n  degree r < degree y\n\ngoal (1 subgoal):\n 1. degree r < degree x", "by auto"], ["proof (state)\nthis:\n  degree r < degree x\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  degree r < degree x", "have \"degree x = degree (x-r)\""], ["proof (prove)\nusing this:\n  degree r < degree x\n\ngoal (1 subgoal):\n 1. degree x = degree (x - r)", "using degree_add_eq_right[of \"-r\" x]"], ["proof (prove)\nusing this:\n  degree r < degree x\n  degree (- r) < degree x \\<Longrightarrow> degree (- r + x) = degree x\n\ngoal (1 subgoal):\n 1. degree x = degree (x - r)", "by auto"], ["proof (state)\nthis:\n  degree x = degree (x - r)\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "have \"x-r = q*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - r = q * y", "using *"], ["proof (prove)\nusing this:\n  eucl_rel_poly x y (q, r)\n\ngoal (1 subgoal):\n 1. x - r = q * y", "unfolding eucl_rel_poly_iff"], ["proof (prove)\nusing this:\n  x = q * y + r \\<and>\n  (if y = 0 then q = 0 else r = 0 \\<or> degree r < degree y)\n\ngoal (1 subgoal):\n 1. x - r = q * y", "by auto"], ["proof (state)\nthis:\n  x - r = q * y\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  x - r = q * y", "have \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  x - r = q * y\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using \\<open>degree r < degree x\\<close>"], ["proof (prove)\nusing this:\n  x - r = q * y\n  degree r < degree x\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "have \"degree x = degree q +degree y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x = degree q + degree y", "using  degree_mult_eq[OF \\<open>q\\<noteq>0\\<close> \\<open>y\\<noteq>0\\<close>] \\<open>x-r = q*y\\<close> \\<open>degree x = degree (x-r)\\<close>"], ["proof (prove)\nusing this:\n  degree (q * y) = degree q + degree y\n  x - r = q * y\n  degree x = degree (x - r)\n\ngoal (1 subgoal):\n 1. degree x = degree q + degree y", "by auto"], ["proof (state)\nthis:\n  degree x = degree q + degree y\n\ngoal (1 subgoal):\n 1. \\<not> degree x < degree y \\<Longrightarrow> degree (x div y) < degree x", "then"], ["proof (chain)\npicking this:\n  degree x = degree q + degree y", "show ?thesis"], ["proof (prove)\nusing this:\n  degree x = degree q + degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "unfolding q_def"], ["proof (prove)\nusing this:\n  degree x = degree (x div y) + degree y\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "using assms"], ["proof (prove)\nusing this:\n  degree x = degree (x div y) + degree y\n  degree x \\<noteq> 0\n  degree y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "by auto"], ["proof (state)\nthis:\n  degree (x div y) < degree x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree r < degree y \\<Longrightarrow> degree (x div y) < degree x\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "ultimately"], ["proof (chain)\npicking this:\n  r = 0 \\<or> degree r < degree y\n  r = 0 \\<Longrightarrow> degree (x div y) < degree x\n  degree r < degree y \\<Longrightarrow> degree (x div y) < degree x", "show ?thesis"], ["proof (prove)\nusing this:\n  r = 0 \\<or> degree r < degree y\n  r = 0 \\<Longrightarrow> degree (x div y) < degree x\n  degree r < degree y \\<Longrightarrow> degree (x div y) < degree x\n\ngoal (1 subgoal):\n 1. degree (x div y) < degree x", "by auto"], ["proof (state)\nthis:\n  degree (x div y) < degree x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_degree_eq:\n  assumes \"f (lead_coeff p) \\<noteq>0\"\n  shows \"degree (map_poly f p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) = degree p", "using assms"], ["proof (prove)\nusing this:\n  f (lead_coeff p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) = degree p", "unfolding map_poly_def degree_eq_length_coeffs coeffs_Poly lead_coeff_list_def"], ["proof (prove)\nusing this:\n  f (coeff p (length (coeffs p) - 1)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f (coeffs p))) - 1 =\n    length (coeffs p) - 1", "by (metis (full_types) last_conv_nth_default length_map no_trailing_unfold nth_default_coeffs_eq \n      nth_default_map_eq strip_while_idem)"], ["", "lemma map_poly_degree_less:\n  assumes \"f (lead_coeff p) =0\" \"degree p\\<noteq>0\"\n  shows \"degree (map_poly f p) < degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"length (coeffs p) >1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (coeffs p)", "using \\<open>degree p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < length (coeffs p)", "by (simp add: degree_eq_length_coeffs)"], ["proof (state)\nthis:\n  1 < length (coeffs p)\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "then"], ["proof (chain)\npicking this:\n  1 < length (coeffs p)", "obtain xs x where xs_def:\"coeffs p=xs@[x]\" \"length xs>0\""], ["proof (prove)\nusing this:\n  1 < length (coeffs p)\n\ngoal (1 subgoal):\n 1. (\\<And>xs x.\n        \\<lbrakk>coeffs p = xs @ [x]; 0 < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def add.commute add_diff_cancel_left' append_Nil assms(2) \n        degree_eq_length_coeffs length_greater_0_conv list.size(3) list.size(4) not_less_zero\n        rev_exhaust)"], ["proof (state)\nthis:\n  coeffs p = xs @ [x]\n  0 < length xs\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"f x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = (0::'a)", "using assms(1)"], ["proof (prove)\nusing this:\n  f (lead_coeff p) = (0::'a)\n\ngoal (1 subgoal):\n 1. f x = (0::'a)", "by (simp add: lead_coeff_list_def xs_def(1))"], ["proof (state)\nthis:\n  f x = (0::'a)\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"degree (map_poly f p) = length (strip_while ((=) 0) (map f (xs@[x]))) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) =\n    length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1", "unfolding map_poly_def degree_eq_length_coeffs coeffs_Poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f (coeffs p))) - 1 =\n    length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1", "by (subst xs_def,auto)"], ["proof (state)\nthis:\n  degree (map_poly f p) =\n  length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "also"], ["proof (state)\nthis:\n  degree (map_poly f p) =\n  length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"... = length (strip_while ((=) 0) (map f xs)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1 =\n    length (strip_while ((=) (0::'a)) (map f xs)) - 1", "using \\<open>f x=0\\<close>"], ["proof (prove)\nusing this:\n  f x = (0::'a)\n\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1 =\n    length (strip_while ((=) (0::'a)) (map f xs)) - 1", "by simp"], ["proof (state)\nthis:\n  length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1 =\n  length (strip_while ((=) (0::'a)) (map f xs)) - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "also"], ["proof (state)\nthis:\n  length (strip_while ((=) (0::'a)) (map f (xs @ [x]))) - 1 =\n  length (strip_while ((=) (0::'a)) (map f xs)) - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"... \\<le> length xs -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f xs)) - 1 \\<le> length xs - 1", "using length_strip_while_le"], ["proof (prove)\nusing this:\n  length (strip_while ?P ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f xs)) - 1 \\<le> length xs - 1", "by (metis diff_le_mono length_map)"], ["proof (state)\nthis:\n  length (strip_while ((=) (0::'a)) (map f xs)) - 1 \\<le> length xs - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "also"], ["proof (state)\nthis:\n  length (strip_while ((=) (0::'a)) (map f xs)) - 1 \\<le> length xs - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"... < length (xs@[x]) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs - 1 < length (xs @ [x]) - 1", "using xs_def(2)"], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. length xs - 1 < length (xs @ [x]) - 1", "by auto"], ["proof (state)\nthis:\n  length xs - 1 < length (xs @ [x]) - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "also"], ["proof (state)\nthis:\n  length xs - 1 < length (xs @ [x]) - 1\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "have \"... = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs @ [x]) - 1 = degree p", "unfolding degree_eq_length_coeffs xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs @ [x]) - 1 = length (xs @ [x]) - 1", "by simp"], ["proof (state)\nthis:\n  length (xs @ [x]) - 1 = degree p\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "finally"], ["proof (chain)\npicking this:\n  degree (map_poly f p) < degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (map_poly f p) < degree p\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) < degree p", "."], ["proof (state)\nthis:\n  degree (map_poly f p) < degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_degree_leq[simp]:\n  shows \"degree (map_poly f p) \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) \\<le> degree p", "unfolding map_poly_def degree_eq_length_coeffs"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (coeffs (Poly (map f (coeffs p)))) - 1\n    \\<le> length (coeffs p) - 1", "by (metis coeffs_Poly diff_le_mono length_map length_strip_while_le)"], ["", "subsection \\<open>roots / zeros of a univariate function\\<close>"], ["", "definition roots_within::\"('a \\<Rightarrow> 'b::zero) \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"roots_within f s = {x\\<in>s. f x = 0}\""], ["", "abbreviation roots::\"('a \\<Rightarrow> 'b::zero) \\<Rightarrow> 'a set\" where\n  \"roots f \\<equiv> roots_within f UNIV\""], ["", "subsection \\<open>The argument principle specialised to polynomials.\\<close>"], ["", "lemma argument_principle_poly:\n  assumes \"p\\<noteq>0\" and valid:\"valid_path g\" and loop: \"pathfinish g = pathstart g\" \n    and no_proots:\"path_image g \\<subseteq> - proots p\"  \n  shows \"contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) = 2 * of_real pi * \\<i> * \n            (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "have \"contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) = 2 * of_real pi * \\<i> * \n          (\\<Sum>x | poly p x = 0. winding_number g x * of_int (zorder (poly p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number g x * of_int (zorder (poly p) x))", "apply (rule argument_principle[of UNIV \"poly p\" \"{}\" \"\\<lambda>_. 1\" g,simplified,OF _ valid loop])"], ["proof (prove)\ngoal (3 subgoals):\n 1. connected UNIV\n 2. path_image g \\<subseteq> UNIV - {x. poly p x = 0}\n 3. finite {x. poly p x = 0}", "using no_proots[unfolded proots_def]"], ["proof (prove)\nusing this:\n  path_image g \\<subseteq> - {x. poly p x = 0}\n\ngoal (3 subgoals):\n 1. connected UNIV\n 2. path_image g \\<subseteq> UNIV - {x. poly p x = 0}\n 3. finite {x. poly p x = 0}", "by (auto simp add:poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>] )"], ["proof (state)\nthis:\n  contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0. winding_number g x * of_int (zorder (poly p) x))\n\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "also"], ["proof (state)\nthis:\n  contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0. winding_number g x * of_int (zorder (poly p) x))\n\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "have \"... =  2 * of_real pi * \\<i> * (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number g x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number g x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "have \"nat (zorder (poly p) x) = order x p\" when \"x\\<in>proots p\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (zorder (poly p) x) = order x p", "using order_zorder[OF \\<open>p\\<noteq>0\\<close>] that"], ["proof (prove)\nusing this:\n  order ?z p = nat (zorder (poly p) ?z)\n  x \\<in> proots p\n\ngoal (1 subgoal):\n 1. nat (zorder (poly p) x) = order x p", "unfolding proots_def"], ["proof (prove)\nusing this:\n  order ?z p = nat (zorder (poly p) ?z)\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. nat (zorder (poly p) x) = order x p", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> proots p \\<Longrightarrow> nat (zorder (poly p) ?x) = order ?x p\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number g x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> proots p \\<Longrightarrow> nat (zorder (poly p) ?x) = order ?x p", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> proots p \\<Longrightarrow> nat (zorder (poly p) ?x) = order ?x p\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number g x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "unfolding proots_def"], ["proof (prove)\nusing this:\n  ?x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n  nat (zorder (poly p) ?x) = order ?x p\n\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number g x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0. winding_number g x * of_nat (order x p))", "apply (auto intro!:comm_monoid_add_class.sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   poly p x = 0 \\<Longrightarrow>\n                   nat (zorder (poly p) x) = order x p;\n        poly p x = 0;\n        of_int (zorder (poly p) x) \\<noteq> of_nat (order x p)\\<rbrakk>\n       \\<Longrightarrow> winding_number g x = 0", "by (metis assms(1) nat_eq_iff2 of_nat_nat order_root)"], ["proof (state)\nthis:\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0.\n     winding_number g x * of_int (zorder (poly p) x)) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0.\n     winding_number g x * of_int (zorder (poly p) x)) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\n\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "finally"], ["proof (chain)\npicking this:\n  contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "show ?thesis"], ["proof (prove)\nusing this:\n  contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\n\ngoal (1 subgoal):\n 1. contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))", "."], ["proof (state)\nthis:\n  contour_integral g (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number g x * of_nat (order x p))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}