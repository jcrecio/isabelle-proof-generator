{"file_name": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval/Missing_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval", "problem_names": ["lemma pathfinish_offset[simp]:\n  \"pathfinish (\\<lambda>t. g t - z) = pathfinish g - z\"", "lemma pathstart_offset[simp]:\n  \"pathstart (\\<lambda>t. g t - z) = pathstart g - z\"", "lemma pathimage_offset[simp]:\n  fixes g :: \"_ \\<Rightarrow> 'b::topological_group_add\"\n  shows \"p \\<in> path_image (\\<lambda>t. g t - z) \\<longleftrightarrow> p+z \\<in> path_image g \"", "lemma path_offset[simp]:\n fixes g :: \"_ \\<Rightarrow> 'b::topological_group_add\"\n shows \"path (\\<lambda>t. g t - z) \\<longleftrightarrow> path g\"", "lemma not_on_circlepathI:\n  assumes \"cmod (z-z0) \\<noteq> \\<bar>r\\<bar>\"\n  shows \"z \\<notin> path_image (part_circlepath z0 r st tt)\"", "lemma circlepath_inj_on: \n  assumes \"r>0\"\n  shows \"inj_on (circlepath z r) {0..<1}\"", "lemma winding_number_comp:\n  assumes \"open s\" \"f holomorphic_on s\" \"path_image \\<gamma> \\<subseteq> s\"  \n    \"valid_path \\<gamma>\" \"z \\<notin> path_image (f \\<circ> \\<gamma>)\" \n  shows \"winding_number (f \\<circ> \\<gamma>) z = 1/(2*pi*\\<i>)* contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\"", "lemma winding_number_uminus_comp:\n  assumes \"valid_path \\<gamma>\" \"- z \\<notin> path_image \\<gamma>\" \n  shows \"winding_number (uminus \\<circ> \\<gamma>) z = winding_number \\<gamma> (-z)\"", "lemma winding_number_comp_linear:\n  assumes \"c\\<noteq>0\" \"valid_path \\<gamma>\" and not_image: \"(z-b)/c \\<notin> path_image \\<gamma>\"\n  shows \"winding_number ((\\<lambda>x. c*x+b) \\<circ> \\<gamma>) z = winding_number \\<gamma> ((z-b)/c)\" (is \"?L = ?R\")"], "translations": [["", "lemma pathfinish_offset[simp]:\n  \"pathfinish (\\<lambda>t. g t - z) = pathfinish g - z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish (\\<lambda>t. g t - z) = pathfinish g - z", "unfolding pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g 1 - z = g 1 - z", "by simp"], ["", "lemma pathstart_offset[simp]:\n  \"pathstart (\\<lambda>t. g t - z) = pathstart g - z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart (\\<lambda>t. g t - z) = pathstart g - z", "unfolding pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g 0 - z = g 0 - z", "by simp"], ["", "lemma pathimage_offset[simp]:\n  fixes g :: \"_ \\<Rightarrow> 'b::topological_group_add\"\n  shows \"p \\<in> path_image (\\<lambda>t. g t - z) \\<longleftrightarrow> p+z \\<in> path_image g \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> path_image (\\<lambda>t. g t - z)) = (p + z \\<in> path_image g)", "unfolding path_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> (\\<lambda>t. g t - z) ` {0..1}) = (p + z \\<in> g ` {0..1})", "by (auto simp:algebra_simps)"], ["", "lemma path_offset[simp]:\n fixes g :: \"_ \\<Rightarrow> 'b::topological_group_add\"\n shows \"path (\\<lambda>t. g t - z) \\<longleftrightarrow> path g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (\\<lambda>t. g t - z) = path g", "unfolding path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>t. g t - z) = continuous_on {0..1} g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. g t - z) \\<Longrightarrow>\n    continuous_on {0..1} g\n 2. continuous_on {0..1} g \\<Longrightarrow>\n    continuous_on {0..1} (\\<lambda>t. g t - z)", "assume \"continuous_on {0..1} (\\<lambda>t. g t - z)\""], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>t. g t - z)\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. g t - z) \\<Longrightarrow>\n    continuous_on {0..1} g\n 2. continuous_on {0..1} g \\<Longrightarrow>\n    continuous_on {0..1} (\\<lambda>t. g t - z)", "hence \"continuous_on {0..1} (\\<lambda>t. (g t - z) + z)\""], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>t. g t - z)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>t. g t - z + z)", "apply (rule continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. z)", "by (intro continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>t. g t - z + z)\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. g t - z) \\<Longrightarrow>\n    continuous_on {0..1} g\n 2. continuous_on {0..1} g \\<Longrightarrow>\n    continuous_on {0..1} (\\<lambda>t. g t - z)", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1} (\\<lambda>t. g t - z + z)", "show \"continuous_on {0..1} g\""], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>t. g t - z + z)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} g", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} g \\<Longrightarrow>\n    continuous_on {0..1} (\\<lambda>t. g t - z)", "qed (auto intro:continuous_intros)"], ["", "lemma not_on_circlepathI:\n  assumes \"cmod (z-z0) \\<noteq> \\<bar>r\\<bar>\"\n  shows \"z \\<notin> path_image (part_circlepath z0 r st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (part_circlepath z0 r st tt)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "assume \"\\<not> z \\<notin> path_image (part_circlepath z0 r st tt)\""], ["proof (state)\nthis:\n  \\<not> z \\<notin> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> z \\<notin> path_image (part_circlepath z0 r st tt)", "have \"z\\<in>path_image (part_circlepath z0 r st tt)\""], ["proof (prove)\nusing this:\n  \\<not> z \\<notin> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. z \\<in> path_image (part_circlepath z0 r st tt)", "by simp"], ["proof (state)\nthis:\n  z \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  z \\<in> path_image (part_circlepath z0 r st tt)", "obtain t where \"t\\<in>{0..1}\" and *:\"z = z0 + r * exp (\\<i> * (linepath st tt t))\""], ["proof (prove)\nusing this:\n  z \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {0..1};\n         z =\n         z0 +\n         complex_of_real r *\n         exp (\\<i> * complex_of_real (linepath st tt t))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def image_def part_circlepath_def"], ["proof (prove)\nusing this:\n  z \\<in> {y. \\<exists>x\\<in>{0..1}.\n                 y =\n                 z0 +\n                 complex_of_real r *\n                 exp (\\<i> * complex_of_real (linepath st tt x))}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {0..1};\n         z =\n         z0 +\n         complex_of_real r *\n         exp (\\<i> * complex_of_real (linepath st tt t))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> {0..1}\n  z =\n  z0 + complex_of_real r * exp (\\<i> * complex_of_real (linepath st tt t))\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "define \\<theta> where \"\\<theta> = linepath st tt t\""], ["proof (state)\nthis:\n  \\<theta> = linepath st tt t\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<theta> = linepath st tt t", "have \"z-z0 = r * exp (\\<i> * \\<theta>)\""], ["proof (prove)\nusing this:\n  \\<theta> = linepath st tt t\n\ngoal (1 subgoal):\n 1. z - z0 = complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)", "using *"], ["proof (prove)\nusing this:\n  \\<theta> = linepath st tt t\n  z =\n  z0 + complex_of_real r * exp (\\<i> * complex_of_real (linepath st tt t))\n\ngoal (1 subgoal):\n 1. z - z0 = complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)", "by auto"], ["proof (state)\nthis:\n  z - z0 = complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  z - z0 = complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)", "have \"cmod (z-z0) = cmod (r * exp (\\<i> * \\<theta>))\""], ["proof (prove)\nusing this:\n  z - z0 = complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)\n\ngoal (1 subgoal):\n 1. cmod (z - z0) =\n    cmod (complex_of_real r * exp (\\<i> * complex_of_real \\<theta>))", "by auto"], ["proof (state)\nthis:\n  cmod (z - z0) =\n  cmod (complex_of_real r * exp (\\<i> * complex_of_real \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  cmod (z - z0) =\n  cmod (complex_of_real r * exp (\\<i> * complex_of_real \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "have \"\\<dots> = \\<bar>r\\<bar> * cmod (exp (\\<i> * \\<theta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)) =\n    \\<bar>r\\<bar> * cmod (exp (\\<i> * complex_of_real \\<theta>))", "by (simp add: norm_mult)"], ["proof (state)\nthis:\n  cmod (complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)) =\n  \\<bar>r\\<bar> * cmod (exp (\\<i> * complex_of_real \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  cmod (complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)) =\n  \\<bar>r\\<bar> * cmod (exp (\\<i> * complex_of_real \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "have \"\\<dots> = \\<bar>r\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>r\\<bar> * cmod (exp (\\<i> * complex_of_real \\<theta>)) =\n    \\<bar>r\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>r\\<bar> * cmod (exp (\\<i> * complex_of_real \\<theta>)) =\n  \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  cmod (z - z0) = \\<bar>r\\<bar>", "have \"cmod (z-z0) = \\<bar>r\\<bar>\""], ["proof (prove)\nusing this:\n  cmod (z - z0) = \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. cmod (z - z0) = \\<bar>r\\<bar>", "."], ["proof (state)\nthis:\n  cmod (z - z0) = \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> z \\<notin> path_image\n                       (part_circlepath z0 r st tt) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  cmod (z - z0) = \\<bar>r\\<bar>", "show False"], ["proof (prove)\nusing this:\n  cmod (z - z0) = \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  cmod (z - z0) = \\<bar>r\\<bar>\n  cmod (z - z0) \\<noteq> \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circlepath_inj_on: \n  assumes \"r>0\"\n  shows \"inj_on (circlepath z r) {0..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (circlepath z r) {0..<1}", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume asm: \"x \\<in> {0..<1}\" \"y \\<in> {0..<1}\" \"circlepath z r x = circlepath z r y\""], ["proof (state)\nthis:\n  x \\<in> {0..<1}\n  y \\<in> {0..<1}\n  circlepath z r x = circlepath z r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "define c where \"c=2 * pi * \\<i>\""], ["proof (state)\nthis:\n  c = complex_of_real (2 * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"c\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from asm(3)"], ["proof (chain)\npicking this:\n  circlepath z r x = circlepath z r y", "have \"exp (c * x) =exp (c * y)\""], ["proof (prove)\nusing this:\n  circlepath z r x = circlepath z r y\n\ngoal (1 subgoal):\n 1. exp (c * complex_of_real x) = exp (c * complex_of_real y)", "unfolding circlepath c_def"], ["proof (prove)\nusing this:\n  z +\n  complex_of_real r *\n  exp (2 * complex_of_real pi * \\<i> * complex_of_real x) =\n  z +\n  complex_of_real r *\n  exp (2 * complex_of_real pi * \\<i> * complex_of_real y)\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi) * \\<i> * complex_of_real x) =\n    exp (complex_of_real (2 * pi) * \\<i> * complex_of_real y)", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  z +\n  complex_of_real r *\n  exp (2 * complex_of_real pi * \\<i> * complex_of_real x) =\n  z +\n  complex_of_real r *\n  exp (2 * complex_of_real pi * \\<i> * complex_of_real y)\n  0 < r\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi) * \\<i> * complex_of_real x) =\n    exp (complex_of_real (2 * pi) * \\<i> * complex_of_real y)", "by auto"], ["proof (state)\nthis:\n  exp (c * complex_of_real x) = exp (c * complex_of_real y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  exp (c * complex_of_real x) = exp (c * complex_of_real y)", "obtain n where \"c * x =c * (y + of_int n)\""], ["proof (prove)\nusing this:\n  exp (c * complex_of_real x) = exp (c * complex_of_real y)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        c * complex_of_real x =\n        c * complex_of_real (y + real_of_int n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:exp_eq c_def algebra_simps)"], ["proof (state)\nthis:\n  c * complex_of_real x = c * complex_of_real (y + real_of_int n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  c * complex_of_real x = c * complex_of_real (y + real_of_int n)", "have \"x=y+n\""], ["proof (prove)\nusing this:\n  c * complex_of_real x = c * complex_of_real (y + real_of_int n)\n\ngoal (1 subgoal):\n 1. x = y + real_of_int n", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c * complex_of_real x = c * complex_of_real (y + real_of_int n)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = y + real_of_int n", "by (meson mult_cancel_left of_real_eq_iff)"], ["proof (state)\nthis:\n  x = y + real_of_int n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<1}; y \\<in> {0..<1};\n        circlepath z r x = circlepath z r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x = y + real_of_int n", "show \"x=y\""], ["proof (prove)\nusing this:\n  x = y + real_of_int n\n\ngoal (1 subgoal):\n 1. x = y", "using asm(1,2)"], ["proof (prove)\nusing this:\n  x = y + real_of_int n\n  x \\<in> {0..<1}\n  y \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More lemmas related to @{term winding_number}\\<close>"], ["", "lemma winding_number_comp:\n  assumes \"open s\" \"f holomorphic_on s\" \"path_image \\<gamma> \\<subseteq> s\"  \n    \"valid_path \\<gamma>\" \"z \\<notin> path_image (f \\<circ> \\<gamma>)\" \n  shows \"winding_number (f \\<circ> \\<gamma>) z = 1/(2*pi*\\<i>)* contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "obtain spikes where \"finite spikes\" and \\<gamma>_diff: \"\\<gamma> C1_differentiable_on {0..1} - spikes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>spikes.\n        \\<lbrakk>finite spikes;\n         \\<gamma> C1_differentiable_on {0..1} - spikes\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>valid_path \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>spikes.\n        \\<lbrakk>finite spikes;\n         \\<gamma> C1_differentiable_on {0..1} - spikes\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding valid_path_def piecewise_C1_differentiable_on_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} \\<gamma> \\<and>\n  (\\<exists>S. finite S \\<and> \\<gamma> C1_differentiable_on {0..1} - S)\n\ngoal (1 subgoal):\n 1. (\\<And>spikes.\n        \\<lbrakk>finite spikes;\n         \\<gamma> C1_differentiable_on {0..1} - spikes\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite spikes\n  \\<gamma> C1_differentiable_on {0..1} - spikes\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "have \"valid_path (f \\<circ> \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (f \\<circ> \\<gamma>)", "using valid_path_compose_holomorphic assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?g; ?f holomorphic_on ?S; open ?S;\n   path_image ?g \\<subseteq> ?S\\<rbrakk>\n  \\<Longrightarrow> valid_path (?f \\<circ> ?g)\n  open s\n  f holomorphic_on s\n  path_image \\<gamma> \\<subseteq> s\n  valid_path \\<gamma>\n  z \\<notin> path_image (f \\<circ> \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path (f \\<circ> \\<gamma>)", "by blast"], ["proof (state)\nthis:\n  valid_path (f \\<circ> \\<gamma>)\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "moreover"], ["proof (state)\nthis:\n  valid_path (f \\<circ> \\<gamma>)\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "have \"contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) \n      = contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "unfolding contour_integral_integral"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         1 / ((f \\<circ> \\<gamma>) x - z) *\n         vector_derivative (f \\<circ> \\<gamma>) (at x)) =\n    integral {0..1}\n     (\\<lambda>x.\n         deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n         vector_derivative \\<gamma> (at x))", "proof (rule integral_spike[rule_format,OF negligible_finite[OF \\<open>finite spikes\\<close>]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - spikes \\<Longrightarrow>\n       deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n       vector_derivative \\<gamma> (at x) =\n       1 / ((f \\<circ> \\<gamma>) x - z) *\n       vector_derivative (f \\<circ> \\<gamma>) (at x)", "fix t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - spikes \\<Longrightarrow>\n       deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n       vector_derivative \\<gamma> (at x) =\n       1 / ((f \\<circ> \\<gamma>) x - z) *\n       vector_derivative (f \\<circ> \\<gamma>) (at x)", "assume t:\"t \\<in> {0..1} - spikes\""], ["proof (state)\nthis:\n  t \\<in> {0..1} - spikes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - spikes \\<Longrightarrow>\n       deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n       vector_derivative \\<gamma> (at x) =\n       1 / ((f \\<circ> \\<gamma>) x - z) *\n       vector_derivative (f \\<circ> \\<gamma>) (at x)", "then"], ["proof (chain)\npicking this:\n  t \\<in> {0..1} - spikes", "have \"\\<gamma> differentiable at t\""], ["proof (prove)\nusing this:\n  t \\<in> {0..1} - spikes\n\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at t", "using \\<gamma>_diff"], ["proof (prove)\nusing this:\n  t \\<in> {0..1} - spikes\n  \\<gamma> C1_differentiable_on {0..1} - spikes\n\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at t", "unfolding C1_differentiable_on_eq"], ["proof (prove)\nusing this:\n  t \\<in> {0..1} - spikes\n  (\\<forall>x\\<in>{0..1} - spikes. \\<gamma> differentiable at x) \\<and>\n  continuous_on ({0..1} - spikes)\n   (\\<lambda>x. vector_derivative \\<gamma> (at x))\n\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at t", "by auto"], ["proof (state)\nthis:\n  \\<gamma> differentiable at t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - spikes \\<Longrightarrow>\n       deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n       vector_derivative \\<gamma> (at x) =\n       1 / ((f \\<circ> \\<gamma>) x - z) *\n       vector_derivative (f \\<circ> \\<gamma>) (at x)", "moreover"], ["proof (state)\nthis:\n  \\<gamma> differentiable at t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - spikes \\<Longrightarrow>\n       deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n       vector_derivative \\<gamma> (at x) =\n       1 / ((f \\<circ> \\<gamma>) x - z) *\n       vector_derivative (f \\<circ> \\<gamma>) (at x)", "have \"f field_differentiable at (\\<gamma> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f field_differentiable at (\\<gamma> t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f field_differentiable at (\\<gamma> t)", "have \"\\<gamma> t \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> t \\<in> s", "using \\<open>path_image \\<gamma> \\<subseteq> s\\<close> t"], ["proof (prove)\nusing this:\n  path_image \\<gamma> \\<subseteq> s\n  t \\<in> {0..1} - spikes\n\ngoal (1 subgoal):\n 1. \\<gamma> t \\<in> s", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<gamma> ` {0..1} \\<subseteq> s\n  t \\<in> {0..1} - spikes\n\ngoal (1 subgoal):\n 1. \\<gamma> t \\<in> s", "by auto"], ["proof (state)\nthis:\n  \\<gamma> t \\<in> s\n\ngoal (1 subgoal):\n 1. f field_differentiable at (\\<gamma> t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<gamma> t \\<in> s\n\ngoal (1 subgoal):\n 1. f field_differentiable at (\\<gamma> t)", "using \\<open>open s\\<close> \\<open>f holomorphic_on s\\<close>  holomorphic_on_imp_differentiable_at"], ["proof (prove)\nusing this:\n  \\<gamma> t \\<in> s\n  open s\n  f holomorphic_on s\n  \\<lbrakk>?f holomorphic_on ?s; open ?s; ?x \\<in> ?s\\<rbrakk>\n  \\<Longrightarrow> ?f field_differentiable at ?x\n\ngoal (1 subgoal):\n 1. f field_differentiable at (\\<gamma> t)", "by blast"], ["proof (state)\nthis:\n  f field_differentiable at (\\<gamma> t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f field_differentiable at (\\<gamma> t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - spikes \\<Longrightarrow>\n       deriv f (\\<gamma> x) / (f (\\<gamma> x) - z) *\n       vector_derivative \\<gamma> (at x) =\n       1 / ((f \\<circ> \\<gamma>) x - z) *\n       vector_derivative (f \\<circ> \\<gamma>) (at x)", "ultimately"], ["proof (chain)\npicking this:\n  \\<gamma> differentiable at t\n  f field_differentiable at (\\<gamma> t)", "show \" deriv f (\\<gamma> t) / (f (\\<gamma> t) - z) * vector_derivative \\<gamma> (at t) =\n         1 / ((f \\<circ> \\<gamma>) t - z) * vector_derivative (f \\<circ> \\<gamma>) (at t)\""], ["proof (prove)\nusing this:\n  \\<gamma> differentiable at t\n  f field_differentiable at (\\<gamma> t)\n\ngoal (1 subgoal):\n 1. deriv f (\\<gamma> t) / (f (\\<gamma> t) - z) *\n    vector_derivative \\<gamma> (at t) =\n    1 / ((f \\<circ> \\<gamma>) t - z) *\n    vector_derivative (f \\<circ> \\<gamma>) (at t)", "apply (subst vector_derivative_chain_at_general)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<gamma> differentiable at t;\n     f field_differentiable at (\\<gamma> t)\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> differentiable at t\n 2. \\<lbrakk>\\<gamma> differentiable at t;\n     f field_differentiable at (\\<gamma> t)\\<rbrakk>\n    \\<Longrightarrow> f field_differentiable at (\\<gamma> t)\n 3. \\<lbrakk>\\<gamma> differentiable at t;\n     f field_differentiable at (\\<gamma> t)\\<rbrakk>\n    \\<Longrightarrow> deriv f (\\<gamma> t) / (f (\\<gamma> t) - z) *\n                      vector_derivative \\<gamma> (at t) =\n                      1 / ((f \\<circ> \\<gamma>) t - z) *\n                      (vector_derivative \\<gamma> (at t) *\n                       deriv f (\\<gamma> t))", "by (simp_all add:field_simps)"], ["proof (state)\nthis:\n  deriv f (\\<gamma> t) / (f (\\<gamma> t) - z) *\n  vector_derivative \\<gamma> (at t) =\n  1 / ((f \\<circ> \\<gamma>) t - z) *\n  vector_derivative (f \\<circ> \\<gamma>) (at t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n  contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "moreover"], ["proof (state)\nthis:\n  contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n  contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "note \\<open>z \\<notin> path_image (f \\<circ> \\<gamma>)\\<close>"], ["proof (state)\nthis:\n  z \\<notin> path_image (f \\<circ> \\<gamma>)\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "ultimately"], ["proof (chain)\npicking this:\n  valid_path (f \\<circ> \\<gamma>)\n  contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n  contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n  z \\<notin> path_image (f \\<circ> \\<gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path (f \\<circ> \\<gamma>)\n  contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n  contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n  z \\<notin> path_image (f \\<circ> \\<gamma>)\n\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "apply (subst winding_number_valid_path)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>valid_path (f \\<circ> \\<gamma>);\n     contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n     contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z));\n     z \\<notin> path_image (f \\<circ> \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> valid_path (f \\<circ> \\<gamma>)\n 2. \\<lbrakk>valid_path (f \\<circ> \\<gamma>);\n     contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n     contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z));\n     z \\<notin> path_image (f \\<circ> \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> z \\<notin> path_image (f \\<circ> \\<gamma>)\n 3. \\<lbrakk>valid_path (f \\<circ> \\<gamma>);\n     contour_integral (f \\<circ> \\<gamma>) (\\<lambda>w. 1 / (w - z)) =\n     contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z));\n     z \\<notin> path_image (f \\<circ> \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> 1 / (complex_of_real (2 * pi) * \\<i>) *\n                      contour_integral (f \\<circ> \\<gamma>)\n                       (\\<lambda>w. 1 / (w - z)) =\n                      1 / (complex_of_real (2 * pi) * \\<i>) *\n                      contour_integral \\<gamma>\n                       (\\<lambda>w. deriv f w / (f w - z))", "by simp_all"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  1 / (complex_of_real (2 * pi) * \\<i>) *\n  contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma winding_number_uminus_comp:\n  assumes \"valid_path \\<gamma>\" \"- z \\<notin> path_image \\<gamma>\" \n  shows \"winding_number (uminus \\<circ> \\<gamma>) z = winding_number \\<gamma> (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "define c where \"c= 2 * pi * \\<i>\""], ["proof (state)\nthis:\n  c = complex_of_real (2 * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "have \"winding_number (uminus \\<circ> \\<gamma>) z = 1/c * contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (-w-z)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    1 / c *\n    contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (- w - z))", "proof (rule winding_number_comp[of UNIV, folded c_def])"], ["proof (state)\ngoal (5 subgoals):\n 1. open UNIV\n 2. uminus holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>\n 5. z \\<notin> path_image (uminus \\<circ> \\<gamma>)", "show \"open UNIV\" \"uminus holomorphic_on UNIV\" \"path_image \\<gamma> \\<subseteq> UNIV\" \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (open UNIV &&& uminus holomorphic_on UNIV) &&&\n    path_image \\<gamma> \\<subseteq> UNIV &&& valid_path \\<gamma>", "using \\<open>valid_path \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. (open UNIV &&& uminus holomorphic_on UNIV) &&&\n    path_image \\<gamma> \\<subseteq> UNIV &&& valid_path \\<gamma>", "by (auto intro:holomorphic_intros)"], ["proof (state)\nthis:\n  open UNIV\n  uminus holomorphic_on UNIV\n  path_image \\<gamma> \\<subseteq> UNIV\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (uminus \\<circ> \\<gamma>)", "show \"z \\<notin> path_image (uminus \\<circ> \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (uminus \\<circ> \\<gamma>)", "unfolding path_image_compose"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> uminus ` path_image \\<gamma>", "using \\<open>- z \\<notin> path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  - z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> uminus ` path_image \\<gamma>", "by auto"], ["proof (state)\nthis:\n  z \\<notin> path_image (uminus \\<circ> \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number (uminus \\<circ> \\<gamma>) z =\n  1 / c * contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (- w - z))\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "also"], ["proof (state)\nthis:\n  winding_number (uminus \\<circ> \\<gamma>) z =\n  1 / c * contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (- w - z))\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "have \"\\<dots> = 1/c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w- (-z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / c *\n    contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (- w - z)) =\n    1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z))", "by (auto intro!:contour_integral_eq simp add:field_simps minus_divide_right)"], ["proof (state)\nthis:\n  1 / c *\n  contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (- w - z)) =\n  1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z))\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "also"], ["proof (state)\nthis:\n  1 / c *\n  contour_integral \\<gamma> (\\<lambda>w. deriv uminus w / (- w - z)) =\n  1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z))\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "have \"\\<dots> = winding_number \\<gamma> (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z)) =\n    winding_number \\<gamma> (- z)", "using winding_number_valid_path[OF \\<open>valid_path \\<gamma>\\<close> \\<open>- z \\<notin> path_image \\<gamma>\\<close>,folded c_def]"], ["proof (prove)\nusing this:\n  winding_number \\<gamma> (- z) =\n  1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z))\n\ngoal (1 subgoal):\n 1. 1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z)) =\n    winding_number \\<gamma> (- z)", "by simp"], ["proof (state)\nthis:\n  1 / c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - - z)) =\n  winding_number \\<gamma> (- z)\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "finally"], ["proof (chain)\npicking this:\n  winding_number (uminus \\<circ> \\<gamma>) z = winding_number \\<gamma> (- z)", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number (uminus \\<circ> \\<gamma>) z = winding_number \\<gamma> (- z)\n\ngoal (1 subgoal):\n 1. winding_number (uminus \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> (- z)", "by auto"], ["proof (state)\nthis:\n  winding_number (uminus \\<circ> \\<gamma>) z = winding_number \\<gamma> (- z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma winding_number_comp_linear:\n  assumes \"c\\<noteq>0\" \"valid_path \\<gamma>\" and not_image: \"(z-b)/c \\<notin> path_image \\<gamma>\"\n  shows \"winding_number ((\\<lambda>x. c*x+b) \\<circ> \\<gamma>) z = winding_number \\<gamma> ((z-b)/c)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "define cc where \"cc=1 / (complex_of_real (2 * pi) * \\<i>)\""], ["proof (state)\nthis:\n  cc = 1 / (complex_of_real (2 * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "define zz where \"zz=(z-b)/c\""], ["proof (state)\nthis:\n  zz = (z - b) / c\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "have \"?L = cc * contour_integral \\<gamma> (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "apply (subst winding_number_comp[of UNIV,simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<lambda>x. c * x + b) holomorphic_on UNIV\n 2. valid_path \\<gamma>\n 3. z \\<notin> path_image ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>)\n 4. contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. c * x + b) holomorphic_on UNIV", "by (auto intro:holomorphic_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. valid_path \\<gamma>\n 2. z \\<notin> path_image ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>)\n 3. contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using \\<open>valid_path \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "."], ["proof (prove)\ngoal (2 subgoals):\n 1. z \\<notin> path_image ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>)\n 2. contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>)", "using not_image \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (z - b) / c \\<notin> path_image \\<gamma>\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>)", "unfolding path_image_compose"], ["proof (prove)\nusing this:\n  (z - b) / c \\<notin> path_image \\<gamma>\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<lambda>x. c * x + b) ` path_image \\<gamma>", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "unfolding cc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) /\n    (2 * complex_of_real pi * \\<i>) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n  cc *\n  contour_integral \\<gamma>\n   (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "also"], ["proof (state)\nthis:\n  winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n  cc *\n  contour_integral \\<gamma>\n   (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z))\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "have \"\\<dots> = cc * contour_integral \\<gamma> (\\<lambda>w.1 / (w - zz))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n    cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n    cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))", "have \"deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)", "by (auto intro:derivative_intros)"], ["proof (state)\nthis:\n  deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)\n\ngoal (1 subgoal):\n 1. cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n    cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))", "then"], ["proof (chain)\npicking this:\n  deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)", "show ?thesis"], ["proof (prove)\nusing this:\n  deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)\n\ngoal (1 subgoal):\n 1. cc *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n    cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))", "unfolding zz_def cc_def"], ["proof (prove)\nusing this:\n  deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)\n\ngoal (1 subgoal):\n 1. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. 1 / (w - (z - b) / c))", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  deriv (\\<lambda>x. c * x + b) = (\\<lambda>x. c)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. 1 / (w - (z - b) / c))", "by (auto simp:field_simps)"], ["proof (state)\nthis:\n  cc *\n  contour_integral \\<gamma>\n   (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n  cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cc *\n  contour_integral \\<gamma>\n   (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n  cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "also"], ["proof (state)\nthis:\n  cc *\n  contour_integral \\<gamma>\n   (\\<lambda>w. deriv (\\<lambda>x. c * x + b) w / (c * w + b - z)) =\n  cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "have \"\\<dots> = winding_number \\<gamma> zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz)) =\n    winding_number \\<gamma> zz", "using winding_number_valid_path[OF \\<open>valid_path \\<gamma>\\<close> not_image,folded zz_def cc_def]"], ["proof (prove)\nusing this:\n  winding_number \\<gamma> zz =\n  cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz))\n\ngoal (1 subgoal):\n 1. cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz)) =\n    winding_number \\<gamma> zz", "by simp"], ["proof (state)\nthis:\n  cc * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - zz)) =\n  winding_number \\<gamma> zz\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> ((z - b) / c)", "finally"], ["proof (chain)\npicking this:\n  winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n  winding_number \\<gamma> zz", "show \"winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z = winding_number \\<gamma> zz\""], ["proof (prove)\nusing this:\n  winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n  winding_number \\<gamma> zz\n\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n    winding_number \\<gamma> zz", "."], ["proof (state)\nthis:\n  winding_number ((\\<lambda>x. c * x + b) \\<circ> \\<gamma>) z =\n  winding_number \\<gamma> zz\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}