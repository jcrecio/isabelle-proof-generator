{"file_name": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval/Winding_Number_Eval_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval", "problem_names": ["lemma example1:\n  assumes \"R>1\"\n  shows \"winding_number (part_circlepath 0 R 0 pi +++ linepath (-R) R) \\<i> = 1\"", "lemma example2:\n  assumes \"R>1\"\n  shows \"winding_number (part_circlepath 0 R 0 pi +++ linepath (-R) R) (-\\<i>) = 0\"", "lemma example3:\n  fixes lb ub z :: complex\n  defines \"rec \\<equiv>  linepath lb (Complex (Re ub) (Im lb)) +++ linepath (Complex (Re ub) (Im lb)) ub \n              +++ linepath ub (Complex (Re lb) (Im ub)) +++ linepath (Complex (Re lb) (Im ub)) lb\"\n  assumes order_asms:\"Re lb < Re z\" \"Re z < Re ub\" \"Im lb < Im z\" \"Im z < Im ub\"\n  shows \"winding_number rec z = 1\""], "translations": [["", "lemma example1:\n  assumes \"R>1\"\n  shows \"winding_number (part_circlepath 0 R 0 pi +++ linepath (-R) R) \\<i> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (part_circlepath 0 R 0 pi +++\n      (\\<lambda>x. complex_of_real (linepath (- R) R x)))\n     \\<i> =\n    1", "proof (eval_winding,simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)\n 2. \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 3. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "define CR where  \"CR \\<equiv>part_circlepath 0 R 0 pi\""], ["proof (state)\nthis:\n  CR \\<equiv> part_circlepath 0 R 0 pi\n\ngoal (3 subgoals):\n 1. \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)\n 2. \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 3. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "define L where \"L\\<equiv> linepath (- (complex_of_real R)) R\""], ["proof (state)\nthis:\n  L \\<equiv> linepath (- complex_of_real R) (complex_of_real R)\n\ngoal (3 subgoals):\n 1. \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)\n 2. \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 3. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "show \"\\<i> \\<notin> path_image CR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> \\<notin> path_image CR", "unfolding CR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)", "using \\<open>R>1\\<close>"], ["proof (prove)\nusing this:\n  1 < R\n\ngoal (1 subgoal):\n 1. \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)", "by (intro not_on_circlepathI,auto)"], ["proof (state)\nthis:\n  \\<i> \\<notin> path_image CR\n\ngoal (2 subgoals):\n 1. \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 2. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "show *:\"\\<i> \\<notin> closed_segment (- (of_real R)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)", "using \\<open>R>1\\<close> complex_eq_iff"], ["proof (prove)\nusing this:\n  1 < R\n  (?x = ?y) = (Re ?x = Re ?y \\<and> Im ?x = Im ?y)\n\ngoal (1 subgoal):\n 1. \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)", "by (intro not_on_closed_segmentI,auto)"], ["proof (state)\nthis:\n  \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n\ngoal (1 subgoal):\n 1. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "from cindex_pathE_linepath[OF this]"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n  (let c1 = Re (- complex_of_real R) - Re \\<i>;\n       c2 = Re (complex_of_real R) - Re \\<i>;\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re \\<i> * Im (complex_of_real R) +\n            Im \\<i> * Re (- complex_of_real R) -\n            Im \\<i> * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re \\<i> * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im \\<i>;\n       d2 = Im (complex_of_real R) - Im \\<i>\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)", "have \"cindex_pathE L \\<i> = -1\""], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n  (let c1 = Re (- complex_of_real R) - Re \\<i>;\n       c2 = Re (complex_of_real R) - Re \\<i>;\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re \\<i> * Im (complex_of_real R) +\n            Im \\<i> * Re (- complex_of_real R) -\n            Im \\<i> * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re \\<i> * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im \\<i>;\n       d2 = Im (complex_of_real R) - Im \\<i>\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE L \\<i> = - 1", "unfolding L_def"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n  (let c1 = Re (- complex_of_real R) - Re \\<i>;\n       c2 = Re (complex_of_real R) - Re \\<i>;\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re \\<i> * Im (complex_of_real R) +\n            Im \\<i> * Re (- complex_of_real R) -\n            Im \\<i> * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re \\<i> * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im \\<i>;\n       d2 = Im (complex_of_real R) - Im \\<i>\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n    - 1", "using \\<open>R>1\\<close>"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n  (let c1 = Re (- complex_of_real R) - Re \\<i>;\n       c2 = Re (complex_of_real R) - Re \\<i>;\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re \\<i> * Im (complex_of_real R) +\n            Im \\<i> * Re (- complex_of_real R) -\n            Im \\<i> * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re \\<i> * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im \\<i>;\n       d2 = Im (complex_of_real R) - Im \\<i>\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n  1 < R\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n    - 1", "by auto"], ["proof (state)\nthis:\n  cindex_pathE L \\<i> = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "moreover"], ["proof (state)\nthis:\n  cindex_pathE L \\<i> = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "have \"cindex_pathE CR \\<i> = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE CR \\<i> = - 1", "unfolding CR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 R 0 pi) \\<i> = - 1", "using \\<open>R>1\\<close>"], ["proof (prove)\nusing this:\n  1 < R\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 R 0 pi) \\<i> = - 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. 1 < R \\<Longrightarrow> cmod (0 - \\<i>) \\<noteq> R\n 2. 1 < R \\<Longrightarrow> 0 < R\n 3. 1 < R \\<Longrightarrow> 0 \\<le> 0\n 4. 1 < R \\<Longrightarrow> 0 < pi\n 5. 1 < R \\<Longrightarrow> pi \\<le> 2 * pi\n 6. 1 < R \\<Longrightarrow>\n    (if \\<bar>Re 0 - Re \\<i>\\<bar> < R\n     then let \\<theta> = arccos ((Re \\<i> - Re 0) / R);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath 0 R 0 pi) \\<i> +\n             (if 0 < \\<theta> \\<and> \\<theta> < pi\n              then if Im \\<i> < R * sin \\<theta> + Im 0 then - 1 else 1\n              else 0) +\n             (if 0 < \\<beta> \\<and> \\<beta> < pi\n              then if Im \\<i> < R * sin \\<beta> + Im 0 then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath 0 R 0 pi) \\<i>\n     else if \\<bar>Re 0 - Re \\<i>\\<bar> = R\n          then jumpF_pathstart (part_circlepath 0 R 0 pi) \\<i> -\n               jumpF_pathfinish (part_circlepath 0 R 0 pi) \\<i>\n          else 0) =\n    - 1", "by (simp_all add:jumpF_pathstart_part_circlepath jumpF_pathfinish_part_circlepath)"], ["proof (state)\nthis:\n  cindex_pathE CR \\<i> = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE L \\<i> = - 1\n  cindex_pathE CR \\<i> = - 1", "show \"- complex_of_real (cindex_pathE CR \\<i>) - cindex_pathE L \\<i> = 2\""], ["proof (prove)\nusing this:\n  cindex_pathE L \\<i> = - 1\n  cindex_pathE CR \\<i> = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real (cindex_pathE CR \\<i>) -\n    complex_of_real (cindex_pathE L \\<i>) =\n    2", "unfolding L_def CR_def"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R)) \\<i> =\n  - 1\n  cindex_pathE (part_circlepath 0 R 0 pi) \\<i> = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real (cindex_pathE (part_circlepath 0 R 0 pi) \\<i>) -\n    complex_of_real\n     (cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n       \\<i>) =\n    2", "by auto"], ["proof (state)\nthis:\n  - complex_of_real (cindex_pathE CR \\<i>) -\n  complex_of_real (cindex_pathE L \\<i>) =\n  2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma example2:\n  assumes \"R>1\"\n  shows \"winding_number (part_circlepath 0 R 0 pi +++ linepath (-R) R) (-\\<i>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (part_circlepath 0 R 0 pi +++\n      (\\<lambda>x. complex_of_real (linepath (- R) R x)))\n     (- \\<i>) =\n    0", "proof (eval_winding,simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. - \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)\n 2. - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 3. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "define CR where  \"CR \\<equiv>part_circlepath 0 R 0 pi\""], ["proof (state)\nthis:\n  CR \\<equiv> part_circlepath 0 R 0 pi\n\ngoal (3 subgoals):\n 1. - \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)\n 2. - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 3. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "define L where \"L\\<equiv> linepath (- (complex_of_real R)) R\""], ["proof (state)\nthis:\n  L \\<equiv> linepath (- complex_of_real R) (complex_of_real R)\n\ngoal (3 subgoals):\n 1. - \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)\n 2. - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 3. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "show \"-\\<i> \\<notin> path_image CR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<i> \\<notin> path_image CR", "unfolding CR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)", "using \\<open>R>1\\<close>"], ["proof (prove)\nusing this:\n  1 < R\n\ngoal (1 subgoal):\n 1. - \\<i> \\<notin> path_image (part_circlepath 0 R 0 pi)", "by (intro not_on_circlepathI,auto)"], ["proof (state)\nthis:\n  - \\<i> \\<notin> path_image CR\n\ngoal (2 subgoals):\n 1. - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n 2. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "show *:\"-\\<i> \\<notin> closed_segment (- (of_real R)) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)", "using \\<open>R>1\\<close> complex_eq_iff"], ["proof (prove)\nusing this:\n  1 < R\n  (?x = ?y) = (Re ?x = Re ?y \\<and> Im ?x = Im ?y)\n\ngoal (1 subgoal):\n 1. - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)", "by (intro not_on_closed_segmentI,auto)"], ["proof (state)\nthis:\n  - \\<i> \\<notin> closed_segment (- complex_of_real R) (complex_of_real R)\n\ngoal (1 subgoal):\n 1. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "from cindex_pathE_linepath[OF this]"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n   (- \\<i>) =\n  (let c1 = Re (- complex_of_real R) - Re (- \\<i>);\n       c2 = Re (complex_of_real R) - Re (- \\<i>);\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re (- \\<i>) * Im (complex_of_real R) +\n            Im (- \\<i>) * Re (- complex_of_real R) -\n            Im (- \\<i>) * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re (- \\<i>) * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im (- \\<i>);\n       d2 = Im (complex_of_real R) - Im (- \\<i>)\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)", "have \"cindex_pathE L (-\\<i>) = 1\""], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n   (- \\<i>) =\n  (let c1 = Re (- complex_of_real R) - Re (- \\<i>);\n       c2 = Re (complex_of_real R) - Re (- \\<i>);\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re (- \\<i>) * Im (complex_of_real R) +\n            Im (- \\<i>) * Re (- complex_of_real R) -\n            Im (- \\<i>) * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re (- \\<i>) * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im (- \\<i>);\n       d2 = Im (complex_of_real R) - Im (- \\<i>)\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE L (- \\<i>) = 1", "unfolding L_def"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n   (- \\<i>) =\n  (let c1 = Re (- complex_of_real R) - Re (- \\<i>);\n       c2 = Re (complex_of_real R) - Re (- \\<i>);\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re (- \\<i>) * Im (complex_of_real R) +\n            Im (- \\<i>) * Re (- complex_of_real R) -\n            Im (- \\<i>) * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re (- \\<i>) * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im (- \\<i>);\n       d2 = Im (complex_of_real R) - Im (- \\<i>)\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>) =\n    1", "using \\<open>R>1\\<close>"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n   (- \\<i>) =\n  (let c1 = Re (- complex_of_real R) - Re (- \\<i>);\n       c2 = Re (complex_of_real R) - Re (- \\<i>);\n       c3 = Im (- complex_of_real R) * Re (complex_of_real R) +\n            Re (- \\<i>) * Im (complex_of_real R) +\n            Im (- \\<i>) * Re (- complex_of_real R) -\n            Im (- \\<i>) * Re (complex_of_real R) -\n            Im (complex_of_real R) * Re (- complex_of_real R) -\n            Re (- \\<i>) * Im (- complex_of_real R);\n       d1 = Im (- complex_of_real R) - Im (- \\<i>);\n       d2 = Im (complex_of_real R) - Im (- \\<i>)\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n  1 < R\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>) =\n    1", "by auto"], ["proof (state)\nthis:\n  cindex_pathE L (- \\<i>) = 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE L (- \\<i>) = 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "have \"cindex_pathE CR (-\\<i>) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE CR (- \\<i>) = - 1", "unfolding CR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) = - 1", "using \\<open>R>1\\<close>"], ["proof (prove)\nusing this:\n  1 < R\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) = - 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. 1 < R \\<Longrightarrow> cmod (0 - - \\<i>) \\<noteq> R\n 2. 1 < R \\<Longrightarrow> 0 < R\n 3. 1 < R \\<Longrightarrow> 0 \\<le> 0\n 4. 1 < R \\<Longrightarrow> 0 < pi\n 5. 1 < R \\<Longrightarrow> pi \\<le> 2 * pi\n 6. 1 < R \\<Longrightarrow>\n    (if \\<bar>Re 0 - Re (- \\<i>)\\<bar> < R\n     then let \\<theta> = arccos ((Re (- \\<i>) - Re 0) / R);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath 0 R 0 pi) (- \\<i>) +\n             (if 0 < \\<theta> \\<and> \\<theta> < pi\n              then if Im (- \\<i>) < R * sin \\<theta> + Im 0 then - 1 else 1\n              else 0) +\n             (if 0 < \\<beta> \\<and> \\<beta> < pi\n              then if Im (- \\<i>) < R * sin \\<beta> + Im 0 then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath 0 R 0 pi) (- \\<i>)\n     else if \\<bar>Re 0 - Re (- \\<i>)\\<bar> = R\n          then jumpF_pathstart (part_circlepath 0 R 0 pi) (- \\<i>) -\n               jumpF_pathfinish (part_circlepath 0 R 0 pi) (- \\<i>)\n          else 0) =\n    - 1", "by (simp_all add:jumpF_pathstart_part_circlepath jumpF_pathfinish_part_circlepath)"], ["proof (state)\nthis:\n  cindex_pathE CR (- \\<i>) = - 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE L (- \\<i>) = 1\n  cindex_pathE CR (- \\<i>) = - 1", "show \"-cindex_pathE CR (-\\<i>) = cindex_pathE L (-\\<i>)\""], ["proof (prove)\nusing this:\n  cindex_pathE L (- \\<i>) = 1\n  cindex_pathE CR (- \\<i>) = - 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE CR (- \\<i>) = cindex_pathE L (- \\<i>)", "unfolding L_def CR_def"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n   (- \\<i>) =\n  1\n  cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) = - 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (part_circlepath 0 R 0 pi) (- \\<i>) =\n    cindex_pathE (linepath (- complex_of_real R) (complex_of_real R))\n     (- \\<i>)", "by auto"], ["proof (state)\nthis:\n  - cindex_pathE CR (- \\<i>) = cindex_pathE L (- \\<i>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma example3:\n  fixes lb ub z :: complex\n  defines \"rec \\<equiv>  linepath lb (Complex (Re ub) (Im lb)) +++ linepath (Complex (Re ub) (Im lb)) ub \n              +++ linepath ub (Complex (Re lb) (Im ub)) +++ linepath (Complex (Re lb) (Im ub)) lb\"\n  assumes order_asms:\"Re lb < Re z\" \"Re z < Re ub\" \"Im lb < Im z\" \"Im z < Im ub\"\n  shows \"winding_number rec z = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number rec z = 1", "unfolding rec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (linepath lb (Complex (Re ub) (Im lb)) +++\n      linepath (Complex (Re ub) (Im lb)) ub +++\n      linepath ub (Complex (Re lb) (Im ub)) +++\n      linepath (Complex (Re lb) (Im ub)) lb)\n     z =\n    1", "proof (eval_winding)"], ["proof (state)\ngoal (5 subgoals):\n 1. z \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n 2. z \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n 3. z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n 4. z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 5. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "let ?l1 = \"linepath lb (Complex (Re ub) (Im lb))\"\n  and ?l2 = \"linepath (Complex (Re ub) (Im lb)) ub\"\n  and ?l3 = \"linepath ub (Complex (Re lb) (Im ub))\"\n  and ?l4 = \"linepath (Complex (Re lb) (Im ub)) lb\""], ["proof (state)\ngoal (5 subgoals):\n 1. z \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n 2. z \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n 3. z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n 4. z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 5. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "show l1: \"z \\<notin> path_image ?l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))", "apply (auto intro!: not_on_closed_segmentI_complex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re ub - Re z) * (Im z - Im lb) =\n    (Im lb - Im z) * (Re z - Re lb) \\<Longrightarrow>\n    False", "using order_asms"], ["proof (prove)\nusing this:\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (1 subgoal):\n 1. (Re ub - Re z) * (Im z - Im lb) =\n    (Im lb - Im z) * (Re z - Re lb) \\<Longrightarrow>\n    False", "by (simp add: algebra_simps crossproduct_eq)"], ["proof (state)\nthis:\n  z \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n\ngoal (4 subgoals):\n 1. z \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n 2. z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n 3. z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 4. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "show l2:\"z \\<notin> path_image ?l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)", "apply (auto intro!: not_on_closed_segmentI_complex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re ub - Re z) * (Im z - Im lb) =\n    (Im ub - Im z) * (Re z - Re ub) \\<Longrightarrow>\n    False", "using order_asms"], ["proof (prove)\nusing this:\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (1 subgoal):\n 1. (Re ub - Re z) * (Im z - Im lb) =\n    (Im ub - Im z) * (Re z - Re ub) \\<Longrightarrow>\n    False", "by (simp add: algebra_simps crossproduct_eq)"], ["proof (state)\nthis:\n  z \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n\ngoal (3 subgoals):\n 1. z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n 2. z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 3. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "show l3:\"z \\<notin> path_image ?l3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))", "apply (auto intro!: not_on_closed_segmentI_complex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re lb - Re z) * (Im z - Im ub) =\n    (Im ub - Im z) * (Re z - Re ub) \\<Longrightarrow>\n    False", "using order_asms"], ["proof (prove)\nusing this:\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (1 subgoal):\n 1. (Re lb - Re z) * (Im z - Im ub) =\n    (Im ub - Im z) * (Re z - Re ub) \\<Longrightarrow>\n    False", "by (simp add: algebra_simps crossproduct_eq)"], ["proof (state)\nthis:\n  z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n\ngoal (2 subgoals):\n 1. z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 2. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "show l4:\"z \\<notin> path_image ?l4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)", "apply (auto intro!: not_on_closed_segmentI_complex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re lb - Re z) * (Im z - Im ub) =\n    (Im lb - Im z) * (Re z - Re lb) \\<Longrightarrow>\n    False", "using order_asms"], ["proof (prove)\nusing this:\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (1 subgoal):\n 1. (Re lb - Re z) * (Im z - Im ub) =\n    (Im lb - Im z) * (Re z - Re lb) \\<Longrightarrow>\n    False", "by (simp add: algebra_simps crossproduct_eq)"], ["proof (state)\nthis:\n  z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "show \"- complex_of_real (cindex_pathE ?l1 z + (cindex_pathE ?l2 z + (cindex_pathE ?l3 z +\n          cindex_pathE ?l4 z))) = 2 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "have \"(Im z - Im ub) * (Re ub - Re lb) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im z - Im ub) * (Re ub - Re lb) < 0", "using mult_less_0_iff order_asms(1) order_asms(2) order_asms(4)"], ["proof (prove)\nusing this:\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n  Re lb < Re z\n  Re z < Re ub\n  Im z < Im ub\n\ngoal (1 subgoal):\n 1. (Im z - Im ub) * (Re ub - Re lb) < 0", "by fastforce"], ["proof (state)\nthis:\n  (Im z - Im ub) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "then"], ["proof (chain)\npicking this:\n  (Im z - Im ub) * (Re ub - Re lb) < 0", "have \"cindex_pathE ?l3 z = -1\""], ["proof (prove)\nusing this:\n  (Im z - Im ub) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z = - 1", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Im z - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    z \\<notin> closed_segment ub (Complex (Re lb) (Im ub))\n 2. (Im z - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re ub - Re z; c2 = Re (Complex (Re lb) (Im ub)) - Re z;\n         c3 = Im ub * Re (Complex (Re lb) (Im ub)) +\n              Re z * Im (Complex (Re lb) (Im ub)) +\n              Im z * Re ub -\n              Im z * Re (Complex (Re lb) (Im ub)) -\n              Im (Complex (Re lb) (Im ub)) * Re ub -\n              Re z * Im ub;\n         d1 = Im ub - Im z; d2 = Im (Complex (Re lb) (Im ub)) - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "using l3 order_asms"], ["proof (prove)\nusing this:\n  z \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (2 subgoals):\n 1. (Im z - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    z \\<notin> closed_segment ub (Complex (Re lb) (Im ub))\n 2. (Im z - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re ub - Re z; c2 = Re (Complex (Re lb) (Im ub)) - Re z;\n         c3 = Im ub * Re (Complex (Re lb) (Im ub)) +\n              Re z * Im (Complex (Re lb) (Im ub)) +\n              Im z * Re ub -\n              Im z * Re (Complex (Re lb) (Im ub)) -\n              Im (Complex (Re lb) (Im ub)) * Re ub -\n              Re z * Im ub;\n         d1 = Im ub - Im z; d2 = Im (Complex (Re lb) (Im ub)) - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "have \"(Im lb - Im z) * (Re ub - Re lb) <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im lb - Im z) * (Re ub - Re lb) < 0", "using mult_less_0_iff order_asms(1) order_asms(2) order_asms(3)"], ["proof (prove)\nusing this:\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n\ngoal (1 subgoal):\n 1. (Im lb - Im z) * (Re ub - Re lb) < 0", "by fastforce"], ["proof (state)\nthis:\n  (Im lb - Im z) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "then"], ["proof (chain)\npicking this:\n  (Im lb - Im z) * (Re ub - Re lb) < 0", "have \"cindex_pathE ?l1 z = -1\""], ["proof (prove)\nusing this:\n  (Im lb - Im z) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z = - 1", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Im lb - Im z) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    z \\<notin> closed_segment lb (Complex (Re ub) (Im lb))\n 2. (Im lb - Im z) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re lb - Re z; c2 = Re (Complex (Re ub) (Im lb)) - Re z;\n         c3 = Im lb * Re (Complex (Re ub) (Im lb)) +\n              Re z * Im (Complex (Re ub) (Im lb)) +\n              Im z * Re lb -\n              Im z * Re (Complex (Re ub) (Im lb)) -\n              Im (Complex (Re ub) (Im lb)) * Re lb -\n              Re z * Im lb;\n         d1 = Im lb - Im z; d2 = Im (Complex (Re ub) (Im lb)) - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "using l1 order_asms"], ["proof (prove)\nusing this:\n  z \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (2 subgoals):\n 1. (Im lb - Im z) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    z \\<notin> closed_segment lb (Complex (Re ub) (Im lb))\n 2. (Im lb - Im z) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re lb - Re z; c2 = Re (Complex (Re ub) (Im lb)) - Re z;\n         c3 = Im lb * Re (Complex (Re ub) (Im lb)) +\n              Re z * Im (Complex (Re ub) (Im lb)) +\n              Im z * Re lb -\n              Im z * Re (Complex (Re ub) (Im lb)) -\n              Im (Complex (Re ub) (Im lb)) * Re lb -\n              Re z * Im lb;\n         d1 = Im lb - Im z; d2 = Im (Complex (Re ub) (Im lb)) - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "have \"cindex_pathE ?l2 z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z = 0", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. z \\<notin> closed_segment (Complex (Re ub) (Im lb)) ub\n 2. (let c1 = Re (Complex (Re ub) (Im lb)) - Re z; c2 = Re ub - Re z;\n         c3 = Im (Complex (Re ub) (Im lb)) * Re ub + Re z * Im ub +\n              Im z * Re (Complex (Re ub) (Im lb)) -\n              Im z * Re ub -\n              Im ub * Re (Complex (Re ub) (Im lb)) -\n              Re z * Im (Complex (Re ub) (Im lb));\n         d1 = Im (Complex (Re ub) (Im lb)) - Im z; d2 = Im ub - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "using l2 order_asms"], ["proof (prove)\nusing this:\n  z \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (2 subgoals):\n 1. z \\<notin> closed_segment (Complex (Re ub) (Im lb)) ub\n 2. (let c1 = Re (Complex (Re ub) (Im lb)) - Re z; c2 = Re ub - Re z;\n         c3 = Im (Complex (Re ub) (Im lb)) * Re ub + Re z * Im ub +\n              Im z * Re (Complex (Re ub) (Im lb)) -\n              Im z * Re ub -\n              Im ub * Re (Complex (Re ub) (Im lb)) -\n              Re z * Im (Complex (Re ub) (Im lb));\n         d1 = Im (Complex (Re ub) (Im lb)) - Im z; d2 = Im ub - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z = 0\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z = 0\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "have \"cindex_pathE ?l4 z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z = 0", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. z \\<notin> closed_segment (Complex (Re lb) (Im ub)) lb\n 2. (let c1 = Re (Complex (Re lb) (Im ub)) - Re z; c2 = Re lb - Re z;\n         c3 = Im (Complex (Re lb) (Im ub)) * Re lb + Re z * Im lb +\n              Im z * Re (Complex (Re lb) (Im ub)) -\n              Im z * Re lb -\n              Im lb * Re (Complex (Re lb) (Im ub)) -\n              Re z * Im (Complex (Re lb) (Im ub));\n         d1 = Im (Complex (Re lb) (Im ub)) - Im z; d2 = Im lb - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "using l4 order_asms"], ["proof (prove)\nusing this:\n  z \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n  Re lb < Re z\n  Re z < Re ub\n  Im lb < Im z\n  Im z < Im ub\n\ngoal (2 subgoals):\n 1. z \\<notin> closed_segment (Complex (Re lb) (Im ub)) lb\n 2. (let c1 = Re (Complex (Re lb) (Im ub)) - Re z; c2 = Re lb - Re z;\n         c3 = Im (Complex (Re lb) (Im ub)) * Re lb + Re z * Im lb +\n              Im z * Re (Complex (Re lb) (Im ub)) -\n              Im z * Re lb -\n              Im lb * Re (Complex (Re lb) (Im ub)) -\n              Re z * Im (Complex (Re lb) (Im ub));\n         d1 = Im (Complex (Re lb) (Im ub)) - Im z; d2 = Im lb - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z = 0\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z = - 1\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z = - 1\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z = 0\n  cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z = - 1\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z = - 1\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z = 0\n  cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z = 0\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n    2 * 1", "by auto"], ["proof (state)\nthis:\n  - complex_of_real\n     (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n      (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n       (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n        cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n  2 * 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - complex_of_real\n     (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) z +\n      (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) z +\n       (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) z +\n        cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) z))) =\n  2 * 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}