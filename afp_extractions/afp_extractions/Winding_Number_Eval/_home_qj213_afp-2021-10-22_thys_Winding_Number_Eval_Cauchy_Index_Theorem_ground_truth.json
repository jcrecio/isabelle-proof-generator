{"file_name": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval/Cauchy_Index_Theorem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval", "problem_names": ["lemma atMostAtLeast_subset_convex:\n  fixes C :: \"real set\"\n  assumes \"convex C\"\n    and \"x \\<in> C\" \"y \\<in> C\" \n  shows \"{x .. y} \\<subseteq> C\"", "lemma arg_elim:\n  \"f x \\<Longrightarrow> x= y \\<Longrightarrow> f y\"", "lemma arg_elim2:\n  \"f x1 x2 \\<Longrightarrow> x1= y1 \\<Longrightarrow>x2=y2 \\<Longrightarrow> f y1 y2\"", "lemma arg_elim3:\n  \"\\<lbrakk>f x1 x2 x3;x1= y1;x2=y2;x3=y3 \\<rbrakk> \\<Longrightarrow> f y1 y2 y3\"", "lemma IVT_strict:\n  fixes f :: \"'a::linear_continuum_topology \\<Rightarrow> 'b::linorder_topology\"\n  assumes \"(f a > y \\<and> y > f b) \\<or> (f a < y \\<and> y < f b)\" \"a<b\" \"continuous_on {a .. b} f\"\n  shows \"\\<exists>x. a < x \\<and> x < b \\<and> f x = y\"", "lemma (in dense_linorder) atLeastAtMost_subseteq_greaterThanLessThan_iff:\n  \"{a .. b} \\<subseteq> { c <..< d } \\<longleftrightarrow> (a \\<le> b \\<longrightarrow> c < a \\<and> b < d)\"", "lemma Re_winding_number_half_right:\n  assumes \"\\<forall>p\\<in>path_image \\<gamma>. Re p \\<ge> Re z\" and \"valid_path \\<gamma>\" and  \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z)))/(2*pi)\"", "lemma Re_winding_number_half_upper:\n  assumes pimage:\"\\<forall>p\\<in>path_image \\<gamma>. Im p \\<ge> Im z\" and \"valid_path \\<gamma>\" and \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = \n            (Im (Ln (\\<i>*z - \\<i>*pathfinish \\<gamma>)) - Im (Ln (\\<i>*z - \\<i>*pathstart \\<gamma> )))/(2*pi)\"", "lemma Re_winding_number_half_lower:\n  assumes pimage:\"\\<forall>p\\<in>path_image \\<gamma>. Im p \\<le> Im z\" and \"valid_path \\<gamma>\" and \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = \n             (Im (Ln ( \\<i>*pathfinish \\<gamma> - \\<i>*z)) - Im (Ln (\\<i>*pathstart \\<gamma> - \\<i>*z)))/(2*pi)\"", "lemma Re_winding_number_half_left:\n  assumes neg_img:\"\\<forall>p\\<in>path_image \\<gamma>. Re p \\<le> Re z\" and \"valid_path \\<gamma>\" and \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma> )))/(2*pi)\"", "lemma continuous_on_open_Collect_neq:\n  fixes f g :: \"'a::topological_space \\<Rightarrow> 'b::t2_space\"\n  assumes f: \"continuous_on S f\" and g: \"continuous_on S g\" and \"open S\"\n  shows \"open {x\\<in>S. f x \\<noteq> g x}\"", "lemma has_sgnx_eq_rhs: \"(f has_sgnx x) F \\<Longrightarrow> x = y \\<Longrightarrow> (f has_sgnx y) F\"", "lemma sgnx_able_sgnx:\"f sgnx_able F \\<Longrightarrow> (f has_sgnx (sgnx f F)) F\"", "lemma has_sgnx_imp_sgnx_able[elim]:\n  \"(f has_sgnx c) F \\<Longrightarrow> f sgnx_able F\"", "lemma has_sgnx_unique:\n  assumes \"F\\<noteq>bot\" \"(f has_sgnx c1) F\" \"(f has_sgnx c2) F\" \n  shows \"c1=c2\"", "lemma has_sgnx_imp_sgnx[elim]:\n  \"(f has_sgnx c) F \\<Longrightarrow>F\\<noteq>bot \\<Longrightarrow> sgnx f F = c\"", "lemma has_sgnx_const[simp,sgnx_intros]:\n  \"((\\<lambda>_. c) has_sgnx sgn c) F\"", "lemma finite_sgnx_at_left_at_right:\n  assumes \"finite {t. f t=0 \\<and> a<t \\<and> t<b}\" \"continuous_on ({a<..<b} - s) f\" \"finite s\" \n      and x:\"x\\<in>{a<..<b}\"\n  shows \"f sgnx_able (at_left x)\" \"sgnx f (at_left x)\\<noteq>0\"\n        \"f sgnx_able (at_right x)\" \"sgnx f (at_right x)\\<noteq>0\"", "lemma sgnx_able_poly[simp]:\n  \"(poly p) sgnx_able (at_right a)\"\n  \"(poly p) sgnx_able (at_left a)\"\n  \"(poly p) sgnx_able at_top\"\n  \"(poly p) sgnx_able at_bot\"", "lemma has_sgnx_identity[intro,sgnx_intros]:\n  shows \"x\\<ge>0 \\<Longrightarrow>((\\<lambda>x. x) has_sgnx 1) (at_right x)\" \n        \"x\\<le>0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx -1) (at_left x)\"", "lemma has_sgnx_divide[sgnx_intros]:\n  assumes \"(f has_sgnx c1) F\" \"(g has_sgnx c2) F\"\n  shows \"((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\"", "lemma sgnx_able_divide[sgnx_intros]:\n  assumes \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"(\\<lambda>x. f x / g x) sgnx_able F\"", "lemma sgnx_divide:\n  assumes \"F\\<noteq>bot\" \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"sgnx (\\<lambda>x. f x / g x) F =sgnx f F / sgnx g F\"", "lemma has_sgnx_times[sgnx_intros]:\n  assumes \"(f has_sgnx c1) F\" \"(g has_sgnx c2) F\"\n  shows \"((\\<lambda>x. f x* g x) has_sgnx c1 * c2) F\"", "lemma sgnx_able_times[sgnx_intros]:\n  assumes \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"(\\<lambda>x. f x * g x) sgnx_able F\"", "lemma sgnx_times:\n  assumes \"F\\<noteq>bot\" \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"sgnx (\\<lambda>x. f x * g x) F =sgnx f F * sgnx g F\"", "lemma tendsto_nonzero_has_sgnx:\n  assumes \"(f \\<longlongrightarrow> c) F\" \"c\\<noteq>0\"\n  shows \"(f has_sgnx sgn c) F\"", "lemma tendsto_nonzero_sgnx:\n  assumes \"(f \\<longlongrightarrow> c) F\" \"F\\<noteq>bot\" \"c\\<noteq>0\"\n  shows \"sgnx f F = sgn c\"", "lemma filterlim_divide_at_bot_at_top_iff:\n  assumes \"(f \\<longlongrightarrow> c) F\" \"c\\<noteq>0\" \n  shows \n    \"(LIM x F. f x / g x :> at_bot) \\<longleftrightarrow> (g \\<longlongrightarrow> 0) F \n      \\<and> ((\\<lambda>x. g x) has_sgnx - sgn c) F\"\n    \"(LIM x F. f x / g x :> at_top) \\<longleftrightarrow> (g \\<longlongrightarrow> 0) F \n      \\<and> ((\\<lambda>x. g x) has_sgnx sgn c) F\"", "lemma poly_sgnx_left_right:\n  fixes c a::real and p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"sgnx (poly p) (at_left a) = (if even (order a p) \n            then sgnx (poly p) (at_right a)\n            else -sgnx (poly p) (at_right a))\"", "lemma poly_has_sgnx_left_right:\n  fixes c a::real and p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"(poly p has_sgnx c) (at_left a) \\<longleftrightarrow> (if even (order a p) \n            then (poly p has_sgnx c) (at_right a)\n            else (poly p has_sgnx -c) (at_right a))\"", "lemma sign_r_pos_sgnx_iff:\n  \"sign_r_pos p a \\<longleftrightarrow> sgnx (poly p) (at_right a) > 0\"", "lemma sgnx_values:\n  assumes \"f sgnx_able F\" \"F \\<noteq> bot\"\n  shows \"sgnx f F = -1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1\"", "lemma has_sgnx_poly_at_top:\n    \"(poly p has_sgnx  sgn_pos_inf p) at_top\"", "lemma has_sgnx_poly_at_bot:\n    \"(poly p has_sgnx  sgn_neg_inf p) at_bot\"", "lemma sgnx_poly_at_top:\n  \"sgnx (poly p) at_top = sgn_pos_inf p\"", "lemma sgnx_poly_at_bot:\n  \"sgnx (poly p) at_bot = sgn_neg_inf p\"", "lemma poly_has_sgnx_values:\n  assumes \"p\\<noteq>0\"\n  shows \n    \"(poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\"\n    \"(poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\"\n    \"(poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\"\n    \"(poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\"", "lemma poly_sgnx_values:\n  assumes \"p\\<noteq>0\"\n  shows \"sgnx (poly p) (at_left a) = 1 \\<or> sgnx (poly p) (at_left a) = -1\"\n        \"sgnx (poly p) (at_right a) = 1 \\<or> sgnx (poly p) (at_right a) = -1\"", "lemma has_sgnx_inverse: \"(f has_sgnx c) F \\<longleftrightarrow> ((inverse o f) has_sgnx (inverse c)) F\"", "lemma has_sgnx_derivative_at_left:\n  assumes g_deriv:\"(g has_field_derivative c) (at x)\" and \"g x=0\" and \"c\\<noteq>0\" \n  shows \"(g has_sgnx - sgn c) (at_left x)\"", "lemma has_sgnx_derivative_at_right:\n  assumes g_deriv:\"(g has_field_derivative c) (at x)\" and \"g x=0\" and \"c\\<noteq>0\"\n  shows \"(g has_sgnx sgn c) (at_right x)\"", "lemma has_sgnx_split:\n  \"(f has_sgnx c) (at x) \\<longleftrightarrow> (f has_sgnx c) (at_left x) \\<and> (f has_sgnx c) (at_right x)\"", "lemma sgnx_at_top_IVT:\n  assumes \"sgnx (poly p) (at_right a) \\<noteq> sgnx (poly p) at_top\"\n  shows \"\\<exists>x>a. poly p x=0\"", "lemma sgnx_at_left_at_right_IVT:\n  assumes \"sgnx (poly p) (at_right a) \\<noteq> sgnx (poly p) (at_left b)\" \"a<b\"\n  shows \"\\<exists>x. a<x \\<and> x<b \\<and> poly p x=0\"", "lemma sgnx_at_bot_IVT:\n  assumes \"sgnx (poly p) (at_left a) \\<noteq> sgnx (poly p) at_bot\"\n  shows \"\\<exists>x<a. poly p x=0\"", "lemma sgnx_poly_nz:\n  assumes \"poly p x\\<noteq>0\"\n  shows \"sgnx (poly p) (at_left x) = sgn (poly p x)\"\n        \"sgnx (poly p) (at_right x) = sgn (poly p x)\"", "lemma finite_Psegments_pos_linear:\n  assumes \"finite_Psegments P (b*lb+c) (b*ub+c) \" and \"b>0\"\n  shows \"finite_Psegments (P o (\\<lambda>t. b*t+c)) lb ub\"", "lemma finite_Psegments_congE:\n  assumes \"finite_Psegments Q lb ub\" \n    \"\\<And>t. \\<lbrakk>lb<t;t<ub\\<rbrakk> \\<Longrightarrow> Q t \\<longleftrightarrow> P t \"\n  shows \"finite_Psegments P lb ub\"", "lemma finite_Psegments_constI:\n  assumes \"\\<And>t. \\<lbrakk>a<t;t<b\\<rbrakk> \\<Longrightarrow> P t = c\"\n  shows \"finite_Psegments P a b\"", "lemma finite_Psegments_less_eq1:\n  assumes \"finite_Psegments P a c\" \"b\\<le>c\"\n  shows \"finite_Psegments P a b\"", "lemma finite_Psegments_less_eq2:\n  assumes \"finite_Psegments P a c\" \"a\\<le>b\"\n  shows \"finite_Psegments P b c\"", "lemma finite_Psegments_included:\n  assumes \"finite_Psegments P a d\" \"a\\<le>b\" \"c\\<le>d\"\n  shows \"finite_Psegments P b c\"", "lemma finite_Psegments_combine:\n  assumes \"finite_Psegments P a b\" \"finite_Psegments P b c\" \"b\\<in>{a..c}\" \"closed ({x. P x} \\<inter> {a..c})\" \n  shows \"finite_Psegments P a c\"", "lemma finite_ReZ_segments_joinpaths:\n  assumes g1:\"finite_ReZ_segments g1 z\" and g2: \"finite_ReZ_segments g2 z\" and\n    \"path g1\" \"path g2\" \"pathfinish g1=pathstart g2\"\n  shows \"finite_ReZ_segments (g1+++g2) z\"", "lemma finite_ReZ_segments_congE:\n  assumes \"finite_ReZ_segments p1 z1\" \n    \"\\<And>t. \\<lbrakk>0<t;t<1\\<rbrakk> \\<Longrightarrow>  Re(p1 t- z1) = Re(p2 t - z2)\"\n  shows \"finite_ReZ_segments p2 z2\"", "lemma finite_ReZ_segments_constI:\n  assumes \"\\<forall>t. 0<t\\<and>t<1 \\<longrightarrow> g t = c\"\n  shows \"finite_ReZ_segments g z\"", "lemma finite_ReZ_segment_cases [consumes 1, case_names subEq subNEq,cases pred:finite_ReZ_segments]:\n  assumes \"finite_ReZ_segments g z\"\n    and subEq:\"(\\<And>s. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;finite_ReZ_segments (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P)\" \n    and subNEq:\"(\\<And>s. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;finite_ReZ_segments (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P)\"\n  shows \"P\"", "lemma finite_ReZ_segments_induct [case_names sub0 subEq subNEq, induct pred:finite_ReZ_segments]:\n  assumes \"finite_ReZ_segments g z\"\n  assumes  sub0:\"\\<And>g z. (P (subpath 0 0 g) z)\" \n    and subEq:\"(\\<And>s g z. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;finite_ReZ_segments (subpath 0 s g) z; \n          P (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P g z)\" \n    and subNEq:\"(\\<And>s g z. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;finite_ReZ_segments (subpath 0 s g) z;\n          P (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P g z)\"\n  shows \"P g z\"", "lemma finite_ReZ_segments_shiftpah:\n  assumes \"finite_ReZ_segments g z\" \"s\\<in>{0..1}\" \"path g\" and loop:\"pathfinish g = pathstart g\" \n  shows \"finite_ReZ_segments (shiftpath s g) z\"", "lemma finite_imp_finite_ReZ_segments:\n  assumes \"finite {t. Re (g t - z) = 0 \\<and> 0 \\<le> t \\<and> t\\<le>1}\"\n  shows \"finite_ReZ_segments g z\"", "lemma finite_ReZ_segments_poly_linepath:\n  shows \"finite_ReZ_segments (poly p o linepath a b) z\"", "lemma part_circlepath_half_finite_inter:\n  assumes \"st\\<noteq>tt\" \"r\\<noteq>0\" \"c\\<noteq>0\"\n  shows \"finite {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\" (is \"finite ?T\")", "lemma linepath_half_finite_inter:\n  assumes \"a \\<bullet> c \\<noteq> d \\<or> b \\<bullet> c \\<noteq> d\"\n  shows \"finite {t. linepath a b t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\" (is \"finite ?S\")", "lemma finite_half_joinpaths_inter:\n  assumes \"finite {t. l1 t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\" \"finite {t. l2 t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\"\n  shows \"finite {t. (l1+++l2) t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\"", "lemma finite_ReZ_segments_linepath:\n  \"finite_ReZ_segments (linepath a b) z\"", "lemma finite_ReZ_segments_part_circlepath:\n  \"finite_ReZ_segments (part_circlepath z0 r st tt) z\"", "lemma finite_ReZ_segments_poly_of_real:\n  shows \"finite_ReZ_segments (poly p o of_real) z\"", "lemma finite_ReZ_segments_subpath:\n  assumes \"finite_ReZ_segments g z\"\n    \"0\\<le>u\" \"u\\<le>v\" \"v\\<le>1\"\n  shows \"finite_ReZ_segments (subpath u v g) z\"", "lemma jumpF_const[simp]:\n  assumes \"F\\<noteq>bot\"\n  shows \"jumpF (\\<lambda>_. c) F = 0\"", "lemma jumpF_not_infinity:\n  assumes \"continuous F g\" \"F\\<noteq>bot\"\n  shows \"jumpF g F = 0\"", "lemma jumpF_linear_comp:\n  assumes \"c\\<noteq>0\"\n  shows \n    \"jumpF (f o (\\<lambda>x. c*x+b)) (at_left x) = \n            (if c>0 then jumpF f (at_left (c*x+b)) else jumpF f (at_right (c*x+b)))\"\n    (is ?case1)\n    \"jumpF (f o (\\<lambda>x. c*x+b)) (at_right x) = \n            (if c>0 then jumpF f (at_right (c*x+b)) else jumpF f (at_left (c*x+b)))\"\n    (is ?case2)", "lemma jump_const[simp]:\"jump (\\<lambda>_. c) a = 0\"", "lemma jump_not_infinity:\n  \"isCont f a \\<Longrightarrow> jump f a =0\"", "lemma jump_jump_poly_aux:\n  assumes \"p\\<noteq>0\" \"coprime p q\"\n  shows \"jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\"", "lemma jump_jumpF:\n  assumes cont:\"isCont (inverse o f) a\" and \n      sgnxl:\"(f has_sgnx l) (at_left a)\" and sgnxr:\"(f has_sgnx r) (at_right a)\" and\n      \"l\\<noteq>0 \" \"r\\<noteq>0\"\n  shows \"jump f a = jumpF f (at_right a) - jumpF f (at_left a)\"", "lemma jump_linear_comp:\n  assumes \"c\\<noteq>0\"\n  shows \"jump (f o (\\<lambda>x. c*x+b)) x = (if c>0 then jump f (c*x+b) else -jump f (c*x+b))\"", "lemma jump_divide_derivative:\n  assumes \"isCont f x\" \"g x = 0\" \"f x\\<noteq>0\" \n    and g_deriv:\"(g has_field_derivative c) (at x)\" and \"c\\<noteq>0\"\n  shows \"jump (\\<lambda>t. f t/g t) x = (if sgn c = sgn ( f x) then 1 else -1)\"", "lemma jump_jump_poly: \"jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\"", "lemma jump_Im_divide_Re_0:\n  assumes \"path g\" \"Re (g x)\\<noteq>0\" \"0<x\" \"x<1\"\n  shows \"jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0\"", "lemma jumpF_im_divide_Re_0:\n  assumes \"path g\" \"Re (g x)\\<noteq>0\" \n  shows \"\\<lbrakk>0\\<le>x;x<1\\<rbrakk> \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_right x) = 0\"\n        \"\\<lbrakk>0<x;x\\<le>1\\<rbrakk> \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_left x) = 0\"", "lemma jump_cong:\n  assumes \"x=y\" and \"eventually (\\<lambda>x. f x=g x) (at x)\"\n  shows \"jump f x = jump g y\"", "lemma jumpF_cong:\n  assumes \"F=G\" and \"eventually (\\<lambda>x. f x=g x) F\"\n  shows \"jumpF f F = jumpF g G\"", "lemma jump_at_left_at_right_eq:\n  assumes \"isCont f x\" and \"f x \\<noteq> 0\" and sgnx_eq:\"sgnx g (at_left x) = sgnx g (at_right x)\"\n  shows \"jump (\\<lambda>t. f t/g t) x = 0\"", "lemma jumpF_pos_has_sgnx:\n  assumes \"jumpF f F > 0\"\n  shows \"(f has_sgnx 1) F\"", "lemma jumpF_neg_has_sgnx:\n  assumes \"jumpF f F < 0\"\n  shows \"(f has_sgnx -1) F\"", "lemma jumpF_IVT:\n  fixes f::\"real \\<Rightarrow> real\" and a b::real\n  defines \"right\\<equiv>(\\<lambda>(R::real \\<Rightarrow> real \\<Rightarrow> bool). R (jumpF f (at_right a)) 0 \n                      \\<or> (continuous (at_right a) f \\<and> R (f a) 0))\"\n    and\n          \"left\\<equiv>(\\<lambda>(R::real \\<Rightarrow> real \\<Rightarrow> bool). R (jumpF f (at_left b)) 0 \n                      \\<or> (continuous (at_left b) f \\<and> R (f b) 0))\"\n  assumes \"a<b\" and cont:\"continuous_on {a<..<b} f\" and\n    right_left:\"right greater \\<and> left less \\<or> right less \\<and> left greater\" \n  shows \"\\<exists>x. a<x \\<and> x<b \\<and> f x =0\"", "lemma jumpF_eventually_const:\n  assumes \"eventually (\\<lambda>x. f x=c) F\" \"F\\<noteq>bot\"\n  shows \"jumpF f F = 0\"", "lemma jumpF_tan_comp:\n  \"jumpF (f o tan) (at_right x) = (if cos x = 0 \n      then jumpF f at_bot else jumpF f (at_right (tan x)))\"\n  \"jumpF (f o tan) (at_left x) = (if cos x =0 \n      then jumpF f at_top else jumpF f (at_left (tan x)))\"", "lemma finite_jumpFs_linear_pos:\n  assumes \"c>0\"\n  shows \"finite_jumpFs (f o (\\<lambda>x. c * x + b)) lb ub \\<longleftrightarrow> finite_jumpFs f (c * lb +b) (c * ub + b)\"", "lemma finite_jumpFs_consts:\n  \"finite_jumpFs (\\<lambda>_ . c) lb ub\"", "lemma finite_jumpFs_combine:\n  assumes \"finite_jumpFs f a b\" \"finite_jumpFs f b c\" \n  shows \"finite_jumpFs f a c\"", "lemma finite_jumpFs_subE:\n  assumes \"finite_jumpFs f a b\" \"a\\<le>a'\" \"b'\\<le>b\" \n  shows \"finite_jumpFs f a' b'\"", "lemma finite_Psegments_Re_imp_jumpFs:\n  assumes \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a b\" \"continuous_on {a..b} g\" \n  shows \"finite_jumpFs (\\<lambda>t. Im (g t - z)/Re (g t - z)) a b\"", "lemma finite_ReZ_segments_imp_jumpFs:\n  assumes \"finite_ReZ_segments g z\" \"path g\" \n  shows \"finite_jumpFs (\\<lambda>t. Im (g t - z)/Re (g t - z)) 0 1\"", "lemma jumpF_pathstart_eq_0:\n  assumes \"path g\" \"Re(pathstart g)\\<noteq>Re z\"\n  shows \"jumpF_pathstart g z = 0\"", "lemma jumpF_pathfinish_eq_0:\n  assumes \"path g\" \"Re(pathfinish g)\\<noteq>Re z\"\n  shows \"jumpF_pathfinish g z = 0\"", "lemma \n  shows jumpF_pathfinish_reversepath: \"jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\"\n    and jumpF_pathstart_reversepath: \"jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z\"", "lemma jumpF_pathstart_joinpaths[simp]:\n  \"jumpF_pathstart (g1+++g2) z = jumpF_pathstart g1 z\"", "lemma jumpF_pathfinish_joinpaths[simp]:\n  \"jumpF_pathfinish (g1+++g2) z = jumpF_pathfinish g2 z\"", "lemma cindexE_empty:\n  \"cindexE a a f = 0\"", "lemma cindex_const: \"cindex a b (\\<lambda>_. c) = 0\"", "lemma cindex_eq_cindex_poly: \"cindex a b (\\<lambda>x. poly q x/poly p x) = cindex_poly a b q p\"", "lemma cindex_combine:\n  assumes finite:\"finite {x. jump f x\\<noteq>0 \\<and> a<x \\<and> x<c}\" and \"a<b\" \"b<c\"\n  shows \"cindex a c f = cindex a b f  + jump f b + cindex b c f\"", "lemma cindexE_combine:\n  assumes finite:\"finite_jumpFs f a c\" and \"a\\<le>b\" \"b\\<le>c\"\n  shows \"cindexE a c f = cindexE a b f + cindexE b c f\"", "lemma cindex_linear_comp:\n  assumes \"c\\<noteq>0\"\n  shows \"cindex lb ub (f o (\\<lambda>x. c*x+b)) = (if c>0 \n    then cindex (c*lb+b) (c*ub+b) f \n    else - cindex (c*ub+b) (c*lb+b) f)\"", "lemma cindexE_linear_comp: \n  assumes \"c\\<noteq>0\"\n  shows \"cindexE lb ub (f o (\\<lambda>x. c*x+b)) = (if c>0 \n    then cindexE (c*lb+b) (c*ub+b) f \n    else - cindexE (c*ub+b) (c*lb+b) f)\"", "lemma cindexE_cong:\n  assumes \"finite s\" and fg_eq:\"\\<And>x. \\<lbrakk>a<x;x<b;x\\<notin>s\\<rbrakk> \\<Longrightarrow> f x = g x\"\n  shows \"cindexE a b f = cindexE a b g\"", "lemma cindexE_constI:\n  assumes \"\\<And>t. \\<lbrakk>a<t;t<b\\<rbrakk> \\<Longrightarrow> f t=c\"\n  shows \"cindexE a b f = 0\"", "lemma cindex_eq_cindexE_divide:\n  fixes f g::\"real \\<Rightarrow> real\"\n  defines \"h \\<equiv> (\\<lambda>x. f x/g x)\"\n  assumes \"a<b\" and\n    finite_fg: \"finite {x. (f x=0\\<or>g x=0) \\<and> a\\<le>x\\<and>x\\<le>b}\" and \n    g_imp_f:\"\\<forall>x\\<in>{a..b}. g x=0 \\<longrightarrow> f x\\<noteq>0\" and\n    f_cont:\"continuous_on {a..b} f\" and\n    g_cont:\"continuous_on {a..b} g\"\n  shows \"cindexE a b h = jumpF h (at_right a) + cindex a b h - jumpF h (at_left b)\"", "lemma cindex_pathE_point: \"cindex_pathE (linepath a a) b = 0\"", "lemma cindex_path_reversepath:\n  \"cindex_path (reversepath g) z = - cindex_path g z\"", "lemma cindex_pathE_reversepath: \"cindex_pathE (reversepath g) z = -cindex_pathE g z\"", "lemma cindex_pathE_reversepath': \"cindex_pathE g z = -cindex_pathE (reversepath g) z\"", "lemma cindex_pathE_joinpaths:\n  assumes g1:\"finite_ReZ_segments g1 z\" and g2: \"finite_ReZ_segments g2 z\" and\n    \"path g1\" \"path g2\" \"pathfinish g1 = pathstart g2\"\n  shows \"cindex_pathE (g1+++g2) z = cindex_pathE g1 z + cindex_pathE g2 z\"", "lemma cindex_pathE_constI:\n  assumes \"\\<And>t. \\<lbrakk>0<t;t<1\\<rbrakk> \\<Longrightarrow> g t=c\"\n  shows \"cindex_pathE g z = 0\"", "lemma cindex_pathE_subpath_combine:\n  assumes g:\"finite_ReZ_segments g z\"and \"path g\" and\n     \"0\\<le>a\" \"a\\<le>b\" \"b\\<le>c\" \"c\\<le>1\"\n  shows \"cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z \n          = cindex_pathE (subpath a c g) z\"", "lemma cindex_pathE_shiftpath:\n  assumes \"finite_ReZ_segments g z\" \"s\\<in>{0..1}\" \"path g\" and loop:\"pathfinish g = pathstart g\"\n  shows \"cindex_pathE (shiftpath s g) z = cindex_pathE g z\"", "theorem winding_number_cindex_pathE_aux:\n  fixes g::\"real \\<Rightarrow> complex\"\n  assumes \"finite_ReZ_segments g z\" and \"valid_path g\" \"z \\<notin> path_image g\" and\n    Re_ends:\"Re (g 1) = Re z\" \"Re (g 0) = Re z\"\n  shows \"2 * Re(winding_number g z) = - cindex_pathE g z\"", "theorem winding_number_cindex_pathE:\n  fixes g::\"real \\<Rightarrow> complex\"\n  assumes \"finite_ReZ_segments g z\" and \"valid_path g\" \"z \\<notin> path_image g\" and\n    loop: \"pathfinish g = pathstart g\"\n  shows \"winding_number g z = - cindex_pathE g z / 2\""], "translations": [["", "lemma atMostAtLeast_subset_convex:\n  fixes C :: \"real set\"\n  assumes \"convex C\"\n    and \"x \\<in> C\" \"y \\<in> C\" \n  shows \"{x .. y} \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x..y} \\<subseteq> C", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x..y} \\<Longrightarrow> xa \\<in> C", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x..y} \\<Longrightarrow> xa \\<in> C", "assume z: \"z \\<in> {x .. y}\""], ["proof (state)\nthis:\n  z \\<in> {x..y}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x..y} \\<Longrightarrow> xa \\<in> C", "have \"z \\<in> C\" if *: \"x < z\" \"z < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> C", "let ?\\<mu> = \"(y - z) / (y - x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> C", "have \"0 \\<le> ?\\<mu>\" \"?\\<mu> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (y - z) / (y - x) &&& (y - z) / (y - x) \\<le> 1", "using assms *"], ["proof (prove)\nusing this:\n  convex C\n  x \\<in> C\n  y \\<in> C\n  x < z\n  z < y\n\ngoal (1 subgoal):\n 1. 0 \\<le> (y - z) / (y - x) &&& (y - z) / (y - x) \\<le> 1", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  0 \\<le> (y - z) / (y - x)\n  (y - z) / (y - x) \\<le> 1\n\ngoal (1 subgoal):\n 1. z \\<in> C", "then"], ["proof (chain)\npicking this:\n  0 \\<le> (y - z) / (y - x)\n  (y - z) / (y - x) \\<le> 1", "have comb: \"?\\<mu> * x + (1 - ?\\<mu>) * y \\<in> C\""], ["proof (prove)\nusing this:\n  0 \\<le> (y - z) / (y - x)\n  (y - z) / (y - x) \\<le> 1\n\ngoal (1 subgoal):\n 1. (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y \\<in> C", "using assms iffD1[OF convex_alt, rule_format, of C y x ?\\<mu>]"], ["proof (prove)\nusing this:\n  0 \\<le> (y - z) / (y - x)\n  (y - z) / (y - x) \\<le> 1\n  convex C\n  x \\<in> C\n  y \\<in> C\n  \\<lbrakk>convex C; y \\<in> C; x \\<in> C;\n   0 \\<le> (y - z) / (y - x) \\<and> (y - z) / (y - x) \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (1 - (y - z) / (y - x)) *\\<^sub>R y +\n                    ((y - z) / (y - x)) *\\<^sub>R x\n                    \\<in> C\n\ngoal (1 subgoal):\n 1. (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y \\<in> C", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> C", "have \"?\\<mu> * x + (1 - ?\\<mu>) * y = (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y =\n    (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y =\n  (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y\n\ngoal (1 subgoal):\n 1. z \\<in> C", "also"], ["proof (state)\nthis:\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y =\n  (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y\n\ngoal (1 subgoal):\n 1. z \\<in> C", "have \"\\<dots> = ((y - z) * x + (y - x - (y - z)) * y) / (y - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y =\n    ((y - z) * x + (y - x - (y - z)) * y) / (y - x)", "using *"], ["proof (prove)\nusing this:\n  x < z\n  z < y\n\ngoal (1 subgoal):\n 1. (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y =\n    ((y - z) * x + (y - x - (y - z)) * y) / (y - x)", "by (simp only: add_divide_distrib) (auto simp: field_simps)"], ["proof (state)\nthis:\n  (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y =\n  ((y - z) * x + (y - x - (y - z)) * y) / (y - x)\n\ngoal (1 subgoal):\n 1. z \\<in> C", "also"], ["proof (state)\nthis:\n  (y - z) * x / (y - x) + (1 - (y - z) / (y - x)) * y =\n  ((y - z) * x + (y - x - (y - z)) * y) / (y - x)\n\ngoal (1 subgoal):\n 1. z \\<in> C", "have \"\\<dots> = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((y - z) * x + (y - x - (y - z)) * y) / (y - x) = z", "using assms *"], ["proof (prove)\nusing this:\n  convex C\n  x \\<in> C\n  y \\<in> C\n  x < z\n  z < y\n\ngoal (1 subgoal):\n 1. ((y - z) * x + (y - x - (y - z)) * y) / (y - x) = z", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  ((y - z) * x + (y - x - (y - z)) * y) / (y - x) = z\n\ngoal (1 subgoal):\n 1. z \\<in> C", "finally"], ["proof (chain)\npicking this:\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y = z", "show ?thesis"], ["proof (prove)\nusing this:\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y = z\n\ngoal (1 subgoal):\n 1. z \\<in> C", "using comb"], ["proof (prove)\nusing this:\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y = z\n  (y - z) / (y - x) * x + (1 - (y - z) / (y - x)) * y \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> C", "by auto"], ["proof (state)\nthis:\n  z \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x < z; z < y\\<rbrakk> \\<Longrightarrow> z \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x..y} \\<Longrightarrow> xa \\<in> C", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x < z; z < y\\<rbrakk> \\<Longrightarrow> z \\<in> C", "show \"z \\<in> C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x < z; z < y\\<rbrakk> \\<Longrightarrow> z \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> C", "using z assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>x < z; z < y\\<rbrakk> \\<Longrightarrow> z \\<in> C\n  z \\<in> {x..y}\n  convex C\n  x \\<in> C\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> C", "by (auto simp: le_less)"], ["proof (state)\nthis:\n  z \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_elim:\n  \"f x \\<Longrightarrow> x= y \\<Longrightarrow> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x; x = y\\<rbrakk> \\<Longrightarrow> f y", "by auto"], ["", "lemma arg_elim2:\n  \"f x1 x2 \\<Longrightarrow> x1= y1 \\<Longrightarrow>x2=y2 \\<Longrightarrow> f y1 y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x1 x2; x1 = y1; x2 = y2\\<rbrakk> \\<Longrightarrow> f y1 y2", "by auto"], ["", "lemma arg_elim3:\n  \"\\<lbrakk>f x1 x2 x3;x1= y1;x2=y2;x3=y3 \\<rbrakk> \\<Longrightarrow> f y1 y2 y3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x1 x2 x3; x1 = y1; x2 = y2; x3 = y3\\<rbrakk>\n    \\<Longrightarrow> f y1 y2 y3", "by auto"], ["", "lemma IVT_strict:\n  fixes f :: \"'a::linear_continuum_topology \\<Rightarrow> 'b::linorder_topology\"\n  assumes \"(f a > y \\<and> y > f b) \\<or> (f a < y \\<and> y < f b)\" \"a<b\" \"continuous_on {a .. b} f\"\n  shows \"\\<exists>x. a < x \\<and> x < b \\<and> f x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = y", "by (metis IVT' IVT2' assms(1) assms(2) assms(3) linorder_neq_iff order_le_less order_less_imp_le)"], ["", "lemma (in dense_linorder) atLeastAtMost_subseteq_greaterThanLessThan_iff:\n  \"{a .. b} \\<subseteq> { c <..< d } \\<longleftrightarrow> (a \\<le> b \\<longrightarrow> c < a \\<and> b < d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a..b} \\<subseteq> {c<..<d}) =\n    (a \\<le> b \\<longrightarrow> c < a \\<and> b < d)", "using dense[of \"a\" \"min c b\"] dense[of \"max a d\" \"b\"]"], ["proof (prove)\nusing this:\n  a < min c b \\<Longrightarrow> \\<exists>z>a. z < min c b\n  max a d < b \\<Longrightarrow> \\<exists>z>max a d. z < b\n\ngoal (1 subgoal):\n 1. ({a..b} \\<subseteq> {c<..<d}) =\n    (a \\<le> b \\<longrightarrow> c < a \\<and> b < d)", "by (force simp: subset_eq Ball_def not_less[symmetric])"], ["", "lemma Re_winding_number_half_right:\n  assumes \"\\<forall>p\\<in>path_image \\<gamma>. Re p \\<ge> Re z\" and \"valid_path \\<gamma>\" and  \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z)))/(2*pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "define g where \"g=(\\<lambda>t. \\<gamma> t - z)\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. \\<gamma> t - z)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "define st fi where \"st\\<equiv>pathstart g\" and \"fi\\<equiv>pathfinish g\""], ["proof (state)\nthis:\n  st \\<equiv> pathstart g\n  fi \\<equiv> pathfinish g\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "have \"valid_path g\" \"0\\<notin>path_image g\" and pos_img:\"\\<forall>p\\<in>path_image g. Re p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_path g &&& 0 \\<notin> path_image g) &&&\n    \\<forall>p\\<in>path_image g. 0 \\<le> Re p", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_path (\\<lambda>t. \\<gamma> t - z) &&&\n     0 \\<notin> path_image (\\<lambda>t. \\<gamma> t - z)) &&&\n    \\<forall>p\\<in>path_image (\\<lambda>t. \\<gamma> t - z). 0 \\<le> Re p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. \\<gamma> t - z)", "using assms(2)"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. \\<gamma> t - z)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<notin> path_image (\\<lambda>t. \\<gamma> t - z)\n 2. \\<forall>p\\<in>path_image (\\<lambda>t. \\<gamma> t - z). 0 \\<le> Re p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. \\<gamma> t - z)", "using assms(3)"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. \\<gamma> t - z)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. \\<gamma> t - z). 0 \\<le> Re p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. \\<gamma> t - z). 0 \\<le> Re p", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>path_image \\<gamma>. Re z \\<le> Re p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. \\<gamma> t - z). 0 \\<le> Re p", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_path g\n  0 \\<notin> path_image g\n  \\<forall>p\\<in>path_image g. 0 \\<le> Re p\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "have \"(inverse has_contour_integral Ln fi - Ln st) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse has_contour_integral Ln fi - Ln st) g", "unfolding fi_def st_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse has_contour_integral Ln (pathfinish g) - Ln (pathstart g)) g", "proof (rule contour_integral_primitive[OF _ \\<open>valid_path g\\<close>,of \" - \\<real>\\<^sub>\\<le>\\<^sub>0\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0 \\<Longrightarrow>\n       (Ln has_field_derivative inverse x)\n        (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)\n 2. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "fix x::complex"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0 \\<Longrightarrow>\n       (Ln has_field_derivative inverse x)\n        (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)\n 2. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "assume \"x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0\""], ["proof (state)\nthis:\n  x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0 \\<Longrightarrow>\n       (Ln has_field_derivative inverse x)\n        (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)\n 2. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "then"], ["proof (chain)\npicking this:\n  x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0", "have \"(Ln has_field_derivative inverse x) (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0\n\ngoal (1 subgoal):\n 1. (Ln has_field_derivative inverse x) (at x)", "using has_field_derivative_Ln"], ["proof (prove)\nusing this:\n  x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0\n  ?z \\<notin> \\<real>\\<^sub>\\<le>\\<^sub>0 \\<Longrightarrow>\n  (Ln has_field_derivative inverse ?z) (at ?z)\n\ngoal (1 subgoal):\n 1. (Ln has_field_derivative inverse x) (at x)", "by auto"], ["proof (state)\nthis:\n  (Ln has_field_derivative inverse x) (at x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> - \\<real>\\<^sub>\\<le>\\<^sub>0 \\<Longrightarrow>\n       (Ln has_field_derivative inverse x)\n        (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)\n 2. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "then"], ["proof (chain)\npicking this:\n  (Ln has_field_derivative inverse x) (at x)", "show \"(Ln has_field_derivative inverse x) (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)\""], ["proof (prove)\nusing this:\n  (Ln has_field_derivative inverse x) (at x)\n\ngoal (1 subgoal):\n 1. (Ln has_field_derivative inverse x)\n     (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)", "using has_field_derivative_at_within"], ["proof (prove)\nusing this:\n  (Ln has_field_derivative inverse x) (at x)\n  (?f has_field_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_field_derivative ?f') (at ?x within ?s)\n\ngoal (1 subgoal):\n 1. (Ln has_field_derivative inverse x)\n     (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)", "by auto"], ["proof (state)\nthis:\n  (Ln has_field_derivative inverse x)\n   (at x within - \\<real>\\<^sub>\\<le>\\<^sub>0)\n\ngoal (1 subgoal):\n 1. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "show \"path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "using pos_img \\<open>0\\<notin>path_image g\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>path_image g. 0 \\<le> Re p\n  0 \\<notin> path_image g\n\ngoal (1 subgoal):\n 1. path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0", "by (metis ComplI antisym assms(3) complex_nonpos_Reals_iff complex_surj\n          subsetI zero_complex.code)"], ["proof (state)\nthis:\n  path_image g \\<subseteq> - \\<real>\\<^sub>\\<le>\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (inverse has_contour_integral Ln fi - Ln st) g\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "then"], ["proof (chain)\npicking this:\n  (inverse has_contour_integral Ln fi - Ln st) g", "have winding_eq:\"2*pi*\\<i>*winding_number g 0 = (Ln fi - Ln st)\""], ["proof (prove)\nusing this:\n  (inverse has_contour_integral Ln fi - Ln st) g\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * winding_number g 0 = Ln fi - Ln st", "using has_contour_integral_winding_number[OF \\<open>valid_path g\\<close> \\<open>0\\<notin>path_image g\\<close>\n        ,simplified,folded inverse_eq_divide] has_contour_integral_unique"], ["proof (prove)\nusing this:\n  (inverse has_contour_integral Ln fi - Ln st) g\n  (inverse has_contour_integral\n   2 * complex_of_real pi * \\<i> * winding_number g 0)\n   g\n  \\<lbrakk>(?f has_contour_integral ?i) ?g;\n   (?f has_contour_integral ?j) ?g\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi) * \\<i> * winding_number g 0 = Ln fi - Ln st", "by auto"], ["proof (state)\nthis:\n  complex_of_real (2 * pi) * \\<i> * winding_number g 0 = Ln fi - Ln st\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "have \"Re(winding_number g 0) \n      = (Im (Ln fi) - Im (Ln st))/(2*pi)\"\n    (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "have \"?L = Re((Ln fi - Ln st)/(2*pi*\\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number g 0) =\n    Re ((Ln fi - Ln st) / (complex_of_real (2 * pi) * \\<i>))", "using winding_eq[symmetric]"], ["proof (prove)\nusing this:\n  Ln fi - Ln st = complex_of_real (2 * pi) * \\<i> * winding_number g 0\n\ngoal (1 subgoal):\n 1. Re (winding_number g 0) =\n    Re ((Ln fi - Ln st) / (complex_of_real (2 * pi) * \\<i>))", "by auto"], ["proof (state)\nthis:\n  Re (winding_number g 0) =\n  Re ((Ln fi - Ln st) / (complex_of_real (2 * pi) * \\<i>))\n\ngoal (1 subgoal):\n 1. Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "also"], ["proof (state)\nthis:\n  Re (winding_number g 0) =\n  Re ((Ln fi - Ln st) / (complex_of_real (2 * pi) * \\<i>))\n\ngoal (1 subgoal):\n 1. Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "have \"... = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((Ln fi - Ln st) / (complex_of_real (2 * pi) * \\<i>)) =\n    (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "by (metis Im_divide_of_real Im_i_times complex_i_not_zero minus_complex.simps(2) \n          mult.commute mult_divide_mult_cancel_left_if times_divide_eq_right)"], ["proof (state)\nthis:\n  Re ((Ln fi - Ln st) / (complex_of_real (2 * pi) * \\<i>)) =\n  (Im (Ln fi) - Im (Ln st)) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "finally"], ["proof (chain)\npicking this:\n  Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "."], ["proof (state)\nthis:\n  Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "then"], ["proof (chain)\npicking this:\n  Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g 0) = (Im (Ln fi) - Im (Ln st)) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "unfolding g_def fi_def st_def"], ["proof (prove)\nusing this:\n  Re (winding_number (\\<lambda>t. \\<gamma> t - z) 0) =\n  (Im (Ln (pathfinish (\\<lambda>t. \\<gamma> t - z))) -\n   Im (Ln (pathstart (\\<lambda>t. \\<gamma> t - z)))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "using winding_number_offset"], ["proof (prove)\nusing this:\n  Re (winding_number (\\<lambda>t. \\<gamma> t - z) 0) =\n  (Im (Ln (pathfinish (\\<lambda>t. \\<gamma> t - z))) -\n   Im (Ln (pathstart (\\<lambda>t. \\<gamma> t - z)))) /\n  (2 * pi)\n  winding_number ?p ?z = winding_number (\\<lambda>w. ?p w - ?z) 0\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n    (2 * pi)", "by simp"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma> z) =\n  (Im (Ln (pathfinish \\<gamma> - z)) - Im (Ln (pathstart \\<gamma> - z))) /\n  (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Re_winding_number_half_upper:\n  assumes pimage:\"\\<forall>p\\<in>path_image \\<gamma>. Im p \\<ge> Im z\" and \"valid_path \\<gamma>\" and \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = \n            (Im (Ln (\\<i>*z - \\<i>*pathfinish \\<gamma>)) - Im (Ln (\\<i>*z - \\<i>*pathstart \\<gamma> )))/(2*pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "define \\<gamma>' where \"\\<gamma>'=(\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)\""], ["proof (state)\nthis:\n  \\<gamma>' = (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "have \"Re (winding_number \\<gamma>' z) = (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma>' z) =\n    (Im (Ln (pathfinish \\<gamma>' - z)) -\n     Im (Ln (pathstart \\<gamma>' - z))) /\n    (2 * pi)", "unfolding \\<gamma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z) z) =\n    (Im (Ln (pathfinish (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z) - z)) -\n     Im (Ln (pathstart (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z) - z))) /\n    (2 * pi)", "apply (rule Re_winding_number_half_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z).\n       Re z \\<le> Re p\n 2. valid_path (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)\n 3. z \\<notin> path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z).\n       Re z \\<le> Re p", "using pimage"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>path_image \\<gamma>. Im z \\<le> Im p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z).\n       Re z \\<le> Re p", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>\\<gamma> ` {0..1}. Im z \\<le> Im p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>(\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z) ` {0..1}.\n       Re z \\<le> Re p", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)\n 2. z \\<notin> path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)", "apply (rule valid_path_compose_holomorphic[OF \\<open>valid_path \\<gamma>\\<close>,of \"\\<lambda>x. -\\<i> * (x-z) + z\" UNIV\n            , unfolded comp_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>t. - \\<i> * (t - z) + z) holomorphic_on UNIV\n 2. open UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV", "by (auto intro!:holomorphic_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)", "using \\<open>z\\<notin>path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z)", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> \\<gamma> ` {0..1}\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z) ` {0..1}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "moreover"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "have \"winding_number \\<gamma>' z = winding_number \\<gamma> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "define f where \"f=(\\<lambda>x. -\\<i> * (x-z) + z)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. - \\<i> * (x - z) + z)\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "define c where \"c= 1 / (complex_of_real (2 * pi) * \\<i>)\""], ["proof (state)\nthis:\n  c = 1 / (complex_of_real (2 * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"winding_number \\<gamma>' z = winding_number (f o \\<gamma>) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z", "unfolding \\<gamma>'_def comp_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. - \\<i> * (\\<gamma> t - z) + z) z =\n    winding_number (\\<lambda>x. - \\<i> * (\\<gamma> x - z) + z) z", "by auto"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "proof (rule winding_number_comp[of UNIV])"], ["proof (state)\ngoal (5 subgoals):\n 1. open UNIV\n 2. f holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>\n 5. z \\<notin> path_image (f \\<circ> \\<gamma>)", "show \"z \\<notin> path_image (f \\<circ> \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (f \\<circ> \\<gamma>)", "using \\<open>z\\<notin>path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (f \\<circ> \\<gamma>)", "unfolding f_def path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> \\<gamma> ` {0..1}\n\ngoal (1 subgoal):\n 1. z \\<notin> ((\\<lambda>x. - \\<i> * (x - z) + z) \\<circ> \\<gamma>) `\n               {0..1}", "by auto"], ["proof (state)\nthis:\n  z \\<notin> path_image (f \\<circ> \\<gamma>)\n\ngoal (4 subgoals):\n 1. open UNIV\n 2. f holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>", "qed (auto simp add:f_def \\<open>valid_path \\<gamma>\\<close> intro!:holomorphic_intros)"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = c * contour_integral \\<gamma> (\\<lambda>w.  1 / (w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "have \"deriv f x = -\\<i>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv f x = - \\<i>", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (\\<lambda>x. - \\<i> * (x - z) + z) x = - \\<i>", "by (auto intro!:derivative_eq_intros DERIV_imp_deriv)"], ["proof (state)\nthis:\n  deriv f ?x = - \\<i>\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "then"], ["proof (chain)\npicking this:\n  deriv f ?x = - \\<i>", "show ?thesis"], ["proof (prove)\nusing this:\n  deriv f ?x = - \\<i>\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "unfolding f_def c_def"], ["proof (prove)\nusing this:\n  deriv (\\<lambda>x. - \\<i> * (x - z) + z) ?x = - \\<i>\n\ngoal (1 subgoal):\n 1. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma>\n     (\\<lambda>w.\n         deriv (\\<lambda>x. - \\<i> * (x - z) + z) w /\n         (- \\<i> * (w - z) + z - z)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "by (auto simp add:field_simps divide_simps intro!:arg_cong2[where f=contour_integral])"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = winding_number \\<gamma> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n    winding_number \\<gamma> z", "using winding_number_valid_path[OF \\<open>valid_path \\<gamma>\\<close> \\<open>z\\<notin>path_image \\<gamma>\\<close>,folded c_def]"], ["proof (prove)\nusing this:\n  winding_number \\<gamma> z =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n    winding_number \\<gamma> z", "by simp"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n  winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "finally"], ["proof (chain)\npicking this:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "."], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "moreover"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "have \"pathfinish \\<gamma>' = z+ \\<i>*z -\\<i>* pathfinish \\<gamma>\" \"pathstart \\<gamma>' = z+ \\<i>*z -\\<i>*pathstart \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish \\<gamma>' = z + \\<i> * z - \\<i> * pathfinish \\<gamma> &&&\n    pathstart \\<gamma>' = z + \\<i> * z - \\<i> * pathstart \\<gamma>", "unfolding \\<gamma>'_def path_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<i> * (\\<gamma> 1 - z) + z = z + \\<i> * z - \\<i> * \\<gamma> 1 &&&\n    - \\<i> * (\\<gamma> 0 - z) + z = z + \\<i> * z - \\<i> * \\<gamma> 0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  pathfinish \\<gamma>' = z + \\<i> * z - \\<i> * pathfinish \\<gamma>\n  pathstart \\<gamma>' = z + \\<i> * z - \\<i> * pathstart \\<gamma>\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n  pathfinish \\<gamma>' = z + \\<i> * z - \\<i> * pathfinish \\<gamma>\n  pathstart \\<gamma>' = z + \\<i> * z - \\<i> * pathstart \\<gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n  pathfinish \\<gamma>' = z + \\<i> * z - \\<i> * pathfinish \\<gamma>\n  pathstart \\<gamma>' = z + \\<i> * z - \\<i> * pathstart \\<gamma>\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n     Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n    (2 * pi)", "by auto"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma> z) =\n  (Im (Ln (\\<i> * z - \\<i> * pathfinish \\<gamma>)) -\n   Im (Ln (\\<i> * z - \\<i> * pathstart \\<gamma>))) /\n  (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Re_winding_number_half_lower:\n  assumes pimage:\"\\<forall>p\\<in>path_image \\<gamma>. Im p \\<le> Im z\" and \"valid_path \\<gamma>\" and \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = \n             (Im (Ln ( \\<i>*pathfinish \\<gamma> - \\<i>*z)) - Im (Ln (\\<i>*pathstart \\<gamma> - \\<i>*z)))/(2*pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "define \\<gamma>' where \"\\<gamma>'=(\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)\""], ["proof (state)\nthis:\n  \\<gamma>' = (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "have \"Re (winding_number \\<gamma>' z) = (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma>' z) =\n    (Im (Ln (pathfinish \\<gamma>' - z)) -\n     Im (Ln (pathstart \\<gamma>' - z))) /\n    (2 * pi)", "unfolding \\<gamma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z) z) =\n    (Im (Ln (pathfinish (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z) - z)) -\n     Im (Ln (pathstart (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z) - z))) /\n    (2 * pi)", "apply (rule Re_winding_number_half_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z).\n       Re z \\<le> Re p\n 2. valid_path (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)\n 3. z \\<notin> path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z).\n       Re z \\<le> Re p", "using pimage"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>path_image \\<gamma>. Im p \\<le> Im z\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z).\n       Re z \\<le> Re p", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>\\<gamma> ` {0..1}. Im p \\<le> Im z\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>(\\<lambda>t. \\<i> * (\\<gamma> t - z) + z) ` {0..1}.\n       Re z \\<le> Re p", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)\n 2. z \\<notin> path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)", "apply (rule valid_path_compose_holomorphic[OF \\<open>valid_path \\<gamma>\\<close>,of \"\\<lambda>x. \\<i> * (x-z) + z\" UNIV\n            , unfolded comp_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>t. \\<i> * (t - z) + z) holomorphic_on UNIV\n 2. open UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV", "by (auto intro!:holomorphic_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)", "using \\<open>z\\<notin>path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z)", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> \\<gamma> ` {0..1}\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z) ` {0..1}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "moreover"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "have \"winding_number \\<gamma>' z = winding_number \\<gamma> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "define f where \"f=(\\<lambda>x. \\<i> * (x-z) + z)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. \\<i> * (x - z) + z)\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "define c where \"c= 1 / (complex_of_real (2 * pi) * \\<i>)\""], ["proof (state)\nthis:\n  c = 1 / (complex_of_real (2 * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"winding_number \\<gamma>' z = winding_number (f o \\<gamma>) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z", "unfolding \\<gamma>'_def comp_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. \\<i> * (\\<gamma> t - z) + z) z =\n    winding_number (\\<lambda>x. \\<i> * (\\<gamma> x - z) + z) z", "by auto"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "proof (rule winding_number_comp[of UNIV])"], ["proof (state)\ngoal (5 subgoals):\n 1. open UNIV\n 2. f holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>\n 5. z \\<notin> path_image (f \\<circ> \\<gamma>)", "show \"z \\<notin> path_image (f \\<circ> \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (f \\<circ> \\<gamma>)", "using \\<open>z\\<notin>path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (f \\<circ> \\<gamma>)", "unfolding f_def path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> \\<gamma> ` {0..1}\n\ngoal (1 subgoal):\n 1. z \\<notin> ((\\<lambda>x. \\<i> * (x - z) + z) \\<circ> \\<gamma>) ` {0..1}", "by auto"], ["proof (state)\nthis:\n  z \\<notin> path_image (f \\<circ> \\<gamma>)\n\ngoal (4 subgoals):\n 1. open UNIV\n 2. f holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>", "qed (auto simp add:f_def \\<open>valid_path \\<gamma>\\<close> intro!:holomorphic_intros)"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = c * contour_integral \\<gamma> (\\<lambda>w.  1 / (w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "have \"deriv f x = \\<i>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv f x = \\<i>", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (\\<lambda>x. \\<i> * (x - z) + z) x = \\<i>", "by (auto intro!:derivative_eq_intros DERIV_imp_deriv)"], ["proof (state)\nthis:\n  deriv f ?x = \\<i>\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "then"], ["proof (chain)\npicking this:\n  deriv f ?x = \\<i>", "show ?thesis"], ["proof (prove)\nusing this:\n  deriv f ?x = \\<i>\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "unfolding f_def c_def"], ["proof (prove)\nusing this:\n  deriv (\\<lambda>x. \\<i> * (x - z) + z) ?x = \\<i>\n\ngoal (1 subgoal):\n 1. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma>\n     (\\<lambda>w.\n         deriv (\\<lambda>x. \\<i> * (x - z) + z) w /\n         (\\<i> * (w - z) + z - z)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "by (auto simp add:field_simps divide_simps intro!:arg_cong2[where f=contour_integral])"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = winding_number \\<gamma> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n    winding_number \\<gamma> z", "using winding_number_valid_path[OF \\<open>valid_path \\<gamma>\\<close> \\<open>z\\<notin>path_image \\<gamma>\\<close>,folded c_def]"], ["proof (prove)\nusing this:\n  winding_number \\<gamma> z =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n    winding_number \\<gamma> z", "by simp"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n  winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "finally"], ["proof (chain)\npicking this:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "."], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "moreover"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "have \"pathfinish \\<gamma>' = z+ \\<i>* pathfinish \\<gamma> - \\<i>*z\" \"pathstart \\<gamma>' = z+ \\<i>*pathstart \\<gamma> - \\<i>*z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish \\<gamma>' = z + \\<i> * pathfinish \\<gamma> - \\<i> * z &&&\n    pathstart \\<gamma>' = z + \\<i> * pathstart \\<gamma> - \\<i> * z", "unfolding \\<gamma>'_def path_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * (\\<gamma> 1 - z) + z = z + \\<i> * \\<gamma> 1 - \\<i> * z &&&\n    \\<i> * (\\<gamma> 0 - z) + z = z + \\<i> * \\<gamma> 0 - \\<i> * z", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  pathfinish \\<gamma>' = z + \\<i> * pathfinish \\<gamma> - \\<i> * z\n  pathstart \\<gamma>' = z + \\<i> * pathstart \\<gamma> - \\<i> * z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n  pathfinish \\<gamma>' = z + \\<i> * pathfinish \\<gamma> - \\<i> * z\n  pathstart \\<gamma>' = z + \\<i> * pathstart \\<gamma> - \\<i> * z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n  pathfinish \\<gamma>' = z + \\<i> * pathfinish \\<gamma> - \\<i> * z\n  pathstart \\<gamma>' = z + \\<i> * pathstart \\<gamma> - \\<i> * z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n     Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n    (2 * pi)", "by auto"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma> z) =\n  (Im (Ln (\\<i> * pathfinish \\<gamma> - \\<i> * z)) -\n   Im (Ln (\\<i> * pathstart \\<gamma> - \\<i> * z))) /\n  (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Re_winding_number_half_left:\n  assumes neg_img:\"\\<forall>p\\<in>path_image \\<gamma>. Re p \\<le> Re z\" and \"valid_path \\<gamma>\" and \"z\\<notin>path_image \\<gamma>\"\n  shows \"Re(winding_number \\<gamma> z) = (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma> )))/(2*pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "define \\<gamma>' where \"\\<gamma>'\\<equiv>(\\<lambda>t. 2*z - \\<gamma> t)\""], ["proof (state)\nthis:\n  \\<gamma>' \\<equiv> \\<lambda>t. 2 * z - \\<gamma> t\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "have \"Re (winding_number \\<gamma>' z) = (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma>' z) =\n    (Im (Ln (pathfinish \\<gamma>' - z)) -\n     Im (Ln (pathstart \\<gamma>' - z))) /\n    (2 * pi)", "unfolding \\<gamma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (\\<lambda>t. 2 * z - \\<gamma> t) z) =\n    (Im (Ln (pathfinish (\\<lambda>t. 2 * z - \\<gamma> t) - z)) -\n     Im (Ln (pathstart (\\<lambda>t. 2 * z - \\<gamma> t) - z))) /\n    (2 * pi)", "apply (rule Re_winding_number_half_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. 2 * z - \\<gamma> t).\n       Re z \\<le> Re p\n 2. valid_path (\\<lambda>t. 2 * z - \\<gamma> t)\n 3. z \\<notin> path_image (\\<lambda>t. 2 * z - \\<gamma> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. 2 * z - \\<gamma> t).\n       Re z \\<le> Re p", "using neg_img"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>path_image \\<gamma>. Re p \\<le> Re z\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. 2 * z - \\<gamma> t).\n       Re z \\<le> Re p", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>\\<gamma> ` {0..1}. Re p \\<le> Re z\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>(\\<lambda>t. 2 * z - \\<gamma> t) ` {0..1}.\n       Re z \\<le> Re p", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path (\\<lambda>t. 2 * z - \\<gamma> t)\n 2. z \\<notin> path_image (\\<lambda>t. 2 * z - \\<gamma> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. 2 * z - \\<gamma> t)", "apply (rule valid_path_compose_holomorphic[OF \\<open>valid_path \\<gamma>\\<close>,of \"\\<lambda>t. 2*z-t\" UNIV,\n            unfolded comp_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (-) (2 * z) holomorphic_on UNIV\n 2. open UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV", "by (auto intro:holomorphic_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. 2 * z - \\<gamma> t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. 2 * z - \\<gamma> t)", "using \\<open>z\\<notin>path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (\\<lambda>t. 2 * z - \\<gamma> t)", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> \\<gamma> ` {0..1}\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<lambda>t. 2 * z - \\<gamma> t) ` {0..1}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "moreover"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "have \"winding_number \\<gamma>' z = winding_number \\<gamma> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "define f where \"f=(\\<lambda>t. 2*z-t)\""], ["proof (state)\nthis:\n  f = (-) (2 * z)\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "define c where \"c= 1 / (complex_of_real (2 * pi) * \\<i>)\""], ["proof (state)\nthis:\n  c = 1 / (complex_of_real (2 * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"winding_number \\<gamma>' z = winding_number (f o \\<gamma>) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z", "unfolding \\<gamma>'_def comp_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. 2 * z - \\<gamma> t) z =\n    winding_number (\\<lambda>x. 2 * z - \\<gamma> x) z", "by auto"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number (f \\<circ> \\<gamma>) z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (f \\<circ> \\<gamma>) z =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))", "proof (rule winding_number_comp[of UNIV])"], ["proof (state)\ngoal (5 subgoals):\n 1. open UNIV\n 2. f holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>\n 5. z \\<notin> path_image (f \\<circ> \\<gamma>)", "show \"z \\<notin> path_image (f \\<circ> \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (f \\<circ> \\<gamma>)", "using \\<open>z\\<notin>path_image \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image \\<gamma>\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image (f \\<circ> \\<gamma>)", "unfolding f_def path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> \\<gamma> ` {0..1}\n\ngoal (1 subgoal):\n 1. z \\<notin> ((-) (2 * z) \\<circ> \\<gamma>) ` {0..1}", "by auto"], ["proof (state)\nthis:\n  z \\<notin> path_image (f \\<circ> \\<gamma>)\n\ngoal (4 subgoals):\n 1. open UNIV\n 2. f holomorphic_on UNIV\n 3. path_image \\<gamma> \\<subseteq> UNIV\n 4. valid_path \\<gamma>", "qed (auto simp add:f_def \\<open>valid_path \\<gamma>\\<close> intro:holomorphic_intros)"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  winding_number (f \\<circ> \\<gamma>) z =\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = c * contour_integral \\<gamma> (\\<lambda>w.  1 / (w - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n    c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "unfolding f_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma>\n     (\\<lambda>w. deriv ((-) (2 * z)) w / (2 * z - w - z)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))", "by (auto simp add:field_simps divide_simps intro!:arg_cong2[where f=contour_integral])"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "also"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. deriv f w / (f w - z)) =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "have \"... = winding_number \\<gamma> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n    winding_number \\<gamma> z", "using winding_number_valid_path[OF \\<open>valid_path \\<gamma>\\<close> \\<open>z\\<notin>path_image \\<gamma>\\<close>,folded c_def]"], ["proof (prove)\nusing this:\n  winding_number \\<gamma> z =\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z))\n\ngoal (1 subgoal):\n 1. c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n    winding_number \\<gamma> z", "by simp"], ["proof (state)\nthis:\n  c * contour_integral \\<gamma> (\\<lambda>w. 1 / (w - z)) =\n  winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "finally"], ["proof (chain)\npicking this:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. winding_number \\<gamma>' z = winding_number \\<gamma> z", "."], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "moreover"], ["proof (state)\nthis:\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "have \"pathfinish \\<gamma>' = 2*z - pathfinish \\<gamma>\" \"pathstart \\<gamma>' = 2*z - pathstart \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish \\<gamma>' = 2 * z - pathfinish \\<gamma> &&&\n    pathstart \\<gamma>' = 2 * z - pathstart \\<gamma>", "unfolding \\<gamma>'_def path_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * z - \\<gamma> 1 = 2 * z - \\<gamma> 1 &&&\n    2 * z - \\<gamma> 0 = 2 * z - \\<gamma> 0", "by auto"], ["proof (state)\nthis:\n  pathfinish \\<gamma>' = 2 * z - pathfinish \\<gamma>\n  pathstart \\<gamma>' = 2 * z - pathstart \\<gamma>\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n  pathfinish \\<gamma>' = 2 * z - pathfinish \\<gamma>\n  pathstart \\<gamma>' = 2 * z - pathstart \\<gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number \\<gamma>' z) =\n  (Im (Ln (pathfinish \\<gamma>' - z)) - Im (Ln (pathstart \\<gamma>' - z))) /\n  (2 * pi)\n  winding_number \\<gamma>' z = winding_number \\<gamma> z\n  pathfinish \\<gamma>' = 2 * z - pathfinish \\<gamma>\n  pathstart \\<gamma>' = 2 * z - pathstart \\<gamma>\n\ngoal (1 subgoal):\n 1. Re (winding_number \\<gamma> z) =\n    (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n    (2 * pi)", "by auto"], ["proof (state)\nthis:\n  Re (winding_number \\<gamma> z) =\n  (Im (Ln (z - pathfinish \\<gamma>)) - Im (Ln (z - pathstart \\<gamma>))) /\n  (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_open_Collect_neq:\n  fixes f g :: \"'a::topological_space \\<Rightarrow> 'b::t2_space\"\n  assumes f: \"continuous_on S f\" and g: \"continuous_on S g\" and \"open S\"\n  shows \"open {x\\<in>S. f x \\<noteq> g x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {x \\<in> S. f x \\<noteq> g x}", "proof (rule topological_space_class.openI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "assume \"t \\<in> {x\\<in>S. f x \\<noteq> g x}\""], ["proof (state)\nthis:\n  t \\<in> {x \\<in> S. f x \\<noteq> g x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "then"], ["proof (chain)\npicking this:\n  t \\<in> {x \\<in> S. f x \\<noteq> g x}", "obtain U0 V0 where \"open U0\" \"open V0\" \"f t \\<in> U0\" \"g t \\<in> V0\" \"U0 \\<inter> V0 = {}\" \"t\\<in>S\""], ["proof (prove)\nusing this:\n  t \\<in> {x \\<in> S. f x \\<noteq> g x}\n\ngoal (1 subgoal):\n 1. (\\<And>U0 V0.\n        \\<lbrakk>open U0; open V0; f t \\<in> U0; g t \\<in> V0;\n         U0 \\<inter> V0 = {}; t \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: separation_t2)"], ["proof (state)\nthis:\n  open U0\n  open V0\n  f t \\<in> U0\n  g t \\<in> V0\n  U0 \\<inter> V0 = {}\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "obtain U1 where \"open U1\" \"t \\<in> U1\" \"\\<forall>y\\<in>(S \\<inter> U1). f y \\<in> U0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U1.\n        \\<lbrakk>open U1; t \\<in> U1;\n         \\<forall>y\\<in>S \\<inter> U1. f y \\<in> U0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f[unfolded continuous_on_topological,rule_format,OF \\<open>t\\<in>S\\<close> \\<open>open U0\\<close> \\<open>f t \\<in>U0\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     open A \\<and>\n     t \\<in> A \\<and>\n     (\\<forall>y\\<in>S. y \\<in> A \\<longrightarrow> f y \\<in> U0)\n\ngoal (1 subgoal):\n 1. (\\<And>U1.\n        \\<lbrakk>open U1; t \\<in> U1;\n         \\<forall>y\\<in>S \\<inter> U1. f y \\<in> U0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  open U1\n  t \\<in> U1\n  \\<forall>y\\<in>S \\<inter> U1. f y \\<in> U0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "obtain V1 where \"open V1\" \"t \\<in> V1\" \"\\<forall>y\\<in>(S \\<inter> V1). g y \\<in> V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V1.\n        \\<lbrakk>open V1; t \\<in> V1;\n         \\<forall>y\\<in>S \\<inter> V1. g y \\<in> V0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using g[unfolded continuous_on_topological,rule_format,OF \\<open>t\\<in>S\\<close> \\<open>open V0\\<close> \\<open>g t \\<in>V0\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     open A \\<and>\n     t \\<in> A \\<and>\n     (\\<forall>y\\<in>S. y \\<in> A \\<longrightarrow> g y \\<in> V0)\n\ngoal (1 subgoal):\n 1. (\\<And>V1.\n        \\<lbrakk>open V1; t \\<in> V1;\n         \\<forall>y\\<in>S \\<inter> V1. g y \\<in> V0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  open V1\n  t \\<in> V1\n  \\<forall>y\\<in>S \\<inter> V1. g y \\<in> V0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "define T where \"T=V1 \\<inter> U1 \\<inter> S\""], ["proof (state)\nthis:\n  T = V1 \\<inter> U1 \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "have \"open T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (V1 \\<inter> U1 \\<inter> S)", "using \\<open>open U1\\<close> \\<open>open V1\\<close> \\<open>open S\\<close>"], ["proof (prove)\nusing this:\n  open U1\n  open V1\n  open S\n\ngoal (1 subgoal):\n 1. open (V1 \\<inter> U1 \\<inter> S)", "by auto"], ["proof (state)\nthis:\n  open T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "moreover"], ["proof (state)\nthis:\n  open T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "have \"t \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> V1 \\<inter> U1 \\<inter> S", "using \\<open>t\\<in>U1\\<close> \\<open>t\\<in>V1\\<close> \\<open>t\\<in>S\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> U1\n  t \\<in> V1\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. t \\<in> V1 \\<inter> U1 \\<inter> S", "by auto"], ["proof (state)\nthis:\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "moreover"], ["proof (state)\nthis:\n  t \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "have \"T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V1 \\<inter> U1 \\<inter> S \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "using \\<open>U0 \\<inter> V0 = {}\\<close> \\<open>\\<forall>y\\<in>S \\<inter> U1. f y \\<in> U0\\<close> \\<open>\\<forall>y\\<in>S \\<inter> V1. g y \\<in> V0\\<close>"], ["proof (prove)\nusing this:\n  U0 \\<inter> V0 = {}\n  \\<forall>y\\<in>S \\<inter> U1. f y \\<in> U0\n  \\<forall>y\\<in>S \\<inter> V1. g y \\<in> V0\n\ngoal (1 subgoal):\n 1. V1 \\<inter> U1 \\<inter> S \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "by auto"], ["proof (state)\nthis:\n  T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x \\<in> S. f x \\<noteq> g x} \\<Longrightarrow>\n       \\<exists>T.\n          open T \\<and>\n          x \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "ultimately"], ["proof (chain)\npicking this:\n  open T\n  t \\<in> T\n  T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "show \"\\<exists>T. open T \\<and> t \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}\""], ["proof (prove)\nusing this:\n  open T\n  t \\<in> T\n  T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       open T \\<and>\n       t \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}", "by auto"], ["proof (state)\nthis:\n  \\<exists>T.\n     open T \\<and>\n     t \\<in> T \\<and> T \\<subseteq> {x \\<in> S. f x \\<noteq> g x}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sign at a filter\\<close>"], ["", "(*Relaxation in types could be done in the future.*)"], ["", "definition has_sgnx::\"(real \\<Rightarrow> real) \\<Rightarrow> real \\<Rightarrow> real filter \\<Rightarrow> bool\" \n    (infixr \"has'_sgnx\" 55) where\n  \"(f has_sgnx c) F= (eventually (\\<lambda>x. sgn(f x) = c) F)\""], ["", "definition sgnx_able (infixr \"sgnx'_able\" 55) where\n  \"(f sgnx_able F) = (\\<exists>c. (f has_sgnx c) F)\""], ["", "definition sgnx where\n  \"sgnx f F = (SOME c. (f has_sgnx c) F)\""], ["", "lemma has_sgnx_eq_rhs: \"(f has_sgnx x) F \\<Longrightarrow> x = y \\<Longrightarrow> (f has_sgnx y) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_sgnx x) F; x = y\\<rbrakk>\n    \\<Longrightarrow> (f has_sgnx y) F", "by simp"], ["", "named_theorems sgnx_intros \"introduction rules for has_sgnx\""], ["", "setup \\<open>\n  Global_Theory.add_thms_dynamic (@{binding sgnx_eq_intros},\n    fn context =>\n      Named_Theorems.get (Context.proof_of context) @{named_theorems sgnx_intros}\n      |> map_filter (try (fn thm => @{thm has_sgnx_eq_rhs} OF [thm])))\n\\<close>"], ["", "lemma sgnx_able_sgnx:\"f sgnx_able F \\<Longrightarrow> (f has_sgnx (sgnx f F)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f sgnx_able F \\<Longrightarrow> (f has_sgnx sgnx f F) F", "unfolding sgnx_able_def sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. (f has_sgnx c) F \\<Longrightarrow>\n    (f has_sgnx (SOME c. (f has_sgnx c) F)) F", "using someI_ex"], ["proof (prove)\nusing this:\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (SOME x. ?P x)\n\ngoal (1 subgoal):\n 1. \\<exists>c. (f has_sgnx c) F \\<Longrightarrow>\n    (f has_sgnx (SOME c. (f has_sgnx c) F)) F", "by metis"], ["", "lemma has_sgnx_imp_sgnx_able[elim]:\n  \"(f has_sgnx c) F \\<Longrightarrow> f sgnx_able F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx c) F \\<Longrightarrow> f sgnx_able F", "unfolding sgnx_able_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx c) F \\<Longrightarrow> \\<exists>c. (f has_sgnx c) F", "by auto"], ["", "lemma has_sgnx_unique:\n  assumes \"F\\<noteq>bot\" \"(f has_sgnx c1) F\" \"(f has_sgnx c2) F\" \n  shows \"c1=c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 = c2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow> False", "assume \"c1 \\<noteq> c2 \""], ["proof (state)\nthis:\n  c1 \\<noteq> c2\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow> False", "have \"eventually (\\<lambda>x. sgn(f x) = c1 \\<and> sgn(f x) = c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (f x) = c2", "using assms"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  (f has_sgnx c1) F\n  (f has_sgnx c2) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (f x) = c2", "unfolding has_sgnx_def eventually_conj_iff"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c2\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. sgn (f x) = c1) \\<and>\n    (\\<forall>\\<^sub>F x in F. sgn (f x) = c2)", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (f x) = c2\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (f x) = c2", "have \"eventually (\\<lambda>_. c1 = c2) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (f x) = c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F _ in F. c1 = c2", "by (elim eventually_mono,auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F _ in F. c1 = c2\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F _ in F. c1 = c2", "have \"eventually (\\<lambda>_. False) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F _ in F. c1 = c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F _ in F. False", "using \\<open>c1 \\<noteq> c2\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F _ in F. c1 = c2\n  c1 \\<noteq> c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F _ in F. False", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F _ in F. False\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F _ in F. False", "show False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F _ in F. False\n\ngoal (1 subgoal):\n 1. False", "using \\<open>F \\<noteq> bot\\<close> eventually_False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F _ in F. False\n  F \\<noteq> bot\n  (\\<forall>\\<^sub>F x in ?F. False) = (?F = bot)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_imp_sgnx[elim]:\n  \"(f has_sgnx c) F \\<Longrightarrow>F\\<noteq>bot \\<Longrightarrow> sgnx f F = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_sgnx c) F; F \\<noteq> bot\\<rbrakk>\n    \\<Longrightarrow> sgnx f F = c", "using has_sgnx_unique sgnx_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?F \\<noteq> bot; (?f has_sgnx ?c1.0) ?F;\n   (?f has_sgnx ?c2.0) ?F\\<rbrakk>\n  \\<Longrightarrow> ?c1.0 = ?c2.0\n  sgnx ?f ?F = (SOME c. (?f has_sgnx c) ?F)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_sgnx c) F; F \\<noteq> bot\\<rbrakk>\n    \\<Longrightarrow> sgnx f F = c", "by auto"], ["", "lemma has_sgnx_const[simp,sgnx_intros]:\n  \"((\\<lambda>_. c) has_sgnx sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. c) has_sgnx sgn c) F", "by (simp add: has_sgnx_def)"], ["", "lemma finite_sgnx_at_left_at_right:\n  assumes \"finite {t. f t=0 \\<and> a<t \\<and> t<b}\" \"continuous_on ({a<..<b} - s) f\" \"finite s\" \n      and x:\"x\\<in>{a<..<b}\"\n  shows \"f sgnx_able (at_left x)\" \"sgnx f (at_left x)\\<noteq>0\"\n        \"f sgnx_able (at_right x)\" \"sgnx f (at_right x)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f sgnx_able at_left x &&& sgnx f (at_left x) \\<noteq> 0) &&&\n    f sgnx_able at_right x &&& sgnx f (at_right x) \\<noteq> 0", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "define ls where \"ls \\<equiv> {t. (f t=0 \\<or> t\\<in>s) \\<and> a<t \\<and>t<x }\""], ["proof (state)\nthis:\n  ls \\<equiv> {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}\n\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "define l where \"l\\<equiv>(if ls = {} then (a+x)/2 else (Max ls + x)/2)\""], ["proof (state)\nthis:\n  l \\<equiv> if ls = {} then (a + x) / 2 else (Max ls + x) / 2\n\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "have \"finite ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite ls", "have \"{t. f t=0 \\<and> a<t \\<and> t<x} \\<subseteq> {t. f t=0 \\<and> a<t \\<and> t<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. f t = 0 \\<and> a < t \\<and> t < x}\n    \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. {t. f t = 0 \\<and> a < t \\<and> t < x}\n    \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  {t. f t = 0 \\<and> a < t \\<and> t < x}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite ls", "then"], ["proof (chain)\npicking this:\n  {t. f t = 0 \\<and> a < t \\<and> t < x}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}", "have \"finite {t. f t=0 \\<and> a<t \\<and> t<x}\""], ["proof (prove)\nusing this:\n  {t. f t = 0 \\<and> a < t \\<and> t < x}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite {t. f t = 0 \\<and> a < t \\<and> t < x}", "using assms(1)"], ["proof (prove)\nusing this:\n  {t. f t = 0 \\<and> a < t \\<and> t < x}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n  finite {t. f t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite {t. f t = 0 \\<and> a < t \\<and> t < x}", "using finite_subset"], ["proof (prove)\nusing this:\n  {t. f t = 0 \\<and> a < t \\<and> t < x}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n  finite {t. f t = 0 \\<and> a < t \\<and> t < b}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {t. f t = 0 \\<and> a < t \\<and> t < x}", "by blast"], ["proof (state)\nthis:\n  finite {t. f t = 0 \\<and> a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. finite ls", "moreover"], ["proof (state)\nthis:\n  finite {t. f t = 0 \\<and> a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. finite ls", "have \"finite {t. t\\<in>s \\<and> a<t \\<and> t<x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t \\<in> s. a < t \\<and> t < x}", "using assms(3)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. finite {t \\<in> s. a < t \\<and> t < x}", "by auto"], ["proof (state)\nthis:\n  finite {t \\<in> s. a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. finite ls", "moreover"], ["proof (state)\nthis:\n  finite {t \\<in> s. a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. finite ls", "have \"ls = {t. f t=0 \\<and> a<t \\<and> t<x} \\<union> {t. t\\<in>s \\<and> a<t \\<and> t<x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls =\n    {t. f t = 0 \\<and> a < t \\<and> t < x} \\<union>\n    {t \\<in> s. a < t \\<and> t < x}", "unfolding ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x} =\n    {t. f t = 0 \\<and> a < t \\<and> t < x} \\<union>\n    {t \\<in> s. a < t \\<and> t < x}", "by auto"], ["proof (state)\nthis:\n  ls =\n  {t. f t = 0 \\<and> a < t \\<and> t < x} \\<union>\n  {t \\<in> s. a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. finite ls", "ultimately"], ["proof (chain)\npicking this:\n  finite {t. f t = 0 \\<and> a < t \\<and> t < x}\n  finite {t \\<in> s. a < t \\<and> t < x}\n  ls =\n  {t. f t = 0 \\<and> a < t \\<and> t < x} \\<union>\n  {t \\<in> s. a < t \\<and> t < x}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {t. f t = 0 \\<and> a < t \\<and> t < x}\n  finite {t \\<in> s. a < t \\<and> t < x}\n  ls =\n  {t. f t = 0 \\<and> a < t \\<and> t < x} \\<union>\n  {t \\<in> s. a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. finite ls", "by auto"], ["proof (state)\nthis:\n  finite ls\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ls\n\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "have [simp]: \"l<x\" \"a<l\" \"l<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < x &&& a < l &&& l < b", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. l < x\n 2. a < l\n 3. l < b", "have \"l<x \\<and> a<l \\<and> l<b\" when \"ls = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "using that x"], ["proof (prove)\nusing this:\n  ls = {}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "unfolding l_def"], ["proof (prove)\nusing this:\n  ls = {}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < x \\<and>\n    a < (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) \\<and>\n    (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < b", "by auto"], ["proof (state)\nthis:\n  ls = {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b\n\ngoal (3 subgoals):\n 1. l < x\n 2. a < l\n 3. l < b", "moreover"], ["proof (state)\nthis:\n  ls = {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b\n\ngoal (3 subgoals):\n 1. l < x\n 2. a < l\n 3. l < b", "have \"l<x \\<and> a<l \\<and> l<b\" when \"ls \\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "have \"Max ls \\<in> ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ls \\<in> ls", "using assms(1,3) that \\<open>finite ls\\<close>"], ["proof (prove)\nusing this:\n  finite {t. f t = 0 \\<and> a < t \\<and> t < b}\n  finite s\n  ls \\<noteq> {}\n  finite ls\n\ngoal (1 subgoal):\n 1. Max ls \\<in> ls", "apply (intro linorder_class.Max_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite {t. f t = 0 \\<and> a < t \\<and> t < b}; finite s;\n     ls \\<noteq> {}; finite ls\\<rbrakk>\n    \\<Longrightarrow> finite ls\n 2. \\<lbrakk>finite {t. f t = 0 \\<and> a < t \\<and> t < b}; finite s;\n     ls \\<noteq> {}; finite ls\\<rbrakk>\n    \\<Longrightarrow> ls \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Max ls \\<in> ls\n\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "then"], ["proof (chain)\npicking this:\n  Max ls \\<in> ls", "have \"a<Max ls \\<and> Max ls < x\""], ["proof (prove)\nusing this:\n  Max ls \\<in> ls\n\ngoal (1 subgoal):\n 1. a < Max ls \\<and> Max ls < x", "unfolding ls_def"], ["proof (prove)\nusing this:\n  Max {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}\n  \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}\n\ngoal (1 subgoal):\n 1. a < Max {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x} \\<and>\n    Max {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x} < x", "by auto"], ["proof (state)\nthis:\n  a < Max ls \\<and> Max ls < x\n\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "then"], ["proof (chain)\npicking this:\n  a < Max ls \\<and> Max ls < x", "show ?thesis"], ["proof (prove)\nusing this:\n  a < Max ls \\<and> Max ls < x\n\ngoal (1 subgoal):\n 1. l < x \\<and> a < l \\<and> l < b", "unfolding l_def"], ["proof (prove)\nusing this:\n  a < Max ls \\<and> Max ls < x\n\ngoal (1 subgoal):\n 1. (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < x \\<and>\n    a < (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) \\<and>\n    (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < b", "using that x"], ["proof (prove)\nusing this:\n  a < Max ls \\<and> Max ls < x\n  ls \\<noteq> {}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < x \\<and>\n    a < (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) \\<and>\n    (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < b", "by auto"], ["proof (state)\nthis:\n  l < x \\<and> a < l \\<and> l < b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ls \\<noteq> {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b\n\ngoal (3 subgoals):\n 1. l < x\n 2. a < l\n 3. l < b", "ultimately"], ["proof (chain)\npicking this:\n  ls = {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b\n  ls \\<noteq> {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b", "show \"l<x\" \"a<l\" \"l<b\""], ["proof (prove)\nusing this:\n  ls = {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b\n  ls \\<noteq> {} \\<Longrightarrow> l < x \\<and> a < l \\<and> l < b\n\ngoal (1 subgoal):\n 1. l < x &&& a < l &&& l < b", "by auto"], ["proof (state)\nthis:\n  l < x\n  a < l\n  l < b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l < x\n  a < l\n  l < b\n\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "have noroot:\"f t\\<noteq>0\" when t:\"t\\<in>{l..<x}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. f t \\<noteq> 0", "proof (cases \"ls = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ls = {} \\<Longrightarrow> f t \\<noteq> 0\n 2. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "case True"], ["proof (state)\nthis:\n  ls = {}\n\ngoal (2 subgoals):\n 1. ls = {} \\<Longrightarrow> f t \\<noteq> 0\n 2. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "have False when \"f t=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"t>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < t", "using t \\<open>l>a\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {l..<x}\n  a < l\n\ngoal (1 subgoal):\n 1. a < t", "by (meson atLeastLessThan_iff less_le_trans)"], ["proof (state)\nthis:\n  a < t\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  a < t", "have \"t\\<in>ls\""], ["proof (prove)\nusing this:\n  a < t\n\ngoal (1 subgoal):\n 1. t \\<in> ls", "using that t"], ["proof (prove)\nusing this:\n  a < t\n  f t = 0\n  t \\<in> {l..<x}\n\ngoal (1 subgoal):\n 1. t \\<in> ls", "unfolding ls_def"], ["proof (prove)\nusing this:\n  a < t\n  f t = 0\n  t \\<in> {l..<x}\n\ngoal (1 subgoal):\n 1. t \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}", "by auto"], ["proof (state)\nthis:\n  t \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t \\<in> ls", "show False"], ["proof (prove)\nusing this:\n  t \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "using True"], ["proof (prove)\nusing this:\n  t \\<in> ls\n  ls = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. ls = {} \\<Longrightarrow> f t \\<noteq> 0\n 2. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  f t = 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  ls \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "have \"t>Max ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ls < t", "using that False \\<open>l<x\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {l..<x}\n  ls \\<noteq> {}\n  l < x\n\ngoal (1 subgoal):\n 1. Max ls < t", "unfolding l_def"], ["proof (prove)\nusing this:\n  t \\<in> {if ls = {} then (a + x) / 2 else (Max ls + x) / 2..<x}\n  ls \\<noteq> {}\n  (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < x\n\ngoal (1 subgoal):\n 1. Max ls < t", "by auto"], ["proof (state)\nthis:\n  Max ls < t\n\ngoal (1 subgoal):\n 1. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "have False when \"f t=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"t>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < t", "using t \\<open>l>a\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {l..<x}\n  a < l\n\ngoal (1 subgoal):\n 1. a < t", "by (meson atLeastLessThan_iff less_le_trans)"], ["proof (state)\nthis:\n  a < t\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  a < t", "have \"t\\<in>ls\""], ["proof (prove)\nusing this:\n  a < t\n\ngoal (1 subgoal):\n 1. t \\<in> ls", "using that t"], ["proof (prove)\nusing this:\n  a < t\n  f t = 0\n  t \\<in> {l..<x}\n\ngoal (1 subgoal):\n 1. t \\<in> ls", "unfolding ls_def"], ["proof (prove)\nusing this:\n  a < t\n  f t = 0\n  t \\<in> {l..<x}\n\ngoal (1 subgoal):\n 1. t \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}", "by auto"], ["proof (state)\nthis:\n  t \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t \\<in> ls", "have \"t\\<le>Max ls\""], ["proof (prove)\nusing this:\n  t \\<in> ls\n\ngoal (1 subgoal):\n 1. t \\<le> Max ls", "using \\<open>finite ls\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> ls\n  finite ls\n\ngoal (1 subgoal):\n 1. t \\<le> Max ls", "by auto"], ["proof (state)\nthis:\n  t \\<le> Max ls\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t \\<le> Max ls", "show False"], ["proof (prove)\nusing this:\n  t \\<le> Max ls\n\ngoal (1 subgoal):\n 1. False", "using \\<open>t>Max ls\\<close>"], ["proof (prove)\nusing this:\n  t \\<le> Max ls\n  Max ls < t\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ls \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  f t = 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f t \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> {l..<x} \\<Longrightarrow> f ?t \\<noteq> 0\n\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "have \"(f has_sgnx sgn (f l)) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f l)) (at_left x)", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left x. sgn (f x) = sgn (f l)", "proof (rule eventually_at_leftI[OF _ \\<open>l<x\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "assume t:\"t\\<in>{l<..<x}\""], ["proof (state)\nthis:\n  t \\<in> {l<..<x}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "then"], ["proof (chain)\npicking this:\n  t \\<in> {l<..<x}", "have [simp]:\"t>a\" \"t<b\""], ["proof (prove)\nusing this:\n  t \\<in> {l<..<x}\n\ngoal (1 subgoal):\n 1. a < t &&& t < b", "using \\<open>l>a\\<close> x"], ["proof (prove)\nusing this:\n  t \\<in> {l<..<x}\n  a < l\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. a < t &&& t < b", "by (meson greaterThanLessThan_iff less_trans)+"], ["proof (state)\nthis:\n  a < t\n  t < b\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "have False when \"f t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using noroot t that"], ["proof (prove)\nusing this:\n  ?t \\<in> {l..<x} \\<Longrightarrow> f ?t \\<noteq> 0\n  t \\<in> {l<..<x}\n  f t = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "moreover"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "have False when \"f l=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using noroot t that"], ["proof (prove)\nusing this:\n  ?t \\<in> {l..<x} \\<Longrightarrow> f ?t \\<noteq> 0\n  t \\<in> {l<..<x}\n  f l = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  f l = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "moreover"], ["proof (state)\nthis:\n  f l = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "have False when \"f l>0 \\<and> f t<0 \\<or> f l <0 \\<and> f t >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have False when \"{l..t} \\<inter> s \\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain t' where t':\"t'\\<in>{l..t}\" \"t'\\<in>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> {l..t}; t' \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>{l..t} \\<inter> s \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  {l..t} \\<inter> s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> {l..t}; t' \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> {l..t}\n  t' \\<in> s\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {l..t}\n  t' \\<in> s", "have \"a<t' \\<and> t'<x\""], ["proof (prove)\nusing this:\n  t' \\<in> {l..t}\n  t' \\<in> s\n\ngoal (1 subgoal):\n 1. a < t' \\<and> t' < x", "by (metis \\<open>a < l\\<close> atLeastAtMost_iff greaterThanLessThan_iff le_less less_trans t)"], ["proof (state)\nthis:\n  a < t' \\<and> t' < x\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  a < t' \\<and> t' < x", "have \"t'\\<in>ls\""], ["proof (prove)\nusing this:\n  a < t' \\<and> t' < x\n\ngoal (1 subgoal):\n 1. t' \\<in> ls", "unfolding ls_def"], ["proof (prove)\nusing this:\n  a < t' \\<and> t' < x\n\ngoal (1 subgoal):\n 1. t' \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}", "using \\<open>t'\\<in>s\\<close>"], ["proof (prove)\nusing this:\n  a < t' \\<and> t' < x\n  t' \\<in> s\n\ngoal (1 subgoal):\n 1. t' \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> a < t \\<and> t < x}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> ls", "have \"t'\\<le>Max ls\""], ["proof (prove)\nusing this:\n  t' \\<in> ls\n\ngoal (1 subgoal):\n 1. t' \\<le> Max ls", "using \\<open>finite ls\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> ls\n  finite ls\n\ngoal (1 subgoal):\n 1. t' \\<le> Max ls", "by auto"], ["proof (state)\nthis:\n  t' \\<le> Max ls\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  t' \\<le> Max ls\n\ngoal (1 subgoal):\n 1. False", "have \"Max ls<l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ls < l", "using \\<open>l<x\\<close> \\<open>t'\\<in>ls\\<close> \\<open>finite ls\\<close>"], ["proof (prove)\nusing this:\n  l < x\n  t' \\<in> ls\n  finite ls\n\ngoal (1 subgoal):\n 1. Max ls < l", "unfolding l_def"], ["proof (prove)\nusing this:\n  (if ls = {} then (a + x) / 2 else (Max ls + x) / 2) < x\n  t' \\<in> ls\n  finite ls\n\ngoal (1 subgoal):\n 1. Max ls < (if ls = {} then (a + x) / 2 else (Max ls + x) / 2)", "by (auto simp add:ls_def )"], ["proof (state)\nthis:\n  Max ls < l\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  t' \\<le> Max ls\n  Max ls < l", "show False"], ["proof (prove)\nusing this:\n  t' \\<le> Max ls\n  Max ls < l\n\ngoal (1 subgoal):\n 1. False", "using t'(1)"], ["proof (prove)\nusing this:\n  t' \\<le> Max ls\n  Max ls < l\n  t' \\<in> {l..t}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {l..t} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  {l..t} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "have \"{l..t} \\<subseteq> {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l..t} \\<subseteq> {a<..<b}", "by (intro atMostAtLeast_subset_convex,auto)"], ["proof (state)\nthis:\n  {l..t} \\<subseteq> {a<..<b}\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  {l..t} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n  {l..t} \\<subseteq> {a<..<b}", "have \"continuous_on {l..t} f\""], ["proof (prove)\nusing this:\n  {l..t} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n  {l..t} \\<subseteq> {a<..<b}\n\ngoal (1 subgoal):\n 1. continuous_on {l..t} f", "using assms(2)"], ["proof (prove)\nusing this:\n  {l..t} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n  {l..t} \\<subseteq> {a<..<b}\n  continuous_on ({a<..<b} - s) f\n\ngoal (1 subgoal):\n 1. continuous_on {l..t} f", "by (elim continuous_on_subset,auto)"], ["proof (state)\nthis:\n  continuous_on {l..t} f\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {l..t} f", "have \"\\<exists>x>l. x < t \\<and> f x = 0\""], ["proof (prove)\nusing this:\n  continuous_on {l..t} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>l. x < t \\<and> f x = 0", "apply (intro IVT_strict)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {l..t} f \\<Longrightarrow>\n    0 < f l \\<and> f t < 0 \\<or> f l < 0 \\<and> 0 < f t\n 2. continuous_on {l..t} f \\<Longrightarrow> l < t\n 3. continuous_on {l..t} f \\<Longrightarrow> continuous_on {l..t} f", "using that t assms(2)"], ["proof (prove)\nusing this:\n  0 < f l \\<and> f t < 0 \\<or> f l < 0 \\<and> 0 < f t\n  t \\<in> {l<..<x}\n  continuous_on ({a<..<b} - s) f\n\ngoal (3 subgoals):\n 1. continuous_on {l..t} f \\<Longrightarrow>\n    0 < f l \\<and> f t < 0 \\<or> f l < 0 \\<and> 0 < f t\n 2. continuous_on {l..t} f \\<Longrightarrow> l < t\n 3. continuous_on {l..t} f \\<Longrightarrow> continuous_on {l..t} f", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>l. x < t \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>l. x < t \\<and> f x = 0", "obtain t' where \"l<t'\" \"t'<t\" \"f t'=0\""], ["proof (prove)\nusing this:\n  \\<exists>x>l. x < t \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>l < t'; t' < t; f t' = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l < t'\n  t' < t\n  f t' = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  l < t'\n  t' < t\n  f t' = 0", "have \"t'\\<in>{l..<x}\""], ["proof (prove)\nusing this:\n  l < t'\n  t' < t\n  f t' = 0\n\ngoal (1 subgoal):\n 1. t' \\<in> {l..<x}", "unfolding ls_def"], ["proof (prove)\nusing this:\n  l < t'\n  t' < t\n  f t' = 0\n\ngoal (1 subgoal):\n 1. t' \\<in> {l..<x}", "using t"], ["proof (prove)\nusing this:\n  l < t'\n  t' < t\n  f t' = 0\n  t \\<in> {l<..<x}\n\ngoal (1 subgoal):\n 1. t' \\<in> {l..<x}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> {l..<x}\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {l..<x}", "show False"], ["proof (prove)\nusing this:\n  t' \\<in> {l..<x}\n\ngoal (1 subgoal):\n 1. False", "using noroot \\<open>f t'=0\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> {l..<x}\n  ?t \\<in> {l..<x} \\<Longrightarrow> f ?t \\<noteq> 0\n  f t' = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < f l \\<and> f t < 0 \\<or> f l < 0 \\<and> 0 < f t \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {l<..<x} \\<Longrightarrow> sgn (f xa) = sgn (f l)", "ultimately"], ["proof (chain)\npicking this:\n  f t = 0 \\<Longrightarrow> False\n  f l = 0 \\<Longrightarrow> False\n  0 < f l \\<and> f t < 0 \\<or> f l < 0 \\<and> 0 < f t \\<Longrightarrow>\n  False", "show \"sgn (f t) = sgn (f l)\""], ["proof (prove)\nusing this:\n  f t = 0 \\<Longrightarrow> False\n  f l = 0 \\<Longrightarrow> False\n  0 < f l \\<and> f t < 0 \\<or> f l < 0 \\<and> 0 < f t \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. sgn (f t) = sgn (f l)", "by (metis le_less not_less sgn_if)"], ["proof (state)\nthis:\n  sgn (f t) = sgn (f l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx sgn (f l)) (at_left x)\n\ngoal (4 subgoals):\n 1. f sgnx_able at_left x\n 2. sgnx f (at_left x) \\<noteq> 0\n 3. f sgnx_able at_right x\n 4. sgnx f (at_right x) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx sgn (f l)) (at_left x)", "show \"f sgnx_able (at_left x)\""], ["proof (prove)\nusing this:\n  (f has_sgnx sgn (f l)) (at_left x)\n\ngoal (1 subgoal):\n 1. f sgnx_able at_left x", "by auto"], ["proof (state)\nthis:\n  f sgnx_able at_left x\n\ngoal (3 subgoals):\n 1. sgnx f (at_left x) \\<noteq> 0\n 2. f sgnx_able at_right x\n 3. sgnx f (at_right x) \\<noteq> 0", "show \"sgnx f (at_left x)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f (at_left x) \\<noteq> 0", "using noroot[of l,simplified] \\<open>(f has_sgnx sgn (f l)) (at_left x)\\<close>"], ["proof (prove)\nusing this:\n  f l \\<noteq> 0\n  (f has_sgnx sgn (f l)) (at_left x)\n\ngoal (1 subgoal):\n 1. sgnx f (at_left x) \\<noteq> 0", "by (simp add: has_sgnx_imp_sgnx sgn_if)"], ["proof (state)\nthis:\n  sgnx f (at_left x) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "define rs where \"rs \\<equiv> {t. (f t=0 \\<or> t\\<in>s) \\<and> x<t \\<and> t<b}\""], ["proof (state)\nthis:\n  rs \\<equiv> {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "define r where \"r\\<equiv>(if rs = {} then (x+b)/2 else (Min rs + x)/2)\""], ["proof (state)\nthis:\n  r \\<equiv> if rs = {} then (x + b) / 2 else (Min rs + x) / 2\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "have \"finite rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite rs", "have \"{t. f t=0 \\<and> x<t \\<and> t<b} \\<subseteq> {t. f t=0 \\<and> a<t \\<and> t<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. f t = 0 \\<and> x < t \\<and> t < b}\n    \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. {t. f t = 0 \\<and> x < t \\<and> t < b}\n    \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  {t. f t = 0 \\<and> x < t \\<and> t < b}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "then"], ["proof (chain)\npicking this:\n  {t. f t = 0 \\<and> x < t \\<and> t < b}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}", "have \"finite {t. f t=0 \\<and> x<t \\<and> t<b}\""], ["proof (prove)\nusing this:\n  {t. f t = 0 \\<and> x < t \\<and> t < b}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite {t. f t = 0 \\<and> x < t \\<and> t < b}", "using assms(1)"], ["proof (prove)\nusing this:\n  {t. f t = 0 \\<and> x < t \\<and> t < b}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n  finite {t. f t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite {t. f t = 0 \\<and> x < t \\<and> t < b}", "using finite_subset"], ["proof (prove)\nusing this:\n  {t. f t = 0 \\<and> x < t \\<and> t < b}\n  \\<subseteq> {t. f t = 0 \\<and> a < t \\<and> t < b}\n  finite {t. f t = 0 \\<and> a < t \\<and> t < b}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {t. f t = 0 \\<and> x < t \\<and> t < b}", "by blast"], ["proof (state)\nthis:\n  finite {t. f t = 0 \\<and> x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "moreover"], ["proof (state)\nthis:\n  finite {t. f t = 0 \\<and> x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "have \"finite {t. t\\<in>s \\<and> x<t \\<and> t<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t \\<in> s. x < t \\<and> t < b}", "using assms(3)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. finite {t \\<in> s. x < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  finite {t \\<in> s. x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "moreover"], ["proof (state)\nthis:\n  finite {t \\<in> s. x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "have \"rs = {t. f t=0 \\<and> x<t \\<and> t<b} \\<union> {t. t\\<in>s \\<and> x<t \\<and> t<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs =\n    {t. f t = 0 \\<and> x < t \\<and> t < b} \\<union>\n    {t \\<in> s. x < t \\<and> t < b}", "unfolding rs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b} =\n    {t. f t = 0 \\<and> x < t \\<and> t < b} \\<union>\n    {t \\<in> s. x < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  rs =\n  {t. f t = 0 \\<and> x < t \\<and> t < b} \\<union>\n  {t \\<in> s. x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "ultimately"], ["proof (chain)\npicking this:\n  finite {t. f t = 0 \\<and> x < t \\<and> t < b}\n  finite {t \\<in> s. x < t \\<and> t < b}\n  rs =\n  {t. f t = 0 \\<and> x < t \\<and> t < b} \\<union>\n  {t \\<in> s. x < t \\<and> t < b}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {t. f t = 0 \\<and> x < t \\<and> t < b}\n  finite {t \\<in> s. x < t \\<and> t < b}\n  rs =\n  {t. f t = 0 \\<and> x < t \\<and> t < b} \\<union>\n  {t \\<in> s. x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite rs", "by auto"], ["proof (state)\nthis:\n  finite rs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite rs\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "have [simp]: \"r>x\" \"a<r\" \"r<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < r &&& a < r &&& r < b", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. x < r\n 2. a < r\n 3. r < b", "have \"r>x \\<and> a<r \\<and> r<b\" when \"rs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "using that x"], ["proof (prove)\nusing this:\n  rs = {}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "unfolding r_def"], ["proof (prove)\nusing this:\n  rs = {}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. x < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) \\<and>\n    a < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) \\<and>\n    (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) < b", "by auto"], ["proof (state)\nthis:\n  rs = {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b\n\ngoal (3 subgoals):\n 1. x < r\n 2. a < r\n 3. r < b", "moreover"], ["proof (state)\nthis:\n  rs = {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b\n\ngoal (3 subgoals):\n 1. x < r\n 2. a < r\n 3. r < b", "have \"r>x \\<and> a<r \\<and> r<b\" when \"rs \\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "have \"Min rs \\<in> rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min rs \\<in> rs", "using assms(1,3) that \\<open>finite rs\\<close>"], ["proof (prove)\nusing this:\n  finite {t. f t = 0 \\<and> a < t \\<and> t < b}\n  finite s\n  rs \\<noteq> {}\n  finite rs\n\ngoal (1 subgoal):\n 1. Min rs \\<in> rs", "apply (intro linorder_class.Min_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite {t. f t = 0 \\<and> a < t \\<and> t < b}; finite s;\n     rs \\<noteq> {}; finite rs\\<rbrakk>\n    \\<Longrightarrow> finite rs\n 2. \\<lbrakk>finite {t. f t = 0 \\<and> a < t \\<and> t < b}; finite s;\n     rs \\<noteq> {}; finite rs\\<rbrakk>\n    \\<Longrightarrow> rs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Min rs \\<in> rs\n\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "then"], ["proof (chain)\npicking this:\n  Min rs \\<in> rs", "have \"x<Min rs \\<and> Min rs < b\""], ["proof (prove)\nusing this:\n  Min rs \\<in> rs\n\ngoal (1 subgoal):\n 1. x < Min rs \\<and> Min rs < b", "unfolding rs_def"], ["proof (prove)\nusing this:\n  Min {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}\n  \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. x < Min {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b} \\<and>\n    Min {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b} < b", "by auto"], ["proof (state)\nthis:\n  x < Min rs \\<and> Min rs < b\n\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "then"], ["proof (chain)\npicking this:\n  x < Min rs \\<and> Min rs < b", "show ?thesis"], ["proof (prove)\nusing this:\n  x < Min rs \\<and> Min rs < b\n\ngoal (1 subgoal):\n 1. x < r \\<and> a < r \\<and> r < b", "unfolding r_def"], ["proof (prove)\nusing this:\n  x < Min rs \\<and> Min rs < b\n\ngoal (1 subgoal):\n 1. x < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) \\<and>\n    a < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) \\<and>\n    (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) < b", "using that x"], ["proof (prove)\nusing this:\n  x < Min rs \\<and> Min rs < b\n  rs \\<noteq> {}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. x < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) \\<and>\n    a < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) \\<and>\n    (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) < b", "by auto"], ["proof (state)\nthis:\n  x < r \\<and> a < r \\<and> r < b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs \\<noteq> {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b\n\ngoal (3 subgoals):\n 1. x < r\n 2. a < r\n 3. r < b", "ultimately"], ["proof (chain)\npicking this:\n  rs = {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b\n  rs \\<noteq> {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b", "show \"r>x\" \"a<r\" \"r<b\""], ["proof (prove)\nusing this:\n  rs = {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b\n  rs \\<noteq> {} \\<Longrightarrow> x < r \\<and> a < r \\<and> r < b\n\ngoal (1 subgoal):\n 1. x < r &&& a < r &&& r < b", "by auto"], ["proof (state)\nthis:\n  x < r\n  a < r\n  r < b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < r\n  a < r\n  r < b\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "have noroot:\"f t\\<noteq>0\" when t:\"t\\<in>{x<..r}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. f t \\<noteq> 0", "proof (cases \"rs = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = {} \\<Longrightarrow> f t \\<noteq> 0\n 2. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "case True"], ["proof (state)\nthis:\n  rs = {}\n\ngoal (2 subgoals):\n 1. rs = {} \\<Longrightarrow> f t \\<noteq> 0\n 2. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "have False when \"f t=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"t<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < b", "using t \\<open>r<b\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {x<..r}\n  r < b\n\ngoal (1 subgoal):\n 1. t < b", "using greaterThanAtMost_iff"], ["proof (prove)\nusing this:\n  t \\<in> {x<..r}\n  r < b\n  (?i \\<in> {?l<..?u}) = (?l < ?i \\<and> ?i \\<le> ?u)\n\ngoal (1 subgoal):\n 1. t < b", "by fastforce"], ["proof (state)\nthis:\n  t < b\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t < b", "have \"t\\<in>rs\""], ["proof (prove)\nusing this:\n  t < b\n\ngoal (1 subgoal):\n 1. t \\<in> rs", "using that t"], ["proof (prove)\nusing this:\n  t < b\n  f t = 0\n  t \\<in> {x<..r}\n\ngoal (1 subgoal):\n 1. t \\<in> rs", "unfolding rs_def"], ["proof (prove)\nusing this:\n  t < b\n  f t = 0\n  t \\<in> {x<..r}\n\ngoal (1 subgoal):\n 1. t \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  t \\<in> rs\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t \\<in> rs", "show False"], ["proof (prove)\nusing this:\n  t \\<in> rs\n\ngoal (1 subgoal):\n 1. False", "using True"], ["proof (prove)\nusing this:\n  t \\<in> rs\n  rs = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. rs = {} \\<Longrightarrow> f t \\<noteq> 0\n 2. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  f t = 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  rs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "have \"t<Min rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < Min rs", "using that False \\<open>r>x\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {x<..r}\n  rs \\<noteq> {}\n  x < r\n\ngoal (1 subgoal):\n 1. t < Min rs", "unfolding r_def"], ["proof (prove)\nusing this:\n  t \\<in> {x<..if rs = {} then (x + b) / 2 else (Min rs + x) / 2}\n  rs \\<noteq> {}\n  x < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2)\n\ngoal (1 subgoal):\n 1. t < Min rs", "by auto"], ["proof (state)\nthis:\n  t < Min rs\n\ngoal (1 subgoal):\n 1. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "have False when \"f t=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"t<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < b", "using t \\<open>r<b\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {x<..r}\n  r < b\n\ngoal (1 subgoal):\n 1. t < b", "by (metis greaterThanAtMost_iff le_less less_trans)"], ["proof (state)\nthis:\n  t < b\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t < b", "have \"t\\<in>rs\""], ["proof (prove)\nusing this:\n  t < b\n\ngoal (1 subgoal):\n 1. t \\<in> rs", "using that t"], ["proof (prove)\nusing this:\n  t < b\n  f t = 0\n  t \\<in> {x<..r}\n\ngoal (1 subgoal):\n 1. t \\<in> rs", "unfolding rs_def"], ["proof (prove)\nusing this:\n  t < b\n  f t = 0\n  t \\<in> {x<..r}\n\ngoal (1 subgoal):\n 1. t \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  t \\<in> rs\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t \\<in> rs", "have \"t\\<ge>Min rs\""], ["proof (prove)\nusing this:\n  t \\<in> rs\n\ngoal (1 subgoal):\n 1. Min rs \\<le> t", "using \\<open>finite rs\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> rs\n  finite rs\n\ngoal (1 subgoal):\n 1. Min rs \\<le> t", "by auto"], ["proof (state)\nthis:\n  Min rs \\<le> t\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Min rs \\<le> t", "show False"], ["proof (prove)\nusing this:\n  Min rs \\<le> t\n\ngoal (1 subgoal):\n 1. False", "using \\<open>t<Min rs\\<close>"], ["proof (prove)\nusing this:\n  Min rs \\<le> t\n  t < Min rs\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. rs \\<noteq> {} \\<Longrightarrow> f t \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  f t = 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. f t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f t \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> {x<..r} \\<Longrightarrow> f ?t \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "have \"(f has_sgnx sgn (f r)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f r)) (at_right x)", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. sgn (f x) = sgn (f r)", "proof (rule eventually_at_rightI[OF _ \\<open>r>x\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "assume t:\"t\\<in>{x<..<r}\""], ["proof (state)\nthis:\n  t \\<in> {x<..<r}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "then"], ["proof (chain)\npicking this:\n  t \\<in> {x<..<r}", "have [simp]:\"t>a\" \"t<b\""], ["proof (prove)\nusing this:\n  t \\<in> {x<..<r}\n\ngoal (1 subgoal):\n 1. a < t &&& t < b", "using \\<open>r<b\\<close> x"], ["proof (prove)\nusing this:\n  t \\<in> {x<..<r}\n  r < b\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. a < t &&& t < b", "by (meson greaterThanLessThan_iff less_trans)+"], ["proof (state)\nthis:\n  a < t\n  t < b\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "have False when \"f t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using noroot t that"], ["proof (prove)\nusing this:\n  ?t \\<in> {x<..r} \\<Longrightarrow> f ?t \\<noteq> 0\n  t \\<in> {x<..<r}\n  f t = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "moreover"], ["proof (state)\nthis:\n  f t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "have False when \"f r=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using noroot t that"], ["proof (prove)\nusing this:\n  ?t \\<in> {x<..r} \\<Longrightarrow> f ?t \\<noteq> 0\n  t \\<in> {x<..<r}\n  f r = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  f r = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "moreover"], ["proof (state)\nthis:\n  f r = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "have False when \"f r>0 \\<and> f t<0 \\<or> f r <0 \\<and> f t >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have False when \"{t..r} \\<inter> s \\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain t' where t':\"t'\\<in>{t..r}\" \"t'\\<in>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> {t..r}; t' \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>{t..r} \\<inter> s \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  {t..r} \\<inter> s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> {t..r}; t' \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> {t..r}\n  t' \\<in> s\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {t..r}\n  t' \\<in> s", "have \"x<t' \\<and> t'<b\""], ["proof (prove)\nusing this:\n  t' \\<in> {t..r}\n  t' \\<in> s\n\ngoal (1 subgoal):\n 1. x < t' \\<and> t' < b", "by (meson \\<open>r < b\\<close> atLeastAtMost_iff greaterThanLessThan_iff less_le_trans not_le t)"], ["proof (state)\nthis:\n  x < t' \\<and> t' < b\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  x < t' \\<and> t' < b", "have \"t'\\<in>rs\""], ["proof (prove)\nusing this:\n  x < t' \\<and> t' < b\n\ngoal (1 subgoal):\n 1. t' \\<in> rs", "unfolding rs_def"], ["proof (prove)\nusing this:\n  x < t' \\<and> t' < b\n\ngoal (1 subgoal):\n 1. t' \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}", "using t \\<open>t'\\<in>s\\<close>"], ["proof (prove)\nusing this:\n  x < t' \\<and> t' < b\n  t \\<in> {x<..<r}\n  t' \\<in> s\n\ngoal (1 subgoal):\n 1. t' \\<in> {t. (f t = 0 \\<or> t \\<in> s) \\<and> x < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> rs\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> rs", "have \"t'\\<ge>Min rs\""], ["proof (prove)\nusing this:\n  t' \\<in> rs\n\ngoal (1 subgoal):\n 1. Min rs \\<le> t'", "using \\<open>finite rs\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> rs\n  finite rs\n\ngoal (1 subgoal):\n 1. Min rs \\<le> t'", "by auto"], ["proof (state)\nthis:\n  Min rs \\<le> t'\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  Min rs \\<le> t'\n\ngoal (1 subgoal):\n 1. False", "have \"Min rs>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < Min rs", "using \\<open>r>x\\<close> \\<open>t'\\<in>rs\\<close> \\<open>finite rs\\<close>"], ["proof (prove)\nusing this:\n  x < r\n  t' \\<in> rs\n  finite rs\n\ngoal (1 subgoal):\n 1. r < Min rs", "unfolding r_def"], ["proof (prove)\nusing this:\n  x < (if rs = {} then (x + b) / 2 else (Min rs + x) / 2)\n  t' \\<in> rs\n  finite rs\n\ngoal (1 subgoal):\n 1. (if rs = {} then (x + b) / 2 else (Min rs + x) / 2) < Min rs", "by (auto simp add:rs_def )"], ["proof (state)\nthis:\n  r < Min rs\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  Min rs \\<le> t'\n  r < Min rs", "show False"], ["proof (prove)\nusing this:\n  Min rs \\<le> t'\n  r < Min rs\n\ngoal (1 subgoal):\n 1. False", "using t'(1)"], ["proof (prove)\nusing this:\n  Min rs \\<le> t'\n  r < Min rs\n  t' \\<in> {t..r}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t..r} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  {t..r} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "have \"{t..r} \\<subseteq> {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t..r} \\<subseteq> {a<..<b}", "by (intro atMostAtLeast_subset_convex,auto)"], ["proof (state)\nthis:\n  {t..r} \\<subseteq> {a<..<b}\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  {t..r} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n  {t..r} \\<subseteq> {a<..<b}", "have \"continuous_on {t..r} f\""], ["proof (prove)\nusing this:\n  {t..r} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n  {t..r} \\<subseteq> {a<..<b}\n\ngoal (1 subgoal):\n 1. continuous_on {t..r} f", "using assms(2)"], ["proof (prove)\nusing this:\n  {t..r} \\<inter> s \\<noteq> {} \\<Longrightarrow> False\n  {t..r} \\<subseteq> {a<..<b}\n  continuous_on ({a<..<b} - s) f\n\ngoal (1 subgoal):\n 1. continuous_on {t..r} f", "by (elim continuous_on_subset,auto)"], ["proof (state)\nthis:\n  continuous_on {t..r} f\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {t..r} f", "have \"\\<exists>x>t. x < r \\<and> f x = 0\""], ["proof (prove)\nusing this:\n  continuous_on {t..r} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>t. x < r \\<and> f x = 0", "apply (intro IVT_strict)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {t..r} f \\<Longrightarrow>\n    0 < f t \\<and> f r < 0 \\<or> f t < 0 \\<and> 0 < f r\n 2. continuous_on {t..r} f \\<Longrightarrow> t < r\n 3. continuous_on {t..r} f \\<Longrightarrow> continuous_on {t..r} f", "using that t assms(2)"], ["proof (prove)\nusing this:\n  0 < f r \\<and> f t < 0 \\<or> f r < 0 \\<and> 0 < f t\n  t \\<in> {x<..<r}\n  continuous_on ({a<..<b} - s) f\n\ngoal (3 subgoals):\n 1. continuous_on {t..r} f \\<Longrightarrow>\n    0 < f t \\<and> f r < 0 \\<or> f t < 0 \\<and> 0 < f r\n 2. continuous_on {t..r} f \\<Longrightarrow> t < r\n 3. continuous_on {t..r} f \\<Longrightarrow> continuous_on {t..r} f", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>t. x < r \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>t. x < r \\<and> f x = 0", "obtain t' where \"t<t'\" \"t'<r\" \"f t'=0\""], ["proof (prove)\nusing this:\n  \\<exists>x>t. x < r \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t < t'; t' < r; f t' = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t < t'\n  t' < r\n  f t' = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t < t'\n  t' < r\n  f t' = 0", "have \"t'\\<in>{x<..r}\""], ["proof (prove)\nusing this:\n  t < t'\n  t' < r\n  f t' = 0\n\ngoal (1 subgoal):\n 1. t' \\<in> {x<..r}", "unfolding rs_def"], ["proof (prove)\nusing this:\n  t < t'\n  t' < r\n  f t' = 0\n\ngoal (1 subgoal):\n 1. t' \\<in> {x<..r}", "using t"], ["proof (prove)\nusing this:\n  t < t'\n  t' < r\n  f t' = 0\n  t \\<in> {x<..<r}\n\ngoal (1 subgoal):\n 1. t' \\<in> {x<..r}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> {x<..r}\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {x<..r}", "show False"], ["proof (prove)\nusing this:\n  t' \\<in> {x<..r}\n\ngoal (1 subgoal):\n 1. False", "using noroot \\<open>f t'=0\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> {x<..r}\n  ?t \\<in> {x<..r} \\<Longrightarrow> f ?t \\<noteq> 0\n  f t' = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < f r \\<and> f t < 0 \\<or> f r < 0 \\<and> 0 < f t \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x<..<r} \\<Longrightarrow> sgn (f xa) = sgn (f r)", "ultimately"], ["proof (chain)\npicking this:\n  f t = 0 \\<Longrightarrow> False\n  f r = 0 \\<Longrightarrow> False\n  0 < f r \\<and> f t < 0 \\<or> f r < 0 \\<and> 0 < f t \\<Longrightarrow>\n  False", "show \"sgn (f t) = sgn (f r)\""], ["proof (prove)\nusing this:\n  f t = 0 \\<Longrightarrow> False\n  f r = 0 \\<Longrightarrow> False\n  0 < f r \\<and> f t < 0 \\<or> f r < 0 \\<and> 0 < f t \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. sgn (f t) = sgn (f r)", "by (metis le_less not_less sgn_if)"], ["proof (state)\nthis:\n  sgn (f t) = sgn (f r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx sgn (f r)) (at_right x)\n\ngoal (2 subgoals):\n 1. f sgnx_able at_right x\n 2. sgnx f (at_right x) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx sgn (f r)) (at_right x)", "show \"f sgnx_able (at_right x)\""], ["proof (prove)\nusing this:\n  (f has_sgnx sgn (f r)) (at_right x)\n\ngoal (1 subgoal):\n 1. f sgnx_able at_right x", "by auto"], ["proof (state)\nthis:\n  f sgnx_able at_right x\n\ngoal (1 subgoal):\n 1. sgnx f (at_right x) \\<noteq> 0", "show \"sgnx f (at_right x)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f (at_right x) \\<noteq> 0", "using noroot[of r,simplified] \\<open>(f has_sgnx sgn (f r)) (at_right x)\\<close>"], ["proof (prove)\nusing this:\n  f r \\<noteq> 0\n  (f has_sgnx sgn (f r)) (at_right x)\n\ngoal (1 subgoal):\n 1. sgnx f (at_right x) \\<noteq> 0", "by (simp add: has_sgnx_imp_sgnx sgn_if)"], ["proof (state)\nthis:\n  sgnx f (at_right x) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_able_poly[simp]:\n  \"(poly p) sgnx_able (at_right a)\"\n  \"(poly p) sgnx_able (at_left a)\"\n  \"(poly p) sgnx_able at_top\"\n  \"(poly p) sgnx_able at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p sgnx_able at_right a &&& poly p sgnx_able at_left a) &&&\n    poly p sgnx_able at_top &&& poly p sgnx_able at_bot", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. poly p sgnx_able at_right a\n 2. poly p sgnx_able at_left a\n 3. poly p sgnx_able at_top\n 4. poly p sgnx_able at_bot", "show \"(poly p) sgnx_able at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p sgnx_able at_top", "using has_sgnx_def poly_sgn_eventually_at_top sgnx_able_def"], ["proof (prove)\nusing this:\n  (?f has_sgnx ?c) ?F = (\\<forall>\\<^sub>F x in ?F. sgn (?f x) = ?c)\n  \\<forall>\\<^sub>F x in at_top. sgn (poly ?p x) = sgn_pos_inf ?p\n  ?f sgnx_able ?F = (\\<exists>c. (?f has_sgnx c) ?F)\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_top", "by blast"], ["proof (state)\nthis:\n  poly p sgnx_able at_top\n\ngoal (3 subgoals):\n 1. poly p sgnx_able at_right a\n 2. poly p sgnx_able at_left a\n 3. poly p sgnx_able at_bot", "show \"(poly p) sgnx_able at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p sgnx_able at_bot", "using has_sgnx_def poly_sgn_eventually_at_bot sgnx_able_def"], ["proof (prove)\nusing this:\n  (?f has_sgnx ?c) ?F = (\\<forall>\\<^sub>F x in ?F. sgn (?f x) = ?c)\n  \\<forall>\\<^sub>F x in at_bot. sgn (poly ?p x) = sgn_neg_inf ?p\n  ?f sgnx_able ?F = (\\<exists>c. (?f has_sgnx c) ?F)\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_bot", "by blast"], ["proof (state)\nthis:\n  poly p sgnx_able at_bot\n\ngoal (2 subgoals):\n 1. poly p sgnx_able at_right a\n 2. poly p sgnx_able at_left a", "show \"(poly p) sgnx_able (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p sgnx_able at_right a", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly p sgnx_able at_right a\n 2. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly p sgnx_able at_right a\n 2. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_right a", "unfolding sgnx_able_def has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>c b.\n       a < b \\<and>\n       (\\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = c)", "using linordered_field_no_ub"], ["proof (prove)\nusing this:\n  p = 0\n  \\<forall>x. \\<exists>y. x < y\n\ngoal (1 subgoal):\n 1. \\<exists>c b.\n       a < b \\<and>\n       (\\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = c)", "by force"], ["proof (state)\nthis:\n  poly p sgnx_able at_right a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "obtain ub where \"ub>a\" and ub:\"\\<forall>z. a<z\\<and>z\\<le>ub\\<longrightarrow>poly p z\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>a < ub;\n         \\<forall>z.\n            a < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly p z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF False]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>?lb < ub;\n       \\<forall>z.\n          ?lb < z \\<and> z \\<le> ub \\<longrightarrow>\n          poly p z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>a < ub;\n         \\<forall>z.\n            a < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly p z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < ub\n  \\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "have \"\\<forall>z. a<z\\<and>z\\<le>ub\\<longrightarrow>sgn(poly p z) = sgn (poly p ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       a < z \\<and> z \\<le> ub \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p ub)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> sgn (poly p z) = sgn (poly p ub))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>z.\n             a < z \\<and> z \\<le> ub \\<longrightarrow>\n             sgn (poly p z) = sgn (poly p ub))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>z.\n             a < z \\<and> z \\<le> ub \\<longrightarrow>\n             sgn (poly p z) = sgn (poly p ub))", "obtain z where \"a<z\" \"z\\<le>ub\" \"sgn(poly p z) \\<noteq> sgn (poly p ub)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>z.\n             a < z \\<and> z \\<le> ub \\<longrightarrow>\n             sgn (poly p z) = sgn (poly p ub))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>a < z; z \\<le> ub;\n         sgn (poly p z) \\<noteq> sgn (poly p ub)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)", "have \"poly p z\\<noteq>0\" \"poly p ub\\<noteq>0\" \"z\\<noteq>ub\""], ["proof (prove)\nusing this:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)\n\ngoal (1 subgoal):\n 1. poly p z \\<noteq> 0 &&& poly p ub \\<noteq> 0 &&& z \\<noteq> ub", "using ub \\<open>ub>a\\<close>"], ["proof (prove)\nusing this:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)\n  \\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n  a < ub\n\ngoal (1 subgoal):\n 1. poly p z \\<noteq> 0 &&& poly p ub \\<noteq> 0 &&& z \\<noteq> ub", "by blast+"], ["proof (state)\nthis:\n  poly p z \\<noteq> 0\n  poly p ub \\<noteq> 0\n  z \\<noteq> ub\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)\n  poly p z \\<noteq> 0\n  poly p ub \\<noteq> 0\n  z \\<noteq> ub", "have \"(poly p z>0 \\<and> poly p ub<0) \\<or> (poly p z<0 \\<and> poly p ub>0)\""], ["proof (prove)\nusing this:\n  a < z\n  z \\<le> ub\n  sgn (poly p z) \\<noteq> sgn (poly p ub)\n  poly p z \\<noteq> 0\n  poly p ub \\<noteq> 0\n  z \\<noteq> ub\n\ngoal (1 subgoal):\n 1. 0 < poly p z \\<and> poly p ub < 0 \\<or>\n    poly p z < 0 \\<and> 0 < poly p ub", "by (metis linorder_neqE_linordered_idom sgn_neg sgn_pos)"], ["proof (state)\nthis:\n  0 < poly p z \\<and> poly p ub < 0 \\<or> poly p z < 0 \\<and> 0 < poly p ub\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  0 < poly p z \\<and> poly p ub < 0 \\<or> poly p z < 0 \\<and> 0 < poly p ub", "have \"\\<exists>x>z. x < ub \\<and> poly p x = 0\""], ["proof (prove)\nusing this:\n  0 < poly p z \\<and> poly p ub < 0 \\<or> poly p z < 0 \\<and> 0 < poly p ub\n\ngoal (1 subgoal):\n 1. \\<exists>x>z. x < ub \\<and> poly p x = 0", "using poly_IVT_neg[of z ub p] poly_IVT_pos[of z ub p] \\<open>z\\<le>ub\\<close> \\<open>z\\<noteq>ub\\<close>"], ["proof (prove)\nusing this:\n  0 < poly p z \\<and> poly p ub < 0 \\<or> poly p z < 0 \\<and> 0 < poly p ub\n  \\<lbrakk>z < ub; 0 < poly p z; poly p ub < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>z. x < ub \\<and> poly p x = 0\n  \\<lbrakk>z < ub; poly p z < 0; 0 < poly p ub\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>z. x < ub \\<and> poly p x = 0\n  z \\<le> ub\n  z \\<noteq> ub\n\ngoal (1 subgoal):\n 1. \\<exists>x>z. x < ub \\<and> poly p x = 0", "by argo"], ["proof (state)\nthis:\n  \\<exists>x>z. x < ub \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               a < z \\<and> z \\<le> ub \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p ub)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>z. x < ub \\<and> poly p x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>z. x < ub \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "using ub \\<open>a < z\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>z. x < ub \\<and> poly p x = 0\n  \\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n  a < z\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     a < z \\<and> z \\<le> ub \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p ub)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_right a", "then"], ["proof (chain)\npicking this:\n  \\<forall>z.\n     a < z \\<and> z \\<le> ub \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p ub)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     a < z \\<and> z \\<le> ub \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p ub)\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_right a", "unfolding sgnx_able_def has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     a < z \\<and> z \\<le> ub \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p ub)\n\ngoal (1 subgoal):\n 1. \\<exists>c b.\n       a < b \\<and>\n       (\\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = c)", "apply (rule_tac exI[where x=\"sgn(poly p ub)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       a < z \\<and> z \\<le> ub \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p ub) \\<Longrightarrow>\n    \\<exists>b>a.\n       \\<forall>y>a.\n          y < b \\<longrightarrow> sgn (poly p y) = sgn (poly p ub)", "apply (rule_tac exI[where x=\"ub\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       a < z \\<and> z \\<le> ub \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p ub) \\<Longrightarrow>\n    a < ub \\<and>\n    (\\<forall>y>a.\n        y < ub \\<longrightarrow> sgn (poly p y) = sgn (poly p ub))", "using less_eq_real_def \\<open>ub>a\\<close>"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  a < ub\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       a < z \\<and> z \\<le> ub \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p ub) \\<Longrightarrow>\n    a < ub \\<and>\n    (\\<forall>y>a.\n        y < ub \\<longrightarrow> sgn (poly p y) = sgn (poly p ub))", "by blast"], ["proof (state)\nthis:\n  poly p sgnx_able at_right a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p sgnx_able at_right a\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_left a", "show \"(poly p) sgnx_able (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p sgnx_able at_left a", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly p sgnx_able at_left a\n 2. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly p sgnx_able at_left a\n 2. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_left a", "unfolding sgnx_able_def has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>c. \\<forall>\\<^sub>F x in at_left a. sgn (poly p x) = c", "using linordered_field_no_ub"], ["proof (prove)\nusing this:\n  p = 0\n  \\<forall>x. \\<exists>y. x < y\n\ngoal (1 subgoal):\n 1. \\<exists>c. \\<forall>\\<^sub>F x in at_left a. sgn (poly p x) = c", "by force"], ["proof (state)\nthis:\n  poly p sgnx_able at_left a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "obtain lb where \"lb<a\" and ub:\"\\<forall>z. lb\\<le>z\\<and>z<a\\<longrightarrow>poly p z\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < a;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < a \\<longrightarrow>\n            poly p z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using last_non_root_interval[OF False]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>lb < ?ub;\n       \\<forall>z.\n          lb \\<le> z \\<and> z < ?ub \\<longrightarrow>\n          poly p z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < a;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < a \\<longrightarrow>\n            poly p z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lb < a\n  \\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "have \"\\<forall>z. lb\\<le>z\\<and>z<a\\<longrightarrow>sgn(poly p z) = sgn (poly p lb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb \\<le> z \\<and> z < a \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p lb)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>z. lb\\<le>z\\<and>z<a \\<longrightarrow> sgn (poly p z) = sgn (poly p lb))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>z.\n             lb \\<le> z \\<and> z < a \\<longrightarrow>\n             sgn (poly p z) = sgn (poly p lb))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>z.\n             lb \\<le> z \\<and> z < a \\<longrightarrow>\n             sgn (poly p z) = sgn (poly p lb))", "obtain z where \"lb\\<le>z\" \"z<a\" \"sgn(poly p z) \\<noteq> sgn (poly p lb)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>z.\n             lb \\<le> z \\<and> z < a \\<longrightarrow>\n             sgn (poly p z) = sgn (poly p lb))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>lb \\<le> z; z < a;\n         sgn (poly p z) \\<noteq> sgn (poly p lb)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)", "have \"poly p z\\<noteq>0\" \"poly p lb\\<noteq>0\" \"z\\<noteq>lb\""], ["proof (prove)\nusing this:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)\n\ngoal (1 subgoal):\n 1. poly p z \\<noteq> 0 &&& poly p lb \\<noteq> 0 &&& z \\<noteq> lb", "using ub \\<open>lb<a\\<close>"], ["proof (prove)\nusing this:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)\n  \\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p z \\<noteq> 0\n  lb < a\n\ngoal (1 subgoal):\n 1. poly p z \\<noteq> 0 &&& poly p lb \\<noteq> 0 &&& z \\<noteq> lb", "by blast+"], ["proof (state)\nthis:\n  poly p z \\<noteq> 0\n  poly p lb \\<noteq> 0\n  z \\<noteq> lb\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)\n  poly p z \\<noteq> 0\n  poly p lb \\<noteq> 0\n  z \\<noteq> lb", "have \"(poly p z>0 \\<and> poly p lb<0) \\<or> (poly p z<0 \\<and> poly p lb>0)\""], ["proof (prove)\nusing this:\n  lb \\<le> z\n  z < a\n  sgn (poly p z) \\<noteq> sgn (poly p lb)\n  poly p z \\<noteq> 0\n  poly p lb \\<noteq> 0\n  z \\<noteq> lb\n\ngoal (1 subgoal):\n 1. 0 < poly p z \\<and> poly p lb < 0 \\<or>\n    poly p z < 0 \\<and> 0 < poly p lb", "by (metis linorder_neqE_linordered_idom sgn_neg sgn_pos)"], ["proof (state)\nthis:\n  0 < poly p z \\<and> poly p lb < 0 \\<or> poly p z < 0 \\<and> 0 < poly p lb\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  0 < poly p z \\<and> poly p lb < 0 \\<or> poly p z < 0 \\<and> 0 < poly p lb", "have \"\\<exists>x>lb. x < z \\<and> poly p x = 0\""], ["proof (prove)\nusing this:\n  0 < poly p z \\<and> poly p lb < 0 \\<or> poly p z < 0 \\<and> 0 < poly p lb\n\ngoal (1 subgoal):\n 1. \\<exists>x>lb. x < z \\<and> poly p x = 0", "using poly_IVT_neg[of lb z p] poly_IVT_pos[of lb z p] \\<open>lb\\<le>z\\<close> \\<open>z\\<noteq>lb\\<close>"], ["proof (prove)\nusing this:\n  0 < poly p z \\<and> poly p lb < 0 \\<or> poly p z < 0 \\<and> 0 < poly p lb\n  \\<lbrakk>lb < z; 0 < poly p lb; poly p z < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>lb. x < z \\<and> poly p x = 0\n  \\<lbrakk>lb < z; poly p lb < 0; 0 < poly p z\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>lb. x < z \\<and> poly p x = 0\n  lb \\<le> z\n  z \\<noteq> lb\n\ngoal (1 subgoal):\n 1. \\<exists>x>lb. x < z \\<and> poly p x = 0", "by argo"], ["proof (state)\nthis:\n  \\<exists>x>lb. x < z \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>z.\n               lb \\<le> z \\<and> z < a \\<longrightarrow>\n               sgn (poly p z) = sgn (poly p lb)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>lb. x < z \\<and> poly p x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>lb. x < z \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "using ub \\<open>z < a\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>lb. x < z \\<and> poly p x = 0\n  \\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p z \\<noteq> 0\n  z < a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     lb \\<le> z \\<and> z < a \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p lb)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> poly p sgnx_able at_left a", "then"], ["proof (chain)\npicking this:\n  \\<forall>z.\n     lb \\<le> z \\<and> z < a \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p lb)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     lb \\<le> z \\<and> z < a \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p lb)\n\ngoal (1 subgoal):\n 1. poly p sgnx_able at_left a", "unfolding sgnx_able_def has_sgnx_def eventually_at_left"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     lb \\<le> z \\<and> z < a \\<longrightarrow>\n     sgn (poly p z) = sgn (poly p lb)\n\ngoal (1 subgoal):\n 1. \\<exists>c b.\n       b < a \\<and>\n       (\\<forall>y>b. y < a \\<longrightarrow> sgn (poly p y) = c)", "apply (rule_tac exI[where x=\"sgn(poly p lb)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb \\<le> z \\<and> z < a \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p lb) \\<Longrightarrow>\n    \\<exists>b<a.\n       \\<forall>y>b.\n          y < a \\<longrightarrow> sgn (poly p y) = sgn (poly p lb)", "apply (rule_tac exI[where x=\"lb\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb \\<le> z \\<and> z < a \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p lb) \\<Longrightarrow>\n    lb < a \\<and>\n    (\\<forall>y>lb.\n        y < a \\<longrightarrow> sgn (poly p y) = sgn (poly p lb))", "using less_eq_real_def \\<open>lb<a\\<close>"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  lb < a\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb \\<le> z \\<and> z < a \\<longrightarrow>\n       sgn (poly p z) = sgn (poly p lb) \\<Longrightarrow>\n    lb < a \\<and>\n    (\\<forall>y>lb.\n        y < a \\<longrightarrow> sgn (poly p y) = sgn (poly p lb))", "by blast"], ["proof (state)\nthis:\n  poly p sgnx_able at_left a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p sgnx_able at_left a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_identity[intro,sgnx_intros]:\n  shows \"x\\<ge>0 \\<Longrightarrow>((\\<lambda>x. x) has_sgnx 1) (at_right x)\" \n        \"x\\<le>0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx -1) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x \\<Longrightarrow>\n     ((\\<lambda>x. x) has_sgnx 1) (at_right x)) &&&\n    (x \\<le> 0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx - 1) (at_left x))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx 1) (at_right x)\n 2. x \\<le> 0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx - 1) (at_left x)", "show \"x\\<ge>0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx 1) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx 1) (at_right x)", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> sgn y = 1", "apply (intro exI[where x=\"x+1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    x < x + 1 \\<and> (\\<forall>y>x. y < x + 1 \\<longrightarrow> sgn y = 1)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx 1) (at_right x)\n\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx - 1) (at_left x)", "show \"x\\<le>0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx -1) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx - 1) (at_left x)", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<Longrightarrow>\n    \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> sgn y = - 1", "apply (intro exI[where x=\"x-1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<Longrightarrow>\n    x - 1 < x \\<and> (\\<forall>y>x - 1. y < x \\<longrightarrow> sgn y = - 1)", "by auto"], ["proof (state)\nthis:\n  x \\<le> 0 \\<Longrightarrow> ((\\<lambda>x. x) has_sgnx - 1) (at_left x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_divide[sgnx_intros]:\n  assumes \"(f has_sgnx c1) F\" \"(g has_sgnx c2) F\"\n  shows \"((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "have \"\\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "using assms"], ["proof (prove)\nusing this:\n  (f has_sgnx c1) F\n  (g has_sgnx c2) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1\n  \\<forall>\\<^sub>F x in F. sgn (g x) = c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "by (intro eventually_conj,auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "have \"\\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (f x) = c1 \\<and> sgn (g x) = c2 \\<Longrightarrow>\n       sgn (f x / g x) = c1 / c2", "by (simp add: sgn_mult sgn_divide)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2", "show \"((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x / g x) = c1 / c2", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_able_divide[sgnx_intros]:\n  assumes \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"(\\<lambda>x. f x / g x) sgnx_able F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x / g x) sgnx_able F", "using has_sgnx_divide"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?f has_sgnx ?c1.0) ?F; (?g has_sgnx ?c2.0) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?f x / ?g x) has_sgnx ?c1.0 / ?c2.0) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x / g x) sgnx_able F", "by (meson assms(1) assms(2) sgnx_able_def)"], ["", "lemma sgnx_divide:\n  assumes \"F\\<noteq>bot\" \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"sgnx (\\<lambda>x. f x / g x) F =sgnx f F / sgnx g F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "obtain c1 c2 where c1:\"(f has_sgnx c1) F\" and c2:\"(g has_sgnx c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>(f has_sgnx c1) F; (g has_sgnx c2) F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  f sgnx_able F\n  g sgnx_able F\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>(f has_sgnx c1) F; (g has_sgnx c2) F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sgnx_able_def"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  \\<exists>c. (f has_sgnx c) F\n  \\<exists>c. (g has_sgnx c) F\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>(f has_sgnx c1) F; (g has_sgnx c2) F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx c1) F\n  (g has_sgnx c2) F\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "have \"sgnx f F=c1\" \"sgnx g F=c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f F = c1 &&& sgnx g F = c2", "using c1 c2 \\<open>F\\<noteq>bot\\<close>"], ["proof (prove)\nusing this:\n  (f has_sgnx c1) F\n  (g has_sgnx c2) F\n  F \\<noteq> bot\n\ngoal (1 subgoal):\n 1. sgnx f F = c1 &&& sgnx g F = c2", "by auto"], ["proof (state)\nthis:\n  sgnx f F = c1\n  sgnx g F = c2\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "moreover"], ["proof (state)\nthis:\n  sgnx f F = c1\n  sgnx g F = c2\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "have \"((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "using has_sgnx_divide[OF c1 c2]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "ultimately"], ["proof (chain)\npicking this:\n  sgnx f F = c1\n  sgnx g F = c2\n  ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F", "show ?thesis"], ["proof (prove)\nusing this:\n  sgnx f F = c1\n  sgnx g F = c2\n  ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "using assms(1) has_sgnx_imp_sgnx"], ["proof (prove)\nusing this:\n  sgnx f F = c1\n  sgnx g F = c2\n  ((\\<lambda>x. f x / g x) has_sgnx c1 / c2) F\n  F \\<noteq> bot\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F", "by blast"], ["proof (state)\nthis:\n  sgnx (\\<lambda>x. f x / g x) F = sgnx f F / sgnx g F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_times[sgnx_intros]:\n  assumes \"(f has_sgnx c1) F\" \"(g has_sgnx c2) F\"\n  shows \"((\\<lambda>x. f x* g x) has_sgnx c1 * c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "have \"\\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "using assms"], ["proof (prove)\nusing this:\n  (f has_sgnx c1) F\n  (g has_sgnx c2) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1\n  \\<forall>\\<^sub>F x in F. sgn (g x) = c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "by (intro eventually_conj,auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2", "have \"\\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c1 \\<and> sgn (g x) = c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (f x) = c1 \\<and> sgn (g x) = c2 \\<Longrightarrow>\n       sgn (f x * g x) = c1 * c2", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2", "show \"((\\<lambda>x. f x* g x) has_sgnx c1 * c2) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x * g x) = c1 * c2", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_able_times[sgnx_intros]:\n  assumes \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"(\\<lambda>x. f x * g x) sgnx_able F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x * g x) sgnx_able F", "using has_sgnx_times"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?f has_sgnx ?c1.0) ?F; (?g has_sgnx ?c2.0) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?f x * ?g x) has_sgnx ?c1.0 * ?c2.0) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x * g x) sgnx_able F", "by (meson assms(1) assms(2) sgnx_able_def)"], ["", "lemma sgnx_times:\n  assumes \"F\\<noteq>bot\" \"f sgnx_able F\" \"g sgnx_able F\"\n  shows \"sgnx (\\<lambda>x. f x * g x) F =sgnx f F * sgnx g F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "obtain c1 c2 where c1:\"(f has_sgnx c1) F\" and c2:\"(g has_sgnx c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>(f has_sgnx c1) F; (g has_sgnx c2) F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  f sgnx_able F\n  g sgnx_able F\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>(f has_sgnx c1) F; (g has_sgnx c2) F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sgnx_able_def"], ["proof (prove)\nusing this:\n  F \\<noteq> bot\n  \\<exists>c. (f has_sgnx c) F\n  \\<exists>c. (g has_sgnx c) F\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>(f has_sgnx c1) F; (g has_sgnx c2) F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx c1) F\n  (g has_sgnx c2) F\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "have \"sgnx f F=c1\" \"sgnx g F=c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f F = c1 &&& sgnx g F = c2", "using c1 c2 \\<open>F\\<noteq>bot\\<close>"], ["proof (prove)\nusing this:\n  (f has_sgnx c1) F\n  (g has_sgnx c2) F\n  F \\<noteq> bot\n\ngoal (1 subgoal):\n 1. sgnx f F = c1 &&& sgnx g F = c2", "by auto"], ["proof (state)\nthis:\n  sgnx f F = c1\n  sgnx g F = c2\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "moreover"], ["proof (state)\nthis:\n  sgnx f F = c1\n  sgnx g F = c2\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "have \"((\\<lambda>x. f x* g x) has_sgnx c1 * c2) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "using has_sgnx_times[OF c1 c2]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "ultimately"], ["proof (chain)\npicking this:\n  sgnx f F = c1\n  sgnx g F = c2\n  ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F", "show ?thesis"], ["proof (prove)\nusing this:\n  sgnx f F = c1\n  sgnx g F = c2\n  ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "using assms(1) has_sgnx_imp_sgnx"], ["proof (prove)\nusing this:\n  sgnx f F = c1\n  sgnx g F = c2\n  ((\\<lambda>x. f x * g x) has_sgnx c1 * c2) F\n  F \\<noteq> bot\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F", "by blast"], ["proof (state)\nthis:\n  sgnx (\\<lambda>x. f x * g x) F = sgnx f F * sgnx g F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_nonzero_has_sgnx:\n  assumes \"(f \\<longlongrightarrow> c) F\" \"c\\<noteq>0\"\n  shows \"(f has_sgnx sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx sgn c) F", "proof (cases rule:linorder_cases[of c 0])"], ["proof (state)\ngoal (3 subgoals):\n 1. c < 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 2. c = 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 3. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "case less"], ["proof (state)\nthis:\n  c < 0\n\ngoal (3 subgoals):\n 1. c < 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 2. c = 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 3. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  c < 0", "have \"\\<forall>\\<^sub>F x in F. f x<0\""], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x < 0", "using order_topology_class.order_tendstoD[OF assms(1),of 0]"], ["proof (prove)\nusing this:\n  c < 0\n  0 < c \\<Longrightarrow> \\<forall>\\<^sub>F x in F. 0 < f x\n  c < 0 \\<Longrightarrow> \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x < 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (3 subgoals):\n 1. c < 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 2. c = 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 3. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. f x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn c) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = sgn c", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. f x < 0 \\<Longrightarrow> sgn (f x) = sgn c", "using less"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. \\<And>x. f x < 0 \\<Longrightarrow> sgn (f x) = sgn c", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx sgn c) F\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 2. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 2. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "case equal"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> (f has_sgnx sgn c) F\n 2. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn c) F", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c = 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn c) F", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "case greater"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  0 < c", "have \"\\<forall>\\<^sub>F x in F. f x>0\""], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x", "using order_topology_class.order_tendstoD[OF assms(1),of 0]"], ["proof (prove)\nusing this:\n  0 < c\n  0 < c \\<Longrightarrow> \\<forall>\\<^sub>F x in F. 0 < f x\n  c < 0 \\<Longrightarrow> \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow> (f has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. 0 < f x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn c) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = sgn c", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < f x \\<Longrightarrow> sgn (f x) = sgn c", "using greater"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < f x \\<Longrightarrow> sgn (f x) = sgn c", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx sgn c) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_nonzero_sgnx:\n  assumes \"(f \\<longlongrightarrow> c) F\" \"F\\<noteq>bot\" \"c\\<noteq>0\"\n  shows \"sgnx f F = sgn c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f F = sgn c", "using tendsto_nonzero_has_sgnx"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?f \\<longlongrightarrow> ?c) ?F; ?c \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (?f has_sgnx sgn ?c) ?F\n\ngoal (1 subgoal):\n 1. sgnx f F = sgn c", "by (simp add: assms has_sgnx_imp_sgnx)"], ["", "lemma filterlim_divide_at_bot_at_top_iff:\n  assumes \"(f \\<longlongrightarrow> c) F\" \"c\\<noteq>0\" \n  shows \n    \"(LIM x F. f x / g x :> at_bot) \\<longleftrightarrow> (g \\<longlongrightarrow> 0) F \n      \\<and> ((\\<lambda>x. g x) has_sgnx - sgn c) F\"\n    \"(LIM x F. f x / g x :> at_top) \\<longleftrightarrow> (g \\<longlongrightarrow> 0) F \n      \\<and> ((\\<lambda>x. g x) has_sgnx sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIM x F. f x / g x :> at_bot) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F) &&&\n    (LIM x F. f x / g x :> at_top) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (LIM x F. f x / g x :> at_bot) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F)\n 2. (LIM x F. f x / g x :> at_top) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F)", "show \"(LIM x F. f x / g x :> at_bot) \\<longleftrightarrow> ((g \\<longlongrightarrow> 0) F )  \n    \\<and> ((\\<lambda>x. g x) has_sgnx - sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIM x F. f x / g x :> at_bot) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_bot \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "assume asm:\"LIM x F. f x / g x :> at_bot\""], ["proof (state)\nthis:\n  LIM x F. f x / g x :> at_bot\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_bot \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "then"], ["proof (chain)\npicking this:\n  LIM x F. f x / g x :> at_bot", "have \"filterlim g (at 0) F\""], ["proof (prove)\nusing this:\n  LIM x F. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. filterlim g (at 0) F", "using filterlim_at_infinity_divide_iff[OF assms(1,2),of g] \n      at_bot_le_at_infinity filterlim_mono"], ["proof (prove)\nusing this:\n  LIM x F. f x / g x :> at_bot\n  (LIM x F. f x / g x :> at_infinity) = filterlim g (at 0) F\n  at_bot \\<le> at_infinity\n  \\<lbrakk>filterlim ?f ?F2.0 ?F1.0; ?F2.0 \\<le> ?F2';\n   ?F1' \\<le> ?F1.0\\<rbrakk>\n  \\<Longrightarrow> filterlim ?f ?F2' ?F1'\n\ngoal (1 subgoal):\n 1. filterlim g (at 0) F", "by blast"], ["proof (state)\nthis:\n  filterlim g (at 0) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_bot \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "then"], ["proof (chain)\npicking this:\n  filterlim g (at 0) F", "have \"(g \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  filterlim g (at 0) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "using filterlim_at"], ["proof (prove)\nusing this:\n  filterlim g (at 0) F\n  filterlim ?f (at ?b within ?s) ?F =\n  ((\\<forall>\\<^sub>F x in ?F. ?f x \\<in> ?s \\<and> ?f x \\<noteq> ?b) \\<and>\n   (?f \\<longlongrightarrow> ?b) ?F)\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "by blast"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_bot \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_bot \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "have \"(g has_sgnx - sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "have \"((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow> sgn c * inverse c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n     sgn c * inverse c)\n     F", "using assms(1,2)"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> c) F\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n     sgn c * inverse c)\n     F", "by (auto intro:tendsto_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n   sgn c * inverse c)\n   F\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n   sgn c * inverse c)\n   F", "have \"LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_bot\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n   sgn c * inverse c)\n   F\n\ngoal (1 subgoal):\n 1. LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_bot", "apply (elim filterlim_tendsto_pos_mult_at_bot[OF _ _ asm])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sgn c * inverse c", "using \\<open>c\\<noteq>0\\<close> sgn_real_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  sgn ?a = (if ?a = 0 then 0 else if 0 < ?a then 1 else - 1)\n\ngoal (1 subgoal):\n 1. 0 < sgn c * inverse c", "by auto"], ["proof (state)\nthis:\n  LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_bot\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "then"], ["proof (chain)\npicking this:\n  LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_bot", "have \"LIM x F. sgn c / g x :> at_bot\""], ["proof (prove)\nusing this:\n  LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x F. sgn c / g x :> at_bot", "apply (elim filterlim_mono_eventually)"], ["proof (prove)\ngoal (3 subgoals):\n 1. at_bot \\<le> at_bot\n 2. F \\<le> F\n 3. \\<forall>\\<^sub>F x in F.\n       sgn c * inverse (f x) * (f x / g x) = sgn c / g x", "using eventually_times_inverse_1[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. inverse (f x) * f x = 1\n\ngoal (3 subgoals):\n 1. at_bot \\<le> at_bot\n 2. F \\<le> F\n 3. \\<forall>\\<^sub>F x in F.\n       sgn c * inverse (f x) * (f x / g x) = sgn c / g x", "by (auto elim:eventually_mono)"], ["proof (state)\nthis:\n  LIM x F. sgn c / g x :> at_bot\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "then"], ["proof (chain)\npicking this:\n  LIM x F. sgn c / g x :> at_bot", "have \"\\<forall>\\<^sub>F x in F. sgn c / g x < 0\""], ["proof (prove)\nusing this:\n  LIM x F. sgn c / g x :> at_bot\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn c / g x < 0", "using filterlim_at_bot_dense[of \"\\<lambda>x. sgn c/g x\" F]"], ["proof (prove)\nusing this:\n  LIM x F. sgn c / g x :> at_bot\n  (LIM x F. sgn c / g x :> at_bot) =\n  (\\<forall>Z. \\<forall>\\<^sub>F x in F. sgn c / g x < Z)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn c / g x < 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. sgn c / g x < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. sgn c / g x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn c / g x < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn c / g x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (g x) = - sgn c", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. sgn c / g x < 0 \\<Longrightarrow> sgn (g x) = - sgn c", "by (metis add.inverse_inverse divide_less_0_iff sgn_neg sgn_pos sgn_sgn)"], ["proof (state)\nthis:\n  (g has_sgnx - sgn c) F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx - sgn c) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_bot \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "ultimately"], ["proof (chain)\npicking this:\n  (g \\<longlongrightarrow> 0) F\n  (g has_sgnx - sgn c) F", "show \"(g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\""], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 0) F\n  (g has_sgnx - sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F", "by auto"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "assume \"(g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\""], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "then"], ["proof (chain)\npicking this:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F", "have asm:\"(g \\<longlongrightarrow> 0) F\" \"(g has_sgnx - sgn c) F\""], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F &&& (g has_sgnx - sgn c) F", "by auto"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F\n  (g has_sgnx - sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "have \"LIM x F. inverse (g x * sgn c) :> at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x F. inverse (g x * sgn c) :> at_bot", "proof (rule filterlim_inverse_at_bot)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F\n 2. \\<forall>\\<^sub>F x in F. g x * sgn c < 0", "show \"((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F", "apply (rule tendsto_mult_left_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "using asm(1)"], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. g x * sgn c < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. g x * sgn c < 0", "show \"\\<forall>\\<^sub>F x in F. g x * sgn c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. g x * sgn c < 0", "using asm(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn c) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. g x * sgn c < 0", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (g x) = - sgn c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. g x * sgn c < 0", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. sgn (g x) = - sgn c \\<Longrightarrow> g x * sgn c < 0", "by (metis add.inverse_inverse assms(2) linorder_neqE_linordered_idom mult_less_0_iff \n            neg_0_less_iff_less sgn_greater sgn_zero_iff)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. g x * sgn c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x F. inverse (g x * sgn c) :> at_bot\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  LIM x F. inverse (g x * sgn c) :> at_bot\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "have \"((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F", "using \\<open>(f \\<longlongrightarrow> c) F\\<close> \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> c) F\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> c) F; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (f \\<longlongrightarrow> c) F", "by (auto simp add:sgn_zero_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "have \"c * sgn c >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c * sgn c", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < c * sgn c", "by (simp add: sgn_real_def)"], ["proof (state)\nthis:\n  0 < c * sgn c\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "ultimately"], ["proof (chain)\npicking this:\n  LIM x F. inverse (g x * sgn c) :> at_bot\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n  0 < c * sgn c", "have \"LIM x F. (f x * sgn c) *inverse (g x * sgn c) :> at_bot\""], ["proof (prove)\nusing this:\n  LIM x F. inverse (g x * sgn c) :> at_bot\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n  0 < c * sgn c\n\ngoal (1 subgoal):\n 1. LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_bot", "using filterlim_tendsto_pos_mult_at_bot"], ["proof (prove)\nusing this:\n  LIM x F. inverse (g x * sgn c) :> at_bot\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n  0 < c * sgn c\n  \\<lbrakk>(?f \\<longlongrightarrow> ?c) ?F; 0 < ?c;\n   filterlim ?g at_bot ?F\\<rbrakk>\n  \\<Longrightarrow> LIM x ?F. ?f x * ?g x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_bot", "by blast"], ["proof (state)\nthis:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_bot\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx - sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_bot", "then"], ["proof (chain)\npicking this:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_bot", "show \"LIM x F. f x / g x :> at_bot\""], ["proof (prove)\nusing this:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x F. f x / g x :> at_bot", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_bot\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x F. f x / g x :> at_bot", "by (auto simp add:field_simps sgn_zero_iff)"], ["proof (state)\nthis:\n  LIM x F. f x / g x :> at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LIM x F. f x / g x :> at_bot) =\n  ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx - sgn c) F)\n\ngoal (1 subgoal):\n 1. (LIM x F. f x / g x :> at_top) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F)", "show \"(LIM x F. f x / g x :> at_top) \\<longleftrightarrow> ((g \\<longlongrightarrow> 0) F )  \n    \\<and> ((\\<lambda>x. g x) has_sgnx sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIM x F. f x / g x :> at_top) =\n    ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_top \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "assume asm:\"LIM x F. f x / g x :> at_top\""], ["proof (state)\nthis:\n  LIM x F. f x / g x :> at_top\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_top \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "then"], ["proof (chain)\npicking this:\n  LIM x F. f x / g x :> at_top", "have \"filterlim g (at 0) F\""], ["proof (prove)\nusing this:\n  LIM x F. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. filterlim g (at 0) F", "using filterlim_at_infinity_divide_iff[OF assms(1,2),of g] \n      at_top_le_at_infinity filterlim_mono"], ["proof (prove)\nusing this:\n  LIM x F. f x / g x :> at_top\n  (LIM x F. f x / g x :> at_infinity) = filterlim g (at 0) F\n  at_top \\<le> at_infinity\n  \\<lbrakk>filterlim ?f ?F2.0 ?F1.0; ?F2.0 \\<le> ?F2';\n   ?F1' \\<le> ?F1.0\\<rbrakk>\n  \\<Longrightarrow> filterlim ?f ?F2' ?F1'\n\ngoal (1 subgoal):\n 1. filterlim g (at 0) F", "by blast"], ["proof (state)\nthis:\n  filterlim g (at 0) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_top \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "then"], ["proof (chain)\npicking this:\n  filterlim g (at 0) F", "have \"(g \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  filterlim g (at 0) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "using filterlim_at"], ["proof (prove)\nusing this:\n  filterlim g (at 0) F\n  filterlim ?f (at ?b within ?s) ?F =\n  ((\\<forall>\\<^sub>F x in ?F. ?f x \\<in> ?s \\<and> ?f x \\<noteq> ?b) \\<and>\n   (?f \\<longlongrightarrow> ?b) ?F)\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "by blast"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_top \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_top \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "have \"(g has_sgnx sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "have \"((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow> sgn c * inverse c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n     sgn c * inverse c)\n     F", "using assms(1,2)"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> c) F\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n     sgn c * inverse c)\n     F", "by (auto intro:tendsto_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n   sgn c * inverse c)\n   F\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n   sgn c * inverse c)\n   F", "have \"LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. sgn c * inverse (f x)) \\<longlongrightarrow>\n   sgn c * inverse c)\n   F\n\ngoal (1 subgoal):\n 1. LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_top", "apply (elim filterlim_tendsto_pos_mult_at_top[OF _ _ asm])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sgn c * inverse c", "using \\<open>c\\<noteq>0\\<close> sgn_real_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  sgn ?a = (if ?a = 0 then 0 else if 0 < ?a then 1 else - 1)\n\ngoal (1 subgoal):\n 1. 0 < sgn c * inverse c", "by auto"], ["proof (state)\nthis:\n  LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_top\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_top", "have \"LIM x F. sgn c / g x :> at_top\""], ["proof (prove)\nusing this:\n  LIM x F. sgn c * inverse (f x) * (f x / g x) :> at_top\n\ngoal (1 subgoal):\n 1. LIM x F. sgn c / g x :> at_top", "apply (elim filterlim_mono_eventually)"], ["proof (prove)\ngoal (3 subgoals):\n 1. at_top \\<le> at_top\n 2. F \\<le> F\n 3. \\<forall>\\<^sub>F x in F.\n       sgn c * inverse (f x) * (f x / g x) = sgn c / g x", "using eventually_times_inverse_1[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. inverse (f x) * f x = 1\n\ngoal (3 subgoals):\n 1. at_top \\<le> at_top\n 2. F \\<le> F\n 3. \\<forall>\\<^sub>F x in F.\n       sgn c * inverse (f x) * (f x / g x) = sgn c / g x", "by (auto elim:eventually_mono)"], ["proof (state)\nthis:\n  LIM x F. sgn c / g x :> at_top\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  LIM x F. sgn c / g x :> at_top", "have \"\\<forall>\\<^sub>F x in F. sgn c / g x > 0\""], ["proof (prove)\nusing this:\n  LIM x F. sgn c / g x :> at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < sgn c / g x", "using filterlim_at_top_dense[of \"\\<lambda>x. sgn c/g x\" F]"], ["proof (prove)\nusing this:\n  LIM x F. sgn c / g x :> at_top\n  (LIM x F. sgn c / g x :> at_top) =\n  (\\<forall>Z. \\<forall>\\<^sub>F x in F. Z < sgn c / g x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < sgn c / g x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < sgn c / g x\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. 0 < sgn c / g x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < sgn c / g x\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < sgn c / g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (g x) = sgn c", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < sgn c / g x \\<Longrightarrow> sgn (g x) = sgn c", "by (metis sgn_greater sgn_less sgn_neg sgn_pos zero_less_divide_iff)"], ["proof (state)\nthis:\n  (g has_sgnx sgn c) F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx sgn c) F\n\ngoal (2 subgoals):\n 1. LIM x F. f x / g x :> at_top \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n 2. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "ultimately"], ["proof (chain)\npicking this:\n  (g \\<longlongrightarrow> 0) F\n  (g has_sgnx sgn c) F", "show \"(g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\""], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 0) F\n  (g has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F", "by auto"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "assume \"(g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\""], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "then"], ["proof (chain)\npicking this:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F", "have asm:\"(g \\<longlongrightarrow> 0) F\" \"(g has_sgnx sgn c) F\""], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F &&& (g has_sgnx sgn c) F", "by auto"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) F\n  (g has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "have \"LIM x F. inverse (g x * sgn c) :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x F. inverse (g x * sgn c) :> at_top", "proof (rule filterlim_inverse_at_top)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F\n 2. \\<forall>\\<^sub>F x in F. 0 < g x * sgn c", "show \"((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F", "apply (rule tendsto_mult_left_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "using asm(1)"], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x. g x * sgn c) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < g x * sgn c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < g x * sgn c", "show \"\\<forall>\\<^sub>F x in F. g x * sgn c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < g x * sgn c", "using asm(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn c) F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < g x * sgn c", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (g x) = sgn c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < g x * sgn c", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. sgn (g x) = sgn c \\<Longrightarrow> 0 < g x * sgn c", "by (metis assms(2) sgn_1_neg sgn_greater sgn_if zero_less_mult_iff)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < g x * sgn c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x F. inverse (g x * sgn c) :> at_top\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  LIM x F. inverse (g x * sgn c) :> at_top\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "have \"((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F", "using \\<open>(f \\<longlongrightarrow> c) F\\<close> \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> c) F\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> c) F; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (f \\<longlongrightarrow> c) F", "by (auto simp add:sgn_zero_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "have \"c * sgn c >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c * sgn c", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < c * sgn c", "by (simp add: sgn_real_def)"], ["proof (state)\nthis:\n  0 < c * sgn c\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "ultimately"], ["proof (chain)\npicking this:\n  LIM x F. inverse (g x * sgn c) :> at_top\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n  0 < c * sgn c", "have \"LIM x F. (f x * sgn c) *inverse (g x * sgn c) :> at_top\""], ["proof (prove)\nusing this:\n  LIM x F. inverse (g x * sgn c) :> at_top\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n  0 < c * sgn c\n\ngoal (1 subgoal):\n 1. LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_top", "using filterlim_tendsto_pos_mult_at_top"], ["proof (prove)\nusing this:\n  LIM x F. inverse (g x * sgn c) :> at_top\n  ((\\<lambda>x. f x * sgn c) \\<longlongrightarrow> c * sgn c) F\n  0 < c * sgn c\n  \\<lbrakk>(?f \\<longlongrightarrow> ?c) ?F; 0 < ?c;\n   filterlim ?g at_top ?F\\<rbrakk>\n  \\<Longrightarrow> LIM x ?F. ?f x * ?g x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_top", "by blast"], ["proof (state)\nthis:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_top\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) F \\<and>\n    (g has_sgnx sgn c) F \\<Longrightarrow>\n    LIM x F. f x / g x :> at_top", "then"], ["proof (chain)\npicking this:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_top", "show \"LIM x F. f x / g x :> at_top\""], ["proof (prove)\nusing this:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_top\n\ngoal (1 subgoal):\n 1. LIM x F. f x / g x :> at_top", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  LIM x F. f x * sgn c * inverse (g x * sgn c) :> at_top\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x F. f x / g x :> at_top", "by (auto simp add:field_simps sgn_zero_iff)"], ["proof (state)\nthis:\n  LIM x F. f x / g x :> at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LIM x F. f x / g x :> at_top) =\n  ((g \\<longlongrightarrow> 0) F \\<and> (g has_sgnx sgn c) F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_sgnx_left_right:\n  fixes c a::real and p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"sgnx (poly p) (at_left a) = (if even (order a p) \n            then sgnx (poly p) (at_right a)\n            else -sgnx (poly p) (at_right a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "proof (induction \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> sgnx (poly pa) (at_left a) =\n                                     (if even (order a pa)\nthen sgnx (poly pa) (at_right a) else - sgnx (poly pa) (at_right a));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sgnx (poly p) (at_left a) =\n                         (if even (order a p)\n                          then sgnx (poly p) (at_right a)\n                          else - sgnx (poly p) (at_right a))", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p < degree p; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sgnx (poly ?p) (at_left a) =\n                    (if even (order a ?p) then sgnx (poly ?p) (at_right a)\n                     else - sgnx (poly ?p) (at_right a))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> sgnx (poly pa) (at_left a) =\n                                     (if even (order a pa)\nthen sgnx (poly pa) (at_right a) else - sgnx (poly pa) (at_right a));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sgnx (poly p) (at_left a) =\n                         (if even (order a p)\n                          then sgnx (poly p) (at_right a)\n                          else - sgnx (poly p) (at_right a))", "have ?case when \"poly p a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "have \"sgnx (poly p) (at_left a) = sgn (poly p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = sgn (poly p a)", "by (simp add: has_sgnx_imp_sgnx tendsto_nonzero_has_sgnx that)"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = sgn (poly p a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = sgn (poly p a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "have \"sgnx (poly p) (at_right a) = sgn (poly p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgn (poly p a)", "by (simp add: has_sgnx_imp_sgnx tendsto_nonzero_has_sgnx that)"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgn (poly p a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgn (poly p a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "have \"order a p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p = 0", "using that"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order a p = 0", "by (simp add: order_0I)"], ["proof (state)\nthis:\n  order a p = 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left a) = sgn (poly p a)\n  sgnx (poly p) (at_right a) = sgn (poly p a)\n  order a p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) = sgn (poly p a)\n  sgnx (poly p) (at_right a) = sgn (poly p a)\n  order a p = 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> sgnx (poly pa) (at_left a) =\n                                     (if even (order a pa)\nthen sgnx (poly pa) (at_right a) else - sgnx (poly pa) (at_right a));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sgnx (poly p) (at_left a) =\n                         (if even (order a p)\n                          then sgnx (poly p) (at_right a)\n                          else - sgnx (poly p) (at_right a))", "moreover"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> sgnx (poly pa) (at_left a) =\n                                     (if even (order a pa)\nthen sgnx (poly pa) (at_right a) else - sgnx (poly pa) (at_right a));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sgnx (poly p) (at_left a) =\n                         (if even (order a p)\n                          then sgnx (poly p) (at_right a)\n                          else - sgnx (poly p) (at_right a))", "have ?case when \"poly p a=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "obtain q where pq:\"p= [:-a,1:] * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q. p = [:- a, 1:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>poly p a=0\\<close>"], ["proof (prove)\nusing this:\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = [:- a, 1:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson dvdE poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  p = [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "then"], ["proof (chain)\npicking this:\n  p = [:- a, 1:] * q", "have \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = [:- a, 1:] * q\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "then"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have \"degree q < degree p\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree q < degree p", "unfolding pq"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree q < degree ([:- a, 1:] * q)", "by (subst degree_mult_eq,auto)"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "have \"sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)", "have \"sgnx (\\<lambda>x. poly p x) (at_left a) \n          = sgnx (poly q) (at_left a) * sgnx (poly [:-a,1:]) (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)", "unfolding pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly ([:- a, 1:] * q)) (at_left a) =\n    sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)", "apply (subst poly_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. poly [:- a, 1:] x * poly q x) (at_left a) =\n    sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)", "apply (subst sgnx_times)"], ["proof (prove)\ngoal (4 subgoals):\n 1. at_left a \\<noteq> bot\n 2. poly [:- a, 1:] sgnx_able at_left a\n 3. poly q sgnx_able at_left a\n 4. sgnx (poly [:- a, 1:]) (at_left a) * sgnx (poly q) (at_left a) =\n    sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) =\n  sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) =\n  sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)", "have \"sgnx (\\<lambda>x. poly [:-a,1:] x) (at_left a) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly [:- a, 1:]) (at_left a) = - 1", "apply (intro has_sgnx_imp_sgnx)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (poly [:- a, 1:] has_sgnx - 1) (at_left a)\n 2. at_left a \\<noteq> bot", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b<a.\n       \\<forall>y>b. y < a \\<longrightarrow> sgn (poly [:- a, 1:] y) = - 1\n 2. at_left a \\<noteq> bot", "by (auto simp add: linordered_field_no_lb)"], ["proof (state)\nthis:\n  sgnx (poly [:- a, 1:]) (at_left a) = - 1\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left a) =\n  sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)\n  sgnx (poly [:- a, 1:]) (at_left a) = - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) =\n  sgnx (poly q) (at_left a) * sgnx (poly [:- a, 1:]) (at_left a)\n  sgnx (poly [:- a, 1:]) (at_left a) = - 1\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "have \"sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "have \"sgnx (\\<lambda>x. poly p x) (at_right a) \n          = sgnx (poly q) (at_right a) * sgnx (poly [:-a,1:]) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) =\n    sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)", "unfolding pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly ([:- a, 1:] * q)) (at_right a) =\n    sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)", "apply (subst poly_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (\\<lambda>x. poly [:- a, 1:] x * poly q x) (at_right a) =\n    sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)", "apply (subst sgnx_times)"], ["proof (prove)\ngoal (4 subgoals):\n 1. at_right a \\<noteq> bot\n 2. poly [:- a, 1:] sgnx_able at_right a\n 3. poly q sgnx_able at_right a\n 4. sgnx (poly [:- a, 1:]) (at_right a) * sgnx (poly q) (at_right a) =\n    sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) =\n  sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) =\n  sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "have \"sgnx (\\<lambda>x. poly [:-a,1:] x) (at_right a) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly [:- a, 1:]) (at_right a) = 1", "apply (intro has_sgnx_imp_sgnx)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (poly [:- a, 1:] has_sgnx 1) (at_right a)\n 2. at_right a \\<noteq> bot", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b>a.\n       \\<forall>y>a. y < b \\<longrightarrow> sgn (poly [:- a, 1:] y) = 1\n 2. at_right a \\<noteq> bot", "by (auto simp add: linordered_field_no_ub)"], ["proof (state)\nthis:\n  sgnx (poly [:- a, 1:]) (at_right a) = 1\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) =\n  sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)\n  sgnx (poly [:- a, 1:]) (at_right a) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) =\n  sgnx (poly q) (at_right a) * sgnx (poly [:- a, 1:]) (at_right a)\n  sgnx (poly [:- a, 1:]) (at_right a) = 1\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "have \"even (order a p) \\<longleftrightarrow> odd (order a q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (order a p) = odd (order a q)", "unfolding pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (order a ([:- a, 1:] * q)) = odd (order a q)", "apply (subst order_mult[OF \\<open>p \\<noteq> 0\\<close>[unfolded pq]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (order a [:- a, 1:] + order a q) = odd (order a q)", "using  \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. even (order a [:- a, 1:] + order a q) = odd (order a q)", "by (auto simp add:order_power_n_n[of _ 1, simplified])"], ["proof (state)\nthis:\n  even (order a p) = odd (order a q)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "moreover"], ["proof (state)\nthis:\n  even (order a p) = odd (order a q)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "note less.hyps[OF \\<open>degree q < degree p\\<close> \\<open>q\\<noteq>0\\<close>]"], ["proof (state)\nthis:\n  sgnx (poly q) (at_left a) =\n  (if even (order a q) then sgnx (poly q) (at_right a)\n   else - sgnx (poly q) (at_right a))\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n  even (order a p) = odd (order a q)\n  sgnx (poly q) (at_left a) =\n  (if even (order a q) then sgnx (poly q) (at_right a)\n   else - sgnx (poly q) (at_right a))", "show ?thesis"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) = - sgnx (poly q) (at_left a)\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n  even (order a p) = odd (order a q)\n  sgnx (poly q) (at_left a) =\n  (if even (order a q) then sgnx (poly q) (at_right a)\n   else - sgnx (poly q) (at_right a))\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p a = 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> sgnx (poly pa) (at_left a) =\n                                     (if even (order a pa)\nthen sgnx (poly pa) (at_right a) else - sgnx (poly pa) (at_right a));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sgnx (poly p) (at_left a) =\n                         (if even (order a p)\n                          then sgnx (poly p) (at_right a)\n                          else - sgnx (poly p) (at_right a))", "ultimately"], ["proof (chain)\npicking this:\n  poly p a \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n  poly p a = 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))", "show ?case"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n  poly p a = 0 \\<Longrightarrow>\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) =\n    (if even (order a p) then sgnx (poly p) (at_right a)\n     else - sgnx (poly p) (at_right a))", "by blast"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) =\n  (if even (order a p) then sgnx (poly p) (at_right a)\n   else - sgnx (poly p) (at_right a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_has_sgnx_left_right:\n  fixes c a::real and p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"(poly p has_sgnx c) (at_left a) \\<longleftrightarrow> (if even (order a p) \n            then (poly p has_sgnx c) (at_right a)\n            else (poly p has_sgnx -c) (at_right a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_left a) =\n    (if even (order a p) then (poly p has_sgnx c) (at_right a)\n     else (poly p has_sgnx - c) (at_right a))", "using poly_sgnx_left_right"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly ?p) (at_left ?a) =\n  (if even (order ?a ?p) then sgnx (poly ?p) (at_right ?a)\n   else - sgnx (poly ?p) (at_right ?a))\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_left a) =\n    (if even (order a p) then (poly p has_sgnx c) (at_right a)\n     else (poly p has_sgnx - c) (at_right a))", "by (metis (no_types, hide_lams) add.inverse_inverse assms has_sgnx_unique \n     sgnx_able_poly sgnx_able_sgnx trivial_limit_at_left_real trivial_limit_at_right_real)"], ["", "lemma sign_r_pos_sgnx_iff:\n  \"sign_r_pos p a \\<longleftrightarrow> sgnx (poly p) (at_right a) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p a = (0 < sgnx (poly p) (at_right a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)\n 2. 0 < sgnx (poly p) (at_right a) \\<Longrightarrow> sign_r_pos p a", "assume asm:\"0 < sgnx (poly p) (at_right a)\""], ["proof (state)\nthis:\n  0 < sgnx (poly p) (at_right a)\n\ngoal (2 subgoals):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)\n 2. 0 < sgnx (poly p) (at_right a) \\<Longrightarrow> sign_r_pos p a", "obtain c where c_def:\"(poly p has_sgnx c) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (poly p has_sgnx c) (at_right a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sgnx_able_poly(1) sgnx_able_sgnx"], ["proof (prove)\nusing this:\n  poly ?p sgnx_able at_right ?a\n  ?f sgnx_able ?F \\<Longrightarrow> (?f has_sgnx sgnx ?f ?F) ?F\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (poly p has_sgnx c) (at_right a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (2 subgoals):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)\n 2. 0 < sgnx (poly p) (at_right a) \\<Longrightarrow> sign_r_pos p a", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx c) (at_right a)", "have \"c>0\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. 0 < c", "using asm"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n  0 < sgnx (poly p) (at_right a)\n\ngoal (1 subgoal):\n 1. 0 < c", "using has_sgnx_imp_sgnx trivial_limit_at_right_real"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n  0 < sgnx (poly p) (at_right a)\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n  at_right ?x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. 0 < c", "by blast"], ["proof (state)\nthis:\n  0 < c\n\ngoal (2 subgoals):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)\n 2. 0 < sgnx (poly p) (at_right a) \\<Longrightarrow> sign_r_pos p a", "then"], ["proof (chain)\npicking this:\n  0 < c", "show \"sign_r_pos p a\""], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. sign_r_pos p a", "using c_def"], ["proof (prove)\nusing this:\n  0 < c\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos p a", "unfolding sign_r_pos_def has_sgnx_def"], ["proof (prove)\nusing this:\n  0 < c\n  \\<forall>\\<^sub>F x in at_right a. sgn (poly p x) = c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. 0 < poly p x", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < c; sgn (poly p x) = c\\<rbrakk>\n       \\<Longrightarrow> 0 < poly p x", "by force"], ["proof (state)\nthis:\n  sign_r_pos p a\n\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "assume asm:\"sign_r_pos p a\""], ["proof (state)\nthis:\n  sign_r_pos p a\n\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "define c where \"c = sgnx (poly p) (at_right a)\""], ["proof (state)\nthis:\n  c = sgnx (poly p) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "then"], ["proof (chain)\npicking this:\n  c = sgnx (poly p) (at_right a)", "have \"(poly p has_sgnx c) (at_right a)\""], ["proof (prove)\nusing this:\n  c = sgnx (poly p) (at_right a)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_right a)", "by (simp add: sgnx_able_sgnx)"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx c) (at_right a)", "have \"(\\<forall>\\<^sub>F x in (at_right a). poly p x>0 \\<and> sgn (poly p x) = c)\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a.\n       0 < poly p x \\<and> sgn (poly p x) = c", "using asm"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n  sign_r_pos p a\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a.\n       0 < poly p x \\<and> sgn (poly p x) = c", "unfolding has_sgnx_def sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. sgn (poly p x) = c\n  \\<forall>\\<^sub>F x in at_right a. 0 < poly p x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a.\n       0 < poly p x \\<and> sgn (poly p x) = c", "by (simp add:eventually_conj_iff)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right a. 0 < poly p x \\<and> sgn (poly p x) = c\n\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < poly p x \\<and> sgn (poly p x) = c", "have \"\\<forall>\\<^sub>F x in (at_right a). c > 0\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < poly p x \\<and> sgn (poly p x) = c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. 0 < c", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < poly p x \\<and> sgn (poly p x) = c \\<Longrightarrow> 0 < c", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right a. 0 < c\n\ngoal (1 subgoal):\n 1. sign_r_pos p a \\<Longrightarrow> 0 < sgnx (poly p) (at_right a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < c", "show \"c>0\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < c\n\ngoal (1 subgoal):\n 1. 0 < c", "by auto"], ["proof (state)\nthis:\n  0 < c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_values:\n  assumes \"f sgnx_able F\" \"F \\<noteq> bot\"\n  shows \"sgnx f F = -1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "obtain c where c_def:\"(f has_sgnx c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. (f has_sgnx c) F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  f sgnx_able F\n\ngoal (1 subgoal):\n 1. (\\<And>c. (f has_sgnx c) F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sgnx_able_def"], ["proof (prove)\nusing this:\n  \\<exists>c. (f has_sgnx c) F\n\ngoal (1 subgoal):\n 1. (\\<And>c. (f has_sgnx c) F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx c) F\n\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx c) F", "obtain x where \"sgn(f x) = c\""], ["proof (prove)\nusing this:\n  (f has_sgnx c) F\n\ngoal (1 subgoal):\n 1. (\\<And>x. sgn (f x) = c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c\n\ngoal (1 subgoal):\n 1. (\\<And>x. sgn (f x) = c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) eventually_happens"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. sgn (f x) = c\n  F \\<noteq> bot\n  eventually ?P ?net \\<Longrightarrow> ?net = bot \\<or> (\\<exists>x. ?P x)\n\ngoal (1 subgoal):\n 1. (\\<And>x. sgn (f x) = c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sgn (f x) = c\n\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "then"], ["proof (chain)\npicking this:\n  sgn (f x) = c", "have \"c=-1 \\<or> c=0 \\<or> c=1\""], ["proof (prove)\nusing this:\n  sgn (f x) = c\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 0 \\<or> c = 1", "using sgn_if"], ["proof (prove)\nusing this:\n  sgn (f x) = c\n  sgn ?x =\n  (if ?x = (0::?'a) then 0::?'a\n   else if (0::?'a) < ?x then 1::?'a else - (1::?'a))\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 0 \\<or> c = 1", "by metis"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "moreover"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "have \"sgnx f F = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx f F = c", "using c_def"], ["proof (prove)\nusing this:\n  (f has_sgnx c) F\n\ngoal (1 subgoal):\n 1. sgnx f F = c", "by (simp add: assms(2) has_sgnx_imp_sgnx)"], ["proof (state)\nthis:\n  sgnx f F = c\n\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "ultimately"], ["proof (chain)\npicking this:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n  sgnx f F = c", "show ?thesis"], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n  sgnx f F = c\n\ngoal (1 subgoal):\n 1. sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1", "by auto"], ["proof (state)\nthis:\n  sgnx f F = - 1 \\<or> sgnx f F = 0 \\<or> sgnx f F = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_poly_at_top:\n    \"(poly p has_sgnx  sgn_pos_inf p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn_pos_inf p) at_top", "using has_sgnx_def poly_sgn_eventually_at_top"], ["proof (prove)\nusing this:\n  (?f has_sgnx ?c) ?F = (\\<forall>\\<^sub>F x in ?F. sgn (?f x) = ?c)\n  \\<forall>\\<^sub>F x in at_top. sgn (poly ?p x) = sgn_pos_inf ?p\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn_pos_inf p) at_top", "by blast"], ["", "lemma has_sgnx_poly_at_bot:\n    \"(poly p has_sgnx  sgn_neg_inf p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn_neg_inf p) at_bot", "using has_sgnx_def poly_sgn_eventually_at_bot"], ["proof (prove)\nusing this:\n  (?f has_sgnx ?c) ?F = (\\<forall>\\<^sub>F x in ?F. sgn (?f x) = ?c)\n  \\<forall>\\<^sub>F x in at_bot. sgn (poly ?p x) = sgn_neg_inf ?p\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn_neg_inf p) at_bot", "by blast"], ["", "lemma sgnx_poly_at_top:\n  \"sgnx (poly p) at_top = sgn_pos_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) at_top = sgn_pos_inf p", "by (simp add: has_sgnx_def has_sgnx_imp_sgnx poly_sgn_eventually_at_top)"], ["", "lemma sgnx_poly_at_bot:\n  \"sgnx (poly p) at_bot = sgn_neg_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) at_bot = sgn_neg_inf p", "by (simp add: has_sgnx_def has_sgnx_imp_sgnx poly_sgn_eventually_at_bot)"], ["", "lemma poly_has_sgnx_values:\n  assumes \"p\\<noteq>0\"\n  shows \n    \"(poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\"\n    \"(poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\"\n    \"(poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\"\n    \"(poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((poly p has_sgnx 1) (at_left a) \\<or>\n     (poly p has_sgnx - 1) (at_left a) &&&\n     (poly p has_sgnx 1) (at_right a) \\<or>\n     (poly p has_sgnx - 1) (at_right a)) &&&\n    (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top &&&\n    (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)\n 3. (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n 4. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "have \"sgn_pos_inf p = 1 \\<or> sgn_pos_inf p = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_pos_inf p = 1 \\<or> sgn_pos_inf p = - 1", "unfolding sgn_pos_inf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (lead_coeff p) = 1 \\<or> sgn (lead_coeff p) = - 1", "by (simp add: assms sgn_if)"], ["proof (state)\nthis:\n  sgn_pos_inf p = 1 \\<or> sgn_pos_inf p = - 1\n\ngoal (4 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)\n 3. (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n 4. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "then"], ["proof (chain)\npicking this:\n  sgn_pos_inf p = 1 \\<or> sgn_pos_inf p = - 1", "show \"(poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\""], ["proof (prove)\nusing this:\n  sgn_pos_inf p = 1 \\<or> sgn_pos_inf p = - 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top", "using has_sgnx_poly_at_top"], ["proof (prove)\nusing this:\n  sgn_pos_inf p = 1 \\<or> sgn_pos_inf p = - 1\n  (poly ?p has_sgnx sgn_pos_inf ?p) at_top\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top", "by metis"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n\ngoal (3 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)\n 3. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)\n 3. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "have \"sgn_neg_inf p = 1 \\<or> sgn_neg_inf p = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_neg_inf p = 1 \\<or> sgn_neg_inf p = - 1", "unfolding sgn_neg_inf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p)) =\n    1 \\<or>\n    (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p)) =\n    - 1", "by (simp add: assms sgn_if)"], ["proof (state)\nthis:\n  sgn_neg_inf p = 1 \\<or> sgn_neg_inf p = - 1\n\ngoal (3 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)\n 3. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "then"], ["proof (chain)\npicking this:\n  sgn_neg_inf p = 1 \\<or> sgn_neg_inf p = - 1", "show \"(poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\""], ["proof (prove)\nusing this:\n  sgn_neg_inf p = 1 \\<or> sgn_neg_inf p = - 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "using has_sgnx_poly_at_bot"], ["proof (prove)\nusing this:\n  sgn_neg_inf p = 1 \\<or> sgn_neg_inf p = - 1\n  (poly ?p has_sgnx sgn_neg_inf ?p) at_bot\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "by metis"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "obtain c where c_def:\"(poly p has_sgnx c) (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (poly p has_sgnx c) (at_left a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sgnx_able_poly(2) sgnx_able_sgnx"], ["proof (prove)\nusing this:\n  poly ?p sgnx_able at_left ?a\n  ?f sgnx_able ?F \\<Longrightarrow> (?f has_sgnx sgnx ?f ?F) ?F\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (poly p has_sgnx c) (at_left a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_left a)\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx c) (at_left a)", "have \"sgnx (poly p) (at_left a) = c\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_left a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = c", "using assms"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_left a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = c", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = c\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left a) = c", "have \"c=-1 \\<or> c=0 \\<or> c=1\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) = c\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 0 \\<or> c = 1", "using sgnx_values sgnx_able_poly(2) trivial_limit_at_left_real"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) = c\n  \\<lbrakk>?f sgnx_able ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = - 1 \\<or>\n                    sgnx ?f ?F = 0 \\<or> sgnx ?f ?F = 1\n  poly ?p sgnx_able at_left ?a\n  at_left ?x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 0 \\<or> c = 1", "by blast"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "moreover"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "have False when \"c=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(poly p has_sgnx 0) (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx 0) (at_left a)", "using c_def that"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_left a)\n  c = 0\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 0) (at_left a)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 0) (at_left a)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 0) (at_left a)", "obtain lb where \"lb<a\" \"\\<forall>y. (lb<y \\<and> y < a) \\<longrightarrow> poly p y = 0\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx 0) (at_left a)\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < a;\n         \\<forall>y.\n            lb < y \\<and> y < a \\<longrightarrow> poly p y = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def eventually_at_left sgn_if"], ["proof (prove)\nusing this:\n  \\<exists>b<a.\n     \\<forall>y>b.\n        y < a \\<longrightarrow>\n        (if poly p y = 0 then 0 else if 0 < poly p y then 1 else - 1) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < a;\n         \\<forall>y.\n            lb < y \\<and> y < a \\<longrightarrow> poly p y = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis one_neq_zero zero_neq_neg_one)"], ["proof (state)\nthis:\n  lb < a\n  \\<forall>y. lb < y \\<and> y < a \\<longrightarrow> poly p y = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  lb < a\n  \\<forall>y. lb < y \\<and> y < a \\<longrightarrow> poly p y = 0", "have \"{lb<..<a} \\<subseteq> proots p\""], ["proof (prove)\nusing this:\n  lb < a\n  \\<forall>y. lb < y \\<and> y < a \\<longrightarrow> poly p y = 0\n\ngoal (1 subgoal):\n 1. {lb<..<a} \\<subseteq> proots p", "unfolding proots_within_def"], ["proof (prove)\nusing this:\n  lb < a\n  \\<forall>y. lb < y \\<and> y < a \\<longrightarrow> poly p y = 0\n\ngoal (1 subgoal):\n 1. {lb<..<a} \\<subseteq> {x \\<in> UNIV. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  {lb<..<a} \\<subseteq> proots p\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  {lb<..<a} \\<subseteq> proots p", "have \"infinite (proots p)\""], ["proof (prove)\nusing this:\n  {lb<..<a} \\<subseteq> proots p\n\ngoal (1 subgoal):\n 1. infinite (proots p)", "apply (elim infinite_super)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {lb<..<a}", "using \\<open>lb<a\\<close>"], ["proof (prove)\nusing this:\n  lb < a\n\ngoal (1 subgoal):\n 1. infinite {lb<..<a}", "by auto"], ["proof (state)\nthis:\n  infinite (proots p)\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  infinite (proots p)\n\ngoal (1 subgoal):\n 1. False", "have \"finite (proots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots p)", "using finite_proots[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  finite (proots_within p ?s)\n\ngoal (1 subgoal):\n 1. finite (proots p)", "by auto"], ["proof (state)\nthis:\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  infinite (proots p)\n  finite (proots p)", "show False"], ["proof (prove)\nusing this:\n  infinite (proots p)\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n  c = 0 \\<Longrightarrow> False", "have \"c=-1 \\<or> c=1\""], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n  c = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 1", "by auto"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 1\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n 2. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  c = - 1 \\<or> c = 1", "show \"(poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\""], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)", "using c_def"], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 1\n  (poly p has_sgnx c) (at_left a)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "obtain c where c_def:\"(poly p has_sgnx c) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (poly p has_sgnx c) (at_right a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sgnx_able_poly(1) sgnx_able_sgnx"], ["proof (prove)\nusing this:\n  poly ?p sgnx_able at_right ?a\n  ?f sgnx_able ?F \\<Longrightarrow> (?f has_sgnx sgnx ?f ?F) ?F\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (poly p has_sgnx c) (at_right a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx c) (at_right a)", "have \"sgnx (poly p) (at_right a) = c\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = c", "using assms"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = c", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = c\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) = c", "have \"c=-1 \\<or> c=0 \\<or> c=1\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = c\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 0 \\<or> c = 1", "using sgnx_values sgnx_able_poly(1) trivial_limit_at_right_real"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = c\n  \\<lbrakk>?f sgnx_able ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = - 1 \\<or>\n                    sgnx ?f ?F = 0 \\<or> sgnx ?f ?F = 1\n  poly ?p sgnx_able at_right ?a\n  at_right ?x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 0 \\<or> c = 1", "by blast"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "moreover"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "have False when \"c=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(poly p has_sgnx 0) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx 0) (at_right a)", "using c_def that"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n  c = 0\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 0) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 0) (at_right a)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 0) (at_right a)", "obtain ub where \"ub>a\" \"\\<forall>y. (a<y \\<and> y < ub) \\<longrightarrow> poly p y = 0\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx 0) (at_right a)\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>a < ub;\n         \\<forall>y.\n            a < y \\<and> y < ub \\<longrightarrow> poly p y = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def eventually_at_right sgn_if"], ["proof (prove)\nusing this:\n  \\<exists>b>a.\n     \\<forall>y>a.\n        y < b \\<longrightarrow>\n        (if poly p y = 0 then 0 else if 0 < poly p y then 1 else - 1) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>a < ub;\n         \\<forall>y.\n            a < y \\<and> y < ub \\<longrightarrow> poly p y = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis one_neq_zero zero_neq_neg_one)"], ["proof (state)\nthis:\n  a < ub\n  \\<forall>y. a < y \\<and> y < ub \\<longrightarrow> poly p y = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  a < ub\n  \\<forall>y. a < y \\<and> y < ub \\<longrightarrow> poly p y = 0", "have \"{a<..<ub} \\<subseteq> proots p\""], ["proof (prove)\nusing this:\n  a < ub\n  \\<forall>y. a < y \\<and> y < ub \\<longrightarrow> poly p y = 0\n\ngoal (1 subgoal):\n 1. {a<..<ub} \\<subseteq> proots p", "unfolding proots_within_def"], ["proof (prove)\nusing this:\n  a < ub\n  \\<forall>y. a < y \\<and> y < ub \\<longrightarrow> poly p y = 0\n\ngoal (1 subgoal):\n 1. {a<..<ub} \\<subseteq> {x \\<in> UNIV. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  {a<..<ub} \\<subseteq> proots p\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  {a<..<ub} \\<subseteq> proots p", "have \"infinite (proots p)\""], ["proof (prove)\nusing this:\n  {a<..<ub} \\<subseteq> proots p\n\ngoal (1 subgoal):\n 1. infinite (proots p)", "apply (elim infinite_super)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {a<..<ub}", "using \\<open>ub>a\\<close>"], ["proof (prove)\nusing this:\n  a < ub\n\ngoal (1 subgoal):\n 1. infinite {a<..<ub}", "by auto"], ["proof (state)\nthis:\n  infinite (proots p)\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  infinite (proots p)\n\ngoal (1 subgoal):\n 1. False", "have \"finite (proots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots p)", "using finite_proots[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  finite (proots_within p ?s)\n\ngoal (1 subgoal):\n 1. finite (proots p)", "by auto"], ["proof (state)\nthis:\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  infinite (proots p)\n  finite (proots p)", "show False"], ["proof (prove)\nusing this:\n  infinite (proots p)\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n  c = 0 \\<Longrightarrow> False", "have \"c=-1 \\<or> c=1\""], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 0 \\<or> c = 1\n  c = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. c = - 1 \\<or> c = 1", "by auto"], ["proof (state)\nthis:\n  c = - 1 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  c = - 1 \\<or> c = 1", "show \"(poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\""], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 1\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "using c_def"], ["proof (prove)\nusing this:\n  c = - 1 \\<or> c = 1\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_sgnx_values:\n  assumes \"p\\<noteq>0\"\n  shows \"sgnx (poly p) (at_left a) = 1 \\<or> sgnx (poly p) (at_left a) = -1\"\n        \"sgnx (poly p) (at_right a) = 1 \\<or> sgnx (poly p) (at_right a) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = 1 \\<or> sgnx (poly p) (at_left a) = - 1 &&&\n    sgnx (poly p) (at_right a) = 1 \\<or> sgnx (poly p) (at_right a) = - 1", "using poly_has_sgnx_values[OF \\<open>p\\<noteq>0\\<close>] has_sgnx_imp_sgnx trivial_limit_at_left_real \n    trivial_limit_at_right_real"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n  at_left ?x \\<noteq> bot\n  at_right ?x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = 1 \\<or> sgnx (poly p) (at_left a) = - 1 &&&\n    sgnx (poly p) (at_right a) = 1 \\<or> sgnx (poly p) (at_right a) = - 1", "by blast+"], ["", "lemma has_sgnx_inverse: \"(f has_sgnx c) F \\<longleftrightarrow> ((inverse o f) has_sgnx (inverse c)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx c) F = ((inverse \\<circ> f) has_sgnx inverse c) F", "unfolding has_sgnx_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in F. sgn (f x) = c) =\n    (\\<forall>\\<^sub>F x in F. sgn (inverse (f x)) = inverse c)", "apply (rule eventually_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       (sgn (f n) = c) = (sgn (inverse (f n)) = inverse c)", "apply (rule always_eventually)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (sgn (f x) = c) = (sgn (inverse (f x)) = inverse c)", "by (metis inverse_inverse_eq sgn_inverse)"], ["", "lemma has_sgnx_derivative_at_left:\n  assumes g_deriv:\"(g has_field_derivative c) (at x)\" and \"g x=0\" and \"c\\<noteq>0\" \n  shows \"(g has_sgnx - sgn c) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "have \"(g has_sgnx -1) (at_left x)\" when \"c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left x)", "obtain d1 where \"d1>0\" and d1_def:\"\\<forall>h>0. h < d1 \\<longrightarrow> g (x - h) < g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>0 < d1;\n         \\<forall>h>0. h < d1 \\<longrightarrow> g (x - h) < g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_pos_inc_left[OF g_deriv \\<open>c>0\\<close>] \\<open>g x=0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>d>0. \\<forall>h>0. h < d \\<longrightarrow> g (x - h) < g x\n  g x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>0 < d1;\n         \\<forall>h>0. h < d1 \\<longrightarrow> g (x - h) < g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < d1\n  \\<forall>h>0. h < d1 \\<longrightarrow> g (x - h) < g x\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left x)", "have \"(g has_sgnx -1) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left x)", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> sgn (g y) = - 1", "apply (intro exI[where x=\"x-d1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - d1 < x \\<and>\n    (\\<forall>y>x - d1. y < x \\<longrightarrow> sgn (g y) = - 1)", "using \\<open>d1>0\\<close> d1_def"], ["proof (prove)\nusing this:\n  0 < d1\n  \\<forall>h>0. h < d1 \\<longrightarrow> g (x - h) < g x\n\ngoal (1 subgoal):\n 1. x - d1 < x \\<and>\n    (\\<forall>y>x - d1. y < x \\<longrightarrow> sgn (g y) = - 1)", "by (metis (no_types, hide_lams) add.commute add_uminus_conv_diff assms(2) diff_add_cancel \n          diff_strict_left_mono diff_zero minus_diff_eq sgn_neg)"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow> (g has_sgnx - 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "moreover"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow> (g has_sgnx - 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "have \"(g has_sgnx 1) (at_left x)\" when \"c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "obtain d1 where \"d1>0\" and d1_def:\"\\<forall>h>0. h < d1 \\<longrightarrow> g (x - h) > g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>0 < d1;\n         \\<forall>h>0. h < d1 \\<longrightarrow> g x < g (x - h)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_neg_dec_left[OF g_deriv \\<open>c<0\\<close>] \\<open>g x=0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>d>0. \\<forall>h>0. h < d \\<longrightarrow> g x < g (x - h)\n  g x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>0 < d1;\n         \\<forall>h>0. h < d1 \\<longrightarrow> g x < g (x - h)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < d1\n  \\<forall>h>0. h < d1 \\<longrightarrow> g x < g (x - h)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "have \"(g has_sgnx 1) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> sgn (g y) = 1", "apply (intro exI[where x=\"x-d1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - d1 < x \\<and>\n    (\\<forall>y>x - d1. y < x \\<longrightarrow> sgn (g y) = 1)", "using \\<open>d1>0\\<close> d1_def"], ["proof (prove)\nusing this:\n  0 < d1\n  \\<forall>h>0. h < d1 \\<longrightarrow> g x < g (x - h)\n\ngoal (1 subgoal):\n 1. x - d1 < x \\<and>\n    (\\<forall>y>x - d1. y < x \\<longrightarrow> sgn (g y) = 1)", "by (metis (no_types, hide_lams) add.commute add_uminus_conv_diff assms(2) diff_add_cancel\n            diff_zero less_diff_eq minus_diff_eq sgn_pos)"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "using \\<open>c<0\\<close>"], ["proof (prove)\nusing this:\n  (g has_sgnx 1) (at_left x)\n  c < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < 0 \\<Longrightarrow> (g has_sgnx 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "ultimately"], ["proof (chain)\npicking this:\n  0 < c \\<Longrightarrow> (g has_sgnx - 1) (at_left x)\n  c < 0 \\<Longrightarrow> (g has_sgnx 1) (at_left x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow> (g has_sgnx - 1) (at_left x)\n  c < 0 \\<Longrightarrow> (g has_sgnx 1) (at_left x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow> (g has_sgnx - 1) (at_left x)\n  c < 0 \\<Longrightarrow> (g has_sgnx 1) (at_left x)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "using sgn_real_def"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow> (g has_sgnx - 1) (at_left x)\n  c < 0 \\<Longrightarrow> (g has_sgnx 1) (at_left x)\n  c \\<noteq> 0\n  sgn ?a = (if ?a = 0 then 0 else if 0 < ?a then 1 else - 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn c) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn c) (at_left x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_derivative_at_right:\n  assumes g_deriv:\"(g has_field_derivative c) (at x)\" and \"g x=0\" and \"c\\<noteq>0\"\n  shows \"(g has_sgnx sgn c) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "have \"(g has_sgnx 1) (at_right x)\" when \"c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "obtain d2 where \"d2>0\" and d2_def:\"\\<forall>h>0. h < d2 \\<longrightarrow> g x < g (x + h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>0 < d2;\n         \\<forall>h>0. h < d2 \\<longrightarrow> g x < g (x + h)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_pos_inc_right[OF g_deriv \\<open>c>0\\<close>] \\<open>g x=0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>d>0. \\<forall>h>0. h < d \\<longrightarrow> g x < g (x + h)\n  g x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>0 < d2;\n         \\<forall>h>0. h < d2 \\<longrightarrow> g x < g (x + h)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < d2\n  \\<forall>h>0. h < d2 \\<longrightarrow> g x < g (x + h)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "have \"(g has_sgnx 1) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> sgn (g y) = 1", "apply (intro exI[where x=\"x+d2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < x + d2 \\<and>\n    (\\<forall>y>x. y < x + d2 \\<longrightarrow> sgn (g y) = 1)", "using \\<open>d2>0\\<close> d2_def"], ["proof (prove)\nusing this:\n  0 < d2\n  \\<forall>h>0. h < d2 \\<longrightarrow> g x < g (x + h)\n\ngoal (1 subgoal):\n 1. x < x + d2 \\<and>\n    (\\<forall>y>x. y < x + d2 \\<longrightarrow> sgn (g y) = 1)", "by (metis add.commute assms(2) diff_add_cancel diff_less_eq less_add_same_cancel1 sgn_pos)"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "using \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  (g has_sgnx 1) (at_right x)\n  0 < c\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_right x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow> (g has_sgnx 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "moreover"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow> (g has_sgnx 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "have \"(g has_sgnx -1) (at_right x)\" when \"c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "obtain d2 where \"d2>0\" and d2_def:\"\\<forall>h>0. h < d2 \\<longrightarrow> g x > g (x + h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>0 < d2;\n         \\<forall>h>0. h < d2 \\<longrightarrow> g (x + h) < g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_neg_dec_right[OF g_deriv \\<open>c<0\\<close>] \\<open>g x=0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>d>0. \\<forall>h>0. h < d \\<longrightarrow> g (x + h) < g x\n  g x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>0 < d2;\n         \\<forall>h>0. h < d2 \\<longrightarrow> g (x + h) < g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < d2\n  \\<forall>h>0. h < d2 \\<longrightarrow> g (x + h) < g x\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "have \"(g has_sgnx -1) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> sgn (g y) = - 1", "apply (intro exI[where x=\"x+d2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < x + d2 \\<and>\n    (\\<forall>y>x. y < x + d2 \\<longrightarrow> sgn (g y) = - 1)", "using \\<open>d2>0\\<close> d2_def"], ["proof (prove)\nusing this:\n  0 < d2\n  \\<forall>h>0. h < d2 \\<longrightarrow> g (x + h) < g x\n\ngoal (1 subgoal):\n 1. x < x + d2 \\<and>\n    (\\<forall>y>x. y < x + d2 \\<longrightarrow> sgn (g y) = - 1)", "by (metis (no_types, hide_lams) add.commute add.right_inverse add_uminus_conv_diff assms(2) \n          diff_add_cancel diff_less_eq sgn_neg)"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "using \\<open>c<0\\<close>"], ["proof (prove)\nusing this:\n  (g has_sgnx - 1) (at_right x)\n  c < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_right x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "ultimately"], ["proof (chain)\npicking this:\n  0 < c \\<Longrightarrow> (g has_sgnx 1) (at_right x)\n  c < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_right x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow> (g has_sgnx 1) (at_right x)\n  c < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_right x)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow> (g has_sgnx 1) (at_right x)\n  c < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_right x)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "using sgn_real_def"], ["proof (prove)\nusing this:\n  0 < c \\<Longrightarrow> (g has_sgnx 1) (at_right x)\n  c < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_right x)\n  c \\<noteq> 0\n  sgn ?a = (if ?a = 0 then 0 else if 0 < ?a then 1 else - 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn c) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn c) (at_right x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sgnx_split:\n  \"(f has_sgnx c) (at x) \\<longleftrightarrow> (f has_sgnx c) (at_left x) \\<and> (f has_sgnx c) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx c) (at x) =\n    ((f has_sgnx c) (at_left x) \\<and> (f has_sgnx c) (at_right x))", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at x. sgn (f x) = c) =\n    ((\\<forall>\\<^sub>F x in at_left x. sgn (f x) = c) \\<and>\n     (\\<forall>\\<^sub>F x in at_right x. sgn (f x) = c))", "using eventually_at_split"], ["proof (prove)\nusing this:\n  eventually ?P (at ?x) =\n  (eventually ?P (at_left ?x) \\<and> eventually ?P (at_right ?x))\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at x. sgn (f x) = c) =\n    ((\\<forall>\\<^sub>F x in at_left x. sgn (f x) = c) \\<and>\n     (\\<forall>\\<^sub>F x in at_right x. sgn (f x) = c))", "by auto"], ["", "lemma sgnx_at_top_IVT:\n  assumes \"sgnx (poly p) (at_right a) \\<noteq> sgnx (poly p) at_top\"\n  shows \"\\<exists>x>a. poly p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "using gt_ex[of a]"], ["proof (prove)\nusing this:\n  p = 0\n  \\<exists>y. a < y\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "by simp"], ["proof (state)\nthis:\n  \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "from poly_has_sgnx_values[OF this]"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "have \"(poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\"\n    \"(poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a) &&&\n    (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "have ?thesis when has_r:\"(poly p has_sgnx 1) (at_right a)\" \n      and has_top:\"(poly p has_sgnx -1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "obtain b where \"b>a\" \"poly p b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a' where \"a'>a\" and a'_def:\"\\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_r[unfolded has_sgnx_def eventually_at_right]"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a'\n  \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define b where \"b=(a+a')/2\""], ["proof (state)\nthis:\n  b = (a + a') / 2\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a<b\" \"b<a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b &&& b < a'", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < (a + a') / 2 &&& (a + a') / 2 < a'", "using \\<open>a'>a\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n\ngoal (1 subgoal):\n 1. a < (a + a') / 2 &&& (a + a') / 2 < a'", "by auto"], ["proof (state)\nthis:\n  a < b\n  b < a'\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  a < b\n  b < a'\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p b", "using a'_def[rule_format,OF \\<open>b>a\\<close> \\<open>b<a'\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p b) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p b", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p b = 0 then 0 else if 0 < poly p b then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p b", "by argo"], ["proof (state)\nthis:\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  a < b\n  b < a'\n  0 < poly p b", "show ?thesis"], ["proof (prove)\nusing this:\n  a < b\n  b < a'\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  a < b\n  b < a'\n  0 < poly p b\n  \\<lbrakk>a < ?b; 0 < poly p ?b\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < b\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  a < b\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "obtain c where \"c>b\" \"poly p c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain b' where b'_def:\"\\<forall>n\\<ge>b'. sgn (poly p n) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<ge>b'. sgn (poly p n) = - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using has_top[unfolded has_sgnx_def eventually_at_top_linorder]"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. sgn (poly p n) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<ge>b'. sgn (poly p n) = - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>b'. sgn (poly p n) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c=1+max b b'\""], ["proof (state)\nthis:\n  c = 1 + max b b'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"c>b\" \"c\\<ge>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < c &&& b' \\<le> c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b < 1 + max b b' &&& b' \\<le> 1 + max b b'", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. b < 1 + max b b' &&& b' \\<le> 1 + max b b'", "by auto"], ["proof (state)\nthis:\n  b < c\n  b' \\<le> c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  b < c\n  b' \\<le> c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p c < 0", "using b'_def[rule_format,OF \\<open>b'\\<le>c\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p c) = - 1\n\ngoal (1 subgoal):\n 1. poly p c < 0", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p c = 0 then 0 else if 0 < poly p c then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. poly p c < 0", "by argo"], ["proof (state)\nthis:\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  b < c\n  b' \\<le> c\n  poly p c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b < c\n  b' \\<le> c\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  b < c\n  b' \\<le> c\n  poly p c < 0\n  \\<lbrakk>b < ?c; poly p ?c < 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b < c\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  a < b\n  0 < poly p b\n  b < c\n  poly p c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a < b\n  0 < poly p b\n  b < c\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "using poly_IVT_neg[of b c p] not_less"], ["proof (prove)\nusing this:\n  a < b\n  0 < poly p b\n  b < c\n  poly p c < 0\n  \\<lbrakk>b < c; 0 < poly p b; poly p c < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>b. x < c \\<and> poly p x = 0\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x>a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "have ?thesis when has_r:\"(poly p has_sgnx -1) (at_right a)\" \n      and has_top:\"(poly p has_sgnx 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "obtain b where \"b>a\" \"poly p b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a' where \"a'>a\" and a'_def:\"\\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a.\n            y < a' \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_r[unfolded has_sgnx_def eventually_at_right]"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a.\n            y < a' \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a'\n  \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define b where \"b=(a+a')/2\""], ["proof (state)\nthis:\n  b = (a + a') / 2\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a<b\" \"b<a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b &&& b < a'", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < (a + a') / 2 &&& (a + a') / 2 < a'", "using \\<open>a'>a\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n\ngoal (1 subgoal):\n 1. a < (a + a') / 2 &&& (a + a') / 2 < a'", "by auto"], ["proof (state)\nthis:\n  a < b\n  b < a'\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  a < b\n  b < a'\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p b < 0", "using a'_def[rule_format,OF \\<open>b>a\\<close> \\<open>b<a'\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p b) = - 1\n\ngoal (1 subgoal):\n 1. poly p b < 0", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p b = 0 then 0 else if 0 < poly p b then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. poly p b < 0", "by argo"], ["proof (state)\nthis:\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a < b; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  a < b\n  b < a'\n  poly p b < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a < b\n  b < a'\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  a < b\n  b < a'\n  poly p b < 0\n  \\<lbrakk>a < ?b; poly p ?b < 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < b\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  a < b\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "obtain c where \"c>b\" \"poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain b' where b'_def:\"\\<forall>n\\<ge>b'. sgn (poly p n) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<ge>b'. sgn (poly p n) = 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using has_top[unfolded has_sgnx_def eventually_at_top_linorder]"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. sgn (poly p n) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<ge>b'. sgn (poly p n) = 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>b'. sgn (poly p n) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c=1+max b b'\""], ["proof (state)\nthis:\n  c = 1 + max b b'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"c>b\" \"c\\<ge>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < c &&& b' \\<le> c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b < 1 + max b b' &&& b' \\<le> 1 + max b b'", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. b < 1 + max b b' &&& b' \\<le> 1 + max b b'", "by auto"], ["proof (state)\nthis:\n  b < c\n  b' \\<le> c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  b < c\n  b' \\<le> c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p c", "using b'_def[rule_format,OF \\<open>b'\\<le>c\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p c) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p c", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p c = 0 then 0 else if 0 < poly p c then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p c", "by argo"], ["proof (state)\nthis:\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>b < c; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  b < c\n  b' \\<le> c\n  0 < poly p c", "show ?thesis"], ["proof (prove)\nusing this:\n  b < c\n  b' \\<le> c\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  b < c\n  b' \\<le> c\n  0 < poly p c\n  \\<lbrakk>b < ?c; 0 < poly p ?c\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b < c\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  a < b\n  poly p b < 0\n  b < c\n  0 < poly p c", "show ?thesis"], ["proof (prove)\nusing this:\n  a < b\n  poly p b < 0\n  b < c\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "using poly_IVT_pos[of b c p] not_less"], ["proof (prove)\nusing this:\n  a < b\n  poly p b < 0\n  b < c\n  0 < poly p c\n  \\<lbrakk>b < c; poly p b < 0; 0 < poly p c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>b. x < c \\<and> poly p x = 0\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x>a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "have ?thesis when \n    \"(poly p has_sgnx 1) (at_right a) \\<and> (poly p has_sgnx 1) at_top\n     \\<or> (poly p has_sgnx - 1) (at_right a) \\<and> (poly p has_sgnx -1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "have \"sgnx (poly p) (at_right a) = sgnx (poly p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly p) at_top", "using that has_sgnx_imp_sgnx"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_right a) \\<and> (poly p has_sgnx 1) at_top \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and> (poly p has_sgnx - 1) at_top\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly p) at_top", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly p) at_top\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) = sgnx (poly p) at_top", "have False"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = sgnx (poly p) at_top\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = sgnx (poly p) at_top\n  sgnx (poly p) (at_right a) \\<noteq> sgnx (poly p) at_top\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<and> (poly p has_sgnx 1) at_top \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) at_top \\<Longrightarrow>\n  \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n  (poly p has_sgnx 1) (at_right a) \\<and> (poly p has_sgnx 1) at_top \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) at_top \\<Longrightarrow>\n  \\<exists>x>a. poly p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) at_top\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. poly p x = 0\n  (poly p has_sgnx 1) (at_right a) \\<and> (poly p has_sgnx 1) at_top \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) at_top \\<Longrightarrow>\n  \\<exists>x>a. poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. poly p x = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>x>a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_at_left_at_right_IVT:\n  assumes \"sgnx (poly p) (at_right a) \\<noteq> sgnx (poly p) (at_left b)\" \"a<b\"\n  shows \"\\<exists>x. a<x \\<and> x<b \\<and> poly p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "using \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  a < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "by (auto intro:exI[where x=\"(a+b)/2\"])"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "from poly_has_sgnx_values[OF this]"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "have \"(poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\"\n    \"(poly p has_sgnx 1) (at_left b) \\<or> (poly p has_sgnx - 1) (at_left b)\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_right a) \\<or>\n    (poly p has_sgnx - 1) (at_right a) &&&\n    (poly p has_sgnx 1) (at_left b) \\<or> (poly p has_sgnx - 1) (at_left b)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) (at_left b) \\<or> (poly p has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "moreover"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) (at_left b) \\<or> (poly p has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "have ?thesis when has_r:\"(poly p has_sgnx 1) (at_right a)\" \n      and has_l:\"(poly p has_sgnx -1) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "obtain c where \"a<c\" \"c<b\" \"poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a' where \"a'>a\" and a'_def:\"\\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_r[unfolded has_sgnx_def eventually_at_right]"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a'\n  \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c=(a+min a' b)/2\""], ["proof (state)\nthis:\n  c = (a + min a' b) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a<c\" \"c<a'\" \"c<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < c &&& c < a' &&& c < b", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < (a + min a' b) / 2 &&&\n    (a + min a' b) / 2 < a' &&& (a + min a' b) / 2 < b", "using \\<open>a'>a\\<close> \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n  a < b\n\ngoal (1 subgoal):\n 1. a < (a + min a' b) / 2 &&&\n    (a + min a' b) / 2 < a' &&& (a + min a' b) / 2 < b", "by auto"], ["proof (state)\nthis:\n  a < c\n  c < a'\n  c < b\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  a < c\n  c < a'\n  c < b\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p c", "using a'_def[rule_format,OF \\<open>c>a\\<close> \\<open>c<a'\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p c) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p c", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p c = 0 then 0 else if 0 < poly p c then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p c", "by argo"], ["proof (state)\nthis:\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  a < c\n  c < a'\n  c < b\n  0 < poly p c", "show ?thesis"], ["proof (prove)\nusing this:\n  a < c\n  c < a'\n  c < b\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  a < c\n  c < a'\n  c < b\n  0 < poly p c\n  \\<lbrakk>a < ?c; ?c < b; 0 < poly p ?c\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < c\n  c < b\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "moreover"], ["proof (state)\nthis:\n  a < c\n  c < b\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "obtain d where \"c<d\"\"d<b\" \"poly p d<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain b' where \"b'<b\" and b'_def:\"\\<forall>y>b'. y < b \\<longrightarrow> sgn (poly p y) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y>b'.\n            y < b \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_l[unfolded has_sgnx_def eventually_at_left]"], ["proof (prove)\nusing this:\n  \\<exists>ba<b. \\<forall>y>ba. y < b \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y>b'.\n            y < b \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b' < b\n  \\<forall>y>b'. y < b \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define d where \"d=(b+max b' c)/2\""], ["proof (state)\nthis:\n  d = (b + max b' c) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"b'<d\" \"d<b\" \"d>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' < d &&& d < b &&& c < d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b' < (b + max b' c) / 2 &&&\n    (b + max b' c) / 2 < b &&& c < (b + max b' c) / 2", "using \\<open>b>b'\\<close> \\<open>b>c\\<close>"], ["proof (prove)\nusing this:\n  b' < b\n  c < b\n\ngoal (1 subgoal):\n 1. b' < (b + max b' c) / 2 &&&\n    (b + max b' c) / 2 < b &&& c < (b + max b' c) / 2", "by auto"], ["proof (state)\nthis:\n  b' < d\n  d < b\n  c < d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  b' < d\n  d < b\n  c < d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p d<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p d < 0", "using b'_def[rule_format, OF \\<open>b'<d\\<close> \\<open>d<b\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p d) = - 1\n\ngoal (1 subgoal):\n 1. poly p d < 0", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p d = 0 then 0 else if 0 < poly p d then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. poly p d < 0", "by argo"], ["proof (state)\nthis:\n  poly p d < 0\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; poly p d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  b' < d\n  d < b\n  c < d\n  poly p d < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b' < d\n  d < b\n  c < d\n  poly p d < 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  b' < d\n  d < b\n  c < d\n  poly p d < 0\n  \\<lbrakk>c < ?d; ?d < b; poly p ?d < 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < d\n  d < b\n  poly p d < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  a < c\n  c < b\n  0 < poly p c\n  c < d\n  d < b\n  poly p d < 0", "obtain x where \"c<x\" \"x<d\" \"poly p x=0\""], ["proof (prove)\nusing this:\n  a < c\n  c < b\n  0 < poly p c\n  c < d\n  d < b\n  poly p d < 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>c < x; x < d; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using poly_IVT_neg[of c d p]"], ["proof (prove)\nusing this:\n  a < c\n  c < b\n  0 < poly p c\n  c < d\n  d < b\n  poly p d < 0\n  \\<lbrakk>c < d; 0 < poly p c; poly p d < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>c. x < d \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>c < x; x < d; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c < x\n  x < d\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "then"], ["proof (chain)\npicking this:\n  c < x\n  x < d\n  poly p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c < x\n  x < d\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "using \\<open>c>a\\<close> \\<open>d<b\\<close>"], ["proof (prove)\nusing this:\n  c < x\n  x < d\n  poly p x = 0\n  a < c\n  d < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "by (auto intro: exI[where x=x])"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "have ?thesis when has_r:\"(poly p has_sgnx -1) (at_right a)\" \n      and has_l:\"(poly p has_sgnx 1) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "obtain c where \"a<c\" \"c<b\" \"poly p c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a' where \"a'>a\" and a'_def:\"\\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a.\n            y < a' \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_r[unfolded has_sgnx_def eventually_at_right]"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y>a.\n            y < a' \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a'\n  \\<forall>y>a. y < a' \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c=(a+min a' b)/2\""], ["proof (state)\nthis:\n  c = (a + min a' b) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a<c\" \"c<a'\" \"c<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < c &&& c < a' &&& c < b", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < (a + min a' b) / 2 &&&\n    (a + min a' b) / 2 < a' &&& (a + min a' b) / 2 < b", "using \\<open>a'>a\\<close> \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n  a < b\n\ngoal (1 subgoal):\n 1. a < (a + min a' b) / 2 &&&\n    (a + min a' b) / 2 < a' &&& (a + min a' b) / 2 < b", "by auto"], ["proof (state)\nthis:\n  a < c\n  c < a'\n  c < b\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  a < c\n  c < a'\n  c < b\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p c < 0", "using a'_def[rule_format,OF \\<open>c>a\\<close> \\<open>c<a'\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p c) = - 1\n\ngoal (1 subgoal):\n 1. poly p c < 0", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p c = 0 then 0 else if 0 < poly p c then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. poly p c < 0", "by argo"], ["proof (state)\nthis:\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>a < c; c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  a < c\n  c < a'\n  c < b\n  poly p c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a < c\n  c < a'\n  c < b\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  a < c\n  c < a'\n  c < b\n  poly p c < 0\n  \\<lbrakk>a < ?c; ?c < b; poly p ?c < 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < c\n  c < b\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "moreover"], ["proof (state)\nthis:\n  a < c\n  c < b\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "obtain d where \"c<d\"\"d<b\" \"poly p d>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain b' where \"b'<b\" and b'_def:\"\\<forall>y>b'. y < b \\<longrightarrow> sgn (poly p y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y>b'. y < b \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_l[unfolded has_sgnx_def eventually_at_left]"], ["proof (prove)\nusing this:\n  \\<exists>ba<b. \\<forall>y>ba. y < b \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y>b'. y < b \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b' < b\n  \\<forall>y>b'. y < b \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define d where \"d=(b+max b' c)/2\""], ["proof (state)\nthis:\n  d = (b + max b' c) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"b'<d\" \"d<b\" \"d>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' < d &&& d < b &&& c < d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b' < (b + max b' c) / 2 &&&\n    (b + max b' c) / 2 < b &&& c < (b + max b' c) / 2", "using \\<open>b>b'\\<close> \\<open>b>c\\<close>"], ["proof (prove)\nusing this:\n  b' < b\n  c < b\n\ngoal (1 subgoal):\n 1. b' < (b + max b' c) / 2 &&&\n    (b + max b' c) / 2 < b &&& c < (b + max b' c) / 2", "by auto"], ["proof (state)\nthis:\n  b' < d\n  d < b\n  c < d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  b' < d\n  d < b\n  c < d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p d>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p d", "using b'_def[rule_format, OF \\<open>b'<d\\<close> \\<open>d<b\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p d) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p d", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p d = 0 then 0 else if 0 < poly p d then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p d", "by argo"], ["proof (state)\nthis:\n  0 < poly p d\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c < d; d < b; 0 < poly p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  b' < d\n  d < b\n  c < d\n  0 < poly p d", "show ?thesis"], ["proof (prove)\nusing this:\n  b' < d\n  d < b\n  c < d\n  0 < poly p d\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  b' < d\n  d < b\n  c < d\n  0 < poly p d\n  \\<lbrakk>c < ?d; ?d < b; 0 < poly p ?d\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < d\n  d < b\n  0 < poly p d\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  a < c\n  c < b\n  poly p c < 0\n  c < d\n  d < b\n  0 < poly p d", "obtain x where \"c<x\" \"x<d\" \"poly p x=0\""], ["proof (prove)\nusing this:\n  a < c\n  c < b\n  poly p c < 0\n  c < d\n  d < b\n  0 < poly p d\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>c < x; x < d; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using poly_IVT_pos[of c d p]"], ["proof (prove)\nusing this:\n  a < c\n  c < b\n  poly p c < 0\n  c < d\n  d < b\n  0 < poly p d\n  \\<lbrakk>c < d; poly p c < 0; 0 < poly p d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>c. x < d \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>c < x; x < d; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c < x\n  x < d\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "then"], ["proof (chain)\npicking this:\n  c < x\n  x < d\n  poly p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c < x\n  x < d\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "using \\<open>c>a\\<close> \\<open>d<b\\<close>"], ["proof (prove)\nusing this:\n  c < x\n  x < d\n  poly p x = 0\n  a < c\n  d < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "by (auto intro: exI[where x=x])"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "have ?thesis when \n    \"(poly p has_sgnx 1) (at_right a) \\<and> (poly p has_sgnx 1) (at_left b)\n     \\<or> (poly p has_sgnx - 1) (at_right a) \\<and> (poly p has_sgnx -1) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "have \"sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)", "using that has_sgnx_imp_sgnx"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_right a) \\<and>\n  (poly p has_sgnx 1) (at_left b) \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) (at_left b)\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)", "have False"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = sgnx (poly p) (at_left b)\n  sgnx (poly p) (at_right a) \\<noteq> sgnx (poly p) (at_left b)\n  a < b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_right a) \\<and>\n  (poly p has_sgnx 1) (at_left b) \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) (at_left b) \\<Longrightarrow>\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) (at_left b) \\<or> (poly p has_sgnx - 1) (at_left b)\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n  (poly p has_sgnx 1) (at_right a) \\<and>\n  (poly p has_sgnx 1) (at_left b) \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) (at_left b) \\<Longrightarrow>\n  \\<exists>x>a. x < b \\<and> poly p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_right a) \\<or> (poly p has_sgnx - 1) (at_right a)\n  (poly p has_sgnx 1) (at_left b) \\<or> (poly p has_sgnx - 1) (at_left b)\n  \\<lbrakk>(poly p has_sgnx 1) (at_right a);\n   (poly p has_sgnx - 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n  \\<lbrakk>(poly p has_sgnx - 1) (at_right a);\n   (poly p has_sgnx 1) (at_left b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly p x = 0\n  (poly p has_sgnx 1) (at_right a) \\<and>\n  (poly p has_sgnx 1) (at_left b) \\<or>\n  (poly p has_sgnx - 1) (at_right a) \\<and>\n  (poly p has_sgnx - 1) (at_left b) \\<Longrightarrow>\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> poly p x = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_at_bot_IVT:\n  assumes \"sgnx (poly p) (at_left a) \\<noteq> sgnx (poly p) at_bot\"\n  shows \"\\<exists>x<a. poly p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n 2. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "using lt_ex[of a]"], ["proof (prove)\nusing this:\n  p = 0\n  \\<exists>y. y < a\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "by simp"], ["proof (state)\nthis:\n  \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "from poly_has_sgnx_values[OF this]"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "have \"(poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\"\n    \"(poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx 1) (at_left a) \\<or>\n    (poly p has_sgnx - 1) (at_left a) &&&\n    (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "have ?thesis when has_l:\"(poly p has_sgnx 1) (at_left a)\" \n      and has_bot:\"(poly p has_sgnx -1) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "obtain b where \"b<a\" \"poly p b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a' where \"a'<a\" and a'_def:\"\\<forall>y>a'. y < a \\<longrightarrow> sgn (poly p y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' < a;\n         \\<forall>y>a'. y < a \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_l[unfolded has_sgnx_def eventually_at_left]"], ["proof (prove)\nusing this:\n  \\<exists>b<a. \\<forall>y>b. y < a \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' < a;\n         \\<forall>y>a'. y < a \\<longrightarrow> sgn (poly p y) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a' < a\n  \\<forall>y>a'. y < a \\<longrightarrow> sgn (poly p y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define b where \"b=(a+a')/2\""], ["proof (state)\nthis:\n  b = (a + a') / 2\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a>b\" \"b>a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a &&& a' < b", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + a') / 2 < a &&& a' < (a + a') / 2", "using \\<open>a'<a\\<close>"], ["proof (prove)\nusing this:\n  a' < a\n\ngoal (1 subgoal):\n 1. (a + a') / 2 < a &&& a' < (a + a') / 2", "by auto"], ["proof (state)\nthis:\n  b < a\n  a' < b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  b < a\n  a' < b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p b", "using a'_def[rule_format,OF \\<open>b>a'\\<close> \\<open>b<a\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p b) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p b", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p b = 0 then 0 else if 0 < poly p b then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p b", "by argo"], ["proof (state)\nthis:\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; 0 < poly p b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  b < a\n  a' < b\n  0 < poly p b", "show ?thesis"], ["proof (prove)\nusing this:\n  b < a\n  a' < b\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  b < a\n  a' < b\n  0 < poly p b\n  \\<lbrakk>?b < a; 0 < poly p ?b\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b < a\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  b < a\n  0 < poly p b\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "obtain c where \"c<b\" \"poly p c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain b' where b'_def:\"\\<forall>n\\<le>b'. sgn (poly p n) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<le>b'. sgn (poly p n) = - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using has_bot[unfolded has_sgnx_def eventually_at_bot_linorder]"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<le>N. sgn (poly p n) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<le>b'. sgn (poly p n) = - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<le>b'. sgn (poly p n) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c=min b b'- 1\""], ["proof (state)\nthis:\n  c = min b b' - 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"c<b\" \"c\\<le>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < b &&& c \\<le> b'", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min b b' - 1 < b &&& min b b' - 1 \\<le> b'", "using \\<open>b<a\\<close>"], ["proof (prove)\nusing this:\n  b < a\n\ngoal (1 subgoal):\n 1. min b b' - 1 < b &&& min b b' - 1 \\<le> b'", "by auto"], ["proof (state)\nthis:\n  c < b\n  c \\<le> b'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  c < b\n  c \\<le> b'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p c < 0", "using b'_def[rule_format,OF \\<open>b'\\<ge>c\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p c) = - 1\n\ngoal (1 subgoal):\n 1. poly p c < 0", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p c = 0 then 0 else if 0 < poly p c then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. poly p c < 0", "by argo"], ["proof (state)\nthis:\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; poly p c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  c < b\n  c \\<le> b'\n  poly p c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c < b\n  c \\<le> b'\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  c < b\n  c \\<le> b'\n  poly p c < 0\n  \\<lbrakk>?c < b; poly p ?c < 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < b\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  b < a\n  0 < poly p b\n  c < b\n  poly p c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b < a\n  0 < poly p b\n  c < b\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "using poly_IVT_pos[of c b p]"], ["proof (prove)\nusing this:\n  b < a\n  0 < poly p b\n  c < b\n  poly p c < 0\n  \\<lbrakk>c < b; poly p c < 0; 0 < poly p b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>c. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "using not_less"], ["proof (prove)\nusing this:\n  b < a\n  0 < poly p b\n  c < b\n  poly p c < 0\n  \\<lbrakk>c < b; poly p c < 0; 0 < poly p b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>c. x < b \\<and> poly p x = 0\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x<a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx 1) (at_left a);\n   (poly p has_sgnx - 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx 1) (at_left a);\n   (poly p has_sgnx - 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "have ?thesis when has_l:\"(poly p has_sgnx -1) (at_left a)\" \n      and has_bot:\"(poly p has_sgnx 1) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "obtain b where \"b<a\" \"poly p b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a' where \"a'<a\" and a'_def:\"\\<forall>y>a'. y < a \\<longrightarrow> sgn (poly p y) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' < a;\n         \\<forall>y>a'.\n            y < a \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_l[unfolded has_sgnx_def eventually_at_left]"], ["proof (prove)\nusing this:\n  \\<exists>b<a. \\<forall>y>b. y < a \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' < a;\n         \\<forall>y>a'.\n            y < a \\<longrightarrow> sgn (poly p y) = - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a' < a\n  \\<forall>y>a'. y < a \\<longrightarrow> sgn (poly p y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define b where \"b=(a+a')/2\""], ["proof (state)\nthis:\n  b = (a + a') / 2\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"a>b\" \"b>a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < a &&& a' < b", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + a') / 2 < a &&& a' < (a + a') / 2", "using \\<open>a'<a\\<close>"], ["proof (prove)\nusing this:\n  a' < a\n\ngoal (1 subgoal):\n 1. (a + a') / 2 < a &&& a' < (a + a') / 2", "by auto"], ["proof (state)\nthis:\n  b < a\n  a' < b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  b < a\n  a' < b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p b < 0", "using a'_def[rule_format,OF \\<open>b>a'\\<close> \\<open>b<a\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p b) = - 1\n\ngoal (1 subgoal):\n 1. poly p b < 0", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p b = 0 then 0 else if 0 < poly p b then 1 else - 1) = - 1\n\ngoal (1 subgoal):\n 1. poly p b < 0", "by argo"], ["proof (state)\nthis:\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b < a; poly p b < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  b < a\n  a' < b\n  poly p b < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b < a\n  a' < b\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  b < a\n  a' < b\n  poly p b < 0\n  \\<lbrakk>?b < a; poly p ?b < 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b < a\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  b < a\n  poly p b < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "obtain c where \"c<b\" \"poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain b' where b'_def:\"\\<forall>n\\<le>b'. sgn (poly p n) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<le>b'. sgn (poly p n) = 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using has_bot[unfolded has_sgnx_def eventually_at_bot_linorder]"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<le>N. sgn (poly p n) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<forall>n\\<le>b'. sgn (poly p n) = 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<le>b'. sgn (poly p n) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c=min b b'- 1\""], ["proof (state)\nthis:\n  c = min b b' - 1\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"c<b\" \"c\\<le>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < b &&& c \\<le> b'", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min b b' - 1 < b &&& min b b' - 1 \\<le> b'", "using \\<open>b<a\\<close>"], ["proof (prove)\nusing this:\n  b < a\n\ngoal (1 subgoal):\n 1. min b b' - 1 < b &&& min b b' - 1 \\<le> b'", "by auto"], ["proof (state)\nthis:\n  c < b\n  c \\<le> b'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  c < b\n  c \\<le> b'\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p c", "using b'_def[rule_format,OF \\<open>b'\\<ge>c\\<close>]"], ["proof (prove)\nusing this:\n  sgn (poly p c) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p c", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  (if poly p c = 0 then 0 else if 0 < poly p c then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < poly p c", "by argo"], ["proof (state)\nthis:\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c < b; 0 < poly p c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  c < b\n  c \\<le> b'\n  0 < poly p c", "show ?thesis"], ["proof (prove)\nusing this:\n  c < b\n  c \\<le> b'\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  c < b\n  c \\<le> b'\n  0 < poly p c\n  \\<lbrakk>?c < b; 0 < poly p ?c\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < b\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  b < a\n  poly p b < 0\n  c < b\n  0 < poly p c", "show ?thesis"], ["proof (prove)\nusing this:\n  b < a\n  poly p b < 0\n  c < b\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "using poly_IVT_neg[of c b p]"], ["proof (prove)\nusing this:\n  b < a\n  poly p b < 0\n  c < b\n  0 < poly p c\n  \\<lbrakk>c < b; 0 < poly p c; poly p b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>c. x < b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "using not_less"], ["proof (prove)\nusing this:\n  b < a\n  poly p b < 0\n  c < b\n  0 < poly p c\n  \\<lbrakk>c < b; 0 < poly p c; poly p b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>c. x < b \\<and> poly p x = 0\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x<a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - 1) (at_left a);\n   (poly p has_sgnx 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - 1) (at_left a);\n   (poly p has_sgnx 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "have ?thesis when \n    \"(poly p has_sgnx 1) (at_left a) \\<and> (poly p has_sgnx 1) at_bot\n     \\<or> (poly p has_sgnx - 1) (at_left a) \\<and> (poly p has_sgnx -1) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "have \"sgnx (poly p) (at_left a) = sgnx (poly p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = sgnx (poly p) at_bot", "using that has_sgnx_imp_sgnx"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_left a) \\<and> (poly p has_sgnx 1) at_bot \\<or>\n  (poly p has_sgnx - 1) (at_left a) \\<and> (poly p has_sgnx - 1) at_bot\n  \\<lbrakk>(?f has_sgnx ?c) ?F; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> sgnx ?f ?F = ?c\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left a) = sgnx (poly p) at_bot", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left a) = sgnx (poly p) at_bot\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left a) = sgnx (poly p) at_bot", "have False"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) = sgnx (poly p) at_bot\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left a) = sgnx (poly p) at_bot\n  sgnx (poly p) (at_left a) \\<noteq> sgnx (poly p) at_bot\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x<a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly p has_sgnx 1) (at_left a) \\<and> (poly p has_sgnx 1) at_bot \\<or>\n  (poly p has_sgnx - 1) (at_left a) \\<and>\n  (poly p has_sgnx - 1) at_bot \\<Longrightarrow>\n  \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> \\<exists>x<a. poly p x = 0", "ultimately"], ["proof (chain)\npicking this:\n  (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n  \\<lbrakk>(poly p has_sgnx 1) (at_left a);\n   (poly p has_sgnx - 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n  \\<lbrakk>(poly p has_sgnx - 1) (at_left a);\n   (poly p has_sgnx 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n  (poly p has_sgnx 1) (at_left a) \\<and> (poly p has_sgnx 1) at_bot \\<or>\n  (poly p has_sgnx - 1) (at_left a) \\<and>\n  (poly p has_sgnx - 1) at_bot \\<Longrightarrow>\n  \\<exists>x<a. poly p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p has_sgnx 1) (at_left a) \\<or> (poly p has_sgnx - 1) (at_left a)\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n  \\<lbrakk>(poly p has_sgnx 1) (at_left a);\n   (poly p has_sgnx - 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n  \\<lbrakk>(poly p has_sgnx - 1) (at_left a);\n   (poly p has_sgnx 1) at_bot\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<a. poly p x = 0\n  (poly p has_sgnx 1) (at_left a) \\<and> (poly p has_sgnx 1) at_bot \\<or>\n  (poly p has_sgnx - 1) (at_left a) \\<and>\n  (poly p has_sgnx - 1) at_bot \\<Longrightarrow>\n  \\<exists>x<a. poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x<a. poly p x = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>x<a. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgnx_poly_nz:\n  assumes \"poly p x\\<noteq>0\"\n  shows \"sgnx (poly p) (at_left x) = sgn (poly p x)\"\n        \"sgnx (poly p) (at_right x) = sgn (poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left x) = sgn (poly p x) &&&\n    sgnx (poly p) (at_right x) = sgn (poly p x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sgnx (poly p) (at_left x) = sgn (poly p x)\n 2. sgnx (poly p) (at_right x) = sgn (poly p x)", "have \"(poly p has_sgnx sgn(poly p x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn (poly p x)) (at x)", "apply (rule tendsto_nonzero_has_sgnx)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly p \\<midarrow>x\\<rightarrow> poly p x\n 2. poly p x \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly p \\<midarrow>x\\<rightarrow> poly p x\n 2. poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx sgn (poly p x)) (at x)\n\ngoal (2 subgoals):\n 1. sgnx (poly p) (at_left x) = sgn (poly p x)\n 2. sgnx (poly p) (at_right x) = sgn (poly p x)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx sgn (poly p x)) (at x)", "show \"sgnx (poly p) (at_left x) = sgn (poly p x)\"\n        \"sgnx (poly p) (at_right x) = sgn (poly p x)\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx sgn (poly p x)) (at x)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left x) = sgn (poly p x) &&&\n    sgnx (poly p) (at_right x) = sgn (poly p x)", "unfolding has_sgnx_split"], ["proof (prove)\nusing this:\n  (poly p has_sgnx sgn (poly p x)) (at_left x) \\<and>\n  (poly p has_sgnx sgn (poly p x)) (at_right x)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left x) = sgn (poly p x) &&&\n    sgnx (poly p) (at_right x) = sgn (poly p x)", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left x) = sgn (poly p x)\n  sgnx (poly p) (at_right x) = sgn (poly p x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite predicate segments over an interval\\<close>"], ["", "inductive finite_Psegments::\"(real \\<Rightarrow> bool) \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" for P where\n  emptyI: \"a\\<ge>b \\<Longrightarrow> finite_Psegments P a b\"|\n  insertI_1: \"\\<lbrakk>s\\<in>{a..<b};s=a\\<or>P s;\\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s\\<rbrakk> \n        \\<Longrightarrow> finite_Psegments P a b\"|\n  insertI_2: \"\\<lbrakk>s\\<in>{a..<b};s=a\\<or>P s;(\\<forall>t\\<in>{s<..<b}. \\<not>P t);finite_Psegments P a s\\<rbrakk> \n        \\<Longrightarrow> finite_Psegments P a b\""], ["", "lemma finite_Psegments_pos_linear:\n  assumes \"finite_Psegments P (b*lb+c) (b*ub+c) \" and \"b>0\"\n  shows \"finite_Psegments (P o (\\<lambda>t. b*t+c)) lb ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) lb ub", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) lb ub", "have [simp]:\"b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "using \\<open>b>0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) lb ub", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) lb ub", "proof (rule finite_Psegments.induct[OF assms(1),\n        of \"\\<lambda>lb' ub'. finite_Psegments (P o (\\<lambda>t. b*t+c)) ((lb'-c)/b) ((ub'-c)/b)\",simplified])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       ba \\<le> a \\<Longrightarrow>\n       finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n        ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 3. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "(*really weird application of the induction rule, is there an alternative?*)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       ba \\<le> a \\<Longrightarrow>\n       finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n        ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 3. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "fix lb ub f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       ba \\<le> a \\<Longrightarrow>\n       finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n        ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 3. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "assume \"(lb::real)\\<le>ub\""], ["proof (state)\nthis:\n  lb \\<le> ub\n\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       ba \\<le> a \\<Longrightarrow>\n       finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n        ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 3. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "then"], ["proof (chain)\npicking this:\n  lb \\<le> ub", "have \"(lb - c) / b \\<le> (ub - c) / b\""], ["proof (prove)\nusing this:\n  lb \\<le> ub\n\ngoal (1 subgoal):\n 1. (lb - c) / b \\<le> (ub - c) / b", "using \\<open>b>0\\<close>"], ["proof (prove)\nusing this:\n  lb \\<le> ub\n  0 < b\n\ngoal (1 subgoal):\n 1. (lb - c) / b \\<le> (ub - c) / b", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (lb - c) / b \\<le> (ub - c) / b\n\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       ba \\<le> a \\<Longrightarrow>\n       finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n        ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 3. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "then"], ["proof (chain)\npicking this:\n  (lb - c) / b \\<le> (ub - c) / b", "show \"finite_Psegments (f \\<circ> (\\<lambda>t. b * t + c)) ((ub - c) / b) ((lb - c) / b)\""], ["proof (prove)\nusing this:\n  (lb - c) / b \\<le> (ub - c) / b\n\ngoal (1 subgoal):\n 1. finite_Psegments (f \\<circ> (\\<lambda>t. b * t + c)) ((ub - c) / b)\n     ((lb - c) / b)", "by (rule finite_Psegments.emptyI)"], ["proof (state)\nthis:\n  finite_Psegments (f \\<circ> (\\<lambda>t. b * t + c)) ((ub - c) / b)\n   ((lb - c) / b)\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "fix s lb ub P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "assume asm: \"lb \\<le> s \\<and> s < ub\" \n       \"\\<forall>t\\<in>{s<..<ub}. P t\" \n       \"finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b) ((s - c) / b)\"\n       \"s = lb \\<or> P s\""], ["proof (state)\nthis:\n  lb \\<le> s \\<and> s < ub\n  \\<forall>t\\<in>{s<..<ub}. P t\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n   ((s - c) / b)\n  s = lb \\<or> P s\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)\n 2. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "show \"finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b) ((ub - c) / b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n     ((ub - c) / b)", "apply (rule finite_Psegments.insertI_1[of \"(s-c)/b\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (s - c) / b \\<in> {(lb - c) / b..<(ub - c) / b}\n 2. (s - c) / b = (lb - c) / b \\<or>\n    (P \\<circ> (\\<lambda>t. b * t + c)) ((s - c) / b)\n 3. \\<forall>t\\<in>{(s - c) / b<..<(ub - c) / b}.\n       (P \\<circ> (\\<lambda>t. b * t + c)) t\n 4. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n     ((s - c) / b)", "using asm \\<open>b>0\\<close>"], ["proof (prove)\nusing this:\n  lb \\<le> s \\<and> s < ub\n  \\<forall>t\\<in>{s<..<ub}. P t\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n   ((s - c) / b)\n  s = lb \\<or> P s\n  0 < b\n\ngoal (4 subgoals):\n 1. (s - c) / b \\<in> {(lb - c) / b..<(ub - c) / b}\n 2. (s - c) / b = (lb - c) / b \\<or>\n    (P \\<circ> (\\<lambda>t. b * t + c)) ((s - c) / b)\n 3. \\<forall>t\\<in>{(s - c) / b<..<(ub - c) / b}.\n       (P \\<circ> (\\<lambda>t. b * t + c)) t\n 4. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n     ((s - c) / b)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n   ((ub - c) / b)\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "fix s lb ub P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "assume asm: \"lb \\<le> s \\<and> s < ub\" \n       \"\\<forall>t\\<in>{s<..<ub}. \\<not> P t\" \n       \"finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b) ((s - c) / b)\" \n       \"s=lb \\<or> P s\""], ["proof (state)\nthis:\n  lb \\<le> s \\<and> s < ub\n  \\<forall>t\\<in>{s<..<ub}. \\<not> P t\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n   ((s - c) / b)\n  s = lb \\<or> P s\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>a \\<le> s \\<and> s < ba; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n         ((s - c) / b)\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments\n                          (P \\<circ> (\\<lambda>t. b * t + c)) ((a - c) / b)\n                          ((ba - c) / b)", "show \"finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b) ((ub - c) / b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n     ((ub - c) / b)", "apply (rule finite_Psegments.insertI_2[of \"(s-c)/b\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (s - c) / b \\<in> {(lb - c) / b..<(ub - c) / b}\n 2. (s - c) / b = (lb - c) / b \\<or>\n    (P \\<circ> (\\<lambda>t. b * t + c)) ((s - c) / b)\n 3. \\<forall>t\\<in>{(s - c) / b<..<(ub - c) / b}.\n       \\<not> (P \\<circ> (\\<lambda>t. b * t + c)) t\n 4. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n     ((s - c) / b)", "using asm \\<open>b>0\\<close>"], ["proof (prove)\nusing this:\n  lb \\<le> s \\<and> s < ub\n  \\<forall>t\\<in>{s<..<ub}. \\<not> P t\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n   ((s - c) / b)\n  s = lb \\<or> P s\n  0 < b\n\ngoal (4 subgoals):\n 1. (s - c) / b \\<in> {(lb - c) / b..<(ub - c) / b}\n 2. (s - c) / b = (lb - c) / b \\<or>\n    (P \\<circ> (\\<lambda>t. b * t + c)) ((s - c) / b)\n 3. \\<forall>t\\<in>{(s - c) / b<..<(ub - c) / b}.\n       \\<not> (P \\<circ> (\\<lambda>t. b * t + c)) t\n 4. finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n     ((s - c) / b)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) ((lb - c) / b)\n   ((ub - c) / b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments (P \\<circ> (\\<lambda>t. b * t + c)) lb ub\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_Psegments_congE:\n  assumes \"finite_Psegments Q lb ub\" \n    \"\\<And>t. \\<lbrakk>lb<t;t<ub\\<rbrakk> \\<Longrightarrow> Q t \\<longleftrightarrow> P t \"\n  shows \"finite_Psegments P lb ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P lb ub", "using assms"], ["proof (prove)\nusing this:\n  finite_Psegments Q lb ub\n  \\<lbrakk>lb < ?t; ?t < ub\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. finite_Psegments P lb ub", "proof (induct rule:finite_Psegments.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<le> a;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 3. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "case (emptyI a b)"], ["proof (state)\nthis:\n  b \\<le> a\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<le> a;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 3. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "then"], ["proof (chain)\npicking this:\n  b \\<le> a\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t", "show ?case"], ["proof (prove)\nusing this:\n  b \\<le> a\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using finite_Psegments.emptyI"], ["proof (prove)\nusing this:\n  b \\<le> a\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n  ?b \\<le> ?a \\<Longrightarrow> finite_Psegments ?P ?a ?b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "case (insertI_1 s a b)"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  s = a \\<or> Q s\n  \\<forall>t\\<in>{s<..<b}. Q t\n  finite_Psegments Q a s\n  (\\<And>t.\n      \\<lbrakk>a < t; t < s\\<rbrakk>\n      \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n  finite_Psegments P a s\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "proof (rule finite_Psegments.insertI_1[of s])"], ["proof (state)\ngoal (4 subgoals):\n 1. s \\<in> {a..<b}\n 2. s = a \\<or> P s\n 3. \\<forall>t\\<in>{s<..<b}. P t\n 4. finite_Psegments P a s", "have \"P s\" when \"s\\<noteq>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P s", "have \"s\\<in>{a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a<..<b}", "using \\<open>s \\<in> {a..<b}\\<close> that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  s \\<noteq> a\n\ngoal (1 subgoal):\n 1. s \\<in> {a<..<b}", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. P s", "then"], ["proof (chain)\npicking this:\n  s \\<in> {a<..<b}", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. P s", "using insertI_1"], ["proof (prove)\nusing this:\n  s \\<in> {a<..<b}\n  s \\<in> {a..<b}\n  s = a \\<or> Q s\n  \\<forall>t\\<in>{s<..<b}. Q t\n  finite_Psegments Q a s\n  (\\<And>t.\n      \\<lbrakk>a < t; t < s\\<rbrakk>\n      \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n  finite_Psegments P a s\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. P s", "by auto"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> a \\<Longrightarrow> P s\n\ngoal (4 subgoals):\n 1. s \\<in> {a..<b}\n 2. s = a \\<or> P s\n 3. \\<forall>t\\<in>{s<..<b}. P t\n 4. finite_Psegments P a s", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> a \\<Longrightarrow> P s", "show \"s = a \\<or> P s\""], ["proof (prove)\nusing this:\n  s \\<noteq> a \\<Longrightarrow> P s\n\ngoal (1 subgoal):\n 1. s = a \\<or> P s", "by auto"], ["proof (state)\nthis:\n  s = a \\<or> P s\n\ngoal (3 subgoals):\n 1. s \\<in> {a..<b}\n 2. \\<forall>t\\<in>{s<..<b}. P t\n 3. finite_Psegments P a s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. s \\<in> {a..<b}\n 2. \\<forall>t\\<in>{s<..<b}. P t\n 3. finite_Psegments P a s", "show \"s \\<in> {a..<b}\" \" \\<forall>t\\<in>{s<..<b}. P t\" \"finite_Psegments P a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a..<b} &&&\n    \\<forall>t\\<in>{s<..<b}. P t &&& finite_Psegments P a s", "using insertI_1"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  s = a \\<or> Q s\n  \\<forall>t\\<in>{s<..<b}. Q t\n  finite_Psegments Q a s\n  (\\<And>t.\n      \\<lbrakk>a < t; t < s\\<rbrakk>\n      \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n  finite_Psegments P a s\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. s \\<in> {a..<b} &&&\n    \\<forall>t\\<in>{s<..<b}. P t &&& finite_Psegments P a s", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. P t\n  finite_Psegments P a s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "case (insertI_2 s a b)"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  s = a \\<or> Q s\n  \\<forall>t\\<in>{s<..<b}. \\<not> Q t\n  finite_Psegments Q a s\n  (\\<And>t.\n      \\<lbrakk>a < t; t < s\\<rbrakk>\n      \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n  finite_Psegments P a s\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Q s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> Q t; finite_Psegments Q a s;\n        (\\<And>t.\n            \\<lbrakk>a < t; t < s\\<rbrakk>\n            \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n        finite_Psegments P a s;\n        \\<And>t.\n           \\<lbrakk>a < t; t < b\\<rbrakk>\n           \\<Longrightarrow> Q t = P t\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "proof (rule finite_Psegments.insertI_2[of s])"], ["proof (state)\ngoal (4 subgoals):\n 1. s \\<in> {a..<b}\n 2. s = a \\<or> P s\n 3. \\<forall>t\\<in>{s<..<b}. \\<not> P t\n 4. finite_Psegments P a s", "have \"P s\" when \"s\\<noteq>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P s", "have \"s\\<in>{a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a<..<b}", "using \\<open>s \\<in> {a..<b}\\<close> that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  s \\<noteq> a\n\ngoal (1 subgoal):\n 1. s \\<in> {a<..<b}", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. P s", "then"], ["proof (chain)\npicking this:\n  s \\<in> {a<..<b}", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. P s", "using insertI_2"], ["proof (prove)\nusing this:\n  s \\<in> {a<..<b}\n  s \\<in> {a..<b}\n  s = a \\<or> Q s\n  \\<forall>t\\<in>{s<..<b}. \\<not> Q t\n  finite_Psegments Q a s\n  (\\<And>t.\n      \\<lbrakk>a < t; t < s\\<rbrakk>\n      \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n  finite_Psegments P a s\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. P s", "by auto"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> a \\<Longrightarrow> P s\n\ngoal (4 subgoals):\n 1. s \\<in> {a..<b}\n 2. s = a \\<or> P s\n 3. \\<forall>t\\<in>{s<..<b}. \\<not> P t\n 4. finite_Psegments P a s", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> a \\<Longrightarrow> P s", "show \"s = a \\<or> P s\""], ["proof (prove)\nusing this:\n  s \\<noteq> a \\<Longrightarrow> P s\n\ngoal (1 subgoal):\n 1. s = a \\<or> P s", "by auto"], ["proof (state)\nthis:\n  s = a \\<or> P s\n\ngoal (3 subgoals):\n 1. s \\<in> {a..<b}\n 2. \\<forall>t\\<in>{s<..<b}. \\<not> P t\n 3. finite_Psegments P a s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. s \\<in> {a..<b}\n 2. \\<forall>t\\<in>{s<..<b}. \\<not> P t\n 3. finite_Psegments P a s", "show \"s \\<in> {a..<b}\" \" \\<forall>t\\<in>{s<..<b}. \\<not> P t\" \"finite_Psegments P a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a..<b} &&&\n    \\<forall>t\\<in>{s<..<b}. \\<not> P t &&& finite_Psegments P a s", "using insertI_2"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  s = a \\<or> Q s\n  \\<forall>t\\<in>{s<..<b}. \\<not> Q t\n  finite_Psegments Q a s\n  (\\<And>t.\n      \\<lbrakk>a < t; t < s\\<rbrakk>\n      \\<Longrightarrow> Q t = P t) \\<Longrightarrow>\n  finite_Psegments P a s\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> Q ?t = P ?t\n\ngoal (1 subgoal):\n 1. s \\<in> {a..<b} &&&\n    \\<forall>t\\<in>{s<..<b}. \\<not> P t &&& finite_Psegments P a s", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. \\<not> P t\n  finite_Psegments P a s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_Psegments_constI:\n  assumes \"\\<And>t. \\<lbrakk>a<t;t<b\\<rbrakk> \\<Longrightarrow> P t = c\"\n  shows \"finite_Psegments P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "have \"finite_Psegments (\\<lambda>_. c) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "have ?thesis when \"a\\<ge>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "using that finite_Psegments.emptyI"], ["proof (prove)\nusing this:\n  b \\<le> a\n  ?b \\<le> ?a \\<Longrightarrow> finite_Psegments ?P ?a ?b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "by auto"], ["proof (state)\nthis:\n  b \\<le> a \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "moreover"], ["proof (state)\nthis:\n  b \\<le> a \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "have ?thesis when \"a<b\" \"c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "apply (rule finite_Psegments.insertI_1[of a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. a \\<in> {a..<b}\n 2. a = a \\<or> c\n 3. \\<forall>t\\<in>{a<..<b}. c\n 4. finite_Psegments (\\<lambda>_. c) a a", "using that"], ["proof (prove)\nusing this:\n  a < b\n  c\n\ngoal (4 subgoals):\n 1. a \\<in> {a..<b}\n 2. a = a \\<or> c\n 3. \\<forall>t\\<in>{a<..<b}. c\n 4. finite_Psegments (\\<lambda>_. c) a a", "by (auto intro: finite_Psegments.emptyI)"], ["proof (state)\nthis:\n  \\<lbrakk>a < b; c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a < b; c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "have ?thesis when \"a<b\" \"\\<not>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "apply (rule finite_Psegments.insertI_2[of a])"], ["proof (prove)\ngoal (4 subgoals):\n 1. a \\<in> {a..<b}\n 2. a = a \\<or> c\n 3. \\<forall>t\\<in>{a<..<b}. \\<not> c\n 4. finite_Psegments (\\<lambda>_. c) a a", "using that"], ["proof (prove)\nusing this:\n  a < b\n  \\<not> c\n\ngoal (4 subgoals):\n 1. a \\<in> {a..<b}\n 2. a = a \\<or> c\n 3. \\<forall>t\\<in>{a<..<b}. \\<not> c\n 4. finite_Psegments (\\<lambda>_. c) a a", "by (auto intro: finite_Psegments.emptyI)"], ["proof (state)\nthis:\n  \\<lbrakk>a < b; \\<not> c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "ultimately"], ["proof (chain)\npicking this:\n  b \\<le> a \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n  \\<lbrakk>a < b; c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n  \\<lbrakk>a < b; \\<not> c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> a \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n  \\<lbrakk>a < b; c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n  \\<lbrakk>a < b; \\<not> c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>_. c) a b", "by argo"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>_. c) a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>_. c) a b", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>_. c) a b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "apply (elim finite_Psegments_congE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. \\<lbrakk>a < t; t < b\\<rbrakk> \\<Longrightarrow> c = P t", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> P ?t = c\n\ngoal (1 subgoal):\n 1. \\<And>t. \\<lbrakk>a < t; t < b\\<rbrakk> \\<Longrightarrow> c = P t", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal:\nNo subgoals!", "qed"], ["", "context \nbegin"], ["", "private"], ["", "lemma finite_Psegments_less_eq1:\n  assumes \"finite_Psegments P a c\" \"b\\<le>c\"\n  shows \"finite_Psegments P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using assms"], ["proof (prove)\nusing this:\n  finite_Psegments P a c\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "proof (induct arbitrary: b rule:finite_Psegments.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>b \\<le> a; ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 3. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "case (emptyI a c)"], ["proof (state)\nthis:\n  c \\<le> a\n  b \\<le> c\n\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>b \\<le> a; ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 3. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "then"], ["proof (chain)\npicking this:\n  c \\<le> a\n  b \\<le> c", "show ?case"], ["proof (prove)\nusing this:\n  c \\<le> a\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using finite_Psegments.emptyI"], ["proof (prove)\nusing this:\n  c \\<le> a\n  b \\<le> c\n  ?b \\<le> ?a \\<Longrightarrow> finite_Psegments ?P ?a ?b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal (2 subgoals):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "case (insertI_1 s a c)"], ["proof (state)\nthis:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P a s\n  ?b \\<le> s \\<Longrightarrow> finite_Psegments P a ?b\n  b \\<le> c\n\ngoal (2 subgoals):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "have ?case when \"b\\<le>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using insertI_1 that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P a s\n  ?b \\<le> s \\<Longrightarrow> finite_Psegments P a ?b\n  b \\<le> c\n  b \\<le> s\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by auto"], ["proof (state)\nthis:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n\ngoal (2 subgoals):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "moreover"], ["proof (state)\nthis:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n\ngoal (2 subgoals):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "have ?case when \"b>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "have \"s \\<in> {a..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a..<b}", "using that \\<open>s \\<in> {a..<c}\\<close> \\<open>b \\<le> c\\<close>"], ["proof (prove)\nusing this:\n  s < b\n  s \\<in> {a..<c}\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. s \\<in> {a..<b}", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "moreover"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "have \"\\<forall>t\\<in>{s<..<b}. P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<b}. P t", "using \\<open>\\<forall>t\\<in>{s<..<c}. P t\\<close> that \\<open>b \\<le> c\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<c}. P t\n  s < b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<b}. P t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{s<..<b}. P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. P t", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using finite_Psegments.insertI_1[OF _ _ _ \\<open>finite_Psegments P a s\\<close>] \\<open> s = a \\<or> P s\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. P t\n  \\<lbrakk>s \\<in> {a..<?b}; s = a \\<or> P s;\n   \\<forall>t\\<in>{s<..<?b}. P t\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a ?b\n  s = a \\<or> P s\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s < b \\<Longrightarrow> finite_Psegments P a b\n\ngoal (2 subgoals):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba\n 2. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "ultimately"], ["proof (chain)\npicking this:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n  s < b \\<Longrightarrow> finite_Psegments P a b", "show ?case"], ["proof (prove)\nusing this:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n  s < b \\<Longrightarrow> finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by fastforce"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "case (insertI_2 s a c)"], ["proof (state)\nthis:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P a s\n  ?b \\<le> s \\<Longrightarrow> finite_Psegments P a ?b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "have ?case when \"b\\<le>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using insertI_2 that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P a s\n  ?b \\<le> s \\<Longrightarrow> finite_Psegments P a ?b\n  b \\<le> c\n  b \\<le> s\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by auto"], ["proof (state)\nthis:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "moreover"], ["proof (state)\nthis:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "have ?case when \"b>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "have \"s \\<in> {a..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a..<b}", "using that \\<open>s \\<in> {a..<c}\\<close> \\<open>b \\<le> c\\<close>"], ["proof (prove)\nusing this:\n  s < b\n  s \\<in> {a..<c}\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. s \\<in> {a..<b}", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "moreover"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "have \"\\<forall>t\\<in>{s<..<b}. \\<not> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<b}. \\<not> P t", "using \\<open>\\<forall>t\\<in>{s<..<c}. \\<not> P t\\<close> that \\<open>b \\<le> c\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  s < b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<b}. \\<not> P t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{s<..<b}. \\<not> P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. \\<not> P t", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. \\<not> P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "using finite_Psegments.insertI_2[OF _ _ _ \\<open>finite_Psegments P a s\\<close>] \\<open> s = a \\<or> P s\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  \\<forall>t\\<in>{s<..<b}. \\<not> P t\n  \\<lbrakk>s \\<in> {a..<?b}; s = a \\<or> P s;\n   \\<forall>t\\<in>{s<..<?b}. \\<not> P t\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a ?b\n  s = a \\<or> P s\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s < b \\<Longrightarrow> finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. \\<And>s a b ba.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s;\n        \\<And>b. b \\<le> s \\<Longrightarrow> finite_Psegments P a b;\n        ba \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a ba", "ultimately"], ["proof (chain)\npicking this:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n  s < b \\<Longrightarrow> finite_Psegments P a b", "show ?case"], ["proof (prove)\nusing this:\n  b \\<le> s \\<Longrightarrow> finite_Psegments P a b\n  s < b \\<Longrightarrow> finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a b", "by fastforce"], ["proof (state)\nthis:\n  finite_Psegments P a b\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma finite_Psegments_less_eq2:\n  assumes \"finite_Psegments P a c\" \"a\\<le>b\"\n  shows \"finite_Psegments P b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "using assms"], ["proof (prove)\nusing this:\n  finite_Psegments P a c\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "proof (induct arbitrary:  rule:finite_Psegments.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>ba \\<le> a; a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 3. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "case (emptyI a c)"], ["proof (state)\nthis:\n  c \\<le> a\n  a \\<le> b\n\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>ba \\<le> a; a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 3. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "then"], ["proof (chain)\npicking this:\n  c \\<le> a\n  a \\<le> b", "show ?case"], ["proof (prove)\nusing this:\n  c \\<le> a\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "using finite_Psegments.emptyI"], ["proof (prove)\nusing this:\n  c \\<le> a\n  a \\<le> b\n  ?b \\<le> ?a \\<Longrightarrow> finite_Psegments ?P ?a ?b\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P b c\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "case (insertI_1 s a c)"], ["proof (state)\nthis:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P a s\n  a \\<le> b \\<Longrightarrow> finite_Psegments P b s\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "have ?case when \"s\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "have \"\\<forall>t\\<in>{b<..<c}. P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{b<..<c}. P t", "using insertI_1 that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P a s\n  a \\<le> b \\<Longrightarrow> finite_Psegments P b s\n  a \\<le> b\n  s \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{b<..<c}. P t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{b<..<c}. P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>{b<..<c}. P t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{b<..<c}. P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "by (simp add: finite_Psegments_constI)"], ["proof (state)\nthis:\n  finite_Psegments P b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "moreover"], ["proof (state)\nthis:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "have ?case when \"s>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "apply (rule finite_Psegments.insertI_1[where s=s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. s \\<in> {b..<c}\n 2. s = b \\<or> P s\n 3. \\<forall>t\\<in>{s<..<c}. P t\n 4. finite_Psegments P b s", "using insertI_1 that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P a s\n  a \\<le> b \\<Longrightarrow> finite_Psegments P b s\n  a \\<le> b\n  b < s\n\ngoal (4 subgoals):\n 1. s \\<in> {b..<c}\n 2. s = b \\<or> P s\n 3. \\<forall>t\\<in>{s<..<c}. P t\n 4. finite_Psegments P b s", "by auto"], ["proof (state)\nthis:\n  b < s \\<Longrightarrow> finite_Psegments P b c\n\ngoal (2 subgoals):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba\n 2. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "ultimately"], ["proof (chain)\npicking this:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n  b < s \\<Longrightarrow> finite_Psegments P b c", "show ?case"], ["proof (prove)\nusing this:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n  b < s \\<Longrightarrow> finite_Psegments P b c\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "by linarith"], ["proof (state)\nthis:\n  finite_Psegments P b c\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "case (insertI_2 s a c)"], ["proof (state)\nthis:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P a s\n  a \\<le> b \\<Longrightarrow> finite_Psegments P b s\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "have ?case when \"s\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "have \"\\<forall>t\\<in>{b<..<c}. \\<not> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{b<..<c}. \\<not> P t", "using insertI_2 that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P a s\n  a \\<le> b \\<Longrightarrow> finite_Psegments P b s\n  a \\<le> b\n  s \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{b<..<c}. \\<not> P t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{b<..<c}. \\<not> P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>{b<..<c}. \\<not> P t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{b<..<c}. \\<not> P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "by (metis finite_Psegments_constI greaterThanLessThan_iff)"], ["proof (state)\nthis:\n  finite_Psegments P b c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "moreover"], ["proof (state)\nthis:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "have ?case when \"s>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "apply (rule finite_Psegments.insertI_2[where s=s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. s \\<in> {b..<c}\n 2. s = b \\<or> P s\n 3. \\<forall>t\\<in>{s<..<c}. \\<not> P t\n 4. finite_Psegments P b s", "using insertI_2 that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P a s\n  a \\<le> b \\<Longrightarrow> finite_Psegments P b s\n  a \\<le> b\n  b < s\n\ngoal (4 subgoals):\n 1. s \\<in> {b..<c}\n 2. s = b \\<or> P s\n 3. \\<forall>t\\<in>{s<..<c}. \\<not> P t\n 4. finite_Psegments P b s", "by auto"], ["proof (state)\nthis:\n  b < s \\<Longrightarrow> finite_Psegments P b c\n\ngoal (1 subgoal):\n 1. \\<And>s a ba.\n       \\<lbrakk>s \\<in> {a..<ba}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<ba}. \\<not> P t; finite_Psegments P a s;\n        a \\<le> b \\<Longrightarrow> finite_Psegments P b s;\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P b ba", "ultimately"], ["proof (chain)\npicking this:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n  b < s \\<Longrightarrow> finite_Psegments P b c", "show ?case"], ["proof (prove)\nusing this:\n  s \\<le> b \\<Longrightarrow> finite_Psegments P b c\n  b < s \\<Longrightarrow> finite_Psegments P b c\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "by linarith"], ["proof (state)\nthis:\n  finite_Psegments P b c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_Psegments_included:\n  assumes \"finite_Psegments P a d\" \"a\\<le>b\" \"c\\<le>d\"\n  shows \"finite_Psegments P b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "using finite_Psegments_less_eq2 finite_Psegments_less_eq1 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite_Psegments ?P ?a ?c; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P ?b ?c\n  \\<lbrakk>finite_Psegments ?P ?a ?c; ?b \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P ?a ?b\n  finite_Psegments P a d\n  a \\<le> b\n  c \\<le> d\n\ngoal (1 subgoal):\n 1. finite_Psegments P b c", "by blast"], ["", "end"], ["", "lemma finite_Psegments_combine:\n  assumes \"finite_Psegments P a b\" \"finite_Psegments P b c\" \"b\\<in>{a..c}\" \"closed ({x. P x} \\<inter> {a..c})\" \n  shows \"finite_Psegments P a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "using assms(2,1,3,4)"], ["proof (prove)\nusing this:\n  finite_Psegments P b c\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({x. P x} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "proof (induct rule:finite_Psegments.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>b \\<le> aa; finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 3. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "case (emptyI b c)"], ["proof (state)\nthis:\n  c \\<le> b\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>b \\<le> aa; finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 3. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "then"], ["proof (chain)\npicking this:\n  c \\<le> b\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})", "show ?case"], ["proof (prove)\nusing this:\n  c \\<le> b\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "using finite_Psegments_included"], ["proof (prove)\nusing this:\n  c \\<le> b\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n  \\<lbrakk>finite_Psegments ?P ?a ?d; ?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P ?b ?c\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a c\n\ngoal (2 subgoals):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "case (insertI_1 s b c)"], ["proof (state)\nthis:\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (2 subgoals):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "have \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P s", "have \"s<c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < c", "using insertI_1"], ["proof (prove)\nusing this:\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. s < c", "by auto"], ["proof (state)\nthis:\n  s < c\n\ngoal (1 subgoal):\n 1. P s", "define S where \"S = {x. P x} \\<inter> {s..(s+c)/2}\""], ["proof (state)\nthis:\n  S = {x. P x} \\<inter> {s..(s + c) / 2}\n\ngoal (1 subgoal):\n 1. P s", "have \"closed S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed S", "have \"closed ({a. P a} \\<inter> {a..c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ({a. P a} \\<inter> {a..c})", "using insertI_1(8)"], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. closed ({a. P a} \\<inter> {a..c})", "."], ["proof (state)\nthis:\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. closed S", "moreover"], ["proof (state)\nthis:\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. closed S", "have \"S = ({a. P a} \\<inter> {a..c}) \\<inter> {s..(s+c)/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}", "using insertI_1(1,7)"], ["proof (prove)\nusing this:\n  s \\<in> {b..<c}\n  b \\<in> {a..c}\n\ngoal (1 subgoal):\n 1. S = {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}", "unfolding S_def"], ["proof (prove)\nusing this:\n  s \\<in> {b..<c}\n  b \\<in> {a..c}\n\ngoal (1 subgoal):\n 1. Collect P \\<inter> {s..(s + c) / 2} =\n    {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  S = {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}\n\ngoal (1 subgoal):\n 1. closed S", "ultimately"], ["proof (chain)\npicking this:\n  closed ({a. P a} \\<inter> {a..c})\n  S = {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}", "show ?thesis"], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..c})\n  S = {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}\n\ngoal (1 subgoal):\n 1. closed S", "using closed_Int[of \"{a. P a} \\<inter> {a..c}\" \"{s..(s+c)/2}\"]"], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..c})\n  S = {a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2}\n  \\<lbrakk>closed ({a. P a} \\<inter> {a..c});\n   closed {s..(s + c) / 2}\\<rbrakk>\n  \\<Longrightarrow> closed\n                     ({a. P a} \\<inter> {a..c} \\<inter> {s..(s + c) / 2})\n\ngoal (1 subgoal):\n 1. closed S", "by blast"], ["proof (state)\nthis:\n  closed S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed S\n\ngoal (1 subgoal):\n 1. P s", "moreover"], ["proof (state)\nthis:\n  closed S\n\ngoal (1 subgoal):\n 1. P s", "have \"\\<exists>y\\<in>S. dist y s < e\" when \"e>0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "define y where \"y = min ((s+c)/2) (e/2+s)\""], ["proof (state)\nthis:\n  y = min ((s + c) / 2) (e / 2 + s)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "have \"y\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> S", "have \"y\\<in>{s..(s+c)/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {s..(s + c) / 2}", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min ((s + c) / 2) (e / 2 + s) \\<in> {s..(s + c) / 2}", "using \\<open>e>0\\<close> \\<open>s<c\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  s < c\n\ngoal (1 subgoal):\n 1. min ((s + c) / 2) (e / 2 + s) \\<in> {s..(s + c) / 2}", "by (auto simp add:min_mult_distrib_left algebra_simps)"], ["proof (state)\nthis:\n  y \\<in> {s..(s + c) / 2}\n\ngoal (1 subgoal):\n 1. y \\<in> S", "moreover"], ["proof (state)\nthis:\n  y \\<in> {s..(s + c) / 2}\n\ngoal (1 subgoal):\n 1. y \\<in> S", "have \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y", "apply (rule insertI_1(3)[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {s<..<c}", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min ((s + c) / 2) (e / 2 + s) \\<in> {s<..<c}", "using \\<open>e>0\\<close> \\<open>s<c\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  s < c\n\ngoal (1 subgoal):\n 1. min ((s + c) / 2) (e / 2 + s) \\<in> {s<..<c}", "by (auto simp add:algebra_simps min_mult_distrib_left min_less_iff_disj)"], ["proof (state)\nthis:\n  P y\n\ngoal (1 subgoal):\n 1. y \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> {s..(s + c) / 2}\n  P y", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> {s..(s + c) / 2}\n  P y\n\ngoal (1 subgoal):\n 1. y \\<in> S", "unfolding S_def"], ["proof (prove)\nusing this:\n  y \\<in> {s..(s + c) / 2}\n  P y\n\ngoal (1 subgoal):\n 1. y \\<in> Collect P \\<inter> {s..(s + c) / 2}", "by auto"], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "moreover"], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "have \"dist y s <e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y s < e", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (min ((s + c) / 2) (e / 2 + s)) s < e", "using \\<open>e>0\\<close> \\<open>s<c\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  s < c\n\ngoal (1 subgoal):\n 1. dist (min ((s + c) / 2) (e / 2 + s)) s < e", "by (auto simp add:algebra_simps min_mult_distrib_left min_less_iff_disj dist_real_def)"], ["proof (state)\nthis:\n  dist y s < e\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> S\n  dist y s < e", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> S\n  dist y s < e\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>S. dist y s < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e\n\ngoal (1 subgoal):\n 1. P s", "ultimately"], ["proof (chain)\npicking this:\n  closed S\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e", "have \"s\\<in>S\""], ["proof (prove)\nusing this:\n  closed S\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e\n\ngoal (1 subgoal):\n 1. s \\<in> S", "using closed_approachable"], ["proof (prove)\nusing this:\n  closed S\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e\n  closed ?S \\<Longrightarrow>\n  (\\<forall>e>0. \\<exists>y\\<in>?S. dist y ?x < e) = (?x \\<in> ?S)\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. P s", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. P s", "unfolding S_def"], ["proof (prove)\nusing this:\n  s \\<in> Collect P \\<inter> {s..(s + c) / 2}\n\ngoal (1 subgoal):\n 1. P s", "by auto"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal (2 subgoals):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b\n 2. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "proof (rule finite_Psegments.insertI_1[of s])"], ["proof (state)\ngoal (4 subgoals):\n 1. s \\<in> {a..<c}\n 2. s = a \\<or> P s\n 3. \\<forall>t\\<in>{s<..<c}. P t\n 4. finite_Psegments P a s", "show \" s \\<in> {a..<c}\" \"s = a \\<or> P s\" \"\\<forall>t\\<in>{s<..<c}. P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a..<c} &&& s = a \\<or> P s &&& \\<forall>t\\<in>{s<..<c}. P t", "using insertI_1 \\<open>P s\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n  P s\n\ngoal (1 subgoal):\n 1. s \\<in> {a..<c} &&& s = a \\<or> P s &&& \\<forall>t\\<in>{s<..<c}. P t", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "have \"closed ({a. P a} \\<inter> {a..s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ({a. P a} \\<inter> {a..s})", "using closed_Int[OF \\<open>closed ({a. P a} \\<inter> {a..c})\\<close>,of \"{a..s}\",simplified]"], ["proof (prove)\nusing this:\n  closed (Collect P \\<inter> {a..c} \\<inter> {a..s})\n\ngoal (1 subgoal):\n 1. closed ({a. P a} \\<inter> {a..s})", "apply (elim arg_elim[of closed])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {a..s} = {a. P a} \\<inter> {a..s}", "using \\<open>s \\<in> {b..<c}\\<close> \\<open>b \\<in> {a..c}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {b..<c}\n  b \\<in> {a..c}\n\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {a..s} = {a. P a} \\<inter> {a..s}", "by auto"], ["proof (state)\nthis:\n  closed ({a. P a} \\<inter> {a..s})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "then"], ["proof (chain)\npicking this:\n  closed ({a. P a} \\<inter> {a..s})", "show \"finite_Psegments P a s\""], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..s})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "using insertI_1"], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..s})\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P a c\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "case (insertI_2 s b c)"], ["proof (state)\nthis:\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "have ?case when \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "proof (rule finite_Psegments.insertI_2[of s])"], ["proof (state)\ngoal (4 subgoals):\n 1. s \\<in> {a..<c}\n 2. s = a \\<or> P s\n 3. \\<forall>t\\<in>{s<..<c}. \\<not> P t\n 4. finite_Psegments P a s", "show \"s \\<in> {a..<c}\" \"s = a \\<or> P s\" \"\\<forall>t\\<in>{s<..<c}. \\<not> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {a..<c} &&&\n    s = a \\<or> P s &&& \\<forall>t\\<in>{s<..<c}. \\<not> P t", "using that insertI_2"], ["proof (prove)\nusing this:\n  P s\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. s \\<in> {a..<c} &&&\n    s = a \\<or> P s &&& \\<forall>t\\<in>{s<..<c}. \\<not> P t", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..<c}\n  s = a \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "have \"closed ({a. P a} \\<inter> {a..s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ({a. P a} \\<inter> {a..s})", "using closed_Int[OF \\<open>closed ({a. P a} \\<inter> {a..c})\\<close>,of \"{a..s}\",simplified]"], ["proof (prove)\nusing this:\n  closed (Collect P \\<inter> {a..c} \\<inter> {a..s})\n\ngoal (1 subgoal):\n 1. closed ({a. P a} \\<inter> {a..s})", "apply (elim arg_elim[of closed])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {a..s} = {a. P a} \\<inter> {a..s}", "using  \\<open>s \\<in> {b..<c}\\<close> \\<open>b \\<in> {a..c}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {b..<c}\n  b \\<in> {a..c}\n\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {a..s} = {a. P a} \\<inter> {a..s}", "by auto"], ["proof (state)\nthis:\n  closed ({a. P a} \\<inter> {a..s})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "then"], ["proof (chain)\npicking this:\n  closed ({a. P a} \\<inter> {a..s})", "show \"finite_Psegments P a s\""], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..s})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "using insertI_2"], ["proof (prove)\nusing this:\n  closed ({a. P a} \\<inter> {a..s})\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s \\<Longrightarrow> finite_Psegments P a c\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "moreover"], ["proof (state)\nthis:\n  P s \\<Longrightarrow> finite_Psegments P a c\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "have ?case when \"\\<not> P s\" \"s=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "using \\<open>finite_Psegments P a b\\<close>"], ["proof (prove)\nusing this:\n  finite_Psegments P a b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "proof (cases rule:finite_Psegments.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. b \\<le> a \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "case emptyI"], ["proof (state)\nthis:\n  b \\<le> a\n\ngoal (3 subgoals):\n 1. b \\<le> a \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "then"], ["proof (chain)\npicking this:\n  b \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "using insertI_2 that"], ["proof (prove)\nusing this:\n  b \\<le> a\n  s \\<in> {b..<c}\n  s = b \\<or> P s\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  finite_Psegments P b s\n  \\<lbrakk>finite_Psegments P a b; b \\<in> {a..s};\n   closed ({a. P a} \\<inter> {a..s})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a s\n  finite_Psegments P a b\n  b \\<in> {a..c}\n  closed ({a. P a} \\<inter> {a..c})\n  \\<not> P s\n  s = b\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "by (metis antisym_conv atLeastAtMost_iff finite_Psegments.insertI_2)"], ["proof (state)\nthis:\n  finite_Psegments P a c\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "case (insertI_1 s0)"], ["proof (state)\nthis:\n  s0 \\<in> {a..<b}\n  s0 = a \\<or> P s0\n  Ball {s0<..<b} P\n  finite_Psegments P a s0\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "have \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P s", "have \"s0<s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 < s", "using insertI_1 atLeastLessThan_iff that(2)"], ["proof (prove)\nusing this:\n  s0 \\<in> {a..<b}\n  s0 = a \\<or> P s0\n  Ball {s0<..<b} P\n  finite_Psegments P a s0\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  s = b\n\ngoal (1 subgoal):\n 1. s0 < s", "by blast"], ["proof (state)\nthis:\n  s0 < s\n\ngoal (1 subgoal):\n 1. P s", "define S where \"S = {x. P x} \\<inter> {(s0+s)/2..s}\""], ["proof (state)\nthis:\n  S = {x. P x} \\<inter> {(s0 + s) / 2..s}\n\ngoal (1 subgoal):\n 1. P s", "have \"closed S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed S", "using closed_Int[OF \\<open>closed ({a. P a} \\<inter> {a..c})\\<close>,of \"{(s0+s)/2..s}\",simplified]"], ["proof (prove)\nusing this:\n  closed (Collect P \\<inter> {a..c} \\<inter> {(s0 + s) / 2..s})\n\ngoal (1 subgoal):\n 1. closed S", "apply (elim arg_elim[of closed])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {(s0 + s) / 2..s} = S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {(s0 + s) / 2..s} =\n    Collect P \\<inter> {(s0 + s) / 2..s}", "using \\<open>s0 \\<in> {a..<b}\\<close> \\<open> s \\<in> {b..<c}\\<close> \\<open>b \\<in> {a..c}\\<close>"], ["proof (prove)\nusing this:\n  s0 \\<in> {a..<b}\n  s \\<in> {b..<c}\n  b \\<in> {a..c}\n\ngoal (1 subgoal):\n 1. Collect P \\<inter> {a..c} \\<inter> {(s0 + s) / 2..s} =\n    Collect P \\<inter> {(s0 + s) / 2..s}", "by auto"], ["proof (state)\nthis:\n  closed S\n\ngoal (1 subgoal):\n 1. P s", "moreover"], ["proof (state)\nthis:\n  closed S\n\ngoal (1 subgoal):\n 1. P s", "have \"\\<exists>y\\<in>S. dist y s < e\" when \"e>0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "define y where \"y = max ((s+s0)/2) (s-e/2)\""], ["proof (state)\nthis:\n  y = max ((s + s0) / 2) (s - e / 2)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "have \"y\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> S", "have \"y\\<in>{(s0+s)/2..s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {(s0 + s) / 2..s}", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max ((s + s0) / 2) (s - e / 2) \\<in> {(s0 + s) / 2..s}", "using \\<open>e>0\\<close> \\<open>s0<s\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  s0 < s\n\ngoal (1 subgoal):\n 1. max ((s + s0) / 2) (s - e / 2) \\<in> {(s0 + s) / 2..s}", "by (auto simp add:field_simps min_mult_distrib_left)"], ["proof (state)\nthis:\n  y \\<in> {(s0 + s) / 2..s}\n\ngoal (1 subgoal):\n 1. y \\<in> S", "moreover"], ["proof (state)\nthis:\n  y \\<in> {(s0 + s) / 2..s}\n\ngoal (1 subgoal):\n 1. y \\<in> S", "have \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y", "apply (rule insertI_1(3)[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {s0<..<b}", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max ((s + s0) / 2) (s - e / 2) \\<in> {s0<..<b}", "using \\<open>e>0\\<close> \\<open>s0<s\\<close> \\<open>s=b\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  s0 < s\n  s = b\n\ngoal (1 subgoal):\n 1. max ((s + s0) / 2) (s - e / 2) \\<in> {s0<..<b}", "by (auto simp add:field_simps max_mult_distrib_left less_max_iff_disj)"], ["proof (state)\nthis:\n  P y\n\ngoal (1 subgoal):\n 1. y \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> {(s0 + s) / 2..s}\n  P y", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> {(s0 + s) / 2..s}\n  P y\n\ngoal (1 subgoal):\n 1. y \\<in> S", "unfolding S_def"], ["proof (prove)\nusing this:\n  y \\<in> {(s0 + s) / 2..s}\n  P y\n\ngoal (1 subgoal):\n 1. y \\<in> Collect P \\<inter> {(s0 + s) / 2..s}", "by auto"], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "moreover"], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "have \"dist y s <e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y s < e", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (max ((s + s0) / 2) (s - e / 2)) s < e", "using \\<open>e>0\\<close> \\<open>s0<s\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  s0 < s\n\ngoal (1 subgoal):\n 1. dist (max ((s + s0) / 2) (s - e / 2)) s < e", "by (auto simp add:algebra_simps max_mult_distrib_left less_max_iff_disj dist_real_def \n              max_add_distrib_right)"], ["proof (state)\nthis:\n  dist y s < e\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> S\n  dist y s < e", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> S\n  dist y s < e\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>S. dist y s < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>S. dist y s < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e\n\ngoal (1 subgoal):\n 1. P s", "ultimately"], ["proof (chain)\npicking this:\n  closed S\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e", "have \"s\\<in>S\""], ["proof (prove)\nusing this:\n  closed S\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e\n\ngoal (1 subgoal):\n 1. s \\<in> S", "using closed_approachable"], ["proof (prove)\nusing this:\n  closed S\n  0 < ?e \\<Longrightarrow> \\<exists>y\\<in>S. dist y s < ?e\n  closed ?S \\<Longrightarrow>\n  (\\<forall>e>0. \\<exists>y\\<in>?S. dist y ?x < e) = (?x \\<in> ?S)\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. P s", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. P s", "unfolding S_def"], ["proof (prove)\nusing this:\n  s \\<in> Collect P \\<inter> {(s0 + s) / 2..s}\n\ngoal (1 subgoal):\n 1. P s", "by auto"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "then"], ["proof (chain)\npicking this:\n  P s", "have False"], ["proof (prove)\nusing this:\n  P s\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> P s\\<close>"], ["proof (prove)\nusing this:\n  P s\n  \\<not> P s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s; Ball {s<..<b} P;\n        finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "by simp"], ["proof (state)\nthis:\n  finite_Psegments P a c\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "case (insertI_2 s0)"], ["proof (state)\nthis:\n  s0 \\<in> {a..<b}\n  s0 = a \\<or> P s0\n  \\<forall>t\\<in>{s0<..<b}. \\<not> P t\n  finite_Psegments P a s0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "have *: \"\\<forall>t\\<in>{s0<..<c}. \\<not> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s0<..<c}. \\<not> P t", "using \\<open> \\<forall>t\\<in>{s<..<c}. \\<not> P t\\<close> that \\<open>\\<forall>t\\<in>{s0<..<b}. \\<not> P t\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<c}. \\<not> P t\n  \\<not> P s\n  s = b\n  \\<forall>t\\<in>{s0<..<b}. \\<not> P t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s0<..<c}. \\<not> P t", "by force"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{s0<..<c}. \\<not> P t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P a s\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "apply (rule finite_Psegments.insertI_2[of s0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. s0 \\<in> {a..<c}\n 2. s0 = a \\<or> P s0\n 3. \\<forall>t\\<in>{s0<..<c}. \\<not> P t\n 4. finite_Psegments P a s0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 \\<in> {a..<c}", "using insertI_2.prems(2) local.insertI_2(1)"], ["proof (prove)\nusing this:\n  b \\<in> {a..c}\n  s0 \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. s0 \\<in> {a..<c}", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. s0 = a \\<or> P s0\n 2. \\<forall>t\\<in>{s0<..<c}. \\<not> P t\n 3. finite_Psegments P a s0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 = a \\<or> P s0", "using \\<open>s0 = a \\<or> P s0\\<close>"], ["proof (prove)\nusing this:\n  s0 = a \\<or> P s0\n\ngoal (1 subgoal):\n 1. s0 = a \\<or> P s0", "."], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{s0<..<c}. \\<not> P t\n 2. finite_Psegments P a s0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s0<..<c}. \\<not> P t", "using *"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s0<..<c}. \\<not> P t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s0<..<c}. \\<not> P t", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a s0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P a s0", "using \\<open>finite_Psegments P a s0\\<close>"], ["proof (prove)\nusing this:\n  finite_Psegments P a s0\n\ngoal (1 subgoal):\n 1. finite_Psegments P a s0", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite_Psegments P a c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> P s; s = b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a c\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> P s; s = b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a c\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "note \\<open>s = b \\<or> P s\\<close>"], ["proof (state)\nthis:\n  s = b \\<or> P s\n\ngoal (1 subgoal):\n 1. \\<And>s aa b.\n       \\<lbrakk>s \\<in> {aa..<b}; s = aa \\<or> P s;\n        \\<forall>t\\<in>{s<..<b}. \\<not> P t; finite_Psegments P aa s;\n        \\<lbrakk>finite_Psegments P a aa; aa \\<in> {a..s};\n         closed (Collect P \\<inter> {a..s})\\<rbrakk>\n        \\<Longrightarrow> finite_Psegments P a s;\n        finite_Psegments P a aa; aa \\<in> {a..b};\n        closed (Collect P \\<inter> {a..b})\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P a b", "ultimately"], ["proof (chain)\npicking this:\n  P s \\<Longrightarrow> finite_Psegments P a c\n  \\<lbrakk>\\<not> P s; s = b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a c\n  s = b \\<or> P s", "show ?case"], ["proof (prove)\nusing this:\n  P s \\<Longrightarrow> finite_Psegments P a c\n  \\<lbrakk>\\<not> P s; s = b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P a c\n  s = b \\<or> P s\n\ngoal (1 subgoal):\n 1. finite_Psegments P a c", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P a c\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite segment intersection of a path with the imaginary axis\\<close>"], ["", "definition finite_ReZ_segments::\"(real \\<Rightarrow> complex) \\<Rightarrow> complex \\<Rightarrow> bool\" where\n  \"finite_ReZ_segments g z = finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\""], ["", "lemma finite_ReZ_segments_joinpaths:\n  assumes g1:\"finite_ReZ_segments g1 z\" and g2: \"finite_ReZ_segments g2 z\" and\n    \"path g1\" \"path g2\" \"pathfinish g1=pathstart g2\"\n  shows \"finite_ReZ_segments (g1+++g2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "define P where \"P = (\\<lambda>t. (Re ((g1 +++ g2) t - z) = 0 \\<and> 0<t \\<and> t<1) \\<or> t=0 \\<or> t=1)\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>t.\n      Re ((g1 +++ g2) t - z) = 0 \\<and> 0 < t \\<and> t < 1 \\<or>\n      t = 0 \\<or> t = 1)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "have \"finite_Psegments P 0 (1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 (1 / 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 (1 / 2)", "have \"finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1", "using g1"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g1 z\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1", "."], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 (1 / 2)", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1", "have \"finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1/2)\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g1 t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1 / 2)", "apply (drule_tac finite_Psegments_pos_linear[of _ 2 0 0 \"1/2\",simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments ((\\<lambda>t. Re (g1 t - z) = 0) \\<circ> (*) 2) 0\n     (1 / 2) \\<Longrightarrow>\n    finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1 / 2)", "by (auto simp add:comp_def)"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1 / 2)\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 (1 / 2)", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1 / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1 / 2)\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 (1 / 2)", "unfolding P_def joinpaths_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g1 (2 * t) - z) = 0) 0 (1 / 2)\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t.\n         Re ((if t \\<le> 1 / 2 then g1 (2 * t) else g2 (2 * t - 1)) - z) =\n         0 \\<and>\n         0 < t \\<and> t < 1 \\<or>\n         t = 0 \\<or> t = 1)\n     0 (1 / 2)", "by (elim finite_Psegments_congE,auto)"], ["proof (state)\nthis:\n  finite_Psegments P 0 (1 / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P 0 (1 / 2)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite_Psegments P 0 (1 / 2)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "have \"finite_Psegments P (1/2) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P (1 / 2) 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P (1 / 2) 1", "have \"finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1", "using g2"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g2 z\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1", "."], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments P (1 / 2) 1", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1", "have \"finite_Psegments (\\<lambda>t. Re (g2 (2 * t-1) - z) = 0) (1/2) 1\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g2 t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g2 (2 * t - 1) - z) = 0) (1 / 2) 1", "apply (drule_tac finite_Psegments_pos_linear[of _ 2 \"1/2\" \"-1\" 1,simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments\n     ((\\<lambda>t. Re (g2 t - z) = 0) \\<circ> (\\<lambda>t. 2 * t - 1))\n     (1 / 2) 1 \\<Longrightarrow>\n    finite_Psegments (\\<lambda>t. Re (g2 (2 * t - 1) - z) = 0) (1 / 2) 1", "by (auto simp add:comp_def)"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g2 (2 * t - 1) - z) = 0) (1 / 2) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments P (1 / 2) 1", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g2 (2 * t - 1) - z) = 0) (1 / 2) 1", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g2 (2 * t - 1) - z) = 0) (1 / 2) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments P (1 / 2) 1", "unfolding P_def joinpaths_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g2 (2 * t - 1) - z) = 0) (1 / 2) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t.\n         Re ((if t \\<le> 1 / 2 then g1 (2 * t) else g2 (2 * t - 1)) - z) =\n         0 \\<and>\n         0 < t \\<and> t < 1 \\<or>\n         t = 0 \\<or> t = 1)\n     (1 / 2) 1", "apply (elim finite_Psegments_congE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>1 / 2 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (Re (g2 (2 * t - 1) - z) = 0) =\n                         (Re ((if t \\<le> 1 / 2 then g1 (2 * t)\n                               else g2 (2 * t - 1)) -\n                              z) =\n                          0 \\<and>\n                          0 < t \\<and> t < 1 \\<or>\n                          t = 0 \\<or> t = 1)", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P (1 / 2) 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P (1 / 2) 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite_Psegments P (1 / 2) 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "have \"closed {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. P x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {x. P x}", "define Q where \"Q=(\\<lambda>t. Re ((g1 +++ g2) t - z) = 0)\""], ["proof (state)\nthis:\n  Q = (\\<lambda>t. Re ((g1 +++ g2) t - z) = 0)\n\ngoal (1 subgoal):\n 1. closed {x. P x}", "have \"continuous_on {0<..<1} (g1+++g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0<..<1} (g1 +++ g2)", "using path_join_imp[OF \\<open>path g1\\<close> \\<open>path g2\\<close> \\<open>pathfinish g1=pathstart g2\\<close>]"], ["proof (prove)\nusing this:\n  path (g1 +++ g2)\n\ngoal (1 subgoal):\n 1. continuous_on {0<..<1} (g1 +++ g2)", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} (g1 +++ g2)\n\ngoal (1 subgoal):\n 1. continuous_on {0<..<1} (g1 +++ g2)", "by (auto elim:continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on {0<..<1} (g1 +++ g2)\n\ngoal (1 subgoal):\n 1. closed {x. P x}", "from continuous_on_Re[OF this]"], ["proof (chain)\npicking this:\n  continuous_on {0<..<1} (\\<lambda>x. Re ((g1 +++ g2) x))", "have \"continuous_on {0<..<1} (\\<lambda>x. Re ((g1 +++ g2) x))\""], ["proof (prove)\nusing this:\n  continuous_on {0<..<1} (\\<lambda>x. Re ((g1 +++ g2) x))\n\ngoal (1 subgoal):\n 1. continuous_on {0<..<1} (\\<lambda>x. Re ((g1 +++ g2) x))", "."], ["proof (state)\nthis:\n  continuous_on {0<..<1} (\\<lambda>x. Re ((g1 +++ g2) x))\n\ngoal (1 subgoal):\n 1. closed {x. P x}", "from continuous_on_open_Collect_neq[OF this,of \"\\<lambda>_. Re z\",OF continuous_on_const,simplified]"], ["proof (chain)\npicking this:\n  open {x. 0 < x \\<and> x < 1 \\<and> Re ((g1 +++ g2) x) \\<noteq> Re z}", "have \"open {t. Re ((g1 +++ g2) t - z) \\<noteq> 0 \\<and> 0<t \\<and> t<1}\""], ["proof (prove)\nusing this:\n  open {x. 0 < x \\<and> x < 1 \\<and> Re ((g1 +++ g2) x) \\<noteq> Re z}\n\ngoal (1 subgoal):\n 1. open {t. Re ((g1 +++ g2) t - z) \\<noteq> 0 \\<and> 0 < t \\<and> t < 1}", "by (elim arg_elim[where f=\"open\"],auto)"], ["proof (state)\nthis:\n  open {t. Re ((g1 +++ g2) t - z) \\<noteq> 0 \\<and> 0 < t \\<and> t < 1}\n\ngoal (1 subgoal):\n 1. closed {x. P x}", "from closed_Diff[of \"{0::real..1}\",OF _ this,simplified]"], ["proof (chain)\npicking this:\n  closed\n   ({0..1} -\n    {t. Re ((g1 +++ g2) t) \\<noteq> Re z \\<and> 0 < t \\<and> t < 1})", "show \"closed {x. P x}\""], ["proof (prove)\nusing this:\n  closed\n   ({0..1} -\n    {t. Re ((g1 +++ g2) t) \\<noteq> Re z \\<and> 0 < t \\<and> t < 1})\n\ngoal (1 subgoal):\n 1. closed {x. P x}", "apply (elim arg_elim[where f=closed])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..1} -\n    {t. Re ((g1 +++ g2) t) \\<noteq> Re z \\<and> 0 < t \\<and> t < 1} =\n    {x. P x}", "by (auto simp add:P_def)"], ["proof (state)\nthis:\n  closed {x. P x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed {x. P x}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "ultimately"], ["proof (chain)\npicking this:\n  finite_Psegments P 0 (1 / 2)\n  finite_Psegments P (1 / 2) 1\n  closed {x. P x}", "have \"finite_Psegments P 0 1\""], ["proof (prove)\nusing this:\n  finite_Psegments P 0 (1 / 2)\n  finite_Psegments P (1 / 2) 1\n  closed {x. P x}\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 1", "using finite_Psegments_combine[of _ 0 \"1/2\" 1]"], ["proof (prove)\nusing this:\n  finite_Psegments P 0 (1 / 2)\n  finite_Psegments P (1 / 2) 1\n  closed {x. P x}\n  \\<lbrakk>finite_Psegments ?P 0 (1 / 2); finite_Psegments ?P (1 / 2) 1;\n   1 / 2 \\<in> {0..1}; closed ({x. ?P x} \\<inter> {0..1})\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 1", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P 0 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments P 0 1", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments P 0 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "unfolding finite_ReZ_segments_def P_def"], ["proof (prove)\nusing this:\n  finite_Psegments\n   (\\<lambda>t.\n       Re ((g1 +++ g2) t - z) = 0 \\<and> 0 < t \\<and> t < 1 \\<or>\n       t = 0 \\<or> t = 1)\n   0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re ((g1 +++ g2) t - z) = 0) 0 1", "by (elim finite_Psegments_congE,auto)"], ["proof (state)\nthis:\n  finite_ReZ_segments (g1 +++ g2) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_congE:\n  assumes \"finite_ReZ_segments p1 z1\" \n    \"\\<And>t. \\<lbrakk>0<t;t<1\\<rbrakk> \\<Longrightarrow>  Re(p1 t- z1) = Re(p2 t - z2)\"\n  shows \"finite_ReZ_segments p2 z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments p2 z2", "using assms"], ["proof (prove)\nusing this:\n  finite_ReZ_segments p1 z1\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> Re (p1 ?t - z1) = Re (p2 ?t - z2)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments p2 z2", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (p1 t - z1) = 0) 0 1\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> Re (p1 ?t - z1) = Re (p2 ?t - z2)\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (p2 t - z2) = 0) 0 1", "apply (elim finite_Psegments_congE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>0 < t; t < 1\\<rbrakk>\n                   \\<Longrightarrow> Re (p1 t - z1) = Re (p2 t - z2);\n        0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (Re (p1 t - z1) = 0) = (Re (p2 t - z2) = 0)", "by auto"], ["", "lemma finite_ReZ_segments_constI:\n  assumes \"\\<forall>t. 0<t\\<and>t<1 \\<longrightarrow> g t = c\"\n  shows \"finite_ReZ_segments g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "have \"finite_ReZ_segments (\\<lambda>_. c) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (\\<lambda>_. c) z", "unfolding finite_ReZ_segments_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (c - z) = 0) 0 1", "by (rule finite_Psegments_constI,auto)"], ["proof (state)\nthis:\n  finite_ReZ_segments (\\<lambda>_. c) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "then"], ["proof (chain)\npicking this:\n  finite_ReZ_segments (\\<lambda>_. c) z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (\\<lambda>_. c) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "using assms"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (\\<lambda>_. c) z\n  \\<forall>t. 0 < t \\<and> t < 1 \\<longrightarrow> g t = c\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "by (elim finite_ReZ_segments_congE,auto)"], ["proof (state)\nthis:\n  finite_ReZ_segments g z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segment_cases [consumes 1, case_names subEq subNEq,cases pred:finite_ReZ_segments]:\n  assumes \"finite_ReZ_segments g z\"\n    and subEq:\"(\\<And>s. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;finite_ReZ_segments (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P)\" \n    and subNEq:\"(\\<And>s. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;finite_ReZ_segments (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P)\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms(1)"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n\ngoal (1 subgoal):\n 1. P", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. P", "proof (cases rule:finite_Psegments.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> 0 \\<Longrightarrow> P\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "case emptyI"], ["proof (state)\nthis:\n  1 \\<le> 0\n\ngoal (3 subgoals):\n 1. 1 \\<le> 0 \\<Longrightarrow> P\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  1 \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> 0\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "case (insertI_1 s)"], ["proof (state)\nthis:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "have \"finite_ReZ_segments (subpath 0 s g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s g) z", "proof (cases \"s=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z\n 2. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "case True"], ["proof (state)\nthis:\n  s = 0\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z\n 2. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s g) z", "apply (rule finite_ReZ_segments_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. 0 < t \\<and> t < 1 \\<longrightarrow> subpath 0 s g t = ?c", "using True"], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t. 0 < t \\<and> t < 1 \\<longrightarrow> subpath 0 s g t = ?c", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 < t \\<and> t < 1 \\<longrightarrow> g ((s - 0) * t + 0) = ?c", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "case False"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> 0", "have \"s>0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < s", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. 0 < s", "by auto"], ["proof (state)\nthis:\n  0 < s\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "from finite_Psegments_pos_linear[OF _ this,of _ 0 0 1] insertI_1(4)"], ["proof (chain)\npicking this:\n  finite_Psegments ?P (s * 0 + 0) (s * 1 + 0) \\<Longrightarrow>\n  finite_Psegments (?P \\<circ> (\\<lambda>t. s * t + 0)) 0 1\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "show \"finite_ReZ_segments (subpath 0 s g) z\""], ["proof (prove)\nusing this:\n  finite_Psegments ?P (s * 0 + 0) (s * 1 + 0) \\<Longrightarrow>\n  finite_Psegments (?P \\<circ> (\\<lambda>t. s * t + 0)) 0 1\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s g) z", "unfolding finite_ReZ_segments_def comp_def subpath_def"], ["proof (prove)\nusing this:\n  finite_Psegments ?P (s * 0 + 0) (s * 1 + 0) \\<Longrightarrow>\n  finite_Psegments (\\<lambda>x. ?P (s * x + 0)) 0 1\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g ((s - 0) * t + 0) - z) = 0) 0 1", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  finite_ReZ_segments (subpath 0 s g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. P", "using subEq insertI_1"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath 0 s g) z\n  \\<lbrakk>?s \\<in> {0..<1}; ?s = 0 \\<or> Re (g ?s) = Re z;\n   \\<forall>t\\<in>{?s<..<1}. Re (g t) = Re z;\n   finite_ReZ_segments (subpath 0 ?s g) z\\<rbrakk>\n  \\<Longrightarrow> P\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. P", "by force"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "case (insertI_2 s)"], ["proof (state)\nthis:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "have \"finite_ReZ_segments (subpath 0 s g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s g) z", "proof (cases \"s=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z\n 2. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "case True"], ["proof (state)\nthis:\n  s = 0\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z\n 2. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s g) z", "apply (rule finite_ReZ_segments_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. 0 < t \\<and> t < 1 \\<longrightarrow> subpath 0 s g t = ?c", "using True"], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t. 0 < t \\<and> t < 1 \\<longrightarrow> subpath 0 s g t = ?c", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 < t \\<and> t < 1 \\<longrightarrow> g ((s - 0) * t + 0) = ?c", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "case False"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> 0", "have \"s>0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < s", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. 0 < s", "by auto"], ["proof (state)\nthis:\n  0 < s\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> finite_ReZ_segments (subpath 0 s g) z", "from finite_Psegments_pos_linear[OF _ this,of _ 0 0 1] insertI_2(4)"], ["proof (chain)\npicking this:\n  finite_Psegments ?P (s * 0 + 0) (s * 1 + 0) \\<Longrightarrow>\n  finite_Psegments (?P \\<circ> (\\<lambda>t. s * t + 0)) 0 1\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "show \"finite_ReZ_segments (subpath 0 s g) z\""], ["proof (prove)\nusing this:\n  finite_Psegments ?P (s * 0 + 0) (s * 1 + 0) \\<Longrightarrow>\n  finite_Psegments (?P \\<circ> (\\<lambda>t. s * t + 0)) 0 1\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s g) z", "unfolding finite_ReZ_segments_def comp_def subpath_def"], ["proof (prove)\nusing this:\n  finite_Psegments ?P (s * 0 + 0) (s * 1 + 0) \\<Longrightarrow>\n  finite_Psegments (\\<lambda>x. ?P (s * x + 0)) 0 1\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g ((s - 0) * t + 0) - z) = 0) 0 1", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  finite_ReZ_segments (subpath 0 s g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. P", "using subNEq insertI_2"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath 0 s g) z\n  \\<lbrakk>?s \\<in> {0..<1}; ?s = 0 \\<or> Re (g ?s) = Re z;\n   \\<forall>t\\<in>{?s<..<1}. Re (g t) \\<noteq> Re z;\n   finite_ReZ_segments (subpath 0 ?s g) z\\<rbrakk>\n  \\<Longrightarrow> P\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal (1 subgoal):\n 1. P", "by force"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_induct [case_names sub0 subEq subNEq, induct pred:finite_ReZ_segments]:\n  assumes \"finite_ReZ_segments g z\"\n  assumes  sub0:\"\\<And>g z. (P (subpath 0 0 g) z)\" \n    and subEq:\"(\\<And>s g z. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;finite_ReZ_segments (subpath 0 s g) z; \n          P (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P g z)\" \n    and subNEq:\"(\\<And>s g z. \\<lbrakk>s \\<in> {0..<1};s=0\\<or>Re (g s) = Re z;\n          \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;finite_ReZ_segments (subpath 0 s g) z;\n          P (subpath 0 s g) z\\<rbrakk> \\<Longrightarrow> P g z)\"\n  shows \"P g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P g z", "have \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "using assms(1)"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. P g z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "have \"(0::real)\\<le>1 \\<longrightarrow> P (subpath 0 1 g) z\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 \\<longrightarrow> P (subpath 0 1 g) z", "proof (induct rule: finite_Psegments.induct[of _ 0 1 \"\\<lambda>a b. b\\<ge>a \\<longrightarrow> P (subpath a b g) z\"] )"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 3. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "case (emptyI a b)"], ["proof (state)\nthis:\n  b \\<le> a\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 3. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "then"], ["proof (chain)\npicking this:\n  b \\<le> a", "show ?case"], ["proof (prove)\nusing this:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "using sub0[of \"subpath a b g\"]"], ["proof (prove)\nusing this:\n  b \\<le> a\n  P (subpath 0 0 (subpath a b g)) ?z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  b \\<le> a\n  P (\\<lambda>x. g ((b - a) * ((0 - 0) * x + 0) + a)) ?z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (\\<lambda>x. g ((b - a) * x + a)) z", "by auto"], ["proof (state)\nthis:\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "case (insertI_1 s a b)"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  a \\<le> s \\<longrightarrow> P (subpath a s g) z\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have ?case when \"a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "using sub0[of \"subpath a b g\"] that"], ["proof (prove)\nusing this:\n  P (subpath 0 0 (subpath a b g)) ?z\n  a = b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  P (\\<lambda>x. g ((b - a) * ((0 - 0) * x + 0) + a)) ?z\n  a = b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (\\<lambda>x. g ((b - a) * x + a)) z", "by auto"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "moreover"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have ?case when \"a\\<noteq>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have \"b>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b", "using that \\<open>s \\<in> {a..<b}\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. a < b", "by auto"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "define s'::real where \"s'=(s-a)/(b-a)\""], ["proof (state)\nthis:\n  s' = (s - a) / (b - a)\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have \"P (subpath a b g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (subpath a b g) z", "proof (rule subEq[of s' \"subpath a b g\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. s' \\<in> {0..<1}\n 2. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 3. \\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) = Re z\n 4. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 5. P (subpath 0 s' (subpath a b g)) z", "show \"\\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) = Re z", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {s'<..<1} \\<Longrightarrow> Re (subpath a b g t) = Re z", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {s'<..<1} \\<Longrightarrow> Re (subpath a b g t) = Re z", "assume \"t \\<in> {s'<..<1}\""], ["proof (state)\nthis:\n  t \\<in> {s'<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {s'<..<1} \\<Longrightarrow> Re (subpath a b g t) = Re z", "then"], ["proof (chain)\npicking this:\n  t \\<in> {s'<..<1}", "have \"(b - a) * t + a\\<in>{s<..<b}\""], ["proof (prove)\nusing this:\n  t \\<in> {s'<..<1}\n\ngoal (1 subgoal):\n 1. (b - a) * t + a \\<in> {s<..<b}", "unfolding s'_def"], ["proof (prove)\nusing this:\n  t \\<in> {(s - a) / (b - a)<..<1}\n\ngoal (1 subgoal):\n 1. (b - a) * t + a \\<in> {s<..<b}", "using \\<open>b>a\\<close> \\<open>s \\<in> {a..<b}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {(s - a) / (b - a)<..<1}\n  a < b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. (b - a) * t + a \\<in> {s<..<b}", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s + a * t < a + b * t; t < 1; a \\<le> s; s < b\\<rbrakk>\n    \\<Longrightarrow> a + b * t < b + a * t", "by (sos \"((((A<0 * (A<1 * A<2)) * R<1) + (((A<=1 * (A<0 * R<1)) * (R<1 * [1]^2))\n               + ((A<=0 * (A<0 * (A<1 * R<1))) * (R<1 * [1]^2)))))\")"], ["proof (state)\nthis:\n  (b - a) * t + a \\<in> {s<..<b}\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {s'<..<1} \\<Longrightarrow> Re (subpath a b g t) = Re z", "then"], ["proof (chain)\npicking this:\n  (b - a) * t + a \\<in> {s<..<b}", "have \"Re (g ((b - a) * t + a) - z) = 0\""], ["proof (prove)\nusing this:\n  (b - a) * t + a \\<in> {s<..<b}\n\ngoal (1 subgoal):\n 1. Re (g ((b - a) * t + a) - z) = 0", "using insertI_1(3)[rule_format,of \"(b - a) * t + a\"]"], ["proof (prove)\nusing this:\n  (b - a) * t + a \\<in> {s<..<b}\n  (b - a) * t + a \\<in> {s<..<b} \\<Longrightarrow>\n  Re (g ((b - a) * t + a) - z) = 0\n\ngoal (1 subgoal):\n 1. Re (g ((b - a) * t + a) - z) = 0", "by auto"], ["proof (state)\nthis:\n  Re (g ((b - a) * t + a) - z) = 0\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {s'<..<1} \\<Longrightarrow> Re (subpath a b g t) = Re z", "then"], ["proof (chain)\npicking this:\n  Re (g ((b - a) * t + a) - z) = 0", "show \"Re (subpath a b g t) = Re z\""], ["proof (prove)\nusing this:\n  Re (g ((b - a) * t + a) - z) = 0\n\ngoal (1 subgoal):\n 1. Re (subpath a b g t) = Re z", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  Re (g ((b - a) * t + a) - z) = 0\n\ngoal (1 subgoal):\n 1. Re (g ((b - a) * t + a)) = Re z", "by auto"], ["proof (state)\nthis:\n  Re (subpath a b g t) = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) = Re z\n\ngoal (4 subgoals):\n 1. s' \\<in> {0..<1}\n 2. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 3. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 4. P (subpath 0 s' (subpath a b g)) z", "show \"finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "proof (cases \"s=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 2. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "case True"], ["proof (state)\nthis:\n  s = a\n\ngoal (2 subgoals):\n 1. s = a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 2. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  s = a", "show ?thesis"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "unfolding s'_def subpath_def"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments\n     (\\<lambda>x. g ((b - a) * (((s - a) / (b - a) - 0) * x + 0) + a)) z", "by (auto intro:finite_ReZ_segments_constI)"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "case False"], ["proof (state)\nthis:\n  s \\<noteq> a\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "have \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "using insertI_1(4)"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "have \"finite_Psegments ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0 1\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a))\n     0 1", "apply (elim finite_Psegments_pos_linear[of _ \"s-a\" 0 a 1,simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < s", "using False \\<open>s\\<in>{a..<b}\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> a\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. a < s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1\n  a < b\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "unfolding finite_ReZ_segments_def subpath_def s'_def comp_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>x. Re (g ((s - a) * x + a) - z) = 0) 0 1\n  a < b\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t.\n         Re (g ((b - a) * (((s - a) / (b - a) - 0) * t + 0) + a) - z) = 0)\n     0 1", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n\ngoal (3 subgoals):\n 1. s' \\<in> {0..<1}\n 2. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 3. P (subpath 0 s' (subpath a b g)) z", "show \"s' \\<in> {0..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> {0..<1}", "using \\<open>b>a\\<close> \\<open>s\\<in>{a..<b}\\<close>"], ["proof (prove)\nusing this:\n  a < b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. s' \\<in> {0..<1}", "unfolding s'_def"], ["proof (prove)\nusing this:\n  a < b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. (s - a) / (b - a) \\<in> {0..<1}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  s' \\<in> {0..<1}\n\ngoal (2 subgoals):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 2. P (subpath 0 s' (subpath a b g)) z", "show \"P (subpath 0 s' (subpath a b g)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "have \"P (subpath a s g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (subpath a s g) z", "using insertI_1(1,5)"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  a \\<le> s \\<longrightarrow> P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. P (subpath a s g) z", "by auto"], ["proof (state)\nthis:\n  P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  P (subpath a s g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  P (subpath a s g) z\n  a < b\n\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "unfolding s'_def subpath_def"], ["proof (prove)\nusing this:\n  P (\\<lambda>x. g ((s - a) * x + a)) z\n  a < b\n\ngoal (1 subgoal):\n 1. P (\\<lambda>x. g ((b - a) * (((s - a) / (b - a) - 0) * x + 0) + a)) z", "by simp"], ["proof (state)\nthis:\n  P (subpath 0 s' (subpath a b g)) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (subpath 0 s' (subpath a b g)) z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "show \"s' = 0 \\<or> Re (subpath a b g s') = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "have ?thesis when \"s=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "using that"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "unfolding s'_def"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. (s - a) / (b - a) = 0 \\<or>\n    Re (subpath a b g ((s - a) / (b - a))) = Re z", "by auto"], ["proof (state)\nthis:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "moreover"], ["proof (state)\nthis:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "have ?thesis when \"Re (g s - z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "using that"], ["proof (prove)\nusing this:\n  Re (g s - z) = 0\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "unfolding s'_def subpath_def"], ["proof (prove)\nusing this:\n  Re (g s - z) = 0\n\ngoal (1 subgoal):\n 1. (s - a) / (b - a) = 0 \\<or>\n    Re (g ((b - a) * ((s - a) / (b - a)) + a)) = Re z", "by auto"], ["proof (state)\nthis:\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "ultimately"], ["proof (chain)\npicking this:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "using \\<open>s = a \\<or> Re (g s - z) = 0\\<close>"], ["proof (prove)\nusing this:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n  s = a \\<or> Re (g s - z) = 0\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "by auto"], ["proof (state)\nthis:\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "then"], ["proof (chain)\npicking this:\n  P (subpath a b g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  P (subpath a b g) z\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "by auto"], ["proof (state)\nthis:\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<noteq> b \\<Longrightarrow>\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "ultimately"], ["proof (chain)\npicking this:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n  a \\<noteq> b \\<Longrightarrow>\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z", "show ?case"], ["proof (prove)\nusing this:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n  a \\<noteq> b \\<Longrightarrow>\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "by auto"], ["proof (state)\nthis:\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "case (insertI_2 s a b)"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  a \\<le> s \\<longrightarrow> P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have ?case when \"a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "using sub0[of \"subpath a b g\"] that"], ["proof (prove)\nusing this:\n  P (subpath 0 0 (subpath a b g)) ?z\n  a = b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  P (\\<lambda>x. g ((b - a) * ((0 - 0) * x + 0) + a)) ?z\n  a = b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (\\<lambda>x. g ((b - a) * x + a)) z", "by auto"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "moreover"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have ?case when \"a\\<noteq>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have \"b>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b", "using that \\<open>s \\<in> {a..<b}\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. a < b", "by auto"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "define s'::real where \"s'=(s-a)/(b-a)\""], ["proof (state)\nthis:\n  s' = (s - a) / (b - a)\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "have \"P (subpath a b g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (subpath a b g) z", "proof (rule subNEq[of s' \"subpath a b g\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. s' \\<in> {0..<1}\n 2. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 3. \\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) \\<noteq> Re z\n 4. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 5. P (subpath 0 s' (subpath a b g)) z", "show \"\\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) \\<noteq> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) \\<noteq> Re z", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {s'<..<1} \\<Longrightarrow>\n       Re (subpath a b g t) \\<noteq> Re z", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {s'<..<1} \\<Longrightarrow>\n       Re (subpath a b g t) \\<noteq> Re z", "assume \"t \\<in> {s'<..<1}\""], ["proof (state)\nthis:\n  t \\<in> {s'<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {s'<..<1} \\<Longrightarrow>\n       Re (subpath a b g t) \\<noteq> Re z", "then"], ["proof (chain)\npicking this:\n  t \\<in> {s'<..<1}", "have \"(b - a) * t + a\\<in>{s<..<b}\""], ["proof (prove)\nusing this:\n  t \\<in> {s'<..<1}\n\ngoal (1 subgoal):\n 1. (b - a) * t + a \\<in> {s<..<b}", "unfolding s'_def"], ["proof (prove)\nusing this:\n  t \\<in> {(s - a) / (b - a)<..<1}\n\ngoal (1 subgoal):\n 1. (b - a) * t + a \\<in> {s<..<b}", "using \\<open>b>a\\<close> \\<open>s \\<in> {a..<b}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {(s - a) / (b - a)<..<1}\n  a < b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. (b - a) * t + a \\<in> {s<..<b}", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s + a * t < a + b * t; t < 1; a \\<le> s; s < b\\<rbrakk>\n    \\<Longrightarrow> a + b * t < b + a * t", "by (sos \"((((A<0 * (A<1 * A<2)) * R<1) + (((A<=1 * (A<0 * R<1)) * (R<1 * [1]^2)) + \n              ((A<=0 * (A<0 * (A<1 * R<1))) * (R<1 * [1]^2)))))\")"], ["proof (state)\nthis:\n  (b - a) * t + a \\<in> {s<..<b}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {s'<..<1} \\<Longrightarrow>\n       Re (subpath a b g t) \\<noteq> Re z", "then"], ["proof (chain)\npicking this:\n  (b - a) * t + a \\<in> {s<..<b}", "have \"Re (g ((b - a) * t + a) - z) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (b - a) * t + a \\<in> {s<..<b}\n\ngoal (1 subgoal):\n 1. Re (g ((b - a) * t + a) - z) \\<noteq> 0", "using insertI_2(3)[rule_format,of \"(b - a) * t + a\"]"], ["proof (prove)\nusing this:\n  (b - a) * t + a \\<in> {s<..<b}\n  (b - a) * t + a \\<in> {s<..<b} \\<Longrightarrow>\n  Re (g ((b - a) * t + a) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (g ((b - a) * t + a) - z) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Re (g ((b - a) * t + a) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {s'<..<1} \\<Longrightarrow>\n       Re (subpath a b g t) \\<noteq> Re z", "then"], ["proof (chain)\npicking this:\n  Re (g ((b - a) * t + a) - z) \\<noteq> 0", "show \"Re (subpath a b g t) \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  Re (g ((b - a) * t + a) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (subpath a b g t) \\<noteq> Re z", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  Re (g ((b - a) * t + a) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (g ((b - a) * t + a)) \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (subpath a b g t) \\<noteq> Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{s'<..<1}. Re (subpath a b g t) \\<noteq> Re z\n\ngoal (4 subgoals):\n 1. s' \\<in> {0..<1}\n 2. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 3. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 4. P (subpath 0 s' (subpath a b g)) z", "show \"finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "proof (cases \"s=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 2. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "case True"], ["proof (state)\nthis:\n  s = a\n\ngoal (2 subgoals):\n 1. s = a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n 2. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  s = a", "show ?thesis"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "unfolding s'_def subpath_def"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments\n     (\\<lambda>x. g ((b - a) * (((s - a) / (b - a) - 0) * x + 0) + a)) z", "by (auto intro:finite_ReZ_segments_constI)"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "case False"], ["proof (state)\nthis:\n  s \\<noteq> a\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "have \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "using insertI_2(4)"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s", "have \"finite_Psegments ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0 1\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a))\n     0 1", "apply (elim finite_Psegments_pos_linear[of _ \"s-a\" 0 a 1,simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < s", "using False \\<open>s\\<in>{a..<b}\\<close>"], ["proof (prove)\nusing this:\n  s \\<noteq> a\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. a < s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1\n\ngoal (1 subgoal):\n 1. s \\<noteq> a \\<Longrightarrow>\n    finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  finite_Psegments\n   ((\\<lambda>t. Re (g t - z) = 0) \\<circ> (\\<lambda>t. (s - a) * t + a)) 0\n   1\n  a < b\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath 0 s' (subpath a b g)) z", "unfolding finite_ReZ_segments_def subpath_def s'_def comp_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>x. Re (g ((s - a) * x + a) - z) = 0) 0 1\n  a < b\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t.\n         Re (g ((b - a) * (((s - a) / (b - a) - 0) * t + 0) + a) - z) = 0)\n     0 1", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath 0 s' (subpath a b g)) z\n\ngoal (3 subgoals):\n 1. s' \\<in> {0..<1}\n 2. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 3. P (subpath 0 s' (subpath a b g)) z", "show \"s' \\<in> {0..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> {0..<1}", "using \\<open>b>a\\<close> \\<open>s\\<in>{a..<b}\\<close>"], ["proof (prove)\nusing this:\n  a < b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. s' \\<in> {0..<1}", "unfolding s'_def"], ["proof (prove)\nusing this:\n  a < b\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. (s - a) / (b - a) \\<in> {0..<1}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  s' \\<in> {0..<1}\n\ngoal (2 subgoals):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z\n 2. P (subpath 0 s' (subpath a b g)) z", "show \"P (subpath 0 s' (subpath a b g)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "have \"P (subpath a s g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (subpath a s g) z", "using insertI_2(1,5)"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  a \\<le> s \\<longrightarrow> P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. P (subpath a s g) z", "by auto"], ["proof (state)\nthis:\n  P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "then"], ["proof (chain)\npicking this:\n  P (subpath a s g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  P (subpath a s g) z\n\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  P (subpath a s g) z\n  a < b\n\ngoal (1 subgoal):\n 1. P (subpath 0 s' (subpath a b g)) z", "unfolding s'_def subpath_def"], ["proof (prove)\nusing this:\n  P (\\<lambda>x. g ((s - a) * x + a)) z\n  a < b\n\ngoal (1 subgoal):\n 1. P (\\<lambda>x. g ((b - a) * (((s - a) / (b - a) - 0) * x + 0) + a)) z", "by simp"], ["proof (state)\nthis:\n  P (subpath 0 s' (subpath a b g)) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (subpath 0 s' (subpath a b g)) z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "show \"s' = 0 \\<or> Re (subpath a b g s') = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "have ?thesis when \"s=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "using that"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "unfolding s'_def"], ["proof (prove)\nusing this:\n  s = a\n\ngoal (1 subgoal):\n 1. (s - a) / (b - a) = 0 \\<or>\n    Re (subpath a b g ((s - a) / (b - a))) = Re z", "by auto"], ["proof (state)\nthis:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "moreover"], ["proof (state)\nthis:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "have ?thesis when \"Re (g s - z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "using that"], ["proof (prove)\nusing this:\n  Re (g s - z) = 0\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "unfolding s'_def subpath_def"], ["proof (prove)\nusing this:\n  Re (g s - z) = 0\n\ngoal (1 subgoal):\n 1. (s - a) / (b - a) = 0 \\<or>\n    Re (g ((b - a) * ((s - a) / (b - a)) + a)) = Re z", "by auto"], ["proof (state)\nthis:\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "ultimately"], ["proof (chain)\npicking this:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "using \\<open>s = a \\<or> Re (g s - z) = 0\\<close>"], ["proof (prove)\nusing this:\n  s = a \\<Longrightarrow> s' = 0 \\<or> Re (subpath a b g s') = Re z\n  Re (g s - z) = 0 \\<Longrightarrow>\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n  s = a \\<or> Re (g s - z) = 0\n\ngoal (1 subgoal):\n 1. s' = 0 \\<or> Re (subpath a b g s') = Re z", "by auto"], ["proof (state)\nthis:\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' = 0 \\<or> Re (subpath a b g s') = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "then"], ["proof (chain)\npicking this:\n  P (subpath a b g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "using \\<open>b>a\\<close>"], ["proof (prove)\nusing this:\n  P (subpath a b g) z\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "by auto"], ["proof (state)\nthis:\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<noteq> b \\<Longrightarrow>\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        a \\<le> s \\<longrightarrow> P (subpath a s g) z\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z", "ultimately"], ["proof (chain)\npicking this:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n  a \\<noteq> b \\<Longrightarrow>\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z", "show ?case"], ["proof (prove)\nusing this:\n  a = b \\<Longrightarrow> a \\<le> b \\<longrightarrow> P (subpath a b g) z\n  a \\<noteq> b \\<Longrightarrow>\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<longrightarrow> P (subpath a b g) z", "by auto"], ["proof (state)\nthis:\n  a \\<le> b \\<longrightarrow> P (subpath a b g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> 1 \\<longrightarrow> P (subpath 0 1 g) z\n\ngoal (1 subgoal):\n 1. P g z", "then"], ["proof (chain)\npicking this:\n  0 \\<le> 1 \\<longrightarrow> P (subpath 0 1 g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> 1 \\<longrightarrow> P (subpath 0 1 g) z\n\ngoal (1 subgoal):\n 1. P g z", "by auto"], ["proof (state)\nthis:\n  P g z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_shiftpah:\n  assumes \"finite_ReZ_segments g z\" \"s\\<in>{0..1}\" \"path g\" and loop:\"pathfinish g = pathstart g\" \n  shows \"finite_ReZ_segments (shiftpath s g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "have \"finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1-s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)", "have \"finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1", "using assms finite_Psegments_included[of _ 0 1 s]"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  s \\<in> {0..1}\n  path g\n  pathfinish g = pathstart g\n  \\<lbrakk>finite_Psegments ?P 0 1; 0 \\<le> s; ?c \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P s ?c\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n  s \\<in> {0..1}\n  path g\n  pathfinish g = pathstart g\n  \\<lbrakk>finite_Psegments ?P 0 1; 0 \\<le> s; ?c \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P s ?c\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1", "by force"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1", "have \"finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1-s)\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)", "using finite_Psegments_pos_linear[of \"\\<lambda>t. Re (g t - z) =0\" 1 0 s \"1-s\",simplified]"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1 \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g t) = Re z) \\<circ> (\\<lambda>t. t + s)) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)", "unfolding comp_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) s 1 \\<Longrightarrow>\n  finite_Psegments (\\<lambda>x. Re (g (x + s)) = Re z) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)", "unfolding shiftpath_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g (s + t) - z) = 0) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t.\n         Re ((if s + t \\<le> 1 then g (s + t) else g (s + t - 1)) - z) = 0)\n     0 (1 - s)", "apply (elim finite_Psegments_congE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1 - s\\<rbrakk>\n       \\<Longrightarrow> (Re (g (s + t) - z) = 0) =\n                         (Re ((if s + t \\<le> 1 then g (s + t)\n                               else g (s + t - 1)) -\n                              z) =\n                          0)", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1 - s\\<rbrakk>\n       \\<Longrightarrow> (Re (g (s + t) - z) = 0) =\n                         (Re ((if s + t \\<le> 1 then g (s + t)\n                               else g (s + t - 1)) -\n                              z) =\n                          0)", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "moreover"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "have \"finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1-s) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1", "have \"finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s \""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s", "using assms finite_Psegments_included"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  s \\<in> {0..1}\n  path g\n  pathfinish g = pathstart g\n  \\<lbrakk>finite_Psegments ?P ?a ?d; ?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P ?b ?c\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n  s \\<in> {0..1}\n  path g\n  pathfinish g = pathstart g\n  \\<lbrakk>finite_Psegments ?P ?a ?d; ?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments ?P ?b ?c\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s", "by force"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s", "have \"finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1-s) 1\""], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1", "using finite_Psegments_pos_linear[of \"\\<lambda>t. Re (g t - z) =0\" 1 \"1-s\" \"s-1\" 1,simplified]"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g t) = Re z) \\<circ> (\\<lambda>t. t + (s - 1))) (1 - s)\n   1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1", "unfolding comp_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s\n  finite_Psegments (\\<lambda>t. Re (g t) = Re z) 0 s \\<Longrightarrow>\n  finite_Psegments (\\<lambda>x. Re (g (x + (s - 1))) = Re z) (1 - s) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1", "then"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1", "unfolding shiftpath_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g (s + t - 1) - z) = 0) (1 - s) 1\n\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t.\n         Re ((if s + t \\<le> 1 then g (s + t) else g (s + t - 1)) - z) = 0)\n     (1 - s) 1", "apply (elim finite_Psegments_congE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>1 - s < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (Re (g (s + t - 1) - z) = 0) =\n                         (Re ((if s + t \\<le> 1 then g (s + t)\n                               else g (s + t - 1)) -\n                              z) =\n                          0)", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>1 - s < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (Re (g (s + t - 1) - z) = 0) =\n                         (Re ((if s + t \\<le> 1 then g (s + t)\n                               else g (s + t - 1)) -\n                              z) =\n                          0)", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "moreover"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "have \"1 - s \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - s \\<in> {0..1}", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 1 - s \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  1 - s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "moreover"], ["proof (state)\nthis:\n  1 - s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "have \"closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})", "let ?f = \"\\<lambda>x. Re (shiftpath s g x - z)\""], ["proof (state)\ngoal (1 subgoal):\n 1. closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})", "have \"continuous_on {0..1} ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (shiftpath s g x - z))", "using path_shiftpath[OF \\<open>path g\\<close> loop \\<open>s\\<in>{0..1}\\<close>]"], ["proof (prove)\nusing this:\n  path (shiftpath s g)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (shiftpath s g x - z))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} (shiftpath s g)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (shiftpath s g x - z))", "by (auto intro: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. Re (shiftpath s g x - z))\n\ngoal (1 subgoal):\n 1. closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})", "from continuous_closed_preimage_constant[OF this,of 0,simplified]"], ["proof (chain)\npicking this:\n  closed {x. 0 \\<le> x \\<and> x \\<le> 1 \\<and> Re (shiftpath s g x) = Re z}", "show ?thesis"], ["proof (prove)\nusing this:\n  closed {x. 0 \\<le> x \\<and> x \\<le> 1 \\<and> Re (shiftpath s g x) = Re z}\n\ngoal (1 subgoal):\n 1. closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})", "apply (elim arg_elim[of closed])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 0 \\<le> x \\<and> x \\<le> 1 \\<and> Re (shiftpath s g x) = Re z} =\n    {x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1}", "by force"], ["proof (state)\nthis:\n  closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "ultimately"], ["proof (chain)\npicking this:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1\n  1 - s \\<in> {0..1}\n  closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1\n  1 - s \\<in> {0..1}\n  closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 (1 - s)\n  finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) (1 - s) 1\n  1 - s \\<in> {0..1}\n  closed ({x. Re (shiftpath s g x - z) = 0} \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (shiftpath s g t - z) = 0) 0 1", "by (rule finite_Psegments_combine[where b=\"1-s\"])"], ["proof (state)\nthis:\n  finite_ReZ_segments (shiftpath s g) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_imp_finite_ReZ_segments:\n  assumes \"finite {t. Re (g t - z) = 0 \\<and> 0 \\<le> t \\<and> t\\<le>1}\"\n  shows \"finite_ReZ_segments g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "define P where \"P = (\\<lambda>t. Re (g t - z) = 0)\""], ["proof (state)\nthis:\n  P = (\\<lambda>t. Re (g t - z) = 0)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "define rs where \"rs=(\\<lambda>b. {t. P t \\<and> 0 < t \\<and> t<b})\""], ["proof (state)\nthis:\n  rs = (\\<lambda>b. {t. P t \\<and> 0 < t \\<and> t < b})\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "have \"finite_Psegments P 0 b\" when \"finite (rs b)\" \"b>0\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "using that"], ["proof (prove)\nusing this:\n  finite (rs b)\n  0 < b\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "proof (induct \"card (rs b)\" arbitrary:b rule:nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>m<card (rs b).\n                   \\<forall>x.\n                      m = card (rs x) \\<longrightarrow>\n                      finite (rs x) \\<longrightarrow>\n                      0 < x \\<longrightarrow> finite_Psegments P 0 x;\n        finite (rs b); 0 < b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P 0 b", "case ind:1"], ["proof (state)\nthis:\n  \\<forall>m<card (rs b).\n     \\<forall>x.\n        m = card (rs x) \\<longrightarrow>\n        finite (rs x) \\<longrightarrow>\n        0 < x \\<longrightarrow> finite_Psegments P 0 x\n  finite (rs b)\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>m<card (rs b).\n                   \\<forall>x.\n                      m = card (rs x) \\<longrightarrow>\n                      finite (rs x) \\<longrightarrow>\n                      0 < x \\<longrightarrow> finite_Psegments P 0 x;\n        finite (rs b); 0 < b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P 0 b", "have ?case when \"rs b= {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "apply (rule finite_Psegments.intros(3)[of 0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<in> {0..<b}\n 2. 0 = 0 \\<or> P 0\n 3. \\<forall>t\\<in>{0<..<b}. \\<not> P t\n 4. finite_Psegments P 0 0", "using that \\<open>0 < b\\<close>"], ["proof (prove)\nusing this:\n  rs b = {}\n  0 < b\n\ngoal (4 subgoals):\n 1. 0 \\<in> {0..<b}\n 2. 0 = 0 \\<or> P 0\n 3. \\<forall>t\\<in>{0<..<b}. \\<not> P t\n 4. finite_Psegments P 0 0", "unfolding rs_def"], ["proof (prove)\nusing this:\n  {t. P t \\<and> 0 < t \\<and> t < b} = {}\n  0 < b\n\ngoal (4 subgoals):\n 1. 0 \\<in> {0..<b}\n 2. 0 = 0 \\<or> P 0\n 3. \\<forall>t\\<in>{0<..<b}. \\<not> P t\n 4. finite_Psegments P 0 0", "by (auto intro:finite_Psegments.intros)"], ["proof (state)\nthis:\n  rs b = {} \\<Longrightarrow> finite_Psegments P 0 b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>m<card (rs b).\n                   \\<forall>x.\n                      m = card (rs x) \\<longrightarrow>\n                      finite (rs x) \\<longrightarrow>\n                      0 < x \\<longrightarrow> finite_Psegments P 0 x;\n        finite (rs b); 0 < b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P 0 b", "moreover"], ["proof (state)\nthis:\n  rs b = {} \\<Longrightarrow> finite_Psegments P 0 b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>m<card (rs b).\n                   \\<forall>x.\n                      m = card (rs x) \\<longrightarrow>\n                      finite (rs x) \\<longrightarrow>\n                      0 < x \\<longrightarrow> finite_Psegments P 0 x;\n        finite (rs b); 0 < b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P 0 b", "have ?case when \"rs b\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "define lj where \"lj = Max (rs b)\""], ["proof (state)\nthis:\n  lj = Max (rs b)\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "have \"0<lj\" \"lj<b\" \"P lj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lj &&& lj < b &&& P lj", "using Max_in[OF \\<open>finite (rs b)\\<close> \\<open>rs b\\<noteq>{}\\<close>,folded lj_def]"], ["proof (prove)\nusing this:\n  lj \\<in> rs b\n\ngoal (1 subgoal):\n 1. 0 < lj &&& lj < b &&& P lj", "unfolding rs_def"], ["proof (prove)\nusing this:\n  lj \\<in> {t. P t \\<and> 0 < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. 0 < lj &&& lj < b &&& P lj", "by auto"], ["proof (state)\nthis:\n  0 < lj\n  lj < b\n  P lj\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "proof (rule finite_Psegments.intros(3)[of lj])"], ["proof (state)\ngoal (4 subgoals):\n 1. lj \\<in> {0..<b}\n 2. lj = 0 \\<or> P lj\n 3. \\<forall>t\\<in>{lj<..<b}. \\<not> P t\n 4. finite_Psegments P 0 lj", "show \"lj \\<in> {0..<b}\" \" lj = 0 \\<or> P lj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lj \\<in> {0..<b} &&& lj = 0 \\<or> P lj", "using \\<open>0<lj\\<close> \\<open>lj<b\\<close> \\<open>P lj\\<close>"], ["proof (prove)\nusing this:\n  0 < lj\n  lj < b\n  P lj\n\ngoal (1 subgoal):\n 1. lj \\<in> {0..<b} &&& lj = 0 \\<or> P lj", "by auto"], ["proof (state)\nthis:\n  lj \\<in> {0..<b}\n  lj = 0 \\<or> P lj\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{lj<..<b}. \\<not> P t\n 2. finite_Psegments P 0 lj", "show \"\\<forall>t\\<in>{lj<..<b}. \\<not> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{lj<..<b}. \\<not> P t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t) \\<Longrightarrow> False", "assume \" \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t) \""], ["proof (state)\nthis:\n  \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t)", "obtain t where t:\"P t\" \"lj < t\" \"t < b\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>P t; lj < t; t < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P t\n  lj < t\n  t < b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  P t\n  lj < t\n  t < b", "have \"t\\<in>rs b\""], ["proof (prove)\nusing this:\n  P t\n  lj < t\n  t < b\n\ngoal (1 subgoal):\n 1. t \\<in> rs b", "unfolding rs_def"], ["proof (prove)\nusing this:\n  P t\n  lj < t\n  t < b\n\ngoal (1 subgoal):\n 1. t \\<in> {t. P t \\<and> 0 < t \\<and> t < b}", "using \\<open>lj>0\\<close>"], ["proof (prove)\nusing this:\n  P t\n  lj < t\n  t < b\n  0 < lj\n\ngoal (1 subgoal):\n 1. t \\<in> {t. P t \\<and> 0 < t \\<and> t < b}", "by auto"], ["proof (state)\nthis:\n  t \\<in> rs b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<in> rs b", "have \"t\\<le>lj\""], ["proof (prove)\nusing this:\n  t \\<in> rs b\n\ngoal (1 subgoal):\n 1. t \\<le> lj", "using Max_ge[OF \\<open>finite (rs b)\\<close>,of t]"], ["proof (prove)\nusing this:\n  t \\<in> rs b\n  t \\<in> rs b \\<Longrightarrow> t \\<le> Max (rs b)\n\ngoal (1 subgoal):\n 1. t \\<le> lj", "unfolding lj_def"], ["proof (prove)\nusing this:\n  t \\<in> rs b\n  t \\<in> rs b \\<Longrightarrow> t \\<le> Max (rs b)\n\ngoal (1 subgoal):\n 1. t \\<le> Max (rs b)", "by auto"], ["proof (state)\nthis:\n  t \\<le> lj\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{lj<..<b}. \\<not> P t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<le> lj", "show False"], ["proof (prove)\nusing this:\n  t \\<le> lj\n\ngoal (1 subgoal):\n 1. False", "using \\<open>t>lj\\<close>"], ["proof (prove)\nusing this:\n  t \\<le> lj\n  lj < t\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{lj<..<b}. \\<not> P t\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 lj", "show \"finite_Psegments P 0 lj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments P 0 lj", "proof (rule ind.hyps[rule_format,of \"card (rs lj)\" lj,simplified])"], ["proof (state)\ngoal (3 subgoals):\n 1. card (rs lj) < card (rs b)\n 2. finite (rs lj)\n 3. 0 < lj", "show \"finite (rs lj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (rs lj)", "using \\<open>finite (rs b)\\<close>"], ["proof (prove)\nusing this:\n  finite (rs b)\n\ngoal (1 subgoal):\n 1. finite (rs lj)", "unfolding rs_def"], ["proof (prove)\nusing this:\n  finite {t. P t \\<and> 0 < t \\<and> t < b}\n\ngoal (1 subgoal):\n 1. finite {t. P t \\<and> 0 < t \\<and> t < lj}", "using \\<open>lj<b\\<close>"], ["proof (prove)\nusing this:\n  finite {t. P t \\<and> 0 < t \\<and> t < b}\n  lj < b\n\ngoal (1 subgoal):\n 1. finite {t. P t \\<and> 0 < t \\<and> t < lj}", "by (auto elim!:rev_finite_subset )"], ["proof (state)\nthis:\n  finite (rs lj)\n\ngoal (2 subgoals):\n 1. card (rs lj) < card (rs b)\n 2. 0 < lj", "show \"card (rs lj) < card (rs b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (rs lj) < card (rs b)", "apply (rule psubset_card_mono[OF \\<open>finite (rs b)\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs lj \\<subset> rs b", "using Max_in \\<open>finite (rs lj)\\<close> \\<open>lj < b\\<close> lj_def rs_def that"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n  finite (rs lj)\n  lj < b\n  lj = Max (rs b)\n  rs = (\\<lambda>b. {t. P t \\<and> 0 < t \\<and> t < b})\n  rs b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rs lj \\<subset> rs b", "by fastforce"], ["proof (state)\nthis:\n  card (rs lj) < card (rs b)\n\ngoal (1 subgoal):\n 1. 0 < lj", "show \"0 < lj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lj", "using \\<open>0<lj\\<close>"], ["proof (prove)\nusing this:\n  0 < lj\n\ngoal (1 subgoal):\n 1. 0 < lj", "."], ["proof (state)\nthis:\n  0 < lj\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P 0 lj\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_Psegments P 0 b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs b \\<noteq> {} \\<Longrightarrow> finite_Psegments P 0 b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>m<card (rs b).\n                   \\<forall>x.\n                      m = card (rs x) \\<longrightarrow>\n                      finite (rs x) \\<longrightarrow>\n                      0 < x \\<longrightarrow> finite_Psegments P 0 x;\n        finite (rs b); 0 < b\\<rbrakk>\n       \\<Longrightarrow> finite_Psegments P 0 b", "ultimately"], ["proof (chain)\npicking this:\n  rs b = {} \\<Longrightarrow> finite_Psegments P 0 b\n  rs b \\<noteq> {} \\<Longrightarrow> finite_Psegments P 0 b", "show ?case"], ["proof (prove)\nusing this:\n  rs b = {} \\<Longrightarrow> finite_Psegments P 0 b\n  rs b \\<noteq> {} \\<Longrightarrow> finite_Psegments P 0 b\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 b", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P 0 b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite (rs ?b); 0 < ?b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P 0 ?b\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>finite (rs ?b); 0 < ?b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P 0 ?b\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "have \"finite (rs 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (rs 1)", "using assms"], ["proof (prove)\nusing this:\n  finite {t. Re (g t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite (rs 1)", "unfolding rs_def P_def"], ["proof (prove)\nusing this:\n  finite {t. Re (g t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {t. Re (g t - z) = 0 \\<and> 0 < t \\<and> t < 1}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite (rs 1)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (rs ?b); 0 < ?b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P 0 ?b\n  finite (rs 1)", "have \"finite_Psegments P 0 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (rs ?b); 0 < ?b\\<rbrakk>\n  \\<Longrightarrow> finite_Psegments P 0 ?b\n  finite (rs 1)\n\ngoal (1 subgoal):\n 1. finite_Psegments P 0 1", "by auto"], ["proof (state)\nthis:\n  finite_Psegments P 0 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "then"], ["proof (chain)\npicking this:\n  finite_Psegments P 0 1", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_Psegments P 0 1\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "unfolding P_def finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "."], ["proof (state)\nthis:\n  finite_ReZ_segments g z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_poly_linepath:\n  shows \"finite_ReZ_segments (poly p o linepath a b) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "define P where \"P=map_poly Re (pcompose (p-[:z:]) [:a,b-a:])\""], ["proof (state)\nthis:\n  P = map_poly Re ((p - [:z:]) \\<circ>\\<^sub>p [:a, b - a:])\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "have *:\"Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<longleftrightarrow> poly P t=0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> linepath a b) t - z) = 0) = (poly P t = 0)", "unfolding inner_complex_def P_def linepath_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (poly p ((1 - t) *\\<^sub>R a + t *\\<^sub>R b) - z) = 0) =\n    (poly (map_poly Re ((p - [:z:]) \\<circ>\\<^sub>p [:a, b - a:])) t = 0)", "apply (subst Re_poly_of_real[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (poly p ((1 - t) *\\<^sub>R a + t *\\<^sub>R b) - z) = 0) =\n    (Re (poly ((p - [:z:]) \\<circ>\\<^sub>p [:a, b - a:])\n          (complex_of_real t)) =\n     0)", "by (auto simp add: algebra_simps poly_pcompose scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (Re ((poly p \\<circ> linepath a b) ?t - z) = 0) = (poly P ?t = 0)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "have ?thesis when \"P\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "have \"finite {t. poly P t=0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. poly P t = 0}", "using that poly_roots_finite"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite {t. poly P t = 0}", "by auto"], ["proof (state)\nthis:\n  finite {t. poly P t = 0}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "then"], ["proof (chain)\npicking this:\n  finite {t. poly P t = 0}", "have \"finite {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (prove)\nusing this:\n  finite {t. poly P t = 0}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "using *"], ["proof (prove)\nusing this:\n  finite {t. poly P t = 0}\n  (Re ((poly p \\<circ> linepath a b) ?t - z) = 0) = (poly P ?t = 0)\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite\n   {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "then"], ["proof (chain)\npicking this:\n  finite\n   {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "using finite_imp_finite_ReZ_segments[of \"poly p o linepath a b\" z]"], ["proof (prove)\nusing this:\n  finite\n   {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Re ((poly p \\<circ> linepath a b) t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<noteq> 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "moreover"], ["proof (state)\nthis:\n  P \\<noteq> 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "have ?thesis when \"P=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "unfolding finite_ReZ_segments_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments\n     (\\<lambda>t. Re ((poly p \\<circ> linepath a b) t - z) = 0) 0 1", "apply (rule finite_Psegments_constI[where c=True])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (Re ((poly p \\<circ> linepath a b) t - z) = 0) =\n                         True", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (poly P t = 0) = True", "using that"], ["proof (prove)\nusing this:\n  P = 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> (poly P t = 0) = True", "by auto"], ["proof (state)\nthis:\n  P = 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "ultimately"], ["proof (chain)\npicking this:\n  P \\<noteq> 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n  P = 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<noteq> 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n  P = 0 \\<Longrightarrow>\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> linepath a b) z", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (poly p \\<circ> linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma part_circlepath_half_finite_inter:\n  assumes \"st\\<noteq>tt\" \"r\\<noteq>0\" \"c\\<noteq>0\"\n  shows \"finite {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\" (is \"finite ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "let ?S = \"{\\<theta>. (z0+r*exp (\\<i> * \\<theta> )) \\<bullet> c = d \\<and> \\<theta> \\<in> closed_segment st tt}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "define S where \"S \\<equiv> {\\<theta>. (z0+r*exp (\\<i> * \\<theta> )) \\<bullet> c = d \\<and> \\<theta> \\<in> closed_segment st tt}\""], ["proof (state)\nthis:\n  S \\<equiv>\n  {\\<theta>.\n   (z0 +\n    complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)) \\<bullet>\n   c =\n   d \\<and>\n   \\<theta> \\<in> closed_segment st tt}\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"S = linepath st tt ` ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S =\n    linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\n 2. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "define g where \"g\\<equiv>(\\<lambda>t. (t-st)/(tt -st))\""], ["proof (state)\nthis:\n  g \\<equiv> \\<lambda>t. (t - st) / (tt - st)\n\ngoal (2 subgoals):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\n 2. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "have \"0\\<le>g t\" \"g t\\<le>1\" when \"t \\<in> closed_segment st tt \" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> g t &&& g t \\<le> 1", "using that \\<open>st\\<noteq>tt\\<close> closed_segment_eq_real_ivl"], ["proof (prove)\nusing this:\n  t \\<in> closed_segment st tt\n  st \\<noteq> tt\n  closed_segment ?a ?b = (if ?a \\<le> ?b then {?a..?b} else {?b..?a})\n\ngoal (1 subgoal):\n 1. 0 \\<le> g t &&& g t \\<le> 1", "unfolding  g_def real_scaleR_def"], ["proof (prove)\nusing this:\n  t \\<in> closed_segment st tt\n  st \\<noteq> tt\n  closed_segment ?a ?b = (if ?a \\<le> ?b then {?a..?b} else {?b..?a})\n\ngoal (1 subgoal):\n 1. 0 \\<le> (t - st) / (tt - st) &&& (t - st) / (tt - st) \\<le> 1", "by (auto simp add:divide_simps)"], ["proof (state)\nthis:\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> 0 \\<le> g ?t\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> g ?t \\<le> 1\n\ngoal (2 subgoals):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\n 2. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "moreover"], ["proof (state)\nthis:\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> 0 \\<le> g ?t\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> g ?t \\<le> 1\n\ngoal (2 subgoals):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\n 2. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "have \"linepath st tt (g t) =t\" \"g (linepath st tt t) = t\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath st tt (g t) = t &&& g (linepath st tt t) = t", "unfolding linepath_def g_def real_scaleR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (t - st) / (tt - st)) * st + (t - st) / (tt - st) * tt = t &&&\n    ((1 - t) * st + t * tt - st) / (tt - st) = t", "using \\<open>st\\<noteq>tt\\<close>"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n\ngoal (1 subgoal):\n 1. (1 - (t - st) / (tt - st)) * st + (t - st) / (tt - st) * tt = t &&&\n    ((1 - t) * st + t * tt - st) / (tt - st) = t", "apply (simp_all add:divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    (tt - t) * st + (t - st) * tt = t * (tt - st)\n 2. st \\<noteq> tt \\<Longrightarrow>\n    (1 - t) * st + t * tt - st = t * (tt - st)", "by (auto simp add:algebra_simps )"], ["proof (state)\nthis:\n  linepath st tt (g ?t) = ?t\n  g (linepath st tt ?t) = ?t\n\ngoal (2 subgoals):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\n 2. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "ultimately"], ["proof (chain)\npicking this:\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> 0 \\<le> g ?t\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> g ?t \\<le> 1\n  linepath st tt (g ?t) = ?t\n  g (linepath st tt ?t) = ?t", "have \"x\\<in>linepath st tt ` ?T\" when \"x\\<in>S\" for x"], ["proof (prove)\nusing this:\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> 0 \\<le> g ?t\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> g ?t \\<le> 1\n  linepath st tt (g ?t) = ?t\n  g (linepath st tt ?t) = ?t\n\ngoal (1 subgoal):\n 1. x \\<in> linepath st tt `\n            {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                0 \\<le> t \\<and> t \\<le> 1}", "using that"], ["proof (prove)\nusing this:\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> 0 \\<le> g ?t\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> g ?t \\<le> 1\n  linepath st tt (g ?t) = ?t\n  g (linepath st tt ?t) = ?t\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> linepath st tt `\n            {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                0 \\<le> t \\<and> t \\<le> 1}", "unfolding S_def"], ["proof (prove)\nusing this:\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> 0 \\<le> g ?t\n  ?t \\<in> closed_segment st tt \\<Longrightarrow> g ?t \\<le> 1\n  linepath st tt (g ?t) = ?t\n  g (linepath st tt ?t) = ?t\n  x \\<in> {\\<theta>.\n           (z0 +\n            complex_of_real r *\n            exp (\\<i> * complex_of_real \\<theta>)) \\<bullet>\n           c =\n           d \\<and>\n           \\<theta> \\<in> closed_segment st tt}\n\ngoal (1 subgoal):\n 1. x \\<in> linepath st tt `\n            {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                0 \\<le> t \\<and> t \\<le> 1}", "by (auto intro!:image_eqI[where x=\"g x\"] simp add:part_circlepath_def)"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow>\n  ?x \\<in> linepath st tt `\n           {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\n 2. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> S \\<Longrightarrow>\n  ?x \\<in> linepath st tt `\n           {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}", "show \"S \\<subseteq> linepath st tt ` ?T\""], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow>\n  ?x \\<in> linepath st tt `\n           {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. S \\<subseteq> linepath st tt `\n                  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> linepath st tt `\n                {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "have \"x\\<in>S\" when \"x\\<in>linepath st tt ` ?T\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "using that"], ["proof (prove)\nusing this:\n  x \\<in> linepath st tt `\n          {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n              0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. x \\<in> S", "unfolding part_circlepath_def S_def"], ["proof (prove)\nusing this:\n  x \\<in> linepath st tt `\n          {t. (z0 +\n               complex_of_real r *\n               exp (\\<i> * complex_of_real (linepath st tt t))) \\<bullet>\n              c =\n              d \\<and>\n              0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. x \\<in> {\\<theta>.\n             (z0 +\n              complex_of_real r *\n              exp (\\<i> * complex_of_real \\<theta>)) \\<bullet>\n             c =\n             d \\<and>\n             \\<theta> \\<in> closed_segment st tt}", "by (auto simp add: linepath_in_path)"], ["proof (state)\nthis:\n  ?x \\<in> linepath st tt `\n           {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n  ?x \\<in> S\n\ngoal (1 subgoal):\n 1. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> linepath st tt `\n           {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n  ?x \\<in> S", "show \"linepath st tt ` ?T \\<subseteq> S\""], ["proof (prove)\nusing this:\n  ?x \\<in> linepath st tt `\n           {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n  ?x \\<in> S\n\ngoal (1 subgoal):\n 1. linepath st tt `\n    {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\n    \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  linepath st tt `\n  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n  \\<subseteq> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S =\n  linepath st tt `\n  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "moreover"], ["proof (state)\nthis:\n  S =\n  linepath st tt `\n  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite S", "define a' b' c' where \"a'=r * Re c\" and \"b' = r* Im c\" and \"c'=Im c * Im z0 + Re z0 * Re c - d\""], ["proof (state)\nthis:\n  a' = r * Re c\n  b' = r * Im c\n  c' = Im c * Im z0 + Re z0 * Re c - d\n\ngoal (1 subgoal):\n 1. finite S", "define f where \"f \\<theta>= a' * cos \\<theta> + b' * sin \\<theta> + c'\" for \\<theta>"], ["proof (state)\nthis:\n  f ?\\<theta> = a' * cos ?\\<theta> + b' * sin ?\\<theta> + c'\n\ngoal (1 subgoal):\n 1. finite S", "have \"(z0+r*exp (\\<i> * \\<theta> )) \\<bullet> c = d \\<longleftrightarrow> f \\<theta> = 0\" for \\<theta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((z0 +\n      complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)) \\<bullet>\n     c =\n     d) =\n    (f \\<theta> = 0)", "unfolding exp_Euler inner_complex_def f_def a'_def b'_def c'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (z0 +\n         complex_of_real r *\n         (cos (complex_of_real \\<theta>) +\n          \\<i> * sin (complex_of_real \\<theta>))) *\n     Re c +\n     Im (z0 +\n         complex_of_real r *\n         (cos (complex_of_real \\<theta>) +\n          \\<i> * sin (complex_of_real \\<theta>))) *\n     Im c =\n     d) =\n    (r * Re c * cos \\<theta> + r * Im c * sin \\<theta> +\n     (Im c * Im z0 + Re z0 * Re c - d) =\n     0)", "by (auto simp add:algebra_simps cos_of_real sin_of_real)"], ["proof (state)\nthis:\n  ((z0 +\n    complex_of_real r * exp (\\<i> * complex_of_real ?\\<theta>)) \\<bullet>\n   c =\n   d) =\n  (f ?\\<theta> = 0)\n\ngoal (1 subgoal):\n 1. finite S", "then"], ["proof (chain)\npicking this:\n  ((z0 +\n    complex_of_real r * exp (\\<i> * complex_of_real ?\\<theta>)) \\<bullet>\n   c =\n   d) =\n  (f ?\\<theta> = 0)", "have *:\"S = roots f \\<inter> closed_segment st tt\""], ["proof (prove)\nusing this:\n  ((z0 +\n    complex_of_real r * exp (\\<i> * complex_of_real ?\\<theta>)) \\<bullet>\n   c =\n   d) =\n  (f ?\\<theta> = 0)\n\ngoal (1 subgoal):\n 1. S = roots f \\<inter> closed_segment st tt", "unfolding S_def roots_within_def"], ["proof (prove)\nusing this:\n  ((z0 +\n    complex_of_real r * exp (\\<i> * complex_of_real ?\\<theta>)) \\<bullet>\n   c =\n   d) =\n  (f ?\\<theta> = 0)\n\ngoal (1 subgoal):\n 1. {\\<theta>.\n     (z0 +\n      complex_of_real r * exp (\\<i> * complex_of_real \\<theta>)) \\<bullet>\n     c =\n     d \\<and>\n     \\<theta> \\<in> closed_segment st tt} =\n    {x \\<in> UNIV. f x = 0} \\<inter> closed_segment st tt", "by auto"], ["proof (state)\nthis:\n  S = roots f \\<inter> closed_segment st tt\n\ngoal (1 subgoal):\n 1. finite S", "have \"uniform_discrete S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniform_discrete S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uniform_discrete S", "have \"a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0", "using assms complex_eq_iff"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n  r \\<noteq> 0\n  c \\<noteq> 0\n  (?x = ?y) = (Re ?x = Re ?y \\<and> Im ?x = Im ?y)\n\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0", "unfolding a'_def b'_def c'_def"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n  r \\<noteq> 0\n  c \\<noteq> 0\n  (?x = ?y) = (Re ?x = Re ?y \\<and> Im ?x = Im ?y)\n\ngoal (1 subgoal):\n 1. r * Re c \\<noteq> 0 \\<or>\n    r * Im c \\<noteq> 0 \\<or> Im c * Im z0 + Re z0 * Re c - d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. uniform_discrete S", "then"], ["proof (chain)\npicking this:\n  a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0", "have \"periodic_set (roots f) (4 * pi)\""], ["proof (prove)\nusing this:\n  a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. periodic_set (roots f) (4 * pi)", "using periodic_set_sin_cos_linear[of a' b' c',folded f_def]"], ["proof (prove)\nusing this:\n  a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0\n  a' \\<noteq> 0 \\<or> b' \\<noteq> 0 \\<or> c' \\<noteq> 0 \\<Longrightarrow>\n  periodic_set (roots f) (4 * pi)\n\ngoal (1 subgoal):\n 1. periodic_set (roots f) (4 * pi)", "by auto"], ["proof (state)\nthis:\n  periodic_set (roots f) (4 * pi)\n\ngoal (1 subgoal):\n 1. uniform_discrete S", "then"], ["proof (chain)\npicking this:\n  periodic_set (roots f) (4 * pi)", "have \"uniform_discrete (roots f)\""], ["proof (prove)\nusing this:\n  periodic_set (roots f) (4 * pi)\n\ngoal (1 subgoal):\n 1. uniform_discrete (roots f)", "using periodic_imp_uniform_discrete"], ["proof (prove)\nusing this:\n  periodic_set (roots f) (4 * pi)\n  periodic_set ?S ?\\<delta> \\<Longrightarrow> uniform_discrete ?S\n\ngoal (1 subgoal):\n 1. uniform_discrete (roots f)", "by auto"], ["proof (state)\nthis:\n  uniform_discrete (roots f)\n\ngoal (1 subgoal):\n 1. uniform_discrete S", "then"], ["proof (chain)\npicking this:\n  uniform_discrete (roots f)", "show ?thesis"], ["proof (prove)\nusing this:\n  uniform_discrete (roots f)\n\ngoal (1 subgoal):\n 1. uniform_discrete S", "unfolding *"], ["proof (prove)\nusing this:\n  uniform_discrete (roots f)\n\ngoal (1 subgoal):\n 1. uniform_discrete (roots f \\<inter> closed_segment st tt)", "by auto"], ["proof (state)\nthis:\n  uniform_discrete S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uniform_discrete S\n\ngoal (1 subgoal):\n 1. finite S", "moreover"], ["proof (state)\nthis:\n  uniform_discrete S\n\ngoal (1 subgoal):\n 1. finite S", "have \"bounded S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded S", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (roots f \\<inter> closed_segment st tt)", "by (simp add: bounded_Int bounded_closed_segment)"], ["proof (state)\nthis:\n  bounded S\n\ngoal (1 subgoal):\n 1. finite S", "ultimately"], ["proof (chain)\npicking this:\n  uniform_discrete S\n  bounded S", "show ?thesis"], ["proof (prove)\nusing this:\n  uniform_discrete S\n  bounded S\n\ngoal (1 subgoal):\n 1. finite S", "using uniform_discrete_finite_iff"], ["proof (prove)\nusing this:\n  uniform_discrete S\n  bounded S\n  (uniform_discrete ?S \\<and> bounded ?S) = finite ?S\n\ngoal (1 subgoal):\n 1. finite S", "by auto"], ["proof (state)\nthis:\n  finite S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"inj_on (linepath st tt) ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (linepath st tt)\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (linepath st tt)\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"inj (linepath st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (linepath st tt)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt)", "using assms inj_segment"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n  r \\<noteq> 0\n  c \\<noteq> 0\n  ?a \\<noteq> ?b \\<Longrightarrow>\n  inj_on (\\<lambda>u. (1 - u) *\\<^sub>R ?a + u *\\<^sub>R ?b) ?I\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt)", "by blast"], ["proof (state)\nthis:\n  inj (linepath st tt)\n\ngoal (1 subgoal):\n 1. inj_on (linepath st tt)\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  inj (linepath st tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  inj (linepath st tt)\n\ngoal (1 subgoal):\n 1. inj_on (linepath st tt)\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by (auto elim:subset_inj_on)"], ["proof (state)\nthis:\n  inj_on (linepath st tt)\n   {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (linepath st tt)\n   {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "ultimately"], ["proof (chain)\npicking this:\n  S =\n  linepath st tt `\n  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n  finite S\n  inj_on (linepath st tt)\n   {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  S =\n  linepath st tt `\n  {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n  finite S\n  inj_on (linepath st tt)\n   {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by (auto elim!: finite_imageD)"], ["proof (state)\nthis:\n  finite\n   {t. part_circlepath z0 r st tt t \\<bullet> c = d \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linepath_half_finite_inter:\n  assumes \"a \\<bullet> c \\<noteq> d \\<or> b \\<bullet> c \\<noteq> d\"\n  shows \"finite {t. linepath a b t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. linepath a b t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "assume asm:\"infinite ?S\""], ["proof (state)\nthis:\n  infinite\n   {t. linepath a b t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "obtain t1 t2 where u1u2:\"t1\\<noteq>t2\" \"t1\\<in>?S\" \"t2\\<in>?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<noteq> t2;\n         t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1};\n         t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<noteq> t2;\n         t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1};\n         t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain t1 where \"t1\\<in>?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1.\n        t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                     0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not_finite_existsD asm"], ["proof (prove)\nusing this:\n  infinite {a. ?P a} \\<Longrightarrow> \\<exists>a. ?P a\n  infinite\n   {t. linepath a b t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>t1.\n        t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                     0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<noteq> t2;\n         t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1};\n         t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<noteq> t2;\n         t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1};\n         t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>u2. u2\\<in>?S-{t1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u2.\n       u2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1} -\n                {t1}", "using infinite_remove[OF asm,of t1]"], ["proof (prove)\nusing this:\n  infinite\n   ({t. linepath a b t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1} -\n    {t1})\n\ngoal (1 subgoal):\n 1. \\<exists>u2.\n       u2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1} -\n                {t1}", "by (meson finite.emptyI rev_finite_subset subsetI)"], ["proof (state)\nthis:\n  \\<exists>u2.\n     u2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                  0 \\<le> t \\<and> t \\<le> 1} -\n              {t1}\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<noteq> t2;\n         t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1};\n         t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                      0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n  \\<exists>u2.\n     u2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                  0 \\<le> t \\<and> t \\<le> 1} -\n              {t1}", "show ?thesis"], ["proof (prove)\nusing this:\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n  \\<exists>u2.\n     u2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                  0 \\<le> t \\<and> t \\<le> 1} -\n              {t1}\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n  \\<exists>u2.\n     u2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n                  0 \\<le> t \\<and> t \\<le> 1} -\n              {t1}\n  \\<lbrakk>?t1.0 \\<noteq> ?t2.0;\n   ?t1.0\n   \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n             0 \\<le> t \\<and> t \\<le> 1};\n   ?t2.0\n   \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n             0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t1 \\<noteq> t2\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n  t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "have t1:\"(1-t1)*(a \\<bullet> c) + t1 * (b \\<bullet> c) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c) = d", "using \\<open>t1\\<in>?S\\<close>"], ["proof (prove)\nusing this:\n  t1 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c) = d", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  t1 \\<in> {t. ((1 - t) *\\<^sub>R a + t *\\<^sub>R b) \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c) = d", "by (simp add: inner_left_distrib)"], ["proof (state)\nthis:\n  (1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c) = d\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "have t2:\"(1-t2)*(a \\<bullet> c) + t2 * (b \\<bullet> c) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c) = d", "using \\<open>t2\\<in>?S\\<close>"], ["proof (prove)\nusing this:\n  t2 \\<in> {t. linepath a b t \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c) = d", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  t2 \\<in> {t. ((1 - t) *\\<^sub>R a + t *\\<^sub>R b) \\<bullet> c = d \\<and>\n               0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. (1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c) = d", "by (simp add: inner_left_distrib)"], ["proof (state)\nthis:\n  (1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c) = d\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "have \"a \\<bullet> c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "have \"t2*((1-t1)*(a \\<bullet> c) + t1 * (b \\<bullet> c)) = t2*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t2 * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) = t2 * d", "using t1"], ["proof (prove)\nusing this:\n  (1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c) = d\n\ngoal (1 subgoal):\n 1. t2 * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) = t2 * d", "by auto"], ["proof (state)\nthis:\n  t2 * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) = t2 * d\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "then"], ["proof (chain)\npicking this:\n  t2 * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) = t2 * d", "have *:\"(t2-t1*t2)*(a \\<bullet> c) + t1*t2 * (b \\<bullet> c) = t2*d\""], ["proof (prove)\nusing this:\n  t2 * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) = t2 * d\n\ngoal (1 subgoal):\n 1. (t2 - t1 * t2) * (a \\<bullet> c) + t1 * t2 * (b \\<bullet> c) = t2 * d", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (t2 - t1 * t2) * (a \\<bullet> c) + t1 * t2 * (b \\<bullet> c) = t2 * d\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "have \"t1*((1-t2)*(a \\<bullet> c) + t2 * (b \\<bullet> c)) = t1*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) = t1 * d", "using t2"], ["proof (prove)\nusing this:\n  (1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c) = d\n\ngoal (1 subgoal):\n 1. t1 * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) = t1 * d", "by auto"], ["proof (state)\nthis:\n  t1 * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) = t1 * d\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "then"], ["proof (chain)\npicking this:\n  t1 * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) = t1 * d", "have **:\"(t1-t1*t2)*(a \\<bullet> c) + t1*t2 * (b \\<bullet> c) = t1*d\""], ["proof (prove)\nusing this:\n  t1 * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) = t1 * d\n\ngoal (1 subgoal):\n 1. (t1 - t1 * t2) * (a \\<bullet> c) + t1 * t2 * (b \\<bullet> c) = t1 * d", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (t1 - t1 * t2) * (a \\<bullet> c) + t1 * t2 * (b \\<bullet> c) = t1 * d\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "have \"(t2-t1)*(a \\<bullet> c) = (t2-t1)*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t2 - t1) * (a \\<bullet> c) = (t2 - t1) * d", "using arg_cong2[OF * **,of minus]"], ["proof (prove)\nusing this:\n  (t2 - t1 * t2) * (a \\<bullet> c) + t1 * t2 * (b \\<bullet> c) -\n  ((t1 - t1 * t2) * (a \\<bullet> c) + t1 * t2 * (b \\<bullet> c)) =\n  t2 * d - t1 * d\n\ngoal (1 subgoal):\n 1. (t2 - t1) * (a \\<bullet> c) = (t2 - t1) * d", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (t2 - t1) * (a \\<bullet> c) = (t2 - t1) * d\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "then"], ["proof (chain)\npicking this:\n  (t2 - t1) * (a \\<bullet> c) = (t2 - t1) * d", "show ?thesis"], ["proof (prove)\nusing this:\n  (t2 - t1) * (a \\<bullet> c) = (t2 - t1) * d\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "using \\<open>t1\\<noteq>t2\\<close>"], ["proof (prove)\nusing this:\n  (t2 - t1) * (a \\<bullet> c) = (t2 - t1) * d\n  t1 \\<noteq> t2\n\ngoal (1 subgoal):\n 1. a \\<bullet> c = d", "by auto"], ["proof (state)\nthis:\n  a \\<bullet> c = d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<bullet> c = d\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  a \\<bullet> c = d\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "have \"b \\<bullet> c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "have \"(1-t2)*((1-t1)*(a \\<bullet> c) + t1 * (b \\<bullet> c)) = (1-t2)*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t2) * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) =\n    (1 - t2) * d", "using t1"], ["proof (prove)\nusing this:\n  (1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c) = d\n\ngoal (1 subgoal):\n 1. (1 - t2) * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) =\n    (1 - t2) * d", "by auto"], ["proof (state)\nthis:\n  (1 - t2) * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) =\n  (1 - t2) * d\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "then"], ["proof (chain)\npicking this:\n  (1 - t2) * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) =\n  (1 - t2) * d", "have *:\"(1-t1)*(1-t2)*(a \\<bullet> c) + (t1-t1*t2) * (b \\<bullet> c) = (1-t2)*d\""], ["proof (prove)\nusing this:\n  (1 - t2) * ((1 - t1) * (a \\<bullet> c) + t1 * (b \\<bullet> c)) =\n  (1 - t2) * d\n\ngoal (1 subgoal):\n 1. (1 - t1) * (1 - t2) * (a \\<bullet> c) +\n    (t1 - t1 * t2) * (b \\<bullet> c) =\n    (1 - t2) * d", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (1 - t1) * (1 - t2) * (a \\<bullet> c) + (t1 - t1 * t2) * (b \\<bullet> c) =\n  (1 - t2) * d\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "have \"(1-t1)*((1-t2)*(a \\<bullet> c) + t2 * (b \\<bullet> c)) = (1-t1)*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t1) * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) =\n    (1 - t1) * d", "using t2"], ["proof (prove)\nusing this:\n  (1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c) = d\n\ngoal (1 subgoal):\n 1. (1 - t1) * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) =\n    (1 - t1) * d", "by auto"], ["proof (state)\nthis:\n  (1 - t1) * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) =\n  (1 - t1) * d\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "then"], ["proof (chain)\npicking this:\n  (1 - t1) * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) =\n  (1 - t1) * d", "have **:\"(1-t1)*(1-t2)*(a \\<bullet> c) + (t2-t1*t2) * (b \\<bullet> c) = (1-t1)*d\""], ["proof (prove)\nusing this:\n  (1 - t1) * ((1 - t2) * (a \\<bullet> c) + t2 * (b \\<bullet> c)) =\n  (1 - t1) * d\n\ngoal (1 subgoal):\n 1. (1 - t1) * (1 - t2) * (a \\<bullet> c) +\n    (t2 - t1 * t2) * (b \\<bullet> c) =\n    (1 - t1) * d", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (1 - t1) * (1 - t2) * (a \\<bullet> c) + (t2 - t1 * t2) * (b \\<bullet> c) =\n  (1 - t1) * d\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "have \"(t2-t1)*(b \\<bullet> c) = (t2-t1)*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t2 - t1) * (b \\<bullet> c) = (t2 - t1) * d", "using arg_cong2[OF ** *,of minus]"], ["proof (prove)\nusing this:\n  (1 - t1) * (1 - t2) * (a \\<bullet> c) + (t2 - t1 * t2) * (b \\<bullet> c) -\n  ((1 - t1) * (1 - t2) * (a \\<bullet> c) +\n   (t1 - t1 * t2) * (b \\<bullet> c)) =\n  (1 - t1) * d - (1 - t2) * d\n\ngoal (1 subgoal):\n 1. (t2 - t1) * (b \\<bullet> c) = (t2 - t1) * d", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (t2 - t1) * (b \\<bullet> c) = (t2 - t1) * d\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "then"], ["proof (chain)\npicking this:\n  (t2 - t1) * (b \\<bullet> c) = (t2 - t1) * d", "show ?thesis"], ["proof (prove)\nusing this:\n  (t2 - t1) * (b \\<bullet> c) = (t2 - t1) * d\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "using \\<open>t1\\<noteq>t2\\<close>"], ["proof (prove)\nusing this:\n  (t2 - t1) * (b \\<bullet> c) = (t2 - t1) * d\n  t1 \\<noteq> t2\n\ngoal (1 subgoal):\n 1. b \\<bullet> c = d", "by auto"], ["proof (state)\nthis:\n  b \\<bullet> c = d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<bullet> c = d\n\ngoal (1 subgoal):\n 1. infinite\n     {t. linepath a b t \\<bullet> c = d \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  a \\<bullet> c = d\n  b \\<bullet> c = d", "show False"], ["proof (prove)\nusing this:\n  a \\<bullet> c = d\n  b \\<bullet> c = d\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  a \\<bullet> c = d\n  b \\<bullet> c = d\n  a \\<bullet> c \\<noteq> d \\<or> b \\<bullet> c \\<noteq> d\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_half_joinpaths_inter:\n  assumes \"finite {t. l1 t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\" \"finite {t. l2 t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\"\n  shows \"finite {t. (l1+++l2) t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "let ?l1s = \"{t. l1 (2*t) \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1/2}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "let ?l2s = \"{t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1/2< t \\<and> t\\<le>1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "let ?ls = \"\\<lambda>l. {t. l t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"{t. (l1+++l2) t \\<bullet> c = d \\<and> 0\\<le> t \\<and> t\\<le>1} = ?l1s \\<union> ?l2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1} =\n    {t. l1 (2 * t) \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1 / 2} \\<union>\n    {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "unfolding joinpaths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (if t \\<le> 1 / 2 then l1 (2 * t) else l2 (2 * t - 1)) \\<bullet> c =\n        d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} =\n    {t. l1 (2 * t) \\<bullet> c = d \\<and>\n        0 \\<le> t \\<and> t \\<le> 1 / 2} \\<union>\n    {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1} =\n  {t. l1 (2 * t) \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1 / 2} \\<union>\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "moreover"], ["proof (state)\nthis:\n  {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1} =\n  {t. l1 (2 * t) \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1 / 2} \\<union>\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"finite ?l1s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}", "have \"?l1s = ((*) (1/2)) ` ?ls l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2} =\n    (*) (1 / 2) `\n    {t. l1 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto intro:rev_image_eqI)"], ["proof (state)\nthis:\n  {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2} =\n  (*) (1 / 2) ` {t. l1 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2} =\n  (*) (1 / 2) ` {t. l1 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}", "using assms"], ["proof (prove)\nusing this:\n  {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2} =\n  (*) (1 / 2) ` {t. l1 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. l1 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. l2 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}", "by simp"], ["proof (state)\nthis:\n  finite\n   {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "moreover"], ["proof (state)\nthis:\n  finite\n   {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"finite ?l2s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "have \"?l2s \\<subseteq> (\\<lambda>x. x/2 + 1/2) ` ?ls l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n    \\<subseteq> (\\<lambda>x. x / 2 + 1 / 2) `\n                {t. l2 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto intro:rev_image_eqI simp add:field_simps)"], ["proof (state)\nthis:\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n  \\<subseteq> (\\<lambda>x. x / 2 + 1 / 2) `\n              {t. l2 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n  \\<subseteq> (\\<lambda>x. x / 2 + 1 / 2) `\n              {t. l2 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "using assms"], ["proof (prove)\nusing this:\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n  \\<subseteq> (\\<lambda>x. x / 2 + 1 / 2) `\n              {t. l2 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. l1 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. l2 t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "by (auto elim:finite_subset)"], ["proof (state)\nthis:\n  finite\n   {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "ultimately"], ["proof (chain)\npicking this:\n  {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1} =\n  {t. l1 (2 * t) \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1 / 2} \\<union>\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n  finite\n   {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}\n  finite\n   {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1} =\n  {t. l1 (2 * t) \\<bullet> c = d \\<and>\n      0 \\<le> t \\<and> t \\<le> 1 / 2} \\<union>\n  {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n  finite\n   {t. l1 (2 * t) \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1 / 2}\n  finite\n   {t. l2 (2 * t - 1) \\<bullet> c = d \\<and> 1 / 2 < t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by simp"], ["proof (state)\nthis:\n  finite\n   {t. (l1 +++ l2) t \\<bullet> c = d \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_linepath:\n  \"finite_ReZ_segments (linepath a b) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "have ?thesis when \"Re a\\<noteq>Re z \\<or> Re b \\<noteq>Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "let ?S1=\"{t. Re (linepath a b t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "have \"finite ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "using linepath_half_finite_inter[of a \"Complex 1 0\" \"Re z\" b] that"], ["proof (prove)\nusing this:\n  a \\<bullet> Complex 1 0 \\<noteq> Re z \\<or>\n  b \\<bullet> Complex 1 0 \\<noteq> Re z \\<Longrightarrow>\n  finite\n   {t. linepath a b t \\<bullet> Complex 1 0 = Re z \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "using one_complex.code"], ["proof (prove)\nusing this:\n  a \\<bullet> Complex 1 0 \\<noteq> Re z \\<or>\n  b \\<bullet> Complex 1 0 \\<noteq> Re z \\<Longrightarrow>\n  finite\n   {t. linepath a b t \\<bullet> Complex 1 0 = Re z \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z\n  1 = Complex 1 0\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "from finite_imp_finite_ReZ_segments[OF this]"], ["proof (chain)\npicking this:\n  finite_ReZ_segments (linepath a b) z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "."], ["proof (state)\nthis:\n  finite_ReZ_segments (linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z \\<Longrightarrow>\n  finite_ReZ_segments (linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "moreover"], ["proof (state)\nthis:\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z \\<Longrightarrow>\n  finite_ReZ_segments (linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "have ?thesis when \"Re a=Re z\" \"Re b=Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "unfolding finite_ReZ_segments_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (linepath a b t - z) = 0) 0 1", "apply (rule finite_Psegments.intros(2)[of 0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<in> {0..<1}\n 2. 0 = 0 \\<or> Re (linepath a b 0 - z) = 0\n 3. \\<forall>t\\<in>{0<..<1}. Re (linepath a b t - z) = 0\n 4. finite_Psegments (\\<lambda>t. Re (linepath a b t - z) = 0) 0 0", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re z\n\ngoal (4 subgoals):\n 1. 0 \\<in> {0..<1}\n 2. 0 = 0 \\<or> Re (linepath a b 0 - z) = 0\n 3. \\<forall>t\\<in>{0<..<1}. Re (linepath a b t - z) = 0\n 4. finite_Psegments (\\<lambda>t. Re (linepath a b t - z) = 0) 0 0", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re z\n\ngoal (4 subgoals):\n 1. 0 \\<in> {0..<1}\n 2. 0 = 0 \\<or> Re ((1 - 0) *\\<^sub>R a + 0 *\\<^sub>R b - z) = 0\n 3. \\<forall>t\\<in>{0<..<1}.\n       Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) = 0\n 4. finite_Psegments\n     (\\<lambda>t. Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) = 0) 0 0", "by (auto simp add:algebra_simps intro:finite_Psegments.intros)"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "ultimately"], ["proof (chain)\npicking this:\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z \\<Longrightarrow>\n  finite_ReZ_segments (linepath a b) z\n  \\<lbrakk>Re a = Re z; Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (linepath a b) z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z \\<Longrightarrow>\n  finite_ReZ_segments (linepath a b) z\n  \\<lbrakk>Re a = Re z; Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (linepath a b) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (linepath a b) z", "by blast"], ["proof (state)\nthis:\n  finite_ReZ_segments (linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_part_circlepath:\n  \"finite_ReZ_segments (part_circlepath z0 r st tt) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "have ?thesis when \"st \\<noteq> tt\" \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "let ?S1=\"{t. Re (part_circlepath z0 r st tt t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "have \"finite ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "using part_circlepath_half_finite_inter[of st tt r \"Complex 1 0\" z0 \"Re z\"] that one_complex.code"], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0; Complex 1 0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. part_circlepath z0 r st tt t \\<bullet>\n                         Complex 1 0 =\n                         Re z \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  st \\<noteq> tt\n  r \\<noteq> 0\n  1 = Complex 1 0\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def )"], ["proof (state)\nthis:\n  finite\n   {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "from finite_imp_finite_ReZ_segments[OF this]"], ["proof (chain)\npicking this:\n  finite_ReZ_segments (part_circlepath z0 r st tt) z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "."], ["proof (state)\nthis:\n  finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "have ?thesis when \"st =tt \\<or> r=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "define c where \"c = z0 + r * exp (\\<i> *  tt)\""], ["proof (state)\nthis:\n  c = z0 + complex_of_real r * exp (\\<i> * complex_of_real tt)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "have \"part_circlepath z0 r st tt = (\\<lambda>t. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_circlepath z0 r st tt = (\\<lambda>t. c)", "unfolding part_circlepath_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        z0 +\n        complex_of_real r *\n        exp (\\<i> * complex_of_real (linepath st tt x))) =\n    (\\<lambda>t. z0 + complex_of_real r * exp (\\<i> * complex_of_real tt))", "using that linepath_refl"], ["proof (prove)\nusing this:\n  st = tt \\<or> r = 0\n  linepath ?a ?a = (\\<lambda>x. ?a)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        z0 +\n        complex_of_real r *\n        exp (\\<i> * complex_of_real (linepath st tt x))) =\n    (\\<lambda>t. z0 + complex_of_real r * exp (\\<i> * complex_of_real tt))", "by auto"], ["proof (state)\nthis:\n  part_circlepath z0 r st tt = (\\<lambda>t. c)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "then"], ["proof (chain)\npicking this:\n  part_circlepath z0 r st tt = (\\<lambda>t. c)", "show ?thesis"], ["proof (prove)\nusing this:\n  part_circlepath z0 r st tt = (\\<lambda>t. c)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "using finite_ReZ_segments_linepath[of c c z] linepath_refl[of c]"], ["proof (prove)\nusing this:\n  part_circlepath z0 r st tt = (\\<lambda>t. c)\n  finite_ReZ_segments (linepath c c) z\n  linepath c c = (\\<lambda>x. c)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st = tt \\<or> r = 0 \\<Longrightarrow>\n  finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (part_circlepath z0 r st tt) z\n  st = tt \\<or> r = 0 \\<Longrightarrow>\n  finite_ReZ_segments (part_circlepath z0 r st tt) z", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (part_circlepath z0 r st tt) z\n  st = tt \\<or> r = 0 \\<Longrightarrow>\n  finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (part_circlepath z0 r st tt) z", "by blast"], ["proof (state)\nthis:\n  finite_ReZ_segments (part_circlepath z0 r st tt) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_poly_of_real:\n  shows \"finite_ReZ_segments (poly p o of_real) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> complex_of_real) z", "using finite_ReZ_segments_poly_linepath[of p 0 1 z]"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (poly p \\<circ> linepath 0 1) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> complex_of_real) z", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  finite_ReZ_segments\n   (poly p \\<circ> (\\<lambda>x. (1 - x) *\\<^sub>R 0 + x *\\<^sub>R 1)) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> complex_of_real) z", "by (auto simp add:scaleR_conv_of_real)"], ["", "lemma finite_ReZ_segments_subpath:\n  assumes \"finite_ReZ_segments g z\"\n    \"0\\<le>u\" \"u\\<le>v\" \"v\\<le>1\"\n  shows \"finite_ReZ_segments (subpath u v g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath u v g) z", "proof (cases \"u=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z\n 2. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "case True"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z\n 2. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "then"], ["proof (chain)\npicking this:\n  u = v", "show ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath u v g) z", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (\\<lambda>x. g ((v - u) * x + u)) z", "by (auto intro:finite_ReZ_segments_constI)"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath u v g) z\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "case False"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> v", "have \"u<v\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u < v", "using \\<open>u\\<le>v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. u < v", "by auto"], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "define P where \"P=(\\<lambda>t. Re (g t - z) = 0)\""], ["proof (state)\nthis:\n  P = (\\<lambda>t. Re (g t - z) = 0)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "have \"finite_ReZ_segments (subpath u v g) z \n      = finite_Psegments (P o (\\<lambda>t. (v - u) * t + u)) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath u v g) z =\n    finite_Psegments (P \\<circ> (\\<lambda>t. (v - u) * t + u)) 0 1", "unfolding finite_ReZ_segments_def subpath_def P_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g ((v - u) * t + u) - z) = 0) 0 1 =\n    finite_Psegments (\\<lambda>x. Re (g ((v - u) * x + u) - z) = 0) 0 1", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath u v g) z =\n  finite_Psegments (P \\<circ> (\\<lambda>t. (v - u) * t + u)) 0 1\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "also"], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath u v g) z =\n  finite_Psegments (P \\<circ> (\\<lambda>t. (v - u) * t + u)) 0 1\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (P \\<circ> (\\<lambda>t. (v - u) * t + u)) 0 1", "apply (rule finite_Psegments_pos_linear)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite_Psegments P ((v - u) * 0 + u) ((v - u) * 1 + u)\n 2. 0 < v - u", "using assms False"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  0 \\<le> u\n  u \\<le> v\n  v \\<le> 1\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. finite_Psegments P ((v - u) * 0 + u) ((v - u) * 1 + u)\n 2. 0 < v - u", "unfolding finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n  0 \\<le> u\n  u \\<le> v\n  v \\<le> 1\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. finite_Psegments P ((v - u) * 0 + u) ((v - u) * 1 + u)\n 2. 0 < v - u", "by (fold P_def,auto elim:finite_Psegments_included)"], ["proof (state)\nthis:\n  finite_Psegments (P \\<circ> (\\<lambda>t. (v - u) * t + u)) 0 1\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> finite_ReZ_segments (subpath u v g) z", "finally"], ["proof (chain)\npicking this:\n  finite_ReZ_segments (subpath u v g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath u v g) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath u v g) z", "."], ["proof (state)\nthis:\n  finite_ReZ_segments (subpath u v g) z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>jump and jumpF\\<close>"], ["", "definition jump::\"(real \\<Rightarrow> real) \\<Rightarrow> real \\<Rightarrow> int\" where\n  \"jump f a = (if \n        (LIM x (at_left a). f x :> at_bot) \\<and> (LIM x (at_right a). f x :> at_top) \n      then 1 else if \n        (LIM x (at_left a). f x :> at_top) \\<and> (LIM x (at_right a). f x :> at_bot) \n      then -1 else 0)\""], ["", "definition jumpF::\"(real \\<Rightarrow> real) \\<Rightarrow> real filter \\<Rightarrow> real\" where \n  \"jumpF f F \\<equiv> (if filterlim f at_top F then 1/2 else \n    if filterlim f at_bot F then -1/2 else (0::real))\""], ["", "lemma jumpF_const[simp]:\n  assumes \"F\\<noteq>bot\"\n  shows \"jumpF (\\<lambda>_. c) F = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "have False when \"LIM x F. c :> at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using filterlim_at_bot_nhds[OF that _ \\<open>F\\<noteq>bot\\<close>]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. c) \\<longlongrightarrow> ?c) F \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  LIM x F. c :> at_bot \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "moreover"], ["proof (state)\nthis:\n  LIM x F. c :> at_bot \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "have False when \"LIM x F. c :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using filterlim_at_top_nhds[OF that _ \\<open>F\\<noteq>bot\\<close>]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. c) \\<longlongrightarrow> ?c) F \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  LIM x F. c :> at_top \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "ultimately"], ["proof (chain)\npicking this:\n  LIM x F. c :> at_bot \\<Longrightarrow> False\n  LIM x F. c :> at_top \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x F. c :> at_bot \\<Longrightarrow> False\n  LIM x F. c :> at_top \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x F. c :> at_bot \\<Longrightarrow> False\n  LIM x F. c :> at_top \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if LIM _ F. c :> at_top then 1 / 2\n     else if LIM _ F. c :> at_bot then - 1 / 2 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>_. c) F = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_not_infinity:\n  assumes \"continuous F g\" \"F\\<noteq>bot\"\n  shows \"jumpF g F = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF g F = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF g F = 0", "have \"\\<not> filterlim g at_infinity F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> filterlim g at_infinity F", "using not_tendsto_and_filterlim_at_infinity[OF \\<open>F \\<noteq>bot\\<close> assms(1)[unfolded continuous_def]]"], ["proof (prove)\nusing this:\n  filterlim g at_infinity F \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g at_infinity F", "by auto"], ["proof (state)\nthis:\n  \\<not> filterlim g at_infinity F\n\ngoal (1 subgoal):\n 1. jumpF g F = 0", "then"], ["proof (chain)\npicking this:\n  \\<not> filterlim g at_infinity F", "have \"\\<not> filterlim g at_bot F\" \"\\<not> filterlim g at_top F\""], ["proof (prove)\nusing this:\n  \\<not> filterlim g at_infinity F\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g at_bot F &&& \\<not> filterlim g at_top F", "using at_bot_le_at_infinity at_top_le_at_infinity filterlim_mono"], ["proof (prove)\nusing this:\n  \\<not> filterlim g at_infinity F\n  at_bot \\<le> at_infinity\n  at_top \\<le> at_infinity\n  \\<lbrakk>filterlim ?f ?F2.0 ?F1.0; ?F2.0 \\<le> ?F2';\n   ?F1' \\<le> ?F1.0\\<rbrakk>\n  \\<Longrightarrow> filterlim ?f ?F2' ?F1'\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g at_bot F &&& \\<not> filterlim g at_top F", "by blast+"], ["proof (state)\nthis:\n  \\<not> filterlim g at_bot F\n  \\<not> filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF g F = 0", "then"], ["proof (chain)\npicking this:\n  \\<not> filterlim g at_bot F\n  \\<not> filterlim g at_top F", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> filterlim g at_bot F\n  \\<not> filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF g F = 0", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  \\<not> filterlim g at_bot F\n  \\<not> filterlim g at_top F\n\ngoal (1 subgoal):\n 1. (if filterlim g at_top F then 1 / 2\n     else if filterlim g at_bot F then - 1 / 2 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jumpF g F = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_linear_comp:\n  assumes \"c\\<noteq>0\"\n  shows \n    \"jumpF (f o (\\<lambda>x. c*x+b)) (at_left x) = \n            (if c>0 then jumpF f (at_left (c*x+b)) else jumpF f (at_right (c*x+b)))\"\n    (is ?case1)\n    \"jumpF (f o (\\<lambda>x. c*x+b)) (at_right x) = \n            (if c>0 then jumpF f (at_right (c*x+b)) else jumpF f (at_left (c*x+b)))\"\n    (is ?case2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "let ?g = \"\\<lambda>x. c*x+b\""], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "have ?case1 ?case2 when \"\\<not> c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "have \"c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < 0", "using \\<open>c\\<noteq>0\\<close> that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. c < 0", "by auto"], ["proof (state)\nthis:\n  c < 0\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "have \"filtermap ?g (at_left x) = at_right (?g x)\"\n         \"filtermap ?g (at_right x) = at_left (?g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)", "using \\<open>c<0\\<close> \n      filtermap_linear_at_left[OF \\<open>c\\<noteq>0\\<close>, of b x] \n      filtermap_linear_at_right[OF \\<open>c\\<noteq>0\\<close>, of b x]"], ["proof (prove)\nusing this:\n  c < 0\n  filtermap (\\<lambda>x. c * x + b) (at_left x) =\n  (if 0 < c then at_left (c * x + b) else at_right (c * x + b))\n  filtermap (\\<lambda>x. c * x + b) (at_right x) =\n  (if 0 < c then at_right (c * x + b) else at_left (c * x + b))\n\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)", "by auto"], ["proof (state)\nthis:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "then"], ["proof (chain)\npicking this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)", "have \n        \"jumpF (f \\<circ> ?g) (at_left x) = jumpF f (at_right (?g x))\"\n        \"jumpF (f \\<circ> ?g) (at_right x) = jumpF f (at_left (?g x))\""], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    jumpF f (at_right (c * x + b)) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    jumpF f (at_left (c * x + b))", "unfolding jumpF_def filterlim_def comp_def"], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)\n\ngoal (1 subgoal):\n 1. (if filtermap (\\<lambda>x. f (c * x + b)) (at_left x) \\<le> at_top\n     then 1 / 2\n     else if filtermap (\\<lambda>x. f (c * x + b)) (at_left x) \\<le> at_bot\n          then - 1 / 2 else 0) =\n    (if filtermap f (at_right (c * x + b)) \\<le> at_top then 1 / 2\n     else if filtermap f (at_right (c * x + b)) \\<le> at_bot then - 1 / 2\n          else 0) &&&\n    (if filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_top\n     then 1 / 2\n     else if filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_bot\n          then - 1 / 2 else 0) =\n    (if filtermap f (at_left (c * x + b)) \\<le> at_top then 1 / 2\n     else if filtermap f (at_left (c * x + b)) \\<le> at_bot then - 1 / 2\n          else 0)", "by (auto simp add: filtermap_filtermap[of f ?g,symmetric])"], ["proof (state)\nthis:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_right (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_left (c * x + b))\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "then"], ["proof (chain)\npicking this:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_right (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_left (c * x + b))", "show ?case1 ?case2"], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_right (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_left (c * x + b))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "using \\<open>c<0\\<close>"], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_right (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_left (c * x + b))\n  c < 0\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "by auto"], ["proof (state)\nthis:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "moreover"], ["proof (state)\nthis:\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "have ?case1 ?case2 when \"c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "have \"filtermap ?g (at_left x) = at_left (?g x)\"\n         \"filtermap ?g (at_right x) = at_right (?g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)", "using that \n      filtermap_linear_at_left[OF \\<open>c\\<noteq>0\\<close>, of b x] \n      filtermap_linear_at_right[OF \\<open>c\\<noteq>0\\<close>, of b x]"], ["proof (prove)\nusing this:\n  0 < c\n  filtermap (\\<lambda>x. c * x + b) (at_left x) =\n  (if 0 < c then at_left (c * x + b) else at_right (c * x + b))\n  filtermap (\\<lambda>x. c * x + b) (at_right x) =\n  (if 0 < c then at_right (c * x + b) else at_left (c * x + b))\n\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)", "by auto"], ["proof (state)\nthis:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "then"], ["proof (chain)\npicking this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)", "have \n        \"jumpF (f \\<circ> ?g) (at_left x) = jumpF f (at_left (?g x))\"\n        \"jumpF (f \\<circ> ?g) (at_right x) = jumpF f (at_right (?g x))\""], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    jumpF f (at_left (c * x + b)) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    jumpF f (at_right (c * x + b))", "unfolding jumpF_def filterlim_def comp_def"], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)\n\ngoal (1 subgoal):\n 1. (if filtermap (\\<lambda>x. f (c * x + b)) (at_left x) \\<le> at_top\n     then 1 / 2\n     else if filtermap (\\<lambda>x. f (c * x + b)) (at_left x) \\<le> at_bot\n          then - 1 / 2 else 0) =\n    (if filtermap f (at_left (c * x + b)) \\<le> at_top then 1 / 2\n     else if filtermap f (at_left (c * x + b)) \\<le> at_bot then - 1 / 2\n          else 0) &&&\n    (if filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_top\n     then 1 / 2\n     else if filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_bot\n          then - 1 / 2 else 0) =\n    (if filtermap f (at_right (c * x + b)) \\<le> at_top then 1 / 2\n     else if filtermap f (at_right (c * x + b)) \\<le> at_bot then - 1 / 2\n          else 0)", "by (auto simp add: filtermap_filtermap[of f ?g,symmetric])"], ["proof (state)\nthis:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_left (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_right (c * x + b))\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "then"], ["proof (chain)\npicking this:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_left (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_right (c * x + b))", "show ?case1 ?case2"], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_left (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_right (c * x + b))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "using that"], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  jumpF f (at_left (c * x + b))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  jumpF f (at_right (c * x + b))\n  0 < c\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "by auto"], ["proof (state)\nthis:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b)))\n 2. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n  0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))", "show ?case1 ?case2"], ["proof (prove)\nusing this:\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  \\<not> 0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n  0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  0 < c \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    (if 0 < c then jumpF f (at_left (c * x + b))\n     else jumpF f (at_right (c * x + b))) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    (if 0 < c then jumpF f (at_right (c * x + b))\n     else jumpF f (at_left (c * x + b)))", "by auto"], ["proof (state)\nthis:\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_const[simp]:\"jump (\\<lambda>_. c) a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>_. c) a = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>_. c) a = 0", "have False when \"LIM x (at_left a). c :> at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule not_tendsto_and_filterlim_at_infinity[of \"at_left a\" \"\\<lambda>_. c\" c])"], ["proof (prove)\ngoal (3 subgoals):\n 1. at_left a \\<noteq> bot\n 2. ((\\<lambda>_. c) \\<longlongrightarrow> c) (at_left a)\n 3. LIM _ at_left a. c :> at_infinity", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM _ at_left a. c :> at_infinity", "using at_bot_le_at_infinity filterlim_mono that"], ["proof (prove)\nusing this:\n  at_bot \\<le> at_infinity\n  \\<lbrakk>filterlim ?f ?F2.0 ?F1.0; ?F2.0 \\<le> ?F2';\n   ?F1' \\<le> ?F1.0\\<rbrakk>\n  \\<Longrightarrow> filterlim ?f ?F2' ?F1'\n  LIM x at_left a. c :> at_bot\n\ngoal (1 subgoal):\n 1. LIM _ at_left a. c :> at_infinity", "by blast"], ["proof (state)\nthis:\n  LIM x at_left a. c :> at_bot \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>_. c) a = 0", "moreover"], ["proof (state)\nthis:\n  LIM x at_left a. c :> at_bot \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>_. c) a = 0", "have False when \"LIM x (at_left a). c :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule not_tendsto_and_filterlim_at_infinity[of \"at_left a\" \"\\<lambda>_. c\" c])"], ["proof (prove)\ngoal (3 subgoals):\n 1. at_left a \\<noteq> bot\n 2. ((\\<lambda>_. c) \\<longlongrightarrow> c) (at_left a)\n 3. LIM _ at_left a. c :> at_infinity", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM _ at_left a. c :> at_infinity", "using at_top_le_at_infinity filterlim_mono that"], ["proof (prove)\nusing this:\n  at_top \\<le> at_infinity\n  \\<lbrakk>filterlim ?f ?F2.0 ?F1.0; ?F2.0 \\<le> ?F2';\n   ?F1' \\<le> ?F1.0\\<rbrakk>\n  \\<Longrightarrow> filterlim ?f ?F2' ?F1'\n  LIM x at_left a. c :> at_top\n\ngoal (1 subgoal):\n 1. LIM _ at_left a. c :> at_infinity", "by blast"], ["proof (state)\nthis:\n  LIM x at_left a. c :> at_top \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>_. c) a = 0", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_left a. c :> at_bot \\<Longrightarrow> False\n  LIM x at_left a. c :> at_top \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left a. c :> at_bot \\<Longrightarrow> False\n  LIM x at_left a. c :> at_top \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>_. c) a = 0", "unfolding jump_def"], ["proof (prove)\nusing this:\n  LIM x at_left a. c :> at_bot \\<Longrightarrow> False\n  LIM x at_left a. c :> at_top \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if (LIM _ at_left a. c :> at_bot) \\<and>\n        (LIM _ at_right a. c :> at_top)\n     then 1\n     else if (LIM _ at_left a. c :> at_top) \\<and>\n             (LIM _ at_right a. c :> at_bot)\n          then - 1 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>_. c) a = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_not_infinity:\n  \"isCont f a \\<Longrightarrow> jump f a =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f a \\<Longrightarrow> jump f a = 0", "by (meson at_bot_le_at_infinity at_top_le_at_infinity filterlim_at_split \n      filterlim_def isCont_def jump_def not_tendsto_and_filterlim_at_infinity \n      order_trans trivial_limit_at_left_real)"], ["", "lemma jump_jump_poly_aux:\n  assumes \"p\\<noteq>0\" \"coprime p q\"\n  shows \"jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "proof (cases \"q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "case True"], ["proof (state)\nthis:\n  q = 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "case False"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "define f where \"f \\<equiv> (\\<lambda>x. poly q x / poly p x)\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>x. poly q x / poly p x\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have ?thesis when \"poly q a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"poly p a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p a \\<noteq> 0", "using coprime_poly_0[OF \\<open>coprime p q\\<close>] that"], ["proof (prove)\nusing this:\n  poly p ?x \\<noteq> 0 \\<or> poly q ?x \\<noteq> 0\n  poly q a = 0\n\ngoal (1 subgoal):\n 1. poly p a \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  poly p a \\<noteq> 0", "have \"isCont f a\""], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont f a", "unfolding f_def"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. poly q x / poly p x) a", "by simp"], ["proof (state)\nthis:\n  isCont f a\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  isCont f a", "have \"jump f a=0\""], ["proof (prove)\nusing this:\n  isCont f a\n\ngoal (1 subgoal):\n 1. jump f a = 0", "using jump_not_infinity"], ["proof (prove)\nusing this:\n  isCont f a\n  isCont ?f ?a \\<Longrightarrow> jump ?f ?a = 0\n\ngoal (1 subgoal):\n 1. jump f a = 0", "by auto"], ["proof (state)\nthis:\n  jump f a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  jump f a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"jump_poly q p a=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly q p a = 0", "using jump_poly_not_root[OF \\<open>poly p a\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jump_poly ?q p a = 0\n\ngoal (1 subgoal):\n 1. jump_poly q p a = 0", "by auto"], ["proof (state)\nthis:\n  jump_poly q p a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "ultimately"], ["proof (chain)\npicking this:\n  jump f a = 0\n  jump_poly q p a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jump f a = 0\n  jump_poly q p a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "unfolding f_def"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q x / poly p x) a = 0\n  jump_poly q p a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly q a = 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  poly q a = 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have ?thesis when \"poly q a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "proof (cases \"even(order a p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "case True"], ["proof (state)\nthis:\n  even (order a p)\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "define c where \"c\\<equiv>sgn (poly q a)\""], ["proof (state)\nthis:\n  c \\<equiv> sgn (poly q a)\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "note \n      filterlim_divide_at_bot_at_top_iff\n        [OF _ that,of \"poly q\"  \"at_left a\" \"poly p\",folded f_def c_def,simplified]\n      filterlim_divide_at_bot_at_top_iff\n        [OF _ that,of \"poly q\"  \"at_right a\" \"poly p\",folded f_def c_def,simplified]"], ["proof (state)\nthis:\n  filterlim f at_bot (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx - c) (at_left a))\n  filterlim f at_top (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx c) (at_left a))\n  filterlim f at_bot (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx - c) (at_right a))\n  filterlim f at_top (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx c) (at_right a))\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  filterlim f at_bot (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx - c) (at_left a))\n  filterlim f at_top (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx c) (at_left a))\n  filterlim f at_bot (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx - c) (at_right a))\n  filterlim f at_top (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx c) (at_right a))\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"(poly p has_sgnx - c) (at_left a) = (poly p has_sgnx - c) (at_right a)\"\n         \"(poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx - c) (at_left a) =\n    (poly p has_sgnx - c) (at_right a) &&&\n    (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)", "using poly_has_sgnx_left_right[OF \\<open>p\\<noteq>0\\<close>] True"], ["proof (prove)\nusing this:\n  (poly p has_sgnx ?c) (at_left ?a) =\n  (if even (order ?a p) then (poly p has_sgnx ?c) (at_right ?a)\n   else (poly p has_sgnx - ?c) (at_right ?a))\n  even (order a p)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx - c) (at_left a) =\n    (poly p has_sgnx - c) (at_right a) &&&\n    (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"c\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by (simp add: c_def sgn_if that)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> 0", "have False when \n        \"(poly p has_sgnx - c) (at_right a)\" \n        \"(poly p has_sgnx c) (at_right a)\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using has_sgnx_unique[OF _ that]"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  at_right a \\<noteq> bot \\<Longrightarrow> - c = c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(poly p has_sgnx - c) (at_right a);\n   (poly p has_sgnx c) (at_right a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "ultimately"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx - c) (at_left a))\n  filterlim f at_top (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx c) (at_left a))\n  filterlim f at_bot (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx - c) (at_right a))\n  filterlim f at_top (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx c) (at_right a))\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)\n  \\<lbrakk>(poly p has_sgnx - c) (at_right a);\n   (poly p has_sgnx c) (at_right a)\\<rbrakk>\n  \\<Longrightarrow> False", "have \"jump f a = 0\""], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx - c) (at_left a))\n  filterlim f at_top (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx c) (at_left a))\n  filterlim f at_bot (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx - c) (at_right a))\n  filterlim f at_top (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx c) (at_right a))\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)\n  \\<lbrakk>(poly p has_sgnx - c) (at_right a);\n   (poly p has_sgnx c) (at_right a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump f a = 0", "unfolding jump_def"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx - c) (at_left a))\n  filterlim f at_top (at_left a) =\n  ((poly p \\<longlongrightarrow> 0) (at_left a) \\<and>\n   (poly p has_sgnx c) (at_left a))\n  filterlim f at_bot (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx - c) (at_right a))\n  filterlim f at_top (at_right a) =\n  ((poly p \\<longlongrightarrow> 0) (at_right a) \\<and>\n   (poly p has_sgnx c) (at_right a))\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx c) (at_right a)\n  \\<lbrakk>(poly p has_sgnx - c) (at_right a);\n   (poly p has_sgnx c) (at_right a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jump f a = 0\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  jump f a = 0\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"jump_poly q p a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly q p a = 0", "unfolding jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order a p - order a q)\n     then if sign_r_pos (q * p) a then 1 else - 1 else 0) =\n    0", "using True"], ["proof (prove)\nusing this:\n  even (order a p)\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order a p - order a q)\n     then if sign_r_pos (q * p) a then 1 else - 1 else 0) =\n    0", "by (simp add: order_0I that)"], ["proof (state)\nthis:\n  jump_poly q p a = 0\n\ngoal (2 subgoals):\n 1. even (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "ultimately"], ["proof (chain)\npicking this:\n  jump f a = 0\n  jump_poly q p a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jump f a = 0\n  jump_poly q p a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "unfolding f_def"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q x / poly p x) a = 0\n  jump_poly q p a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "case False"], ["proof (state)\nthis:\n  odd (order a p)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "define c where \"c\\<equiv>sgn (poly q a)\""], ["proof (state)\nthis:\n  c \\<equiv> sgn (poly q a)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"(poly p \\<longlongrightarrow> 0) (at a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p \\<midarrow>a\\<rightarrow> 0", "using False"], ["proof (prove)\nusing this:\n  odd (order a p)\n\ngoal (1 subgoal):\n 1. poly p \\<midarrow>a\\<rightarrow> 0", "by (metis even_zero order_0I poly_tendsto(1))"], ["proof (state)\nthis:\n  poly p \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  poly p \\<midarrow>a\\<rightarrow> 0", "have \"(poly p \\<longlongrightarrow> 0) (at_left a)\" and \"(poly p \\<longlongrightarrow> 0) (at_right a)\""], ["proof (prove)\nusing this:\n  poly p \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. (poly p \\<longlongrightarrow> 0) (at_left a) &&&\n    (poly p \\<longlongrightarrow> 0) (at_right a)", "by (auto simp add: filterlim_at_split)"], ["proof (state)\nthis:\n  (poly p \\<longlongrightarrow> 0) (at_left a)\n  (poly p \\<longlongrightarrow> 0) (at_right a)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  (poly p \\<longlongrightarrow> 0) (at_left a)\n  (poly p \\<longlongrightarrow> 0) (at_right a)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "note \n      filterlim_divide_at_bot_at_top_iff\n        [OF _ that,of \"poly q\" _ \"poly p\",folded f_def c_def]"], ["proof (state)\nthis:\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_bot ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx - c) ?F)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_top ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx c) ?F)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "moreover"], ["proof (state)\nthis:\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_bot ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx - c) ?F)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_top ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx c) ?F)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"(poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a)\"\n         \"(poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a) &&&\n    (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)", "using poly_has_sgnx_left_right[OF \\<open>p\\<noteq>0\\<close>] False"], ["proof (prove)\nusing this:\n  (poly p has_sgnx ?c) (at_left ?a) =\n  (if even (order ?a p) then (poly p has_sgnx ?c) (at_right ?a)\n   else (poly p has_sgnx - ?c) (at_right ?a))\n  odd (order a p)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a) &&&\n    (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "ultimately"], ["proof (chain)\npicking this:\n  (poly p \\<longlongrightarrow> 0) (at_left a)\n  (poly p \\<longlongrightarrow> 0) (at_right a)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_bot ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx - c) ?F)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_top ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx c) ?F)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)", "have \"jump f a = (if (poly p has_sgnx c) (at_right a) then 1\n        else if (poly p has_sgnx - c) (at_right a) then -1 else 0)\""], ["proof (prove)\nusing this:\n  (poly p \\<longlongrightarrow> 0) (at_left a)\n  (poly p \\<longlongrightarrow> 0) (at_right a)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_bot ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx - c) ?F)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_top ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx c) ?F)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. jump f a =\n    (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0)", "unfolding jump_def"], ["proof (prove)\nusing this:\n  (poly p \\<longlongrightarrow> 0) (at_left a)\n  (poly p \\<longlongrightarrow> 0) (at_right a)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_bot ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx - c) ?F)\n  (poly q \\<longlongrightarrow> poly q a) ?F \\<Longrightarrow>\n  filterlim f at_top ?F =\n  ((poly p \\<longlongrightarrow> 0) ?F \\<and> (poly p has_sgnx c) ?F)\n  (poly p has_sgnx c) (at_left a) = (poly p has_sgnx - c) (at_right a)\n  (poly p has_sgnx - c) (at_left a) = (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0) =\n    (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump f a =\n  (if (poly p has_sgnx c) (at_right a) then 1\n   else if (poly p has_sgnx - c) (at_right a) then - 1 else 0)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "also"], ["proof (state)\nthis:\n  jump f a =\n  (if (poly p has_sgnx c) (at_right a) then 1\n   else if (poly p has_sgnx - c) (at_right a) then - 1 else 0)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"... = (if sign_r_pos (q * p) a then 1 else - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n    (if sign_r_pos (q * p) a then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n    (if sign_r_pos (q * p) a then 1 else - 1)", "have \"(poly p has_sgnx c) (at_right a) \\<longleftrightarrow>  sign_r_pos (q * p) a \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_right a) = sign_r_pos (q * p) a", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "assume \"(poly p has_sgnx c) (at_right a)\""], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx c) (at_right a)", "have \"sgnx (poly p) (at_right a) = c\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a)\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = c", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = c\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = c\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "have \"sgnx (poly q) (at_right a) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly q) (at_right a) = c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly q) (at_right a) = sgn (poly q a)", "using that"], ["proof (prove)\nusing this:\n  poly q a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgnx (poly q) (at_right a) = sgn (poly q a)", "by (auto intro!: tendsto_nonzero_sgnx)"], ["proof (state)\nthis:\n  sgnx (poly q) (at_right a) = c\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) = c\n  sgnx (poly q) (at_right a) = c", "have \"sgnx (\\<lambda>x. poly (q*p) x) (at_right a) = c * c\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = c\n  sgnx (poly q) (at_right a) = c\n\ngoal (1 subgoal):\n 1. sgnx (poly (q * p)) (at_right a) = c * c", "by (simp add:sgnx_times)"], ["proof (state)\nthis:\n  sgnx (poly (q * p)) (at_right a) = c * c\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "moreover"], ["proof (state)\nthis:\n  sgnx (poly (q * p)) (at_right a) = c * c\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "have \"c\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by (simp add: c_def sgn_if that)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly (q * p)) (at_right a) = c * c\n  c \\<noteq> 0", "have \"sgnx (\\<lambda>x. poly (q*p) x) (at_right a) > 0\""], ["proof (prove)\nusing this:\n  sgnx (poly (q * p)) (at_right a) = c * c\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < sgnx (poly (q * p)) (at_right a)", "using not_real_square_gt_zero"], ["proof (prove)\nusing this:\n  sgnx (poly (q * p)) (at_right a) = c * c\n  c \\<noteq> 0\n  (\\<not> 0 < ?x * ?x) = (?x = 0)\n\ngoal (1 subgoal):\n 1. 0 < sgnx (poly (q * p)) (at_right a)", "by fastforce"], ["proof (state)\nthis:\n  0 < sgnx (poly (q * p)) (at_right a)\n\ngoal (2 subgoals):\n 1. (poly p has_sgnx c) (at_right a) \\<Longrightarrow> sign_r_pos (q * p) a\n 2. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "then"], ["proof (chain)\npicking this:\n  0 < sgnx (poly (q * p)) (at_right a)", "show \"sign_r_pos (q * p) a\""], ["proof (prove)\nusing this:\n  0 < sgnx (poly (q * p)) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a", "using sign_r_pos_sgnx_iff"], ["proof (prove)\nusing this:\n  0 < sgnx (poly (q * p)) (at_right a)\n  sign_r_pos ?p ?a = (0 < sgnx (poly ?p) (at_right ?a))\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a", "by blast"], ["proof (state)\nthis:\n  sign_r_pos (q * p) a\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "assume asm:\"sign_r_pos (q * p) a\""], ["proof (state)\nthis:\n  sign_r_pos (q * p) a\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "let ?c1 = \"sgnx (poly p) (at_right a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "let ?c2 = \"sgnx (poly q) (at_right a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "have \"0 < sgnx (\\<lambda>x. poly (q * p) x) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sgnx (poly (q * p)) (at_right a)", "using asm sign_r_pos_sgnx_iff"], ["proof (prove)\nusing this:\n  sign_r_pos (q * p) a\n  sign_r_pos ?p ?a = (0 < sgnx (poly ?p) (at_right ?a))\n\ngoal (1 subgoal):\n 1. 0 < sgnx (poly (q * p)) (at_right a)", "by blast"], ["proof (state)\nthis:\n  0 < sgnx (poly (q * p)) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "then"], ["proof (chain)\npicking this:\n  0 < sgnx (poly (q * p)) (at_right a)", "have \"?c2 * ?c1 >0\""], ["proof (prove)\nusing this:\n  0 < sgnx (poly (q * p)) (at_right a)\n\ngoal (1 subgoal):\n 1. 0 < sgnx (poly q) (at_right a) * sgnx (poly p) (at_right a)", "apply (subst (asm) poly_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sgnx (\\<lambda>x. poly q x * poly p x)\n         (at_right a) \\<Longrightarrow>\n    0 < sgnx (poly q) (at_right a) * sgnx (poly p) (at_right a)", "apply (subst (asm) sgnx_times)"], ["proof (prove)\ngoal (4 subgoals):\n 1. at_right a \\<noteq> bot\n 2. poly q sgnx_able at_right a\n 3. poly p sgnx_able at_right a\n 4. 0 < sgnx (poly q) (at_right a) *\n        sgnx (poly p) (at_right a) \\<Longrightarrow>\n    0 < sgnx (poly q) (at_right a) * sgnx (poly p) (at_right a)", "by auto"], ["proof (state)\nthis:\n  0 < sgnx (poly q) (at_right a) * sgnx (poly p) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "then"], ["proof (chain)\npicking this:\n  0 < sgnx (poly q) (at_right a) * sgnx (poly p) (at_right a)", "have \"?c2>0 \\<and> ?c1>0 \\<or> ?c2<0 \\<and> ?c1<0\""], ["proof (prove)\nusing this:\n  0 < sgnx (poly q) (at_right a) * sgnx (poly p) (at_right a)\n\ngoal (1 subgoal):\n 1. 0 < sgnx (poly q) (at_right a) \\<and>\n    0 < sgnx (poly p) (at_right a) \\<or>\n    sgnx (poly q) (at_right a) < 0 \\<and> sgnx (poly p) (at_right a) < 0", "by (simp add: zero_less_mult_iff)"], ["proof (state)\nthis:\n  0 < sgnx (poly q) (at_right a) \\<and> 0 < sgnx (poly p) (at_right a) \\<or>\n  sgnx (poly q) (at_right a) < 0 \\<and> sgnx (poly p) (at_right a) < 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "then"], ["proof (chain)\npicking this:\n  0 < sgnx (poly q) (at_right a) \\<and> 0 < sgnx (poly p) (at_right a) \\<or>\n  sgnx (poly q) (at_right a) < 0 \\<and> sgnx (poly p) (at_right a) < 0", "have \"?c1=?c2\""], ["proof (prove)\nusing this:\n  0 < sgnx (poly q) (at_right a) \\<and> 0 < sgnx (poly p) (at_right a) \\<or>\n  sgnx (poly q) (at_right a) < 0 \\<and> sgnx (poly p) (at_right a) < 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "using sgnx_values[OF sgnx_able_poly(1), of a,simplified]"], ["proof (prove)\nusing this:\n  0 < sgnx (poly q) (at_right a) \\<and> 0 < sgnx (poly p) (at_right a) \\<or>\n  sgnx (poly q) (at_right a) < 0 \\<and> sgnx (poly p) (at_right a) < 0\n  sgnx (poly ?p1) (at_right a) = - 1 \\<or>\n  sgnx (poly ?p1) (at_right a) = 0 \\<or> sgnx (poly ?p1) (at_right a) = 1\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)", "by (metis add.inverse_neutral less_minus_iff less_not_sym)"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "moreover"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "have \"sgnx (poly q) (at_right a) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly q) (at_right a) = c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly q) (at_right a) = sgn (poly q a)", "using that"], ["proof (prove)\nusing this:\n  poly q a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgnx (poly q) (at_right a) = sgn (poly q a)", "by (auto intro!: tendsto_nonzero_sgnx)"], ["proof (state)\nthis:\n  sgnx (poly q) (at_right a) = c\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n  sgnx (poly q) (at_right a) = c", "have \"?c1 = c\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = sgnx (poly q) (at_right a)\n  sgnx (poly q) (at_right a) = c\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right a) = c", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right a) = c\n\ngoal (1 subgoal):\n 1. sign_r_pos (q * p) a \\<Longrightarrow> (poly p has_sgnx c) (at_right a)", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right a) = c", "show \"(poly p has_sgnx c) (at_right a)\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = c\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_right a)", "using sgnx_able_poly(1) sgnx_able_sgnx"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right a) = c\n  poly ?p sgnx_able at_right ?a\n  ?f sgnx_able ?F \\<Longrightarrow> (?f has_sgnx sgnx ?f ?F) ?F\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx c) (at_right a)", "by blast"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly p has_sgnx c) (at_right a) = sign_r_pos (q * p) a\n\ngoal (1 subgoal):\n 1. (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n    (if sign_r_pos (q * p) a then 1 else - 1)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx c) (at_right a) = sign_r_pos (q * p) a", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a) = sign_r_pos (q * p) a\n\ngoal (1 subgoal):\n 1. (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n    (if sign_r_pos (q * p) a then 1 else - 1)", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a) = sign_r_pos (q * p) a\n\ngoal (1 subgoal):\n 1. (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n    (if sign_r_pos (q * p) a then 1 else - 1)", "using poly_has_sgnx_values[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  (poly p has_sgnx c) (at_right a) = sign_r_pos (q * p) a\n  (poly p has_sgnx 1) (at_left ?a) \\<or> (poly p has_sgnx - 1) (at_left ?a)\n  (poly p has_sgnx 1) (at_right ?a) \\<or>\n  (poly p has_sgnx - 1) (at_right ?a)\n  (poly p has_sgnx 1) at_top \\<or> (poly p has_sgnx - 1) at_top\n  (poly p has_sgnx 1) at_bot \\<or> (poly p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. (if (poly p has_sgnx c) (at_right a) then 1\n     else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n    (if sign_r_pos (q * p) a then 1 else - 1)", "by (metis add.inverse_inverse c_def sgn_if that)"], ["proof (state)\nthis:\n  (if (poly p has_sgnx c) (at_right a) then 1\n   else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n  (if sign_r_pos (q * p) a then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if (poly p has_sgnx c) (at_right a) then 1\n   else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n  (if sign_r_pos (q * p) a then 1 else - 1)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "also"], ["proof (state)\nthis:\n  (if (poly p has_sgnx c) (at_right a) then 1\n   else if (poly p has_sgnx - c) (at_right a) then - 1 else 0) =\n  (if sign_r_pos (q * p) a then 1 else - 1)\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"... = jump_poly q p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sign_r_pos (q * p) a then 1 else - 1) = jump_poly q p a", "unfolding jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if sign_r_pos (q * p) a then 1 else - 1) =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order a p - order a q)\n     then if sign_r_pos (q * p) a then 1 else - 1 else 0)", "using False order_root that"], ["proof (prove)\nusing this:\n  odd (order a p)\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n  poly q a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if sign_r_pos (q * p) a then 1 else - 1) =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order a p - order a q)\n     then if sign_r_pos (q * p) a then 1 else - 1 else 0)", "by (simp add: order_root assms(1))"], ["proof (state)\nthis:\n  (if sign_r_pos (q * p) a then 1 else - 1) = jump_poly q p a\n\ngoal (1 subgoal):\n 1. odd (order a p) \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "finally"], ["proof (chain)\npicking this:\n  jump f a = jump_poly q p a", "show ?thesis"], ["proof (prove)\nusing this:\n  jump f a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "unfolding f_def"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly q a \\<noteq> 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "ultimately"], ["proof (chain)\npicking this:\n  poly q a = 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n  poly q a \\<noteq> 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "show ?thesis"], ["proof (prove)\nusing this:\n  poly q a = 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n  poly q a \\<noteq> 0 \\<Longrightarrow>\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_jumpF:\n  assumes cont:\"isCont (inverse o f) a\" and \n      sgnxl:\"(f has_sgnx l) (at_left a)\" and sgnxr:\"(f has_sgnx r) (at_right a)\" and\n      \"l\\<noteq>0 \" \"r\\<noteq>0\"\n  shows \"jump f a = jumpF f (at_right a) - jumpF f (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \"filterlim f at_bot (at_left a)\" \"filterlim f at_top (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "unfolding jump_def jumpF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (if filterlim f at_bot (at_left a) \\<and>\n         filterlim f at_top (at_right a)\n      then 1\n      else if filterlim f at_top (at_left a) \\<and>\n              filterlim f at_bot (at_right a)\n           then - 1 else 0) =\n    (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) -\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0)", "using that filterlim_at_top_at_bot[OF _ _ trivial_limit_at_left_real]"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left a)\n  filterlim f at_top (at_right a)\n  \\<lbrakk>filterlim ?f at_top (at_left ?x1);\n   filterlim ?f at_bot (at_left ?x1)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if filterlim f at_bot (at_left a) \\<and>\n         filterlim f at_top (at_right a)\n      then 1\n      else if filterlim f at_top (at_left a) \\<and>\n              filterlim f at_bot (at_right a)\n           then - 1 else 0) =\n    (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) -\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>filterlim f at_bot (at_left a);\n   filterlim f at_top (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>filterlim f at_bot (at_left a);\n   filterlim f at_top (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \"filterlim f at_top (at_left a)\" \"filterlim f at_bot (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "unfolding jump_def jumpF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (if filterlim f at_bot (at_left a) \\<and>\n         filterlim f at_top (at_right a)\n      then 1\n      else if filterlim f at_top (at_left a) \\<and>\n              filterlim f at_bot (at_right a)\n           then - 1 else 0) =\n    (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) -\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0)", "using that filterlim_at_top_at_bot[OF _ _ trivial_limit_at_right_real]"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_left a)\n  filterlim f at_bot (at_right a)\n  \\<lbrakk>filterlim ?f at_top (at_right ?x1);\n   filterlim ?f at_bot (at_right ?x1)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if filterlim f at_bot (at_left a) \\<and>\n         filterlim f at_top (at_right a)\n      then 1\n      else if filterlim f at_top (at_left a) \\<and>\n              filterlim f at_bot (at_right a)\n           then - 1 else 0) =\n    (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) -\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>filterlim f at_top (at_left a);\n   filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>filterlim f at_top (at_left a);\n   filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \n          \"\\<not> filterlim f at_bot (at_left a) \\<or> \\<not> filterlim f at_top (at_right a)\"\n          \"\\<not> filterlim f at_top (at_left a) \\<or> \\<not> filterlim f at_bot (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "proof (cases \"f a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n 2. f a \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "case False"], ["proof (state)\nthis:\n  f a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n 2. f a \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have \"jumpF f (at_right a) = 0\" \"jumpF f (at_left a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right a) = 0 &&& jumpF f (at_left a) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_right a) = 0\n 2. jumpF f (at_left a) = 0", "have \"isCont (inverse o inverse o f) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> inverse \\<circ> f) a", "using cont False"], ["proof (prove)\nusing this:\n  isCont (inverse \\<circ> f) a\n  f a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> inverse \\<circ> f) a", "unfolding comp_def"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. inverse (f x)) a\n  f a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. inverse (inverse (f x))) a", "by (rule_tac continuous_at_within_inverse, auto)"], ["proof (state)\nthis:\n  isCont (inverse \\<circ> inverse \\<circ> f) a\n\ngoal (2 subgoals):\n 1. jumpF f (at_right a) = 0\n 2. jumpF f (at_left a) = 0", "then"], ["proof (chain)\npicking this:\n  isCont (inverse \\<circ> inverse \\<circ> f) a", "have \"isCont f a\""], ["proof (prove)\nusing this:\n  isCont (inverse \\<circ> inverse \\<circ> f) a\n\ngoal (1 subgoal):\n 1. isCont f a", "unfolding comp_def"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. inverse (inverse (f x))) a\n\ngoal (1 subgoal):\n 1. isCont f a", "by auto"], ["proof (state)\nthis:\n  isCont f a\n\ngoal (2 subgoals):\n 1. jumpF f (at_right a) = 0\n 2. jumpF f (at_left a) = 0", "then"], ["proof (chain)\npicking this:\n  isCont f a", "have \"(f \\<longlongrightarrow> f a) (at_right a)\" \"(f \\<longlongrightarrow> f a) (at_left a)\""], ["proof (prove)\nusing this:\n  isCont f a\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a) &&&\n    (f \\<longlongrightarrow> f a) (at_left a)", "unfolding continuous_at_split"], ["proof (prove)\nusing this:\n  continuous (at_left a) f \\<and> continuous (at_right a) f\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a) &&&\n    (f \\<longlongrightarrow> f a) (at_left a)", "by (auto simp add:continuous_within)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  (f \\<longlongrightarrow> f a) (at_left a)\n\ngoal (2 subgoals):\n 1. jumpF f (at_right a) = 0\n 2. jumpF f (at_left a) = 0", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  (f \\<longlongrightarrow> f a) (at_left a)\n\ngoal (2 subgoals):\n 1. jumpF f (at_right a) = 0\n 2. jumpF f (at_left a) = 0", "note trivial_limit_at_left_real trivial_limit_at_right_real"], ["proof (state)\nthis:\n  at_left ?x \\<noteq> bot\n  at_right ?x \\<noteq> bot\n\ngoal (2 subgoals):\n 1. jumpF f (at_right a) = 0\n 2. jumpF f (at_left a) = 0", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  (f \\<longlongrightarrow> f a) (at_left a)\n  at_left ?x \\<noteq> bot\n  at_right ?x \\<noteq> bot", "show \"jumpF f (at_right a) = 0\" \"jumpF f (at_left a) = 0\""], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  (f \\<longlongrightarrow> f a) (at_left a)\n  at_left ?x \\<noteq> bot\n  at_right ?x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. jumpF f (at_right a) = 0 &&& jumpF f (at_left a) = 0", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  (f \\<longlongrightarrow> f a) (at_left a)\n  at_left ?x \\<noteq> bot\n  at_right ?x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) =\n    0 &&&\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0) =\n    0", "using filterlim_at_bot_nhds filterlim_at_top_nhds"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  (f \\<longlongrightarrow> f a) (at_left a)\n  at_left ?x \\<noteq> bot\n  at_right ?x \\<noteq> bot\n  \\<lbrakk>filterlim ?f at_bot ?F; (?f \\<longlongrightarrow> ?c) ?F;\n   ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>filterlim ?f at_top ?F; (?f \\<longlongrightarrow> ?c) ?F;\n   ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) =\n    0 &&&\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0) =\n    0", "by metis+"], ["proof (state)\nthis:\n  jumpF f (at_right a) = 0\n  jumpF f (at_left a) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF f (at_right a) = 0\n  jumpF f (at_left a) = 0\n\ngoal (2 subgoals):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n 2. f a \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_right a) = 0\n  jumpF f (at_left a) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) = 0\n  jumpF f (at_left a) = 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "unfolding jump_def"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) = 0\n  jumpF f (at_left a) = 0\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if filterlim f at_bot (at_left a) \\<and>\n         filterlim f at_top (at_right a)\n      then 1\n      else if filterlim f at_top (at_left a) \\<and>\n              filterlim f at_bot (at_right a)\n           then - 1 else 0) =\n    jumpF f (at_right a) - jumpF f (at_left a)", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) = 0\n  jumpF f (at_left a) = 0\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if filterlim f at_bot (at_left a) \\<and>\n         filterlim f at_top (at_right a)\n      then 1\n      else if filterlim f at_top (at_left a) \\<and>\n              filterlim f at_bot (at_right a)\n           then - 1 else 0) =\n    jumpF f (at_right a) - jumpF f (at_left a)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "case True"], ["proof (state)\nthis:\n  f a = 0\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "then"], ["proof (chain)\npicking this:\n  f a = 0", "have tends0:\"((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at a)\""], ["proof (prove)\nusing this:\n  f a = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0", "using cont"], ["proof (prove)\nusing this:\n  f a = 0\n  isCont (inverse \\<circ> f) a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0", "unfolding isCont_def comp_def"], ["proof (prove)\nusing this:\n  f a = 0\n  (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> inverse (f a)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have \"jump f a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump f a = 0", "using that"], ["proof (prove)\nusing this:\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. jump f a = 0", "unfolding jump_def"], ["proof (prove)\nusing this:\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jump f a = 0\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have r_lim:\"if r>0 then filterlim f at_top (at_right a) else filterlim f at_bot (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "proof (cases \"r>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)\n 2. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "case True"], ["proof (state)\nthis:\n  0 < r\n\ngoal (2 subgoals):\n 1. 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)\n 2. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "then"], ["proof (chain)\npicking this:\n  0 < r", "have \"\\<forall>\\<^sub>F x in (at_right a). 0 < f x\""], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. 0 < f x", "using sgnxr"], ["proof (prove)\nusing this:\n  0 < r\n  (f has_sgnx r) (at_right a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. 0 < f x", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  0 < r\n  \\<forall>\\<^sub>F x in at_right a. sgn (f x) = r\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. 0 < f x", "by (auto elim:eventually_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right a. 0 < f x\n\ngoal (2 subgoals):\n 1. 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)\n 2. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < f x", "have \"filterlim f at_top (at_right a)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < f x\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_right a)", "using filterlim_inverse_at_top[of \"\\<lambda>x. inverse (f x)\", simplified] tends0"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < f x\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. 0 < f x\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_top ?F\n  (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_right a)", "unfolding filterlim_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. 0 < f x\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. 0 < f x\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_top ?F\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_left a) \\<and>\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_right a)\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_right a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_top (at_right a)\n\ngoal (2 subgoals):\n 1. 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)\n 2. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top (at_right a)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_right a)\n\ngoal (1 subgoal):\n 1. if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "using True"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_right a)\n  0 < r\n\ngoal (1 subgoal):\n 1. if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "by presburger"], ["proof (state)\nthis:\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < r", "have \"\\<forall>\\<^sub>F x in (at_right a). 0 > f x\""], ["proof (prove)\nusing this:\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. f x < 0", "using sgnxr \\<open>r\\<noteq>0\\<close> False"], ["proof (prove)\nusing this:\n  \\<not> 0 < r\n  (f has_sgnx r) (at_right a)\n  r \\<noteq> 0\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. f x < 0", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<not> 0 < r\n  \\<forall>\\<^sub>F x in at_right a. sgn (f x) = r\n  r \\<noteq> 0\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a. f x < 0", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> 0 < r; r \\<noteq> 0; \\<not> 0 < r;\n        sgn (f x) = r\\<rbrakk>\n       \\<Longrightarrow> f x < 0", "by (meson linorder_neqE_linordered_idom sgn_less)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right a. f x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_right a. f x < 0", "have \"filterlim f at_bot (at_right a)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. f x < 0\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a)", "using filterlim_inverse_at_bot[of \"\\<lambda>x. inverse (f x)\", simplified] tends0"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. f x < 0\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. f x < 0\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_bot ?F\n  (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a)", "unfolding filterlim_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right a. f x < 0\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. f x < 0\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_bot ?F\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_left a) \\<and>\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_right a)\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < r \\<Longrightarrow>\n    if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_right a)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "using False"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right a)\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. if 0 < r then filterlim f at_top (at_right a)\n    else filterlim f at_bot (at_right a)", "by simp"], ["proof (state)\nthis:\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have l_lim:\"if l>0 then filterlim f at_top (at_left a) else filterlim f at_bot (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "proof (cases \"l>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)\n 2. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "case True"], ["proof (state)\nthis:\n  0 < l\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)\n 2. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "then"], ["proof (chain)\npicking this:\n  0 < l", "have \"\\<forall>\\<^sub>F x in (at_left a). 0 < f x\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. 0 < f x", "using sgnxl"], ["proof (prove)\nusing this:\n  0 < l\n  (f has_sgnx l) (at_left a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. 0 < f x", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  0 < l\n  \\<forall>\\<^sub>F x in at_left a. sgn (f x) = l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. 0 < f x", "by (auto elim:eventually_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left a. 0 < f x\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)\n 2. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left a. 0 < f x", "have \"filterlim f at_top (at_left a)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. 0 < f x\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_left a)", "using filterlim_inverse_at_top[of \"\\<lambda>x. inverse (f x)\", simplified] tends0"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. 0 < f x\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. 0 < f x\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_top ?F\n  (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_left a)", "unfolding filterlim_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. 0 < f x\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. 0 < f x\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_top ?F\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_left a) \\<and>\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_right a)\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_left a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_top (at_left a)\n\ngoal (2 subgoals):\n 1. 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)\n 2. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top (at_left a)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_left a)\n\ngoal (1 subgoal):\n 1. if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "using True"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_left a)\n  0 < l\n\ngoal (1 subgoal):\n 1. if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "by presburger"], ["proof (state)\nthis:\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < l\n\ngoal (1 subgoal):\n 1. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < l", "have \"\\<forall>\\<^sub>F x in (at_left a). 0 > f x\""], ["proof (prove)\nusing this:\n  \\<not> 0 < l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. f x < 0", "using sgnxl \\<open>l\\<noteq>0\\<close> False"], ["proof (prove)\nusing this:\n  \\<not> 0 < l\n  (f has_sgnx l) (at_left a)\n  l \\<noteq> 0\n  \\<not> 0 < l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. f x < 0", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<not> 0 < l\n  \\<forall>\\<^sub>F x in at_left a. sgn (f x) = l\n  l \\<noteq> 0\n  \\<not> 0 < l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. f x < 0", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> 0 < l; l \\<noteq> 0; \\<not> 0 < l;\n        sgn (f x) = l\\<rbrakk>\n       \\<Longrightarrow> f x < 0", "by (meson linorder_neqE_linordered_idom sgn_less)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left a. f x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left a. f x < 0", "have \"filterlim f at_bot (at_left a)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. f x < 0\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left a)", "using filterlim_inverse_at_bot[of \"\\<lambda>x. inverse (f x)\", simplified] tends0"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. f x < 0\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. f x < 0\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_bot ?F\n  (\\<lambda>x. inverse (f x)) \\<midarrow>a\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left a)", "unfolding filterlim_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. f x < 0\n  \\<lbrakk>((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) ?F;\n   \\<forall>\\<^sub>F x in ?F. f x < 0\\<rbrakk>\n  \\<Longrightarrow> filterlim f at_bot ?F\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_left a) \\<and>\n  ((\\<lambda>x. inverse (f x)) \\<longlongrightarrow> 0) (at_right a)\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < l \\<Longrightarrow>\n    if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_left a)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "using False"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left a)\n  \\<not> 0 < l\n\ngoal (1 subgoal):\n 1. if 0 < l then filterlim f at_top (at_left a)\n    else filterlim f at_bot (at_left a)", "by simp"], ["proof (state)\nthis:\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \"l>0\" \"r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "using that l_lim r_lim \\<open>jump f a=0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n  0 < r\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n  jump f a = 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  0 < l\n  0 < r\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n  jump f a = 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) =\n    (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) -\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \"\\<not> l>0\" \"\\<not> r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have \"filterlim f at_bot (at_right a)\" \"filterlim f at_bot (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a) &&& filterlim f at_bot (at_left a)", "using r_lim l_lim that"], ["proof (prove)\nusing this:\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n  \\<not> 0 < l\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a) &&& filterlim f at_bot (at_left a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)", "have \"\\<not> filterlim f at_top (at_right a)\" \"\\<not> filterlim f at_top (at_left a)\""], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)\n\ngoal (1 subgoal):\n 1. \\<not> filterlim f at_top (at_right a) &&&\n    \\<not> filterlim f at_top (at_left a)", "by (auto elim: filterlim_at_top_at_bot)"], ["proof (state)\nthis:\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "ultimately"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a)", "have \"jumpF f (at_right a) = -1/2 \"  \"jumpF f (at_left a) = -1/2\""], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right a) = - 1 / 2 &&& jumpF f (at_left a) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_left a)\n  \\<not> filterlim f at_top (at_right a)\n  \\<not> filterlim f at_top (at_left a)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_right a) then 1 / 2\n     else if filterlim f at_bot (at_right a) then - 1 / 2 else 0) =\n    - 1 / 2 &&&\n    (if filterlim f at_top (at_left a) then 1 / 2\n     else if filterlim f at_bot (at_left a) then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_right a) = - 1 / 2\n  jumpF f (at_left a) = - 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_right a) = - 1 / 2\n  jumpF f (at_left a) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) = - 1 / 2\n  jumpF f (at_left a) = - 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "using \\<open>jump f a=0\\<close>"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) = - 1 / 2\n  jumpF f (at_left a) = - 1 / 2\n  jump f a = 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> 0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> 0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \"l>0\" \"\\<not> r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "note \\<open>\\<not> filterlim f at_top (at_left a) \\<or> \\<not> filterlim f at_bot (at_right a)\\<close>"], ["proof (state)\nthis:\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have \"filterlim f at_bot (at_right a)\" \"filterlim f at_top (at_left a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a) &&& filterlim f at_top (at_left a)", "using r_lim l_lim that"], ["proof (prove)\nusing this:\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n  0 < l\n  \\<not> 0 < r\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right a) &&& filterlim f at_top (at_left a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_right a)\n  filterlim f at_top (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_right a)\n  filterlim f at_top (at_left a)", "have False"], ["proof (prove)\nusing this:\n  \\<not> filterlim f at_top (at_left a) \\<or>\n  \\<not> filterlim f at_bot (at_right a)\n  filterlim f at_bot (at_right a)\n  filterlim f at_top (at_left a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have ?thesis when \"\\<not> l>0\" \"r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "note \\<open>\\<not> filterlim f at_bot (at_left a) \\<or> \\<not> filterlim f at_top (at_right a)\\<close>"], ["proof (state)\nthis:\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "moreover"], ["proof (state)\nthis:\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "have \"filterlim f at_bot (at_left a)\" \"filterlim f at_top (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left a) &&& filterlim f at_top (at_right a)", "using r_lim l_lim that"], ["proof (prove)\nusing this:\n  if 0 < r then filterlim f at_top (at_right a)\n  else filterlim f at_bot (at_right a)\n  if 0 < l then filterlim f at_top (at_left a)\n  else filterlim f at_bot (at_left a)\n  \\<not> 0 < l\n  0 < r\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left a) &&& filterlim f at_top (at_right a)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_left a)\n  filterlim f at_top (at_right a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n  filterlim f at_bot (at_left a)\n  filterlim f at_top (at_right a)", "have False"], ["proof (prove)\nusing this:\n  \\<not> filterlim f at_bot (at_left a) \\<or>\n  \\<not> filterlim f at_top (at_right a)\n  filterlim f at_bot (at_left a)\n  filterlim f at_top (at_right a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> 0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. f a = 0 \\<Longrightarrow>\n    real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>\\<not> 0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>\\<not> 0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>\\<not> 0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>0 < l; \\<not> 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>\\<not> 0 < l; 0 < r\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> filterlim f at_bot (at_left a) \\<or>\n           \\<not> filterlim f at_top (at_right a);\n   \\<not> filterlim f at_top (at_left a) \\<or>\n   \\<not> filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>filterlim f at_bot (at_left a);\n   filterlim f at_top (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>filterlim f at_top (at_left a);\n   filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>\\<not> filterlim f at_bot (at_left a) \\<or>\n           \\<not> filterlim f at_top (at_right a);\n   \\<not> filterlim f at_top (at_left a) \\<or>\n   \\<not> filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>filterlim f at_bot (at_left a);\n   filterlim f at_top (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>filterlim f at_top (at_left a);\n   filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n  \\<lbrakk>\\<not> filterlim f at_bot (at_left a) \\<or>\n           \\<not> filterlim f at_top (at_right a);\n   \\<not> filterlim f at_top (at_left a) \\<or>\n   \\<not> filterlim f at_bot (at_right a)\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump f a) =\n                    jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal (1 subgoal):\n 1. real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump f a) = jumpF f (at_right a) - jumpF f (at_left a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_linear_comp:\n  assumes \"c\\<noteq>0\"\n  shows \"jump (f o (\\<lambda>x. c*x+b)) x = (if c>0 then jump f (c*x+b) else -jump f (c*x+b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "proof (cases \"c>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n 2. \\<not> 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < c\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n 2. \\<not> 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < c", "have \"c<0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. c < 0", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < c\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c < 0", "by auto"], ["proof (state)\nthis:\n  c < 0\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n 2. \\<not> 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "let ?g = \"\\<lambda>x. c*x+b\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n 2. \\<not> 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "have \"filtermap ?g (at_left x) = at_right (?g x)\"\n       \"filtermap ?g (at_right x) = at_left (?g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)", "using \\<open>c<0\\<close> \n      filtermap_linear_at_left[OF \\<open>c\\<noteq>0\\<close>, of b x] \n      filtermap_linear_at_right[OF \\<open>c\\<noteq>0\\<close>, of b x]"], ["proof (prove)\nusing this:\n  c < 0\n  filtermap (\\<lambda>x. c * x + b) (at_left x) =\n  (if 0 < c then at_left (c * x + b) else at_right (c * x + b))\n  filtermap (\\<lambda>x. c * x + b) (at_right x) =\n  (if 0 < c then at_right (c * x + b) else at_left (c * x + b))\n\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)", "by auto"], ["proof (state)\nthis:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n 2. \\<not> 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "then"], ["proof (chain)\npicking this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)", "have \"jump (f \\<circ> ?g) x = - jump f (c * x + b)\""], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)\n\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x = - jump f (c * x + b)", "unfolding jump_def filterlim_def comp_def"], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_right (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b)\n\ngoal (1 subgoal):\n 1. (if filtermap (\\<lambda>x. f (c * x + b)) (at_left x)\n        \\<le> at_bot \\<and>\n        filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_top\n     then 1\n     else if filtermap (\\<lambda>x. f (c * x + b)) (at_left x)\n             \\<le> at_top \\<and>\n             filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_bot\n          then - 1 else 0) =\n    - (if filtermap f (at_left (c * x + b)) \\<le> at_bot \\<and>\n          filtermap f (at_right (c * x + b)) \\<le> at_top\n       then 1\n       else if filtermap f (at_left (c * x + b)) \\<le> at_top \\<and>\n               filtermap f (at_right (c * x + b)) \\<le> at_bot\n            then - 1 else 0)", "apply (auto simp add: filtermap_filtermap[of f ?g,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filtermap (\\<lambda>x. c * x + b) (at_left x) =\n             at_right (c * x + b);\n     filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b);\n     filtermap f (at_left (c * x + b)) \\<le> at_top;\n     filtermap f (at_right (c * x + b)) \\<le> at_bot;\n     filtermap f (at_left (c * x + b)) \\<le> at_bot;\n     filtermap f (at_right (c * x + b)) \\<le> at_top\\<rbrakk>\n    \\<Longrightarrow> False", "apply (fold filterlim_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filtermap (\\<lambda>x. c * x + b) (at_left x) =\n             at_right (c * x + b);\n     filtermap (\\<lambda>x. c * x + b) (at_right x) = at_left (c * x + b);\n     filterlim f at_top (at_left (c * x + b));\n     filterlim f at_bot (at_right (c * x + b));\n     filterlim f at_bot (at_left (c * x + b));\n     filterlim f at_top (at_right (c * x + b))\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto elim:filterlim_at_top_at_bot)"], ["proof (state)\nthis:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = - jump f (c * x + b)\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n 2. \\<not> 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "then"], ["proof (chain)\npicking this:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = - jump f (c * x + b)", "show ?thesis"], ["proof (prove)\nusing this:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = - jump f (c * x + b)\n\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "using \\<open>c<0\\<close>"], ["proof (prove)\nusing this:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = - jump f (c * x + b)\n  c < 0\n\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "by auto"], ["proof (state)\nthis:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n  (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "case True"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "let ?g = \"\\<lambda>x. c*x+b\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "have \"filtermap ?g (at_left x) = at_left (?g x)\"\n       \"filtermap ?g (at_right x) = at_right (?g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)", "using True \n      filtermap_linear_at_left[OF \\<open>c\\<noteq>0\\<close>, of b x] \n      filtermap_linear_at_right[OF \\<open>c\\<noteq>0\\<close>, of b x]"], ["proof (prove)\nusing this:\n  0 < c\n  filtermap (\\<lambda>x. c * x + b) (at_left x) =\n  (if 0 < c then at_left (c * x + b) else at_right (c * x + b))\n  filtermap (\\<lambda>x. c * x + b) (at_right x) =\n  (if 0 < c then at_right (c * x + b) else at_left (c * x + b))\n\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b) &&&\n    filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)", "by auto"], ["proof (state)\nthis:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "then"], ["proof (chain)\npicking this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)", "have \"jump (f \\<circ> ?g) x = jump f (c * x + b)\""], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)\n\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x = jump f (c * x + b)", "unfolding jump_def filterlim_def comp_def"], ["proof (prove)\nusing this:\n  filtermap (\\<lambda>x. c * x + b) (at_left x) = at_left (c * x + b)\n  filtermap (\\<lambda>x. c * x + b) (at_right x) = at_right (c * x + b)\n\ngoal (1 subgoal):\n 1. (if filtermap (\\<lambda>x. f (c * x + b)) (at_left x)\n        \\<le> at_bot \\<and>\n        filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_top\n     then 1\n     else if filtermap (\\<lambda>x. f (c * x + b)) (at_left x)\n             \\<le> at_top \\<and>\n             filtermap (\\<lambda>x. f (c * x + b)) (at_right x) \\<le> at_bot\n          then - 1 else 0) =\n    (if filtermap f (at_left (c * x + b)) \\<le> at_bot \\<and>\n        filtermap f (at_right (c * x + b)) \\<le> at_top\n     then 1\n     else if filtermap f (at_left (c * x + b)) \\<le> at_top \\<and>\n             filtermap f (at_right (c * x + b)) \\<le> at_bot\n          then - 1 else 0)", "by (auto simp add: filtermap_filtermap[of f ?g,symmetric])"], ["proof (state)\nthis:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = jump f (c * x + b)\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "then"], ["proof (chain)\npicking this:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = jump f (c * x + b)", "show ?thesis"], ["proof (prove)\nusing this:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = jump f (c * x + b)\n\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "using True"], ["proof (prove)\nusing this:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x = jump f (c * x + b)\n  0 < c\n\ngoal (1 subgoal):\n 1. jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n    (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))", "by auto"], ["proof (state)\nthis:\n  jump (f \\<circ> (\\<lambda>x. c * x + b)) x =\n  (if 0 < c then jump f (c * x + b) else - jump f (c * x + b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_divide_derivative:\n  assumes \"isCont f x\" \"g x = 0\" \"f x\\<noteq>0\" \n    and g_deriv:\"(g has_field_derivative c) (at x)\" and \"c\\<noteq>0\"\n  shows \"jump (\\<lambda>t. f t/g t) x = (if sgn c = sgn ( f x) then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have g_tendsto:\"(g \\<longlongrightarrow> 0) (at_left x)\" \"(g \\<longlongrightarrow> 0) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_left x) &&&\n    (g \\<longlongrightarrow> 0) (at_right x)", "by (metis DERIV_isCont Lim_at_imp_Lim_at_within assms(2) assms(4) continuous_at)+"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_left x)\n  (g \\<longlongrightarrow> 0) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have f_tendsto:\"(f \\<longlongrightarrow> f x) (at_left x)\" \"(f \\<longlongrightarrow> f x) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (at_left x) &&&\n    (f \\<longlongrightarrow> f x) (at_right x)", "using Lim_at_imp_Lim_at_within assms(1) continuous_at"], ["proof (prove)\nusing this:\n  ?f \\<midarrow>?x\\<rightarrow> ?l \\<Longrightarrow>\n  (?f \\<longlongrightarrow> ?l) (at ?x within ?S)\n  isCont f x\n  isCont ?f ?x = ?f \\<midarrow>?x\\<rightarrow> ?f ?x\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (at_left x) &&&\n    (f \\<longlongrightarrow> f x) (at_right x)", "by blast+"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f x) (at_left x)\n  (f \\<longlongrightarrow> f x) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have ?thesis when \"c>0\" \"f x>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx - sgn (f x)) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_left x)", "using has_sgnx_derivative_at_left[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx - sgn c) (at_left x)\n  0 < c\n  0 < f x\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx sgn (f x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_right x)", "using has_sgnx_derivative_at_right[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx sgn c) (at_right x)\n  0 < c\n  0 < f x\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)", "have \"(LIM t at_left x. f t / g t :> at_bot) \\<and> (LIM t at_right x. f t / g t :> at_top)\""], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_bot) \\<and>\n    (LIM t at_right x. f t / g t :> at_top)", "using filterlim_divide_at_bot_at_top_iff[OF _ \\<open>f x\\<noteq>0\\<close>, of f]"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_bot) \\<and>\n    (LIM t at_right x. f t / g t :> at_top)", "using f_tendsto(1) f_tendsto(2) g_tendsto(1) g_tendsto(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) (at_left x)\n  (f \\<longlongrightarrow> f x) (at_right x)\n  (g \\<longlongrightarrow> 0) (at_left x)\n  (g \\<longlongrightarrow> 0) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_bot) \\<and>\n    (LIM t at_right x. f t / g t :> at_top)", "by blast"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"sgn c = sgn (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn c = sgn (f x)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n  0 < f x\n\ngoal (1 subgoal):\n 1. sgn c = sgn (f x)", "by auto"], ["proof (state)\nthis:\n  sgn c = sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n  sgn c = sgn (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n  sgn c = sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "unfolding jump_def"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n  sgn c = sgn (f x)\n\ngoal (1 subgoal):\n 1. (if (LIM t at_left x. f t / g t :> at_bot) \\<and>\n        (LIM t at_right x. f t / g t :> at_top)\n     then 1\n     else if (LIM t at_left x. f t / g t :> at_top) \\<and>\n             (LIM t at_right x. f t / g t :> at_bot)\n          then - 1 else 0) =\n    (if sgn c = sgn (f x) then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < c; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < c; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have ?thesis when \"c>0\" \"f x<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx sgn (f x)) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_left x)", "using has_sgnx_derivative_at_left[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx - sgn c) (at_left x)\n  0 < c\n  f x < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx - sgn (f x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_right x)", "using has_sgnx_derivative_at_right[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx sgn c) (at_right x)\n  0 < c\n  f x < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)", "have \"(LIM t at_left x. f t / g t :> at_top) \\<and> (LIM t at_right x. f t / g t :> at_bot)\""], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_top) \\<and>\n    (LIM t at_right x. f t / g t :> at_bot)", "using filterlim_divide_at_bot_at_top_iff[OF _ \\<open>f x\\<noteq>0\\<close>, of f]"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_top) \\<and>\n    (LIM t at_right x. f t / g t :> at_bot)", "using f_tendsto(1) f_tendsto(2) g_tendsto(1) g_tendsto(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) (at_left x)\n  (f \\<longlongrightarrow> f x) (at_right x)\n  (g \\<longlongrightarrow> 0) (at_left x)\n  (g \\<longlongrightarrow> 0) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_top) \\<and>\n    (LIM t at_right x. f t / g t :> at_bot)", "by blast"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "from this"], ["proof (chain)\npicking this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)", "have \"\\<not> (LIM t at_left x. f t / g t :> at_bot)\""], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. \\<not> (LIM t at_left x. f t / g t :> at_bot)", "using filterlim_at_top_at_bot"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<lbrakk>filterlim ?f at_top ?F; filterlim ?f at_bot ?F;\n   ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (LIM t at_left x. f t / g t :> at_bot)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"sgn c \\<noteq> sgn (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn c \\<noteq> sgn (f x)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n  f x < 0\n\ngoal (1 subgoal):\n 1. sgn c \\<noteq> sgn (f x)", "by auto"], ["proof (state)\nthis:\n  sgn c \\<noteq> sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n  sgn c \\<noteq> sgn (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n  sgn c \\<noteq> sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "unfolding jump_def"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n  sgn c \\<noteq> sgn (f x)\n\ngoal (1 subgoal):\n 1. (if (LIM t at_left x. f t / g t :> at_bot) \\<and>\n        (LIM t at_right x. f t / g t :> at_top)\n     then 1\n     else if (LIM t at_left x. f t / g t :> at_top) \\<and>\n             (LIM t at_right x. f t / g t :> at_bot)\n          then - 1 else 0) =\n    (if sgn c = sgn (f x) then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < c; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < c; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have ?thesis when \"c<0\" \"f x>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx sgn (f x)) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_left x)", "using has_sgnx_derivative_at_left[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx - sgn c) (at_left x)\n  c < 0\n  0 < f x\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx - sgn (f x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_right x)", "using has_sgnx_derivative_at_right[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx sgn c) (at_right x)\n  c < 0\n  0 < f x\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)", "have \"(LIM t at_left x. f t / g t :> at_top) \\<and> (LIM t at_right x. f t / g t :> at_bot)\""], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_top) \\<and>\n    (LIM t at_right x. f t / g t :> at_bot)", "using filterlim_divide_at_bot_at_top_iff[OF _ \\<open>f x\\<noteq>0\\<close>, of f]"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_top) \\<and>\n    (LIM t at_right x. f t / g t :> at_bot)", "using f_tendsto(1) f_tendsto(2) g_tendsto(1) g_tendsto(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f x)) (at_left x)\n  (g has_sgnx - sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) (at_left x)\n  (f \\<longlongrightarrow> f x) (at_right x)\n  (g \\<longlongrightarrow> 0) (at_left x)\n  (g \\<longlongrightarrow> 0) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_top) \\<and>\n    (LIM t at_right x. f t / g t :> at_bot)", "by blast"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "from this"], ["proof (chain)\npicking this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)", "have \"\\<not> (LIM t at_left x. f t / g t :> at_bot)\""], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. \\<not> (LIM t at_left x. f t / g t :> at_bot)", "using filterlim_at_top_at_bot"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<lbrakk>filterlim ?f at_top ?F; filterlim ?f at_bot ?F;\n   ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (LIM t at_left x. f t / g t :> at_bot)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"sgn c \\<noteq> sgn (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn c \\<noteq> sgn (f x)", "using that"], ["proof (prove)\nusing this:\n  c < 0\n  0 < f x\n\ngoal (1 subgoal):\n 1. sgn c \\<noteq> sgn (f x)", "by auto"], ["proof (state)\nthis:\n  sgn c \\<noteq> sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n  sgn c \\<noteq> sgn (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n  sgn c \\<noteq> sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "unfolding jump_def"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_top) \\<and>\n  (LIM t at_right x. f t / g t :> at_bot)\n  \\<not> (LIM t at_left x. f t / g t :> at_bot)\n  sgn c \\<noteq> sgn (f x)\n\ngoal (1 subgoal):\n 1. (if (LIM t at_left x. f t / g t :> at_bot) \\<and>\n        (LIM t at_right x. f t / g t :> at_top)\n     then 1\n     else if (LIM t at_left x. f t / g t :> at_top) \\<and>\n             (LIM t at_right x. f t / g t :> at_bot)\n          then - 1 else 0) =\n    (if sgn c = sgn (f x) then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c < 0; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c < 0; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have ?thesis when \"c<0\" \"f x<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx - sgn (f x)) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_left x)", "using has_sgnx_derivative_at_left[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx - sgn c) (at_left x)\n  c < 0\n  f x < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f x)) (at_left x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"(g has_sgnx sgn (f x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_right x)", "using has_sgnx_derivative_at_right[OF g_deriv \\<open>g x=0\\<close>] that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> (g has_sgnx sgn c) (at_right x)\n  c < 0\n  f x < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f x)) (at_right x)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)", "have \"(LIM t at_left x. f t / g t :> at_bot) \\<and> (LIM t at_right x. f t / g t :> at_top)\""], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_bot) \\<and>\n    (LIM t at_right x. f t / g t :> at_top)", "using filterlim_divide_at_bot_at_top_iff[OF _ \\<open>f x\\<noteq>0\\<close>, of f]"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_bot) \\<and>\n    (LIM t at_right x. f t / g t :> at_top)", "using f_tendsto(1) f_tendsto(2) g_tendsto(1) g_tendsto(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f x)) (at_left x)\n  (g has_sgnx sgn (f x)) (at_right x)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_bot) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx - sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) ?F \\<Longrightarrow>\n  (LIM x ?F. f x / ?g x :> at_top) =\n  ((?g \\<longlongrightarrow> 0) ?F \\<and> (?g has_sgnx sgn (f x)) ?F)\n  (f \\<longlongrightarrow> f x) (at_left x)\n  (f \\<longlongrightarrow> f x) (at_right x)\n  (g \\<longlongrightarrow> 0) (at_left x)\n  (g \\<longlongrightarrow> 0) (at_right x)\n\ngoal (1 subgoal):\n 1. (LIM t at_left x. f t / g t :> at_bot) \\<and>\n    (LIM t at_right x. f t / g t :> at_top)", "by blast"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "have \"sgn c =sgn (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn c = sgn (f x)", "using that"], ["proof (prove)\nusing this:\n  c < 0\n  f x < 0\n\ngoal (1 subgoal):\n 1. sgn c = sgn (f x)", "by auto"], ["proof (state)\nthis:\n  sgn c = sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n  sgn c = sgn (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n  sgn c = sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "unfolding jump_def"], ["proof (prove)\nusing this:\n  (LIM t at_left x. f t / g t :> at_bot) \\<and>\n  (LIM t at_right x. f t / g t :> at_top)\n  sgn c = sgn (f x)\n\ngoal (1 subgoal):\n 1. (if (LIM t at_left x. f t / g t :> at_bot) \\<and>\n        (LIM t at_right x. f t / g t :> at_top)\n     then 1\n     else if (LIM t at_left x. f t / g t :> at_top) \\<and>\n             (LIM t at_right x. f t / g t :> at_bot)\n          then - 1 else 0) =\n    (if sgn c = sgn (f x) then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c < 0; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < c; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>0 < c; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>c < 0; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>c < 0; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < c; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>0 < c; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>c < 0; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>c < 0; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "using \\<open>c\\<noteq>0\\<close> \\<open>f x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < c; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>0 < c; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>c < 0; 0 < f x\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  \\<lbrakk>c < 0; f x < 0\\<rbrakk>\n  \\<Longrightarrow> jump (\\<lambda>t. f t / g t) x =\n                    (if sgn c = sgn (f x) then 1 else - 1)\n  c \\<noteq> 0\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)", "by argo"], ["proof (state)\nthis:\n  jump (\\<lambda>t. f t / g t) x = (if sgn c = sgn (f x) then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_jump_poly: \"jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "obtain p' q' where p':\"p= p'*gcd p q\" and q':\"q=q'*gcd p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p = p' * gcd p q; q = q' * gcd p q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gcd_dvd1 gcd_dvd2 dvd_def[of \"gcd p q\", simplified mult.commute]"], ["proof (prove)\nusing this:\n  gcd ?a ?b dvd ?a\n  gcd ?a ?b dvd ?b\n  (gcd p q dvd ?a) = (\\<exists>k. ?a = k * gcd p q)\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p = p' * gcd p q; q = q' * gcd p q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  p = p' * gcd p q\n  q = q' * gcd p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  p = p' * gcd p q\n  q = q' * gcd p q", "have \"coprime p' q'\" \"p'\\<noteq>0\" \"gcd p q\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = p' * gcd p q\n  q = q' * gcd p q\n\ngoal (1 subgoal):\n 1. coprime p' q' &&& p' \\<noteq> 0 &&& gcd p q \\<noteq> 0", "using gcd_coprime \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = p' * gcd p q\n  q = q' * gcd p q\n  \\<lbrakk>gcd ?a ?b \\<noteq> (0::?'a); ?a = ?a' * gcd ?a ?b;\n   ?b = ?b' * gcd ?a ?b\\<rbrakk>\n  \\<Longrightarrow> coprime ?a' ?b'\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime p' q' &&& p' \\<noteq> 0 &&& gcd p q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  coprime p' q'\n  p' \\<noteq> 0\n  gcd p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "define f where \"f \\<equiv> (\\<lambda>x. poly q' x / poly p' x)\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>x. poly q' x / poly p' x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "define g where \"g \\<equiv> (\\<lambda>x. if poly (gcd p q) x = 0 then 0::real else 1)\""], ["proof (state)\nthis:\n  g \\<equiv> \\<lambda>x. if poly (gcd p q) x = 0 then 0 else 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have g_tendsto:\"(g \\<longlongrightarrow> 1) (at_left a)\" \"(g \\<longlongrightarrow> 1) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 1) (at_left a) &&&\n    (g \\<longlongrightarrow> 1) (at_right a)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (g \\<longlongrightarrow> 1) (at_left a)\n 2. (g \\<longlongrightarrow> 1) (at_right a)", "have\n      \"(poly (gcd p q) has_sgnx 1) (at_left a) \n          \\<or> (poly (gcd p q) has_sgnx - 1) (at_left a)\"\n      \"(poly (gcd p q) has_sgnx 1) (at_right a) \n          \\<or> (poly (gcd p q) has_sgnx - 1) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (gcd p q) has_sgnx 1) (at_left a) \\<or>\n    (poly (gcd p q) has_sgnx - 1) (at_left a) &&&\n    (poly (gcd p q) has_sgnx 1) (at_right a) \\<or>\n    (poly (gcd p q) has_sgnx - 1) (at_right a)", "using \\<open>p\\<noteq>0\\<close> poly_has_sgnx_values"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  (poly ?p has_sgnx 1) (at_left ?a) \\<or>\n  (poly ?p has_sgnx - 1) (at_left ?a)\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  (poly ?p has_sgnx 1) (at_right ?a) \\<or>\n  (poly ?p has_sgnx - 1) (at_right ?a)\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  (poly ?p has_sgnx 1) at_top \\<or> (poly ?p has_sgnx - 1) at_top\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  (poly ?p has_sgnx 1) at_bot \\<or> (poly ?p has_sgnx - 1) at_bot\n\ngoal (1 subgoal):\n 1. (poly (gcd p q) has_sgnx 1) (at_left a) \\<or>\n    (poly (gcd p q) has_sgnx - 1) (at_left a) &&&\n    (poly (gcd p q) has_sgnx 1) (at_right a) \\<or>\n    (poly (gcd p q) has_sgnx - 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (poly (gcd p q) has_sgnx 1) (at_left a) \\<or>\n  (poly (gcd p q) has_sgnx - 1) (at_left a)\n  (poly (gcd p q) has_sgnx 1) (at_right a) \\<or>\n  (poly (gcd p q) has_sgnx - 1) (at_right a)\n\ngoal (2 subgoals):\n 1. (g \\<longlongrightarrow> 1) (at_left a)\n 2. (g \\<longlongrightarrow> 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (poly (gcd p q) has_sgnx 1) (at_left a) \\<or>\n  (poly (gcd p q) has_sgnx - 1) (at_left a)\n  (poly (gcd p q) has_sgnx 1) (at_right a) \\<or>\n  (poly (gcd p q) has_sgnx - 1) (at_right a)", "have \" \\<forall>\\<^sub>F x in at_left a. g x = 1\" \" \\<forall>\\<^sub>F x in at_right a. g x = 1\""], ["proof (prove)\nusing this:\n  (poly (gcd p q) has_sgnx 1) (at_left a) \\<or>\n  (poly (gcd p q) has_sgnx - 1) (at_left a)\n  (poly (gcd p q) has_sgnx 1) (at_right a) \\<or>\n  (poly (gcd p q) has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a. g x = 1 &&&\n    \\<forall>\\<^sub>F x in at_right a. g x = 1", "unfolding has_sgnx_def g_def"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F x in at_left a. sgn (poly (gcd p q) x) = 1) \\<or>\n  (\\<forall>\\<^sub>F x in at_left a. sgn (poly (gcd p q) x) = - 1)\n  (\\<forall>\\<^sub>F x in at_right a. sgn (poly (gcd p q) x) = 1) \\<or>\n  (\\<forall>\\<^sub>F x in at_right a. sgn (poly (gcd p q) x) = - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a.\n       (if poly (gcd p q) x = 0 then 0 else 1) = 1 &&&\n    \\<forall>\\<^sub>F x in at_right a.\n       (if poly (gcd p q) x = 0 then 0 else 1) = 1", "by (auto elim:eventually_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left a. g x = 1\n  \\<forall>\\<^sub>F x in at_right a. g x = 1\n\ngoal (2 subgoals):\n 1. (g \\<longlongrightarrow> 1) (at_left a)\n 2. (g \\<longlongrightarrow> 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left a. g x = 1\n  \\<forall>\\<^sub>F x in at_right a. g x = 1", "show \"(g \\<longlongrightarrow> 1) (at_left a)\" \"(g \\<longlongrightarrow> 1) (at_right a)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. g x = 1\n  \\<forall>\\<^sub>F x in at_right a. g x = 1\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 1) (at_left a) &&&\n    (g \\<longlongrightarrow> 1) (at_right a)", "using tendsto_eventually"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left a. g x = 1\n  \\<forall>\\<^sub>F x in at_right a. g x = 1\n  \\<forall>\\<^sub>F x in ?net. ?f x = ?l \\<Longrightarrow>\n  (?f \\<longlongrightarrow> ?l) ?net\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 1) (at_left a) &&&\n    (g \\<longlongrightarrow> 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 1) (at_left a)\n  (g \\<longlongrightarrow> 1) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 1) (at_left a)\n  (g \\<longlongrightarrow> 1) (at_right a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"poly q x / poly p x = g x * f x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x / poly p x = g x * f x", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    (if poly (gcd p q) x = 0 then 0 else 1) * (poly q' x / poly p' x)", "by (subst p',subst q',auto)"], ["proof (state)\nthis:\n  poly q ?x / poly p ?x = g ?x * f ?x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "then"], ["proof (chain)\npicking this:\n  poly q ?x / poly p ?x = g ?x * f ?x", "have \"jump (\\<lambda>x. poly q x / poly p x) a = jump (\\<lambda>x. g x * f x) a\""], ["proof (prove)\nusing this:\n  poly q ?x / poly p ?x = g ?x * f ?x\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a =\n    jump (\\<lambda>x. g x * f x) a", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump (\\<lambda>x. g x * f x) a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "also"], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump (\\<lambda>x. g x * f x) a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"... = jump f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. g x * f x) a = jump f a", "unfolding jump_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (LIM x at_left a. g x * f x :> at_bot) \\<and>\n        (LIM x at_right a. g x * f x :> at_top)\n     then 1\n     else if (LIM x at_left a. g x * f x :> at_top) \\<and>\n             (LIM x at_right a. g x * f x :> at_bot)\n          then - 1 else 0) =\n    (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0)", "apply (subst (1 2) filterlim_tendsto_pos_mult_at_top_iff)"], ["proof (prove)\ngoal (5 subgoals):\n 1. (g \\<longlongrightarrow> ?c) (at_left a)\n 2. 0 < ?c\n 3. (g \\<longlongrightarrow> ?c1) (at_right a)\n 4. 0 < ?c1\n 5. (if (LIM x at_left a. g x * f x :> at_bot) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             (LIM x at_right a. g x * f x :> at_bot)\n          then - 1 else 0) =\n    (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0)", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. (if (LIM x at_left a. g x * f x :> at_bot) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             (LIM x at_right a. g x * f x :> at_bot)\n          then - 1 else 0) =\n    (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0)\n 2. (g \\<longlongrightarrow> ?c) (at_left a)\n 3. 0 < ?c\n 4. (g \\<longlongrightarrow> ?c1) (at_right a)\n 5. 0 < ?c1", "apply (subst (1 2) filterlim_tendsto_pos_mult_at_bot_iff)"], ["proof (prove)\ngoal (9 subgoals):\n 1. (g \\<longlongrightarrow> ?c3) (at_right a)\n 2. 0 < ?c3\n 3. (g \\<longlongrightarrow> ?c4) (at_left a)\n 4. 0 < ?c4\n 5. (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0) =\n    (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0)\n 6. (g \\<longlongrightarrow> ?c) (at_left a)\n 7. 0 < ?c\n 8. (g \\<longlongrightarrow> ?c1) (at_right a)\n 9. 0 < ?c1", "using g_tendsto"], ["proof (prove)\nusing this:\n  (g \\<longlongrightarrow> 1) (at_left a)\n  (g \\<longlongrightarrow> 1) (at_right a)\n\ngoal (9 subgoals):\n 1. (g \\<longlongrightarrow> ?c3) (at_right a)\n 2. 0 < ?c3\n 3. (g \\<longlongrightarrow> ?c4) (at_left a)\n 4. 0 < ?c4\n 5. (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0) =\n    (if filterlim f at_bot (at_left a) \\<and>\n        filterlim f at_top (at_right a)\n     then 1\n     else if filterlim f at_top (at_left a) \\<and>\n             filterlim f at_bot (at_right a)\n          then - 1 else 0)\n 6. (g \\<longlongrightarrow> ?c) (at_left a)\n 7. 0 < ?c\n 8. (g \\<longlongrightarrow> ?c1) (at_right a)\n 9. 0 < ?c1", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>x. g x * f x) a = jump f a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "also"], ["proof (state)\nthis:\n  jump (\\<lambda>x. g x * f x) a = jump f a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"... = jump_poly q' p' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump f a = jump_poly q' p' a", "using jump_jump_poly_aux[OF \\<open>p'\\<noteq>0\\<close> \\<open>coprime p' q'\\<close>]"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q' x / poly p' x) ?a = jump_poly q' p' ?a\n\ngoal (1 subgoal):\n 1. jump f a = jump_poly q' p' a", "unfolding f_def"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q' x / poly p' x) ?a = jump_poly q' p' ?a\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q' x / poly p' x) a = jump_poly q' p' a", "by auto"], ["proof (state)\nthis:\n  jump f a = jump_poly q' p' a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "also"], ["proof (state)\nthis:\n  jump f a = jump_poly q' p' a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "have \"... = jump_poly q p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly q' p' a = jump_poly q p a", "using jump_poly_mult[OF \\<open>gcd p q \\<noteq> 0\\<close>, of q'] p' q'"], ["proof (prove)\nusing this:\n  jump_poly (gcd p q * q') (gcd p q * ?p) ?x = jump_poly q' ?p ?x\n  p = p' * gcd p q\n  q = q' * gcd p q\n\ngoal (1 subgoal):\n 1. jump_poly q' p' a = jump_poly q p a", "by (metis mult.commute)"], ["proof (state)\nthis:\n  jump_poly q' p' a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "finally"], ["proof (chain)\npicking this:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "show ?thesis"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a", "."], ["proof (state)\nthis:\n  jump (\\<lambda>x. poly q x / poly p x) a = jump_poly q p a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_Im_divide_Re_0:\n  assumes \"path g\" \"Re (g x)\\<noteq>0\" \"0<x\" \"x<1\"\n  shows \"jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0", "have \"isCont g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont g x", "using \\<open>path g\\<close>[unfolded path_def] \\<open>0<x\\<close> \\<open>x<1\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  0 < x\n  x < 1\n\ngoal (1 subgoal):\n 1. isCont g x", "apply (elim continuous_on_interior)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x < 1\\<rbrakk> \\<Longrightarrow> x \\<in> interior {0..1}", "by auto"], ["proof (state)\nthis:\n  isCont g x\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0", "then"], ["proof (chain)\npicking this:\n  isCont g x", "have \"isCont (\\<lambda>t. Im(g t)/Re(g t)) x\""], ["proof (prove)\nusing this:\n  isCont g x\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t) / Re (g t)) x", "using \\<open>Re (g x)\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  isCont g x\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t) / Re (g t)) x", "by (auto intro:continuous_intros isCont_Re isCont_Im)"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. Im (g t) / Re (g t)) x\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0", "then"], ["proof (chain)\npicking this:\n  isCont (\\<lambda>t. Im (g t) / Re (g t)) x", "show \"jump (\\<lambda>t. Im(g t)/Re(g t)) x=0\""], ["proof (prove)\nusing this:\n  isCont (\\<lambda>t. Im (g t) / Re (g t)) x\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0", "using jump_not_infinity"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>t. Im (g t) / Re (g t)) x\n  isCont ?f ?a \\<Longrightarrow> jump ?f ?a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (g t) / Re (g t)) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_im_divide_Re_0:\n  assumes \"path g\" \"Re (g x)\\<noteq>0\" \n  shows \"\\<lbrakk>0\\<le>x;x<1\\<rbrakk> \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_right x) = 0\"\n        \"\\<lbrakk>0<x;x\\<le>1\\<rbrakk> \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_left x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 \\<le> x; x < 1\\<rbrakk>\n     \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t))\n                        (at_right x) =\n                       0) &&&\n    (\\<lbrakk>0 < x; x \\<le> 1\\<rbrakk>\n     \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_left x) =\n                       0)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk>\n    \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_right x) =\n                      0\n 2. \\<lbrakk>0 < x; x \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_left x) =\n                      0", "define g' where \"g' = (\\<lambda>t. Im (g t) / Re (g t))\""], ["proof (state)\nthis:\n  g' = (\\<lambda>t. Im (g t) / Re (g t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk>\n    \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_right x) =\n                      0\n 2. \\<lbrakk>0 < x; x \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_left x) =\n                      0", "show \"jumpF g' (at_right x) = 0\" when \"0\\<le>x\" \"x<1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF g' (at_right x) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF g' (at_right x) = 0", "have \"(g' \\<longlongrightarrow> g' x) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_right x)", "proof (cases \"x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "have \"continuous (at_right 0) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_right 0) g", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (1 subgoal):\n 1. continuous (at_right 0) g", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous (at_right 0) g", "by (auto elim:continuous_on_at_right)"], ["proof (state)\nthis:\n  continuous (at_right 0) g\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "then"], ["proof (chain)\npicking this:\n  continuous (at_right 0) g", "have \"continuous (at_right x) (\\<lambda>t. Im(g t))\" \"continuous (at_right x) (\\<lambda>t. Re(g t))\""], ["proof (prove)\nusing this:\n  continuous (at_right 0) g\n\ngoal (1 subgoal):\n 1. continuous (at_right x) (\\<lambda>t. Im (g t)) &&&\n    continuous (at_right x) (\\<lambda>t. Re (g t))", "using continuous_Im continuous_Re True"], ["proof (prove)\nusing this:\n  continuous (at_right 0) g\n  continuous ?F ?g \\<Longrightarrow> continuous ?F (\\<lambda>x. Im (?g x))\n  continuous ?F ?g \\<Longrightarrow> continuous ?F (\\<lambda>x. Re (?g x))\n  x = 0\n\ngoal (1 subgoal):\n 1. continuous (at_right x) (\\<lambda>t. Im (g t)) &&&\n    continuous (at_right x) (\\<lambda>t. Re (g t))", "by auto"], ["proof (state)\nthis:\n  continuous (at_right x) (\\<lambda>t. Im (g t))\n  continuous (at_right x) (\\<lambda>t. Re (g t))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "moreover"], ["proof (state)\nthis:\n  continuous (at_right x) (\\<lambda>t. Im (g t))\n  continuous (at_right x) (\\<lambda>t. Re (g t))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "have \"Re (g (netlimit (at_right x))) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g (netlimit (at_right x))) \\<noteq> 0", "using assms(2)"], ["proof (prove)\nusing this:\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (g (netlimit (at_right x))) \\<noteq> 0", "by (simp add: Lim_ident_at)"], ["proof (state)\nthis:\n  Re (g (netlimit (at_right x))) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "ultimately"], ["proof (chain)\npicking this:\n  continuous (at_right x) (\\<lambda>t. Im (g t))\n  continuous (at_right x) (\\<lambda>t. Re (g t))\n  Re (g (netlimit (at_right x))) \\<noteq> 0", "have \"continuous (at_right x) (\\<lambda>t. Im (g t)/Re(g t))\""], ["proof (prove)\nusing this:\n  continuous (at_right x) (\\<lambda>t. Im (g t))\n  continuous (at_right x) (\\<lambda>t. Re (g t))\n  Re (g (netlimit (at_right x))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_right x) (\\<lambda>t. Im (g t) / Re (g t))", "by (auto intro:continuous_divide)"], ["proof (state)\nthis:\n  continuous (at_right x) (\\<lambda>t. Im (g t) / Re (g t))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_right x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "then"], ["proof (chain)\npicking this:\n  continuous (at_right x) (\\<lambda>t. Im (g t) / Re (g t))", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous (at_right x) (\\<lambda>t. Im (g t) / Re (g t))\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_right x)", "unfolding g'_def continuous_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. Im (g t) / Re (g t)) \\<longlongrightarrow>\n   Im (g (netlimit (at_right x))) / Re (g (netlimit (at_right x))))\n   (at_right x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Im (g t) / Re (g t)) \\<longlongrightarrow>\n     Im (g x) / Re (g x))\n     (at_right x)", "by (simp add: Lim_ident_at)"], ["proof (state)\nthis:\n  (g' \\<longlongrightarrow> g' x) (at_right x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "have \"isCont (\\<lambda>x. Im (g x)) x\" \"isCont (\\<lambda>x. Re (g x)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. Im (g x)) x &&& isCont (\\<lambda>x. Re (g x)) x", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. Im (g x)) x &&& isCont (\\<lambda>x. Re (g x)) x", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. Im (g x)) x &&& isCont (\\<lambda>x. Re (g x)) x", "by (metis False atLeastAtMost_iff at_within_Icc_at continuous_Im continuous_Re\n          continuous_on_eq_continuous_within less_le that)+"], ["proof (state)\nthis:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "then"], ["proof (chain)\npicking this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x", "have \"isCont g' x\""], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n\ngoal (1 subgoal):\n 1. isCont g' x", "using assms(2)"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont g' x", "unfolding g'_def"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t) / Re (g t)) x", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  isCont g' x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_right x)", "then"], ["proof (chain)\npicking this:\n  isCont g' x", "show ?thesis"], ["proof (prove)\nusing this:\n  isCont g' x\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_right x)", "unfolding isCont_def"], ["proof (prove)\nusing this:\n  g' \\<midarrow>x\\<rightarrow> g' x\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_right x)", "using filterlim_at_split"], ["proof (prove)\nusing this:\n  g' \\<midarrow>x\\<rightarrow> g' x\n  filterlim ?f ?F (at ?x) =\n  (filterlim ?f ?F (at_left ?x) \\<and> filterlim ?f ?F (at_right ?x))\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_right x)", "by blast"], ["proof (state)\nthis:\n  (g' \\<longlongrightarrow> g' x) (at_right x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g' \\<longlongrightarrow> g' x) (at_right x)\n\ngoal (1 subgoal):\n 1. jumpF g' (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  (g' \\<longlongrightarrow> g' x) (at_right x)", "have \"\\<not> filterlim g' at_top (at_right x)\" \"\\<not> filterlim g' at_bot (at_right x)\""], ["proof (prove)\nusing this:\n  (g' \\<longlongrightarrow> g' x) (at_right x)\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g' at_top (at_right x) &&&\n    \\<not> filterlim g' at_bot (at_right x)", "using filterlim_at_top_nhds[of g' \"at_right x\"] filterlim_at_bot_nhds[of g' \"at_right x\"]"], ["proof (prove)\nusing this:\n  (g' \\<longlongrightarrow> g' x) (at_right x)\n  \\<lbrakk>filterlim g' at_top (at_right x);\n   (g' \\<longlongrightarrow> ?c) (at_right x);\n   at_right x \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>filterlim g' at_bot (at_right x);\n   (g' \\<longlongrightarrow> ?c) (at_right x);\n   at_right x \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g' at_top (at_right x) &&&\n    \\<not> filterlim g' at_bot (at_right x)", "by auto"], ["proof (state)\nthis:\n  \\<not> filterlim g' at_top (at_right x)\n  \\<not> filterlim g' at_bot (at_right x)\n\ngoal (1 subgoal):\n 1. jumpF g' (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  \\<not> filterlim g' at_top (at_right x)\n  \\<not> filterlim g' at_bot (at_right x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> filterlim g' at_top (at_right x)\n  \\<not> filterlim g' at_bot (at_right x)\n\ngoal (1 subgoal):\n 1. jumpF g' (at_right x) = 0", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  \\<not> filterlim g' at_top (at_right x)\n  \\<not> filterlim g' at_bot (at_right x)\n\ngoal (1 subgoal):\n 1. (if filterlim g' at_top (at_right x) then 1 / 2\n     else if filterlim g' at_bot (at_right x) then - 1 / 2 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jumpF g' (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF g' (at_right x) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk> \\<Longrightarrow> 0 \\<le> x\n 2. \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk> \\<Longrightarrow> x < 1\n 3. \\<lbrakk>0 < x; x \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> jumpF (\\<lambda>t. Im (g t) / Re (g t)) (at_left x) =\n                      0", "show \"jumpF g' (at_left x) = 0\" when \"0<x\" \"x\\<le>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF g' (at_left x) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF g' (at_left x) = 0", "have \"(g' \\<longlongrightarrow> g' x) (at_left x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_left x)", "proof (cases \"x=1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "case True"], ["proof (state)\nthis:\n  x = 1\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "have \"continuous (at_left 1) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_left 1) g", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (1 subgoal):\n 1. continuous (at_left 1) g", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous (at_left 1) g", "by (auto elim:continuous_on_at_left)"], ["proof (state)\nthis:\n  continuous (at_left 1) g\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "then"], ["proof (chain)\npicking this:\n  continuous (at_left 1) g", "have \"continuous (at_left x) (\\<lambda>t. Im(g t))\" \"continuous (at_left x) (\\<lambda>t. Re(g t))\""], ["proof (prove)\nusing this:\n  continuous (at_left 1) g\n\ngoal (1 subgoal):\n 1. continuous (at_left x) (\\<lambda>t. Im (g t)) &&&\n    continuous (at_left x) (\\<lambda>t. Re (g t))", "using continuous_Im continuous_Re True"], ["proof (prove)\nusing this:\n  continuous (at_left 1) g\n  continuous ?F ?g \\<Longrightarrow> continuous ?F (\\<lambda>x. Im (?g x))\n  continuous ?F ?g \\<Longrightarrow> continuous ?F (\\<lambda>x. Re (?g x))\n  x = 1\n\ngoal (1 subgoal):\n 1. continuous (at_left x) (\\<lambda>t. Im (g t)) &&&\n    continuous (at_left x) (\\<lambda>t. Re (g t))", "by auto"], ["proof (state)\nthis:\n  continuous (at_left x) (\\<lambda>t. Im (g t))\n  continuous (at_left x) (\\<lambda>t. Re (g t))\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "moreover"], ["proof (state)\nthis:\n  continuous (at_left x) (\\<lambda>t. Im (g t))\n  continuous (at_left x) (\\<lambda>t. Re (g t))\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "have \"Re (g (netlimit (at_left x))) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g (netlimit (at_left x))) \\<noteq> 0", "using assms(2)"], ["proof (prove)\nusing this:\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (g (netlimit (at_left x))) \\<noteq> 0", "by (simp add: Lim_ident_at)"], ["proof (state)\nthis:\n  Re (g (netlimit (at_left x))) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "ultimately"], ["proof (chain)\npicking this:\n  continuous (at_left x) (\\<lambda>t. Im (g t))\n  continuous (at_left x) (\\<lambda>t. Re (g t))\n  Re (g (netlimit (at_left x))) \\<noteq> 0", "have \"continuous (at_left x) (\\<lambda>t. Im (g t)/Re(g t))\""], ["proof (prove)\nusing this:\n  continuous (at_left x) (\\<lambda>t. Im (g t))\n  continuous (at_left x) (\\<lambda>t. Re (g t))\n  Re (g (netlimit (at_left x))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_left x) (\\<lambda>t. Im (g t) / Re (g t))", "by (auto intro:continuous_divide)"], ["proof (state)\nthis:\n  continuous (at_left x) (\\<lambda>t. Im (g t) / Re (g t))\n\ngoal (2 subgoals):\n 1. x = 1 \\<Longrightarrow> (g' \\<longlongrightarrow> g' x) (at_left x)\n 2. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "then"], ["proof (chain)\npicking this:\n  continuous (at_left x) (\\<lambda>t. Im (g t) / Re (g t))", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous (at_left x) (\\<lambda>t. Im (g t) / Re (g t))\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_left x)", "unfolding g'_def continuous_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. Im (g t) / Re (g t)) \\<longlongrightarrow>\n   Im (g (netlimit (at_left x))) / Re (g (netlimit (at_left x))))\n   (at_left x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Im (g t) / Re (g t)) \\<longlongrightarrow>\n     Im (g x) / Re (g x))\n     (at_left x)", "by (simp add: Lim_ident_at)"], ["proof (state)\nthis:\n  (g' \\<longlongrightarrow> g' x) (at_left x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "have \"isCont (\\<lambda>x. Im (g x)) x\" \"isCont (\\<lambda>x. Re (g x)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. Im (g x)) x &&& isCont (\\<lambda>x. Re (g x)) x", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. Im (g x)) x &&& isCont (\\<lambda>x. Re (g x)) x", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. Im (g x)) x &&& isCont (\\<lambda>x. Re (g x)) x", "by (metis False atLeastAtMost_iff at_within_Icc_at continuous_Im continuous_Re\n          continuous_on_eq_continuous_within less_le that)+"], ["proof (state)\nthis:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "then"], ["proof (chain)\npicking this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x", "have \"isCont g' x\""], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n\ngoal (1 subgoal):\n 1. isCont g' x", "using assms(2)"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont g' x", "unfolding g'_def"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Im (g x)) x\n  isCont (\\<lambda>x. Re (g x)) x\n  Re (g x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t) / Re (g t)) x", "by (auto)"], ["proof (state)\nthis:\n  isCont g' x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1 \\<Longrightarrow>\n    (g' \\<longlongrightarrow> g' x) (at_left x)", "then"], ["proof (chain)\npicking this:\n  isCont g' x", "show ?thesis"], ["proof (prove)\nusing this:\n  isCont g' x\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_left x)", "unfolding isCont_def"], ["proof (prove)\nusing this:\n  g' \\<midarrow>x\\<rightarrow> g' x\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_left x)", "using filterlim_at_split"], ["proof (prove)\nusing this:\n  g' \\<midarrow>x\\<rightarrow> g' x\n  filterlim ?f ?F (at ?x) =\n  (filterlim ?f ?F (at_left ?x) \\<and> filterlim ?f ?F (at_right ?x))\n\ngoal (1 subgoal):\n 1. (g' \\<longlongrightarrow> g' x) (at_left x)", "by blast"], ["proof (state)\nthis:\n  (g' \\<longlongrightarrow> g' x) (at_left x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g' \\<longlongrightarrow> g' x) (at_left x)\n\ngoal (1 subgoal):\n 1. jumpF g' (at_left x) = 0", "then"], ["proof (chain)\npicking this:\n  (g' \\<longlongrightarrow> g' x) (at_left x)", "have \"\\<not> filterlim g' at_top (at_left x)\" \"\\<not> filterlim g' at_bot (at_left x)\""], ["proof (prove)\nusing this:\n  (g' \\<longlongrightarrow> g' x) (at_left x)\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g' at_top (at_left x) &&&\n    \\<not> filterlim g' at_bot (at_left x)", "using filterlim_at_top_nhds[of g' \"at_left x\"] filterlim_at_bot_nhds[of g' \"at_left x\"]"], ["proof (prove)\nusing this:\n  (g' \\<longlongrightarrow> g' x) (at_left x)\n  \\<lbrakk>filterlim g' at_top (at_left x);\n   (g' \\<longlongrightarrow> ?c) (at_left x);\n   at_left x \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>filterlim g' at_bot (at_left x);\n   (g' \\<longlongrightarrow> ?c) (at_left x);\n   at_left x \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> filterlim g' at_top (at_left x) &&&\n    \\<not> filterlim g' at_bot (at_left x)", "by auto"], ["proof (state)\nthis:\n  \\<not> filterlim g' at_top (at_left x)\n  \\<not> filterlim g' at_bot (at_left x)\n\ngoal (1 subgoal):\n 1. jumpF g' (at_left x) = 0", "then"], ["proof (chain)\npicking this:\n  \\<not> filterlim g' at_top (at_left x)\n  \\<not> filterlim g' at_bot (at_left x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> filterlim g' at_top (at_left x)\n  \\<not> filterlim g' at_bot (at_left x)\n\ngoal (1 subgoal):\n 1. jumpF g' (at_left x) = 0", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  \\<not> filterlim g' at_top (at_left x)\n  \\<not> filterlim g' at_bot (at_left x)\n\ngoal (1 subgoal):\n 1. (if filterlim g' at_top (at_left x) then 1 / 2\n     else if filterlim g' at_bot (at_left x) then - 1 / 2 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jumpF g' (at_left x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> jumpF g' (at_left x) = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk> \\<Longrightarrow> 0 \\<le> x\n 2. \\<lbrakk>0 \\<le> x; x < 1\\<rbrakk> \\<Longrightarrow> x < 1\n 3. \\<lbrakk>0 < x; x \\<le> 1\\<rbrakk> \\<Longrightarrow> 0 < x\n 4. \\<lbrakk>0 < x; x \\<le> 1\\<rbrakk> \\<Longrightarrow> x \\<le> 1", "qed"], ["", "lemma jump_cong:\n  assumes \"x=y\" and \"eventually (\\<lambda>x. f x=g x) (at x)\"\n  shows \"jump f x = jump g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump f x = jump g y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump f x = jump g y", "have left:\"eventually (\\<lambda>x. f x=g x) (at_left x)\" \n    and right:\"eventually (\\<lambda>x. f x=g x) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left x. f x = g x &&&\n    \\<forall>\\<^sub>F x in at_right x. f x = g x", "using assms(2) eventually_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x. f x = g x\n  eventually ?P (at ?x) =\n  (eventually ?P (at_left ?x) \\<and> eventually ?P (at_right ?x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left x. f x = g x &&&\n    \\<forall>\\<^sub>F x in at_right x. f x = g x", "by blast+"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left x. f x = g x\n  \\<forall>\\<^sub>F x in at_right x. f x = g x\n\ngoal (1 subgoal):\n 1. jump f x = jump g y", "from filterlim_cong[OF _ _ this(1)] filterlim_cong[OF _ _ this(2)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?F1.0 = ?F1'; at_left x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_left x) = filterlim g ?F1' ?F2'\n  \\<lbrakk>?F1.0 = ?F1'; at_right x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_right x) = filterlim g ?F1' ?F2'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?F1.0 = ?F1'; at_left x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_left x) = filterlim g ?F1' ?F2'\n  \\<lbrakk>?F1.0 = ?F1'; at_right x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_right x) = filterlim g ?F1' ?F2'\n\ngoal (1 subgoal):\n 1. jump f x = jump g y", "unfolding jump_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?F1.0 = ?F1'; at_left x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_left x) = filterlim g ?F1' ?F2'\n  \\<lbrakk>?F1.0 = ?F1'; at_right x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_right x) = filterlim g ?F1' ?F2'\n\ngoal (1 subgoal):\n 1. (if filterlim f at_bot (at_left x) \\<and>\n        filterlim f at_top (at_right x)\n     then 1\n     else if filterlim f at_top (at_left x) \\<and>\n             filterlim f at_bot (at_right x)\n          then - 1 else 0) =\n    (if filterlim g at_bot (at_left y) \\<and>\n        filterlim g at_top (at_right y)\n     then 1\n     else if filterlim g at_top (at_left y) \\<and>\n             filterlim g at_bot (at_right y)\n          then - 1 else 0)", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?F1.0 = ?F1'; at_left x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_left x) = filterlim g ?F1' ?F2'\n  \\<lbrakk>?F1.0 = ?F1'; at_right x = ?F2'\\<rbrakk>\n  \\<Longrightarrow> filterlim f ?F1.0 (at_right x) = filterlim g ?F1' ?F2'\n  x = y\n\ngoal (1 subgoal):\n 1. (if filterlim f at_bot (at_left x) \\<and>\n        filterlim f at_top (at_right x)\n     then 1\n     else if filterlim f at_top (at_left x) \\<and>\n             filterlim f at_bot (at_right x)\n          then - 1 else 0) =\n    (if filterlim g at_bot (at_left y) \\<and>\n        filterlim g at_top (at_right y)\n     then 1\n     else if filterlim g at_top (at_left y) \\<and>\n             filterlim g at_bot (at_right y)\n          then - 1 else 0)", "by fastforce"], ["proof (state)\nthis:\n  jump f x = jump g y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_cong:\n  assumes \"F=G\" and \"eventually (\\<lambda>x. f x=g x) F\"\n  shows \"jumpF f F = jumpF g G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f F = jumpF g G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f F = jumpF g G", "have \"\\<forall>\\<^sub>F r in G. f r = g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in G. f r = g r", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  F = G\n  \\<forall>\\<^sub>F x in F. f x = g x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in G. f r = g r", "by force"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in G. f r = g r\n\ngoal (1 subgoal):\n 1. jumpF f F = jumpF g G", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in G. f r = g r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in G. f r = g r\n\ngoal (1 subgoal):\n 1. jumpF f F = jumpF g G", "by (simp add: assms(1) filterlim_cong jumpF_def)"], ["proof (state)\nthis:\n  jumpF f F = jumpF g G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_at_left_at_right_eq:\n  assumes \"isCont f x\" and \"f x \\<noteq> 0\" and sgnx_eq:\"sgnx g (at_left x) = sgnx g (at_right x)\"\n  shows \"jump (\\<lambda>t. f t/g t) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "define c where \"c = sgn (f x)\""], ["proof (state)\nthis:\n  c = sgn (f x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "then"], ["proof (chain)\npicking this:\n  c = sgn (f x)", "have \"c\\<noteq>0\""], ["proof (prove)\nusing this:\n  c = sgn (f x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using \\<open>f x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c = sgn (f x)\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by (simp add: sgn_zero_iff)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "have f_tendsto:\"(f \\<longlongrightarrow> f x) (at_left x)\" \" (f \\<longlongrightarrow> f x) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (at_left x) &&&\n    (f \\<longlongrightarrow> f x) (at_right x)", "using \\<open>isCont f x\\<close> Lim_at_imp_Lim_at_within isCont_def"], ["proof (prove)\nusing this:\n  isCont f x\n  ?f \\<midarrow>?x\\<rightarrow> ?l \\<Longrightarrow>\n  (?f \\<longlongrightarrow> ?l) (at ?x within ?S)\n  isCont ?f ?a = ?f \\<midarrow>?a\\<rightarrow> ?f ?a\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (at_left x) &&&\n    (f \\<longlongrightarrow> f x) (at_right x)", "by blast+"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f x) (at_left x)\n  (f \\<longlongrightarrow> f x) (at_right x)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "have False when \"(g has_sgnx - c) (at_left x)\" \"(g has_sgnx c) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"sgnx g (at_left x) = -c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx g (at_left x) = - c", "using that(1)"], ["proof (prove)\nusing this:\n  (g has_sgnx - c) (at_left x)\n\ngoal (1 subgoal):\n 1. sgnx g (at_left x) = - c", "by auto"], ["proof (state)\nthis:\n  sgnx g (at_left x) = - c\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  sgnx g (at_left x) = - c\n\ngoal (1 subgoal):\n 1. False", "have \"sgnx g (at_right x) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx g (at_right x) = c", "using that(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx c) (at_right x)\n\ngoal (1 subgoal):\n 1. sgnx g (at_right x) = c", "by auto"], ["proof (state)\nthis:\n  sgnx g (at_right x) = c\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  sgnx g (at_left x) = - c\n  sgnx g (at_right x) = c", "show False"], ["proof (prove)\nusing this:\n  sgnx g (at_left x) = - c\n  sgnx g (at_right x) = c\n\ngoal (1 subgoal):\n 1. False", "using sgnx_eq \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sgnx g (at_left x) = - c\n  sgnx g (at_right x) = c\n  sgnx g (at_left x) = sgnx g (at_right x)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(g has_sgnx - c) (at_left x);\n   (g has_sgnx c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(g has_sgnx - c) (at_left x);\n   (g has_sgnx c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "have False when \"(g has_sgnx c) (at_left x)\" \"(g has_sgnx - c) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"sgnx g (at_left x) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx g (at_left x) = c", "using that(1)"], ["proof (prove)\nusing this:\n  (g has_sgnx c) (at_left x)\n\ngoal (1 subgoal):\n 1. sgnx g (at_left x) = c", "by auto"], ["proof (state)\nthis:\n  sgnx g (at_left x) = c\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  sgnx g (at_left x) = c\n\ngoal (1 subgoal):\n 1. False", "have \"sgnx g (at_right x) = - c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx g (at_right x) = - c", "using that(2)"], ["proof (prove)\nusing this:\n  (g has_sgnx - c) (at_right x)\n\ngoal (1 subgoal):\n 1. sgnx g (at_right x) = - c", "by auto"], ["proof (state)\nthis:\n  sgnx g (at_right x) = - c\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  sgnx g (at_left x) = c\n  sgnx g (at_right x) = - c", "show False"], ["proof (prove)\nusing this:\n  sgnx g (at_left x) = c\n  sgnx g (at_right x) = - c\n\ngoal (1 subgoal):\n 1. False", "using sgnx_eq \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sgnx g (at_left x) = c\n  sgnx g (at_right x) = - c\n  sgnx g (at_left x) = sgnx g (at_right x)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(g has_sgnx c) (at_left x);\n   (g has_sgnx - c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(g has_sgnx - c) (at_left x);\n   (g has_sgnx c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>(g has_sgnx c) (at_left x);\n   (g has_sgnx - c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(g has_sgnx - c) (at_left x);\n   (g has_sgnx c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>(g has_sgnx c) (at_left x);\n   (g has_sgnx - c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. f t / g t) x = 0", "unfolding jump_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(g has_sgnx - c) (at_left x);\n   (g has_sgnx c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>(g has_sgnx c) (at_left x);\n   (g has_sgnx - c) (at_right x)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if (LIM t at_left x. f t / g t :> at_bot) \\<and>\n        (LIM t at_right x. f t / g t :> at_top)\n     then 1\n     else if (LIM t at_left x. f t / g t :> at_top) \\<and>\n             (LIM t at_right x. f t / g t :> at_bot)\n          then - 1 else 0) =\n    0", "by (auto simp add:f_tendsto filterlim_divide_at_bot_at_top_iff[OF _ \\<open>f x \\<noteq> 0\\<close>] c_def)"], ["proof (state)\nthis:\n  jump (\\<lambda>t. f t / g t) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_pos_has_sgnx:\n  assumes \"jumpF f F > 0\"\n  shows \"(f has_sgnx 1) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) F", "have \"filterlim f at_top F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_top F", "using assms"], ["proof (prove)\nusing this:\n  0 < jumpF f F\n\ngoal (1 subgoal):\n 1. filterlim f at_top F", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  0 < (if filterlim f at_top F then 1 / 2\n       else if filterlim f at_bot F then - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. filterlim f at_top F", "by argo"], ["proof (state)\nthis:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) F", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top F", "have \"eventually (\\<lambda>x. f x>0) F\""], ["proof (prove)\nusing this:\n  filterlim f at_top F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x", "using filterlim_at_top_dense[of f F]"], ["proof (prove)\nusing this:\n  filterlim f at_top F\n  filterlim f at_top F = (\\<forall>Z. \\<forall>\\<^sub>F x in F. Z < f x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. 0 < f x", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. 0 < f x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. 0 < f x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = 1", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < f x \\<Longrightarrow> sgn (f x) = 1", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx 1) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_neg_has_sgnx:\n  assumes \"jumpF f F < 0\"\n  shows \"(f has_sgnx -1) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) F", "have \"filterlim f at_bot F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_bot F", "using assms"], ["proof (prove)\nusing this:\n  jumpF f F < 0\n\ngoal (1 subgoal):\n 1. filterlim f at_bot F", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  (if filterlim f at_top F then 1 / 2\n   else if filterlim f at_bot F then - 1 / 2 else 0)\n  < 0\n\ngoal (1 subgoal):\n 1. filterlim f at_bot F", "by argo"], ["proof (state)\nthis:\n  filterlim f at_bot F\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) F", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot F", "have \"eventually (\\<lambda>x. f x<0) F\""], ["proof (prove)\nusing this:\n  filterlim f at_bot F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x < 0", "using filterlim_at_bot_dense[of f F]"], ["proof (prove)\nusing this:\n  filterlim f at_bot F\n  filterlim f at_bot F = (\\<forall>Z. \\<forall>\\<^sub>F x in F. f x < Z)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. f x < 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in F. f x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) F", "unfolding has_sgnx_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. sgn (f x) = - 1", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. f x < 0 \\<Longrightarrow> sgn (f x) = - 1", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx - 1) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_IVT:\n  fixes f::\"real \\<Rightarrow> real\" and a b::real\n  defines \"right\\<equiv>(\\<lambda>(R::real \\<Rightarrow> real \\<Rightarrow> bool). R (jumpF f (at_right a)) 0 \n                      \\<or> (continuous (at_right a) f \\<and> R (f a) 0))\"\n    and\n          \"left\\<equiv>(\\<lambda>(R::real \\<Rightarrow> real \\<Rightarrow> bool). R (jumpF f (at_left b)) 0 \n                      \\<or> (continuous (at_left b) f \\<and> R (f b) 0))\"\n  assumes \"a<b\" and cont:\"continuous_on {a<..<b} f\" and\n    right_left:\"right greater \\<and> left less \\<or> right less \\<and> left greater\" \n  shows \"\\<exists>x. a<x \\<and> x<b \\<and> f x =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have ?thesis when \"right greater\" \"left less\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"(f has_sgnx 1) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "have ?thesis when \"jumpF f (at_right a)>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "using jumpF_pos_has_sgnx[OF that]"], ["proof (prove)\nusing this:\n  (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "."], ["proof (state)\nthis:\n  0 < jumpF f (at_right a) \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "moreover"], ["proof (state)\nthis:\n  0 < jumpF f (at_right a) \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "have ?thesis when \"f a > 0\" \"continuous (at_right a) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "have \"(f \\<longlongrightarrow> f a) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a)", "using that(2)"], ["proof (prove)\nusing this:\n  continuous (at_right a) f\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f a) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> f a) (at_right a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "using tendsto_nonzero_has_sgnx[of f \"f a\" \"at_right a\"] that"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  \\<lbrakk>(f \\<longlongrightarrow> f a) (at_right a);\n   f a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx sgn (f a)) (at_right a)\n  0 < f a\n  continuous (at_right a) f\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx 1) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < f a; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  0 < jumpF f (at_right a) \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n  \\<lbrakk>0 < f a; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_right a)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < jumpF f (at_right a) \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n  \\<lbrakk>0 < f a; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "using that(1)"], ["proof (prove)\nusing this:\n  0 < jumpF f (at_right a) \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n  \\<lbrakk>0 < f a; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n  right (\\<lambda>x y. y < x)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "unfolding right_def"], ["proof (prove)\nusing this:\n  0 < jumpF f (at_right a) \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n  \\<lbrakk>0 < f a; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_right a)\n  0 < jumpF f (at_right a) \\<or> continuous (at_right a) f \\<and> 0 < f a\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx 1) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx 1) (at_right a)", "obtain a' where \"a<a'\" and a'_def:\"\\<forall>y. a<y \\<and> y < a' \\<longrightarrow> f y > 0\""], ["proof (prove)\nusing this:\n  (f has_sgnx 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> 0 < f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (f y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> 0 < f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sgn_1_pos"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (f y) = 1\n  (sgn ?a = (1::?'a)) = ((0::?'a) < ?a)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> 0 < f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a'\n  \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> 0 < f y\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"(f has_sgnx - 1) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "have ?thesis when \"jumpF f (at_left b)<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "using jumpF_neg_has_sgnx[OF that]"], ["proof (prove)\nusing this:\n  (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "."], ["proof (state)\nthis:\n  jumpF f (at_left b) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "moreover"], ["proof (state)\nthis:\n  jumpF f (at_left b) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "have ?thesis when \"f b < 0\" \"continuous (at_left b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "have \"(f \\<longlongrightarrow> f b) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f b) (at_left b)", "using that(2)"], ["proof (prove)\nusing this:\n  continuous (at_left b) f\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f b) (at_left b)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f b) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> f b) (at_left b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f b) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "using tendsto_nonzero_has_sgnx[of f \"f b\" \"at_left b\"] that"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f b) (at_left b)\n  \\<lbrakk>(f \\<longlongrightarrow> f b) (at_left b);\n   f b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx sgn (f b)) (at_left b)\n  f b < 0\n  continuous (at_left b) f\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx - 1) (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>f b < 0; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "ultimately"], ["proof (chain)\npicking this:\n  jumpF f (at_left b) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n  \\<lbrakk>f b < 0; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_left b)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_left b) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n  \\<lbrakk>f b < 0; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "using that(2)"], ["proof (prove)\nusing this:\n  jumpF f (at_left b) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n  \\<lbrakk>f b < 0; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n  left (<)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "unfolding left_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left b) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n  \\<lbrakk>f b < 0; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_left b)\n  jumpF f (at_left b) < 0 \\<or> continuous (at_left b) f \\<and> f b < 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_left b)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx - 1) (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx - 1) (at_left b)", "obtain b' where \"b'<b\" and b'_def:\"\\<forall>y. b'<y \\<and> y < b \\<longrightarrow> f y < 0\""], ["proof (prove)\nusing this:\n  (f has_sgnx - 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> f y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\nusing this:\n  \\<exists>ba<b. \\<forall>y>ba. y < b \\<longrightarrow> sgn (f y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> f y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sgn_1_neg"], ["proof (prove)\nusing this:\n  \\<exists>ba<b. \\<forall>y>ba. y < b \\<longrightarrow> sgn (f y) = - 1\n  (sgn ?a = - (1::?'a)) = (?a < (0::?'a))\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> f y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b' < b\n  \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> f y < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"a' \\<le> b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<le> b'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "assume \"\\<not> a' \\<le> b'\""], ["proof (state)\nthis:\n  \\<not> a' \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> a' \\<le> b'", "have \"{a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> a' \\<le> b'\n\ngoal (1 subgoal):\n 1. {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}", "using \\<open>a<a'\\<close> \\<open>b'<b\\<close> \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  \\<not> a' \\<le> b'\n  a < a'\n  b' < b\n  a < b\n\ngoal (1 subgoal):\n 1. {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}", "obtain c where \"c\\<in>{a<..<a'}\" \"c\\<in>{b'<..<b}\""], ["proof (prove)\nusing this:\n  {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> {a<..<a'}; c \\<in> {b'<..<b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}", "have \"f c>0\" \"f c<0\""], ["proof (prove)\nusing this:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}\n\ngoal (1 subgoal):\n 1. 0 < f c &&& f c < 0", "using a'_def b'_def"], ["proof (prove)\nusing this:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}\n  \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> 0 < f y\n  \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> f y < 0\n\ngoal (1 subgoal):\n 1. 0 < f c &&& f c < 0", "by auto"], ["proof (state)\nthis:\n  0 < f c\n  f c < 0\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < f c\n  f c < 0", "show False"], ["proof (prove)\nusing this:\n  0 < f c\n  f c < 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a' \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "define a0 where \"a0=(a+a')/2\""], ["proof (state)\nthis:\n  a0 = (a + a') / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "define b0 where \"b0=(b+b')/2\""], ["proof (state)\nthis:\n  b0 = (b + b') / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have [simp]:\"a<a0\" \"a0<a'\" \"a0<b0\" \"b'<b0\" \"b0<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < a0 &&& a0 < a') &&& a0 < b0 &&& b' < b0 &&& b0 < b", "unfolding a0_def b0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < (a + a') / 2 &&& (a + a') / 2 < a') &&&\n    (a + a') / 2 < (b + b') / 2 &&& b' < (b + b') / 2 &&& (b + b') / 2 < b", "using \\<open>a<a'\\<close> \\<open>b'<b\\<close> \\<open>a'\\<le>b'\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n  b' < b\n  a' \\<le> b'\n\ngoal (1 subgoal):\n 1. (a < (a + a') / 2 &&& (a + a') / 2 < a') &&&\n    (a + a') / 2 < (b + b') / 2 &&& b' < (b + b') / 2 &&& (b + b') / 2 < b", "by auto"], ["proof (state)\nthis:\n  a < a0\n  a0 < a'\n  a0 < b0\n  b' < b0\n  b0 < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"f a0>0\" \"f b0<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f a0 &&& f b0 < 0", "using a'_def[rule_format,of a0] b'_def[rule_format,of b0]"], ["proof (prove)\nusing this:\n  a < a0 \\<and> a0 < a' \\<Longrightarrow> 0 < f a0\n  b' < b0 \\<and> b0 < b \\<Longrightarrow> f b0 < 0\n\ngoal (1 subgoal):\n 1. 0 < f a0 &&& f b0 < 0", "by auto"], ["proof (state)\nthis:\n  0 < f a0\n  f b0 < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "moreover"], ["proof (state)\nthis:\n  0 < f a0\n  f b0 < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"continuous_on {a0..b0} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a0..b0} f", "using cont \\<open>a < a0\\<close> \\<open>b0 < b\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {a<..<b} f\n  a < a0\n  b0 < b\n\ngoal (1 subgoal):\n 1. continuous_on {a0..b0} f", "by (meson atLeastAtMost_subseteq_greaterThanLessThan_iff continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on {a0..b0} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "ultimately"], ["proof (chain)\npicking this:\n  0 < f a0\n  f b0 < 0\n  continuous_on {a0..b0} f", "have \"\\<exists>x>a0. x < b0 \\<and> f x = 0\""], ["proof (prove)\nusing this:\n  0 < f a0\n  f b0 < 0\n  continuous_on {a0..b0} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>a0. x < b0 \\<and> f x = 0", "using IVT_strict[of 0 f a0 b0]"], ["proof (prove)\nusing this:\n  0 < f a0\n  f b0 < 0\n  continuous_on {a0..b0} f\n  \\<lbrakk>0 < f a0 \\<and> f b0 < 0 \\<or> f a0 < 0 \\<and> 0 < f b0; a0 < b0;\n   continuous_on {a0..b0} f\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a0. x < b0 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a0. x < b0 \\<and> f x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "using \\<open>a < a0\\<close> \\<open>b0 < b\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0\n  a < a0\n  b0 < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "by (meson lessThan_strict_subset_iff psubsetE subset_psubset_trans)"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>right (\\<lambda>x y. y < x); left (<)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>right (\\<lambda>x y. y < x); left (<)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have ?thesis when \"right less\" \"left greater\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"(f has_sgnx -1) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "have ?thesis when \"jumpF f (at_right a)<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "using jumpF_neg_has_sgnx[OF that]"], ["proof (prove)\nusing this:\n  (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "."], ["proof (state)\nthis:\n  jumpF f (at_right a) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "moreover"], ["proof (state)\nthis:\n  jumpF f (at_right a) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "have ?thesis when \"f a < 0\" \"continuous (at_right a) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "have \"(f \\<longlongrightarrow> f a) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a)", "using that(2)"], ["proof (prove)\nusing this:\n  continuous (at_right a) f\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f a) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> f a) (at_right a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "using tendsto_nonzero_has_sgnx[of f \"f a\" \"at_right a\"] that"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  \\<lbrakk>(f \\<longlongrightarrow> f a) (at_right a);\n   f a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx sgn (f a)) (at_right a)\n  f a < 0\n  continuous (at_right a) f\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx - 1) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>f a < 0; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "ultimately"], ["proof (chain)\npicking this:\n  jumpF f (at_right a) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n  \\<lbrakk>f a < 0; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_right a)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n  \\<lbrakk>f a < 0; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "using that(1)"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n  \\<lbrakk>f a < 0; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n  right (<)\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "unfolding right_def"], ["proof (prove)\nusing this:\n  jumpF f (at_right a) < 0 \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n  \\<lbrakk>f a < 0; continuous (at_right a) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx - 1) (at_right a)\n  jumpF f (at_right a) < 0 \\<or> continuous (at_right a) f \\<and> f a < 0\n\ngoal (1 subgoal):\n 1. (f has_sgnx - 1) (at_right a)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx - 1) (at_right a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx - 1) (at_right a)", "obtain a' where \"a<a'\" and a'_def:\"\\<forall>y. a<y \\<and> y < a' \\<longrightarrow> f y < 0\""], ["proof (prove)\nusing this:\n  (f has_sgnx - 1) (at_right a)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> f y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (f y) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> f y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sgn_1_neg"], ["proof (prove)\nusing this:\n  \\<exists>b>a. \\<forall>y>a. y < b \\<longrightarrow> sgn (f y) = - 1\n  (sgn ?a = - (1::?'a)) = (?a < (0::?'a))\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a < a';\n         \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> f y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a'\n  \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> f y < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"(f has_sgnx  1) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "have ?thesis when \"jumpF f (at_left b)>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "using jumpF_pos_has_sgnx[OF that]"], ["proof (prove)\nusing this:\n  (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "."], ["proof (state)\nthis:\n  0 < jumpF f (at_left b) \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "moreover"], ["proof (state)\nthis:\n  0 < jumpF f (at_left b) \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "have ?thesis when \"f b > 0\" \"continuous (at_left b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "have \"(f \\<longlongrightarrow> f b) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f b) (at_left b)", "using that(2)"], ["proof (prove)\nusing this:\n  continuous (at_left b) f\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f b) (at_left b)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f b) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> f b) (at_left b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f b) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "using tendsto_nonzero_has_sgnx[of f \"f b\" \"at_left b\"] that"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> f b) (at_left b)\n  \\<lbrakk>(f \\<longlongrightarrow> f b) (at_left b);\n   f b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx sgn (f b)) (at_left b)\n  0 < f b\n  continuous (at_left b) f\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx 1) (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < f b; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "ultimately"], ["proof (chain)\npicking this:\n  0 < jumpF f (at_left b) \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n  \\<lbrakk>0 < f b; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_left b)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < jumpF f (at_left b) \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n  \\<lbrakk>0 < f b; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "using that(2)"], ["proof (prove)\nusing this:\n  0 < jumpF f (at_left b) \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n  \\<lbrakk>0 < f b; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n  left (\\<lambda>x y. y < x)\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "unfolding left_def"], ["proof (prove)\nusing this:\n  0 < jumpF f (at_left b) \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n  \\<lbrakk>0 < f b; continuous (at_left b) f\\<rbrakk>\n  \\<Longrightarrow> (f has_sgnx 1) (at_left b)\n  0 < jumpF f (at_left b) \\<or> continuous (at_left b) f \\<and> 0 < f b\n\ngoal (1 subgoal):\n 1. (f has_sgnx 1) (at_left b)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx 1) (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx 1) (at_left b)", "obtain b' where \"b'<b\" and b'_def:\"\\<forall>y. b'<y \\<and> y < b \\<longrightarrow> f y > 0\""], ["proof (prove)\nusing this:\n  (f has_sgnx 1) (at_left b)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> 0 < f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\nusing this:\n  \\<exists>ba<b. \\<forall>y>ba. y < b \\<longrightarrow> sgn (f y) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> 0 < f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sgn_1_pos"], ["proof (prove)\nusing this:\n  \\<exists>ba<b. \\<forall>y>ba. y < b \\<longrightarrow> sgn (f y) = 1\n  (sgn ?a = (1::?'a)) = ((0::?'a) < ?a)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' < b;\n         \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> 0 < f y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b' < b\n  \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> 0 < f y\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"a' \\<le> b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<le> b'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "assume \"\\<not> a' \\<le> b'\""], ["proof (state)\nthis:\n  \\<not> a' \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> a' \\<le> b'", "have \"{a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> a' \\<le> b'\n\ngoal (1 subgoal):\n 1. {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}", "using \\<open>a<a'\\<close> \\<open>b'<b\\<close> \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  \\<not> a' \\<le> b'\n  a < a'\n  b' < b\n  a < b\n\ngoal (1 subgoal):\n 1. {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}", "obtain c where \"c\\<in>{a<..<a'}\" \"c\\<in>{b'<..<b}\""], ["proof (prove)\nusing this:\n  {a<..<a'} \\<inter> {b'<..<b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> {a<..<a'}; c \\<in> {b'<..<b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}", "have \"f c>0\" \"f c<0\""], ["proof (prove)\nusing this:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}\n\ngoal (1 subgoal):\n 1. 0 < f c &&& f c < 0", "using a'_def b'_def"], ["proof (prove)\nusing this:\n  c \\<in> {a<..<a'}\n  c \\<in> {b'<..<b}\n  \\<forall>y. a < y \\<and> y < a' \\<longrightarrow> f y < 0\n  \\<forall>y. b' < y \\<and> y < b \\<longrightarrow> 0 < f y\n\ngoal (1 subgoal):\n 1. 0 < f c &&& f c < 0", "by auto"], ["proof (state)\nthis:\n  0 < f c\n  f c < 0\n\ngoal (1 subgoal):\n 1. \\<not> a' \\<le> b' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < f c\n  f c < 0", "show False"], ["proof (prove)\nusing this:\n  0 < f c\n  f c < 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a' \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "define a0 where \"a0=(a+a')/2\""], ["proof (state)\nthis:\n  a0 = (a + a') / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "define b0 where \"b0=(b+b')/2\""], ["proof (state)\nthis:\n  b0 = (b + b') / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have [simp]:\"a<a0\" \"a0<a'\" \"a0<b0\" \"b'<b0\" \"b0<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < a0 &&& a0 < a') &&& a0 < b0 &&& b' < b0 &&& b0 < b", "unfolding a0_def b0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < (a + a') / 2 &&& (a + a') / 2 < a') &&&\n    (a + a') / 2 < (b + b') / 2 &&& b' < (b + b') / 2 &&& (b + b') / 2 < b", "using \\<open>a<a'\\<close> \\<open>b'<b\\<close> \\<open>a'\\<le>b'\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n  b' < b\n  a' \\<le> b'\n\ngoal (1 subgoal):\n 1. (a < (a + a') / 2 &&& (a + a') / 2 < a') &&&\n    (a + a') / 2 < (b + b') / 2 &&& b' < (b + b') / 2 &&& (b + b') / 2 < b", "by auto"], ["proof (state)\nthis:\n  a < a0\n  a0 < a'\n  a0 < b0\n  b' < b0\n  b0 < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"f a0<0\" \"f b0>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a0 < 0 &&& 0 < f b0", "using a'_def[rule_format,of a0] b'_def[rule_format,of b0]"], ["proof (prove)\nusing this:\n  a < a0 \\<and> a0 < a' \\<Longrightarrow> f a0 < 0\n  b' < b0 \\<and> b0 < b \\<Longrightarrow> 0 < f b0\n\ngoal (1 subgoal):\n 1. f a0 < 0 &&& 0 < f b0", "by auto"], ["proof (state)\nthis:\n  f a0 < 0\n  0 < f b0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "moreover"], ["proof (state)\nthis:\n  f a0 < 0\n  0 < f b0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "have \"continuous_on {a0..b0} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a0..b0} f", "using cont  \\<open>a < a0\\<close> \\<open>b0 < b\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {a<..<b} f\n  a < a0\n  b0 < b\n\ngoal (1 subgoal):\n 1. continuous_on {a0..b0} f", "by (meson atLeastAtMost_subseteq_greaterThanLessThan_iff continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on {a0..b0} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "ultimately"], ["proof (chain)\npicking this:\n  f a0 < 0\n  0 < f b0\n  continuous_on {a0..b0} f", "have \"\\<exists>x>a0. x < b0 \\<and> f x = 0\""], ["proof (prove)\nusing this:\n  f a0 < 0\n  0 < f b0\n  continuous_on {a0..b0} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>a0. x < b0 \\<and> f x = 0", "using IVT_strict[of 0 f a0 b0]"], ["proof (prove)\nusing this:\n  f a0 < 0\n  0 < f b0\n  continuous_on {a0..b0} f\n  \\<lbrakk>0 < f a0 \\<and> f b0 < 0 \\<or> f a0 < 0 \\<and> 0 < f b0; a0 < b0;\n   continuous_on {a0..b0} f\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a0. x < b0 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a0. x < b0 \\<and> f x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "using \\<open>a < a0\\<close> \\<open>b0 < b\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>a0. x < b0 \\<and> f x = 0\n  a < a0\n  b0 < b\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "by (meson lessThan_strict_subset_iff psubsetE subset_psubset_trans)"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>right (<); left (\\<lambda>x y. y < x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>right (\\<lambda>x y. y < x); left (<)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n  \\<lbrakk>right (<); left (\\<lambda>x y. y < x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>right (\\<lambda>x y. y < x); left (<)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n  \\<lbrakk>right (<); left (\\<lambda>x y. y < x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "using right_left"], ["proof (prove)\nusing this:\n  \\<lbrakk>right (\\<lambda>x y. y < x); left (<)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n  \\<lbrakk>right (<); left (\\<lambda>x y. y < x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> f x = 0\n  right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n  right (<) \\<and> left (\\<lambda>x y. y < x)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_eventually_const:\n  assumes \"eventually (\\<lambda>x. f x=c) F\" \"F\\<noteq>bot\"\n  shows \"jumpF f F = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f F = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f F = 0", "have \"jumpF f F = jumpF (\\<lambda>_. c) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f F = jumpF (\\<lambda>_. c) F", "apply (rule jumpF_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. F = F\n 2. \\<forall>\\<^sub>F x in F. f x = c", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. f x = c\n\ngoal (2 subgoals):\n 1. F = F\n 2. \\<forall>\\<^sub>F x in F. f x = c", "by auto"], ["proof (state)\nthis:\n  jumpF f F = jumpF (\\<lambda>_. c) F\n\ngoal (1 subgoal):\n 1. jumpF f F = 0", "also"], ["proof (state)\nthis:\n  jumpF f F = jumpF (\\<lambda>_. c) F\n\ngoal (1 subgoal):\n 1. jumpF f F = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "using jumpF_const[OF \\<open>F\\<noteq>bot\\<close>]"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>_. ?c) F = 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>_. c) F = 0", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>_. c) F = 0\n\ngoal (1 subgoal):\n 1. jumpF f F = 0", "finally"], ["proof (chain)\npicking this:\n  jumpF f F = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f F = 0\n\ngoal (1 subgoal):\n 1. jumpF f F = 0", "."], ["proof (state)\nthis:\n  jumpF f F = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_tan_comp:\n  \"jumpF (f o tan) (at_right x) = (if cos x = 0 \n      then jumpF f at_bot else jumpF f (at_right (tan x)))\"\n  \"jumpF (f o tan) (at_left x) = (if cos x =0 \n      then jumpF f at_top else jumpF f (at_left (tan x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> tan) (at_right x) =\n    (if cos x = 0 then jumpF f at_bot else jumpF f (at_right (tan x))) &&&\n    jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> tan) (at_right x) =\n    (if cos x = 0 then jumpF f at_bot else jumpF f (at_right (tan x)))\n 2. jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "have \"filtermap (f \\<circ> tan) (at_right x) = \n      (if cos x = 0 then filtermap f at_bot else filtermap f (at_right (tan x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (f \\<circ> tan) (at_right x) =\n    (if cos x = 0 then filtermap f at_bot\n     else filtermap f (at_right (tan x)))", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. f (tan x)) (at_right x) =\n    (if cos x = 0 then filtermap f at_bot\n     else filtermap f (at_right (tan x)))", "apply (subst filtermap_filtermap[of f tan,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap f (filtermap tan (at_right x)) =\n    (if cos x = 0 then filtermap f at_bot\n     else filtermap f (at_right (tan x)))", "using filtermap_tan_at_right_inf filtermap_tan_at_right"], ["proof (prove)\nusing this:\n  cos ?a = 0 \\<Longrightarrow> filtermap tan (at_right ?a) = at_bot\n  cos ?a \\<noteq> 0 \\<Longrightarrow>\n  filtermap tan (at_right ?a) = at_right (tan ?a)\n\ngoal (1 subgoal):\n 1. filtermap f (filtermap tan (at_right x)) =\n    (if cos x = 0 then filtermap f at_bot\n     else filtermap f (at_right (tan x)))", "by auto"], ["proof (state)\nthis:\n  filtermap (f \\<circ> tan) (at_right x) =\n  (if cos x = 0 then filtermap f at_bot else filtermap f (at_right (tan x)))\n\ngoal (2 subgoals):\n 1. jumpF (f \\<circ> tan) (at_right x) =\n    (if cos x = 0 then jumpF f at_bot else jumpF f (at_right (tan x)))\n 2. jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "then"], ["proof (chain)\npicking this:\n  filtermap (f \\<circ> tan) (at_right x) =\n  (if cos x = 0 then filtermap f at_bot else filtermap f (at_right (tan x)))", "show \"jumpF (f o tan) (at_right x) = (if cos x = 0 \n          then jumpF f at_bot else jumpF f (at_right (tan x)))\""], ["proof (prove)\nusing this:\n  filtermap (f \\<circ> tan) (at_right x) =\n  (if cos x = 0 then filtermap f at_bot else filtermap f (at_right (tan x)))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> tan) (at_right x) =\n    (if cos x = 0 then jumpF f at_bot else jumpF f (at_right (tan x)))", "unfolding jumpF_def filterlim_def"], ["proof (prove)\nusing this:\n  filtermap (f \\<circ> tan) (at_right x) =\n  (if cos x = 0 then filtermap f at_bot else filtermap f (at_right (tan x)))\n\ngoal (1 subgoal):\n 1. (if filtermap (f \\<circ> tan) (at_right x) \\<le> at_top then 1 / 2\n     else if filtermap (f \\<circ> tan) (at_right x) \\<le> at_bot\n          then - 1 / 2 else 0) =\n    (if cos x = 0\n     then if filtermap f at_bot \\<le> at_top then 1 / 2\n          else if filtermap f at_bot \\<le> at_bot then - 1 / 2 else 0\n     else if filtermap f (at_right (tan x)) \\<le> at_top then 1 / 2\n          else if filtermap f (at_right (tan x)) \\<le> at_bot then - 1 / 2\n               else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (f \\<circ> tan) (at_right x) =\n  (if cos x = 0 then jumpF f at_bot else jumpF f (at_right (tan x)))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "have \"filtermap (f \\<circ> tan) (at_left x) = \n      (if cos x = 0 then filtermap f at_top else filtermap f (at_left (tan x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then filtermap f at_top\n     else filtermap f (at_left (tan x)))", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>x. f (tan x)) (at_left x) =\n    (if cos x = 0 then filtermap f at_top\n     else filtermap f (at_left (tan x)))", "apply (subst filtermap_filtermap[of f tan,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap f (filtermap tan (at_left x)) =\n    (if cos x = 0 then filtermap f at_top\n     else filtermap f (at_left (tan x)))", "using filtermap_tan_at_left_inf filtermap_tan_at_left"], ["proof (prove)\nusing this:\n  cos ?a = 0 \\<Longrightarrow> filtermap tan (at_left ?a) = at_top\n  cos ?a \\<noteq> 0 \\<Longrightarrow>\n  filtermap tan (at_left ?a) = at_left (tan ?a)\n\ngoal (1 subgoal):\n 1. filtermap f (filtermap tan (at_left x)) =\n    (if cos x = 0 then filtermap f at_top\n     else filtermap f (at_left (tan x)))", "by auto"], ["proof (state)\nthis:\n  filtermap (f \\<circ> tan) (at_left x) =\n  (if cos x = 0 then filtermap f at_top else filtermap f (at_left (tan x)))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "then"], ["proof (chain)\npicking this:\n  filtermap (f \\<circ> tan) (at_left x) =\n  (if cos x = 0 then filtermap f at_top else filtermap f (at_left (tan x)))", "show \"jumpF (f o tan) (at_left x) = (if cos x = 0 \n          then jumpF f at_top else jumpF f (at_left (tan x)))\""], ["proof (prove)\nusing this:\n  filtermap (f \\<circ> tan) (at_left x) =\n  (if cos x = 0 then filtermap f at_top else filtermap f (at_left (tan x)))\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> tan) (at_left x) =\n    (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))", "unfolding jumpF_def filterlim_def"], ["proof (prove)\nusing this:\n  filtermap (f \\<circ> tan) (at_left x) =\n  (if cos x = 0 then filtermap f at_top else filtermap f (at_left (tan x)))\n\ngoal (1 subgoal):\n 1. (if filtermap (f \\<circ> tan) (at_left x) \\<le> at_top then 1 / 2\n     else if filtermap (f \\<circ> tan) (at_left x) \\<le> at_bot then - 1 / 2\n          else 0) =\n    (if cos x = 0\n     then if filtermap f at_top \\<le> at_top then 1 / 2\n          else if filtermap f at_top \\<le> at_bot then - 1 / 2 else 0\n     else if filtermap f (at_left (tan x)) \\<le> at_top then 1 / 2\n          else if filtermap f (at_left (tan x)) \\<le> at_bot then - 1 / 2\n               else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (f \\<circ> tan) (at_left x) =\n  (if cos x = 0 then jumpF f at_top else jumpF f (at_left (tan x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite jumpFs over an interval\\<close>"], ["", "definition finite_jumpFs::\"(real \\<Rightarrow> real) \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow>  bool\" where\n  \"finite_jumpFs f a b = finite {x. (jumpF f (at_left x) \\<noteq>0 \\<or> jumpF f (at_right x) \\<noteq>0) \\<and> a\\<le>x \\<and> x\\<le>b}\""], ["", "lemma finite_jumpFs_linear_pos:\n  assumes \"c>0\"\n  shows \"finite_jumpFs (f o (\\<lambda>x. c * x + b)) lb ub \\<longleftrightarrow> finite_jumpFs f (c * lb +b) (c * ub + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "define left where \"left = (\\<lambda>f lb ub. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> lb \\<le> x \\<and> x \\<le> ub})\""], ["proof (state)\nthis:\n  left =\n  (\\<lambda>f lb ub.\n      {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n          lb \\<le> x \\<and> x \\<le> ub})\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "define right where \"right = (\\<lambda>f lb ub. {x. jumpF f (at_right x) \\<noteq> 0 \\<and> lb \\<le> x \\<and> x \\<le> ub})\""], ["proof (state)\nthis:\n  right =\n  (\\<lambda>f lb ub.\n      {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n          lb \\<le> x \\<and> x \\<le> ub})\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "define g where \"g=(\\<lambda>x. c*x+b)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. c * x + b)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "define gi where \"gi = (\\<lambda>x. (x-b)/c)\""], ["proof (state)\nthis:\n  gi = (\\<lambda>x. (x - b) / c)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "have \"finite_jumpFs (f o (\\<lambda>x. c * x + b)) lb ub \n      = finite (left (f o g) lb ub \\<union> right (f o g) lb ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub)", "unfolding finite_jumpFs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n          0 \\<or>\n          jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n          0) \\<and>\n         lb \\<le> x \\<and> x \\<le> ub} =\n    finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub)", "apply (rule arg_cong[where f=finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n         0 \\<or>\n         jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n         0) \\<and>\n        lb \\<le> x \\<and> x \\<le> ub} =\n    left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub", "by (auto simp add:left_def right_def g_def)"], ["proof (state)\nthis:\n  finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n  finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "also"], ["proof (state)\nthis:\n  finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n  finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "have \"... = finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n    finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n    finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))", "have j_rw:\n      \"jumpF (f o g) (at_left x) = jumpF f (at_left (g x))\" \n      \"jumpF (f o g) (at_right x) = jumpF f (at_right (g x))\"\n        for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> g) (at_left x) = jumpF f (at_left (g x)) &&&\n    jumpF (f \\<circ> g) (at_right x) = jumpF f (at_right (g x))", "using jumpF_linear_comp[of c f b x] \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  c \\<noteq> 0 \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n  0 < c\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> g) (at_left x) = jumpF f (at_left (g x)) &&&\n    jumpF (f \\<circ> g) (at_right x) = jumpF f (at_right (g x))", "unfolding g_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n  (if 0 < c then jumpF f (at_left (c * x + b))\n   else jumpF f (at_right (c * x + b)))\n  c \\<noteq> 0 \\<Longrightarrow>\n  jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n  (if 0 < c then jumpF f (at_right (c * x + b))\n   else jumpF f (at_left (c * x + b)))\n  0 < c\n\ngoal (1 subgoal):\n 1. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) =\n    jumpF f (at_left (c * x + b)) &&&\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) =\n    jumpF f (at_right (c * x + b))", "by auto"], ["proof (state)\nthis:\n  jumpF (f \\<circ> g) (at_left ?x) = jumpF f (at_left (g ?x))\n  jumpF (f \\<circ> g) (at_right ?x) = jumpF f (at_right (g ?x))\n\ngoal (1 subgoal):\n 1. finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n    finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))", "then"], ["proof (chain)\npicking this:\n  jumpF (f \\<circ> g) (at_left ?x) = jumpF f (at_left (g ?x))\n  jumpF (f \\<circ> g) (at_right ?x) = jumpF f (at_right (g ?x))", "have \n        \"left (f o g) lb ub = gi ` left f (g lb) (g ub)\"\n        \"right (f o g) lb ub = gi ` right f (g lb) (g ub)\""], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> g) (at_left ?x) = jumpF f (at_left (g ?x))\n  jumpF (f \\<circ> g) (at_right ?x) = jumpF f (at_right (g ?x))\n\ngoal (1 subgoal):\n 1. left (f \\<circ> g) lb ub = gi ` left f (g lb) (g ub) &&&\n    right (f \\<circ> g) lb ub = gi ` right f (g lb) (g ub)", "unfolding left_def right_def gi_def"], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> g) (at_left ?x) = jumpF f (at_left (g ?x))\n  jumpF (f \\<circ> g) (at_right ?x) = jumpF f (at_right (g ?x))\n\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> g) (at_left x) \\<noteq> 0 \\<and>\n        lb \\<le> x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        g lb \\<le> x \\<and> x \\<le> g ub} &&&\n    {x. jumpF (f \\<circ> g) (at_right x) \\<noteq> 0 \\<and>\n        lb \\<le> x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        g lb \\<le> x \\<and> x \\<le> g ub}", "using \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  jumpF (f \\<circ> g) (at_left ?x) = jumpF f (at_left (g ?x))\n  jumpF (f \\<circ> g) (at_right ?x) = jumpF f (at_right (g ?x))\n  0 < c\n\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> g) (at_left x) \\<noteq> 0 \\<and>\n        lb \\<le> x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        g lb \\<le> x \\<and> x \\<le> g ub} &&&\n    {x. jumpF (f \\<circ> g) (at_right x) \\<noteq> 0 \\<and>\n        lb \\<le> x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        g lb \\<le> x \\<and> x \\<le> g ub}", "by (auto simp add:g_def field_simps)"], ["proof (state)\nthis:\n  left (f \\<circ> g) lb ub = gi ` left f (g lb) (g ub)\n  right (f \\<circ> g) lb ub = gi ` right f (g lb) (g ub)\n\ngoal (1 subgoal):\n 1. finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n    finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))", "then"], ["proof (chain)\npicking this:\n  left (f \\<circ> g) lb ub = gi ` left f (g lb) (g ub)\n  right (f \\<circ> g) lb ub = gi ` right f (g lb) (g ub)", "have \"left (f o g) lb ub \\<union> right (f o g) lb ub \n        = gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))\""], ["proof (prove)\nusing this:\n  left (f \\<circ> g) lb ub = gi ` left f (g lb) (g ub)\n  right (f \\<circ> g) lb ub = gi ` right f (g lb) (g ub)\n\ngoal (1 subgoal):\n 1. left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub =\n    gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))", "by auto"], ["proof (state)\nthis:\n  left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub =\n  gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))\n\ngoal (1 subgoal):\n 1. finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n    finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))", "then"], ["proof (chain)\npicking this:\n  left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub =\n  gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))", "show ?thesis"], ["proof (prove)\nusing this:\n  left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub =\n  gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))\n\ngoal (1 subgoal):\n 1. finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n    finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))", "by auto"], ["proof (state)\nthis:\n  finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n  finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n  finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "also"], ["proof (state)\nthis:\n  finite (left (f \\<circ> g) lb ub \\<union> right (f \\<circ> g) lb ub) =\n  finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)))\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "have \"... = finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))) =\n    finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))", "apply (rule finite_image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on gi (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))", "unfolding gi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))", "using \\<open>c >0\\<close>  inj_on_def"], ["proof (prove)\nusing this:\n  0 < c\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))", "by fastforce"], ["proof (state)\nthis:\n  finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))) =\n  finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "also"], ["proof (state)\nthis:\n  finite (gi ` (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))) =\n  finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub))\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "have \"... =  finite_jumpFs f (c * lb +b) (c * ub + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)) =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "unfolding finite_jumpFs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)) =\n    finite\n     {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n          jumpF f (at_right x) \\<noteq> 0) \\<and>\n         c * lb + b \\<le> x \\<and> x \\<le> c * ub + b}", "apply (rule arg_cong[where f=finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. left f (g lb) (g ub) \\<union> right f (g lb) (g ub) =\n    {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        c * lb + b \\<le> x \\<and> x \\<le> c * ub + b}", "by (auto simp add:left_def right_def g_def)"], ["proof (state)\nthis:\n  finite (left f (g lb) (g ub) \\<union> right f (g lb) (g ub)) =\n  finite_jumpFs f (c * lb + b) (c * ub + b)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "finally"], ["proof (chain)\npicking this:\n  finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n  finite_jumpFs f (c * lb + b) (c * ub + b)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n  finite_jumpFs f (c * lb + b) (c * ub + b)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n    finite_jumpFs f (c * lb + b) (c * ub + b)", "."], ["proof (state)\nthis:\n  finite_jumpFs (f \\<circ> (\\<lambda>x. c * x + b)) lb ub =\n  finite_jumpFs f (c * lb + b) (c * ub + b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_jumpFs_consts:\n  \"finite_jumpFs (\\<lambda>_ . c) lb ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>_. c) lb ub", "unfolding finite_jumpFs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF (\\<lambda>_. c) (at_left x) \\<noteq> 0 \\<or>\n          jumpF (\\<lambda>_. c) (at_right x) \\<noteq> 0) \\<and>\n         lb \\<le> x \\<and> x \\<le> ub}", "using jumpF_const"], ["proof (prove)\nusing this:\n  ?F \\<noteq> bot \\<Longrightarrow> jumpF (\\<lambda>_. ?c) ?F = 0\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF (\\<lambda>_. c) (at_left x) \\<noteq> 0 \\<or>\n          jumpF (\\<lambda>_. c) (at_right x) \\<noteq> 0) \\<and>\n         lb \\<le> x \\<and> x \\<le> ub}", "by auto"], ["", "lemma finite_jumpFs_combine:\n  assumes \"finite_jumpFs f a b\" \"finite_jumpFs f b c\" \n  shows \"finite_jumpFs f a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "define P where \"P=(\\<lambda>x. jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0)\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>x.\n      jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "have \"{x. P x \\<and> a \\<le> x \\<and> x \\<le> c} \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x\\<le>b} \\<union> {x. P x \\<and> b \\<le>x \\<and> x\\<le>c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n    \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n                {x. P x \\<and> b \\<le> x \\<and> x \\<le> c}", "by auto"], ["proof (state)\nthis:\n  {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n  \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n              {x. P x \\<and> b \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "moreover"], ["proof (state)\nthis:\n  {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n  \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n              {x. P x \\<and> b \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "have \"finite ({x. P x \\<and> a \\<le> x \\<and> x\\<le>b} \\<union> {x. P x \\<and> b \\<le>x \\<and> x\\<le>c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n      {x. P x \\<and> b \\<le> x \\<and> x \\<le> c})", "using assms"], ["proof (prove)\nusing this:\n  finite_jumpFs f a b\n  finite_jumpFs f b c\n\ngoal (1 subgoal):\n 1. finite\n     ({x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n      {x. P x \\<and> b \\<le> x \\<and> x \\<le> c})", "unfolding finite_jumpFs_def P_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n        jumpF f (at_right x) \\<noteq> 0) \\<and>\n       a \\<le> x \\<and> x \\<le> b}\n  finite\n   {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n        jumpF f (at_right x) \\<noteq> 0) \\<and>\n       b \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite\n     ({x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n           jumpF f (at_right x) \\<noteq> 0) \\<and>\n          a \\<le> x \\<and> x \\<le> b} \\<union>\n      {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n           jumpF f (at_right x) \\<noteq> 0) \\<and>\n          b \\<le> x \\<and> x \\<le> c})", "by auto"], ["proof (state)\nthis:\n  finite\n   ({x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n    {x. P x \\<and> b \\<le> x \\<and> x \\<le> c})\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "ultimately"], ["proof (chain)\npicking this:\n  {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n  \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n              {x. P x \\<and> b \\<le> x \\<and> x \\<le> c}\n  finite\n   ({x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n    {x. P x \\<and> b \\<le> x \\<and> x \\<le> c})", "have \"finite {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\""], ["proof (prove)\nusing this:\n  {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n  \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n              {x. P x \\<and> b \\<le> x \\<and> x \\<le> c}\n  finite\n   ({x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n    {x. P x \\<and> b \\<le> x \\<and> x \\<le> c})\n\ngoal (1 subgoal):\n 1. finite {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}", "using finite_subset"], ["proof (prove)\nusing this:\n  {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n  \\<subseteq> {x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n              {x. P x \\<and> b \\<le> x \\<and> x \\<le> c}\n  finite\n   ({x. P x \\<and> a \\<le> x \\<and> x \\<le> b} \\<union>\n    {x. P x \\<and> b \\<le> x \\<and> x \\<le> c})\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}", "by auto"], ["proof (state)\nthis:\n  finite {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "then"], ["proof (chain)\npicking this:\n  finite {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. P x \\<and> a \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "unfolding finite_jumpFs_def P_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n        jumpF f (at_right x) \\<noteq> 0) \\<and>\n       a \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n          jumpF f (at_right x) \\<noteq> 0) \\<and>\n         a \\<le> x \\<and> x \\<le> c}", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs f a c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_jumpFs_subE:\n  assumes \"finite_jumpFs f a b\" \"a\\<le>a'\" \"b'\\<le>b\" \n  shows \"finite_jumpFs f a' b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f a' b'", "using assms"], ["proof (prove)\nusing this:\n  finite_jumpFs f a b\n  a \\<le> a'\n  b' \\<le> b\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a' b'", "unfolding finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n        jumpF f (at_right x) \\<noteq> 0) \\<and>\n       a \\<le> x \\<and> x \\<le> b}\n  a \\<le> a'\n  b' \\<le> b\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n          jumpF f (at_right x) \\<noteq> 0) \\<and>\n         a' \\<le> x \\<and> x \\<le> b'}", "apply (elim rev_finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> a'; b' \\<le> b\\<rbrakk>\n    \\<Longrightarrow> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                           jumpF f (at_right x) \\<noteq> 0) \\<and>\n                          a' \\<le> x \\<and> x \\<le> b'}\n                      \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n jumpF f (at_right x) \\<noteq> 0) \\<and>\na \\<le> x \\<and> x \\<le> b}", "by auto"], ["", "lemma finite_Psegments_Re_imp_jumpFs:\n  assumes \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a b\" \"continuous_on {a..b} g\" \n  shows \"finite_jumpFs (\\<lambda>t. Im (g t - z)/Re (g t - z)) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "using assms"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a b\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "proof (induct rule:finite_Psegments.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<le> a; continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 3. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "case (emptyI a b)"], ["proof (state)\nthis:\n  b \\<le> a\n  continuous_on {a..b} g\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<le> a; continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 3. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "then"], ["proof (chain)\npicking this:\n  b \\<le> a\n  continuous_on {a..b} g", "show ?case"], ["proof (prove)\nusing this:\n  b \\<le> a\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "unfolding finite_jumpFs_def"], ["proof (prove)\nusing this:\n  b \\<le> a\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z))\n           (at_left x) \\<noteq>\n          0 \\<or>\n          jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z))\n           (at_right x) \\<noteq>\n          0) \\<and>\n         a \\<le> x \\<and> x \\<le> b}", "by (auto intro:rev_finite_subset[of \"{a}\"])"], ["proof (state)\nthis:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "case (insertI_1 s a b)"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "define f where \"f=(\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (g t - z) / Re (g t - z))\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "have \"finite_jumpFs f a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "have \"continuous_on {a..s} g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..s} g", "using \\<open>continuous_on {a..b} g\\<close> \\<open>s \\<in> {a..<b}\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {a..b} g\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. continuous_on {a..s} g", "by (auto elim:continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on {a..s} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "then"], ["proof (chain)\npicking this:\n  continuous_on {a..s} g", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_on {a..s} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "using insertI_1"], ["proof (prove)\nusing this:\n  continuous_on {a..s} g\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "unfolding f_def"], ["proof (prove)\nusing this:\n  continuous_on {a..s} g\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs f a s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_jumpFs f a s\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "moreover"], ["proof (state)\nthis:\n  finite_jumpFs f a s\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "have \"finite_jumpFs f s b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "have \"jumpF f (at_left x) =0\" \"jumpF f (at_right x) = 0\" when \"x\\<in>{s<..<b}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "show \"jumpF f (at_left x) =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "apply (rule jumpF_eventually_const[of _ 0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left x. f x = 0\n 2. at_left x \\<noteq> bot", "unfolding eventually_at_left"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> f y = 0\n 2. at_left x \\<noteq> bot", "apply (rule exI[where x=s])"], ["proof (prove)\ngoal (2 subgoals):\n 1. s < x \\<and> (\\<forall>y>s. y < x \\<longrightarrow> f y = 0)\n 2. at_left x \\<noteq> bot", "using that insertI_1"], ["proof (prove)\nusing this:\n  x \\<in> {s<..<b}\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (2 subgoals):\n 1. s < x \\<and> (\\<forall>y>s. y < x \\<longrightarrow> f y = 0)\n 2. at_left x \\<noteq> bot", "unfolding f_def"], ["proof (prove)\nusing this:\n  x \\<in> {s<..<b}\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (2 subgoals):\n 1. s < x \\<and>\n    (\\<forall>y>s. y < x \\<longrightarrow> Im (g y - z) / Re (g y - z) = 0)\n 2. at_left x \\<noteq> bot", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "show \"jumpF f (at_right x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "apply (rule jumpF_eventually_const[of _ 0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_right x. f x = 0\n 2. at_right x \\<noteq> bot", "unfolding eventually_at_right"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> f y = 0\n 2. at_right x \\<noteq> bot", "apply (rule exI[where x=b])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < b \\<and> (\\<forall>y>x. y < b \\<longrightarrow> f y = 0)\n 2. at_right x \\<noteq> bot", "using that insertI_1"], ["proof (prove)\nusing this:\n  x \\<in> {s<..<b}\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (2 subgoals):\n 1. x < b \\<and> (\\<forall>y>x. y < b \\<longrightarrow> f y = 0)\n 2. at_right x \\<noteq> bot", "unfolding f_def"], ["proof (prove)\nusing this:\n  x \\<in> {s<..<b}\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (2 subgoals):\n 1. x < b \\<and>\n    (\\<forall>y>x. y < b \\<longrightarrow> Im (g y - z) / Re (g y - z) = 0)\n 2. at_right x \\<noteq> bot", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0", "have \"{x. (jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0) \\<and> s \\<le> x \\<and> x \\<le> b}\n          = {x. (jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0) \\<and> (x=s \\<or> x = b)}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        s \\<le> x \\<and> x \\<le> b} =\n    {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        (x = s \\<or> x = b)}", "using  \\<open>s\\<in>{a..<b}\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        s \\<le> x \\<and> x \\<le> b} =\n    {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        (x = s \\<or> x = b)}", "by force"], ["proof (state)\nthis:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "then"], ["proof (chain)\npicking this:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "unfolding finite_jumpFs_def"], ["proof (prove)\nusing this:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n          jumpF f (at_right x) \\<noteq> 0) \\<and>\n         s \\<le> x \\<and> x \\<le> b}", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs f s b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_jumpFs f s b\n\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) = 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n 2. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "ultimately"], ["proof (chain)\npicking this:\n  finite_jumpFs f a s\n  finite_jumpFs f s b", "show ?case"], ["proof (prove)\nusing this:\n  finite_jumpFs f a s\n  finite_jumpFs f s b\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "using finite_jumpFs_combine[of _ a s b]"], ["proof (prove)\nusing this:\n  finite_jumpFs f a s\n  finite_jumpFs f s b\n  \\<lbrakk>finite_jumpFs ?f a s; finite_jumpFs ?f s b\\<rbrakk>\n  \\<Longrightarrow> finite_jumpFs ?f a b\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "unfolding f_def"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) s b\n  \\<lbrakk>finite_jumpFs ?f a s; finite_jumpFs ?f s b\\<rbrakk>\n  \\<Longrightarrow> finite_jumpFs ?f a b\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "case (insertI_2 s a b)"], ["proof (state)\nthis:\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "define f where \"f=(\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (g t - z) / Re (g t - z))\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "have \"finite_jumpFs f a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "have \"continuous_on {a..s} g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..s} g", "using \\<open>continuous_on {a..b} g\\<close> \\<open>s \\<in> {a..<b}\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {a..b} g\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. continuous_on {a..s} g", "by (auto elim:continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on {a..s} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "then"], ["proof (chain)\npicking this:\n  continuous_on {a..s} g", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_on {a..s} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "using insertI_2"], ["proof (prove)\nusing this:\n  continuous_on {a..s} g\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a s", "unfolding f_def"], ["proof (prove)\nusing this:\n  continuous_on {a..s} g\n  s \\<in> {a..<b}\n  s = a \\<or> Re (g s - z) = 0\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s\n  continuous_on {a..s} g \\<Longrightarrow>\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs f a s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_jumpFs f a s\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "moreover"], ["proof (state)\nthis:\n  finite_jumpFs f a s\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "have \"finite_jumpFs f s b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "have \"jumpF f (at_left x) =0\" \"jumpF f (at_right x) = 0\" when \"x\\<in>{s<..<b}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "have \"isCont f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f x", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t - z) / Re (g t - z)) x", "apply (intro continuous_intros isCont_Im isCont_Re \n            continuous_on_interior[OF \\<open>continuous_on {a..b} g\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> interior {a..b}\n 2. x \\<in> interior {a..b}\n 3. Re (g x - z) \\<noteq> 0", "using insertI_2.hyps(1) that"], ["proof (prove)\nusing this:\n  s \\<in> {a..<b}\n  x \\<in> {s<..<b}\n\ngoal (3 subgoals):\n 1. x \\<in> interior {a..b}\n 2. x \\<in> interior {a..b}\n 3. Re (g x - z) \\<noteq> 0", "apply auto[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g x - z) \\<noteq> 0", "using insertI_2.hyps(3) that"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0\n  x \\<in> {s<..<b}\n\ngoal (1 subgoal):\n 1. Re (g x - z) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  isCont f x\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  isCont f x", "show \"jumpF f (at_left x) =0\" \"jumpF f (at_right x) = 0\""], ["proof (prove)\nusing this:\n  isCont f x\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "by (simp_all add: continuous_at_split jumpF_not_infinity)"], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0", "have \"{x. (jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0) \\<and> s \\<le> x \\<and> x \\<le> b}\n          = {x. (jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0) \\<and> (x=s \\<or> x = b)}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        s \\<le> x \\<and> x \\<le> b} =\n    {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        (x = s \\<or> x = b)}", "using  \\<open>s\\<in>{a..<b}\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {s<..<b} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  s \\<in> {a..<b}\n\ngoal (1 subgoal):\n 1. {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        s \\<le> x \\<and> x \\<le> b} =\n    {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n         jumpF f (at_right x) \\<noteq> 0) \\<and>\n        (x = s \\<or> x = b)}", "by force"], ["proof (state)\nthis:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "then"], ["proof (chain)\npicking this:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}\n\ngoal (1 subgoal):\n 1. finite_jumpFs f s b", "unfolding finite_jumpFs_def"], ["proof (prove)\nusing this:\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      s \\<le> x \\<and> x \\<le> b} =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      (x = s \\<or> x = b)}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n          jumpF f (at_right x) \\<noteq> 0) \\<and>\n         s \\<le> x \\<and> x \\<le> b}", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs f s b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_jumpFs f s b\n\ngoal (1 subgoal):\n 1. \\<And>s a b.\n       \\<lbrakk>s \\<in> {a..<b}; s = a \\<or> Re (g s - z) = 0;\n        \\<forall>t\\<in>{s<..<b}. Re (g t - z) \\<noteq> 0;\n        finite_Psegments (\\<lambda>t. Re (g t - z) = 0) a s;\n        continuous_on {a..s} g \\<Longrightarrow>\n        finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s;\n        continuous_on {a..b} g\\<rbrakk>\n       \\<Longrightarrow> finite_jumpFs\n                          (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "ultimately"], ["proof (chain)\npicking this:\n  finite_jumpFs f a s\n  finite_jumpFs f s b", "show ?case"], ["proof (prove)\nusing this:\n  finite_jumpFs f a s\n  finite_jumpFs f s b\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "using finite_jumpFs_combine[of _ a s b]"], ["proof (prove)\nusing this:\n  finite_jumpFs f a s\n  finite_jumpFs f s b\n  \\<lbrakk>finite_jumpFs ?f a s; finite_jumpFs ?f s b\\<rbrakk>\n  \\<Longrightarrow> finite_jumpFs ?f a b\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "unfolding f_def"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a s\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) s b\n  \\<lbrakk>finite_jumpFs ?f a s; finite_jumpFs ?f s b\\<rbrakk>\n  \\<Longrightarrow> finite_jumpFs ?f a b\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ReZ_segments_imp_jumpFs:\n  assumes \"finite_ReZ_segments g z\" \"path g\" \n  shows \"finite_jumpFs (\\<lambda>t. Im (g t - z)/Re (g t - z)) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1", "using assms"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  path g\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1", "unfolding finite_ReZ_segments_def path_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1", "by (rule finite_Psegments_Re_imp_jumpFs)"], ["", "subsection \\<open>@{term jumpF} at path ends\\<close>"], ["", "definition jumpF_pathstart::\"(real \\<Rightarrow> complex) \\<Rightarrow> complex \\<Rightarrow> real\" where\n  \"jumpF_pathstart g z= jumpF (\\<lambda>t. Im(g t- z)/Re(g t - z)) (at_right 0)\""], ["", "definition jumpF_pathfinish::\"(real \\<Rightarrow> complex) \\<Rightarrow> complex \\<Rightarrow> real\" where\n  \"jumpF_pathfinish g z= jumpF (\\<lambda>t. Im(g t - z)/Re(g t -z)) (at_left 1)\""], ["", "lemma jumpF_pathstart_eq_0:\n  assumes \"path g\" \"Re(pathstart g)\\<noteq>Re z\"\n  shows \"jumpF_pathstart g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "unfolding jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z)) (at_right 0) = 0", "apply (rule jumpF_im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. g t - z)\n 2. Re (g 0 - z) \\<noteq> 0\n 3. 0 \\<le> 0\n 4. 0 < 1", "using assms[unfolded pathstart_def]"], ["proof (prove)\nusing this:\n  path g\n  Re (g 0) \\<noteq> Re z\n\ngoal (4 subgoals):\n 1. path (\\<lambda>t. g t - z)\n 2. Re (g 0 - z) \\<noteq> 0\n 3. 0 \\<le> 0\n 4. 0 < 1", "by auto"], ["", "lemma jumpF_pathfinish_eq_0:\n  assumes \"path g\" \"Re(pathfinish g)\\<noteq>Re z\"\n  shows \"jumpF_pathfinish g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "unfolding jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z)) (at_left 1) = 0", "apply (rule jumpF_im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. g t - z)\n 2. Re (g 1 - z) \\<noteq> 0\n 3. 0 < 1\n 4. 1 \\<le> 1", "using assms[unfolded pathfinish_def]"], ["proof (prove)\nusing this:\n  path g\n  Re (g 1) \\<noteq> Re z\n\ngoal (4 subgoals):\n 1. path (\\<lambda>t. g t - z)\n 2. Re (g 1 - z) \\<noteq> 0\n 3. 0 < 1\n 4. 1 \\<le> 1", "by auto"], ["", "lemma \n  shows jumpF_pathfinish_reversepath: \"jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\"\n    and jumpF_pathstart_reversepath: \"jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z &&&\n    jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\n 2. jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z", "define f where \"f=(\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (g t - z) / Re (g t - z))\n\ngoal (2 subgoals):\n 1. jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\n 2. jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z", "define f' where \"f'=(\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\""], ["proof (state)\nthis:\n  f' = (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\n\ngoal (2 subgoals):\n 1. jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\n 2. jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z", "have \"f o (\\<lambda>t. 1 - t) = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (-) 1 = f'", "unfolding f_def f'_def comp_def reversepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Im (g (1 - x) - z) / Re (g (1 - x) - z)) =\n    (\\<lambda>t. Im (g (1 - t) - z) / Re (g (1 - t) - z))", "by auto"], ["proof (state)\nthis:\n  f \\<circ> (-) 1 = f'\n\ngoal (2 subgoals):\n 1. jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\n 2. jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z", "then"], ["proof (chain)\npicking this:\n  f \\<circ> (-) 1 = f'", "show \"jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\" \n        \"jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z\""], ["proof (prove)\nusing this:\n  f \\<circ> (-) 1 = f'\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z &&&\n    jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z", "unfolding jumpF_pathstart_def jumpF_pathfinish_def"], ["proof (prove)\nusing this:\n  f \\<circ> (-) 1 = f'\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\n     (at_left 1) =\n    jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z)) (at_right 0) &&&\n    jumpF (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\n     (at_right 0) =\n    jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z)) (at_left 1)", "using jumpF_linear_comp(2)[of \"-1\" f 1 0,simplified] jumpF_linear_comp(1)[of \"-1\" f 1 1,simplified]"], ["proof (prove)\nusing this:\n  f \\<circ> (-) 1 = f'\n  jumpF (f \\<circ> (-) 1) (at_right 0) = jumpF f (at_left 1)\n  jumpF (f \\<circ> (-) 1) (at_left 1) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\n     (at_left 1) =\n    jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z)) (at_right 0) &&&\n    jumpF (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\n     (at_right 0) =\n    jumpF (\\<lambda>t. Im (g t - z) / Re (g t - z)) (at_left 1)", "apply (fold f_def f'_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<circ> (-) 1 = f';\n     jumpF (f \\<circ> (-) 1) (at_right 0) = jumpF f (at_left 1);\n     jumpF (f \\<circ> (-) 1) (at_left 1) = jumpF f (at_right 0)\\<rbrakk>\n    \\<Longrightarrow> jumpF f' (at_left 1) = jumpF f (at_right 0)\n 2. \\<lbrakk>f \\<circ> (-) 1 = f';\n     jumpF (f \\<circ> (-) 1) (at_right 0) = jumpF f (at_left 1);\n     jumpF (f \\<circ> (-) 1) (at_left 1) = jumpF f (at_right 0)\\<rbrakk>\n    \\<Longrightarrow> jumpF f' (at_right 0) = jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (reversepath g) z = jumpF_pathstart g z\n  jumpF_pathstart (reversepath g) z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_pathstart_joinpaths[simp]:\n  \"jumpF_pathstart (g1+++g2) z = jumpF_pathstart g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "let ?h=\"(\\<lambda>t. Im (g1 t - z) / Re (g1 t - z))\""], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "let ?f=\"\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)\""], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "have \"jumpF_pathstart g1 z = jumpF ?h (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g1 z =\n    jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0)", "unfolding jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0) =\n    jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0)", "by simp"], ["proof (state)\nthis:\n  jumpF_pathstart g1 z =\n  jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "also"], ["proof (state)\nthis:\n  jumpF_pathstart g1 z =\n  jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "have \"... = jumpF (?h o (\\<lambda>t. 2*t)) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0) =\n    jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n     (at_right 0)", "using jumpF_linear_comp[of 2 ?h 0 0,simplified]"], ["proof (prove)\nusing this:\n  jumpF\n   ((\\<lambda>t. (Im (g1 t) - Im z) / (Re (g1 t) - Re z)) \\<circ> (*) 2)\n   (at_left 0) =\n  jumpF (\\<lambda>t. (Im (g1 t) - Im z) / (Re (g1 t) - Re z)) (at_left 0)\n  jumpF\n   ((\\<lambda>t. (Im (g1 t) - Im z) / (Re (g1 t) - Re z)) \\<circ> (*) 2)\n   (at_right 0) =\n  jumpF (\\<lambda>t. (Im (g1 t) - Im z) / (Re (g1 t) - Re z)) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0) =\n    jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n     (at_right 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0) =\n  jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n   (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "also"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_right 0) =\n  jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n   (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "have \"... = jumpF ?f (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n     (at_right 0) =\n    jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_right 0)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_right 0 = at_right 0\n 2. \\<forall>\\<^sub>F x in at_right 0.\n       ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2) x =\n       Im ((g1 +++ g2) x - z) / Re ((g1 +++ g2) x - z)", "show \" \\<forall>\\<^sub>F x in at_right 0. (?h \\<circ> (*) 2) x =?f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right 0.\n       ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2) x =\n       Im ((g1 +++ g2) x - z) / Re ((g1 +++ g2) x - z)", "unfolding eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>0.\n       \\<forall>y>0.\n          y < b \\<longrightarrow>\n          ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2) y =\n          Im ((g1 +++ g2) y - z) / Re ((g1 +++ g2) y - z)", "apply (intro exI[where x=\"1/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 \\<and>\n    (\\<forall>y>0.\n        y < 1 / 2 \\<longrightarrow>\n        ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2) y =\n        Im ((g1 +++ g2) y - z) / Re ((g1 +++ g2) y - z))", "by (auto simp add:joinpaths_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right 0.\n     ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2) x =\n     Im ((g1 +++ g2) x - z) / Re ((g1 +++ g2) x - z)\n\ngoal (1 subgoal):\n 1. at_right 0 = at_right 0", "qed simp"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n   (at_right 0) =\n  jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n   (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "also"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) \\<circ> (*) 2)\n   (at_right 0) =\n  jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n   (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "have \"... =jumpF_pathstart (g1+++g2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_right 0) =\n    jumpF_pathstart (g1 +++ g2) z", "unfolding jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_right 0) =\n    jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_right 0)", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n   (at_right 0) =\n  jumpF_pathstart (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "finally"], ["proof (chain)\npicking this:\n  jumpF_pathstart g1 z = jumpF_pathstart (g1 +++ g2) z", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g1 z = jumpF_pathstart (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z", "by simp"], ["proof (state)\nthis:\n  jumpF_pathstart (g1 +++ g2) z = jumpF_pathstart g1 z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_pathfinish_joinpaths[simp]:\n  \"jumpF_pathfinish (g1+++g2) z = jumpF_pathfinish g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "let ?h=\"(\\<lambda>t. Im (g2 t - z) / Re (g2 t - z))\""], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "let ?f=\"\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)\""], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "have \"jumpF_pathfinish g2 z = jumpF ?h (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g2 z =\n    jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1)", "unfolding jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1) =\n    jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1)", "by simp"], ["proof (state)\nthis:\n  jumpF_pathfinish g2 z =\n  jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "also"], ["proof (state)\nthis:\n  jumpF_pathfinish g2 z =\n  jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "have \"... = jumpF (?h o (\\<lambda>t. 2*t-1)) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1) =\n    jumpF\n     ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n      (\\<lambda>t. 2 * t - 1))\n     (at_left 1)", "using jumpF_linear_comp[of 2 _ \"-1\" 1,simplified]"], ["proof (prove)\nusing this:\n  jumpF (?f \\<circ> (\\<lambda>x. 2 * x - 1)) (at_left 1) =\n  jumpF ?f (at_left 1)\n  jumpF (?f \\<circ> (\\<lambda>x. 2 * x - 1)) (at_right 1) =\n  jumpF ?f (at_right 1)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1) =\n    jumpF\n     ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n      (\\<lambda>t. 2 * t - 1))\n     (at_left 1)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1) =\n  jumpF\n   ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n    (\\<lambda>t. 2 * t - 1))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "also"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_left 1) =\n  jumpF\n   ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n    (\\<lambda>t. 2 * t - 1))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "have \"... = jumpF ?f (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n      (\\<lambda>t. 2 * t - 1))\n     (at_left 1) =\n    jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_left 1)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_left 1 = at_left 1\n 2. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n        (\\<lambda>t. 2 * t - 1))\n        x =\n       Im ((g1 +++ g2) x - z) / Re ((g1 +++ g2) x - z)", "show \" \\<forall>\\<^sub>F x in at_left 1. (?h \\<circ> (\\<lambda>t. 2 * t - 1)) x =?f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n        (\\<lambda>t. 2 * t - 1))\n        x =\n       Im ((g1 +++ g2) x - z) / Re ((g1 +++ g2) x - z)", "unfolding eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<1.\n       \\<forall>y>b.\n          y < 1 \\<longrightarrow>\n          ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n           (\\<lambda>t. 2 * t - 1))\n           y =\n          Im ((g1 +++ g2) y - z) / Re ((g1 +++ g2) y - z)", "apply (intro exI[where x=\"1/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 < 1 \\<and>\n    (\\<forall>y>1 / 2.\n        y < 1 \\<longrightarrow>\n        ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n         (\\<lambda>t. 2 * t - 1))\n         y =\n        Im ((g1 +++ g2) y - z) / Re ((g1 +++ g2) y - z))", "by (auto simp add:joinpaths_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1.\n     ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n      (\\<lambda>t. 2 * t - 1))\n      x =\n     Im ((g1 +++ g2) x - z) / Re ((g1 +++ g2) x - z)\n\ngoal (1 subgoal):\n 1. at_left 1 = at_left 1", "qed simp"], ["proof (state)\nthis:\n  jumpF\n   ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n    (\\<lambda>t. 2 * t - 1))\n   (at_left 1) =\n  jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "also"], ["proof (state)\nthis:\n  jumpF\n   ((\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) \\<circ>\n    (\\<lambda>t. 2 * t - 1))\n   (at_left 1) =\n  jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "have \"... =jumpF_pathfinish (g1+++g2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_left 1) =\n    jumpF_pathfinish (g1 +++ g2) z", "unfolding jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_left 1) =\n    jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_left 1)", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n   (at_left 1) =\n  jumpF_pathfinish (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "finally"], ["proof (chain)\npicking this:\n  jumpF_pathfinish g2 z = jumpF_pathfinish (g1 +++ g2) z", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathfinish g2 z = jumpF_pathfinish (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z", "by simp"], ["proof (state)\nthis:\n  jumpF_pathfinish (g1 +++ g2) z = jumpF_pathfinish g2 z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cauchy index\\<close>  \n\n\\<comment>\\<open>Deprecated, use \"cindexE\" if possible\\<close>"], ["", "definition cindex::\"real \\<Rightarrow> real \\<Rightarrow> (real \\<Rightarrow> real) \\<Rightarrow> int\" where\n  \"cindex a b f = (\\<Sum>x\\<in>{x. jump f x\\<noteq>0 \\<and> a<x \\<and> x<b}. jump f x )\""], ["", "definition cindexE::\"real \\<Rightarrow> real \\<Rightarrow> (real \\<Rightarrow> real) \\<Rightarrow> real\" where\n  \"cindexE a b f = (\\<Sum>x\\<in>{x. jumpF f (at_right x) \\<noteq>0 \\<and> a\\<le>x \\<and> x<b}. jumpF f (at_right x)) \n                    - (\\<Sum>x\\<in>{x. jumpF f (at_left x) \\<noteq>0 \\<and> a<x \\<and> x\\<le>b}. jumpF f (at_left x))\""], ["", "definition cindexE_ubd::\"(real \\<Rightarrow> real) \\<Rightarrow> real\" where\n  \"cindexE_ubd f = (\\<Sum>x\\<in>{x. jumpF f (at_right x) \\<noteq>0 }. jumpF f (at_right x)) \n                      - (\\<Sum>x\\<in>{x. jumpF f (at_left x) \\<noteq>0}. jumpF f (at_left x))\""], ["", "lemma cindexE_empty:\n  \"cindexE a a f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a a f = 0", "unfolding cindexE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < a.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> a.\n       jumpF f (at_left x)) =\n    0", "by (simp add: sum.neutral)"], ["", "lemma cindex_const: \"cindex a b (\\<lambda>_. c) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex a b (\\<lambda>_. c) = 0", "unfolding cindex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump (\\<lambda>_. c))\n     {x. jump (\\<lambda>_. c) x \\<noteq> 0 \\<and> a < x \\<and> x < b} =\n    0", "apply (rule sum.neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. jump (\\<lambda>_. c) x \\<noteq> 0 \\<and>\n                       a < x \\<and> x < b}.\n       jump (\\<lambda>_. c) x = 0", "by auto"], ["", "lemma cindex_eq_cindex_poly: \"cindex a b (\\<lambda>x. poly q x/poly p x) = cindex_poly a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "using cindex_const"], ["proof (prove)\nusing this:\n  p = 0\n  cindex ?a ?b (\\<lambda>_. ?c) = 0\n\ngoal (1 subgoal):\n 1. cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "by auto"], ["proof (state)\nthis:\n  cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "have \"cindex_poly a b q p = \n      (\\<Sum>x |jump_poly q p x \\<noteq>0 \\<and> a < x \\<and> x < b. jump_poly q p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n       jump_poly q p x)", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) =\n    (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n       jump_poly q p x)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jump_poly q p x \\<noteq> 0 \\<and>\n                       a < x \\<and> x < b}.\n       jump_poly q p i = 0\n 4. \\<And>x.\n       x \\<in> {x. jump_poly q p x \\<noteq> 0 \\<and>\n                   a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly q p x = jump_poly q p x", "using jump_poly_not_root"], ["proof (prove)\nusing this:\n  poly ?p ?x \\<noteq> 0 \\<Longrightarrow> jump_poly ?q ?p ?x = 0\n\ngoal (4 subgoals):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jump_poly q p x \\<noteq> 0 \\<and>\n                       a < x \\<and> x < b}.\n       jump_poly q p i = 0\n 4. \\<And>x.\n       x \\<in> {x. jump_poly q p x \\<noteq> 0 \\<and>\n                   a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly q p x = jump_poly q p x", "by (auto simp add: \\<open>p\\<noteq>0\\<close> poly_roots_finite)"], ["proof (state)\nthis:\n  cindex_poly a b q p =\n  (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n     jump_poly q p x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "also"], ["proof (state)\nthis:\n  cindex_poly a b q p =\n  (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n     jump_poly q p x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "have \"... = cindex a b (\\<lambda>x. poly q x/poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n       jump_poly q p x) =\n    cindex a b (\\<lambda>x. poly q x / poly p x)", "unfolding cindex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n       jump_poly q p x) =\n    sum (jump (\\<lambda>x. poly q x / poly p x))\n     {x. jump (\\<lambda>x. poly q x / poly p x) x \\<noteq> 0 \\<and>\n         a < x \\<and> x < b}", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b} =\n    {x. jump (\\<lambda>x. poly q x / poly p x) x \\<noteq> 0 \\<and>\n        a < x \\<and> x < b}\n 2. \\<And>x.\n       x \\<in> {x. jump (\\<lambda>x. poly q x / poly p x) x \\<noteq>\n                   0 \\<and>\n                   a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly q p x = jump (\\<lambda>x. poly q x / poly p x) x", "using jump_jump_poly[of q]"], ["proof (prove)\nusing this:\n  jump (\\<lambda>x. poly q x / poly ?p x) ?a = jump_poly q ?p ?a\n\ngoal (2 subgoals):\n 1. {x. jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b} =\n    {x. jump (\\<lambda>x. poly q x / poly p x) x \\<noteq> 0 \\<and>\n        a < x \\<and> x < b}\n 2. \\<And>x.\n       x \\<in> {x. jump (\\<lambda>x. poly q x / poly p x) x \\<noteq>\n                   0 \\<and>\n                   a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly q p x = jump (\\<lambda>x. poly q x / poly p x) x", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x | jump_poly q p x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n     jump_poly q p x) =\n  cindex a b (\\<lambda>x. poly q x / poly p x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "finally"], ["proof (chain)\npicking this:\n  cindex_poly a b q p = cindex a b (\\<lambda>x. poly q x / poly p x)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_poly a b q p = cindex a b (\\<lambda>x. poly q x / poly p x)\n\ngoal (1 subgoal):\n 1. cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p", "by auto"], ["proof (state)\nthis:\n  cindex a b (\\<lambda>x. poly q x / poly p x) = cindex_poly a b q p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_combine:\n  assumes finite:\"finite {x. jump f x\\<noteq>0 \\<and> a<x \\<and> x<c}\" and \"a<b\" \"b<c\"\n  shows \"cindex a c f = cindex a b f  + jump f b + cindex b c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "define ssum where \"ssum = (\\<lambda>s. sum (jump f) ({x. jump f x\\<noteq>0 \\<and> a<x \\<and> x<c} \\<inter> s))\""], ["proof (state)\nthis:\n  ssum =\n  (\\<lambda>s.\n      sum (jump f)\n       ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> s))\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "have ssum_union:\"ssum (A \\<union> B) = ssum A + ssum B\" when \"A \\<inter> B ={}\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. ssum (A \\<union> B) = ssum A + ssum B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ssum (A \\<union> B) = ssum A + ssum B", "define C where \"C={x. jump f x \\<noteq> 0 \\<and> a<x \\<and> x<c}\""], ["proof (state)\nthis:\n  C = {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c}\n\ngoal (1 subgoal):\n 1. ssum (A \\<union> B) = ssum A + ssum B", "have \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "using finite"], ["proof (prove)\nusing this:\n  finite {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c}\n\ngoal (1 subgoal):\n 1. finite C", "unfolding C_def"], ["proof (prove)\nusing this:\n  finite {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c}\n\ngoal (1 subgoal):\n 1. finite {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c}", "."], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. ssum (A \\<union> B) = ssum A + ssum B", "then"], ["proof (chain)\npicking this:\n  finite C", "show ?thesis"], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. ssum (A \\<union> B) = ssum A + ssum B", "unfolding ssum_def"], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter>\n      (A \\<union> B)) =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> A) +\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> B)", "apply (fold C_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow>\n    sum (jump f) (C \\<inter> (A \\<union> B)) =\n    sum (jump f) (C \\<inter> A) + sum (jump f) (C \\<inter> B)", "using sum_Un[of \"C \\<inter> A\" \"C \\<inter> B\"] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (C \\<inter> A); finite (C \\<inter> B)\\<rbrakk>\n  \\<Longrightarrow> sum ?f (C \\<inter> A \\<union> C \\<inter> B) =\n                    sum ?f (C \\<inter> A) + sum ?f (C \\<inter> B) -\n                    sum ?f (C \\<inter> A \\<inter> (C \\<inter> B))\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow>\n    sum (jump f) (C \\<inter> (A \\<union> B)) =\n    sum (jump f) (C \\<inter> A) + sum (jump f) (C \\<inter> B)", "by (simp add: inf_assoc inf_sup_aci(3) inf_sup_distrib1 sum.union_disjoint)"], ["proof (state)\nthis:\n  ssum (A \\<union> B) = ssum A + ssum B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?A \\<inter> ?B = {} \\<Longrightarrow>\n  ssum (?A \\<union> ?B) = ssum ?A + ssum ?B\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "have \"cindex a c f = ssum ({a<..<b} \\<union> {b} \\<union> {b<..<c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex a c f = ssum ({a<..<b} \\<union> {b} \\<union> {b<..<c})", "unfolding ssum_def cindex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump f) {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter>\n      ({a<..<b} \\<union> {b} \\<union> {b<..<c}))", "apply (rule sum.cong[of _ _ \"jump f\" \"jump f\",simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} =\n    {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter>\n    ({a<..<b} \\<union> {b} \\<union> {b<..<c})", "using \\<open>a<b\\<close> \\<open>b<c\\<close>"], ["proof (prove)\nusing this:\n  a < b\n  b < c\n\ngoal (1 subgoal):\n 1. {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} =\n    {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter>\n    ({a<..<b} \\<union> {b} \\<union> {b<..<c})", "by fastforce"], ["proof (state)\nthis:\n  cindex a c f = ssum ({a<..<b} \\<union> {b} \\<union> {b<..<c})\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "moreover"], ["proof (state)\nthis:\n  cindex a c f = ssum ({a<..<b} \\<union> {b} \\<union> {b<..<c})\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "have \"cindex a b f = ssum {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex a b f = ssum {a<..<b}", "unfolding cindex_def ssum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump f) {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < b} =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> {a<..<b})", "using \\<open>a<b\\<close> \\<open>b<c\\<close>"], ["proof (prove)\nusing this:\n  a < b\n  b < c\n\ngoal (1 subgoal):\n 1. sum (jump f) {x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < b} =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> {a<..<b})", "by (intro sum.cong,auto)"], ["proof (state)\nthis:\n  cindex a b f = ssum {a<..<b}\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "moreover"], ["proof (state)\nthis:\n  cindex a b f = ssum {a<..<b}\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "have \"jump f b = ssum {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump f b = ssum {b}", "unfolding ssum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump f b =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> {b})", "using \\<open>a<b\\<close> \\<open>b<c\\<close>"], ["proof (prove)\nusing this:\n  a < b\n  b < c\n\ngoal (1 subgoal):\n 1. jump f b =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> {b})", "by (cases \"jump f b=0\",auto)"], ["proof (state)\nthis:\n  jump f b = ssum {b}\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "moreover"], ["proof (state)\nthis:\n  jump f b = ssum {b}\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "have \"cindex b c f = ssum {b<..<c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex b c f = ssum {b<..<c}", "unfolding cindex_def ssum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump f) {x. jump f x \\<noteq> 0 \\<and> b < x \\<and> x < c} =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> {b<..<c})", "using \\<open>a<b\\<close> \\<open>b<c\\<close>"], ["proof (prove)\nusing this:\n  a < b\n  b < c\n\ngoal (1 subgoal):\n 1. sum (jump f) {x. jump f x \\<noteq> 0 \\<and> b < x \\<and> x < c} =\n    sum (jump f)\n     ({x. jump f x \\<noteq> 0 \\<and> a < x \\<and> x < c} \\<inter> {b<..<c})", "by (intro sum.cong,auto)"], ["proof (state)\nthis:\n  cindex b c f = ssum {b<..<c}\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "ultimately"], ["proof (chain)\npicking this:\n  cindex a c f = ssum ({a<..<b} \\<union> {b} \\<union> {b<..<c})\n  cindex a b f = ssum {a<..<b}\n  jump f b = ssum {b}\n  cindex b c f = ssum {b<..<c}", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex a c f = ssum ({a<..<b} \\<union> {b} \\<union> {b<..<c})\n  cindex a b f = ssum {a<..<b}\n  jump f b = ssum {b}\n  cindex b c f = ssum {b<..<c}\n\ngoal (1 subgoal):\n 1. cindex a c f = cindex a b f + jump f b + cindex b c f", "apply (subst (asm) ssum_union,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex a c f = ssum ({a<..<b} \\<union> {b}) + ssum {b<..<c};\n     cindex a b f = ssum {a<..<b}; jump f b = ssum {b};\n     cindex b c f = ssum {b<..<c}\\<rbrakk>\n    \\<Longrightarrow> cindex a c f = cindex a b f + jump f b + cindex b c f", "by (subst (asm) ssum_union,auto)"], ["proof (state)\nthis:\n  cindex a c f = cindex a b f + jump f b + cindex b c f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindexE_combine:\n  assumes finite:\"finite_jumpFs f a c\" and \"a\\<le>b\" \"b\\<le>c\"\n  shows \"cindexE a c f = cindexE a b f + cindexE b c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define S where \"S={x. (jumpF f (at_left x) \\<noteq> 0 \\<or> jumpF f (at_right x) \\<noteq> 0) \\<and> a \\<le> x \\<and> x \\<le> c}\""], ["proof (state)\nthis:\n  S =\n  {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n       jumpF f (at_right x) \\<noteq> 0) \\<and>\n      a \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define A0 where \"A0={x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < c}\""], ["proof (state)\nthis:\n  A0 = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < c}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define A1 where \"A1={x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b}\""], ["proof (state)\nthis:\n  A1 = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define A2 where \"A2={x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c}\""], ["proof (state)\nthis:\n  A2 = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define B0 where \"B0={x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> c}\""], ["proof (state)\nthis:\n  B0 = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define B1 where \"B1={x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b}\""], ["proof (state)\nthis:\n  B1 = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "define B2 where \"B2={x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c}\""], ["proof (state)\nthis:\n  B2 = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "have [simp]:\"finite A1\" \"finite A2\" \"finite B1\" \"finite B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite A1 &&& finite A2) &&& finite B1 &&& finite B2", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. finite A1\n 2. finite A2\n 3. finite B1\n 4. finite B2", "have \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "using finite"], ["proof (prove)\nusing this:\n  finite_jumpFs f a c\n\ngoal (1 subgoal):\n 1. finite S", "unfolding finite_jumpFs_def S_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n        jumpF f (at_right x) \\<noteq> 0) \\<and>\n       a \\<le> x \\<and> x \\<le> c}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n          jumpF f (at_right x) \\<noteq> 0) \\<and>\n         a \\<le> x \\<and> x \\<le> c}", "by auto"], ["proof (state)\nthis:\n  finite S\n\ngoal (4 subgoals):\n 1. finite A1\n 2. finite A2\n 3. finite B1\n 4. finite B2", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (4 subgoals):\n 1. finite A1\n 2. finite A2\n 3. finite B1\n 4. finite B2", "have \"A1 \\<subseteq> S\" \"A2 \\<subseteq> S\" \"B1 \\<subseteq> S\" \"B2 \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 \\<subseteq> S &&& A2 \\<subseteq> S) &&&\n    B1 \\<subseteq> S &&& B2 \\<subseteq> S", "unfolding A1_def A2_def B1_def B2_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b}\n     \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                      jumpF f (at_right x) \\<noteq> 0) \\<and>\n                     a \\<le> x \\<and> x \\<le> c} &&&\n     {x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c}\n     \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                      jumpF f (at_right x) \\<noteq> 0) \\<and>\n                     a \\<le> x \\<and> x \\<le> c}) &&&\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b}\n    \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                     jumpF f (at_right x) \\<noteq> 0) \\<and>\n                    a \\<le> x \\<and> x \\<le> c} &&&\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c}\n    \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                     jumpF f (at_right x) \\<noteq> 0) \\<and>\n                    a \\<le> x \\<and> x \\<le> c}", "using \\<open>a\\<le>b\\<close> \\<open>b\\<le>c\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. ({x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b}\n     \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                      jumpF f (at_right x) \\<noteq> 0) \\<and>\n                     a \\<le> x \\<and> x \\<le> c} &&&\n     {x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c}\n     \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                      jumpF f (at_right x) \\<noteq> 0) \\<and>\n                     a \\<le> x \\<and> x \\<le> c}) &&&\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b}\n    \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                     jumpF f (at_right x) \\<noteq> 0) \\<and>\n                    a \\<le> x \\<and> x \\<le> c} &&&\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c}\n    \\<subseteq> {x. (jumpF f (at_left x) \\<noteq> 0 \\<or>\n                     jumpF f (at_right x) \\<noteq> 0) \\<and>\n                    a \\<le> x \\<and> x \\<le> c}", "by auto"], ["proof (state)\nthis:\n  A1 \\<subseteq> S\n  A2 \\<subseteq> S\n  B1 \\<subseteq> S\n  B2 \\<subseteq> S\n\ngoal (4 subgoals):\n 1. finite A1\n 2. finite A2\n 3. finite B1\n 4. finite B2", "ultimately"], ["proof (chain)\npicking this:\n  finite S\n  A1 \\<subseteq> S\n  A2 \\<subseteq> S\n  B1 \\<subseteq> S\n  B2 \\<subseteq> S", "show \"finite A1\" \"finite A2\" \"finite B1\" \"finite B2\""], ["proof (prove)\nusing this:\n  finite S\n  A1 \\<subseteq> S\n  A2 \\<subseteq> S\n  B1 \\<subseteq> S\n  B2 \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (finite A1 &&& finite A2) &&& finite B1 &&& finite B2", "by (auto elim:finite_subset)"], ["proof (state)\nthis:\n  finite A1\n  finite A2\n  finite B1\n  finite B2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite A1\n  finite A2\n  finite B1\n  finite B2\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "have \"cindexE a c f = sum (\\<lambda>x. jumpF f (at_right x)) A0 \n        - sum (\\<lambda>x. jumpF f (at_left x)) B0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a c f =\n    (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x))", "unfolding cindexE_def A0_def B0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < c.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> c.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < c.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> c.\n       jumpF f (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE a c f =\n  (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B0. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "also"], ["proof (state)\nthis:\n  cindexE a c f =\n  (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B0. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "have \"... = sum (\\<lambda>x. jumpF f (at_right x)) (A1 \\<union> A2) \n        - sum (\\<lambda>x. jumpF f (at_left x)) (B1 \\<union> B2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n    (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n    (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))", "have \"A0=A1\\<union>A2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 = A1 \\<union> A2", "unfolding A0_def A1_def A2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < c} =\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        a \\<le> x \\<and> x < b} \\<union>\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c}", "using assms"], ["proof (prove)\nusing this:\n  finite_jumpFs f a c\n  a \\<le> b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < c} =\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        a \\<le> x \\<and> x < b} \\<union>\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c}", "by auto"], ["proof (state)\nthis:\n  A0 = A1 \\<union> A2\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n    (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))", "moreover"], ["proof (state)\nthis:\n  A0 = A1 \\<union> A2\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n    (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))", "have \"B0=B1\\<union>B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B0 = B1 \\<union> B2", "unfolding B0_def B1_def B2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> c} =\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        a < x \\<and> x \\<le> b} \\<union>\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c}", "using assms"], ["proof (prove)\nusing this:\n  finite_jumpFs f a c\n  a \\<le> b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> c} =\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        a < x \\<and> x \\<le> b} \\<union>\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c}", "by auto"], ["proof (state)\nthis:\n  B0 = B1 \\<union> B2\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n    (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))", "ultimately"], ["proof (chain)\npicking this:\n  A0 = A1 \\<union> A2\n  B0 = B1 \\<union> B2", "show ?thesis"], ["proof (prove)\nusing this:\n  A0 = A1 \\<union> A2\n  B0 = B1 \\<union> B2\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n    (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n  (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n  (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A0. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B0. jumpF f (at_left x)) =\n  (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "have \"... = cindexE a b f + cindexE b c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    cindexE a b f + cindexE b c f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    cindexE a b f + cindexE b c f", "have \"A1 \\<inter> A2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 \\<inter> A2 = {}", "unfolding A1_def A2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        a \\<le> x \\<and> x < b} \\<inter>\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and> b \\<le> x \\<and> x < c} =\n    {}", "by auto"], ["proof (state)\nthis:\n  A1 \\<inter> A2 = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    cindexE a b f + cindexE b c f", "moreover"], ["proof (state)\nthis:\n  A1 \\<inter> A2 = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    cindexE a b f + cindexE b c f", "have \"B1 \\<inter> B2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B1 \\<inter> B2 = {}", "unfolding B1_def B2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        a < x \\<and> x \\<le> b} \\<inter>\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and> b < x \\<and> x \\<le> c} =\n    {}", "by auto"], ["proof (state)\nthis:\n  B1 \\<inter> B2 = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    cindexE a b f + cindexE b c f", "ultimately"], ["proof (chain)\npicking this:\n  A1 \\<inter> A2 = {}\n  B1 \\<inter> B2 = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  A1 \\<inter> A2 = {}\n  B1 \\<inter> B2 = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    cindexE a b f + cindexE b c f", "unfolding cindexE_def"], ["proof (prove)\nusing this:\n  A1 \\<inter> A2 = {}\n  B1 \\<inter> B2 = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF f (at_left x)) +\n    ((\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n                b \\<le> x \\<and> x < c.\n        jumpF f (at_right x)) -\n     (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n                b < x \\<and> x \\<le> c.\n        jumpF f (at_left x)))", "apply (fold A1_def A2_def B1_def B2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A1 \\<inter> A2 = {}; B1 \\<inter> B2 = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n                      (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n                      (\\<Sum>x\\<in>A1. jumpF f (at_right x)) -\n                      (\\<Sum>x\\<in>B1. jumpF f (at_left x)) +\n                      ((\\<Sum>x\\<in>A2. jumpF f (at_right x)) -\n                       (\\<Sum>x\\<in>B2. jumpF f (at_left x)))", "by (auto simp add:sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n  cindexE a b f + cindexE b c f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A1 \\<union> A2. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>B1 \\<union> B2. jumpF f (at_left x)) =\n  cindexE a b f + cindexE b c f\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "finally"], ["proof (chain)\npicking this:\n  cindexE a c f = cindexE a b f + cindexE b c f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE a c f = cindexE a b f + cindexE b c f\n\ngoal (1 subgoal):\n 1. cindexE a c f = cindexE a b f + cindexE b c f", "."], ["proof (state)\nthis:\n  cindexE a c f = cindexE a b f + cindexE b c f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_linear_comp:\n  assumes \"c\\<noteq>0\"\n  shows \"cindex lb ub (f o (\\<lambda>x. c*x+b)) = (if c>0 \n    then cindex (c*lb+b) (c*ub+b) f \n    else - cindex (c*ub+b) (c*lb+b) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "proof (cases \"c>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < c\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < c", "have \"c<0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. c < 0", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < c\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c < 0", "by auto"], ["proof (state)\nthis:\n  c < 0\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "have \"cindex lb ub (f o (\\<lambda>x. c*x+b)) = - cindex (c*ub+b) (c*lb+b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    - cindex (c * ub + b) (c * lb + b) f", "unfolding cindex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump (f \\<circ> (\\<lambda>x. c * x + b)))\n     {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n         lb < x \\<and> x < ub} =\n    - sum (jump f)\n       {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}", "apply (subst sum_negf[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump (f \\<circ> (\\<lambda>x. c * x + b)))\n     {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n         lb < x \\<and> x < ub} =\n    (\\<Sum>x | jump f x \\<noteq> 0 \\<and>\n               c * ub + b < x \\<and> x < c * lb + b.\n       - jump f x)", "apply (intro sum.reindex_cong[of \"\\<lambda>x. (x-b)/c\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}\n 2. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}\n 3. \\<And>x.\n       x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                   c * ub + b < x \\<and> x < c * lb + b} \\<Longrightarrow>\n       jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = - jump f x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}", "by (simp add: inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}\n 2. \\<And>x.\n       x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                   c * ub + b < x \\<and> x < c * lb + b} \\<Longrightarrow>\n       jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = - jump f x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}", "apply (subst jump_linear_comp[OF \\<open>c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow>\n    {x. (if 0 < c then jump f (c * x + b)\n         else - jump f (c * x + b)) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * ub + b < x \\<and> x < c * lb + b}", "by (auto simp add:\\<open>c<0\\<close> \\<open>c\\<noteq>0\\<close> field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                   c * ub + b < x \\<and> x < c * lb + b} \\<Longrightarrow>\n       jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = - jump f x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                c * ub + b < x \\<and> x < c * lb + b} \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = - jump f x", "apply (subst jump_linear_comp[OF \\<open>c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                c * ub + b < x \\<and> x < c * lb + b} \\<Longrightarrow>\n    (if 0 < c then jump f (c * ((x - b) / c) + b)\n     else - jump f (c * ((x - b) / c) + b)) =\n    - jump f x", "by (auto simp add:\\<open>c<0\\<close> \\<open>c\\<noteq>0\\<close> False field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  - cindex (c * ub + b) (c * lb + b) f\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "then"], ["proof (chain)\npicking this:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  - cindex (c * ub + b) (c * lb + b) f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  - cindex (c * ub + b) (c * lb + b) f\n\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "using False"], ["proof (prove)\nusing this:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  - cindex (c * ub + b) (c * lb + b) f\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "by auto"], ["proof (state)\nthis:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n   else - cindex (c * ub + b) (c * lb + b) f)\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "case True"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "have \"cindex lb ub (f o (\\<lambda>x. c*x+b)) = cindex (c*lb+b) (c*ub+b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    cindex (c * lb + b) (c * ub + b) f", "unfolding cindex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump (f \\<circ> (\\<lambda>x. c * x + b)))\n     {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n         lb < x \\<and> x < ub} =\n    sum (jump f)\n     {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}", "apply (intro sum.reindex_cong[of \"\\<lambda>x. (x-b)/c\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}\n 2. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}\n 3. \\<And>x.\n       x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                   c * lb + b < x \\<and> x < c * ub + b} \\<Longrightarrow>\n       jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = jump f x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}", "by (simp add: inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}\n 2. \\<And>x.\n       x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                   c * lb + b < x \\<and> x < c * ub + b} \\<Longrightarrow>\n       jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = jump f x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jump (f \\<circ> (\\<lambda>x. c * x + b)) x \\<noteq> 0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}", "apply (subst jump_linear_comp[OF \\<open>c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if 0 < c then jump f (c * x + b)\n         else - jump f (c * x + b)) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jump f x \\<noteq> 0 \\<and> c * lb + b < x \\<and> x < c * ub + b}", "by (auto simp add: True \\<open>c\\<noteq>0\\<close> field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                   c * lb + b < x \\<and> x < c * ub + b} \\<Longrightarrow>\n       jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = jump f x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                c * lb + b < x \\<and> x < c * ub + b} \\<Longrightarrow>\n    jump (f \\<circ> (\\<lambda>x. c * x + b)) ((x - b) / c) = jump f x", "apply (subst jump_linear_comp[OF \\<open>c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jump f x \\<noteq> 0 \\<and>\n                c * lb + b < x \\<and> x < c * ub + b} \\<Longrightarrow>\n    (if 0 < c then jump f (c * ((x - b) / c) + b)\n     else - jump f (c * ((x - b) / c) + b)) =\n    jump f x", "by (auto simp add: \\<open>c\\<noteq>0\\<close> True field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cindex (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "then"], ["proof (chain)\npicking this:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cindex (c * lb + b) (c * ub + b) f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cindex (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "using True"], ["proof (prove)\nusing this:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cindex (c * lb + b) (c * ub + b) f\n  0 < c\n\ngoal (1 subgoal):\n 1. cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n     else - cindex (c * ub + b) (c * lb + b) f)", "by auto"], ["proof (state)\nthis:\n  cindex lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindex (c * lb + b) (c * ub + b) f\n   else - cindex (c * ub + b) (c * lb + b) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindexE_linear_comp: \n  assumes \"c\\<noteq>0\"\n  shows \"cindexE lb ub (f o (\\<lambda>x. c*x+b)) = (if c>0 \n    then cindexE (c*lb+b) (c*ub+b) f \n    else - cindexE (c*ub+b) (c*lb+b) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "define cright where \"cright = (\\<lambda>lb ub f. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and> lb \\<le> x \\<and> x < ub. \n                        jumpF f (at_right x)))\""], ["proof (state)\nthis:\n  cright =\n  (\\<lambda>lb ub f.\n      \\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n                lb \\<le> x \\<and> x < ub.\n        jumpF f (at_right x))\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "define cleft where \"cleft = (\\<lambda>lb ub f. (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> lb < x \\<and> x \\<le> ub. \n                        jumpF f (at_left x)))\""], ["proof (state)\nthis:\n  cleft =\n  (\\<lambda>lb ub f.\n      \\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n                lb < x \\<and> x \\<le> ub.\n        jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have cindexE_unfold:\"cindexE lb ub f = cright lb ub f - cleft lb ub f\"\n    for lb ub f"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub f = cright lb ub f - cleft lb ub f", "unfolding cindexE_def cright_def cleft_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               lb \\<le> x \\<and> x < ub.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               lb < x \\<and> x \\<le> ub.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               lb \\<le> x \\<and> x < ub.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               lb < x \\<and> x \\<le> ub.\n       jumpF f (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE ?lb ?ub ?f = cright ?lb ?ub ?f - cleft ?lb ?ub ?f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have ?thesis when \"c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have \"cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) = cleft (c * ub + b) (c * lb + b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    cleft (c * ub + b) (c * lb + b) f", "unfolding cright_def cleft_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF (f \\<circ> (\\<lambda>x. c * x + b))\n                (at_right x) \\<noteq>\n               0 \\<and>\n               lb \\<le> x \\<and> x < ub.\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x)) =\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               c * ub + b < x \\<and> x \\<le> c * lb + b.\n       jumpF f (at_left x))", "apply (intro sum.reindex_cong[of \"\\<lambda>x. (x-b)/c\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n         c * ub + b < x \\<and> x \\<le> c * lb + b}\n 2. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * ub + b < x \\<and> x \\<le> c * lb + b}\n 3. \\<And>x.\n       x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                   c * ub + b < x \\<and>\n                   x \\<le> c * lb + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n       jumpF f (at_left x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n         c * ub + b < x \\<and> x \\<le> c * lb + b}", "by (simp add: inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * ub + b < x \\<and> x \\<le> c * lb + b}\n 2. \\<And>x.\n       x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                   c * ub + b < x \\<and>\n                   x \\<le> c * lb + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n       jumpF f (at_left x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * ub + b < x \\<and> x \\<le> c * lb + b}", "using that"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * ub + b < x \\<and> x \\<le> c * lb + b}", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                   c * ub + b < x \\<and>\n                   x \\<le> c * lb + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n       jumpF f (at_left x)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                c * ub + b < x \\<and> x \\<le> c * lb + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n    jumpF f (at_left x)", "using that"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                c * ub + b < x \\<and> x \\<le> c * lb + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n    jumpF f (at_left x)", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * ub + b) (c * lb + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "moreover"], ["proof (state)\nthis:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * ub + b) (c * lb + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have \"cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) = cright (c*ub+b) (c*lb + b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    cright (c * ub + b) (c * lb + b) f", "unfolding cright_def cleft_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF (f \\<circ> (\\<lambda>x. c * x + b))\n                (at_left x) \\<noteq>\n               0 \\<and>\n               lb < x \\<and> x \\<le> ub.\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               c * ub + b \\<le> x \\<and> x < c * lb + b.\n       jumpF f (at_right x))", "apply (intro sum.reindex_cong[of \"\\<lambda>x. (x-b)/c\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n         c * ub + b \\<le> x \\<and> x < c * lb + b}\n 2. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * ub + b \\<le> x \\<and> x < c * lb + b}\n 3. \\<And>x.\n       x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                   c * ub + b \\<le> x \\<and>\n                   x < c * lb + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n       jumpF f (at_right x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n         c * ub + b \\<le> x \\<and> x < c * lb + b}", "by (simp add: inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * ub + b \\<le> x \\<and> x < c * lb + b}\n 2. \\<And>x.\n       x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                   c * ub + b \\<le> x \\<and>\n                   x < c * lb + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n       jumpF f (at_right x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * ub + b \\<le> x \\<and> x < c * lb + b}", "using that"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * ub + b \\<le> x \\<and> x < c * lb + b}", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                   c * ub + b \\<le> x \\<and>\n                   x < c * lb + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n       jumpF f (at_right x)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                c * ub + b \\<le> x \\<and> x < c * lb + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n    jumpF f (at_right x)", "using that"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                c * ub + b \\<le> x \\<and> x < c * lb + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n    jumpF f (at_right x)", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * ub + b) (c * lb + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "ultimately"], ["proof (chain)\npicking this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * ub + b) (c * lb + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * ub + b) (c * lb + b) f", "show ?thesis"], ["proof (prove)\nusing this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * ub + b) (c * lb + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * ub + b) (c * lb + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "unfolding cindexE_unfold"], ["proof (prove)\nusing this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * ub + b) (c * lb + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * ub + b) (c * lb + b) f\n\ngoal (1 subgoal):\n 1. cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) -\n    cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c\n     then cright (c * lb + b) (c * ub + b) f -\n          cleft (c * lb + b) (c * ub + b) f\n     else - (cright (c * ub + b) (c * lb + b) f -\n             cleft (c * ub + b) (c * lb + b) f))", "using that"], ["proof (prove)\nusing this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * ub + b) (c * lb + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * ub + b) (c * lb + b) f\n  c < 0\n\ngoal (1 subgoal):\n 1. cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) -\n    cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c\n     then cright (c * lb + b) (c * ub + b) f -\n          cleft (c * lb + b) (c * ub + b) f\n     else - (cright (c * ub + b) (c * lb + b) f -\n             cleft (c * ub + b) (c * lb + b) f))", "by auto"], ["proof (state)\nthis:\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < 0 \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "moreover"], ["proof (state)\nthis:\n  c < 0 \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have ?thesis when \"c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have \"cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) = cright (c * lb + b) (c * ub + b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    cright (c * lb + b) (c * ub + b) f", "unfolding cright_def cleft_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF (f \\<circ> (\\<lambda>x. c * x + b))\n                (at_right x) \\<noteq>\n               0 \\<and>\n               lb \\<le> x \\<and> x < ub.\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               c * lb + b \\<le> x \\<and> x < c * ub + b.\n       jumpF f (at_right x))", "apply (intro sum.reindex_cong[of \"\\<lambda>x. (x-b)/c\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n         c * lb + b \\<le> x \\<and> x < c * ub + b}\n 2. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * lb + b \\<le> x \\<and> x < c * ub + b}\n 3. \\<And>x.\n       x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                   c * lb + b \\<le> x \\<and>\n                   x < c * ub + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n       jumpF f (at_right x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n         c * lb + b \\<le> x \\<and> x < c * ub + b}", "by (simp add: inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * lb + b \\<le> x \\<and> x < c * ub + b}\n 2. \\<And>x.\n       x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                   c * lb + b \\<le> x \\<and>\n                   x < c * ub + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n       jumpF f (at_right x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * lb + b \\<le> x \\<and> x < c * ub + b}", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right x) \\<noteq>\n        0 \\<and>\n        lb \\<le> x \\<and> x < ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        c * lb + b \\<le> x \\<and> x < c * ub + b}", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                   c * lb + b \\<le> x \\<and>\n                   x < c * ub + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n       jumpF f (at_right x)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                c * lb + b \\<le> x \\<and> x < c * ub + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n    jumpF f (at_right x)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n                c * lb + b \\<le> x \\<and> x < c * ub + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_right ((x - b) / c)) =\n    jumpF f (at_right x)", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "moreover"], ["proof (state)\nthis:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "have \"cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) = cleft (c*lb+b) (c*ub + b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    cleft (c * lb + b) (c * ub + b) f", "unfolding cright_def cleft_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF (f \\<circ> (\\<lambda>x. c * x + b))\n                (at_left x) \\<noteq>\n               0 \\<and>\n               lb < x \\<and> x \\<le> ub.\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x)) =\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               c * lb + b < x \\<and> x \\<le> c * ub + b.\n       jumpF f (at_left x))", "apply (intro sum.reindex_cong[of \"\\<lambda>x. (x-b)/c\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n         c * lb + b < x \\<and> x \\<le> c * ub + b}\n 2. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * lb + b < x \\<and> x \\<le> c * ub + b}\n 3. \\<And>x.\n       x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                   c * lb + b < x \\<and>\n                   x \\<le> c * ub + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n       jumpF f (at_left x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (x - b) / c)\n     {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n         c * lb + b < x \\<and> x \\<le> c * ub + b}", "by (simp add: inj_on_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * lb + b < x \\<and> x \\<le> c * ub + b}\n 2. \\<And>x.\n       x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                   c * lb + b < x \\<and>\n                   x \\<le> c * ub + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n       jumpF f (at_left x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * lb + b < x \\<and> x \\<le> c * ub + b}", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. {x. jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left x) \\<noteq>\n        0 \\<and>\n        lb < x \\<and> x \\<le> ub} =\n    (\\<lambda>x. (x - b) / c) `\n    {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        c * lb + b < x \\<and> x \\<le> c * ub + b}", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                   c * lb + b < x \\<and>\n                   x \\<le> c * ub + b} \\<Longrightarrow>\n       jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n       jumpF f (at_left x)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                c * lb + b < x \\<and> x \\<le> c * ub + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n    jumpF f (at_left x)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. x \\<in> {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n                c * lb + b < x \\<and> x \\<le> c * ub + b} \\<Longrightarrow>\n    jumpF (f \\<circ> (\\<lambda>x. c * x + b)) (at_left ((x - b) / c)) =\n    jumpF f (at_left x)", "by (subst jumpF_linear_comp[OF \\<open>c\\<noteq>0\\<close>],auto simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "ultimately"], ["proof (chain)\npicking this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * lb + b) (c * ub + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * lb + b) (c * ub + b) f", "show ?thesis"], ["proof (prove)\nusing this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * lb + b) (c * ub + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "unfolding cindexE_unfold"], ["proof (prove)\nusing this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * lb + b) (c * ub + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * lb + b) (c * ub + b) f\n\ngoal (1 subgoal):\n 1. cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) -\n    cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c\n     then cright (c * lb + b) (c * ub + b) f -\n          cleft (c * lb + b) (c * ub + b) f\n     else - (cright (c * ub + b) (c * lb + b) f -\n             cleft (c * ub + b) (c * lb + b) f))", "using that"], ["proof (prove)\nusing this:\n  cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cright (c * lb + b) (c * ub + b) f\n  cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  cleft (c * lb + b) (c * ub + b) f\n  0 < c\n\ngoal (1 subgoal):\n 1. cright lb ub (f \\<circ> (\\<lambda>x. c * x + b)) -\n    cleft lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c\n     then cright (c * lb + b) (c * ub + b) f -\n          cleft (c * lb + b) (c * ub + b) f\n     else - (cright (c * ub + b) (c * lb + b) f -\n             cleft (c * ub + b) (c * lb + b) f))", "by auto"], ["proof (state)\nthis:\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "ultimately"], ["proof (chain)\npicking this:\n  c < 0 \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n  0 < c \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)", "show ?thesis"], ["proof (prove)\nusing this:\n  c < 0 \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n  0 < c \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c < 0 \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n  0 < c \\<Longrightarrow>\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n    (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n     else - cindexE (c * ub + b) (c * lb + b) f)", "by auto"], ["proof (state)\nthis:\n  cindexE lb ub (f \\<circ> (\\<lambda>x. c * x + b)) =\n  (if 0 < c then cindexE (c * lb + b) (c * ub + b) f\n   else - cindexE (c * ub + b) (c * lb + b) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindexE_cong:\n  assumes \"finite s\" and fg_eq:\"\\<And>x. \\<lbrakk>a<x;x<b;x\\<notin>s\\<rbrakk> \\<Longrightarrow> f x = g x\"\n  shows \"cindexE a b f = cindexE a b g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "define left where \n      \"left=(\\<lambda>f. (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b. jumpF f (at_left x)))\""], ["proof (state)\nthis:\n  left =\n  (\\<lambda>f.\n      \\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n                a < x \\<and> x \\<le> b.\n        jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "define right where \n      \"right=(\\<lambda>f. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b. jumpF f (at_right x)))\""], ["proof (state)\nthis:\n  right =\n  (\\<lambda>f.\n      \\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n                a \\<le> x \\<and> x < b.\n        jumpF f (at_right x))\n\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "have \"left f = left g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left f = left g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. left f = left g", "have \"jumpF f (at_left x) = jumpF g (at_left x)\" when \"a<x\" \"x\\<le>b\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = jumpF g (at_left x)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = g x", "define cs where \"cs \\<equiv> {y\\<in>s. a<y \\<and> y<x}\""], ["proof (state)\nthis:\n  cs \\<equiv> {y \\<in> s. a < y \\<and> y < x}\n\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = g x", "define c where \"c\\<equiv> (if cs = {} then (x+a)/2 else Max cs)\""], ["proof (state)\nthis:\n  c \\<equiv> if cs = {} then (x + a) / 2 else Max cs\n\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = g x", "have \"finite cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite cs", "unfolding cs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y \\<in> s. a < y \\<and> y < x}", "using assms(1)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. finite {y \\<in> s. a < y \\<and> y < x}", "by auto"], ["proof (state)\nthis:\n  finite cs\n\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = g x", "have \"c<x \\<and> (\\<forall>y. c<y \\<and> y<x \\<longrightarrow> f y=g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "proof (cases \"cs={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "case True"], ["proof (state)\nthis:\n  cs = {}\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "then"], ["proof (chain)\npicking this:\n  cs = {}", "have \"\\<forall>y. c<y \\<and> y<x \\<longrightarrow> y \\<notin> s\""], ["proof (prove)\nusing this:\n  cs = {}\n\ngoal (1 subgoal):\n 1. \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s", "unfolding cs_def c_def"], ["proof (prove)\nusing this:\n  {y \\<in> s. a < y \\<and> y < x} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (if {y \\<in> s. a < y \\<and> y < x} = {} then (x + a) / 2\n        else Max {y \\<in> s. a < y \\<and> y < x})\n       < y \\<and>\n       y < x \\<longrightarrow>\n       y \\<notin> s", "by force"], ["proof (state)\nthis:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "moreover"], ["proof (state)\nthis:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "have \"c=(x+a)/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (x + a) / 2", "using True"], ["proof (prove)\nusing this:\n  cs = {}\n\ngoal (1 subgoal):\n 1. c = (x + a) / 2", "unfolding c_def"], ["proof (prove)\nusing this:\n  cs = {}\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + a) / 2 else Max cs) = (x + a) / 2", "by auto"], ["proof (state)\nthis:\n  c = (x + a) / 2\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n  c = (x + a) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n  c = (x + a) / 2\n\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "using fg_eq"], ["proof (prove)\nusing this:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n  c = (x + a) / 2\n  \\<lbrakk>a < ?x; ?x < b; ?x \\<notin> s\\<rbrakk>\n  \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n  c = (x + a) / 2\n  \\<lbrakk>a < ?x; ?x < b; ?x \\<notin> s\\<rbrakk>\n  \\<Longrightarrow> f ?x = g ?x\n  a < x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "by auto"], ["proof (state)\nthis:\n  c < x \\<and> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "case False"], ["proof (state)\nthis:\n  cs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "then"], ["proof (chain)\npicking this:\n  cs \\<noteq> {}", "have \"c\\<in>cs\""], ["proof (prove)\nusing this:\n  cs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c \\<in> cs", "unfolding c_def"], ["proof (prove)\nusing this:\n  cs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + a) / 2 else Max cs) \\<in> cs", "using False \\<open>finite cs\\<close>"], ["proof (prove)\nusing this:\n  cs \\<noteq> {}\n  cs \\<noteq> {}\n  finite cs\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + a) / 2 else Max cs) \\<in> cs", "by auto"], ["proof (state)\nthis:\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "moreover"], ["proof (state)\nthis:\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "have \"\\<forall>y. c<y \\<and> y<x \\<longrightarrow> y \\<notin> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               c < y \\<and> y < x \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s) \""], ["proof (state)\nthis:\n  \\<not> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               c < y \\<and> y < x \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s)", "obtain y' where \"c<y'\" \"y'<x\" \"y'\\<in>s\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>c < y'; y' < x; y' \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c < y'\n  y' < x\n  y' \\<in> s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               c < y \\<and> y < x \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  c < y'\n  y' < x\n  y' \\<in> s", "have \"y'\\<in>cs\""], ["proof (prove)\nusing this:\n  c < y'\n  y' < x\n  y' \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<in> cs", "using \\<open>c\\<in>cs\\<close>"], ["proof (prove)\nusing this:\n  c < y'\n  y' < x\n  y' \\<in> s\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. y' \\<in> cs", "unfolding cs_def"], ["proof (prove)\nusing this:\n  c < y'\n  y' < x\n  y' \\<in> s\n  c \\<in> {y \\<in> s. a < y \\<and> y < x}\n\ngoal (1 subgoal):\n 1. y' \\<in> {y \\<in> s. a < y \\<and> y < x}", "by auto"], ["proof (state)\nthis:\n  y' \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               c < y \\<and> y < x \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  y' \\<in> cs", "have \"y'\\<le>c\""], ["proof (prove)\nusing this:\n  y' \\<in> cs\n\ngoal (1 subgoal):\n 1. y' \\<le> c", "unfolding c_def"], ["proof (prove)\nusing this:\n  y' \\<in> cs\n\ngoal (1 subgoal):\n 1. y' \\<le> (if cs = {} then (x + a) / 2 else Max cs)", "using False \\<open>finite cs\\<close>"], ["proof (prove)\nusing this:\n  y' \\<in> cs\n  cs \\<noteq> {}\n  finite cs\n\ngoal (1 subgoal):\n 1. y' \\<le> (if cs = {} then (x + a) / 2 else Max cs)", "by auto"], ["proof (state)\nthis:\n  y' \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               c < y \\<and> y < x \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  y' \\<le> c", "show False"], ["proof (prove)\nusing this:\n  y' \\<le> c\n\ngoal (1 subgoal):\n 1. False", "using \\<open>c<y'\\<close>"], ["proof (prove)\nusing this:\n  y' \\<le> c\n  c < y'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "ultimately"], ["proof (chain)\npicking this:\n  c \\<in> cs\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> cs\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "unfolding cs_def"], ["proof (prove)\nusing this:\n  c \\<in> {y \\<in> s. a < y \\<and> y < x}\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "using that"], ["proof (prove)\nusing this:\n  c \\<in> {y \\<in> s. a < y \\<and> y < x}\n  \\<forall>y. c < y \\<and> y < x \\<longrightarrow> y \\<notin> s\n  a < x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. c < x \\<and>\n    (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "by (auto intro!:fg_eq)"], ["proof (state)\nthis:\n  c < x \\<and> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < x \\<and> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = g x", "then"], ["proof (chain)\npicking this:\n  c < x \\<and> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)", "show \"\\<forall>\\<^sub>F x in at_left x. f x = g x\""], ["proof (prove)\nusing this:\n  c < x \\<and> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left x. f x = g x", "unfolding eventually_at_left"], ["proof (prove)\nusing this:\n  c < x \\<and> (\\<forall>y. c < y \\<and> y < x \\<longrightarrow> f y = g y)\n\ngoal (1 subgoal):\n 1. \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> f y = g y", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left x. f x = g x\n\ngoal (1 subgoal):\n 1. at_left x = at_left x", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = jumpF g (at_left ?x)\n\ngoal (1 subgoal):\n 1. left f = left g", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = jumpF g (at_left ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = jumpF g (at_left ?x)\n\ngoal (1 subgoal):\n 1. left f = left g", "unfolding left_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = jumpF g (at_left ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF g (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF g (at_left x))", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  left f = left g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  left f = left g\n\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "moreover"], ["proof (state)\nthis:\n  left f = left g\n\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "have \"right f = right g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right f = right g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. right f = right g", "have \"jumpF f (at_right x) = jumpF g (at_right x)\" when \"a\\<le>x\" \"x<b\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = jumpF g (at_right x)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = g x", "define cs where \"cs \\<equiv> {y\\<in>s. x<y \\<and> y<b}\""], ["proof (state)\nthis:\n  cs \\<equiv> {y \\<in> s. x < y \\<and> y < b}\n\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = g x", "define c where \"c\\<equiv> (if cs = {} then (x+b)/2 else Min cs)\""], ["proof (state)\nthis:\n  c \\<equiv> if cs = {} then (x + b) / 2 else Min cs\n\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = g x", "have \"finite cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite cs", "unfolding cs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y \\<in> s. x < y \\<and> y < b}", "using assms(1)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. finite {y \\<in> s. x < y \\<and> y < b}", "by auto"], ["proof (state)\nthis:\n  finite cs\n\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = g x", "have \"x<c \\<and> (\\<forall>y. x<y \\<and> y<c \\<longrightarrow> f y=g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "proof (cases \"cs={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "case True"], ["proof (state)\nthis:\n  cs = {}\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "then"], ["proof (chain)\npicking this:\n  cs = {}", "have \"\\<forall>y. x<y \\<and> y<c \\<longrightarrow> y \\<notin> s\""], ["proof (prove)\nusing this:\n  cs = {}\n\ngoal (1 subgoal):\n 1. \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s", "unfolding cs_def c_def"], ["proof (prove)\nusing this:\n  {y \\<in> s. x < y \\<and> y < b} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       x < y \\<and>\n       y < (if {y \\<in> s. x < y \\<and> y < b} = {} then (x + b) / 2\n            else Min {y \\<in> s. x < y \\<and> y < b}) \\<longrightarrow>\n       y \\<notin> s", "by force"], ["proof (state)\nthis:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "moreover"], ["proof (state)\nthis:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "have \"c=(x+b)/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (x + b) / 2", "using True"], ["proof (prove)\nusing this:\n  cs = {}\n\ngoal (1 subgoal):\n 1. c = (x + b) / 2", "unfolding c_def"], ["proof (prove)\nusing this:\n  cs = {}\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + b) / 2 else Min cs) = (x + b) / 2", "by auto"], ["proof (state)\nthis:\n  c = (x + b) / 2\n\ngoal (2 subgoals):\n 1. cs = {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n 2. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n  c = (x + b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n  c = (x + b) / 2\n\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "using fg_eq"], ["proof (prove)\nusing this:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n  c = (x + b) / 2\n  \\<lbrakk>a < ?x; ?x < b; ?x \\<notin> s\\<rbrakk>\n  \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n  c = (x + b) / 2\n  \\<lbrakk>a < ?x; ?x < b; ?x \\<notin> s\\<rbrakk>\n  \\<Longrightarrow> f ?x = g ?x\n  a \\<le> x\n  x < b\n\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "by auto"], ["proof (state)\nthis:\n  x < c \\<and> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "case False"], ["proof (state)\nthis:\n  cs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "then"], ["proof (chain)\npicking this:\n  cs \\<noteq> {}", "have \"c\\<in>cs\""], ["proof (prove)\nusing this:\n  cs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c \\<in> cs", "unfolding c_def"], ["proof (prove)\nusing this:\n  cs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + b) / 2 else Min cs) \\<in> cs", "using False \\<open>finite cs\\<close>"], ["proof (prove)\nusing this:\n  cs \\<noteq> {}\n  cs \\<noteq> {}\n  finite cs\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + b) / 2 else Min cs) \\<in> cs", "by auto"], ["proof (state)\nthis:\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "moreover"], ["proof (state)\nthis:\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "have \"\\<forall>y. x<y \\<and> y<c \\<longrightarrow> y \\<notin> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               x < y \\<and> y < c \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s) \""], ["proof (state)\nthis:\n  \\<not> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               x < y \\<and> y < c \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s)", "obtain y' where \"x<y'\" \"y'<c\" \"y'\\<in>s\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>x < y'; y' < c; y' \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < y'\n  y' < c\n  y' \\<in> s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               x < y \\<and> y < c \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x < y'\n  y' < c\n  y' \\<in> s", "have \"y'\\<in>cs\""], ["proof (prove)\nusing this:\n  x < y'\n  y' < c\n  y' \\<in> s\n\ngoal (1 subgoal):\n 1. y' \\<in> cs", "using \\<open>c\\<in>cs\\<close>"], ["proof (prove)\nusing this:\n  x < y'\n  y' < c\n  y' \\<in> s\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. y' \\<in> cs", "unfolding cs_def"], ["proof (prove)\nusing this:\n  x < y'\n  y' < c\n  y' \\<in> s\n  c \\<in> {y \\<in> s. x < y \\<and> y < b}\n\ngoal (1 subgoal):\n 1. y' \\<in> {y \\<in> s. x < y \\<and> y < b}", "by auto"], ["proof (state)\nthis:\n  y' \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               x < y \\<and> y < c \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  y' \\<in> cs", "have \"y'\\<ge>c\""], ["proof (prove)\nusing this:\n  y' \\<in> cs\n\ngoal (1 subgoal):\n 1. c \\<le> y'", "unfolding c_def"], ["proof (prove)\nusing this:\n  y' \\<in> cs\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + b) / 2 else Min cs) \\<le> y'", "using False \\<open>finite cs\\<close>"], ["proof (prove)\nusing this:\n  y' \\<in> cs\n  cs \\<noteq> {}\n  finite cs\n\ngoal (1 subgoal):\n 1. (if cs = {} then (x + b) / 2 else Min cs) \\<le> y'", "by auto"], ["proof (state)\nthis:\n  c \\<le> y'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y.\n               x < y \\<and> y < c \\<longrightarrow>\n               y \\<notin> s) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  c \\<le> y'", "show False"], ["proof (prove)\nusing this:\n  c \\<le> y'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>c>y'\\<close>"], ["proof (prove)\nusing this:\n  c \\<le> y'\n  y' < c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {} \\<Longrightarrow>\n    x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "ultimately"], ["proof (chain)\npicking this:\n  c \\<in> cs\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> cs\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "unfolding cs_def"], ["proof (prove)\nusing this:\n  c \\<in> {y \\<in> s. x < y \\<and> y < b}\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "using that"], ["proof (prove)\nusing this:\n  c \\<in> {y \\<in> s. x < y \\<and> y < b}\n  \\<forall>y. x < y \\<and> y < c \\<longrightarrow> y \\<notin> s\n  a \\<le> x\n  x < b\n\ngoal (1 subgoal):\n 1. x < c \\<and>\n    (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "by (auto intro!:fg_eq)"], ["proof (state)\nthis:\n  x < c \\<and> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < c \\<and> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = g x", "then"], ["proof (chain)\npicking this:\n  x < c \\<and> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)", "show \"\\<forall>\\<^sub>F x in at_right x. f x = g x\""], ["proof (prove)\nusing this:\n  x < c \\<and> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. f x = g x", "unfolding eventually_at_right"], ["proof (prove)\nusing this:\n  x < c \\<and> (\\<forall>y. x < y \\<and> y < c \\<longrightarrow> f y = g y)\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> f y = g y", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right x. f x = g x\n\ngoal (1 subgoal):\n 1. at_right x = at_right x", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = jumpF g (at_right ?x)\n\ngoal (1 subgoal):\n 1. right f = right g", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = jumpF g (at_right ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = jumpF g (at_right ?x)\n\ngoal (1 subgoal):\n 1. right f = right g", "unfolding right_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = jumpF g (at_right ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF f (at_right x)) =\n    (\\<Sum>x | jumpF g (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF g (at_right x))", "by (auto intro: sum.cong)"], ["proof (state)\nthis:\n  right f = right g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right f = right g\n\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "ultimately"], ["proof (chain)\npicking this:\n  left f = left g\n  right f = right g", "show ?thesis"], ["proof (prove)\nusing this:\n  left f = left g\n  right f = right g\n\ngoal (1 subgoal):\n 1. cindexE a b f = cindexE a b g", "unfolding cindexE_def left_def right_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n     jumpF f (at_left x)) =\n  (\\<Sum>x | jumpF g (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n     jumpF g (at_left x))\n  (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b.\n     jumpF f (at_right x)) =\n  (\\<Sum>x | jumpF g (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b.\n     jumpF g (at_right x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF g (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF g (at_right x)) -\n    (\\<Sum>x | jumpF g (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF g (at_left x))", "by presburger"], ["proof (state)\nthis:\n  cindexE a b f = cindexE a b g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindexE_constI:\n  assumes \"\\<And>t. \\<lbrakk>a<t;t<b\\<rbrakk> \\<Longrightarrow> f t=c\"\n  shows \"cindexE a b f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "define left where \n      \"left=(\\<lambda>f. (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b. jumpF f (at_left x)))\""], ["proof (state)\nthis:\n  left =\n  (\\<lambda>f.\n      \\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n                a < x \\<and> x \\<le> b.\n        jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "define right where \n      \"right=(\\<lambda>f. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b. jumpF f (at_right x)))\""], ["proof (state)\nthis:\n  right =\n  (\\<lambda>f.\n      \\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n                a \\<le> x \\<and> x < b.\n        jumpF f (at_right x))\n\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "have \"left f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left f = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. left f = 0", "have \"jumpF f (at_left x) = 0\" when \"a<x\" \"x\\<le>b\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "apply (rule jumpF_eventually_const[of _ c])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left x. f x = c\n 2. at_left x \\<noteq> bot", "unfolding eventually_at_left"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> f y = c\n 2. at_left x \\<noteq> bot", "using assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> f ?t = c\n  a < x\n  x \\<le> b\n\ngoal (2 subgoals):\n 1. \\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> f y = c\n 2. at_left x \\<noteq> bot", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. left f = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. left f = 0", "unfolding left_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x \\<le> b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF f (at_left x)) =\n    0", "by auto"], ["proof (state)\nthis:\n  left f = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  left f = 0\n\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "moreover"], ["proof (state)\nthis:\n  left f = 0\n\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "have \"right f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right f = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. right f = 0", "have \"jumpF f (at_right x) = 0\" when \"a\\<le>x\" \"x<b\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "apply (rule jumpF_eventually_const[of _ c])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_right x. f x = c\n 2. at_right x \\<noteq> bot", "unfolding eventually_at_right"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> f y = c\n 2. at_right x \\<noteq> bot", "using assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?t; ?t < b\\<rbrakk> \\<Longrightarrow> f ?t = c\n  a \\<le> x\n  x < b\n\ngoal (2 subgoals):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> f y = c\n 2. at_right x \\<noteq> bot", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. right f = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. right f = 0", "unfolding right_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> ?x; ?x < b\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF f (at_right x)) =\n    0", "by auto"], ["proof (state)\nthis:\n  right f = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right f = 0\n\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "ultimately"], ["proof (chain)\npicking this:\n  left f = 0\n  right f = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  left f = 0\n  right f = 0\n\ngoal (1 subgoal):\n 1. cindexE a b f = 0", "unfolding cindexE_def left_def right_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n     jumpF f (at_left x)) =\n  0\n  (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and> a \\<le> x \\<and> x < b.\n     jumpF f (at_right x)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF f (at_left x)) =\n    0", "by auto"], ["proof (state)\nthis:\n  cindexE a b f = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_eq_cindexE_divide:\n  fixes f g::\"real \\<Rightarrow> real\"\n  defines \"h \\<equiv> (\\<lambda>x. f x/g x)\"\n  assumes \"a<b\" and\n    finite_fg: \"finite {x. (f x=0\\<or>g x=0) \\<and> a\\<le>x\\<and>x\\<le>b}\" and \n    g_imp_f:\"\\<forall>x\\<in>{a..b}. g x=0 \\<longrightarrow> f x\\<noteq>0\" and\n    f_cont:\"continuous_on {a..b} f\" and\n    g_cont:\"continuous_on {a..b} g\"\n  shows \"cindexE a b h = jumpF h (at_right a) + cindex a b h - jumpF h (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "define R where \"R=(\\<lambda>S.{x. jumpF h (at_right x) \\<noteq> 0 \\<and> x\\<in>S})\""], ["proof (state)\nthis:\n  R = (\\<lambda>S. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> S})\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "define L where \"L=(\\<lambda>S.{x. jumpF h (at_left x) \\<noteq> 0 \\<and> x\\<in>S})\""], ["proof (state)\nthis:\n  L = (\\<lambda>S. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> S})\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "define right where \"right = (\\<lambda>S. (\\<Sum>x\\<in>R S. jumpF h (at_right x)))\""], ["proof (state)\nthis:\n  right = (\\<lambda>S. \\<Sum>x\\<in>R S. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "define left where \"left = (\\<lambda>S. (\\<Sum>x\\<in>L S. jumpF h (at_left x)))\""], ["proof (state)\nthis:\n  left = (\\<lambda>S. \\<Sum>x\\<in>L S. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have jump_gnz:\"jumpF h (at_left x) = 0\" \"jumpF h (at_right x) = 0\" \"jump h x=0\" \n      when \"a<x\" \"x<b\" \"g x\\<noteq>0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0 &&& jump h x = 0", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. jumpF h (at_left x) = 0\n 2. jumpF h (at_right x) = 0\n 3. jump h x = 0", "have \"isCont h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont h x", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. f x / g x) x", "using f_cont g_cont that"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  continuous_on {a..b} g\n  a < x\n  x < b\n  g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. f x / g x) x", "by (auto intro!:continuous_intros elim:continuous_on_interior)"], ["proof (state)\nthis:\n  isCont h x\n\ngoal (3 subgoals):\n 1. jumpF h (at_left x) = 0\n 2. jumpF h (at_right x) = 0\n 3. jump h x = 0", "then"], ["proof (chain)\npicking this:\n  isCont h x", "show \"jumpF h (at_left x) = 0\" \"jumpF h (at_right x) = 0\" \"jump h x=0\""], ["proof (prove)\nusing this:\n  isCont h x\n\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0 &&& jump h x = 0", "using jumpF_not_infinity jump_not_infinity"], ["proof (prove)\nusing this:\n  isCont h x\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n  isCont ?f ?a \\<Longrightarrow> jump ?f ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0 &&& jump h x = 0", "unfolding continuous_at_split"], ["proof (prove)\nusing this:\n  continuous (at_left x) h \\<and> continuous (at_right x) h\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n  continuous (at_left ?a) ?f \\<and>\n  continuous (at_right ?a) ?f \\<Longrightarrow>\n  jump ?f ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0 &&& jump h x = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_left x) = 0\n  jumpF h (at_right x) = 0\n  jump h x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have finite_jFs:\"finite_jumpFs h a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "define S where \"S=(\\<lambda>s. {x. (jumpF h (at_left x) \\<noteq> 0 \\<or> jumpF h (at_right x) \\<noteq> 0) \\<and> x\\<in>s})\""], ["proof (state)\nthis:\n  S =\n  (\\<lambda>s.\n      {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n           jumpF h (at_right x) \\<noteq> 0) \\<and>\n          x \\<in> s})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "note jump_gnz"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0", "have \"S {a<..<b} \\<subseteq> {x. (f x=0\\<or>g x=0) \\<and> a\\<le>x\\<and>x\\<le>b}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n\ngoal (1 subgoal):\n 1. S {a<..<b}\n    \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and>\n                    a \\<le> x \\<and> x \\<le> b}", "unfolding S_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n\ngoal (1 subgoal):\n 1. {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a<..<b}}\n    \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and>\n                    a \\<le> x \\<and> x \\<le> b}", "by auto"], ["proof (state)\nthis:\n  S {a<..<b}\n  \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "then"], ["proof (chain)\npicking this:\n  S {a<..<b}\n  \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}", "have \"finite (S {a<..<b})\""], ["proof (prove)\nusing this:\n  S {a<..<b}\n  \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite (S {a<..<b})", "using rev_finite_subset[OF finite_fg]"], ["proof (prove)\nusing this:\n  S {a<..<b}\n  \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n  ?A \\<subseteq> {x. (f x = 0 \\<or> g x = 0) \\<and>\n                     a \\<le> x \\<and> x \\<le> b} \\<Longrightarrow>\n  finite ?A\n\ngoal (1 subgoal):\n 1. finite (S {a<..<b})", "by auto"], ["proof (state)\nthis:\n  finite (S {a<..<b})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "moreover"], ["proof (state)\nthis:\n  finite (S {a<..<b})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "have \"finite (S {a,b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S {a, b})", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         x \\<in> {a, b}}", "by auto"], ["proof (state)\nthis:\n  finite (S {a, b})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "moreover"], ["proof (state)\nthis:\n  finite (S {a, b})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "have \"S {a..b} = S {a<..<b} \\<union> S {a,b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S {a..b} = S {a<..<b} \\<union> S {a, b}", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a..b}} =\n    {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a<..<b}} \\<union>\n    {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a, b}}", "using \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a..b}} =\n    {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a<..<b}} \\<union>\n    {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n         jumpF h (at_right x) \\<noteq> 0) \\<and>\n        x \\<in> {a, b}}", "by auto"], ["proof (state)\nthis:\n  S {a..b} = S {a<..<b} \\<union> S {a, b}\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "ultimately"], ["proof (chain)\npicking this:\n  finite (S {a<..<b})\n  finite (S {a, b})\n  S {a..b} = S {a<..<b} \\<union> S {a, b}", "have \"finite (S {a..b})\""], ["proof (prove)\nusing this:\n  finite (S {a<..<b})\n  finite (S {a, b})\n  S {a..b} = S {a<..<b} \\<union> S {a, b}\n\ngoal (1 subgoal):\n 1. finite (S {a..b})", "by auto"], ["proof (state)\nthis:\n  finite (S {a..b})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "then"], ["proof (chain)\npicking this:\n  finite (S {a..b})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (S {a..b})\n\ngoal (1 subgoal):\n 1. finite_jumpFs h a b", "unfolding S_def finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       x \\<in> {a..b}}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         a \\<le> x \\<and> x \\<le> b}", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs h a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_jumpFs h a b\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"cindexE a b h = right {a..<b} - left {a<..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b h = right {a..<b} - left {a<..b}", "unfolding cindexE_def right_def left_def R_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> a < x \\<and> x \\<le> b.\n       jumpF h (at_left x)) =\n    (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a..<b}.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..b}.\n       jumpF h (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE a b h = right {a..<b} - left {a<..b}\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "also"], ["proof (state)\nthis:\n  cindexE a b h = right {a..<b} - left {a<..b}\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"... = jumpF h (at_right a) +  right {a<..<b} - left {a<..<b} - jumpF h (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right {a..<b} - left {a<..b} =\n    jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. right {a..<b} - left {a<..b} =\n    jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b)", "have \"right {a..<b} = jumpF h (at_right a) +  right {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "proof (cases \"jumpF h (at_right a) =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_right a) = 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n 2. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "case True"], ["proof (state)\nthis:\n  jumpF h (at_right a) = 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_right a) = 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n 2. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right a) = 0", "have \"R {a..<b} = R {a<..<b}\""], ["proof (prove)\nusing this:\n  jumpF h (at_right a) = 0\n\ngoal (1 subgoal):\n 1. R {a..<b} = R {a<..<b}", "unfolding R_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right a) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a..<b}} =\n    {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}", "using less_eq_real_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right a) = 0\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a..<b}} =\n    {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}", "by auto"], ["proof (state)\nthis:\n  R {a..<b} = R {a<..<b}\n\ngoal (2 subgoals):\n 1. jumpF h (at_right a) = 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n 2. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "then"], ["proof (chain)\npicking this:\n  R {a..<b} = R {a<..<b}", "have \"right {a..<b} = right {a<..<b}\""], ["proof (prove)\nusing this:\n  R {a..<b} = R {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} = right {a<..<b}", "unfolding right_def"], ["proof (prove)\nusing this:\n  R {a..<b} = R {a<..<b}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>R {a..<b}. jumpF h (at_right x)) =\n    (\\<Sum>x\\<in>R {a<..<b}. jumpF h (at_right x))", "by auto"], ["proof (state)\nthis:\n  right {a..<b} = right {a<..<b}\n\ngoal (2 subgoals):\n 1. jumpF h (at_right a) = 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n 2. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "then"], ["proof (chain)\npicking this:\n  right {a..<b} = right {a<..<b}", "show ?thesis"], ["proof (prove)\nusing this:\n  right {a..<b} = right {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "using True"], ["proof (prove)\nusing this:\n  right {a..<b} = right {a<..<b}\n  jumpF h (at_right a) = 0\n\ngoal (1 subgoal):\n 1. right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "by auto"], ["proof (state)\nthis:\n  right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "case False"], ["proof (state)\nthis:\n  jumpF h (at_right a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "have \"finite (R {a..<b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R {a..<b})", "using finite_jFs"], ["proof (prove)\nusing this:\n  finite_jumpFs h a b\n\ngoal (1 subgoal):\n 1. finite (R {a..<b})", "unfolding R_def finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a..<b}}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite (R {a..<b})\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "moreover"], ["proof (state)\nthis:\n  finite (R {a..<b})\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "have \"a \\<in> R {a..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> R {a..<b}", "using False \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  jumpF h (at_right a) \\<noteq> 0\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<in> R {a..<b}", "unfolding R_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right a) \\<noteq> 0\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<in> {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a..<b}}", "by auto"], ["proof (state)\nthis:\n  a \\<in> R {a..<b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "moreover"], ["proof (state)\nthis:\n  a \\<in> R {a..<b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "have \"R {a..<b} - {a} = R {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R {a..<b} - {a} = R {a<..<b}", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a..<b}} - {a} =\n    {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}", "by auto"], ["proof (state)\nthis:\n  R {a..<b} - {a} = R {a<..<b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) \\<noteq> 0 \\<Longrightarrow>\n    right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "ultimately"], ["proof (chain)\npicking this:\n  finite (R {a..<b})\n  a \\<in> R {a..<b}\n  R {a..<b} - {a} = R {a<..<b}", "show \"right {a..<b}= jumpF h (at_right a) \n            + right {a<..<b}\""], ["proof (prove)\nusing this:\n  finite (R {a..<b})\n  a \\<in> R {a..<b}\n  R {a..<b} - {a} = R {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "using sum.remove[of \"R {a..<b}\" a \"\\<lambda>x. jumpF h (at_right x)\"]"], ["proof (prove)\nusing this:\n  finite (R {a..<b})\n  a \\<in> R {a..<b}\n  R {a..<b} - {a} = R {a<..<b}\n  \\<lbrakk>finite (R {a..<b}); a \\<in> R {a..<b}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>R {a..<b}. jumpF h (at_right x)) =\n                    jumpF h (at_right a) +\n                    (\\<Sum>x\\<in>R {a..<b} - {a}. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. right {a..<b} = jumpF h (at_right a) + right {a<..<b}", "unfolding right_def"], ["proof (prove)\nusing this:\n  finite (R {a..<b})\n  a \\<in> R {a..<b}\n  R {a..<b} - {a} = R {a<..<b}\n  \\<lbrakk>finite (R {a..<b}); a \\<in> R {a..<b}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>R {a..<b}. jumpF h (at_right x)) =\n                    jumpF h (at_right a) +\n                    (\\<Sum>x\\<in>R {a..<b} - {a}. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>R {a..<b}. jumpF h (at_right x)) =\n    jumpF h (at_right a) + (\\<Sum>x\\<in>R {a<..<b}. jumpF h (at_right x))", "by simp"], ["proof (state)\nthis:\n  right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} - left {a<..b} =\n    jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b)", "moreover"], ["proof (state)\nthis:\n  right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} - left {a<..b} =\n    jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b)", "have \"left {a<..b} = jumpF h (at_left b) +  left {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "proof (cases \"jumpF h (at_left b) =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_left b) = 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n 2. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "case True"], ["proof (state)\nthis:\n  jumpF h (at_left b) = 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_left b) = 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n 2. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_left b) = 0", "have \"L {a<..b} = L {a<..<b}\""], ["proof (prove)\nusing this:\n  jumpF h (at_left b) = 0\n\ngoal (1 subgoal):\n 1. L {a<..b} = L {a<..<b}", "unfolding L_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left b) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..b}} =\n    {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}", "using less_eq_real_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left b) = 0\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..b}} =\n    {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}", "by auto"], ["proof (state)\nthis:\n  L {a<..b} = L {a<..<b}\n\ngoal (2 subgoals):\n 1. jumpF h (at_left b) = 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n 2. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "then"], ["proof (chain)\npicking this:\n  L {a<..b} = L {a<..<b}", "have \"left {a<..b} = left {a<..<b}\""], ["proof (prove)\nusing this:\n  L {a<..b} = L {a<..<b}\n\ngoal (1 subgoal):\n 1. left {a<..b} = left {a<..<b}", "unfolding left_def"], ["proof (prove)\nusing this:\n  L {a<..b} = L {a<..<b}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>L {a<..b}. jumpF h (at_left x)) =\n    (\\<Sum>x\\<in>L {a<..<b}. jumpF h (at_left x))", "by auto"], ["proof (state)\nthis:\n  left {a<..b} = left {a<..<b}\n\ngoal (2 subgoals):\n 1. jumpF h (at_left b) = 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n 2. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "then"], ["proof (chain)\npicking this:\n  left {a<..b} = left {a<..<b}", "show ?thesis"], ["proof (prove)\nusing this:\n  left {a<..b} = left {a<..<b}\n\ngoal (1 subgoal):\n 1. left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "using True"], ["proof (prove)\nusing this:\n  left {a<..b} = left {a<..<b}\n  jumpF h (at_left b) = 0\n\ngoal (1 subgoal):\n 1. left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "by auto"], ["proof (state)\nthis:\n  left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "case False"], ["proof (state)\nthis:\n  jumpF h (at_left b) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "have \"finite (L {a<..b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (L {a<..b})", "using finite_jFs"], ["proof (prove)\nusing this:\n  finite_jumpFs h a b\n\ngoal (1 subgoal):\n 1. finite (L {a<..b})", "unfolding L_def finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..b}}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite (L {a<..b})\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "moreover"], ["proof (state)\nthis:\n  finite (L {a<..b})\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "have \"b \\<in> L {a<..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> L {a<..b}", "using False \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  jumpF h (at_left b) \\<noteq> 0\n  a < b\n\ngoal (1 subgoal):\n 1. b \\<in> L {a<..b}", "unfolding L_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left b) \\<noteq> 0\n  a < b\n\ngoal (1 subgoal):\n 1. b \\<in> {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..b}}", "by auto"], ["proof (state)\nthis:\n  b \\<in> L {a<..b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "moreover"], ["proof (state)\nthis:\n  b \\<in> L {a<..b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "have \"L {a<..b} - {b} = L {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L {a<..b} - {b} = L {a<..<b}", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..b}} - {b} =\n    {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}", "by auto"], ["proof (state)\nthis:\n  L {a<..b} - {b} = L {a<..<b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left b) \\<noteq> 0 \\<Longrightarrow>\n    left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "ultimately"], ["proof (chain)\npicking this:\n  finite (L {a<..b})\n  b \\<in> L {a<..b}\n  L {a<..b} - {b} = L {a<..<b}", "show \"left {a<..b}= jumpF h (at_left b) + left {a<..<b}\""], ["proof (prove)\nusing this:\n  finite (L {a<..b})\n  b \\<in> L {a<..b}\n  L {a<..b} - {b} = L {a<..<b}\n\ngoal (1 subgoal):\n 1. left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "using sum.remove[of \"L {a<..b}\" b \"\\<lambda>x. jumpF h (at_left x)\"]"], ["proof (prove)\nusing this:\n  finite (L {a<..b})\n  b \\<in> L {a<..b}\n  L {a<..b} - {b} = L {a<..<b}\n  \\<lbrakk>finite (L {a<..b}); b \\<in> L {a<..b}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>L {a<..b}. jumpF h (at_left x)) =\n                    jumpF h (at_left b) +\n                    (\\<Sum>x\\<in>L {a<..b} - {b}. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "unfolding left_def"], ["proof (prove)\nusing this:\n  finite (L {a<..b})\n  b \\<in> L {a<..b}\n  L {a<..b} - {b} = L {a<..<b}\n  \\<lbrakk>finite (L {a<..b}); b \\<in> L {a<..b}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>L {a<..b}. jumpF h (at_left x)) =\n                    jumpF h (at_left b) +\n                    (\\<Sum>x\\<in>L {a<..b} - {b}. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>L {a<..b}. jumpF h (at_left x)) =\n    jumpF h (at_left b) + (\\<Sum>x\\<in>L {a<..<b}. jumpF h (at_left x))", "by simp"], ["proof (state)\nthis:\n  left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} - left {a<..b} =\n    jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b)", "ultimately"], ["proof (chain)\npicking this:\n  right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n  left {a<..b} = jumpF h (at_left b) + left {a<..<b}", "show ?thesis"], ["proof (prove)\nusing this:\n  right {a..<b} = jumpF h (at_right a) + right {a<..<b}\n  left {a<..b} = jumpF h (at_left b) + left {a<..<b}\n\ngoal (1 subgoal):\n 1. right {a..<b} - left {a<..b} =\n    jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b)", "by simp"], ["proof (state)\nthis:\n  right {a..<b} - left {a<..b} =\n  jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n  jumpF h (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right {a..<b} - left {a<..b} =\n  jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n  jumpF h (at_left b)\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "also"], ["proof (state)\nthis:\n  right {a..<b} - left {a<..b} =\n  jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n  jumpF h (at_left b)\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"... = jumpF h (at_right a) + cindex a b h - jumpF h (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "define S where \"S={x. g x=0 \\<and> a < x \\<and> x < b}\""], ["proof (state)\nthis:\n  S = {x. g x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"right {a<..<b} = sum (\\<lambda>x. jumpF h (at_right x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_right x))", "unfolding right_def S_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}.\n       jumpF h (at_right x)) =\n    (\\<Sum>x | g x = 0 \\<and> a < x \\<and> x < b. jumpF h (at_right x))", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_right i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}", "using finite_fg"], ["proof (prove)\nusing this:\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}", "by (auto elim:rev_finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}\n 2. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_right i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}", "using jump_gnz"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_right i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_right i) = 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  right {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "moreover"], ["proof (state)\nthis:\n  right {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"left {a<..<b} = sum (\\<lambda>x. jumpF h (at_left x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_left x))", "unfolding left_def S_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}.\n       jumpF h (at_left x)) =\n    (\\<Sum>x | g x = 0 \\<and> a < x \\<and> x < b. jumpF h (at_left x))", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_left i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}", "using finite_fg"], ["proof (prove)\nusing this:\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}", "by (auto elim:rev_finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}\n 2. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_left i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}", "using jump_gnz"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {a<..<b}}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_left i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {a<..<b}}.\n       jumpF h (at_left i) = 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  left {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "ultimately"], ["proof (chain)\npicking this:\n  right {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n  left {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_left x))", "have \"right {a<..<b} - left {a<..<b} \n        = sum (\\<lambda>x. jumpF h (at_right x) - jumpF h (at_left x)) S\""], ["proof (prove)\nusing this:\n  right {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n  left {a<..<b} = (\\<Sum>x\\<in>S. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. right {a<..<b} - left {a<..<b} =\n    (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x))", "by (simp add: sum_subtractf)"], ["proof (state)\nthis:\n  right {a<..<b} - left {a<..<b} =\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "also"], ["proof (state)\nthis:\n  right {a<..<b} - left {a<..<b} =\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"... = sum (\\<lambda>x. of_int(jump h x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) =\n    (\\<Sum>x\\<in>S. real_of_int (jump h x))", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "assume \"x\\<in>S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "define hr where \"hr = sgnx h (at_right x)\""], ["proof (state)\nthis:\n  hr = sgnx h (at_right x)\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "define hl where \"hl = sgnx h (at_left x)\""], ["proof (state)\nthis:\n  hl = sgnx h (at_left x)\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "have \"h sgnx_able (at_left x)\" \"hr\\<noteq>0\" \"h sgnx_able (at_right x)\" \"hl\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h sgnx_able at_left x &&& hr \\<noteq> 0) &&&\n    h sgnx_able at_right x &&& hl \\<noteq> 0", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "have \"finite {t. h t = 0 \\<and> a < t \\<and> t < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. h t = 0 \\<and> a < t \\<and> t < b}", "using finite_fg"], ["proof (prove)\nusing this:\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {t. h t = 0 \\<and> a < t \\<and> t < b}", "unfolding h_def"], ["proof (prove)\nusing this:\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {t. f t / g t = 0 \\<and> a < t \\<and> t < b}", "by (auto elim!:rev_finite_subset)"], ["proof (state)\nthis:\n  finite {t. h t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  finite {t. h t = 0 \\<and> a < t \\<and> t < b}\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "have \"continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b})\n     (\\<lambda>x. f x / g x)", "using f_cont g_cont"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b})\n     (\\<lambda>x. f x / g x)", "by (auto intro!: continuous_intros elim:continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "have \"finite {x. g x = 0 \\<and> a < x \\<and> x < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}", "using finite_fg"], ["proof (prove)\nusing this:\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}", "by (auto elim!:rev_finite_subset)"], ["proof (state)\nthis:\n  finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "have  \" x \\<in> {a<..<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {a<..<b}", "using \\<open>x\\<in>S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> {a<..<b}", "unfolding S_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. g x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. x \\<in> {a<..<b}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {a<..<b}\n\ngoal (4 subgoals):\n 1. h sgnx_able at_left x\n 2. hr \\<noteq> 0\n 3. h sgnx_able at_right x\n 4. hl \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  finite {t. h t = 0 \\<and> a < t \\<and> t < b}\n  continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\n  finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n  x \\<in> {a<..<b}", "show \"h sgnx_able (at_left x)\"  \"hl\\<noteq>0\" \"h sgnx_able (at_right x)\"  \"hr\\<noteq>0\""], ["proof (prove)\nusing this:\n  finite {t. h t = 0 \\<and> a < t \\<and> t < b}\n  continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\n  finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n  x \\<in> {a<..<b}\n\ngoal (1 subgoal):\n 1. (h sgnx_able at_left x &&& hl \\<noteq> 0) &&&\n    h sgnx_able at_right x &&& hr \\<noteq> 0", "using  finite_sgnx_at_left_at_right[of h a b \"{x. g x=0 \\<and> a<x\\<and>x<b}\" x]"], ["proof (prove)\nusing this:\n  finite {t. h t = 0 \\<and> a < t \\<and> t < b}\n  continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\n  finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n  x \\<in> {a<..<b}\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> h sgnx_able at_left x\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> sgnx h (at_left x) \\<noteq> 0\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> h sgnx_able at_right x\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> sgnx h (at_right x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (h sgnx_able at_left x &&& hl \\<noteq> 0) &&&\n    h sgnx_able at_right x &&& hr \\<noteq> 0", "unfolding hl_def hr_def"], ["proof (prove)\nusing this:\n  finite {t. h t = 0 \\<and> a < t \\<and> t < b}\n  continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h\n  finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n  x \\<in> {a<..<b}\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> h sgnx_able at_left x\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> sgnx h (at_left x) \\<noteq> 0\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> h sgnx_able at_right x\n  \\<lbrakk>finite {t. h t = 0 \\<and> a < t \\<and> t < b};\n   continuous_on ({a<..<b} - {x. g x = 0 \\<and> a < x \\<and> x < b}) h;\n   finite {x. g x = 0 \\<and> a < x \\<and> x < b}; x \\<in> {a<..<b}\\<rbrakk>\n  \\<Longrightarrow> sgnx h (at_right x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (h sgnx_able at_left x &&& sgnx h (at_left x) \\<noteq> 0) &&&\n    h sgnx_able at_right x &&& sgnx h (at_right x) \\<noteq> 0", "by blast+"], ["proof (state)\nthis:\n  h sgnx_able at_left x\n  hl \\<noteq> 0\n  h sgnx_able at_right x\n  hr \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h sgnx_able at_left x\n  hr \\<noteq> 0\n  h sgnx_able at_right x\n  hl \\<noteq> 0\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "then"], ["proof (chain)\npicking this:\n  h sgnx_able at_left x\n  hr \\<noteq> 0\n  h sgnx_able at_right x\n  hl \\<noteq> 0", "have \"(h has_sgnx hl) (at_left x)\" \"(h has_sgnx hr) (at_right x)\""], ["proof (prove)\nusing this:\n  h sgnx_able at_left x\n  hr \\<noteq> 0\n  h sgnx_able at_right x\n  hl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (h has_sgnx hl) (at_left x) &&& (h has_sgnx hr) (at_right x)", "unfolding hl_def hr_def"], ["proof (prove)\nusing this:\n  h sgnx_able at_left x\n  sgnx h (at_right x) \\<noteq> 0\n  h sgnx_able at_right x\n  sgnx h (at_left x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (h has_sgnx sgnx h (at_left x)) (at_left x) &&&\n    (h has_sgnx sgnx h (at_right x)) (at_right x)", "using sgnx_able_sgnx"], ["proof (prove)\nusing this:\n  h sgnx_able at_left x\n  sgnx h (at_right x) \\<noteq> 0\n  h sgnx_able at_right x\n  sgnx h (at_left x) \\<noteq> 0\n  ?f sgnx_able ?F \\<Longrightarrow> (?f has_sgnx sgnx ?f ?F) ?F\n\ngoal (1 subgoal):\n 1. (h has_sgnx sgnx h (at_left x)) (at_left x) &&&\n    (h has_sgnx sgnx h (at_right x)) (at_right x)", "by blast+"], ["proof (state)\nthis:\n  (h has_sgnx hl) (at_left x)\n  (h has_sgnx hr) (at_right x)\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "moreover"], ["proof (state)\nthis:\n  (h has_sgnx hl) (at_left x)\n  (h has_sgnx hr) (at_right x)\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "have \"isCont (inverse \\<circ> h) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h) x", "have \"f x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<noteq> 0", "using \\<open>x\\<in>S\\<close> g_imp_f"], ["proof (prove)\nusing this:\n  x \\<in> S\n  \\<forall>x\\<in>{a..b}. g x = 0 \\<longrightarrow> f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f x \\<noteq> 0", "unfolding S_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. g x = 0 \\<and> a < x \\<and> x < b}\n  \\<forall>x\\<in>{a..b}. g x = 0 \\<longrightarrow> f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h) x", "then"], ["proof (chain)\npicking this:\n  f x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h) x", "using f_cont g_cont \\<open>x\\<in>S\\<close>"], ["proof (prove)\nusing this:\n  f x \\<noteq> 0\n  continuous_on {a..b} f\n  continuous_on {a..b} g\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h) x", "unfolding h_def S_def"], ["proof (prove)\nusing this:\n  f x \\<noteq> 0\n  continuous_on {a..b} f\n  continuous_on {a..b} g\n  x \\<in> {x. g x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> (\\<lambda>x. f x / g x)) x", "by (auto simp add:comp_def intro!:continuous_intros elim:continuous_on_interior)"], ["proof (state)\nthis:\n  isCont (inverse \\<circ> h) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isCont (inverse \\<circ> h) x\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "ultimately"], ["proof (chain)\npicking this:\n  (h has_sgnx hl) (at_left x)\n  (h has_sgnx hr) (at_right x)\n  isCont (inverse \\<circ> h) x", "show \"jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)\""], ["proof (prove)\nusing this:\n  (h has_sgnx hl) (at_left x)\n  (h has_sgnx hr) (at_right x)\n  isCont (inverse \\<circ> h) x\n\ngoal (1 subgoal):\n 1. jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "using jump_jumpF[of x h] \\<open>hr\\<noteq>0\\<close> \\<open>hl\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (h has_sgnx hl) (at_left x)\n  (h has_sgnx hr) (at_right x)\n  isCont (inverse \\<circ> h) x\n  \\<lbrakk>isCont (inverse \\<circ> h) x; (h has_sgnx ?l) (at_left x);\n   (h has_sgnx ?r) (at_right x); ?l \\<noteq> 0; ?r \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> real_of_int (jump h x) =\n                    jumpF h (at_right x) - jumpF h (at_left x)\n  hr \\<noteq> 0\n  hl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right x) - jumpF h (at_left x) = real_of_int (jump h x)\n\ngoal (1 subgoal):\n 1. S = S", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) =\n  (\\<Sum>x\\<in>S. real_of_int (jump h x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) =\n  (\\<Sum>x\\<in>S. real_of_int (jump h x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "have \"... = cindex a b h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. real_of_int (jump h x)) = real_of_int (cindex a b h)", "unfolding cindex_def of_int_sum S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | g x = 0 \\<and> a < x \\<and> x < b. real_of_int (jump h x)) =\n    (\\<Sum>x | jump h x \\<noteq> 0 \\<and> a < x \\<and> x < b.\n       real_of_int (jump h x))", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. jump h x \\<noteq> 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jump h x \\<noteq> 0 \\<and> a < x \\<and> x < b}.\n       real_of_int (jump h i) = 0\n 4. \\<And>x.\n       x \\<in> {x. jump h x \\<noteq> 0 \\<and>\n                   a < x \\<and> x < b} \\<Longrightarrow>\n       real_of_int (jump h x) = real_of_int (jump h x)", "using jump_gnz finite_fg"], ["proof (prove)\nusing this:\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  \\<lbrakk>a < ?x; ?x < b; g ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jump h ?x = 0\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> a \\<le> x \\<and> x \\<le> b}\n\ngoal (4 subgoals):\n 1. finite {x. g x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. jump h x \\<noteq> 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. g x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. g x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. jump h x \\<noteq> 0 \\<and> a < x \\<and> x < b}.\n       real_of_int (jump h i) = 0\n 4. \\<And>x.\n       x \\<in> {x. jump h x \\<noteq> 0 \\<and>\n                   a < x \\<and> x < b} \\<Longrightarrow>\n       real_of_int (jump h x) = real_of_int (jump h x)", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S. real_of_int (jump h x)) = real_of_int (cindex a b h)\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "finally"], ["proof (chain)\npicking this:\n  right {a<..<b} - left {a<..<b} = real_of_int (cindex a b h)", "show ?thesis"], ["proof (prove)\nusing this:\n  right {a<..<b} - left {a<..<b} = real_of_int (cindex a b h)\n\ngoal (1 subgoal):\n 1. jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n    jumpF h (at_left b) =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "by simp"], ["proof (state)\nthis:\n  jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n  jumpF h (at_left b) =\n  jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF h (at_right a) + right {a<..<b} - left {a<..<b} -\n  jumpF h (at_left b) =\n  jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "finally"], ["proof (chain)\npicking this:\n  cindexE a b h =\n  jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE a b h =\n  jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)\n\ngoal (1 subgoal):\n 1. cindexE a b h =\n    jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)", "."], ["proof (state)\nthis:\n  cindexE a b h =\n  jumpF h (at_right a) + real_of_int (cindex a b h) - jumpF h (at_left b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cauchy index along a path\\<close>\n\n\\<comment>\\<open>Deprecated, use \"cindex\\_pathE\" if possible\\<close>"], ["", "definition cindex_path::\"(real \\<Rightarrow> complex) \\<Rightarrow> complex \\<Rightarrow> int\" where\n  \"cindex_path g z = cindex 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["", "definition cindex_pathE::\"(real \\<Rightarrow> complex) \\<Rightarrow> complex \\<Rightarrow> real\" where\n  \"cindex_pathE g z = cindexE 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["", "lemma cindex_pathE_point: \"cindex_pathE (linepath a a) b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a a) b = 0", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a a t - b) / Re (linepath a a t - b)) =\n    0", "by (simp add:cindexE_constI)"], ["", "lemma cindex_path_reversepath:\n  \"cindex_path (reversepath g) z = - cindex_path g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "define f where \"f=(\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (g t - z) / Re (g t - z))\n\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "define f' where \"f'=(\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\""], ["proof (state)\nthis:\n  f' = (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z))\n\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "have \"f o (\\<lambda>t. 1 - t) = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (-) 1 = f'", "unfolding f_def f'_def comp_def reversepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Im (g (1 - x) - z) / Re (g (1 - x) - z)) =\n    (\\<lambda>t. Im (g (1 - t) - z) / Re (g (1 - t) - z))", "by auto"], ["proof (state)\nthis:\n  f \\<circ> (-) 1 = f'\n\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "then"], ["proof (chain)\npicking this:\n  f \\<circ> (-) 1 = f'", "have \"cindex 0 1 f' = - cindex 0 1 f\""], ["proof (prove)\nusing this:\n  f \\<circ> (-) 1 = f'\n\ngoal (1 subgoal):\n 1. cindex 0 1 f' = - cindex 0 1 f", "using cindex_linear_comp[of \"-1\" 0 1 f 1,simplified]"], ["proof (prove)\nusing this:\n  f \\<circ> (-) 1 = f'\n  cindex 0 1 (f \\<circ> (-) 1) = - cindex 0 1 f\n\ngoal (1 subgoal):\n 1. cindex 0 1 f' = - cindex 0 1 f", "by simp"], ["proof (state)\nthis:\n  cindex 0 1 f' = - cindex 0 1 f\n\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "then"], ["proof (chain)\npicking this:\n  cindex 0 1 f' = - cindex 0 1 f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex 0 1 f' = - cindex 0 1 f\n\ngoal (1 subgoal):\n 1. cindex_path (reversepath g) z = - cindex_path g z", "unfolding cindex_path_def"], ["proof (prove)\nusing this:\n  cindex 0 1 f' = - cindex 0 1 f\n\ngoal (1 subgoal):\n 1. cindex 0 1\n     (\\<lambda>t. Im (reversepath g t - z) / Re (reversepath g t - z)) =\n    - cindex 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z))", "apply (fold f_def f'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 1 f' = - cindex 0 1 f \\<Longrightarrow>\n    cindex 0 1 f' = - cindex 0 1 f", "by simp"], ["proof (state)\nthis:\n  cindex_path (reversepath g) z = - cindex_path g z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_pathE_reversepath: \"cindex_pathE (reversepath g) z = -cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (reversepath g) z = - cindex_pathE g z", "using cindexE_linear_comp[of \"-1\" 0 1 \"\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z)\" 1]"], ["proof (prove)\nusing this:\n  - 1 \\<noteq> 0 \\<Longrightarrow>\n  cindexE 0 1\n   ((\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z)) \\<circ>\n    (\\<lambda>x. - 1 * x + 1)) =\n  (if 0 < - 1\n   then cindexE (- 1 * 0 + 1) (- 1 * 1 + 1)\n         (\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z))\n   else - cindexE (- 1 * 1 + 1) (- 1 * 0 + 1)\n           (\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z)))\n\ngoal (1 subgoal):\n 1. cindex_pathE (reversepath g) z = - cindex_pathE g z", "by (simp add: cindex_pathE_def reversepath_def o_def)"], ["", "lemma cindex_pathE_reversepath': \"cindex_pathE g z = -cindex_pathE (reversepath g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = - cindex_pathE (reversepath g) z", "using cindexE_linear_comp[of \"-1\" 0 1 \"\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z)\" 1]"], ["proof (prove)\nusing this:\n  - 1 \\<noteq> 0 \\<Longrightarrow>\n  cindexE 0 1\n   ((\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z)) \\<circ>\n    (\\<lambda>x. - 1 * x + 1)) =\n  (if 0 < - 1\n   then cindexE (- 1 * 0 + 1) (- 1 * 1 + 1)\n         (\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z))\n   else - cindexE (- 1 * 1 + 1) (- 1 * 0 + 1)\n           (\\<lambda>t. (Im (g t) - Im z) / (Re (g t) - Re z)))\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = - cindex_pathE (reversepath g) z", "by (simp add: cindex_pathE_def reversepath_def o_def)"], ["", "lemma cindex_pathE_joinpaths:\n  assumes g1:\"finite_ReZ_segments g1 z\" and g2: \"finite_ReZ_segments g2 z\" and\n    \"path g1\" \"path g2\" \"pathfinish g1 = pathstart g2\"\n  shows \"cindex_pathE (g1+++g2) z = cindex_pathE g1 z + cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "define f where \"f = (\\<lambda>g (t::real). Im (g t - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>g t. Im (g t - z) / Re (g t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "have \"cindex_pathE (g1 +++ g2) z =  cindexE 0 1 (f (g1+++g2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindexE 0 1 (f (g1 +++ g2))", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) =\n    cindexE 0 1\n     (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (g1 +++ g2) z = cindexE 0 1 (f (g1 +++ g2))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "also"], ["proof (state)\nthis:\n  cindex_pathE (g1 +++ g2) z = cindexE 0 1 (f (g1 +++ g2))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "have \"... = cindexE 0 (1/2) (f (g1+++g2)) + cindexE (1/2) 1 (f (g1+++g2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f (g1 +++ g2)) =\n    cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2))", "proof (rule cindexE_combine)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite_jumpFs (f (g1 +++ g2)) 0 1\n 2. 0 \\<le> 1 / 2\n 3. 1 / 2 \\<le> 1", "show \"finite_jumpFs (f (g1 +++ g2)) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (f (g1 +++ g2)) 0 1", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs\n     (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) 0 1", "apply (rule finite_ReZ_segments_imp_jumpFs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite_ReZ_segments (g1 +++ g2) z\n 2. path (g1 +++ g2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "using finite_ReZ_segments_joinpaths[OF g1 g2] assms(3-5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g1; path g2; pathfinish g1 = pathstart g2\\<rbrakk>\n  \\<Longrightarrow> finite_ReZ_segments (g1 +++ g2) z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2) z", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. path (g1 +++ g2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (g1 +++ g2)", "using path_join_imp[OF \\<open>path g1\\<close> \\<open>path g2\\<close> \\<open>pathfinish g1=pathstart g2\\<close>]"], ["proof (prove)\nusing this:\n  path (g1 +++ g2)\n\ngoal (1 subgoal):\n 1. path (g1 +++ g2)", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite_jumpFs (f (g1 +++ g2)) 0 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> 1 / 2\n 2. 1 / 2 \\<le> 1", "qed auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f (g1 +++ g2)) =\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (f (g1 +++ g2)) =\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "have \"... = cindex_pathE g1 z + cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindex_pathE g1 z + cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindex_pathE g1 z + cindex_pathE g2 z", "have \"cindexE 0 (1/2) (f (g1+++g2)) = cindex_pathE g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "have \"cindexE 0 (1/2) (f (g1+++g2)) = cindexE 0 (1/2) (f g1 o ((*) 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) =\n    cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2)", "apply (rule cindexE_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>0 < x; x < 1 / 2; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> f (g1 +++ g2) x = (f g1 \\<circ> (*) 2) x", "unfolding comp_def joinpaths_def f_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>0 < x; x < 1 / 2; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> Im ((if x \\<le> 1 / 2 then g1 (2 * x)\n                              else g2 (2 * x - 1)) -\n                             z) /\n                         Re ((if x \\<le> 1 / 2 then g1 (2 * x)\n                              else g2 (2 * x - 1)) -\n                             z) =\n                         Im (g1 (2 * x) - z) / Re (g1 (2 * x) - z)", "by auto"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "also"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "have \"... = cindexE 0 1 (f g1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2) = cindexE 0 1 (f g1)", "using cindexE_linear_comp[of 2 0 \"1/2\" _ 0,simplified]"], ["proof (prove)\nusing this:\n  cindexE 0 (1 / 2) (?f \\<circ> (*) 2) = cindexE 0 1 ?f\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2) = cindexE 0 1 (f g1)", "by simp"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2) = cindexE 0 1 (f g1)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "also"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f g1 \\<circ> (*) 2) = cindexE 0 1 (f g1)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "have \"... = cindex_pathE g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f g1) = cindex_pathE g1 z", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) =\n    cindexE 0 1 (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z))", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f g1) = cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "finally"], ["proof (chain)\npicking this:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z", "."], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindex_pathE g1 z + cindex_pathE g2 z", "moreover"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindex_pathE g1 z + cindex_pathE g2 z", "have \"cindexE (1/2) 1 (f (g1+++g2)) = cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "have \"cindexE (1/2) 1 (f (g1+++g2)) = cindexE (1/2) 1 (f g2 o (\\<lambda>x. 2*x  - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1))", "apply (rule cindexE_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>1 / 2 < x; x < 1; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> f (g1 +++ g2) x =\n                         (f g2 \\<circ> (\\<lambda>x. 2 * x - 1)) x", "unfolding comp_def joinpaths_def f_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>1 / 2 < x; x < 1; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> Im ((if x \\<le> 1 / 2 then g1 (2 * x)\n                              else g2 (2 * x - 1)) -\n                             z) /\n                         Re ((if x \\<le> 1 / 2 then g1 (2 * x)\n                              else g2 (2 * x - 1)) -\n                             z) =\n                         Im (g2 (2 * x - 1) - z) / Re (g2 (2 * x - 1) - z)", "by auto"], ["proof (state)\nthis:\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n  cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1))\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "also"], ["proof (state)\nthis:\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n  cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1))\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "have \"... = cindexE 0 1 (f g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1)) =\n    cindexE 0 1 (f g2)", "using cindexE_linear_comp[of 2 \"1/2\" 1 _ \"-1\",simplified]"], ["proof (prove)\nusing this:\n  cindexE (1 / 2) 1 (?f \\<circ> (\\<lambda>x. 2 * x - 1)) = cindexE 0 1 ?f\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1)) =\n    cindexE 0 1 (f g2)", "by simp"], ["proof (state)\nthis:\n  cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1)) =\n  cindexE 0 1 (f g2)\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "also"], ["proof (state)\nthis:\n  cindexE (1 / 2) 1 (f g2 \\<circ> (\\<lambda>x. 2 * x - 1)) =\n  cindexE 0 1 (f g2)\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "have \"... = cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f g2) = cindex_pathE g2 z", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) =\n    cindexE 0 1 (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z))", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f g2) = cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "finally"], ["proof (chain)\npicking this:\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "."], ["proof (state)\nthis:\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindex_pathE g1 z + cindex_pathE g2 z", "ultimately"], ["proof (chain)\npicking this:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) = cindex_pathE g1 z\n  cindexE (1 / 2) 1 (f (g1 +++ g2)) = cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n    cindex_pathE g1 z + cindex_pathE g2 z", "by simp"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n  cindex_pathE g1 z + cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 (1 / 2) (f (g1 +++ g2)) + cindexE (1 / 2) 1 (f (g1 +++ g2)) =\n  cindex_pathE g1 z + cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z", "."], ["proof (state)\nthis:\n  cindex_pathE (g1 +++ g2) z = cindex_pathE g1 z + cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_pathE_constI:\n  assumes \"\\<And>t. \\<lbrakk>0<t;t<1\\<rbrakk> \\<Longrightarrow> g t=c\"\n  shows \"cindex_pathE g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z)) = 0", "apply (rule cindexE_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Im (g t - z) / Re (g t - z) = ?c", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk> \\<Longrightarrow> g ?t = c\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Im (g t - z) / Re (g t - z) = ?c", "by auto"], ["", "lemma cindex_pathE_subpath_combine:\n  assumes g:\"finite_ReZ_segments g z\"and \"path g\" and\n     \"0\\<le>a\" \"a\\<le>b\" \"b\\<le>c\" \"c\\<le>1\"\n  shows \"cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z \n          = cindex_pathE (subpath a c g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "define f where \"f = (\\<lambda>t. Im (g t - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (g t - z) / Re (g t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have ?thesis when \"a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have \"cindex_pathE (subpath a b g) z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = 0", "apply (rule cindex_pathE_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk> \\<Longrightarrow> subpath a b g t = ?c", "using that"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk> \\<Longrightarrow> subpath a b g t = ?c", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> g ((b - a) * t + a) = ?c", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "then"], ["proof (chain)\npicking this:\n  cindex_pathE (subpath a b g) z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath a b g) z = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "using that"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath a b g) z = 0\n  a = b\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "moreover"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have ?thesis when \"b=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have \"cindex_pathE (subpath b c g) z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = 0", "apply (rule cindex_pathE_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk> \\<Longrightarrow> subpath b c g t = ?c", "using that"], ["proof (prove)\nusing this:\n  b = c\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk> \\<Longrightarrow> subpath b c g t = ?c", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  b = c\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> g ((c - b) * t + b) = ?c", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath b c g) z = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "then"], ["proof (chain)\npicking this:\n  cindex_pathE (subpath b c g) z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath b c g) z = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "using that"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath b c g) z = 0\n  b = c\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = c \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "moreover"], ["proof (state)\nthis:\n  b = c \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have ?thesis when \"a\\<noteq>b\" \"b\\<noteq>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have  [simp]:\"a<b\" \"b<c\" \"a<c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b &&& b < c &&& a < c", "using that \\<open>a\\<le>b\\<close> \\<open>b\\<le>c\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  b \\<noteq> c\n  a \\<le> b\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. a < b &&& b < c &&& a < c", "by auto"], ["proof (state)\nthis:\n  a < b\n  b < c\n  a < c\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have \"cindex_pathE (subpath a b g) z = cindexE a b f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = cindexE a b f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = cindexE a b f", "have \"cindex_pathE (subpath a b g) z = cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a))", "unfolding cindex_pathE_def f_def comp_def subpath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t.\n         Im (g ((b - a) * t + a) - z) / Re (g ((b - a) * t + a) - z)) =\n    cindexE 0 1\n     (\\<lambda>x.\n         Im (g ((b - a) * x + a) - z) / Re (g ((b - a) * x + a) - z))", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = cindexE a b f", "also"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = cindexE a b f", "have \"... =  cindexE a b f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a)) = cindexE a b f", "using cindexE_linear_comp[of \"b-a\" 0 1 f a,simplified] that(1)"], ["proof (prove)\nusing this:\n  b \\<noteq> a \\<Longrightarrow>\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a)) = cindexE a b f\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a)) = cindexE a b f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (b - a) * x + a)) = cindexE a b f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = cindexE a b f", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (subpath a b g) z = cindexE a b f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath a b g) z = cindexE a b f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z = cindexE a b f", "."], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z = cindexE a b f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z = cindexE a b f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z = cindexE a b f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have \"cindex_pathE (subpath b c g) z = cindexE b c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = cindexE b c f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = cindexE b c f", "have \"cindex_pathE (subpath b c g) z = cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b))", "unfolding cindex_pathE_def f_def comp_def subpath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t.\n         Im (g ((c - b) * t + b) - z) / Re (g ((c - b) * t + b) - z)) =\n    cindexE 0 1\n     (\\<lambda>x.\n         Im (g ((c - b) * x + b) - z) / Re (g ((c - b) * x + b) - z))", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath b c g) z =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = cindexE b c f", "also"], ["proof (state)\nthis:\n  cindex_pathE (subpath b c g) z =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = cindexE b c f", "have \"... =  cindexE b c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b)) = cindexE b c f", "using cindexE_linear_comp[of \"c-b\" 0 1 f b,simplified] that(2)"], ["proof (prove)\nusing this:\n  c \\<noteq> b \\<Longrightarrow>\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b)) = cindexE b c f\n  b \\<noteq> c\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b)) = cindexE b c f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - b) * x + b)) = cindexE b c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = cindexE b c f", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (subpath b c g) z = cindexE b c f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath b c g) z = cindexE b c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath b c g) z = cindexE b c f", "."], ["proof (state)\nthis:\n  cindex_pathE (subpath b c g) z = cindexE b c f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (subpath b c g) z = cindexE b c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (subpath b c g) z = cindexE b c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have \"cindex_pathE (subpath a c g) z = cindexE a c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z = cindexE a c f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z = cindexE a c f", "have \"cindex_pathE (subpath a c g) z = cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a))", "unfolding cindex_pathE_def f_def comp_def subpath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t.\n         Im (g ((c - a) * t + a) - z) / Re (g ((c - a) * t + a) - z)) =\n    cindexE 0 1\n     (\\<lambda>x.\n         Im (g ((c - a) * x + a) - z) / Re (g ((c - a) * x + a) - z))", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath a c g) z =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z = cindexE a c f", "also"], ["proof (state)\nthis:\n  cindex_pathE (subpath a c g) z =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a))\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z = cindexE a c f", "have \"... =  cindexE a c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a)) = cindexE a c f", "using cindexE_linear_comp[of \"c-a\" 0 1 f a,simplified] \\<open>a<c\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> a \\<Longrightarrow>\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a)) = cindexE a c f\n  a < c\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a)) = cindexE a c f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (c - a) * x + a)) = cindexE a c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z = cindexE a c f", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (subpath a c g) z = cindexE a c f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath a c g) z = cindexE a c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a c g) z = cindexE a c f", "."], ["proof (state)\nthis:\n  cindex_pathE (subpath a c g) z = cindexE a c f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (subpath a c g) z = cindexE a c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (subpath a c g) z = cindexE a c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "have \"cindexE a b f + cindexE b c f = cindexE a c f \""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b f + cindexE b c f = cindexE a c f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE a b f + cindexE b c f = cindexE a c f", "have \"finite_jumpFs f a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "using finite_ReZ_segments_imp_jumpFs[OF g \\<open>path g\\<close>] \\<open>0\\<le>a\\<close> \\<open>c\\<le>1\\<close>"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1\n  0 \\<le> a\n  c \\<le> 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs f a c", "unfolding f_def"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1\n  0 \\<le> a\n  c \\<le> 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) a c", "by (elim finite_jumpFs_subE,auto)"], ["proof (state)\nthis:\n  finite_jumpFs f a c\n\ngoal (1 subgoal):\n 1. cindexE a b f + cindexE b c f = cindexE a c f", "then"], ["proof (chain)\npicking this:\n  finite_jumpFs f a c", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_jumpFs f a c\n\ngoal (1 subgoal):\n 1. cindexE a b f + cindexE b c f = cindexE a c f", "using cindexE_linear_comp cindexE_combine[OF _ \\<open>a\\<le>b\\<close> \\<open>b\\<le>c\\<close>]"], ["proof (prove)\nusing this:\n  finite_jumpFs f a c\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  cindexE ?lb ?ub (?f \\<circ> (\\<lambda>x. ?c * x + ?b)) =\n  (if 0 < ?c then cindexE (?c * ?lb + ?b) (?c * ?ub + ?b) ?f\n   else - cindexE (?c * ?ub + ?b) (?c * ?lb + ?b) ?f)\n  finite_jumpFs ?f a c \\<Longrightarrow>\n  cindexE a c ?f = cindexE a b ?f + cindexE b c ?f\n\ngoal (1 subgoal):\n 1. cindexE a b f + cindexE b c f = cindexE a c f", "by auto"], ["proof (state)\nthis:\n  cindexE a b f + cindexE b c f = cindexE a c f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE a b f + cindexE b c f = cindexE a c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (subpath a b g) z = cindexE a b f\n  cindex_pathE (subpath b c g) z = cindexE b c f\n  cindex_pathE (subpath a c g) z = cindexE a c f\n  cindexE a b f + cindexE b c f = cindexE a c f", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (subpath a b g) z = cindexE a b f\n  cindex_pathE (subpath b c g) z = cindexE b c f\n  cindex_pathE (subpath a c g) z = cindexE a c f\n  cindexE a b f + cindexE b c f = cindexE a c f\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> b; b \\<noteq> c\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (subpath a b g) z +\n                    cindex_pathE (subpath b c g) z =\n                    cindex_pathE (subpath a c g) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "ultimately"], ["proof (chain)\npicking this:\n  a = b \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n  b = c \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n  \\<lbrakk>a \\<noteq> b; b \\<noteq> c\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (subpath a b g) z +\n                    cindex_pathE (subpath b c g) z =\n                    cindex_pathE (subpath a c g) z", "show ?thesis"], ["proof (prove)\nusing this:\n  a = b \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n  b = c \\<Longrightarrow>\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n  \\<lbrakk>a \\<noteq> b; b \\<noteq> c\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (subpath a b g) z +\n                    cindex_pathE (subpath b c g) z =\n                    cindex_pathE (subpath a c g) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n    cindex_pathE (subpath a c g) z", "by blast"], ["proof (state)\nthis:\n  cindex_pathE (subpath a b g) z + cindex_pathE (subpath b c g) z =\n  cindex_pathE (subpath a c g) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_pathE_shiftpath:\n  assumes \"finite_ReZ_segments g z\" \"s\\<in>{0..1}\" \"path g\" and loop:\"pathfinish g = pathstart g\"\n  shows \"cindex_pathE (shiftpath s g) z = cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "define f where \"f=(\\<lambda>g t. Im (g (t::real) - z) / Re (g t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>g t. Im (g t - z) / Re (g t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "have \"cindex_pathE (shiftpath s g) z = cindexE 0 1 (f (shiftpath s g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindexE 0 1 (f (shiftpath s g))", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (shiftpath s g t - z) / Re (shiftpath s g t - z)) =\n    cindexE 0 1\n     (\\<lambda>t. Im (shiftpath s g t - z) / Re (shiftpath s g t - z))", "by simp"], ["proof (state)\nthis:\n  cindex_pathE (shiftpath s g) z = cindexE 0 1 (f (shiftpath s g))\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "also"], ["proof (state)\nthis:\n  cindex_pathE (shiftpath s g) z = cindexE 0 1 (f (shiftpath s g))\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "have \"... = cindexE 0 (1-s) (f (shiftpath s g)) + cindexE (1-s) 1 (f (shiftpath s g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f (shiftpath s g)) =\n    cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g))", "proof (rule cindexE_combine)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite_jumpFs (f (shiftpath s g)) 0 1\n 2. 0 \\<le> 1 - s\n 3. 1 - s \\<le> 1", "have \"finite_ReZ_segments (shiftpath s g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "using finite_ReZ_segments_shiftpah[OF assms]"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (shiftpath s g) z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "."], ["proof (state)\nthis:\n  finite_ReZ_segments (shiftpath s g) z\n\ngoal (3 subgoals):\n 1. finite_jumpFs (f (shiftpath s g)) 0 1\n 2. 0 \\<le> 1 - s\n 3. 1 - s \\<le> 1", "from finite_ReZ_segments_imp_jumpFs[OF this] path_shiftpath[OF \\<open>path g\\<close> loop \\<open>s\\<in>{0..1}\\<close>]"], ["proof (chain)\npicking this:\n  path (shiftpath s g) \\<Longrightarrow>\n  finite_jumpFs\n   (\\<lambda>t. Im (shiftpath s g t - z) / Re (shiftpath s g t - z)) 0 1\n  path (shiftpath s g)", "show \"finite_jumpFs (f (shiftpath s g)) 0 1\""], ["proof (prove)\nusing this:\n  path (shiftpath s g) \\<Longrightarrow>\n  finite_jumpFs\n   (\\<lambda>t. Im (shiftpath s g t - z) / Re (shiftpath s g t - z)) 0 1\n  path (shiftpath s g)\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f (shiftpath s g)) 0 1", "unfolding f_def"], ["proof (prove)\nusing this:\n  path (shiftpath s g) \\<Longrightarrow>\n  finite_jumpFs\n   (\\<lambda>t. Im (shiftpath s g t - z) / Re (shiftpath s g t - z)) 0 1\n  path (shiftpath s g)\n\ngoal (1 subgoal):\n 1. finite_jumpFs\n     (\\<lambda>t. Im (shiftpath s g t - z) / Re (shiftpath s g t - z)) 0 1", "by simp"], ["proof (state)\nthis:\n  finite_jumpFs (f (shiftpath s g)) 0 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> 1 - s\n 2. 1 - s \\<le> 1", "show \"0 \\<le> 1 - s\" \"1 - s \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 - s &&& 1 - s \\<le> 1", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 - s &&& 1 - s \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 1 - s\n  1 - s \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 1 (f (shiftpath s g)) =\n  cindexE 0 (1 - s) (f (shiftpath s g)) +\n  cindexE (1 - s) 1 (f (shiftpath s g))\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (f (shiftpath s g)) =\n  cindexE 0 (1 - s) (f (shiftpath s g)) +\n  cindexE (1 - s) 1 (f (shiftpath s g))\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "have \"... = cindexE 0 s (f g) + cindexE s 1 (f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE 0 s (f g) + cindexE s 1 (f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE 0 s (f g) + cindexE s 1 (f g)", "have \"cindexE 0 (1-s) (f (shiftpath s g)) = cindexE s 1 (f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "have \"cindexE 0 (1-s) (f (shiftpath s g)) = cindexE 0 (1-s) ((f g) o (\\<lambda>t. t+s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) =\n    cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>t. t + s))", "apply (rule cindexE_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>0 < x; x < 1 - s; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> f (shiftpath s g) x =\n                         (f g \\<circ> (\\<lambda>t. t + s)) x", "unfolding shiftpath_def f_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>0 < x; x < 1 - s; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> Im ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) /\n                         Re ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) =\n                         ((\\<lambda>t. Im (g t - z) / Re (g t - z)) \\<circ>\n                          (\\<lambda>t. t + s))\n                          x", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>0 < x; x < 1 - s; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> Im ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) /\n                         Re ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) =\n                         ((\\<lambda>t. Im (g t - z) / Re (g t - z)) \\<circ>\n                          (\\<lambda>t. t + s))\n                          x", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) =\n  cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>t. t + s))\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "also"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) =\n  cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>t. t + s))\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "have \"...= cindexE s 1 (f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>t. t + s)) = cindexE s 1 (f g)", "using cindexE_linear_comp[of 1 0 \"1-s\" \"f g\" s,simplified]"], ["proof (prove)\nusing this:\n  cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>x. x + s)) = cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>t. t + s)) = cindexE s 1 (f g)", "."], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f g \\<circ> (\\<lambda>t. t + s)) = cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "finally"], ["proof (chain)\npicking this:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)", "."], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE 0 s (f g) + cindexE s 1 (f g)", "moreover"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE 0 s (f g) + cindexE s 1 (f g)", "have \"cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "have \"cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE (1-s) 1 ((f g) o (\\<lambda>t. t+s-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>t. t + s - 1))", "apply (rule cindexE_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>1 - s < x; x < 1; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> f (shiftpath s g) x =\n                         (f g \\<circ> (\\<lambda>t. t + s - 1)) x", "unfolding shiftpath_def f_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>1 - s < x; x < 1; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> Im ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) /\n                         Re ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) =\n                         ((\\<lambda>t. Im (g t - z) / Re (g t - z)) \\<circ>\n                          (\\<lambda>t. t + s - 1))\n                          x", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. finite ?s\n 2. \\<And>x.\n       \\<lbrakk>1 - s < x; x < 1; x \\<notin> ?s\\<rbrakk>\n       \\<Longrightarrow> Im ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) /\n                         Re ((if s + x \\<le> 1 then g (s + x)\n                              else g (s + x - 1)) -\n                             z) =\n                         ((\\<lambda>t. Im (g t - z) / Re (g t - z)) \\<circ>\n                          (\\<lambda>t. t + s - 1))\n                          x", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindexE (1 - s) 1 (f (shiftpath s g)) =\n  cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>t. t + s - 1))\n\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "also"], ["proof (state)\nthis:\n  cindexE (1 - s) 1 (f (shiftpath s g)) =\n  cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>t. t + s - 1))\n\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "have \"... = cindexE 0 s (f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>t. t + s - 1)) =\n    cindexE 0 s (f g)", "using cindexE_linear_comp[of 1 \"1-s\" 1 \"f g\" \"s-1\",simplified]"], ["proof (prove)\nusing this:\n  cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>x. x + (s - 1))) =\n  cindexE 0 s (f g)\n\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>t. t + s - 1)) =\n    cindexE 0 s (f g)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindexE (1 - s) 1 (f g \\<circ> (\\<lambda>t. t + s - 1)) =\n  cindexE 0 s (f g)\n\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "finally"], ["proof (chain)\npicking this:\n  cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)\n\ngoal (1 subgoal):\n 1. cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "."], ["proof (state)\nthis:\n  cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE 0 s (f g) + cindexE s 1 (f g)", "ultimately"], ["proof (chain)\npicking this:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)\n  cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE 0 (1 - s) (f (shiftpath s g)) = cindexE s 1 (f g)\n  cindexE (1 - s) 1 (f (shiftpath s g)) = cindexE 0 s (f g)\n\ngoal (1 subgoal):\n 1. cindexE 0 (1 - s) (f (shiftpath s g)) +\n    cindexE (1 - s) 1 (f (shiftpath s g)) =\n    cindexE 0 s (f g) + cindexE s 1 (f g)", "by auto"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) +\n  cindexE (1 - s) 1 (f (shiftpath s g)) =\n  cindexE 0 s (f g) + cindexE s 1 (f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) +\n  cindexE (1 - s) 1 (f (shiftpath s g)) =\n  cindexE 0 s (f g) + cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "also"], ["proof (state)\nthis:\n  cindexE 0 (1 - s) (f (shiftpath s g)) +\n  cindexE (1 - s) 1 (f (shiftpath s g)) =\n  cindexE 0 s (f g) + cindexE s 1 (f g)\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "have \"... = cindexE 0 1 (f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 s (f g) + cindexE s 1 (f g) = cindexE 0 1 (f g)", "proof (rule cindexE_combine[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. finite_jumpFs (f g) 0 1\n 2. 0 \\<le> s\n 3. s \\<le> 1", "show \"finite_jumpFs (f g) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs (f g) 0 1", "using finite_ReZ_segments_imp_jumpFs[OF assms(1,3)]"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs (f g) 0 1", "unfolding f_def"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. Im (g t - z) / Re (g t - z)) 0 1", "by simp"], ["proof (state)\nthis:\n  finite_jumpFs (f g) 0 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> s\n 2. s \\<le> 1", "show \"0 \\<le> s\" \"s\\<le>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s &&& s \\<le> 1", "using \\<open>s\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> s &&& s \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> s\n  s \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 s (f g) + cindexE s 1 (f g) = cindexE 0 1 (f g)\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "also"], ["proof (state)\nthis:\n  cindexE 0 s (f g) + cindexE s 1 (f g) = cindexE 0 1 (f g)\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "have \"... = cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f g) = cindex_pathE g z", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z)) =\n    cindexE 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z))", "by simp"], ["proof (state)\nthis:\n  cindexE 0 1 (f g) = cindex_pathE g z\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (shiftpath s g) z = cindex_pathE g z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (shiftpath s g) z = cindex_pathE g z\n\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "."], ["proof (state)\nthis:\n  cindex_pathE (shiftpath s g) z = cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cauchy's Index Theorem\\<close>"], ["", "theorem winding_number_cindex_pathE_aux:\n  fixes g::\"real \\<Rightarrow> complex\"\n  assumes \"finite_ReZ_segments g z\" and \"valid_path g\" \"z \\<notin> path_image g\" and\n    Re_ends:\"Re (g 1) = Re z\" \"Re (g 0) = Re z\"\n  shows \"2 * Re(winding_number g z) = - cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "using assms"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  valid_path g\n  z \\<notin> path_image g\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof (induct rule:finite_ReZ_segments_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g z.\n       \\<lbrakk>valid_path (subpath 0 0 g);\n        z \\<notin> path_image (subpath 0 0 g); Re (subpath 0 0 g 1) = Re z;\n        Re (subpath 0 0 g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number (subpath 0 0 g) z) =\n                         - cindex_pathE (subpath 0 0 g) z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 3. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "case (sub0 g z)"], ["proof (state)\nthis:\n  valid_path (subpath 0 0 g)\n  z \\<notin> path_image (subpath 0 0 g)\n  Re (subpath 0 0 g 1) = Re z\n  Re (subpath 0 0 g 0) = Re z\n\ngoal (3 subgoals):\n 1. \\<And>g z.\n       \\<lbrakk>valid_path (subpath 0 0 g);\n        z \\<notin> path_image (subpath 0 0 g); Re (subpath 0 0 g 1) = Re z;\n        Re (subpath 0 0 g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number (subpath 0 0 g) z) =\n                         - cindex_pathE (subpath 0 0 g) z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 3. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"winding_number (subpath 0 0 g) z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (subpath 0 0 g) z = 0", "using \\<open>z \\<notin> path_image (subpath 0 0 g)\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image (subpath 0 0 g)\n\ngoal (1 subgoal):\n 1. winding_number (subpath 0 0 g) z = 0", "unfolding subpath_refl"], ["proof (prove)\nusing this:\n  z \\<notin> path_image (linepath (g 0) (g 0))\n\ngoal (1 subgoal):\n 1. winding_number (linepath (g 0) (g 0)) z = 0", "by (auto intro!: winding_number_trivial)"], ["proof (state)\nthis:\n  winding_number (subpath 0 0 g) z = 0\n\ngoal (3 subgoals):\n 1. \\<And>g z.\n       \\<lbrakk>valid_path (subpath 0 0 g);\n        z \\<notin> path_image (subpath 0 0 g); Re (subpath 0 0 g 1) = Re z;\n        Re (subpath 0 0 g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number (subpath 0 0 g) z) =\n                         - cindex_pathE (subpath 0 0 g) z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 3. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  winding_number (subpath 0 0 g) z = 0\n\ngoal (3 subgoals):\n 1. \\<And>g z.\n       \\<lbrakk>valid_path (subpath 0 0 g);\n        z \\<notin> path_image (subpath 0 0 g); Re (subpath 0 0 g 1) = Re z;\n        Re (subpath 0 0 g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number (subpath 0 0 g) z) =\n                         - cindex_pathE (subpath 0 0 g) z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 3. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"cindex_pathE (subpath 0 0 g) z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (subpath 0 0 g) z = 0", "unfolding subpath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (\\<lambda>x. g ((0 - 0) * x + 0)) z = 0", "by (auto intro:cindex_pathE_constI)"], ["proof (state)\nthis:\n  cindex_pathE (subpath 0 0 g) z = 0\n\ngoal (3 subgoals):\n 1. \\<And>g z.\n       \\<lbrakk>valid_path (subpath 0 0 g);\n        z \\<notin> path_image (subpath 0 0 g); Re (subpath 0 0 g 1) = Re z;\n        Re (subpath 0 0 g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number (subpath 0 0 g) z) =\n                         - cindex_pathE (subpath 0 0 g) z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 3. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  winding_number (subpath 0 0 g) z = 0\n  cindex_pathE (subpath 0 0 g) z = 0", "show ?case"], ["proof (prove)\nusing this:\n  winding_number (subpath 0 0 g) z = 0\n  cindex_pathE (subpath 0 0 g) z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (subpath 0 0 g) z) =\n    - cindex_pathE (subpath 0 0 g) z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number (subpath 0 0 g) z) =\n  - cindex_pathE (subpath 0 0 g) z\n\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "case (subEq s g z)"], ["proof (state)\nthis:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s) = Re z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\n  finite_ReZ_segments (subpath 0 s g) z\n  \\<lbrakk>valid_path (subpath 0 s g);\n   z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n   Re (subpath 0 s g 0) = Re z\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                    - cindex_pathE (subpath 0 s g) z\n  valid_path g\n  z \\<notin> path_image g\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have Re_winding_0:\"Re(winding_number h z) = 0\" \n    when Re_const:\"\\<forall>t\\<in>{0..1}. Re (h t) = Re z\" and \"valid_path h\" \"z\\<notin>path_image h\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "have \"Re (winding_number (\\<lambda>t. h t - z) 0) = (Im (Ln (pathfinish (\\<lambda>t. h t - z))) \n              - Im (Ln (pathstart (\\<lambda>t. h t - z)))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (\\<lambda>t. h t - z) 0) =\n    (Im (Ln (pathfinish (\\<lambda>t. h t - z))) -\n     Im (Ln (pathstart (\\<lambda>t. h t - z)))) /\n    (2 * pi)", "apply (rule Re_winding_number_half_right[of _ 0,simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. h t - z). 0 \\<le> Re p\n 2. valid_path (\\<lambda>t. h t - z)\n 3. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "using Re_const \\<open>valid_path h\\<close> \\<open>z \\<notin> path_image h\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n  valid_path h\n  z \\<notin> path_image h\n\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image (\\<lambda>t. h t - z). 0 \\<le> Re p\n 2. valid_path (\\<lambda>t. h t - z)\n 3. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>t\\<in>{0..1}. Re (h t) = Re z; valid_path h;\n        z \\<notin> path_image h; p + z \\<in> path_image h\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> Re p", "by (metis (no_types, hide_lams) add.commute imageE le_add_same_cancel1 order_refl \n            path_image_def plus_complex.simps(1))"], ["proof (state)\nthis:\n  Re (winding_number (\\<lambda>t. h t - z) 0) =\n  (Im (Ln (pathfinish (\\<lambda>t. h t - z))) -\n   Im (Ln (pathstart (\\<lambda>t. h t - z)))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "moreover"], ["proof (state)\nthis:\n  Re (winding_number (\\<lambda>t. h t - z) 0) =\n  (Im (Ln (pathfinish (\\<lambda>t. h t - z))) -\n   Im (Ln (pathstart (\\<lambda>t. h t - z)))) /\n  (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "have \"Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "define z0 where \"z0 = h 0 - z\""], ["proof (state)\nthis:\n  z0 = h 0 - z\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "define z1 where \"z1 = h 1 - z\""], ["proof (state)\nthis:\n  z1 = h 1 - z\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "have [simp]: \"z0\\<noteq>0\" \"z1\\<noteq>0\" \"Re z0=0\" \"Re z1=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z0 \\<noteq> 0 &&& z1 \\<noteq> 0) &&& Re z0 = 0 &&& Re z1 = 0", "using \\<open>z \\<notin> path_image h\\<close> that(1)"], ["proof (prove)\nusing this:\n  z \\<notin> path_image h\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n\ngoal (1 subgoal):\n 1. (z0 \\<noteq> 0 &&& z1 \\<noteq> 0) &&& Re z0 = 0 &&& Re z1 = 0", "unfolding z1_def z0_def path_image_def"], ["proof (prove)\nusing this:\n  z \\<notin> h ` {0..1}\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n\ngoal (1 subgoal):\n 1. (h 0 - z \\<noteq> 0 &&& h 1 - z \\<noteq> 0) &&&\n    Re (h 0 - z) = 0 &&& Re (h 1 - z) = 0", "by auto"], ["proof (state)\nthis:\n  z0 \\<noteq> 0\n  z1 \\<noteq> 0\n  Re z0 = 0\n  Re z1 = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "have ?thesis when [simp]: \"Im z0>0\" \"Im z1>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "apply (fold z1_def z0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln z1) = Im (Ln z0)", "using Im_Ln_eq_pi_half[of z1] Im_Ln_eq_pi_half[of z0]"], ["proof (prove)\nusing this:\n  z1 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z1) = pi / 2) = (0 < Im z1 \\<and> Re z1 = 0)\n  z1 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z1) = - pi / 2) = (Im z1 < 0 \\<and> Re z1 = 0)\n  z0 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z0) = pi / 2) = (0 < Im z0 \\<and> Re z0 = 0)\n  z0 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z0) = - pi / 2) = (Im z0 < 0 \\<and> Re z0 = 0)\n\ngoal (1 subgoal):\n 1. Im (Ln z1) = Im (Ln z0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < Im z0; 0 < Im z1\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < Im z0; 0 < Im z1\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "have ?thesis when [simp]: \"Im z0<0\" \"Im z1<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "apply (fold z1_def z0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln z1) = Im (Ln z0)", "using Im_Ln_eq_pi_half[of z1] Im_Ln_eq_pi_half[of z0]"], ["proof (prove)\nusing this:\n  z1 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z1) = pi / 2) = (0 < Im z1 \\<and> Re z1 = 0)\n  z1 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z1) = - pi / 2) = (Im z1 < 0 \\<and> Re z1 = 0)\n  z0 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z0) = pi / 2) = (0 < Im z0 \\<and> Re z0 = 0)\n  z0 \\<noteq> 0 \\<Longrightarrow>\n  (Im (Ln z0) = - pi / 2) = (Im z0 < 0 \\<and> Re z0 = 0)\n\ngoal (1 subgoal):\n 1. Im (Ln z1) = Im (Ln z0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>Im z0 < 0; Im z1 < 0\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Im z0 < 0; Im z1 < 0\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "have False when \"Im z0\\<ge>0\" \"Im z1\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define f where \"f=(\\<lambda>t. Im (h t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (h t - z))\n\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0", "apply (rule IVT2'[of f 1 0 0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. f 1 \\<le> 0\n 2. 0 \\<le> f 0\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} f", "using that valid_path_imp_path[OF \\<open>valid_path h\\<close>]"], ["proof (prove)\nusing this:\n  0 \\<le> Im z0\n  Im z1 \\<le> 0\n  path h\n\ngoal (4 subgoals):\n 1. f 1 \\<le> 0\n 2. 0 \\<le> f 0\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} f", "unfolding f_def z0_def z1_def path_def"], ["proof (prove)\nusing this:\n  0 \\<le> Im (h 0 - z)\n  Im (h 1 - z) \\<le> 0\n  continuous_on {0..1} h\n\ngoal (4 subgoals):\n 1. Im (h 1 - z) \\<le> 0\n 2. 0 \\<le> Im (h 0 - z)\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} (\\<lambda>t. Im (h t - z))", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "using Re_const  \\<open>z \\<notin> path_image h\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> Im (h x - z) = 0\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. False", "by (metis atLeastAtMost_iff complex_surj image_eqI minus_complex.simps(2) \n                path_defs(4) right_minus_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> Im z0; Im z1 \\<le> 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> Im z0; Im z1 \\<le> 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "have False when \"Im z0\\<le>0\" \"Im z1\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define f where \"f=(\\<lambda>t. Im (h t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (h t - z))\n\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0", "apply (rule IVT')"], ["proof (prove)\ngoal (4 subgoals):\n 1. f 0 \\<le> 0\n 2. 0 \\<le> f 1\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} f", "using that valid_path_imp_path[OF \\<open>valid_path h\\<close>]"], ["proof (prove)\nusing this:\n  Im z0 \\<le> 0\n  0 \\<le> Im z1\n  path h\n\ngoal (4 subgoals):\n 1. f 0 \\<le> 0\n 2. 0 \\<le> f 1\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} f", "unfolding f_def z0_def z1_def path_def"], ["proof (prove)\nusing this:\n  Im (h 0 - z) \\<le> 0\n  0 \\<le> Im (h 1 - z)\n  continuous_on {0..1} h\n\ngoal (4 subgoals):\n 1. Im (h 0 - z) \\<le> 0\n 2. 0 \\<le> Im (h 1 - z)\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} (\\<lambda>x. Im (h x - z))", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "using Re_const \\<open>z \\<notin> path_image h\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> f x = 0\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> 1 \\<and> Im (h x - z) = 0\n  \\<forall>t\\<in>{0..1}. Re (h t) = Re z\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. False", "by (metis atLeastAtMost_iff complex_surj image_eqI minus_complex.simps(2) \n                path_defs(4) right_minus_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Im z0 \\<le> 0; 0 \\<le> Im z1\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < Im z0; 0 < Im z1\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n  \\<lbrakk>Im z0 < 0; Im z1 < 0\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n  \\<lbrakk>0 \\<le> Im z0; Im z1 \\<le> 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>Im z0 \\<le> 0; 0 \\<le> Im z1\\<rbrakk> \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < Im z0; 0 < Im z1\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n  \\<lbrakk>Im z0 < 0; Im z1 < 0\\<rbrakk>\n  \\<Longrightarrow> Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n  \\<lbrakk>0 \\<le> Im z0; Im z1 \\<le> 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>Im z0 \\<le> 0; 0 \\<le> Im z1\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "by argo"], ["proof (state)\nthis:\n  Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number (\\<lambda>t. h t - z) 0) =\n  (Im (Ln (pathfinish (\\<lambda>t. h t - z))) -\n   Im (Ln (pathstart (\\<lambda>t. h t - z)))) /\n  (2 * pi)\n  Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))", "have \"Re (winding_number (\\<lambda>t. h t - z) 0) = 0\""], ["proof (prove)\nusing this:\n  Re (winding_number (\\<lambda>t. h t - z) 0) =\n  (Im (Ln (pathfinish (\\<lambda>t. h t - z))) -\n   Im (Ln (pathstart (\\<lambda>t. h t - z)))) /\n  (2 * pi)\n  Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Re (winding_number (\\<lambda>t. h t - z) 0) = 0", "unfolding pathfinish_def pathstart_def"], ["proof (prove)\nusing this:\n  Re (winding_number (\\<lambda>t. h t - z) 0) =\n  (Im (Ln (h 1 - z)) - Im (Ln (h 0 - z))) / (2 * pi)\n  Im (Ln (h 1 - z)) = Im (Ln (h 0 - z))\n\ngoal (1 subgoal):\n 1. Re (winding_number (\\<lambda>t. h t - z) 0) = 0", "by auto"], ["proof (state)\nthis:\n  Re (winding_number (\\<lambda>t. h t - z) 0) = 0\n\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "then"], ["proof (chain)\npicking this:\n  Re (winding_number (\\<lambda>t. h t - z) 0) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number (\\<lambda>t. h t - z) 0) = 0\n\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "using winding_number_offset"], ["proof (prove)\nusing this:\n  Re (winding_number (\\<lambda>t. h t - z) 0) = 0\n  winding_number ?p ?z = winding_number (\\<lambda>w. ?p w - ?z) 0\n\ngoal (1 subgoal):\n 1. Re (winding_number h z) = 0", "by auto"], ["proof (state)\nthis:\n  Re (winding_number h z) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>{0..1}. Re (?h t) = Re z; valid_path ?h;\n   z \\<notin> path_image ?h\\<rbrakk>\n  \\<Longrightarrow> Re (winding_number ?h z) = 0\n\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have ?case when \"s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have *: \"\\<forall>t\\<in>{0..1}. Re (g t) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0..1}. Re (g t) = Re z", "using \\<open>\\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\\<close> \\<open>Re (g 1) = Re z\\<close> \\<open>Re (g 0) = Re z\\<close> \\<open>s=0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n  s = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0..1}. Re (g t) = Re z", "by force"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0..1}. Re (g t) = Re z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"Re(winding_number g z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "by (rule Re_winding_0[OF * \\<open>valid_path g\\<close> \\<open>z \\<notin> path_image g\\<close>])"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"cindex_pathE g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g t - z) / Re (g t - z)) = 0", "apply (rule cindexE_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Im (g t - z) / Re (g t - z) = ?c", "using *"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0..1}. Re (g t) = Re z\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Im (g t - z) / Re (g t - z) = ?c", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number g z) = 0\n  cindex_pathE g z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g z) = 0\n  cindex_pathE g z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have ?case when \"s\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define g1 where \"g1 = subpath 0 s g\""], ["proof (state)\nthis:\n  g1 = subpath 0 s g\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define g2 where \"g2 = subpath s 1 g\""], ["proof (state)\nthis:\n  g2 = subpath s 1 g\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"path g\" \"s>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g &&& 0 < s", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>] that \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  path g\n  s \\<noteq> 0\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. path g &&& 0 < s", "by auto"], ["proof (state)\nthis:\n  path g\n  0 < s\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"2 * Re (winding_number g z) = 2*Re (winding_number g1 z) + 2*Re (winding_number g2 z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) =\n    2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)", "apply (subst winding_number_subpath_combine[OF \\<open>path g\\<close> \\<open>z\\<notin>path_image g\\<close>,of 0 s 1\n            ,simplified,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> s \\<and> s \\<le> 1\n 2. 2 *\n    Re (winding_number (subpath 0 s g) z +\n        winding_number (subpath s 1 g) z) =\n    2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (2 subgoals):\n 1. 0 \\<le> s \\<and> s \\<le> 1\n 2. 2 *\n    Re (winding_number (subpath 0 s g) z +\n        winding_number (subpath s 1 g) z) =\n    2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)", "unfolding g1_def g2_def"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (2 subgoals):\n 1. 0 \\<le> s \\<and> s \\<le> 1\n 2. 2 *\n    Re (winding_number (subpath 0 s g) z +\n        winding_number (subpath s 1 g) z) =\n    2 * Re (winding_number (subpath 0 s g) z) +\n    2 * Re (winding_number (subpath s 1 g) z)", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) =\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "also"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) =\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"... = - cindex_pathE g1 z - cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "have \"2*Re (winding_number g1 z) = - cindex_pathE g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) = - cindex_pathE g1 z", "unfolding g1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (subpath 0 s g) z) =\n    - cindex_pathE (subpath 0 s g) z", "apply (rule subEq.hyps(5))"], ["proof (prove)\ngoal (4 subgoals):\n 1. valid_path (subpath 0 s g)\n 2. z \\<notin> path_image (subpath 0 s g)\n 3. Re (subpath 0 s g 1) = Re z\n 4. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (subpath 0 s g)", "using subEq.hyps(1) subEq.prems(1) valid_path_subpath"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n  valid_path g\n  \\<lbrakk>valid_path ?g; ?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> valid_path (subpath ?u ?v ?g)\n\ngoal (1 subgoal):\n 1. valid_path (subpath 0 s g)", "by fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. z \\<notin> path_image (subpath 0 s g)\n 2. Re (subpath 0 s g 1) = Re z\n 3. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (subpath 0 s g)", "by (meson Path_Connected.path_image_subpath_subset atLeastAtMost_iff \n            atLeastLessThan_iff less_eq_real_def subEq(7) subEq.hyps(1) subEq.prems(1) \n            subsetCE valid_path_imp_path zero_le_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re (subpath 0 s g 1) = Re z\n 2. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath 0 s g 1) = Re z", "by (metis Groups.add_ac(2) add_0_left diff_zero mult.right_neutral subEq(2) \n            subEq(9) subpath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath 0 s g 0) = Re z", "by (simp add: subEq.prems(4) subpath_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "have \"2*Re (winding_number g2 z) = - cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "have *: \"\\<forall>t\\<in>{0..1}. Re (g2 t) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0..1}. Re (g2 t) = Re z", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0..1} \\<Longrightarrow> Re (g2 t) = Re z", "fix t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0..1} \\<Longrightarrow> Re (g2 t) = Re z", "assume \"t\\<in>{0..1}\""], ["proof (state)\nthis:\n  t \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0..1} \\<Longrightarrow> Re (g2 t) = Re z", "have \"Re (g2 t) = Re z\" when \"t=0 \\<or> t=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "using that"], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "unfolding g2_def"], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1\n\ngoal (1 subgoal):\n 1. Re (subpath s 1 g t) = Re z", "by (metis \\<open>s \\<noteq> 0\\<close> add.left_neutral diff_add_cancel mult.commute mult.left_neutral \n                mult_zero_left subEq.hyps(2) subEq.prems(3) subpath_def)"], ["proof (state)\nthis:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> Re (g2 t) = Re z\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0..1} \\<Longrightarrow> Re (g2 t) = Re z", "moreover"], ["proof (state)\nthis:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> Re (g2 t) = Re z\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0..1} \\<Longrightarrow> Re (g2 t) = Re z", "have \"Re (g2 t) = Re z\" when \"t\\<in>{0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "define t' where \"t'=(1 - s) * t + s\""], ["proof (state)\nthis:\n  t' = (1 - s) * t + s\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "then"], ["proof (chain)\npicking this:\n  t' = (1 - s) * t + s", "have \"t'\\<in>{s<..<1}\""], ["proof (prove)\nusing this:\n  t' = (1 - s) * t + s\n\ngoal (1 subgoal):\n 1. t' \\<in> {s<..<1}", "using that \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  t' = (1 - s) * t + s\n  t \\<in> {0<..<1}\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. t' \\<in> {s<..<1}", "unfolding t'_def"], ["proof (prove)\nusing this:\n  (1 - s) * t + s = (1 - s) * t + s\n  t \\<in> {0<..<1}\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. (1 - s) * t + s \\<in> {s<..<1}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; 0 \\<le> s; s < 1\\<rbrakk>\n    \\<Longrightarrow> (1 - s) * t + s < 1", "by (sos \"((((A<0 * (A<1 * A<2)) * R<1) + ((A<=1 * (A<0 * R<1)) * (R<1 * [1]^2))))\")"], ["proof (state)\nthis:\n  t' \\<in> {s<..<1}\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {s<..<1}", "have \"Re (g t') = Re z\""], ["proof (prove)\nusing this:\n  t' \\<in> {s<..<1}\n\ngoal (1 subgoal):\n 1. Re (g t') = Re z", "using \\<open>\\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> {s<..<1}\n  \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\n\ngoal (1 subgoal):\n 1. Re (g t') = Re z", "by auto"], ["proof (state)\nthis:\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "then"], ["proof (chain)\npicking this:\n  Re (g t') = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "unfolding g2_def subpath_def t'_def"], ["proof (prove)\nusing this:\n  Re (g ((1 - s) * t + s)) = Re z\n\ngoal (1 subgoal):\n 1. Re (g ((1 - s) * t + s)) = Re z", "."], ["proof (state)\nthis:\n  Re (g2 t) = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) = Re z\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0..1} \\<Longrightarrow> Re (g2 t) = Re z", "ultimately"], ["proof (chain)\npicking this:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> Re (g2 t) = Re z\n  t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) = Re z", "show \"Re (g2 t) = Re z\""], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> Re (g2 t) = Re z\n  t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) = Re z\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "using \\<open>t\\<in>{0..1}\\<close>"], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> Re (g2 t) = Re z\n  t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) = Re z\n  t \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. Re (g2 t) = Re z", "by fastforce"], ["proof (state)\nthis:\n  Re (g2 t) = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0..1}. Re (g2 t) = Re z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "have \"Re(winding_number g2 z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number g2 z) = 0", "apply (rule Re_winding_0[OF *])"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path g2\n 2. z \\<notin> path_image g2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path g2", "using g2_def subEq.hyps(1) subEq.prems(1) valid_path_subpath"], ["proof (prove)\nusing this:\n  g2 = subpath s 1 g\n  s \\<in> {0..<1}\n  valid_path g\n  \\<lbrakk>valid_path ?g; ?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> valid_path (subpath ?u ?v ?g)\n\ngoal (1 subgoal):\n 1. valid_path g2", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image g2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image g2", "by (metis (no_types, hide_lams) Path_Connected.path_image_subpath_subset \n                atLeastAtMost_iff atLeastLessThan_iff g2_def less_eq_real_def subEq.hyps(1) \n                subEq.prems(1) subEq.prems(2) subsetCE valid_path_imp_path zero_le_one)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number g2 z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "moreover"], ["proof (state)\nthis:\n  Re (winding_number g2 z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "have \"cindex_pathE g2 z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g2 z = 0", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) = 0", "apply (rule cindexE_constI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Im (g2 t - z) / Re (g2 t - z) = ?c", "using *"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0..1}. Re (g2 t) = Re z\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Im (g2 t - z) / Re (g2 t - z) = ?c", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g2 z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number g2 z) = 0\n  cindex_pathE g2 z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g2 z) = 0\n  cindex_pathE g2 z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n  - cindex_pathE g1 z - cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n  - cindex_pathE g1 z - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "also"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n  - cindex_pathE g1 z - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"... = - cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "have \"finite_ReZ_segments g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "unfolding finite_ReZ_segments_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "apply (rule finite_Psegments.insertI_1[of s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. s \\<in> {0..<1}\n 2. s = 0 \\<or> Re (g s - z) = 0\n 3. \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0\n 4. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {0..<1}", "using \\<open>s \\<in> {0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. s \\<in> {0..<1}", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. s = 0 \\<or> Re (g s - z) = 0\n 2. \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0\n 3. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = 0 \\<or> Re (g s - z) = 0", "using \\<open>s = 0 \\<or> Re (g s) = Re z\\<close>"], ["proof (prove)\nusing this:\n  s = 0 \\<or> Re (g s) = Re z\n\ngoal (1 subgoal):\n 1. s = 0 \\<or> Re (g s - z) = 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0\n 2. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0", "using \\<open>\\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<1}. Re (g t - z) = 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "have \"finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1", "using \\<open>finite_ReZ_segments (subpath 0 s g) z\\<close>"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1", "unfolding subpath_def finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g ((s - 0) * t + 0) - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "from finite_Psegments_pos_linear[of _ \"1/s\" 0 0 s,simplified,OF this]"], ["proof (chain)\npicking this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g (s * t)) = Re z) \\<circ> (\\<lambda>t. t / s)) 0 s", "show \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\""], ["proof (prove)\nusing this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g (s * t)) = Re z) \\<circ> (\\<lambda>t. t / s)) 0 s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "using \\<open>s>0\\<close>"], ["proof (prove)\nusing this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g (s * t)) = Re z) \\<circ> (\\<lambda>t. t / s)) 0 s\n  0 < s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "unfolding comp_def"], ["proof (prove)\nusing this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments (\\<lambda>x. Re (g (s * (x / s))) = Re z) 0 s\n  0 < s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite_ReZ_segments g z\n\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "then"], ["proof (chain)\npicking this:\n  finite_ReZ_segments g z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "using cindex_pathE_subpath_combine[OF _ \\<open>path g\\<close>,of z 0 s 1,folded g1_def g2_def,simplified]\n          \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  \\<lbrakk>finite_ReZ_segments g z; 0 \\<le> s; s \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE g1 z + cindex_pathE g2 z = cindex_pathE g z\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "finally"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g z) = - cindex_pathE g z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "."], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (2 subgoals):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n 2. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z", "show ?case"], ["proof (prove)\nusing this:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "case (subNEq s g z)"], ["proof (state)\nthis:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s) = Re z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  finite_ReZ_segments (subpath 0 s g) z\n  \\<lbrakk>valid_path (subpath 0 s g);\n   z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n   Re (subpath 0 s g 0) = Re z\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                    - cindex_pathE (subpath 0 s g) z\n  valid_path g\n  z \\<notin> path_image g\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have Re_winding:\"2*Re(winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\" \n    when Re_neq:\"\\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\" and \"Re (h 0) = Re z\" \"Re (h 1) = Re z\"\n          and \"valid_path h\" \"z\\<notin>path_image h\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have Re_winding_pos:\n        \"2*Re(winding_number h0 0) = jumpF_pathfinish h0 0 - jumpF_pathstart h0 0\" \n      when Re_gt:\"\\<forall>t\\<in>{0<..<1}. Re (h0 t) > 0\" and \"Re (h0 0) = 0\" \"Re (h0 1) = 0\"\n          and \"valid_path h0\" \"0\\<notin>path_image h0\" for h0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "define f where \"f \\<equiv> (\\<lambda>(t::real). Im(h0 t) / Re (h0 t))\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>t. Im (h0 t) / Re (h0 t)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "define ln0 where \"ln0 = Im (Ln (h0 0)) / pi\""], ["proof (state)\nthis:\n  ln0 = Im (Ln (h0 0)) / pi\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "define ln1 where \"ln1 = Im (Ln (h0 1)) / pi\""], ["proof (state)\nthis:\n  ln1 = Im (Ln (h0 1)) / pi\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "have \"path h0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path h0", "using \\<open>valid_path h0\\<close> valid_path_imp_path"], ["proof (prove)\nusing this:\n  valid_path h0\n  valid_path ?g \\<Longrightarrow> path ?g\n\ngoal (1 subgoal):\n 1. path h0", "by auto"], ["proof (state)\nthis:\n  path h0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "have \"h0 0\\<noteq>0\" \"h0 1\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h0 0 \\<noteq> 0 &&& h0 1 \\<noteq> 0", "using path_defs(4) that(5)"], ["proof (prove)\nusing this:\n  path_image ?g = ?g ` {0..1}\n  0 \\<notin> path_image h0\n\ngoal (1 subgoal):\n 1. h0 0 \\<noteq> 0 &&& h0 1 \\<noteq> 0", "by fastforce+"], ["proof (state)\nthis:\n  h0 0 \\<noteq> 0\n  h0 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "have \"ln1 = jumpF_pathfinish h0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have sgnx_at_left:\"((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_left 1)", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<1. \\<forall>y>b. y < 1 \\<longrightarrow> sgn (Re (h0 y)) = 1", "using \\<open>\\<forall>p\\<in>{0<..<1}. Re (h0 p) > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{0<..<1}. 0 < Re (h0 p)\n\ngoal (1 subgoal):\n 1. \\<exists>b<1. \\<forall>y>b. y < 1 \\<longrightarrow> sgn (Re (h0 y)) = 1", "by (intro exI[where x=0],auto)"], ["proof (state)\nthis:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_left 1)\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have cont:\"continuous (at_left 1) (\\<lambda>t. Im (h0 t))\" \n                \"continuous (at_left 1) (\\<lambda>t. Re (h0 t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_left 1) (\\<lambda>t. Im (h0 t)) &&&\n    continuous (at_left 1) (\\<lambda>t. Re (h0 t))", "using \\<open>path h0\\<close>"], ["proof (prove)\nusing this:\n  path h0\n\ngoal (1 subgoal):\n 1. continuous (at_left 1) (\\<lambda>t. Im (h0 t)) &&&\n    continuous (at_left 1) (\\<lambda>t. Re (h0 t))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} h0\n\ngoal (1 subgoal):\n 1. continuous (at_left 1) (\\<lambda>t. Im (h0 t)) &&&\n    continuous (at_left 1) (\\<lambda>t. Re (h0 t))", "by (auto intro:continuous_on_at_left[of 0 1] continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_left 1) (\\<lambda>t. Im (h0 t))\n  continuous (at_left 1) (\\<lambda>t. Re (h0 t))\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have ?thesis when \"Im (h0 1) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have \"ln1 = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln1 = 1 / 2", "using Im_Ln_eq_pi_half[OF \\<open>h0 1\\<noteq>0\\<close>] that \\<open>Re (h0 1) = 0\\<close>"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 1)) = pi / 2) = (0 < Im (h0 1) \\<and> Re (h0 1) = 0)\n  (Im (Ln (h0 1)) = - pi / 2) = (Im (h0 1) < 0 \\<and> Re (h0 1) = 0)\n  0 < Im (h0 1)\n  Re (h0 1) = 0\n\ngoal (1 subgoal):\n 1. ln1 = 1 / 2", "unfolding ln1_def"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 1)) = pi / 2) = (0 < Im (h0 1) \\<and> Re (h0 1) = 0)\n  (Im (Ln (h0 1)) = - pi / 2) = (Im (h0 1) < 0 \\<and> Re (h0 1) = 0)\n  0 < Im (h0 1)\n  Re (h0 1) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h0 1)) / pi = 1 / 2", "by auto"], ["proof (state)\nthis:\n  ln1 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "moreover"], ["proof (state)\nthis:\n  ln1 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have \"jumpF_pathfinish h0 0 = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = 1 / 2", "have \"filterlim f at_top (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_top (at_left 1)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM t at_left 1. Im (h0 t) / Re (h0 t) :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \" Im (h0 1)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1)\n 2. Im (h0 1) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx sgn (Im (h0 1))) (at_left 1)", "using \\<open>Re(h0 1) = 0\\<close> sgnx_at_left cont that"], ["proof (prove)\nusing this:\n  Re (h0 1) = 0\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_left 1)\n  continuous (at_left 1) (\\<lambda>t. Im (h0 t))\n  continuous (at_left 1) (\\<lambda>t. Re (h0 t))\n  0 < Im (h0 1)\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1)\n 2. Im (h0 1) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx sgn (Im (h0 1))) (at_left 1)", "unfolding continuous_within"], ["proof (prove)\nusing this:\n  Re (h0 1) = 0\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_left 1)\n  ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1)\n  ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1)\n  0 < Im (h0 1)\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1)\n 2. Im (h0 1) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx sgn (Im (h0 1))) (at_left 1)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_top (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = 1 / 2", "unfolding jumpF_pathfinish_def jumpF_def f_def"], ["proof (prove)\nusing this:\n  LIM t at_left 1. Im (h0 t) / Re (h0 t) :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. Im (h0 t - 0) / Re (h0 t - 0) :> at_top then 1 / 2\n     else if LIM t at_left 1. Im (h0 t - 0) / Re (h0 t - 0) :> at_bot\n          then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish h0 0 = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish h0 0 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "ultimately"], ["proof (chain)\npicking this:\n  ln1 = 1 / 2\n  jumpF_pathfinish h0 0 = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  ln1 = 1 / 2\n  jumpF_pathfinish h0 0 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "by auto"], ["proof (state)\nthis:\n  ln1 = jumpF_pathfinish h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < Im (h0 1) \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "moreover"], ["proof (state)\nthis:\n  0 < Im (h0 1) \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have ?thesis when \"Im (h0 1) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have \"ln1 = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln1 = - 1 / 2", "using Im_Ln_eq_pi_half[OF \\<open>h0 1\\<noteq>0\\<close>] that \\<open>Re (h0 1) = 0\\<close>"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 1)) = pi / 2) = (0 < Im (h0 1) \\<and> Re (h0 1) = 0)\n  (Im (Ln (h0 1)) = - pi / 2) = (Im (h0 1) < 0 \\<and> Re (h0 1) = 0)\n  Im (h0 1) < 0\n  Re (h0 1) = 0\n\ngoal (1 subgoal):\n 1. ln1 = - 1 / 2", "unfolding ln1_def"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 1)) = pi / 2) = (0 < Im (h0 1) \\<and> Re (h0 1) = 0)\n  (Im (Ln (h0 1)) = - pi / 2) = (Im (h0 1) < 0 \\<and> Re (h0 1) = 0)\n  Im (h0 1) < 0\n  Re (h0 1) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h0 1)) / pi = - 1 / 2", "by auto"], ["proof (state)\nthis:\n  ln1 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "moreover"], ["proof (state)\nthis:\n  ln1 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have \"jumpF_pathfinish h0 0 = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = - 1 / 2", "have \"((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)", "using sgnx_at_left that"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_left 1)\n  Im (h0 1) < 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)", "have \"filterlim f at_bot (at_left 1)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left 1)", "unfolding f_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM t at_left 1. Im (h0 t) / Re (h0 t) :> at_bot", "using cont that"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1))) (at_left 1)\n  continuous (at_left 1) (\\<lambda>t. Im (h0 t))\n  continuous (at_left 1) (\\<lambda>t. Re (h0 t))\n  Im (h0 1) < 0\n\ngoal (1 subgoal):\n 1. LIM t at_left 1. Im (h0 t) / Re (h0 t) :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \" Im (h0 1)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     continuous (at_left 1) (\\<lambda>t. Im (h0 t));\n     continuous (at_left 1) (\\<lambda>t. Re (h0 t)); Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow>\n                       Im (h0 1))\n                       (at_left 1)\n 2. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     continuous (at_left 1) (\\<lambda>t. Im (h0 t));\n     continuous (at_left 1) (\\<lambda>t. Re (h0 t)); Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> Im (h0 1) \\<noteq> 0\n 3. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     continuous (at_left 1) (\\<lambda>t. Im (h0 t));\n     continuous (at_left 1) (\\<lambda>t. Re (h0 t)); Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0)\n                       (at_left 1) \\<and>\n                      ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n                       (at_left 1)", "unfolding continuous_within"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1);\n     ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1);\n     Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow>\n                       Im (h0 1))\n                       (at_left 1)\n 2. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1);\n     ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1);\n     Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> Im (h0 1) \\<noteq> 0\n 3. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1);\n     ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1);\n     Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0)\n                       (at_left 1) \\<and>\n                      ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n                       (at_left 1)", "using \\<open>Re(h0 1) = 0\\<close>"], ["proof (prove)\nusing this:\n  Re (h0 1) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1);\n     ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1);\n     Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow>\n                       Im (h0 1))\n                       (at_left 1)\n 2. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1);\n     ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1);\n     Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> Im (h0 1) \\<noteq> 0\n 3. \\<lbrakk>((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n              (at_left 1);\n     ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 1)) (at_left 1);\n     ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 1)) (at_left 1);\n     Im (h0 1) < 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0)\n                       (at_left 1) \\<and>\n                      ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 1)))\n                       (at_left 1)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish h0 0 = - 1 / 2", "unfolding jumpF_pathfinish_def jumpF_def f_def"], ["proof (prove)\nusing this:\n  LIM t at_left 1. Im (h0 t) / Re (h0 t) :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. Im (h0 t - 0) / Re (h0 t - 0) :> at_top then 1 / 2\n     else if LIM t at_left 1. Im (h0 t - 0) / Re (h0 t - 0) :> at_bot\n          then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish h0 0 = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish h0 0 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "ultimately"], ["proof (chain)\npicking this:\n  ln1 = - 1 / 2\n  jumpF_pathfinish h0 0 = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  ln1 = - 1 / 2\n  jumpF_pathfinish h0 0 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "by auto"], ["proof (state)\nthis:\n  ln1 = jumpF_pathfinish h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (h0 1) < 0 \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "moreover"], ["proof (state)\nthis:\n  Im (h0 1) < 0 \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "have \"Im (h0 1)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (h0 1) \\<noteq> 0", "using \\<open>h0 1\\<noteq>0\\<close> \\<open>Re (h0 1) = 0\\<close>"], ["proof (prove)\nusing this:\n  h0 1 \\<noteq> 0\n  Re (h0 1) = 0\n\ngoal (1 subgoal):\n 1. Im (h0 1) \\<noteq> 0", "using complex.expand"], ["proof (prove)\nusing this:\n  h0 1 \\<noteq> 0\n  Re (h0 1) = 0\n  Re ?complex = Re ?complex' \\<and>\n  Im ?complex = Im ?complex' \\<Longrightarrow>\n  ?complex = ?complex'\n\ngoal (1 subgoal):\n 1. Im (h0 1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Im (h0 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "ultimately"], ["proof (chain)\npicking this:\n  0 < Im (h0 1) \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n  Im (h0 1) < 0 \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n  Im (h0 1) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Im (h0 1) \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n  Im (h0 1) < 0 \\<Longrightarrow> ln1 = jumpF_pathfinish h0 0\n  Im (h0 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ln1 = jumpF_pathfinish h0 0", "by linarith"], ["proof (state)\nthis:\n  ln1 = jumpF_pathfinish h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ln1 = jumpF_pathfinish h0 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "moreover"], ["proof (state)\nthis:\n  ln1 = jumpF_pathfinish h0 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "have \"ln0 = jumpF_pathstart h0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have sgnx_at_right:\"((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>0. \\<forall>y>0. y < b \\<longrightarrow> sgn (Re (h0 y)) = 1", "using \\<open>\\<forall>p\\<in>{0<..<1}. Re (h0 p) > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{0<..<1}. 0 < Re (h0 p)\n\ngoal (1 subgoal):\n 1. \\<exists>b>0. \\<forall>y>0. y < b \\<longrightarrow> sgn (Re (h0 y)) = 1", "by (intro exI[where x=1],auto)"], ["proof (state)\nthis:\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have cont:\"continuous (at_right 0) (\\<lambda>t. Im (h0 t))\" \n          \"continuous (at_right 0) (\\<lambda>t. Re (h0 t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_right 0) (\\<lambda>t. Im (h0 t)) &&&\n    continuous (at_right 0) (\\<lambda>t. Re (h0 t))", "using \\<open>path h0\\<close>"], ["proof (prove)\nusing this:\n  path h0\n\ngoal (1 subgoal):\n 1. continuous (at_right 0) (\\<lambda>t. Im (h0 t)) &&&\n    continuous (at_right 0) (\\<lambda>t. Re (h0 t))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} h0\n\ngoal (1 subgoal):\n 1. continuous (at_right 0) (\\<lambda>t. Im (h0 t)) &&&\n    continuous (at_right 0) (\\<lambda>t. Re (h0 t))", "by (auto intro:continuous_on_at_right[of 0 1] continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_right 0) (\\<lambda>t. Im (h0 t))\n  continuous (at_right 0) (\\<lambda>t. Re (h0 t))\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have ?thesis when \"Im (h0 0) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have \"ln0 = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln0 = 1 / 2", "using Im_Ln_eq_pi_half[OF \\<open>h0 0\\<noteq>0\\<close>] that \\<open>Re (h0 0) = 0\\<close>"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 0)) = pi / 2) = (0 < Im (h0 0) \\<and> Re (h0 0) = 0)\n  (Im (Ln (h0 0)) = - pi / 2) = (Im (h0 0) < 0 \\<and> Re (h0 0) = 0)\n  0 < Im (h0 0)\n  Re (h0 0) = 0\n\ngoal (1 subgoal):\n 1. ln0 = 1 / 2", "unfolding ln0_def"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 0)) = pi / 2) = (0 < Im (h0 0) \\<and> Re (h0 0) = 0)\n  (Im (Ln (h0 0)) = - pi / 2) = (Im (h0 0) < 0 \\<and> Re (h0 0) = 0)\n  0 < Im (h0 0)\n  Re (h0 0) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h0 0)) / pi = 1 / 2", "by auto"], ["proof (state)\nthis:\n  ln0 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "moreover"], ["proof (state)\nthis:\n  ln0 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have \"jumpF_pathstart h0 0 = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = 1 / 2", "have \"filterlim f at_top (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_top (at_right 0)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM t at_right 0. Im (h0 t) / Re (h0 t) :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \" Im (h0 0)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n 2. Im (h0 0) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx sgn (Im (h0 0))) (at_right 0)", "using \\<open>Re(h0 0) = 0\\<close> sgnx_at_right cont that"], ["proof (prove)\nusing this:\n  Re (h0 0) = 0\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)\n  continuous (at_right 0) (\\<lambda>t. Im (h0 t))\n  continuous (at_right 0) (\\<lambda>t. Re (h0 t))\n  0 < Im (h0 0)\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n 2. Im (h0 0) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx sgn (Im (h0 0))) (at_right 0)", "unfolding continuous_within"], ["proof (prove)\nusing this:\n  Re (h0 0) = 0\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)\n  ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n  ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 0)) (at_right 0)\n  0 < Im (h0 0)\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n 2. Im (h0 0) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx sgn (Im (h0 0))) (at_right 0)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_top (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top (at_right 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = 1 / 2", "unfolding jumpF_pathstart_def jumpF_def f_def"], ["proof (prove)\nusing this:\n  LIM t at_right 0. Im (h0 t) / Re (h0 t) :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. Im (h0 t - 0) / Re (h0 t - 0) :> at_top then 1 / 2\n     else if LIM t at_right 0. Im (h0 t - 0) / Re (h0 t - 0) :> at_bot\n          then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart h0 0 = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart h0 0 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "ultimately"], ["proof (chain)\npicking this:\n  ln0 = 1 / 2\n  jumpF_pathstart h0 0 = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  ln0 = 1 / 2\n  jumpF_pathstart h0 0 = 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "by auto"], ["proof (state)\nthis:\n  ln0 = jumpF_pathstart h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < Im (h0 0) \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "moreover"], ["proof (state)\nthis:\n  0 < Im (h0 0) \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have ?thesis when \"Im (h0 0) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have \"ln0 = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln0 = - 1 / 2", "using Im_Ln_eq_pi_half[OF \\<open>h0 0\\<noteq>0\\<close>] that \\<open>Re (h0 0) = 0\\<close>"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 0)) = pi / 2) = (0 < Im (h0 0) \\<and> Re (h0 0) = 0)\n  (Im (Ln (h0 0)) = - pi / 2) = (Im (h0 0) < 0 \\<and> Re (h0 0) = 0)\n  Im (h0 0) < 0\n  Re (h0 0) = 0\n\ngoal (1 subgoal):\n 1. ln0 = - 1 / 2", "unfolding ln0_def"], ["proof (prove)\nusing this:\n  (Im (Ln (h0 0)) = pi / 2) = (0 < Im (h0 0) \\<and> Re (h0 0) = 0)\n  (Im (Ln (h0 0)) = - pi / 2) = (Im (h0 0) < 0 \\<and> Re (h0 0) = 0)\n  Im (h0 0) < 0\n  Re (h0 0) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h0 0)) / pi = - 1 / 2", "by auto"], ["proof (state)\nthis:\n  ln0 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "moreover"], ["proof (state)\nthis:\n  ln0 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have \"jumpF_pathstart h0 0 = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = - 1 / 2", "have \"filterlim f at_bot (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right 0)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM t at_right 0. Im (h0 t) / Re (h0 t) :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \" Im (h0 0)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n 2. Im (h0 0) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 0))) (at_right 0)", "using \\<open>Re(h0 0) = 0\\<close> sgnx_at_right cont that"], ["proof (prove)\nusing this:\n  Re (h0 0) = 0\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)\n  continuous (at_right 0) (\\<lambda>t. Im (h0 t))\n  continuous (at_right 0) (\\<lambda>t. Re (h0 t))\n  Im (h0 0) < 0\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n 2. Im (h0 0) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 0))) (at_right 0)", "unfolding continuous_within"], ["proof (prove)\nusing this:\n  Re (h0 0) = 0\n  ((\\<lambda>x. Re (h0 x)) has_sgnx 1) (at_right 0)\n  ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n  ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> Re (h0 0)) (at_right 0)\n  Im (h0 0) < 0\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. Im (h0 t)) \\<longlongrightarrow> Im (h0 0)) (at_right 0)\n 2. Im (h0 0) \\<noteq> 0\n 3. ((\\<lambda>t. Re (h0 t)) \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    ((\\<lambda>x. Re (h0 x)) has_sgnx - sgn (Im (h0 0))) (at_right 0)", "by auto"], ["proof (state)\nthis:\n  filterlim f at_bot (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_right 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart h0 0 = - 1 / 2", "unfolding jumpF_pathstart_def jumpF_def f_def"], ["proof (prove)\nusing this:\n  LIM t at_right 0. Im (h0 t) / Re (h0 t) :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. Im (h0 t - 0) / Re (h0 t - 0) :> at_top then 1 / 2\n     else if LIM t at_right 0. Im (h0 t - 0) / Re (h0 t - 0) :> at_bot\n          then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart h0 0 = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart h0 0 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "ultimately"], ["proof (chain)\npicking this:\n  ln0 = - 1 / 2\n  jumpF_pathstart h0 0 = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  ln0 = - 1 / 2\n  jumpF_pathstart h0 0 = - 1 / 2\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "by auto"], ["proof (state)\nthis:\n  ln0 = jumpF_pathstart h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (h0 0) < 0 \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "moreover"], ["proof (state)\nthis:\n  Im (h0 0) < 0 \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "have \"Im (h0 0)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (h0 0) \\<noteq> 0", "using \\<open>h0 0\\<noteq>0\\<close> \\<open>Re (h0 0) = 0\\<close>"], ["proof (prove)\nusing this:\n  h0 0 \\<noteq> 0\n  Re (h0 0) = 0\n\ngoal (1 subgoal):\n 1. Im (h0 0) \\<noteq> 0", "using complex.expand"], ["proof (prove)\nusing this:\n  h0 0 \\<noteq> 0\n  Re (h0 0) = 0\n  Re ?complex = Re ?complex' \\<and>\n  Im ?complex = Im ?complex' \\<Longrightarrow>\n  ?complex = ?complex'\n\ngoal (1 subgoal):\n 1. Im (h0 0) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Im (h0 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "ultimately"], ["proof (chain)\npicking this:\n  0 < Im (h0 0) \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n  Im (h0 0) < 0 \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n  Im (h0 0) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Im (h0 0) \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n  Im (h0 0) < 0 \\<Longrightarrow> ln0 = jumpF_pathstart h0 0\n  Im (h0 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ln0 = jumpF_pathstart h0 0", "by linarith"], ["proof (state)\nthis:\n  ln0 = jumpF_pathstart h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ln0 = jumpF_pathstart h0 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "moreover"], ["proof (state)\nthis:\n  ln0 = jumpF_pathstart h0 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "have \"2*Re(winding_number h0 0) = ln1 - ln0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) = ln1 - ln0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) = ln1 - ln0", "have \"\\<forall>p\\<in>path_image h0. 0 \\<le> Re p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image h0. 0 \\<le> Re p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "assume \"p \\<in> path_image h0\""], ["proof (state)\nthis:\n  p \\<in> path_image h0\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "then"], ["proof (chain)\npicking this:\n  p \\<in> path_image h0", "obtain t where t:\"t\\<in>{0..1}\" \"p = h0 t\""], ["proof (prove)\nusing this:\n  p \\<in> path_image h0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {0..1}; p = h0 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  p \\<in> h0 ` {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {0..1}; p = h0 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> {0..1}\n  p = h0 t\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "have \"0 \\<le> Re p\" when \"t=0 \\<or> t=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re p", "using that t \\<open>Re (h0 0) = 0\\<close> \\<open>Re (h0 1) = 0\\<close>"], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1\n  t \\<in> {0..1}\n  p = h0 t\n  Re (h0 0) = 0\n  Re (h0 1) = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re p", "by auto"], ["proof (state)\nthis:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> 0 \\<le> Re p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "moreover"], ["proof (state)\nthis:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> 0 \\<le> Re p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "have \"0 \\<le> Re p\" when \"t\\<in>{0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re p", "using that t Re_gt[rule_format, of t]"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<1}\n  t \\<in> {0..1}\n  p = h0 t\n  t \\<in> {0<..<1} \\<Longrightarrow> 0 < Re (h0 t)\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re p", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> {0<..<1} \\<Longrightarrow> 0 \\<le> Re p\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image h0 \\<Longrightarrow> 0 \\<le> Re p", "ultimately"], ["proof (chain)\npicking this:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> 0 \\<le> Re p\n  t \\<in> {0<..<1} \\<Longrightarrow> 0 \\<le> Re p", "show \"0 \\<le> Re p\""], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> 0 \\<le> Re p\n  t \\<in> {0<..<1} \\<Longrightarrow> 0 \\<le> Re p\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re p", "using t(1)"], ["proof (prove)\nusing this:\n  t = 0 \\<or> t = 1 \\<Longrightarrow> 0 \\<le> Re p\n  t \\<in> {0<..<1} \\<Longrightarrow> 0 \\<le> Re p\n  t \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re p", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> Re p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>path_image h0. 0 \\<le> Re p\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) = ln1 - ln0", "from Re_winding_number_half_right[of _ 0,simplified,OF this \\<open>valid_path h0\\<close> \\<open>0 \\<notin> path_image h0\\<close>]"], ["proof (chain)\npicking this:\n  Re (winding_number h0 0) =\n  (Im (Ln (pathfinish h0)) - Im (Ln (pathstart h0))) / (2 * pi)", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number h0 0) =\n  (Im (Ln (pathfinish h0)) - Im (Ln (pathstart h0))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) = ln1 - ln0", "unfolding ln1_def ln0_def pathfinish_def pathstart_def"], ["proof (prove)\nusing this:\n  Re (winding_number h0 0) = (Im (Ln (h0 1)) - Im (Ln (h0 0))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) = Im (Ln (h0 1)) / pi - Im (Ln (h0 0)) / pi", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  2 * Re (winding_number h0 0) = ln1 - ln0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * Re (winding_number h0 0) = ln1 - ln0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "ultimately"], ["proof (chain)\npicking this:\n  ln1 = jumpF_pathfinish h0 0\n  ln0 = jumpF_pathstart h0 0\n  2 * Re (winding_number h0 0) = ln1 - ln0", "show ?thesis"], ["proof (prove)\nusing this:\n  ln1 = jumpF_pathfinish h0 0\n  ln0 = jumpF_pathstart h0 0\n  2 * Re (winding_number h0 0) = ln1 - ln0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h0 0) =\n    jumpF_pathfinish h0 0 - jumpF_pathstart h0 0", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number h0 0) =\n  jumpF_pathfinish h0 0 - jumpF_pathstart h0 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>{0<..<1}. 0 < Re (?h0.0 t); Re (?h0.0 0) = 0;\n   Re (?h0.0 1) = 0; valid_path ?h0.0; 0 \\<notin> path_image ?h0.0\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number ?h0.0 0) =\n                    jumpF_pathfinish ?h0.0 0 - jumpF_pathstart ?h0.0 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have ?thesis when \"\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "let ?hu= \"\\<lambda>t. z - h t\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"2*Re(winding_number ?hu 0) = jumpF_pathfinish ?hu 0 - jumpF_pathstart ?hu 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (\\<lambda>t. z - h t) 0) =\n    jumpF_pathfinish (\\<lambda>t. z - h t) 0 -\n    jumpF_pathstart (\\<lambda>t. z - h t) 0", "apply(rule Re_winding_pos)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>t\\<in>{0<..<1}. 0 < Re (z - h t)\n 2. Re (z - h 0) = 0\n 3. Re (z - h 1) = 0\n 4. valid_path (\\<lambda>t. z - h t)\n 5. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0<..<1}. 0 < Re (z - h t)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) < Re z\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0<..<1}. 0 < Re (z - h t)", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. Re (z - h 0) = 0\n 2. Re (z - h 1) = 0\n 3. valid_path (\\<lambda>t. z - h t)\n 4. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (z - h 0) = 0", "using \\<open>Re (h 0) = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (h 0) = Re z\n\ngoal (1 subgoal):\n 1. Re (z - h 0) = 0", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. Re (z - h 1) = 0\n 2. valid_path (\\<lambda>t. z - h t)\n 3. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (z - h 1) = 0", "using \\<open>Re (h 1) = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (h 1) = Re z\n\ngoal (1 subgoal):\n 1. Re (z - h 1) = 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path (\\<lambda>t. z - h t)\n 2. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. z - h t)", "using \\<open>valid_path h\\<close> valid_path_offset valid_path_uminus_comp"], ["proof (prove)\nusing this:\n  valid_path h\n  valid_path (\\<lambda>t. ?g t - ?z) = valid_path ?g\n  valid_path (uminus \\<circ> ?g) = valid_path ?g\n\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. z - h t)", "unfolding comp_def"], ["proof (prove)\nusing this:\n  valid_path h\n  valid_path (\\<lambda>t. ?g t - ?z) = valid_path ?g\n  valid_path (\\<lambda>x. - ?g x) = valid_path ?g\n\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. z - h t)", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "using \\<open>z\\<notin>path_image h\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. z - h t)", "by (simp add: image_iff path_defs(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 * Re (winding_number (\\<lambda>t. z - h t) 0) =\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 -\n  jumpF_pathstart (\\<lambda>t. z - h t) 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number (\\<lambda>t. z - h t) 0) =\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 -\n  jumpF_pathstart (\\<lambda>t. z - h t) 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"winding_number ?hu 0 = winding_number h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. z - h t) 0 = winding_number h z", "using winding_number_offset[of h z] \n              winding_number_uminus_comp[of \"\\<lambda>t. h t- z\" 0,unfolded comp_def,simplified] \n              \\<open>valid_path h\\<close> \\<open>z\\<notin>path_image h\\<close>"], ["proof (prove)\nusing this:\n  winding_number h z = winding_number (\\<lambda>w. h w - z) 0\n  \\<lbrakk>valid_path h; z \\<notin> path_image h\\<rbrakk>\n  \\<Longrightarrow> winding_number (\\<lambda>x. z - h x) 0 =\n                    winding_number (\\<lambda>t. h t - z) 0\n  valid_path h\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. z - h t) 0 = winding_number h z", "by auto"], ["proof (state)\nthis:\n  winding_number (\\<lambda>t. z - h t) 0 = winding_number h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  winding_number (\\<lambda>t. z - h t) 0 = winding_number h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"jumpF_pathfinish ?hu 0 =  jumpF_pathfinish h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (\\<lambda>t. z - h t) 0 = jumpF_pathfinish h z", "unfolding jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (z - h t - 0) / Re (z - h t - 0)) (at_left 1) =\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_left 1)", "apply (auto intro!:jumpF_cong eventuallyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (Im z - Im (h x)) / (Re z - Re (h x)) =\n       (Im (h x) - Im z) / (Re (h x) - Re z)", "by (auto simp add:divide_simps algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 = jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 = jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"jumpF_pathstart ?hu 0 =  jumpF_pathstart h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (\\<lambda>t. z - h t) 0 = jumpF_pathstart h z", "unfolding jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (z - h t - 0) / Re (z - h t - 0)) (at_right 0) =\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_right 0)", "apply (auto intro!:jumpF_cong eventuallyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (Im z - Im (h x)) / (Re z - Re (h x)) =\n       (Im (h x) - Im z) / (Re (h x) - Re z)", "by (auto simp add:divide_simps algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathstart (\\<lambda>t. z - h t) 0 = jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number (\\<lambda>t. z - h t) 0) =\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 -\n  jumpF_pathstart (\\<lambda>t. z - h t) 0\n  winding_number (\\<lambda>t. z - h t) 0 = winding_number h z\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 = jumpF_pathfinish h z\n  jumpF_pathstart (\\<lambda>t. z - h t) 0 = jumpF_pathstart h z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number (\\<lambda>t. z - h t) 0) =\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 -\n  jumpF_pathstart (\\<lambda>t. z - h t) 0\n  winding_number (\\<lambda>t. z - h t) 0 = winding_number h z\n  jumpF_pathfinish (\\<lambda>t. z - h t) 0 = jumpF_pathfinish h z\n  jumpF_pathstart (\\<lambda>t. z - h t) 0 = jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have ?thesis when \"\\<forall>t\\<in>{0<..<1}. Re (h t) > Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "let ?hu= \"\\<lambda>t. h t - z\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"2*Re(winding_number ?hu 0) = jumpF_pathfinish ?hu 0 - jumpF_pathstart ?hu 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (\\<lambda>t. h t - z) 0) =\n    jumpF_pathfinish (\\<lambda>t. h t - z) 0 -\n    jumpF_pathstart (\\<lambda>t. h t - z) 0", "apply(rule Re_winding_pos)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>t\\<in>{0<..<1}. 0 < Re (h t - z)\n 2. Re (h 0 - z) = 0\n 3. Re (h 1 - z) = 0\n 4. valid_path (\\<lambda>t. h t - z)\n 5. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0<..<1}. 0 < Re (h t - z)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (h t)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0<..<1}. 0 < Re (h t - z)", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. Re (h 0 - z) = 0\n 2. Re (h 1 - z) = 0\n 3. valid_path (\\<lambda>t. h t - z)\n 4. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 0 - z) = 0", "using \\<open>Re (h 0) = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (h 0) = Re z\n\ngoal (1 subgoal):\n 1. Re (h 0 - z) = 0", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. Re (h 1 - z) = 0\n 2. valid_path (\\<lambda>t. h t - z)\n 3. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 1 - z) = 0", "using \\<open>Re (h 1) = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (h 1) = Re z\n\ngoal (1 subgoal):\n 1. Re (h 1 - z) = 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path (\\<lambda>t. h t - z)\n 2. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. h t - z)", "using \\<open>valid_path h\\<close> valid_path_offset valid_path_uminus_comp"], ["proof (prove)\nusing this:\n  valid_path h\n  valid_path (\\<lambda>t. ?g t - ?z) = valid_path ?g\n  valid_path (uminus \\<circ> ?g) = valid_path ?g\n\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. h t - z)", "unfolding comp_def"], ["proof (prove)\nusing this:\n  valid_path h\n  valid_path (\\<lambda>t. ?g t - ?z) = valid_path ?g\n  valid_path (\\<lambda>x. - ?g x) = valid_path ?g\n\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>t. h t - z)", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "using \\<open>z\\<notin>path_image h\\<close>"], ["proof (prove)\nusing this:\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (\\<lambda>t. h t - z)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 * Re (winding_number (\\<lambda>t. h t - z) 0) =\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 -\n  jumpF_pathstart (\\<lambda>t. h t - z) 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number (\\<lambda>t. h t - z) 0) =\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 -\n  jumpF_pathstart (\\<lambda>t. h t - z) 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"winding_number ?hu 0 = winding_number h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. h t - z) 0 = winding_number h z", "using winding_number_offset[of h z] \\<open>valid_path h\\<close> \\<open>z\\<notin>path_image h\\<close>"], ["proof (prove)\nusing this:\n  winding_number h z = winding_number (\\<lambda>w. h w - z) 0\n  valid_path h\n  z \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. winding_number (\\<lambda>t. h t - z) 0 = winding_number h z", "by auto"], ["proof (state)\nthis:\n  winding_number (\\<lambda>t. h t - z) 0 = winding_number h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  winding_number (\\<lambda>t. h t - z) 0 = winding_number h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"jumpF_pathfinish ?hu 0 =  jumpF_pathfinish h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (\\<lambda>t. h t - z) 0 = jumpF_pathfinish h z", "unfolding jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (h t - z - 0) / Re (h t - z - 0)) (at_left 1) =\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_left 1)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 = jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 = jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"jumpF_pathstart ?hu 0 =  jumpF_pathstart h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (\\<lambda>t. h t - z) 0 = jumpF_pathstart h z", "unfolding jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (h t - z - 0) / Re (h t - z - 0)) (at_right 0) =\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_right 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (\\<lambda>t. h t - z) 0 = jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number (\\<lambda>t. h t - z) 0) =\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 -\n  jumpF_pathstart (\\<lambda>t. h t - z) 0\n  winding_number (\\<lambda>t. h t - z) 0 = winding_number h z\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 = jumpF_pathfinish h z\n  jumpF_pathstart (\\<lambda>t. h t - z) 0 = jumpF_pathstart h z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number (\\<lambda>t. h t - z) 0) =\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 -\n  jumpF_pathstart (\\<lambda>t. h t - z) 0\n  winding_number (\\<lambda>t. h t - z) 0 = winding_number h z\n  jumpF_pathfinish (\\<lambda>t. h t - z) 0 = jumpF_pathfinish h z\n  jumpF_pathstart (\\<lambda>t. h t - z) 0 = jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (h t) \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "moreover"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (h t) \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "have \"(\\<forall>t\\<in>{0<..<1}. Re (h t) > Re z) \\<or> (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n    (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)) \\<Longrightarrow>\n    False", "assume \" \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or> (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z))\""], ["proof (state)\nthis:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z))", "obtain t1 t2 where t:\"t1\\<in>{0<..<1}\" \"t2\\<in>{0<..<1}\" \"Re (h t1)\\<le>Re z\" \"Re (h t2)\\<ge>Re z\""], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z))\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<in> {0<..<1}; t2 \\<in> {0<..<1}; Re (h t1) \\<le> Re z;\n         Re z \\<le> Re (h t2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z))\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<in> {0<..<1}; t2 \\<in> {0<..<1}; Re (h t1) \\<le> Re z;\n         Re z \\<le> Re (h t2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)) \\<Longrightarrow>\n    False", "have False when \"t1\\<le>t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"continuous_on {t1..t2} (\\<lambda>t. Re (h t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {t1..t2} (\\<lambda>t. Re (h t))", "using valid_path_imp_path[OF \\<open>valid_path h\\<close>] t"], ["proof (prove)\nusing this:\n  path h\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t1..t2} (\\<lambda>t. Re (h t))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} h\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t1..t2} (\\<lambda>t. Re (h t))", "by (metis (full_types) atLeastatMost_subset_iff continuous_on_Re continuous_on_subset \n            eucl_less_le_not_le greaterThanLessThan_iff)"], ["proof (state)\nthis:\n  continuous_on {t1..t2} (\\<lambda>t. Re (h t))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {t1..t2} (\\<lambda>t. Re (h t))", "obtain t' where t':\"t'\\<ge>t1\" \"t'\\<le>t2\" \"Re (h t') = Re z\""], ["proof (prove)\nusing this:\n  continuous_on {t1..t2} (\\<lambda>t. Re (h t))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t1 \\<le> t'; t' \\<le> t2; Re (h t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  IVT'[of \"\\<lambda>t. Re (h t)\" t1 _ t2] t \\<open>t1\\<le>t2\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {t1..t2} (\\<lambda>t. Re (h t))\n  \\<lbrakk>Re (h t1) \\<le> ?y; ?y \\<le> Re (h t2); t1 \\<le> t2;\n   continuous_on {t1..t2} (\\<lambda>t. Re (h t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<ge>t1. x \\<le> t2 \\<and> Re (h x) = ?y\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n  t1 \\<le> t2\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t1 \\<le> t'; t' \\<le> t2; Re (h t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (h t') = Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (h t') = Re z", "have \"t'\\<in>{0<..<1}\""], ["proof (prove)\nusing this:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (h t') = Re z\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "using t"], ["proof (prove)\nusing this:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (h t') = Re z\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {0<..<1}", "have \"Re (h t') \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. Re (h t') \\<noteq> Re z", "using Re_neq"], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n  \\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. Re (h t') \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (h t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Re (h t') \\<noteq> Re z", "show False"], ["proof (prove)\nusing this:\n  Re (h t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Re (h t') = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (h t') \\<noteq> Re z\n  Re (h t') = Re z\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t1 \\<le> t2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  t1 \\<le> t2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)) \\<Longrightarrow>\n    False", "have False when \"t1\\<ge>t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"continuous_on {t2..t1} (\\<lambda>t. Re (h t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {t2..t1} (\\<lambda>t. Re (h t))", "using valid_path_imp_path[OF \\<open>valid_path h\\<close>] t"], ["proof (prove)\nusing this:\n  path h\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t2..t1} (\\<lambda>t. Re (h t))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} h\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t2..t1} (\\<lambda>t. Re (h t))", "by (metis (full_types) atLeastatMost_subset_iff continuous_on_Re continuous_on_subset \n            eucl_less_le_not_le greaterThanLessThan_iff)"], ["proof (state)\nthis:\n  continuous_on {t2..t1} (\\<lambda>t. Re (h t))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {t2..t1} (\\<lambda>t. Re (h t))", "obtain t' where t':\"t'\\<le>t1\" \"t'\\<ge>t2\" \"Re (h t') = Re z\""], ["proof (prove)\nusing this:\n  continuous_on {t2..t1} (\\<lambda>t. Re (h t))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<le> t1; t2 \\<le> t'; Re (h t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  IVT2'[of \"\\<lambda>t. Re (h t)\" t1 _ t2] t \\<open>t1\\<ge>t2\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {t2..t1} (\\<lambda>t. Re (h t))\n  \\<lbrakk>Re (h t1) \\<le> ?y; ?y \\<le> Re (h t2); t2 \\<le> t1;\n   continuous_on {t2..t1} (\\<lambda>t. Re (h t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<ge>t2. x \\<le> t1 \\<and> Re (h x) = ?y\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n  t2 \\<le> t1\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<le> t1; t2 \\<le> t'; Re (h t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (h t') = Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (h t') = Re z", "have \"t'\\<in>{0<..<1}\""], ["proof (prove)\nusing this:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (h t') = Re z\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "using t"], ["proof (prove)\nusing this:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (h t') = Re z\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (h t1) \\<le> Re z\n  Re z \\<le> Re (h t2)\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {0<..<1}", "have \"Re (h t') \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. Re (h t') \\<noteq> Re z", "using Re_neq"], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n  \\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. Re (h t') \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (h t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Re (h t') \\<noteq> Re z", "show False"], ["proof (prove)\nusing this:\n  Re (h t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Re (h t') = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (h t') \\<noteq> Re z\n  Re (h t') = Re z\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t2 \\<le> t1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  t1 \\<le> t2 \\<Longrightarrow> False\n  t2 \\<le> t1 \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  t1 \\<le> t2 \\<Longrightarrow> False\n  t2 \\<le> t1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (h t) \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (h t) \\<Longrightarrow>\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (h t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (h t) < Re z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z", "by blast"], ["proof (state)\nthis:\n  2 * Re (winding_number h z) = jumpF_pathfinish h z - jumpF_pathstart h z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>{0<..<1}. Re (?h t) \\<noteq> Re z;\n   Re (?h 0) = Re z; Re (?h 1) = Re z; valid_path ?h;\n   z \\<notin> path_image ?h\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number ?h z) =\n                    jumpF_pathfinish ?h z - jumpF_pathstart ?h z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have index_ends:\"cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z\"\n    when Re_neq:\"\\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\" and \"valid_path h\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "define f where \"f = (\\<lambda>t. Im (h t - z) / Re (h t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (h t - z) / Re (h t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "define Ri where \"Ri = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\""], ["proof (state)\nthis:\n  Ri = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "define Le where \"Le = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\""], ["proof (state)\nthis:\n  Le = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"path h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path h", "using \\<open>valid_path h\\<close> valid_path_imp_path"], ["proof (prove)\nusing this:\n  valid_path h\n  valid_path ?g \\<Longrightarrow> path ?g\n\ngoal (1 subgoal):\n 1. path h", "by auto"], ["proof (state)\nthis:\n  path h\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have jumpF_eq0: \"jumpF f (at_left x) = 0\" \"jumpF f (at_right x) = 0\" when \"x\\<in>{0<..<1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "have \"Re (h x) \\<noteq> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h x) \\<noteq> Re z", "using  \\<open>\\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\\<close> that"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. Re (h x) \\<noteq> Re z", "by blast"], ["proof (state)\nthis:\n  Re (h x) \\<noteq> Re z\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  Re (h x) \\<noteq> Re z", "have \"isCont f x\""], ["proof (prove)\nusing this:\n  Re (h x) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. isCont f x", "unfolding f_def"], ["proof (prove)\nusing this:\n  Re (h x) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (h t - z) / Re (h t - z)) x", "using continuous_on_interior[OF \\<open>path h\\<close>[unfolded path_def]] that"], ["proof (prove)\nusing this:\n  Re (h x) \\<noteq> Re z\n  ?x \\<in> interior {0..1} \\<Longrightarrow> isCont h ?x\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (h t - z) / Re (h t - z)) x", "by (auto intro!: continuous_intros isCont_Im isCont_Re)"], ["proof (state)\nthis:\n  isCont f x\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  isCont f x", "show \"jumpF f (at_left x) = 0\" \"jumpF f (at_right x) = 0\""], ["proof (prove)\nusing this:\n  isCont f x\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "unfolding continuous_at_split"], ["proof (prove)\nusing this:\n  continuous (at_left x) f \\<and> continuous (at_right x) f\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "by (auto intro: jumpF_not_infinity)"], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"cindex_pathE h z  = cindexE 0 1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h z = cindexE 0 1 f", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (h t - z) / Re (h t - z)) =\n    cindexE 0 1 (\\<lambda>t. Im (h t - z) / Re (h t - z))", "by simp"], ["proof (state)\nthis:\n  cindex_pathE h z = cindexE 0 1 f\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "also"], ["proof (state)\nthis:\n  cindex_pathE h z = cindexE 0 1 f\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"... = sum (\\<lambda>x. jumpF f (at_right x)) Ri - sum (\\<lambda>x. jumpF f (at_left x)) Le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 f =\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x))", "unfolding cindexE_def Ri_def Le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF f (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 f =\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "also"], ["proof (state)\nthis:\n  cindexE 0 1 f =\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"... = jumpF f (at_right 0) -  jumpF f (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "have \"sum (\\<lambda>x. jumpF f (at_right x)) Ri = jumpF f (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "proof (cases \"jumpF f (at_right 0) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "case True"], ["proof (state)\nthis:\n  jumpF f (at_right 0) = 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence False if \"x \\<in> Ri\" for x"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) = 0\n  x \\<in> Ri\n\ngoal (1 subgoal):\n 1. False", "by (cases \"x = 0\") (auto simp: jumpF_eq0 Ri_def)"], ["proof (state)\nthis:\n  ?x \\<in> Ri \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence \"Ri = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> Ri \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Ri = {}", "by blast"], ["proof (state)\nthis:\n  Ri = {}\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "then"], ["proof (chain)\npicking this:\n  Ri = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Ri = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "using True"], ["proof (prove)\nusing this:\n  Ri = {}\n  jumpF f (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "case False"], ["proof (state)\nthis:\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence \"x \\<in> Ri \\<longleftrightarrow> x = 0\" for x"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x \\<in> Ri) = (x = 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) \\<noteq> 0\n  \\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\n  valid_path h\n\ngoal (1 subgoal):\n 1. (x \\<in> Ri) = (x = 0)", "by (cases \"x = 0\") (auto simp: jumpF_eq0 Ri_def)"], ["proof (state)\nthis:\n  (?x \\<in> Ri) = (?x = 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence \"Ri = {0}\""], ["proof (prove)\nusing this:\n  (?x \\<in> Ri) = (?x = 0)\n\ngoal (1 subgoal):\n 1. Ri = {0}", "by blast"], ["proof (state)\nthis:\n  Ri = {0}\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "then"], ["proof (chain)\npicking this:\n  Ri = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  Ri = {0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "have \"sum (\\<lambda>x. jumpF f (at_left x)) Le = jumpF f (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "proof (cases \"jumpF f (at_left 1) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "case True"], ["proof (state)\nthis:\n  jumpF f (at_left 1) = 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_left 1) = 0", "have \"Le = {}\""], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. Le = {}", "unfolding Le_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "using jumpF_eq0(1) greaterThanLessThan_iff"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  (?i \\<in> {?l<..<?u}) = (?l < ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "by fastforce"], ["proof (state)\nthis:\n  Le = {}\n\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  Le = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Le = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "using True"], ["proof (prove)\nusing this:\n  Le = {}\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "case False"], ["proof (state)\nthis:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_left 1) \\<noteq> 0", "have \"Le = {1}\""], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Le = {1}", "unfolding Le_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {1}", "using jumpF_eq0(1) greaterThanLessThan_iff"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  (?i \\<in> {?l<..<?u}) = (?l < ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {1}", "by fastforce"], ["proof (state)\nthis:\n  Le = {1}\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  Le = {1}", "show ?thesis"], ["proof (prove)\nusing this:\n  Le = {1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n  jumpF f (at_right 0) - jumpF f (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n  jumpF f (at_right 0) - jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n  jumpF f (at_right 0) - jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"... = jumpF_pathstart h z - jumpF_pathfinish h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) - jumpF f (at_left 1) =\n    jumpF_pathstart h z - jumpF_pathfinish h z", "unfolding jumpF_pathstart_def jumpF_pathfinish_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_right 0) -\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_left 1) =\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_right 0) -\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_left 1)", "by simp"], ["proof (state)\nthis:\n  jumpF f (at_right 0) - jumpF f (at_left 1) =\n  jumpF_pathstart h z - jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "."], ["proof (state)\nthis:\n  cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>{0<..<1}. Re (?h t) \\<noteq> Re z;\n   valid_path ?h\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE ?h z =\n                    jumpF_pathstart ?h z - jumpF_pathfinish ?h z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have ?case when \"s=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"2 * Re (winding_number g z) = jumpF_pathfinish g z - jumpF_pathstart g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = jumpF_pathfinish g z - jumpF_pathstart g z", "apply (rule Re_winding)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>t\\<in>{0<..<1}. Re (g t) \\<noteq> Re z\n 2. Re (g 0) = Re z\n 3. Re (g 1) = Re z\n 4. valid_path g\n 5. z \\<notin> path_image g", "using subNEq that"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s) = Re z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  finite_ReZ_segments (subpath 0 s g) z\n  \\<lbrakk>valid_path (subpath 0 s g);\n   z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n   Re (subpath 0 s g 0) = Re z\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                    - cindex_pathE (subpath 0 s g) z\n  valid_path g\n  z \\<notin> path_image g\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n  s = 0\n\ngoal (5 subgoals):\n 1. \\<forall>t\\<in>{0<..<1}. Re (g t) \\<noteq> Re z\n 2. Re (g 0) = Re z\n 3. Re (g 1) = Re z\n 4. valid_path g\n 5. z \\<notin> path_image g", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = jumpF_pathfinish g z - jumpF_pathstart g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = jumpF_pathfinish g z - jumpF_pathstart g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z", "apply (rule index_ends)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0<..<1}. Re (g t) \\<noteq> Re z\n 2. valid_path g", "using subNEq that"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s) = Re z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  finite_ReZ_segments (subpath 0 s g) z\n  \\<lbrakk>valid_path (subpath 0 s g);\n   z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n   Re (subpath 0 s g 0) = Re z\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                    - cindex_pathE (subpath 0 s g) z\n  valid_path g\n  z \\<notin> path_image g\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n  s = 0\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0<..<1}. Re (g t) \\<noteq> Re z\n 2. valid_path g", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g z) = jumpF_pathfinish g z - jumpF_pathstart g z\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g z) = jumpF_pathfinish g z - jumpF_pathstart g z\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "have ?case when \"s\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define g1 where \"g1 = subpath 0 s g\""], ["proof (state)\nthis:\n  g1 = subpath 0 s g\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define g2 where \"g2 = subpath s 1 g\""], ["proof (state)\nthis:\n  g2 = subpath s 1 g\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"path g\" \"s>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g &&& 0 < s", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>] that \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  path g\n  s \\<noteq> 0\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. path g &&& 0 < s", "by auto"], ["proof (state)\nthis:\n  path g\n  0 < s\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"2 * Re (winding_number g z) = 2*Re (winding_number g1 z) + 2*Re (winding_number g2 z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) =\n    2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)", "apply (subst winding_number_subpath_combine[OF \\<open>path g\\<close> \\<open>z\\<notin>path_image g\\<close>,of 0 s 1\n            ,simplified,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> s \\<and> s \\<le> 1\n 2. 2 *\n    Re (winding_number (subpath 0 s g) z +\n        winding_number (subpath s 1 g) z) =\n    2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (2 subgoals):\n 1. 0 \\<le> s \\<and> s \\<le> 1\n 2. 2 *\n    Re (winding_number (subpath 0 s g) z +\n        winding_number (subpath s 1 g) z) =\n    2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)", "unfolding g1_def g2_def"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (2 subgoals):\n 1. 0 \\<le> s \\<and> s \\<le> 1\n 2. 2 *\n    Re (winding_number (subpath 0 s g) z +\n        winding_number (subpath s 1 g) z) =\n    2 * Re (winding_number (subpath 0 s g) z) +\n    2 * Re (winding_number (subpath s 1 g) z)", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) =\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "also"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) =\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"... = - cindex_pathE g1 z - cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "have \"2*Re (winding_number g1 z) = - cindex_pathE g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) = - cindex_pathE g1 z", "unfolding g1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (subpath 0 s g) z) =\n    - cindex_pathE (subpath 0 s g) z", "apply (rule subNEq.hyps(5))"], ["proof (prove)\ngoal (4 subgoals):\n 1. valid_path (subpath 0 s g)\n 2. z \\<notin> path_image (subpath 0 s g)\n 3. Re (subpath 0 s g 1) = Re z\n 4. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (subpath 0 s g)", "using subNEq.hyps(1) subNEq.prems(1) valid_path_subpath"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n  valid_path g\n  \\<lbrakk>valid_path ?g; ?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> valid_path (subpath ?u ?v ?g)\n\ngoal (1 subgoal):\n 1. valid_path (subpath 0 s g)", "by fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. z \\<notin> path_image (subpath 0 s g)\n 2. Re (subpath 0 s g 1) = Re z\n 3. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image (subpath 0 s g)", "by (meson Path_Connected.path_image_subpath_subset atLeastAtMost_iff \n            atLeastLessThan_iff less_eq_real_def subNEq(7) subNEq.hyps(1) subNEq.prems(1) \n            subsetCE valid_path_imp_path zero_le_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re (subpath 0 s g 1) = Re z\n 2. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath 0 s g 1) = Re z", "by (metis Groups.add_ac(2) add_0_left diff_zero mult.right_neutral subNEq(2) \n            subNEq(9) subpath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath 0 s g 0) = Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath 0 s g 0) = Re z", "by (simp add: subNEq.prems(4) subpath_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "have \"2*Re (winding_number g2 z) = - cindex_pathE g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "have *:\"\\<forall>t\\<in>{0<..<1}. Re (g2 t) \\<noteq> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0<..<1}. Re (g2 t) \\<noteq> Re z", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) \\<noteq> Re z", "fix t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) \\<noteq> Re z", "assume \"t \\<in> {0<..<1}\""], ["proof (state)\nthis:\n  t \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) \\<noteq> Re z", "define t' where \"t'=(1 - s) * t + s\""], ["proof (state)\nthis:\n  t' = (1 - s) * t + s\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) \\<noteq> Re z", "have \"t'\\<in>{s<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in> {s<..<1}", "unfolding t'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - s) * t + s \\<in> {s<..<1}", "using \\<open>s\\<in>{0..<1}\\<close> \\<open>t \\<in> {0<..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n  t \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (1 - s) * t + s \\<in> {s<..<1}", "apply (auto simp add:algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> s; s < 1; 0 < t; t < 1\\<rbrakk>\n    \\<Longrightarrow> s + t < 1 + s * t", "by (sos \"((((A<0 * (A<1 * A<2)) * R<1) + ((A<=1 * (A<1 * R<1)) * (R<1 * [1]^2))))\")"], ["proof (state)\nthis:\n  t' \\<in> {s<..<1}\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) \\<noteq> Re z", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {s<..<1}", "have \"Re (g t') \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  t' \\<in> {s<..<1}\n\ngoal (1 subgoal):\n 1. Re (g t') \\<noteq> Re z", "using \\<open>\\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> {s<..<1}\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. Re (g t') \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (g t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {0<..<1} \\<Longrightarrow> Re (g2 t) \\<noteq> Re z", "then"], ["proof (chain)\npicking this:\n  Re (g t') \\<noteq> Re z", "show \"Re (g2 t) \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  Re (g t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. Re (g2 t) \\<noteq> Re z", "unfolding g2_def subpath_def t'_def"], ["proof (prove)\nusing this:\n  Re (g ((1 - s) * t + s)) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. Re (g ((1 - s) * t + s)) \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (g2 t) \\<noteq> Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re (g2 t) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "have \"2*Re (winding_number g2 z) = jumpF_pathfinish g2 z - jumpF_pathstart g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) =\n    jumpF_pathfinish g2 z - jumpF_pathstart g2 z", "apply (rule Re_winding[OF *])"], ["proof (prove)\ngoal (4 subgoals):\n 1. Re (g2 0) = Re z\n 2. Re (g2 1) = Re z\n 3. valid_path g2\n 4. z \\<notin> path_image g2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g2 0) = Re z", "by (metis add.commute add.right_neutral g2_def mult_zero_right subNEq.hyps(2) \n                subpath_def that)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Re (g2 1) = Re z\n 2. valid_path g2\n 3. z \\<notin> path_image g2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g2 1) = Re z", "by (simp add: \\<open>g2 \\<equiv> subpath s 1 g\\<close> subNEq.prems(3) subpath_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path g2\n 2. z \\<notin> path_image g2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path g2", "using g2_def subNEq.hyps(1) subNEq.prems(1) valid_path_subpath"], ["proof (prove)\nusing this:\n  g2 = subpath s 1 g\n  s \\<in> {0..<1}\n  valid_path g\n  \\<lbrakk>valid_path ?g; ?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> valid_path (subpath ?u ?v ?g)\n\ngoal (1 subgoal):\n 1. valid_path g2", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image g2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image g2", "by (metis (no_types, hide_lams) Path_Connected.path_image_subpath_subset \n                \\<open>path g\\<close> atLeastAtMost_iff atLeastLessThan_iff g2_def less_eq_real_def subNEq.hyps(1) \n                subNEq.prems(2) subsetCE zero_le_one)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 z) =\n  jumpF_pathfinish g2 z - jumpF_pathstart g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 z) =\n  jumpF_pathfinish g2 z - jumpF_pathstart g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "have \"cindex_pathE g2 z = jumpF_pathstart g2 z - jumpF_pathfinish g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g2 z = jumpF_pathstart g2 z - jumpF_pathfinish g2 z", "apply (rule index_ends[OF *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path g2", "using g2_def subNEq.hyps(1) subNEq.prems(1) valid_path_subpath"], ["proof (prove)\nusing this:\n  g2 = subpath s 1 g\n  s \\<in> {0..<1}\n  valid_path g\n  \\<lbrakk>valid_path ?g; ?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> valid_path (subpath ?u ?v ?g)\n\ngoal (1 subgoal):\n 1. valid_path g2", "by fastforce"], ["proof (state)\nthis:\n  cindex_pathE g2 z = jumpF_pathstart g2 z - jumpF_pathfinish g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g2 z) =\n  jumpF_pathfinish g2 z - jumpF_pathstart g2 z\n  cindex_pathE g2 z = jumpF_pathstart g2 z - jumpF_pathfinish g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g2 z) =\n  jumpF_pathfinish g2 z - jumpF_pathstart g2 z\n  cindex_pathE g2 z = jumpF_pathstart g2 z - jumpF_pathfinish g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g1 z) = - cindex_pathE g1 z\n  2 * Re (winding_number g2 z) = - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n    - cindex_pathE g1 z - cindex_pathE g2 z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n  - cindex_pathE g1 z - cindex_pathE g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n  - cindex_pathE g1 z - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "also"], ["proof (state)\nthis:\n  2 * Re (winding_number g1 z) + 2 * Re (winding_number g2 z) =\n  - cindex_pathE g1 z - cindex_pathE g2 z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"... = - cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "have \"finite_ReZ_segments g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g z", "unfolding finite_ReZ_segments_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 1", "apply (rule finite_Psegments.insertI_2[of s])"], ["proof (prove)\ngoal (4 subgoals):\n 1. s \\<in> {0..<1}\n 2. s = 0 \\<or> Re (g s - z) = 0\n 3. \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0\n 4. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {0..<1}", "using \\<open>s \\<in> {0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. s \\<in> {0..<1}", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. s = 0 \\<or> Re (g s - z) = 0\n 2. \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0\n 3. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = 0 \\<or> Re (g s - z) = 0", "using \\<open>s = 0 \\<or> Re (g s) = Re z\\<close>"], ["proof (prove)\nusing this:\n  s = 0 \\<or> Re (g s) = Re z\n\ngoal (1 subgoal):\n 1. s = 0 \\<or> Re (g s - z) = 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0\n 2. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0", "using \\<open>\\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{s<..<1}. Re (g t - z) \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "have \"finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1", "using \\<open>finite_ReZ_segments (subpath 0 s g) z\\<close>"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1", "unfolding subpath_def finite_ReZ_segments_def"], ["proof (prove)\nusing this:\n  finite_Psegments (\\<lambda>t. Re (g ((s - 0) * t + 0) - z) = 0) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g (s * t)) = Re z) 0 1\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "from finite_Psegments_pos_linear[of _ \"1/s\" 0 0 s,simplified,OF this]"], ["proof (chain)\npicking this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g (s * t)) = Re z) \\<circ> (\\<lambda>t. t / s)) 0 s", "show \"finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\""], ["proof (prove)\nusing this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g (s * t)) = Re z) \\<circ> (\\<lambda>t. t / s)) 0 s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "using \\<open>s>0\\<close>"], ["proof (prove)\nusing this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments\n   ((\\<lambda>t. Re (g (s * t)) = Re z) \\<circ> (\\<lambda>t. t / s)) 0 s\n  0 < s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "unfolding comp_def"], ["proof (prove)\nusing this:\n  0 < s \\<Longrightarrow>\n  finite_Psegments (\\<lambda>x. Re (g (s * (x / s))) = Re z) 0 s\n  0 < s\n\ngoal (1 subgoal):\n 1. finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s", "by auto"], ["proof (state)\nthis:\n  finite_Psegments (\\<lambda>t. Re (g t - z) = 0) 0 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite_ReZ_segments g z\n\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "then"], ["proof (chain)\npicking this:\n  finite_ReZ_segments g z", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "using cindex_pathE_subpath_combine[OF _ \\<open>path g\\<close>,of z 0 s 1,folded g1_def g2_def,simplified]\n          \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  finite_ReZ_segments g z\n  \\<lbrakk>finite_ReZ_segments g z; 0 \\<le> s; s \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE g1 z + cindex_pathE g2 z = cindex_pathE g z\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - cindex_pathE g1 z - cindex_pathE g2 z = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "finally"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g z) = - cindex_pathE g z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "."], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s g z.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z;\n        \\<lbrakk>valid_path (subpath 0 s g);\n         z \\<notin> path_image (subpath 0 s g); Re (subpath 0 s g 1) = Re z;\n         Re (subpath 0 s g 0) = Re z\\<rbrakk>\n        \\<Longrightarrow> 2 * Re (winding_number (subpath 0 s g) z) =\n                          - cindex_pathE (subpath 0 s g) z;\n        valid_path g; z \\<notin> path_image g; Re (g 1) = Re z;\n        Re (g 0) = Re z\\<rbrakk>\n       \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z", "show ?case"], ["proof (prove)\nusing this:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem winding_number_cindex_pathE:\n  fixes g::\"real \\<Rightarrow> complex\"\n  assumes \"finite_ReZ_segments g z\" and \"valid_path g\" \"z \\<notin> path_image g\" and\n    loop: \"pathfinish g = pathstart g\"\n  shows \"winding_number g z = - cindex_pathE g z / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number g z = complex_of_real (- cindex_pathE g z / 2)", "proof (rule finite_ReZ_segment_cases[OF assms(1)])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "assume \"s \\<in> {0..<1}\" \"s = 0 \\<or> Re (g s) = Re z\" \n          and const:\"\\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\" \n          and finite:\"finite_ReZ_segments (subpath 0 s g) z\""], ["proof (state)\nthis:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s) = Re z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "have \"Re (g 1) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g 1) = Re z", "apply(rule continuous_constant_on_closure[of \"{s<..<1}\" \"\\<lambda>t. Re(g t)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on (closure {s<..<1}) (\\<lambda>t. Re (g t))\n 2. \\<And>x. x \\<in> {s<..<1} \\<Longrightarrow> Re (g x) = Re z\n 3. 1 \\<in> closure {s<..<1}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (closure {s<..<1}) (\\<lambda>t. Re (g t))", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>,unfolded path_def] \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. continuous_on (closure {s<..<1}) (\\<lambda>t. Re (g t))", "by (auto intro!:continuous_intros continuous_Re elim:continuous_on_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {s<..<1} \\<Longrightarrow> Re (g x) = Re z\n 2. 1 \\<in> closure {s<..<1}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> {s<..<1} \\<Longrightarrow> Re (g x_) = Re z", "using const"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z\n\ngoal (1 subgoal):\n 1. x_ \\<in> {s<..<1} \\<Longrightarrow> Re (g x_) = Re z", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> closure {s<..<1}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> closure {s<..<1}", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. 1 \\<in> closure {s<..<1}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (g 1) = Re z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "moreover"], ["proof (state)\nthis:\n  Re (g 1) = Re z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "then"], ["proof (chain)\npicking this:\n  Re (g 1) = Re z", "have \"Re (g 0) = Re z\""], ["proof (prove)\nusing this:\n  Re (g 1) = Re z\n\ngoal (1 subgoal):\n 1. Re (g 0) = Re z", "using loop"], ["proof (prove)\nusing this:\n  Re (g 1) = Re z\n  pathfinish g = pathstart g\n\ngoal (1 subgoal):\n 1. Re (g 0) = Re z", "unfolding path_defs"], ["proof (prove)\nusing this:\n  Re (g 1) = Re z\n  g 1 = g 0\n\ngoal (1 subgoal):\n 1. Re (g 0) = Re z", "by auto"], ["proof (state)\nthis:\n  Re (g 0) = Re z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "ultimately"], ["proof (chain)\npicking this:\n  Re (g 1) = Re z\n  Re (g 0) = Re z", "have \"2 * Re (winding_number g z) = - cindex_pathE g z\""], ["proof (prove)\nusing this:\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "using winding_number_cindex_pathE_aux[of g z] assms(1-3)"], ["proof (prove)\nusing this:\n  Re (g 1) = Re z\n  Re (g 0) = Re z\n  \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n   Re (g 1) = Re z; Re (g 0) = Re z\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  finite_ReZ_segments g z\n  valid_path g\n  z \\<notin> path_image g\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "have \"winding_number g z \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number g z \\<in> \\<int>", "using integer_winding_number[OF _ loop \\<open>z\\<notin>path_image g\\<close>] valid_path_imp_path[OF \\<open>valid_path g\\<close>]"], ["proof (prove)\nusing this:\n  path g \\<Longrightarrow> winding_number g z \\<in> \\<int>\n  path g\n\ngoal (1 subgoal):\n 1. winding_number g z \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  winding_number g z \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) = Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n  winding_number g z \\<in> \\<int>", "show \"winding_number g z = - cindex_pathE g z / 2\""], ["proof (prove)\nusing this:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n  winding_number g z \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. winding_number g z = complex_of_real (- cindex_pathE g z / 2)", "by (metis add.right_neutral complex_eq complex_is_Int_iff mult_zero_right \n        nonzero_mult_div_cancel_left of_real_0 zero_neq_numeral)"], ["proof (state)\nthis:\n  winding_number g z = complex_of_real (- cindex_pathE g z / 2)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "assume \"s \\<in> {0..<1}\" \"s = 0 \\<or> Re (g s) = Re z\"\n          and Re_neq:\"\\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\" \n          and finite:\"finite_ReZ_segments (subpath 0 s g) z\""], ["proof (state)\nthis:\n  s \\<in> {0..<1}\n  s = 0 \\<or> Re (g s) = Re z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  finite_ReZ_segments (subpath 0 s g) z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "have \"path g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g", "using \\<open>valid_path g\\<close> valid_path_imp_path"], ["proof (prove)\nusing this:\n  valid_path g\n  valid_path ?g \\<Longrightarrow> path ?g\n\ngoal (1 subgoal):\n 1. path g", "by auto"], ["proof (state)\nthis:\n  path g\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "let ?goal = \"2 * Re (winding_number g z) = - cindex_pathE g z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "have ?goal when \"s=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have index_ends:\"cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z\"\n      when Re_neq:\"\\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\" and \"valid_path h\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "define f where \"f = (\\<lambda>t. Im (h t - z) / Re (h t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (h t - z) / Re (h t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "define Ri where \"Ri = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\""], ["proof (state)\nthis:\n  Ri = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "define Le where \"Le = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\""], ["proof (state)\nthis:\n  Le = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"path h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path h", "using \\<open>valid_path h\\<close> valid_path_imp_path"], ["proof (prove)\nusing this:\n  valid_path h\n  valid_path ?g \\<Longrightarrow> path ?g\n\ngoal (1 subgoal):\n 1. path h", "by auto"], ["proof (state)\nthis:\n  path h\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have jumpF_eq0: \"jumpF f (at_left x) = 0\" \"jumpF f (at_right x) = 0\" when \"x\\<in>{0<..<1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "have \"Re (h x) \\<noteq> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h x) \\<noteq> Re z", "using  \\<open>\\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\\<close> that"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. Re (h x) \\<noteq> Re z", "by blast"], ["proof (state)\nthis:\n  Re (h x) \\<noteq> Re z\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  Re (h x) \\<noteq> Re z", "have \"isCont f x\""], ["proof (prove)\nusing this:\n  Re (h x) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. isCont f x", "unfolding f_def"], ["proof (prove)\nusing this:\n  Re (h x) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (h t - z) / Re (h t - z)) x", "using continuous_on_interior[OF \\<open>path h\\<close>[unfolded path_def]] that"], ["proof (prove)\nusing this:\n  Re (h x) \\<noteq> Re z\n  ?x \\<in> interior {0..1} \\<Longrightarrow> isCont h ?x\n  x \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (h t - z) / Re (h t - z)) x", "by (auto intro!: continuous_intros isCont_Im isCont_Re)"], ["proof (state)\nthis:\n  isCont f x\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  isCont f x", "show \"jumpF f (at_left x) = 0\" \"jumpF f (at_right x) = 0\""], ["proof (prove)\nusing this:\n  isCont f x\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "unfolding continuous_at_split"], ["proof (prove)\nusing this:\n  continuous (at_left x) f \\<and> continuous (at_right x) f\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "by (auto intro: jumpF_not_infinity)"], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"cindex_pathE h z  = cindexE 0 1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h z = cindexE 0 1 f", "unfolding cindex_pathE_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (h t - z) / Re (h t - z)) =\n    cindexE 0 1 (\\<lambda>t. Im (h t - z) / Re (h t - z))", "by simp"], ["proof (state)\nthis:\n  cindex_pathE h z = cindexE 0 1 f\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "also"], ["proof (state)\nthis:\n  cindex_pathE h z = cindexE 0 1 f\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"... = sum (\\<lambda>x. jumpF f (at_right x)) Ri - sum (\\<lambda>x. jumpF f (at_left x)) Le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 f =\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x))", "unfolding cindexE_def Ri_def Le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF f (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 f =\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "also"], ["proof (state)\nthis:\n  cindexE 0 1 f =\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"... = jumpF f (at_right 0) -  jumpF f (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "have \"sum (\\<lambda>x. jumpF f (at_right x)) Ri = jumpF f (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "proof (cases \"jumpF f (at_right 0) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "case True"], ["proof (state)\nthis:\n  jumpF f (at_right 0) = 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence False if \"x \\<in> Ri\" for x"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) = 0\n  x \\<in> Ri\n\ngoal (1 subgoal):\n 1. False", "by (cases \"x = 0\") (auto simp: jumpF_eq0 Ri_def)"], ["proof (state)\nthis:\n  ?x \\<in> Ri \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence \"Ri = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> Ri \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Ri = {}", "by blast"], ["proof (state)\nthis:\n  Ri = {}\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "then"], ["proof (chain)\npicking this:\n  Ri = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Ri = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "using True"], ["proof (prove)\nusing this:\n  Ri = {}\n  jumpF f (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "case False"], ["proof (state)\nthis:\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "hence \"x \\<in> Ri \\<longleftrightarrow> x = 0\" for x"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x \\<in> Ri) = (x = 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) \\<noteq> 0\n  \\<forall>t\\<in>{0<..<1}. Re (h t) \\<noteq> Re z\n  valid_path h\n\ngoal (1 subgoal):\n 1. (x \\<in> Ri) = (x = 0)", "by (cases \"x = 0\") (auto simp: jumpF_eq0 Ri_def)"], ["proof (state)\nthis:\n  (?x \\<in> Ri) = (?x = 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "then"], ["proof (chain)\npicking this:\n  (?x \\<in> Ri) = (?x = 0)", "have \"Ri = {0}\""], ["proof (prove)\nusing this:\n  (?x \\<in> Ri) = (?x = 0)\n\ngoal (1 subgoal):\n 1. Ri = {0}", "by blast"], ["proof (state)\nthis:\n  Ri = {0}\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "then"], ["proof (chain)\npicking this:\n  Ri = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  Ri = {0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "have \"sum (\\<lambda>x. jumpF f (at_left x)) Le = jumpF f (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "proof (cases \"jumpF f (at_left 1) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "case True"], ["proof (state)\nthis:\n  jumpF f (at_left 1) = 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_left 1) = 0", "have \"Le = {}\""], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. Le = {}", "unfolding Le_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "using jumpF_eq0(1) greaterThanLessThan_iff"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  (?i \\<in> {?l<..<?u}) = (?l < ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "by fastforce"], ["proof (state)\nthis:\n  Le = {}\n\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  Le = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Le = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "using True"], ["proof (prove)\nusing this:\n  Le = {}\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "case False"], ["proof (state)\nthis:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_left 1) \\<noteq> 0", "have \"Le = {1}\""], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Le = {1}", "unfolding Le_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {1}", "using jumpF_eq0(1) greaterThanLessThan_iff"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  (?i \\<in> {?l<..<?u}) = (?l < ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {1}", "by fastforce"], ["proof (state)\nthis:\n  Le = {1}\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "then"], ["proof (chain)\npicking this:\n  Le = {1}", "show ?thesis"], ["proof (prove)\nusing this:\n  Le = {1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) = jumpF f (at_right 0)\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) = jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n    jumpF f (at_right 0) - jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n  jumpF f (at_right 0) - jumpF f (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n  jumpF f (at_right 0) - jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Ri. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>Le. jumpF f (at_left x)) =\n  jumpF f (at_right 0) - jumpF f (at_left 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "have \"... = jumpF_pathstart h z - jumpF_pathfinish h z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) - jumpF f (at_left 1) =\n    jumpF_pathstart h z - jumpF_pathfinish h z", "unfolding jumpF_pathstart_def jumpF_pathfinish_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_right 0) -\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_left 1) =\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_right 0) -\n    jumpF (\\<lambda>t. Im (h t - z) / Re (h t - z)) (at_left 1)", "by simp"], ["proof (state)\nthis:\n  jumpF f (at_right 0) - jumpF f (at_left 1) =\n  jumpF_pathstart h z - jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z\n\ngoal (1 subgoal):\n 1. cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z", "."], ["proof (state)\nthis:\n  cindex_pathE h z = jumpF_pathstart h z - jumpF_pathfinish h z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>{0<..<1}. Re (?h t) \\<noteq> Re z;\n   valid_path ?h\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE ?h z =\n                    jumpF_pathstart ?h z - jumpF_pathfinish ?h z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define fI where \"fI=(\\<lambda>t. Im (g t - z))\""], ["proof (state)\nthis:\n  fI = (\\<lambda>t. Im (g t - z))\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define fR where \"fR=(\\<lambda>t. Re (g t - z))\""], ["proof (state)\nthis:\n  fR = (\\<lambda>t. Re (g t - z))\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have fI: \"(fI \\<longlongrightarrow> fI 0) (at_right 0)\" \"(fI \\<longlongrightarrow> fI 1) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0) &&&\n    (fI \\<longlongrightarrow> fI 1) (at_left 1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. (fI \\<longlongrightarrow> fI 1) (at_left 1)", "have \"continuous (at_right 0) fI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_right 0) fI", "apply (rule continuous_on_at_right[of _ 1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..1} fI\n 2. 0 < 1", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} fI\n 2. 0 < 1", "unfolding fI_def path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. Im (g t - z))\n 2. 0 < 1", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_right 0) fI\n\ngoal (2 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. (fI \\<longlongrightarrow> fI 1) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  continuous (at_right 0) fI", "show \"(fI \\<longlongrightarrow> fI 0) (at_right 0)\""], ["proof (prove)\nusing this:\n  continuous (at_right 0) fI\n\ngoal (1 subgoal):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. (fI \\<longlongrightarrow> fI 1) (at_left 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (fI \\<longlongrightarrow> fI 1) (at_left 1)", "have \"continuous (at_left 1) fI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_left 1) fI", "apply (rule continuous_on_at_left[of 0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..1} fI\n 2. 0 < 1", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} fI\n 2. 0 < 1", "unfolding fI_def path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. Im (g t - z))\n 2. 0 < 1", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_left 1) fI\n\ngoal (1 subgoal):\n 1. (fI \\<longlongrightarrow> fI 1) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  continuous (at_left 1) fI", "show \"(fI \\<longlongrightarrow> fI 1) (at_left 1)\""], ["proof (prove)\nusing this:\n  continuous (at_left 1) fI\n\ngoal (1 subgoal):\n 1. (fI \\<longlongrightarrow> fI 1) (at_left 1)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have fR: \"(fR \\<longlongrightarrow> 0) (at_right 0)\" \"(fR \\<longlongrightarrow> 0) (at_left 1)\" when \"Re (g 0) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_right 0) &&&\n    (fR \\<longlongrightarrow> 0) (at_left 1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (fR \\<longlongrightarrow> 0) (at_right 0)\n 2. (fR \\<longlongrightarrow> 0) (at_left 1)", "have \"continuous (at_right 0) fR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_right 0) fR", "apply (rule continuous_on_at_right[of _ 1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..1} fR\n 2. 0 < 1", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} fR\n 2. 0 < 1", "unfolding fR_def path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. Re (g t - z))\n 2. 0 < 1", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_right 0) fR\n\ngoal (2 subgoals):\n 1. (fR \\<longlongrightarrow> 0) (at_right 0)\n 2. (fR \\<longlongrightarrow> 0) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  continuous (at_right 0) fR", "show \"(fR \\<longlongrightarrow> 0) (at_right 0)\""], ["proof (prove)\nusing this:\n  continuous (at_right 0) fR\n\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_right 0)", "using that"], ["proof (prove)\nusing this:\n  continuous (at_right 0) fR\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_right 0)", "unfolding fR_def"], ["proof (prove)\nusing this:\n  continuous (at_right 0) (\\<lambda>t. Re (g t - z))\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Re (g t - z)) \\<longlongrightarrow> 0) (at_right 0)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_left 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_left 1)", "have \"continuous (at_left 1) fR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_left 1) fR", "apply (rule continuous_on_at_left[of 0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..1} fR\n 2. 0 < 1", "using \\<open>path g\\<close>"], ["proof (prove)\nusing this:\n  path g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} fR\n 2. 0 < 1", "unfolding fR_def path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>t. Re (g t - z))\n 2. 0 < 1", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_left 1) fR\n\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  continuous (at_left 1) fR", "show \"(fR \\<longlongrightarrow> 0) (at_left 1)\""], ["proof (prove)\nusing this:\n  continuous (at_left 1) fR\n\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_left 1)", "using that loop"], ["proof (prove)\nusing this:\n  continuous (at_left 1) fR\n  Re (g 0) = Re z\n  pathfinish g = pathstart g\n\ngoal (1 subgoal):\n 1. (fR \\<longlongrightarrow> 0) (at_left 1)", "unfolding fR_def path_defs"], ["proof (prove)\nusing this:\n  continuous (at_left 1) (\\<lambda>t. Re (g t - z))\n  Re (g 0) = Re z\n  g 1 = g 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Re (g t - z)) \\<longlongrightarrow> 0) (at_left 1)", "by (simp add: continuous_within)"], ["proof (state)\nthis:\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g 0) = Re z \\<Longrightarrow>\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  Re (g 0) = Re z \\<Longrightarrow> (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"(\\<forall>t\\<in>{0<..<1}. Re (g t) > Re z) \\<or> (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n    (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)) \\<Longrightarrow>\n    False", "assume \" \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or> (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z))\""], ["proof (state)\nthis:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z))", "obtain t1 t2 where t:\"t1\\<in>{0<..<1}\" \"t2\\<in>{0<..<1}\" \"Re (g t1)\\<le>Re z\" \"Re (g t2)\\<ge>Re z\""], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z))\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<in> {0<..<1}; t2 \\<in> {0<..<1}; Re (g t1) \\<le> Re z;\n         Re z \\<le> Re (g t2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n          (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z))\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<in> {0<..<1}; t2 \\<in> {0<..<1}; Re (g t1) \\<le> Re z;\n         Re z \\<le> Re (g t2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)) \\<Longrightarrow>\n    False", "have False when \"t1\\<le>t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"continuous_on {t1..t2} (\\<lambda>t. Re (g t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {t1..t2} (\\<lambda>t. Re (g t))", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>] t"], ["proof (prove)\nusing this:\n  path g\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t1..t2} (\\<lambda>t. Re (g t))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t1..t2} (\\<lambda>t. Re (g t))", "by (metis (full_types) atLeastatMost_subset_iff continuous_on_Re continuous_on_subset \n            eucl_less_le_not_le greaterThanLessThan_iff)"], ["proof (state)\nthis:\n  continuous_on {t1..t2} (\\<lambda>t. Re (g t))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {t1..t2} (\\<lambda>t. Re (g t))", "obtain t' where t':\"t'\\<ge>t1\" \"t'\\<le>t2\" \"Re (g t') = Re z\""], ["proof (prove)\nusing this:\n  continuous_on {t1..t2} (\\<lambda>t. Re (g t))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t1 \\<le> t'; t' \\<le> t2; Re (g t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  IVT'[of \"\\<lambda>t. Re (g t)\" t1 _ t2] t \\<open>t1\\<le>t2\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {t1..t2} (\\<lambda>t. Re (g t))\n  \\<lbrakk>Re (g t1) \\<le> ?y; ?y \\<le> Re (g t2); t1 \\<le> t2;\n   continuous_on {t1..t2} (\\<lambda>t. Re (g t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<ge>t1. x \\<le> t2 \\<and> Re (g x) = ?y\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n  t1 \\<le> t2\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t1 \\<le> t'; t' \\<le> t2; Re (g t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (g t') = Re z", "have \"t'\\<in>{0<..<1}\""], ["proof (prove)\nusing this:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "using t"], ["proof (prove)\nusing this:\n  t1 \\<le> t'\n  t' \\<le> t2\n  Re (g t') = Re z\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {0<..<1}", "have \"Re (g t') \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. Re (g t') \\<noteq> Re z", "using Re_neq \\<open>s=0\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  s = 0\n\ngoal (1 subgoal):\n 1. Re (g t') \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (g t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Re (g t') \\<noteq> Re z", "show False"], ["proof (prove)\nusing this:\n  Re (g t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Re (g t') = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (g t') \\<noteq> Re z\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t1 \\<le> t2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  t1 \\<le> t2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)) \\<Longrightarrow>\n    False", "have False when \"t1\\<ge>t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"continuous_on {t2..t1} (\\<lambda>t. Re (g t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {t2..t1} (\\<lambda>t. Re (g t))", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>] t"], ["proof (prove)\nusing this:\n  path g\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t2..t1} (\\<lambda>t. Re (g t))", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. continuous_on {t2..t1} (\\<lambda>t. Re (g t))", "by (metis (full_types) atLeastatMost_subset_iff continuous_on_Re continuous_on_subset \n            eucl_less_le_not_le greaterThanLessThan_iff)"], ["proof (state)\nthis:\n  continuous_on {t2..t1} (\\<lambda>t. Re (g t))\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {t2..t1} (\\<lambda>t. Re (g t))", "obtain t' where t':\"t'\\<le>t1\" \"t'\\<ge>t2\" \"Re (g t') = Re z\""], ["proof (prove)\nusing this:\n  continuous_on {t2..t1} (\\<lambda>t. Re (g t))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<le> t1; t2 \\<le> t'; Re (g t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  IVT2'[of \"\\<lambda>t. Re (g t)\" t1 _ t2] t \\<open>t1\\<ge>t2\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {t2..t1} (\\<lambda>t. Re (g t))\n  \\<lbrakk>Re (g t1) \\<le> ?y; ?y \\<le> Re (g t2); t2 \\<le> t1;\n   continuous_on {t2..t1} (\\<lambda>t. Re (g t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<ge>t2. x \\<le> t1 \\<and> Re (g x) = ?y\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n  t2 \\<le> t1\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<le> t1; t2 \\<le> t'; Re (g t') = Re z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (g t') = Re z", "have \"t'\\<in>{0<..<1}\""], ["proof (prove)\nusing this:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "using t"], ["proof (prove)\nusing this:\n  t' \\<le> t1\n  t2 \\<le> t'\n  Re (g t') = Re z\n  t1 \\<in> {0<..<1}\n  t2 \\<in> {0<..<1}\n  Re (g t1) \\<le> Re z\n  Re z \\<le> Re (g t2)\n\ngoal (1 subgoal):\n 1. t' \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t' \\<in> {0<..<1}", "have \"Re (g t') \\<noteq> Re z\""], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. Re (g t') \\<noteq> Re z", "using Re_neq \\<open>s=0\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> {0<..<1}\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  s = 0\n\ngoal (1 subgoal):\n 1. Re (g t') \\<noteq> Re z", "by auto"], ["proof (state)\nthis:\n  Re (g t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Re (g t') \\<noteq> Re z", "show False"], ["proof (prove)\nusing this:\n  Re (g t') \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Re (g t') = Re z\\<close>"], ["proof (prove)\nusing this:\n  Re (g t') \\<noteq> Re z\n  Re (g t') = Re z\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t2 \\<le> t1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n            (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  t1 \\<le> t2 \\<Longrightarrow> False\n  t2 \\<le> t1 \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  t1 \\<le> t2 \\<Longrightarrow> False\n  t2 \\<le> t1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have ?thesis when Re_pos:\"\\<forall>t\\<in>{0<..<1}. Re (g t) > Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"Re (winding_number g z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "have \"\\<forall>p\\<in>path_image g. Re z \\<le> Re p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image g. Re z \\<le> Re p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re z \\<le> Re p", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re z \\<le> Re p", "assume \"p \\<in> path_image g\""], ["proof (state)\nthis:\n  p \\<in> path_image g\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re z \\<le> Re p", "then"], ["proof (chain)\npicking this:\n  p \\<in> path_image g", "obtain t where \"0\\<le>t\" \"t\\<le>1\" \"p = g t\""], ["proof (prove)\nusing this:\n  p \\<in> path_image g\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; t \\<le> 1; p = g t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  p \\<in> g ` {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; t \\<le> 1; p = g t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> t\n  t \\<le> 1\n  p = g t\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re z \\<le> Re p", "have \"Re z \\<le> Re (g t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re z \\<le> Re (g t)", "apply (rule continuous_ge_on_closure[of \"{0<..<1}\" \"\\<lambda>t. Re (g t)\" t \"Re z\",simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {0..1} (\\<lambda>x. Re (g x))\n 2. 0 \\<le> t \\<and> t \\<le> 1\n 3. \\<And>x. 0 < x \\<and> x < 1 \\<Longrightarrow> Re z \\<le> Re (g x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (g x))", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>,unfolded path_def]"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (g x))", "by (auto intro:continuous_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> t \\<and> t \\<le> 1\n 2. \\<And>x. 0 < x \\<and> x < 1 \\<Longrightarrow> Re z \\<le> Re (g x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<and> t \\<le> 1", "using \\<open>0\\<le>t\\<close> \\<open>t\\<le>1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<and> t \\<le> 1", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<and> x < 1 \\<Longrightarrow> Re z \\<le> Re (g x)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1 \\<Longrightarrow> Re z \\<le> Re (g x)", "using that[rule_format,of x]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} \\<Longrightarrow> Re z < Re (g x)\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1 \\<Longrightarrow> Re z \\<le> Re (g x)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re z \\<le> Re (g t)\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re z \\<le> Re p", "then"], ["proof (chain)\npicking this:\n  Re z \\<le> Re (g t)", "show \"Re z \\<le> Re p\""], ["proof (prove)\nusing this:\n  Re z \\<le> Re (g t)\n\ngoal (1 subgoal):\n 1. Re z \\<le> Re p", "using \\<open>p = g t\\<close>"], ["proof (prove)\nusing this:\n  Re z \\<le> Re (g t)\n  p = g t\n\ngoal (1 subgoal):\n 1. Re z \\<le> Re p", "by auto"], ["proof (state)\nthis:\n  Re z \\<le> Re p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>path_image g. Re z \\<le> Re p\n\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "from Re_winding_number_half_right[OF this \\<open>valid_path g\\<close> \\<open>z\\<notin>path_image g\\<close>] loop"], ["proof (chain)\npicking this:\n  Re (winding_number g z) =\n  (Im (Ln (pathfinish g - z)) - Im (Ln (pathstart g - z))) / (2 * pi)\n  pathfinish g = pathstart g", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g z) =\n  (Im (Ln (pathfinish g - z)) - Im (Ln (pathstart g - z))) / (2 * pi)\n  pathfinish g = pathstart g\n\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "by auto"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"cindex_pathE g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "have \"cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z", "using index_ends[OF _ \\<open>valid_path g\\<close>] Re_neq \\<open>s=0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (g t) \\<noteq> Re z \\<Longrightarrow>\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  s = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "moreover"], ["proof (state)\nthis:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "have \"jumpF_pathstart g z = jumpF_pathfinish g z\" when \"Re (g 0) \\<noteq> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathstart g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "using jumpF_pathstart_eq_0[OF \\<open>path g\\<close>] that"], ["proof (prove)\nusing this:\n  Re (pathstart g) \\<noteq> Re ?z \\<Longrightarrow> jumpF_pathstart g ?z = 0\n  Re (g 0) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "unfolding path_defs"], ["proof (prove)\nusing this:\n  Re (g 0) \\<noteq> Re ?z \\<Longrightarrow> jumpF_pathstart g ?z = 0\n  Re (g 0) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathfinish g z=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "using jumpF_pathfinish_eq_0[OF \\<open>path g\\<close>] that loop"], ["proof (prove)\nusing this:\n  Re (pathfinish g) \\<noteq> Re ?z \\<Longrightarrow>\n  jumpF_pathfinish g ?z = 0\n  Re (g 0) \\<noteq> Re z\n  pathfinish g = pathstart g\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "unfolding path_defs"], ["proof (prove)\nusing this:\n  Re (g 1) \\<noteq> Re ?z \\<Longrightarrow> jumpF_pathfinish g ?z = 0\n  Re (g 0) \\<noteq> Re z\n  g 1 = g 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart g z = 0\n  jumpF_pathfinish g z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g z = 0\n  jumpF_pathfinish g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "moreover"], ["proof (state)\nthis:\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "have \"jumpF_pathstart g z = jumpF_pathfinish g z\" when \"Re (g 0) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have [simp]:\"(fR has_sgnx 1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fR has_sgnx 1) (at_right 0)", "unfolding fR_def has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>0.\n       \\<forall>y>0. y < b \\<longrightarrow> sgn (Re (g y - z)) = 1", "apply (rule exI[where x=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = 1)", "using Re_pos"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (g t)\n\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = 1)", "by auto"], ["proof (state)\nthis:\n  (fR has_sgnx 1) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have [simp]:\"(fR has_sgnx 1) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fR has_sgnx 1) (at_left 1)", "unfolding fR_def has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<1.\n       \\<forall>y>b. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = 1", "apply (rule exI[where x=0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = 1)", "using Re_pos"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (g t)\n\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = 1)", "by auto"], ["proof (state)\nthis:\n  (fR has_sgnx 1) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"fI 0\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fI 0 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> fI 0 \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> fI 0 \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> fI 0 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> fI 0 \\<noteq> 0", "have \"g 0 =z\""], ["proof (prove)\nusing this:\n  \\<not> fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g 0 = z", "using \\<open>Re (g 0) = Re z\\<close>"], ["proof (prove)\nusing this:\n  \\<not> fI 0 \\<noteq> 0\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. g 0 = z", "unfolding fI_def"], ["proof (prove)\nusing this:\n  \\<not> Im (g 0 - z) \\<noteq> 0\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. g 0 = z", "by (simp add: complex.expand)"], ["proof (state)\nthis:\n  g 0 = z\n\ngoal (1 subgoal):\n 1. \\<not> fI 0 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g 0 = z", "show False"], ["proof (prove)\nusing this:\n  g 0 = z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z \\<notin> path_image g\\<close>"], ["proof (prove)\nusing this:\n  g 0 = z\n  z \\<notin> path_image g\n\ngoal (1 subgoal):\n 1. False", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  g 0 = z\n  z \\<notin> g ` {0..1}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have ?thesis when \"fI 0>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathstart g z = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "have \"(LIM x at_right 0. fI x / fR x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. fI x / fR x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx sgn (fI 0)) (at_right 0)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  0 < fI 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx sgn (fI 0)) (at_right 0)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_right 0. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. fI x / fR x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_right 0. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "unfolding jumpF_pathstart_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. Im (g x - z) / Re (g x - z) :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathfinish g z = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "have \"fI 1>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < fI 1", "using loop that"], ["proof (prove)\nusing this:\n  pathfinish g = pathstart g\n  0 < fI 0\n\ngoal (1 subgoal):\n 1. 0 < fI 1", "unfolding path_defs fI_def"], ["proof (prove)\nusing this:\n  g 1 = g 0\n  0 < Im (g 0 - z)\n\ngoal (1 subgoal):\n 1. 0 < Im (g 1 - z)", "by auto"], ["proof (state)\nthis:\n  0 < fI 1\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "then"], ["proof (chain)\npicking this:\n  0 < fI 1", "have \"(LIM x at_left 1. fI x / fR x :> at_top)\""], ["proof (prove)\nusing this:\n  0 < fI 1\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. fI x / fR x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < fI 1 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. 0 < fI 1 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. 0 < fI 1 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx sgn (fI 1)) (at_left 1)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  0 < fI 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. 0 < fI 1 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. 0 < fI 1 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. 0 < fI 1 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx sgn (fI 1)) (at_left 1)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_left 1. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. fI x / fR x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left 1. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "unfolding jumpF_pathfinish_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. Im (g x - z) / Re (g x - z) :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart g z = 1 / 2\n  jumpF_pathfinish g z = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g z = 1 / 2\n  jumpF_pathfinish g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by simp"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have ?thesis when \"fI 0<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathstart g z = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "have \"(LIM x at_right 0. fI x / fR x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. fI x / fR x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx - sgn (fI 0)) (at_right 0)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  fI 0 < 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx - sgn (fI 0)) (at_right 0)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_right 0. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. fI x / fR x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_right 0. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "unfolding jumpF_pathstart_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. Im (g x - z) / Re (g x - z) :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathfinish g z = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "have \"fI 1<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fI 1 < 0", "using loop that"], ["proof (prove)\nusing this:\n  pathfinish g = pathstart g\n  fI 0 < 0\n\ngoal (1 subgoal):\n 1. fI 1 < 0", "unfolding path_defs fI_def"], ["proof (prove)\nusing this:\n  g 1 = g 0\n  Im (g 0 - z) < 0\n\ngoal (1 subgoal):\n 1. Im (g 1 - z) < 0", "by auto"], ["proof (state)\nthis:\n  fI 1 < 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  fI 1 < 0", "have \"(LIM x at_left 1. fI x / fR x :> at_bot)\""], ["proof (prove)\nusing this:\n  fI 1 < 0\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. fI x / fR x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. fI 1 < 0 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. fI 1 < 0 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. fI 1 < 0 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx - sgn (fI 1)) (at_left 1)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  fI 0 < 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. fI 1 < 0 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. fI 1 < 0 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. fI 1 < 0 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx - sgn (fI 1)) (at_left 1)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_left 1. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. fI x / fR x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left 1. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "unfolding jumpF_pathfinish_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. Im (g x - z) / Re (g x - z) :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart g z = - 1 / 2\n  jumpF_pathfinish g z = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g z = - 1 / 2\n  jumpF_pathfinish g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by simp"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fI 0 < 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  fI 0 \\<noteq> 0\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n  fI 0 < 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z", "show ?thesis"], ["proof (prove)\nusing this:\n  fI 0 \\<noteq> 0\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n  fI 0 < 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by linarith"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g 0) = Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n  Re (g 0) = Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n  Re (g 0) = Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g z = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number g z) = 0\n  cindex_pathE g z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g z) = 0\n  cindex_pathE g z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (g t) \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (g t) \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have ?thesis when Re_neg:\"\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"Re (winding_number g z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "have \"\\<forall>p\\<in>path_image g. Re z \\<ge> Re p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image g. Re p \\<le> Re z", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re p \\<le> Re z", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re p \\<le> Re z", "assume \"p \\<in> path_image g\""], ["proof (state)\nthis:\n  p \\<in> path_image g\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re p \\<le> Re z", "then"], ["proof (chain)\npicking this:\n  p \\<in> path_image g", "obtain t where \"0\\<le>t\" \"t\\<le>1\" \"p = g t\""], ["proof (prove)\nusing this:\n  p \\<in> path_image g\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; t \\<le> 1; p = g t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  p \\<in> g ` {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>0 \\<le> t; t \\<le> 1; p = g t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> t\n  t \\<le> 1\n  p = g t\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re p \\<le> Re z", "have \"Re z \\<ge> Re (g t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g t) \\<le> Re z", "apply (rule continuous_le_on_closure[of \"{0<..<1}\" \"\\<lambda>t. Re (g t)\" t \"Re z\",simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {0..1} (\\<lambda>x. Re (g x))\n 2. 0 \\<le> t \\<and> t \\<le> 1\n 3. \\<And>x. 0 < x \\<and> x < 1 \\<Longrightarrow> Re (g x) \\<le> Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (g x))", "using valid_path_imp_path[OF \\<open>valid_path g\\<close>,unfolded path_def]"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. Re (g x))", "by (auto intro:continuous_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> t \\<and> t \\<le> 1\n 2. \\<And>x. 0 < x \\<and> x < 1 \\<Longrightarrow> Re (g x) \\<le> Re z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<and> t \\<le> 1", "using \\<open>0\\<le>t\\<close> \\<open>t\\<le>1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<and> t \\<le> 1", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<and> x < 1 \\<Longrightarrow> Re (g x) \\<le> Re z", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1 \\<Longrightarrow> Re (g x) \\<le> Re z", "using that[rule_format,of x]"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} \\<Longrightarrow> Re (g x) < Re z\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1 \\<Longrightarrow> Re (g x) \\<le> Re z", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (g t) \\<le> Re z\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> path_image g \\<Longrightarrow> Re p \\<le> Re z", "then"], ["proof (chain)\npicking this:\n  Re (g t) \\<le> Re z", "show \"Re z \\<ge> Re p\""], ["proof (prove)\nusing this:\n  Re (g t) \\<le> Re z\n\ngoal (1 subgoal):\n 1. Re p \\<le> Re z", "using \\<open>p = g t\\<close>"], ["proof (prove)\nusing this:\n  Re (g t) \\<le> Re z\n  p = g t\n\ngoal (1 subgoal):\n 1. Re p \\<le> Re z", "by auto"], ["proof (state)\nthis:\n  Re p \\<le> Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>path_image g. Re p \\<le> Re z\n\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "from Re_winding_number_half_left[OF this \\<open>valid_path g\\<close> \\<open>z\\<notin>path_image g\\<close>] loop"], ["proof (chain)\npicking this:\n  Re (winding_number g z) =\n  (Im (Ln (z - pathfinish g)) - Im (Ln (z - pathstart g))) / (2 * pi)\n  pathfinish g = pathstart g", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g z) =\n  (Im (Ln (z - pathfinish g)) - Im (Ln (z - pathstart g))) / (2 * pi)\n  pathfinish g = pathstart g\n\ngoal (1 subgoal):\n 1. Re (winding_number g z) = 0", "by auto"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  Re (winding_number g z) = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"cindex_pathE g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "have \"cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z", "using index_ends[OF _ \\<open>valid_path g\\<close>] Re_neq \\<open>s=0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (g t) \\<noteq> Re z \\<Longrightarrow>\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n  \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z\n  s = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "moreover"], ["proof (state)\nthis:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "have \"jumpF_pathstart g z = jumpF_pathfinish g z\" when \"Re (g 0) \\<noteq> Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathstart g z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "using jumpF_pathstart_eq_0[OF \\<open>path g\\<close>] that"], ["proof (prove)\nusing this:\n  Re (pathstart g) \\<noteq> Re ?z \\<Longrightarrow> jumpF_pathstart g ?z = 0\n  Re (g 0) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "unfolding path_defs"], ["proof (prove)\nusing this:\n  Re (g 0) \\<noteq> Re ?z \\<Longrightarrow> jumpF_pathstart g ?z = 0\n  Re (g 0) \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathfinish g z=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "using jumpF_pathfinish_eq_0[OF \\<open>path g\\<close>] that loop"], ["proof (prove)\nusing this:\n  Re (pathfinish g) \\<noteq> Re ?z \\<Longrightarrow>\n  jumpF_pathfinish g ?z = 0\n  Re (g 0) \\<noteq> Re z\n  pathfinish g = pathstart g\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "unfolding path_defs"], ["proof (prove)\nusing this:\n  Re (g 1) \\<noteq> Re ?z \\<Longrightarrow> jumpF_pathfinish g ?z = 0\n  Re (g 0) \\<noteq> Re z\n  g 1 = g 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart g z = 0\n  jumpF_pathfinish g z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g z = 0\n  jumpF_pathfinish g z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "moreover"], ["proof (state)\nthis:\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "have \"jumpF_pathstart g z = jumpF_pathfinish g z\" when \"Re (g 0) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have [simp]:\"(fR has_sgnx - 1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fR has_sgnx - 1) (at_right 0)", "unfolding fR_def has_sgnx_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>0.\n       \\<forall>y>0. y < b \\<longrightarrow> sgn (Re (g y - z)) = - 1", "apply (rule exI[where x=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = - 1)", "using Re_neg"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (g t) < Re z\n\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = - 1)", "by auto"], ["proof (state)\nthis:\n  (fR has_sgnx - 1) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have [simp]:\"(fR has_sgnx - 1) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fR has_sgnx - 1) (at_left 1)", "unfolding fR_def has_sgnx_def eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<1.\n       \\<forall>y>b. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = - 1", "apply (rule exI[where x=0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = - 1)", "using Re_neg"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0<..<1}. Re (g t) < Re z\n\ngoal (1 subgoal):\n 1. 0 < 1 \\<and>\n    (\\<forall>y>0. y < 1 \\<longrightarrow> sgn (Re (g y - z)) = - 1)", "by auto"], ["proof (state)\nthis:\n  (fR has_sgnx - 1) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"fI 0\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fI 0 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> fI 0 \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> fI 0 \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> fI 0 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> fI 0 \\<noteq> 0", "have \"g 0 =z\""], ["proof (prove)\nusing this:\n  \\<not> fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g 0 = z", "using \\<open>Re (g 0) = Re z\\<close>"], ["proof (prove)\nusing this:\n  \\<not> fI 0 \\<noteq> 0\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. g 0 = z", "unfolding fI_def"], ["proof (prove)\nusing this:\n  \\<not> Im (g 0 - z) \\<noteq> 0\n  Re (g 0) = Re z\n\ngoal (1 subgoal):\n 1. g 0 = z", "by (simp add: complex.expand)"], ["proof (state)\nthis:\n  g 0 = z\n\ngoal (1 subgoal):\n 1. \\<not> fI 0 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g 0 = z", "show False"], ["proof (prove)\nusing this:\n  g 0 = z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z \\<notin> path_image g\\<close>"], ["proof (prove)\nusing this:\n  g 0 = z\n  z \\<notin> path_image g\n\ngoal (1 subgoal):\n 1. False", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  g 0 = z\n  z \\<notin> g ` {0..1}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  fI 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have ?thesis when \"fI 0>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathstart g z = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "have \"(LIM x at_right 0. fI x / fR x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. fI x / fR x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx - sgn (fI 0)) (at_right 0)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  0 < fI 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx - sgn (fI 0)) (at_right 0)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_right 0. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. fI x / fR x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_right 0. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = - 1 / 2", "unfolding jumpF_pathstart_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. Im (g x - z) / Re (g x - z) :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathfinish g z = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "have \"fI 1>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < fI 1", "using loop that"], ["proof (prove)\nusing this:\n  pathfinish g = pathstart g\n  0 < fI 0\n\ngoal (1 subgoal):\n 1. 0 < fI 1", "unfolding path_defs fI_def"], ["proof (prove)\nusing this:\n  g 1 = g 0\n  0 < Im (g 0 - z)\n\ngoal (1 subgoal):\n 1. 0 < Im (g 1 - z)", "by auto"], ["proof (state)\nthis:\n  0 < fI 1\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  0 < fI 1", "have \"(LIM x at_left 1. fI x / fR x :> at_bot)\""], ["proof (prove)\nusing this:\n  0 < fI 1\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. fI x / fR x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < fI 1 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. 0 < fI 1 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. 0 < fI 1 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx - sgn (fI 1)) (at_left 1)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  0 < fI 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. 0 < fI 1 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. 0 < fI 1 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. 0 < fI 1 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx - sgn (fI 1)) (at_left 1)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_left 1. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. fI x / fR x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left 1. fI x / fR x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = - 1 / 2", "unfolding jumpF_pathfinish_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. Im (g x - z) / Re (g x - z) :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart g z = - 1 / 2\n  jumpF_pathfinish g z = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g z = - 1 / 2\n  jumpF_pathfinish g z = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by simp"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have ?thesis when \"fI 0<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathstart g z = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "have \"(LIM x at_right 0. fI x / fR x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. fI x / fR x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx sgn (fI 0)) (at_right 0)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  fI 0 < 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. (fI \\<longlongrightarrow> fI 0) (at_right 0)\n 2. fI 0 \\<noteq> 0\n 3. (fR \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (fR has_sgnx sgn (fI 0)) (at_right 0)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_right 0. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. fI x / fR x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_right 0. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = 1 / 2", "unfolding jumpF_pathstart_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. Im (g x - z) / Re (g x - z) :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_right 0. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "have \"jumpF_pathfinish g z = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "have \"fI 1<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fI 1 < 0", "using loop that"], ["proof (prove)\nusing this:\n  pathfinish g = pathstart g\n  fI 0 < 0\n\ngoal (1 subgoal):\n 1. fI 1 < 0", "unfolding path_defs fI_def"], ["proof (prove)\nusing this:\n  g 1 = g 0\n  Im (g 0 - z) < 0\n\ngoal (1 subgoal):\n 1. Im (g 1 - z) < 0", "by auto"], ["proof (state)\nthis:\n  fI 1 < 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "then"], ["proof (chain)\npicking this:\n  fI 1 < 0", "have \"(LIM x at_left 1. fI x / fR x :> at_top)\""], ["proof (prove)\nusing this:\n  fI 1 < 0\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. fI x / fR x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"fI 1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. fI 1 < 0 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. fI 1 < 0 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. fI 1 < 0 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx sgn (fI 1)) (at_left 1)", "using that fI fR[OF \\<open>Re (g 0) = Re z\\<close>]"], ["proof (prove)\nusing this:\n  fI 0 < 0\n  (fI \\<longlongrightarrow> fI 0) (at_right 0)\n  (fI \\<longlongrightarrow> fI 1) (at_left 1)\n  (fR \\<longlongrightarrow> 0) (at_right 0)\n  (fR \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (3 subgoals):\n 1. fI 1 < 0 \\<Longrightarrow> (fI \\<longlongrightarrow> fI 1) (at_left 1)\n 2. fI 1 < 0 \\<Longrightarrow> fI 1 \\<noteq> 0\n 3. fI 1 < 0 \\<Longrightarrow>\n    (fR \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (fR has_sgnx sgn (fI 1)) (at_left 1)", "by simp_all"], ["proof (state)\nthis:\n  LIM x at_left 1. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. fI x / fR x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left 1. fI x / fR x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish g z = 1 / 2", "unfolding jumpF_pathfinish_def fI_def fR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. Im (g x - z) / Re (g x - z) :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_top then 1 / 2\n     else if LIM t at_left 1. Im (g t - z) / Re (g t - z) :> at_bot\n          then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart g z = 1 / 2\n  jumpF_pathfinish g z = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart g z = 1 / 2\n  jumpF_pathfinish g z = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by simp"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fI 0 < 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "ultimately"], ["proof (chain)\npicking this:\n  fI 0 \\<noteq> 0\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n  fI 0 < 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z", "show ?thesis"], ["proof (prove)\nusing this:\n  fI 0 \\<noteq> 0\n  0 < fI 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n  fI 0 < 0 \\<Longrightarrow> jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart g z = jumpF_pathfinish g z", "by linarith"], ["proof (state)\nthis:\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g 0) = Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n  Re (g 0) = Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g z = jumpF_pathstart g z - jumpF_pathfinish g z\n  Re (g 0) \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n  Re (g 0) = Re z \\<Longrightarrow>\n  jumpF_pathstart g z = jumpF_pathfinish g z\n\ngoal (1 subgoal):\n 1. cindex_pathE g z = 0", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g z = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number g z) = 0\n  cindex_pathE g z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number g z) = 0\n  cindex_pathE g z = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0<..<1}. Re (g t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (g t) \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n  \\<forall>t\\<in>{0<..<1}. Re (g t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>t\\<in>{0<..<1}. Re z < Re (g t)) \\<or>\n  (\\<forall>t\\<in>{0<..<1}. Re (g t) < Re z)\n  \\<forall>t\\<in>{0<..<1}. Re z < Re (g t) \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n  \\<forall>t\\<in>{0<..<1}. Re (g t) < Re z \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "moreover"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "have ?goal when \"s\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"Re (g s) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g s) = Re z", "using \\<open>s = 0 \\<or> Re (g s) = Re z\\<close> that"], ["proof (prove)\nusing this:\n  s = 0 \\<or> Re (g s) = Re z\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (g s) = Re z", "by auto"], ["proof (state)\nthis:\n  Re (g s) = Re z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "define g' where \"g' = shiftpath s g\""], ["proof (state)\nthis:\n  g' = shiftpath s g\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"2 * Re (winding_number g' z) = - cindex_pathE g' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g' z) = - cindex_pathE g' z", "proof (rule winding_number_cindex_pathE_aux)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite_ReZ_segments g' z\n 2. valid_path g'\n 3. z \\<notin> path_image g'\n 4. Re (g' 1) = Re z\n 5. Re (g' 0) = Re z", "show \"Re (g' 1) = Re z\" \"Re (g' 0) = Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g' 1) = Re z &&& Re (g' 0) = Re z", "using \\<open>Re (g s) = Re z\\<close> \\<open>s\\<in>{0..<1}\\<close> \\<open>s\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re (g s) = Re z\n  s \\<in> {0..<1}\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (g' 1) = Re z &&& Re (g' 0) = Re z", "unfolding g'_def shiftpath_def"], ["proof (prove)\nusing this:\n  Re (g s) = Re z\n  s \\<in> {0..<1}\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (if s + 1 \\<le> 1 then g (s + 1) else g (s + 1 - 1)) = Re z &&&\n    Re (if s + 0 \\<le> 1 then g (s + 0) else g (s + 0 - 1)) = Re z", "by simp_all"], ["proof (state)\nthis:\n  Re (g' 1) = Re z\n  Re (g' 0) = Re z\n\ngoal (3 subgoals):\n 1. finite_ReZ_segments g' z\n 2. valid_path g'\n 3. z \\<notin> path_image g'", "show \"valid_path g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path g'", "using valid_path_shiftpath[OF \\<open>valid_path g\\<close> loop,of s,folded g'_def] \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..1} \\<Longrightarrow> valid_path g'\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. valid_path g'", "by auto"], ["proof (state)\nthis:\n  valid_path g'\n\ngoal (2 subgoals):\n 1. finite_ReZ_segments g' z\n 2. z \\<notin> path_image g'", "show \"z \\<notin> path_image g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> path_image g'", "using \\<open>s \\<in> {0..<1}\\<close> assms(3) g'_def loop path_image_shiftpath"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n  z \\<notin> path_image g\n  g' = shiftpath s g\n  pathfinish g = pathstart g\n  \\<lbrakk>?a \\<in> {0..1}; pathfinish ?g = pathstart ?g\\<rbrakk>\n  \\<Longrightarrow> path_image (shiftpath ?a ?g) = path_image ?g\n\ngoal (1 subgoal):\n 1. z \\<notin> path_image g'", "by fastforce"], ["proof (state)\nthis:\n  z \\<notin> path_image g'\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g' z", "show \"finite_ReZ_segments g' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments g' z", "using finite_ReZ_segments_shiftpah[OF \\<open>finite_ReZ_segments g z\\<close> _ \\<open>path g\\<close> loop] \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  ?s \\<in> {0..1} \\<Longrightarrow> finite_ReZ_segments (shiftpath ?s g) z\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments g' z", "unfolding g'_def"], ["proof (prove)\nusing this:\n  ?s \\<in> {0..1} \\<Longrightarrow> finite_ReZ_segments (shiftpath ?s g) z\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (shiftpath s g) z", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments g' z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * Re (winding_number g' z) = - cindex_pathE g' z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g' z) = - cindex_pathE g' z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"winding_number g' z = winding_number g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number g' z = winding_number g z", "unfolding g'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (shiftpath s g) z = winding_number g z", "apply (rule winding_number_shiftpath[OF \\<open>path g\\<close> \\<open>z \\<notin> path_image g\\<close> loop])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {0..1}", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. s \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  winding_number g' z = winding_number g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "moreover"], ["proof (state)\nthis:\n  winding_number g' z = winding_number g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "have \"cindex_pathE g' z = cindex_pathE g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g' z = cindex_pathE g z", "unfolding g'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (shiftpath s g) z = cindex_pathE g z", "apply (rule cindex_pathE_shiftpath[OF \\<open>finite_ReZ_segments g z\\<close> _ \\<open>path g\\<close> loop])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {0..1}", "using \\<open>s\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. s \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g' z = cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g' z) = - cindex_pathE g' z\n  winding_number g' z = winding_number g z\n  cindex_pathE g' z = cindex_pathE g z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g' z) = - cindex_pathE g' z\n  winding_number g' z = winding_number g z\n  cindex_pathE g' z = cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "ultimately"], ["proof (chain)\npicking this:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z", "have ?goal"], ["proof (prove)\nusing this:\n  s = 0 \\<Longrightarrow> 2 * Re (winding_number g z) = - cindex_pathE g z\n  s \\<noteq> 0 \\<Longrightarrow>\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g z) = - cindex_pathE g z", "by auto"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "moreover"], ["proof (state)\nthis:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "have \"winding_number g z \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number g z \\<in> \\<int>", "using integer_winding_number[OF _ loop \\<open>z\\<notin>path_image g\\<close>] valid_path_imp_path[OF \\<open>valid_path g\\<close>]"], ["proof (prove)\nusing this:\n  path g \\<Longrightarrow> winding_number g z \\<in> \\<int>\n  path g\n\ngoal (1 subgoal):\n 1. winding_number g z \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  winding_number g z \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> {0..<1}; s = 0 \\<or> Re (g s) = Re z;\n        \\<forall>t\\<in>{s<..<1}. Re (g t) \\<noteq> Re z;\n        finite_ReZ_segments (subpath 0 s g) z\\<rbrakk>\n       \\<Longrightarrow> winding_number g z =\n                         complex_of_real (- cindex_pathE g z / 2)", "ultimately"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n  winding_number g z \\<in> \\<int>", "show \"winding_number g z = - cindex_pathE g z / 2\""], ["proof (prove)\nusing this:\n  2 * Re (winding_number g z) = - cindex_pathE g z\n  winding_number g z \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. winding_number g z = complex_of_real (- cindex_pathE g z / 2)", "by (metis add.right_neutral complex_eq complex_is_Int_iff mult_zero_right \n        nonzero_mult_div_cancel_left of_real_0 zero_neq_numeral)"], ["proof (state)\nthis:\n  winding_number g z = complex_of_real (- cindex_pathE g z / 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>REMARK: The usual statement of Cauchy's Index theorem (i.e. Analytic Theory of Polynomials \n  (2002): Theorem 11.1.3) is about the equality between the number of polynomial roots and\n  the Cauchy index, which is the joint application of @{thm winding_number_cindex_pathE} and\n  @{thm argument_principle}.\\<close>"], ["", "end"]]}