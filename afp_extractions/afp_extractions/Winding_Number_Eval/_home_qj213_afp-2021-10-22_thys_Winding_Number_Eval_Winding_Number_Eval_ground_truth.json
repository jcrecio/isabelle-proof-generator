{"file_name": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval/Winding_Number_Eval.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Winding_Number_Eval", "problem_names": ["lemma not_on_closed_segmentI:\n  fixes z::\"'a::euclidean_space\"\n  assumes \"norm (z - a) *\\<^sub>R (b - z) \\<noteq> norm (b - z) *\\<^sub>R (z - a)\"\n  shows \"z \\<notin> closed_segment a b\"", "lemma not_on_closed_segmentI_complex:    \n  fixes z::\"complex\"\n  assumes \"(Re b - Re z) * (Im z - Im a) \\<noteq> (Im b - Im z) * (Re z - Re a)\"\n  shows \"z \\<notin> closed_segment a b\"", "lemma finite_cross_intros:\n  \"\\<lbrakk>Re a\\<noteq>Re z \\<or> Re b \\<noteq>Re z; Im a\\<noteq>Im z \\<or> Im b\\<noteq>Im z\\<rbrakk>\\<Longrightarrow>finite_axes_cross (linepath a b) z\"\n  \"\\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk> \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\"\n  \"\\<lbrakk>finite_axes_cross g1 z;finite_axes_cross g2 z\\<rbrakk> \\<Longrightarrow> finite_axes_cross (g1+++g2) z\"", "lemma cindex_path_joinpaths:\n  assumes \"finite_axes_cross g1 z\" \"finite_axes_cross g2 z\"\n    and \"path g1\" \"path g2\" \"pathfinish g1 = pathstart g2\" \"pathfinish g1\\<noteq>z\" \n  shows \"cindex_path (g1+++g2) z = cindex_path g1 z + jumpF_pathstart g2 z \n            - jumpF_pathfinish g1 z  + cindex_path g2 z\"", "lemma cindex_pathE_linepath:\n  assumes \"z\\<notin>closed_segment a b\"\n  shows \"cindex_pathE (linepath a b) z = (\n    let c1 = Re a - Re z; \n        c2 = Re b - Re z; \n        c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a - Re z * Im a;\n        d1 = Im a - Im z;\n        d2 = Im b - Im z\n    in if (c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0) then \n          (if c3>0 then 1 else -1) \n       else \n          (if (c1=0 \\<longleftrightarrow> c2\\<noteq>0) \\<and> (c1=0 \\<longrightarrow>d1\\<noteq>0) \\<and> (c2=0 \\<longrightarrow> d2\\<noteq>0) then \n            if (c1=0 \\<and> (c2 >0 \\<longleftrightarrow> d1>0)) \\<or> (c2=0 \\<and> (c1 >0 \\<longleftrightarrow> d2<0))  then 1/2 else -1/2\n          else 0))\"", "lemma cindex_path_linepath:\n  assumes \"z\\<notin>path_image (linepath a b)\"\n  shows \"cindex_path (linepath a b) z = (\n    let c1=Re(a)-Re(z) ; c2=Re(b)-Re(z) ; \n        c3 = Im(a)*Re(b)+Re(z)*Im(b)+Im(z)*Re(a) -Im(z)*Re(b) - Im(b)*Re(a) - Re(z)*Im(a)\n    in if (c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0) then (if c3>0 then 1 else -1) else 0)\"", "lemma cindex_pathE_part_circlepath:\n  assumes \"cmod (z-z0) \\<noteq>r\" and \"r>0\" \"0\\<le>st\" \"st<tt\" \"tt\\<le>2*pi\"\n  shows \"cindex_pathE (part_circlepath z r st tt) z0 = (\n    if \\<bar>Re z - Re z0\\<bar> < r then \n      (let\n          \\<theta> = arccos ((Re z0 - Re z)/r);\n          \\<beta> = 2*pi - \\<theta>\n        in\n          jumpF_pathstart (part_circlepath z r st tt) z0\n          +\n          (if st<\\<theta> \\<and> \\<theta><tt then if r * sin \\<theta> + Im z > Im z0 then -1 else 1 else 0)\n          +\n          (if st<\\<beta> \\<and> \\<beta> < tt then if r * sin \\<beta> + Im z > Im z0 then 1 else -1 else 0)\n          - \n          jumpF_pathfinish (part_circlepath z r st tt) z0\n      )\n    else \n      if \\<bar>Re z - Re z0\\<bar> = r then \n        jumpF_pathstart (part_circlepath z r st tt) z0 \n        - jumpF_pathfinish (part_circlepath z r st tt) z0 \n      else 0\n    )\"", "lemma jumpF_pathstart_part_circlepath: \n  assumes \"st<tt\" \"r>0\" \"cmod (z-z0) \\<noteq>r\"\n  shows \"jumpF_pathstart (part_circlepath z r st tt) z0 = (\n            if r * cos st + Re z - Re z0 = 0 then \n              (let \n                \\<Delta> = r* sin st + Im z - Im z0\n              in\n                if (sin st > 0 \\<or> cos st=1 ) \\<and> \\<Delta> < 0 \n                    \\<or> (sin st < 0 \\<or>  cos st=-1 ) \\<and> \\<Delta> > 0  then \n                  1/2\n                else \n                  - 1/2)\n            else 0)\"", "lemma jumpF_pathfinish_part_circlepath: \n  assumes \"st<tt\" \"r>0\" \"cmod (z-z0) \\<noteq>r\"\n  shows \"jumpF_pathfinish (part_circlepath z r st tt) z0 = (\n            if r * cos tt + Re z - Re z0 = 0 then \n              (let \n                \\<Delta> = r* sin tt + Im z - Im z0\n              in\n                if (sin tt > 0 \\<or> cos tt=-1 ) \\<and> \\<Delta> < 0 \n                    \\<or> (sin tt < 0 \\<or>  cos tt=1 ) \\<and> \\<Delta> > 0  then \n                  - 1/2\n                else \n                  1/2)\n            else 0)\"", "lemma \n  fixes z0 z::complex and r::real\n  defines \"upper \\<equiv> cindex_pathE (part_circlepath z r 0 pi) z0\"\n      and \"lower \\<equiv> cindex_pathE (part_circlepath z r pi (2*pi)) z0\"\n  shows cindex_pathE_circlepath_upper:\n      \"\\<lbrakk>cmod (z0-z) < r\\<rbrakk>  \\<Longrightarrow> upper = -1\" \n      \"\\<lbrakk>Im (z0-z) > r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> upper = 1\"\n      \"\\<lbrakk>Im (z0-z) < -r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> upper = -1\" \n      \"\\<lbrakk>\\<bar>Re (z0 - z)\\<bar> > r; r>0\\<rbrakk> \\<Longrightarrow> upper = 0\"\n  and cindex_pathE_circlepath_lower: \n      \"\\<lbrakk>cmod (z0-z) < r\\<rbrakk> \\<Longrightarrow> lower = -1\" \n      \"\\<lbrakk>Im (z0-z) > r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> lower = -1\"\n      \"\\<lbrakk>Im (z0-z) < -r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> lower = 1\"\n      \"\\<lbrakk>\\<bar>Re (z0 - z)\\<bar> > r; r>0\\<rbrakk> \\<Longrightarrow> lower = 0\"", "lemma jumpF_pathstart_linepath:\n  \"jumpF_pathstart (linepath a b) z = \n    (if Re a = Re z \\<and> Im a\\<noteq>Im z \\<and> Re b \\<noteq> Re a then \n        if (Im a>Im z \\<and> Re b > Re a) \\<or> (Im a<Im z \\<and> Re b < Re a) then 1/2 else -1/2 \n     else 0)\"", "lemma jumpF_pathfinish_linepath:\n  \"jumpF_pathfinish (linepath a b) z = \n    (if Re b = Re z \\<and> Im b \\<noteq>Im z \\<and> Re b \\<noteq> Re a then \n        if (Im b>Im z \\<and> Re a > Re b) \\<or> (Im b<Im z \\<and> Re a < Re b) then 1/2 else -1/2 \n     else 0)\"", "lemma pathfinish_pathstart_partcirclepath_simps:\n  \"pathstart (part_circlepath z0 r (3*pi/2) tt) = z0 - Complex 0 r\"\n  \"pathstart (part_circlepath z0 r (2*pi) tt) = z0 + r\"\n  \"pathfinish (part_circlepath z0 r st (3*pi/2)) = z0 - Complex 0 r\"\n  \"pathfinish (part_circlepath z0 r st (2*pi)) = z0 + r\"\n  \"pathstart (part_circlepath z0 r 0 tt) = z0 + r\"\n  \"pathstart (part_circlepath z0 r (pi/2) tt) = z0 + Complex 0 r\"\n  \"pathstart (part_circlepath z0 r (pi) tt) = z0 - r\"\n  \"pathfinish (part_circlepath z0 r st 0) = z0+r\"\n  \"pathfinish (part_circlepath z0 r st (pi/2)) = z0 + Complex 0 r\"\n  \"pathfinish (part_circlepath z0 r st (pi)) = z0 - r\"", "lemma winding_eq_intro:\n  \"finite_ReZ_segments g z \\<Longrightarrow>\n  valid_path g \\<Longrightarrow>\n  z \\<notin> path_image g \\<Longrightarrow>\n  pathfinish g = pathstart g \\<Longrightarrow>  \n  - of_real(cindex_pathE g z) =2*n \\<Longrightarrow>\n  winding_number g z = (n::complex)\"", "lemmas [winding_intros] = \n  finite_ReZ_segments_joinpaths\n  valid_path_join\n  path_join_imp\n  not_in_path_image_join", "lemmas [winding_simps] =\n  finite_ReZ_segments_linepath\n  finite_ReZ_segments_part_circlepath\n  jumpF_pathfinish_joinpaths\n  jumpF_pathstart_joinpaths\n  pathfinish_linepath\n  pathstart_linepath\n  pathfinish_join\n  pathstart_join\n  valid_path_linepath\n  valid_path_part_circlepath\n  path_part_circlepath\n  Re_complex_of_real\n  Im_complex_of_real\n  of_real_linepath\n  pathfinish_pathstart_partcirclepath_simps"], "translations": [["", "lemma not_on_closed_segmentI:\n  fixes z::\"'a::euclidean_space\"\n  assumes \"norm (z - a) *\\<^sub>R (b - z) \\<noteq> norm (b - z) *\\<^sub>R (z - a)\"\n  shows \"z \\<notin> closed_segment a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> closed_segment a b", "using assms"], ["proof (prove)\nusing this:\n  norm (z - a) *\\<^sub>R (b - z) \\<noteq> norm (b - z) *\\<^sub>R (z - a)\n\ngoal (1 subgoal):\n 1. z \\<notin> closed_segment a b", "by (auto simp add:between_mem_segment[symmetric] between_norm)"], ["", "lemma not_on_closed_segmentI_complex:    \n  fixes z::\"complex\"\n  assumes \"(Re b - Re z) * (Im z - Im a) \\<noteq> (Im b - Im z) * (Re z - Re a)\"\n  shows \"z \\<notin> closed_segment a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> closed_segment a b", "proof (cases \"z\\<noteq>a \\<and> z\\<noteq>b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<noteq> a \\<and> z \\<noteq> b \\<Longrightarrow>\n    z \\<notin> closed_segment a b\n 2. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "case True"], ["proof (state)\nthis:\n  z \\<noteq> a \\<and> z \\<noteq> b\n\ngoal (2 subgoals):\n 1. z \\<noteq> a \\<and> z \\<noteq> b \\<Longrightarrow>\n    z \\<notin> closed_segment a b\n 2. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "then"], ["proof (chain)\npicking this:\n  z \\<noteq> a \\<and> z \\<noteq> b", "have \"cmod (z - a)\\<noteq>0\" \"cmod (b - z)\\<noteq>0\""], ["proof (prove)\nusing this:\n  z \\<noteq> a \\<and> z \\<noteq> b\n\ngoal (1 subgoal):\n 1. cmod (z - a) \\<noteq> 0 &&& cmod (b - z) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  cmod (z - a) \\<noteq> 0\n  cmod (b - z) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z \\<noteq> a \\<and> z \\<noteq> b \\<Longrightarrow>\n    z \\<notin> closed_segment a b\n 2. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "then"], ["proof (chain)\npicking this:\n  cmod (z - a) \\<noteq> 0\n  cmod (b - z) \\<noteq> 0", "have \"(Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)\" when \n    \"cmod (z - a) * (Re b - Re z) = cmod (b - z) * (Re z - Re a)\"\n    \"cmod (z - a) * (Im b - Im z) = cmod (b - z) * (Im z - Im a)\""], ["proof (prove)\nusing this:\n  cmod (z - a) \\<noteq> 0\n  cmod (b - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)", "using that"], ["proof (prove)\nusing this:\n  cmod (z - a) \\<noteq> 0\n  cmod (b - z) \\<noteq> 0\n  cmod (z - a) * (Re b - Re z) = cmod (b - z) * (Re z - Re a)\n  cmod (z - a) * (Im b - Im z) = cmod (b - z) * (Im z - Im a)\n\ngoal (1 subgoal):\n 1. (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)", "by algebra"], ["proof (state)\nthis:\n  \\<lbrakk>cmod (z - a) * (Re b - Re z) = cmod (b - z) * (Re z - Re a);\n   cmod (z - a) * (Im b - Im z) = cmod (b - z) * (Im z - Im a)\\<rbrakk>\n  \\<Longrightarrow> (Re b - Re z) * (Im z - Im a) =\n                    (Im b - Im z) * (Re z - Re a)\n\ngoal (2 subgoals):\n 1. z \\<noteq> a \\<and> z \\<noteq> b \\<Longrightarrow>\n    z \\<notin> closed_segment a b\n 2. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>cmod (z - a) * (Re b - Re z) = cmod (b - z) * (Re z - Re a);\n   cmod (z - a) * (Im b - Im z) = cmod (b - z) * (Im z - Im a)\\<rbrakk>\n  \\<Longrightarrow> (Re b - Re z) * (Im z - Im a) =\n                    (Im b - Im z) * (Re z - Re a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>cmod (z - a) * (Re b - Re z) = cmod (b - z) * (Re z - Re a);\n   cmod (z - a) * (Im b - Im z) = cmod (b - z) * (Im z - Im a)\\<rbrakk>\n  \\<Longrightarrow> (Re b - Re z) * (Im z - Im a) =\n                    (Im b - Im z) * (Re z - Re a)\n\ngoal (1 subgoal):\n 1. z \\<notin> closed_segment a b", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>cmod (z - a) * (Re b - Re z) = cmod (b - z) * (Re z - Re a);\n   cmod (z - a) * (Im b - Im z) = cmod (b - z) * (Im z - Im a)\\<rbrakk>\n  \\<Longrightarrow> (Re b - Re z) * (Im z - Im a) =\n                    (Im b - Im z) * (Re z - Re a)\n  (Re b - Re z) * (Im z - Im a) \\<noteq> (Im b - Im z) * (Re z - Re a)\n\ngoal (1 subgoal):\n 1. z \\<notin> closed_segment a b", "apply (intro not_on_closed_segmentI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>cmod (z - a) * (Re b - Re z) =\n                      cmod (b - z) * (Re z - Re a);\n              cmod (z - a) * (Im b - Im z) =\n              cmod (b - z) * (Im z - Im a)\\<rbrakk>\n             \\<Longrightarrow> (Re b - Re z) * (Im z - Im a) =\n                               (Im b - Im z) * (Re z - Re a);\n     (Re b - Re z) * (Im z - Im a) \\<noteq>\n     (Im b - Im z) * (Re z - Re a)\\<rbrakk>\n    \\<Longrightarrow> cmod (z - a) *\\<^sub>R (b - z) \\<noteq>\n                      cmod (b - z) *\\<^sub>R (z - a)", "by (auto simp add:scaleR_complex.ctr simp del:Complex_eq)"], ["proof (state)\nthis:\n  z \\<notin> closed_segment a b\n\ngoal (1 subgoal):\n 1. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "case False"], ["proof (state)\nthis:\n  \\<not> (z \\<noteq> a \\<and> z \\<noteq> b)\n\ngoal (1 subgoal):\n 1. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "then"], ["proof (chain)\npicking this:\n  \\<not> (z \\<noteq> a \\<and> z \\<noteq> b)", "have \"(Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)\""], ["proof (prove)\nusing this:\n  \\<not> (z \\<noteq> a \\<and> z \\<noteq> b)\n\ngoal (1 subgoal):\n 1. (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)", "by auto"], ["proof (state)\nthis:\n  (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)\n\ngoal (1 subgoal):\n 1. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "then"], ["proof (chain)\npicking this:\n  (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)", "have False"], ["proof (prove)\nusing this:\n  (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  (Re b - Re z) * (Im z - Im a) = (Im b - Im z) * (Re z - Re a)\n  (Re b - Re z) * (Im z - Im a) \\<noteq> (Im b - Im z) * (Re z - Re a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (z \\<noteq> a \\<and> z \\<noteq> b) \\<Longrightarrow>\n    z \\<notin> closed_segment a b", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. z \\<notin> closed_segment a b", "by auto"], ["proof (state)\nthis:\n  z \\<notin> closed_segment a b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>finite intersection with the two axes\\<close>"], ["", "definition finite_axes_cross::\"(real \\<Rightarrow> complex) \\<Rightarrow> complex \\<Rightarrow> bool\" where\n  \"finite_axes_cross g z = finite {t. (Re (g t-z) = 0 \\<or> Im (g t-z) = 0) \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["", "lemma finite_cross_intros:\n  \"\\<lbrakk>Re a\\<noteq>Re z \\<or> Re b \\<noteq>Re z; Im a\\<noteq>Im z \\<or> Im b\\<noteq>Im z\\<rbrakk>\\<Longrightarrow>finite_axes_cross (linepath a b) z\"\n  \"\\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk> \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\"\n  \"\\<lbrakk>finite_axes_cross g1 z;finite_axes_cross g2 z\\<rbrakk> \\<Longrightarrow> finite_axes_cross (g1+++g2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n      Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n     \\<Longrightarrow> finite_axes_cross (linepath a b) z) &&&\n    (\\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z) &&&\n    (\\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n     \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "assume asm:\"Re a\\<noteq>Re z \\<or> Re b \\<noteq>Re z\" \"Im a\\<noteq>Im z \\<or> Im b\\<noteq>Im z\""], ["proof (state)\nthis:\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z\n  Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "let ?S1=\"{t. Re (linepath a b t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\"\n  and ?S2=\"{t. Im (linepath a b t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "using linepath_half_finite_inter[of a \"Complex 1 0\" \"Re z\" b] asm(1)"], ["proof (prove)\nusing this:\n  a \\<bullet> Complex 1 0 \\<noteq> Re z \\<or>\n  b \\<bullet> Complex 1 0 \\<noteq> Re z \\<Longrightarrow>\n  finite\n   {t. linepath a b t \\<bullet> Complex 1 0 = Re z \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def)"], ["proof (state)\nthis:\n  finite {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "using linepath_half_finite_inter[of a \"Complex 0 1\" \"Im z\" b] asm(2)"], ["proof (prove)\nusing this:\n  a \\<bullet> Complex 0 1 \\<noteq> Im z \\<or>\n  b \\<bullet> Complex 0 1 \\<noteq> Im z \\<Longrightarrow>\n  finite\n   {t. linepath a b t \\<bullet> Complex 0 1 = Im z \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\n\ngoal (1 subgoal):\n 1. finite\n     {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def)"], ["proof (state)\nthis:\n  finite {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"{t. (Re (linepath a b t-z) = 0 \\<or> Im (linepath a b t-z) = 0) \\<and> 0 \\<le> t \\<and> t \\<le> 1} \n      = ?S1 \\<union> ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (Re (linepath a b t - z) = 0 \\<or>\n         Im (linepath a b t - z) = 0) \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} =\n    {t. Re (linepath a b t - z) = 0 \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by fast"], ["proof (state)\nthis:\n  {t. (Re (linepath a b t - z) = 0 \\<or> Im (linepath a b t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (linepath a b t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a \\<noteq> Re z \\<or> Re b \\<noteq> Re z;\n     Im a \\<noteq> Im z \\<or> Im b \\<noteq> Im z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (linepath a b) z\n 2. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 3. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "ultimately"], ["proof (chain)\npicking this:\n  finite {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re (linepath a b t - z) = 0 \\<or> Im (linepath a b t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (linepath a b t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "show \"finite_axes_cross (linepath a b) z\""], ["proof (prove)\nusing this:\n  finite {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re (linepath a b t - z) = 0 \\<or> Im (linepath a b t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (linepath a b t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_axes_cross (linepath a b) z", "unfolding finite_axes_cross_def"], ["proof (prove)\nusing this:\n  finite {t. Re (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re (linepath a b t - z) = 0 \\<or> Im (linepath a b t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (linepath a b t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (linepath a b t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (Re (linepath a b t - z) = 0 \\<or>\n          Im (linepath a b t - z) = 0) \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by force"], ["proof (state)\nthis:\n  finite_axes_cross (linepath a b) z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "assume asm: \"st \\<noteq>tt\" \"r\\<noteq>0\""], ["proof (state)\nthis:\n  st \\<noteq> tt\n  r \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "let ?S1=\"{t. Re (part_circlepath z0 r st tt t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\"\n  and ?S2=\"{t. Im (part_circlepath z0 r st tt t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "using part_circlepath_half_finite_inter[of st tt r \"Complex 1 0\" z0 \"Re z\"] asm"], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0; Complex 1 0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. part_circlepath z0 r st tt t \\<bullet>\n                         Complex 1 0 =\n                         Re z \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  st \\<noteq> tt\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def Complex_eq_0)"], ["proof (state)\nthis:\n  finite\n   {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite\n   {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "using part_circlepath_half_finite_inter[of st tt r \"Complex 0 1\" z0 \"Im z\"] asm"], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0; Complex 0 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. part_circlepath z0 r st tt t \\<bullet>\n                         Complex 0 1 =\n                         Im z \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  st \\<noteq> tt\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite\n     {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def Complex_eq_0)"], ["proof (state)\nthis:\n  finite\n   {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite\n   {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"{t. (Re (part_circlepath z0 r st tt t-z) = 0 \n      \\<or> Im (part_circlepath z0 r st tt t-z) = 0) \\<and> 0 \\<le> t \\<and> t \\<le> 1} = ?S1 \\<union> ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (Re (part_circlepath z0 r st tt t - z) = 0 \\<or>\n         Im (part_circlepath z0 r st tt t - z) = 0) \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} =\n    {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}", "by fast"], ["proof (state)\nthis:\n  {t. (Re (part_circlepath z0 r st tt t - z) = 0 \\<or>\n       Im (part_circlepath z0 r st tt t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (part_circlepath z0 r st tt) z\n 2. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re (part_circlepath z0 r st tt t - z) = 0 \\<or>\n       Im (part_circlepath z0 r st tt t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}", "show \"finite_axes_cross (part_circlepath z0 r st tt) z\""], ["proof (prove)\nusing this:\n  finite\n   {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re (part_circlepath z0 r st tt t - z) = 0 \\<or>\n       Im (part_circlepath z0 r st tt t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_axes_cross (part_circlepath z0 r st tt) z", "unfolding finite_axes_cross_def"], ["proof (prove)\nusing this:\n  finite\n   {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re (part_circlepath z0 r st tt t - z) = 0 \\<or>\n       Im (part_circlepath z0 r st tt t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (part_circlepath z0 r st tt t - z) = 0 \\<and>\n      0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (Re (part_circlepath z0 r st tt t - z) = 0 \\<or>\n          Im (part_circlepath z0 r st tt t - z) = 0) \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite_axes_cross (part_circlepath z0 r st tt) z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "assume asm:\"finite_axes_cross g1 z\" \"finite_axes_cross g2 z\""], ["proof (state)\nthis:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "let ?g1R=\"{t. Re (g1 t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\"\n  and ?g1I=\"{t. Im (g1 t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\"\n  and ?g2R=\"{t. Re (g2 t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\"\n  and ?g2I=\"{t. Im (g2 t-z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?g1R\" \"finite ?g1I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n 2. finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"{t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and> 0 \\<le> t \\<and> t \\<le> 1} = ?g1R \\<union> ?g1I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} =\n    {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by force"], ["proof (state)\nthis:\n  {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n 2. finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"finite (?g1R \\<union> ?g1I)\""], ["proof (prove)\nusing this:\n  {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     ({t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n      {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "using asm(1)"], ["proof (prove)\nusing this:\n  {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite_axes_cross g1 z\n\ngoal (1 subgoal):\n 1. finite\n     ({t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n      {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "unfolding finite_axes_cross_def"], ["proof (prove)\nusing this:\n  {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. (Re (g1 t - z) = 0 \\<or> Im (g1 t - z) = 0) \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     ({t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n      {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "by auto"], ["proof (state)\nthis:\n  finite\n   ({t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})\n\ngoal (2 subgoals):\n 1. finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n 2. finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  finite\n   ({t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "show \"finite ?g1R\" \"finite ?g1I\""], ["proof (prove)\nusing this:\n  finite\n   ({t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})\n\ngoal (1 subgoal):\n 1. finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by blast+"], ["proof (state)\nthis:\n  finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?g2R\" \"finite ?g2I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n 2. finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"{t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and> 0 \\<le> t \\<and> t \\<le> 1} = ?g2R \\<union> ?g2I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} =\n    {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by force"], ["proof (state)\nthis:\n  {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n 2. finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"finite (?g2R \\<union> ?g2I)\""], ["proof (prove)\nusing this:\n  {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     ({t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n      {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "using asm(2)"], ["proof (prove)\nusing this:\n  {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite_axes_cross g2 z\n\ngoal (1 subgoal):\n 1. finite\n     ({t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n      {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "unfolding finite_axes_cross_def"], ["proof (prove)\nusing this:\n  {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. (Re (g2 t - z) = 0 \\<or> Im (g2 t - z) = 0) \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     ({t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n      {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "by auto"], ["proof (state)\nthis:\n  finite\n   ({t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})\n\ngoal (2 subgoals):\n 1. finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n 2. finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  finite\n   ({t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})", "show \"finite ?g2R\" \"finite ?g2I\""], ["proof (prove)\nusing this:\n  finite\n   ({t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1})\n\ngoal (1 subgoal):\n 1. finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by blast+"], ["proof (state)\nthis:\n  finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "let ?S1 = \"{t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\"\n  and ?S2 = \"{t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "using finite_half_joinpaths_inter[of g1 \"Complex 1 0\" \"Re z\" g2,simplified] \n      \\<open>finite ?g1R\\<close> \\<open>finite ?g2R\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite\n            {t. g1 t \\<bullet> Complex 1 0 = Re z \\<and>\n                0 \\<le> t \\<and> t \\<le> 1};\n   finite\n    {t. g2 t \\<bullet> Complex 1 0 = Re z \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. (g1 +++ g2) t \\<bullet> Complex 1 0 = Re z \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Re (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Re (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def)"], ["proof (state)\nthis:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"finite ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "using finite_half_joinpaths_inter[of g1 \"Complex 0 1\" \"Im z\" g2,simplified] \n      \\<open>finite ?g1I\\<close> \\<open>finite ?g2I\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite\n            {t. g1 t \\<bullet> Complex 0 1 = Im z \\<and>\n                0 \\<le> t \\<and> t \\<le> 1};\n   finite\n    {t. g2 t \\<bullet> Complex 0 1 = Im z \\<and>\n        0 \\<le> t \\<and> t \\<le> 1}\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. (g1 +++ g2) t \\<bullet> Complex 0 1 = Im z \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (g1 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im (g2 t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def)"], ["proof (state)\nthis:\n  finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "moreover"], ["proof (state)\nthis:\n  finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "have \"{t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n        = ?S1 \\<union> ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} =\n    {t. Re ((g1 +++ g2) t - z) = 0 \\<and>\n        0 \\<le> t \\<and> t \\<le> 1} \\<union>\n    {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by force"], ["proof (state)\nthis:\n  {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n    \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z", "ultimately"], ["proof (chain)\npicking this:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "show \"finite_axes_cross (g1 +++ g2) z\""], ["proof (prove)\nusing this:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_axes_cross (g1 +++ g2) z", "unfolding finite_axes_cross_def"], ["proof (prove)\nusing this:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  finite {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n      0 \\<le> t \\<and> t \\<le> 1} =\n  {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} \\<union>\n  {t. Im ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (Re ((g1 +++ g2) t - z) = 0 \\<or>\n          Im ((g1 +++ g2) t - z) = 0) \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite_axes_cross (g1 +++ g2) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_path_joinpaths:\n  assumes \"finite_axes_cross g1 z\" \"finite_axes_cross g2 z\"\n    and \"path g1\" \"path g2\" \"pathfinish g1 = pathstart g2\" \"pathfinish g1\\<noteq>z\" \n  shows \"cindex_path (g1+++g2) z = cindex_path g1 z + jumpF_pathstart g2 z \n            - jumpF_pathfinish g1 z  + cindex_path g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "define h12 where \"h12 = (\\<lambda>t. Im ((g1+++g2) t - z) / Re ((g1+++g2) t - z))\""], ["proof (state)\nthis:\n  h12 = (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "let ?h = \"\\<lambda>g. \\<lambda>t. Im (g t - z) / Re (g t - z)\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "have \"cindex_path (g1+++g2) z = cindex 0 1 h12\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (g1 +++ g2) z = cindex 0 1 h12", "unfolding cindex_path_def h12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 1\n     (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) =\n    cindex 0 1 (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))", "by simp"], ["proof (state)\nthis:\n  cindex_path (g1 +++ g2) z = cindex 0 1 h12\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "also"], ["proof (state)\nthis:\n  cindex_path (g1 +++ g2) z = cindex 0 1 h12\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "have \"... = cindex 0 (1/2) h12 + jump h12 (1/2) + cindex (1/2) 1 h12\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 1 h12 =\n    cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12", "proof (rule cindex_combine)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n 2. 0 < 1 / 2\n 3. 1 / 2 < 1", "have \"finite_axes_cross (g1+++g2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_axes_cross (g1 +++ g2) z", "using assms"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. finite_axes_cross (g1 +++ g2) z", "by (auto intro:finite_cross_intros)"], ["proof (state)\nthis:\n  finite_axes_cross (g1 +++ g2) z\n\ngoal (3 subgoals):\n 1. finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n 2. 0 < 1 / 2\n 3. 1 / 2 < 1", "then"], ["proof (chain)\npicking this:\n  finite_axes_cross (g1 +++ g2) z", "have \"finite {t. Re ((g1+++g2) t - z) = 0 \\<and> 0\\<le>t \\<and> t\\<le>1}\""], ["proof (prove)\nusing this:\n  finite_axes_cross (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "unfolding finite_axes_cross_def"], ["proof (prove)\nusing this:\n  finite\n   {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n 2. 0 < 1 / 2\n 3. 1 / 2 < 1", "moreover"], ["proof (state)\nthis:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (3 subgoals):\n 1. finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n 2. 0 < 1 / 2\n 3. 1 / 2 < 1", "have \" jump h12 t = 0\" when \"Re ((g1 +++ g2) t - z) \\<noteq> 0\" \"0 < t\" \"t < 1\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump h12 t = 0", "apply (rule jump_Im_divide_Re_0[of \"\\<lambda>t. (g1+++g2) t- z\",folded h12_def,OF _ that])"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "using assms"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "by (auto intro:path_offset)"], ["proof (state)\nthis:\n  \\<lbrakk>Re ((g1 +++ g2) ?t1 - z) \\<noteq> 0; 0 < ?t1; ?t1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump h12 ?t1 = 0\n\ngoal (3 subgoals):\n 1. finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n 2. 0 < 1 / 2\n 3. 1 / 2 < 1", "ultimately"], ["proof (chain)\npicking this:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  \\<lbrakk>Re ((g1 +++ g2) ?t1 - z) \\<noteq> 0; 0 < ?t1; ?t1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump h12 ?t1 = 0", "show \"finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\""], ["proof (prove)\nusing this:\n  finite {t. Re ((g1 +++ g2) t - z) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n  \\<lbrakk>Re ((g1 +++ g2) ?t1 - z) \\<noteq> 0; 0 < ?t1; ?t1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump h12 ?t1 = 0\n\ngoal (1 subgoal):\n 1. finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}", "apply (elim rev_finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>Re ((g1 +++ g2) t - z) \\<noteq> 0; 0 < t; t < 1\\<rbrakk>\n        \\<Longrightarrow> jump h12 t = 0) \\<Longrightarrow>\n    {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n    \\<subseteq> {t. Re ((g1 +++ g2) t - z) = 0 \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite {x. jump h12 x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\n\ngoal (2 subgoals):\n 1. 0 < 1 / 2\n 2. 1 / 2 < 1", "qed auto"], ["proof (state)\nthis:\n  cindex 0 1 h12 =\n  cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "also"], ["proof (state)\nthis:\n  cindex 0 1 h12 =\n  cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "have \"... = cindex_path g1 z + jumpF_pathstart g2 z  \n      - jumpF_pathfinish g1 z  + cindex_path g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "have \"jump h12 (1/2) =  jumpF_pathstart g2 z -  jumpF_pathfinish g1 z  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "have \"jump h12 (1 / 2) = jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "proof (cases \"Re ((g1+++g2) (1/2) - z) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "case False"], ["proof (state)\nthis:\n  Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "have \"jump h12 (1 / 2) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump h12 (1 / 2) = 0", "unfolding h12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (1 / 2) =\n    0", "apply (rule jump_Im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n 3. 0 < 1 / 2\n 4. 1 / 2 < 1", "using assms False"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n  Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (4 subgoals):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n 3. 0 < 1 / 2\n 4. 1 / 2 < 1", "by (auto intro:path_offset)"], ["proof (state)\nthis:\n  jump h12 (1 / 2) = 0\n\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "moreover"], ["proof (state)\nthis:\n  jump h12 (1 / 2) = 0\n\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "have \"jumpF h12 (at_right (1/2)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = 0", "unfolding h12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_right (1 / 2)) =\n    0", "apply (intro jumpF_im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n 3. 0 \\<le> 1 / 2\n 4. 1 / 2 < 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "using assms"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "by (auto intro:path_offset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n 2. 0 \\<le> 1 / 2\n 3. 1 / 2 < 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "using assms(5-6) False"], ["proof (prove)\nusing this:\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n  Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "unfolding joinpaths_def pathfinish_def pathstart_def"], ["proof (prove)\nusing this:\n  g1 1 = g2 0\n  g1 1 \\<noteq> z\n  Re ((if 1 / 2 \\<le> 1 / 2 then g1 (2 * (1 / 2))\n       else g2 (2 * (1 / 2) - 1)) -\n      z) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. Re ((if 1 / 2 \\<le> 1 / 2 then g1 (2 * (1 / 2))\n         else g2 (2 * (1 / 2) - 1)) -\n        z) \\<noteq>\n    0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 1 / 2\n 2. 1 / 2 < 1", "by auto"], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) = 0\n\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "moreover"], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) = 0\n\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "have \"jumpF h12 (at_left (1/2)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = 0", "unfolding h12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))\n     (at_left (1 / 2)) =\n    0", "apply (intro jumpF_im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n 3. 0 < 1 / 2\n 4. 1 / 2 \\<le> 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "using assms"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "by (auto intro:path_offset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n 2. 0 < 1 / 2\n 3. 1 / 2 \\<le> 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "using assms(5-6) False"], ["proof (prove)\nusing this:\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n  Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "unfolding joinpaths_def pathfinish_def pathstart_def"], ["proof (prove)\nusing this:\n  g1 1 = g2 0\n  g1 1 \\<noteq> z\n  Re ((if 1 / 2 \\<le> 1 / 2 then g1 (2 * (1 / 2))\n       else g2 (2 * (1 / 2) - 1)) -\n      z) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. Re ((if 1 / 2 \\<le> 1 / 2 then g1 (2 * (1 / 2))\n         else g2 (2 * (1 / 2) - 1)) -\n        z) \\<noteq>\n    0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 1 / 2\n 2. 1 / 2 \\<le> 1", "by auto"], ["proof (state)\nthis:\n  jumpF h12 (at_left (1 / 2)) = 0\n\ngoal (2 subgoals):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n 2. Re ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "ultimately"], ["proof (chain)\npicking this:\n  jump h12 (1 / 2) = 0\n  jumpF h12 (at_right (1 / 2)) = 0\n  jumpF h12 (at_left (1 / 2)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jump h12 (1 / 2) = 0\n  jumpF h12 (at_right (1 / 2)) = 0\n  jumpF h12 (at_left (1 / 2)) = 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "case True"], ["proof (state)\nthis:\n  Re ((g1 +++ g2) (1 / 2) - z) = 0\n\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "then"], ["proof (chain)\npicking this:\n  Re ((g1 +++ g2) (1 / 2) - z) = 0", "have \"Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Re ((g1 +++ g2) (1 / 2) - z) = 0\n\ngoal (1 subgoal):\n 1. Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "using assms(5,6)"], ["proof (prove)\nusing this:\n  Re ((g1 +++ g2) (1 / 2) - z) = 0\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "by (metis (no_types, hide_lams) Re_divide_numeral complex_Re_numeral complex_eq \n              divide_self_if joinpaths_def  minus_complex.simps mult.commute mult.left_neutral\n              numeral_One pathfinish_def pathstart_def right_minus_eq times_divide_eq_left zero_neq_numeral)"], ["proof (state)\nthis:\n  Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re ((g1 +++ g2) (1 / 2) - z) = 0 \\<Longrightarrow>\n    real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))", "proof (rule jump_jumpF[of _ h12 \"sgnx h12 (at_left (1/2))\" \"sgnx h12 (at_right (1/2))\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "define g where \"g=(\\<lambda>t. (g1 +++ g2) t - z)\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. (g1 +++ g2) t - z)\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "have h12_def:\"h12 = (\\<lambda>t. Im(g t)/Re(g t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h12 = (\\<lambda>t. Im (g t) / Re (g t))", "unfolding h12_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) =\n    (\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z))", "by simp"], ["proof (state)\nthis:\n  h12 = (\\<lambda>t. Im (g t) / Re (g t))\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "have \"path g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g", "using assms"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. path g", "unfolding g_def"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  path g1\n  path g2\n  pathfinish g1 = pathstart g2\n  pathfinish g1 \\<noteq> z\n\ngoal (1 subgoal):\n 1. path (\\<lambda>t. (g1 +++ g2) t - z)", "by (auto intro!:path_offset)"], ["proof (state)\nthis:\n  path g\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  path g", "have \"isCont (\\<lambda>t. Im (g t)) (1 / 2)\" \"isCont (\\<lambda>t. Re (g t)) (1 / 2)\""], ["proof (prove)\nusing this:\n  path g\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t)) (1 / 2) &&&\n    isCont (\\<lambda>t. Re (g t)) (1 / 2)", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (g t)) (1 / 2) &&&\n    isCont (\\<lambda>t. Re (g t)) (1 / 2)", "by (auto intro!:continuous_intros continuous_on_interior)"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. Im (g t)) (1 / 2)\n  isCont (\\<lambda>t. Re (g t)) (1 / 2)\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. Im (g t)) (1 / 2)\n  isCont (\\<lambda>t. Re (g t)) (1 / 2)\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "have \"Im (g (1/2)) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (g (1 / 2)) \\<noteq> 0", "using \\<open>Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (g (1 / 2)) \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im ((g1 +++ g2) (1 / 2) - z) \\<noteq> 0", "."], ["proof (state)\nthis:\n  Im (g (1 / 2)) \\<noteq> 0\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h12) (1 / 2)\n 2. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 3. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 4. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 5. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  isCont (\\<lambda>t. Im (g t)) (1 / 2)\n  isCont (\\<lambda>t. Re (g t)) (1 / 2)\n  Im (g (1 / 2)) \\<noteq> 0", "show \"isCont (inverse \\<circ> h12) (1 / 2)\""], ["proof (prove)\nusing this:\n  isCont (\\<lambda>t. Im (g t)) (1 / 2)\n  isCont (\\<lambda>t. Re (g t)) (1 / 2)\n  Im (g (1 / 2)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h12) (1 / 2)", "unfolding h12_def comp_def"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>t. Im (g t)) (1 / 2)\n  isCont (\\<lambda>t. Re (g t)) (1 / 2)\n  Im (g (1 / 2)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. inverse (Im (g x) / Re (g x))) (1 / 2)", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  isCont (inverse \\<circ> h12) (1 / 2)\n\ngoal (4 subgoals):\n 1. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 2. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 3. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 4. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "define l where \"l \\<equiv> sgnx h12 (at_left (1/2))\""], ["proof (state)\nthis:\n  l \\<equiv> sgnx h12 (at_left (1 / 2))\n\ngoal (4 subgoals):\n 1. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 2. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 3. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 4. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "define r where \"r \\<equiv> sgnx h12 (at_right (1/2))\""], ["proof (state)\nthis:\n  r \\<equiv> sgnx h12 (at_right (1 / 2))\n\ngoal (4 subgoals):\n 1. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 2. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 3. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 4. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "have *:\"continuous_on ({0<..<1}- {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}) h12\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0<..<1} - {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}) h12", "using \\<open>path g\\<close>[unfolded path_def]"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous_on ({0<..<1} - {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}) h12", "unfolding h12_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. continuous_on\n     ({0<..<1} - {t. Im (g t) / Re (g t) = 0 \\<and> 0 < t \\<and> t < 1})\n     (\\<lambda>t. Im (g t) / Re (g t))", "apply (auto intro!: continuous_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..1} g \\<Longrightarrow>\n    continuous_on\n     ({0<..<1} -\n      {t. (Im (g t) = 0 \\<or> Re (g t) = 0) \\<and> 0 < t \\<and> t < 1})\n     g\n 2. continuous_on {0..1} g \\<Longrightarrow>\n    continuous_on\n     ({0<..<1} -\n      {t. (Im (g t) = 0 \\<or> Re (g t) = 0) \\<and> 0 < t \\<and> t < 1})\n     g", "by (auto elim:continuous_on_subset)"], ["proof (state)\nthis:\n  continuous_on ({0<..<1} - {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}) h12\n\ngoal (4 subgoals):\n 1. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 2. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 3. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 4. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "have **:\"finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}", "have \"finite_axes_cross (g1 +++ g2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_axes_cross (g1 +++ g2) z", "using assms(1,2) finite_cross_intros(3)[of g1 z g2]"], ["proof (prove)\nusing this:\n  finite_axes_cross g1 z\n  finite_axes_cross g2 z\n  \\<lbrakk>finite_axes_cross g1 z; finite_axes_cross g2 z\\<rbrakk>\n  \\<Longrightarrow> finite_axes_cross (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. finite_axes_cross (g1 +++ g2) z", "by auto"], ["proof (state)\nthis:\n  finite_axes_cross (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}", "then"], ["proof (chain)\npicking this:\n  finite_axes_cross (g1 +++ g2) z", "have \"finite {t. (Re (g t) = 0 \\<or> Im (g t) = 0) \\<and> 0 < t \\<and> t < 1}\""], ["proof (prove)\nusing this:\n  finite_axes_cross (g1 +++ g2) z\n\ngoal (1 subgoal):\n 1. finite {t. (Re (g t) = 0 \\<or> Im (g t) = 0) \\<and> 0 < t \\<and> t < 1}", "unfolding finite_axes_cross_def g_def"], ["proof (prove)\nusing this:\n  finite\n   {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. (Re ((g1 +++ g2) t - z) = 0 \\<or>\n          Im ((g1 +++ g2) t - z) = 0) \\<and>\n         0 < t \\<and> t < 1}", "apply (elim rev_finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (Re ((g1 +++ g2) t - z) = 0 \\<or> Im ((g1 +++ g2) t - z) = 0) \\<and>\n        0 < t \\<and> t < 1}\n    \\<subseteq> {t. (Re ((g1 +++ g2) t - z) = 0 \\<or>\n                     Im ((g1 +++ g2) t - z) = 0) \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite {t. (Re (g t) = 0 \\<or> Im (g t) = 0) \\<and> 0 < t \\<and> t < 1}\n\ngoal (1 subgoal):\n 1. finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}", "then"], ["proof (chain)\npicking this:\n  finite {t. (Re (g t) = 0 \\<or> Im (g t) = 0) \\<and> 0 < t \\<and> t < 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {t. (Re (g t) = 0 \\<or> Im (g t) = 0) \\<and> 0 < t \\<and> t < 1}\n\ngoal (1 subgoal):\n 1. finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}", "unfolding h12_def"], ["proof (prove)\nusing this:\n  finite {t. (Re (g t) = 0 \\<or> Im (g t) = 0) \\<and> 0 < t \\<and> t < 1}\n\ngoal (1 subgoal):\n 1. finite {t. Im (g t) / Re (g t) = 0 \\<and> 0 < t \\<and> t < 1}", "by (simp add:disj_commute)"], ["proof (state)\nthis:\n  finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {t. h12 t = 0 \\<and> 0 < t \\<and> t < 1}\n\ngoal (4 subgoals):\n 1. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 2. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 3. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 4. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "have \"h12 sgnx_able at_left (1/2)\" \"l \\<noteq> 0\" \"h12 sgnx_able at_right (1/2)\" \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h12 sgnx_able at_left (1 / 2) &&& l \\<noteq> 0) &&&\n    h12 sgnx_able at_right (1 / 2) &&& r \\<noteq> 0", "unfolding l_def r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h12 sgnx_able at_left (1 / 2) &&&\n     sgnx h12 (at_left (1 / 2)) \\<noteq> 0) &&&\n    h12 sgnx_able at_right (1 / 2) &&&\n    sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "using finite_sgnx_at_left_at_right[OF ** * **]"], ["proof (prove)\nusing this:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> h12 sgnx_able at_left ?x\n  ?x \\<in> {0<..<1} \\<Longrightarrow> sgnx h12 (at_left ?x) \\<noteq> 0\n  ?x \\<in> {0<..<1} \\<Longrightarrow> h12 sgnx_able at_right ?x\n  ?x \\<in> {0<..<1} \\<Longrightarrow> sgnx h12 (at_right ?x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (h12 sgnx_able at_left (1 / 2) &&&\n     sgnx h12 (at_left (1 / 2)) \\<noteq> 0) &&&\n    h12 sgnx_able at_right (1 / 2) &&&\n    sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  h12 sgnx_able at_left (1 / 2)\n  l \\<noteq> 0\n  h12 sgnx_able at_right (1 / 2)\n  r \\<noteq> 0\n\ngoal (4 subgoals):\n 1. (h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2))\n 2. (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))\n 3. sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n 4. sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  h12 sgnx_able at_left (1 / 2)\n  l \\<noteq> 0\n  h12 sgnx_able at_right (1 / 2)\n  r \\<noteq> 0", "show \"(h12 has_sgnx l) (at_left (1/2))\" \"(h12 has_sgnx r) (at_right (1/2))\" \"l\\<noteq>0\" \"r\\<noteq>0\""], ["proof (prove)\nusing this:\n  h12 sgnx_able at_left (1 / 2)\n  l \\<noteq> 0\n  h12 sgnx_able at_right (1 / 2)\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((h12 has_sgnx l) (at_left (1 / 2)) &&&\n     (h12 has_sgnx r) (at_right (1 / 2))) &&&\n    l \\<noteq> 0 &&& r \\<noteq> 0", "unfolding l_def r_def"], ["proof (prove)\nusing this:\n  h12 sgnx_able at_left (1 / 2)\n  sgnx h12 (at_left (1 / 2)) \\<noteq> 0\n  h12 sgnx_able at_right (1 / 2)\n  sgnx h12 (at_right (1 / 2)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((h12 has_sgnx sgnx h12 (at_left (1 / 2))) (at_left (1 / 2)) &&&\n     (h12 has_sgnx sgnx h12 (at_right (1 / 2))) (at_right (1 / 2))) &&&\n    sgnx h12 (at_left (1 / 2)) \\<noteq> 0 &&&\n    sgnx h12 (at_right (1 / 2)) \\<noteq> 0", "by (auto elim:sgnx_able_sgnx)"], ["proof (state)\nthis:\n  (h12 has_sgnx l) (at_left (1 / 2))\n  (h12 has_sgnx r) (at_right (1 / 2))\n  l \\<noteq> 0\n  r \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "moreover"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "have \"jumpF h12 (at_right (1/2)) = jumpF_pathstart g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "have \" jumpF h12 (at_right (1 / 2)) = jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) =\n    jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0)", "using jumpF_linear_comp[of \"1/2\" h12 \"1/2\" 0,simplified]"], ["proof (prove)\nusing this:\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_left 0) =\n  jumpF h12 (at_left (1 / 2))\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0) =\n  jumpF h12 (at_right (1 / 2))\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) =\n    jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0)", "by simp"], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) =\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "also"], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) =\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "have \"jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0) = jumpF_pathstart g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0) =\n    jumpF_pathstart g2 z", "unfolding h12_def jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2 + 1 / 2))\n     (at_right 0) =\n    jumpF (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) (at_right 0)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_right 0 = at_right 0\n 2. \\<forall>\\<^sub>F x in at_right 0.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2 + 1 / 2))\n        x =\n       Im (g2 x - z) / Re (g2 x - z)", "show \"\\<forall>\\<^sub>F x in at_right 0. ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \n                  \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x = Im (g2 x - z) / Re (g2 x - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right 0.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2 + 1 / 2))\n        x =\n       Im (g2 x - z) / Re (g2 x - z)", "unfolding eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>0.\n       \\<forall>y>0.\n          y < b \\<longrightarrow>\n          ((\\<lambda>t.\n               Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n           (\\<lambda>x. x / 2 + 1 / 2))\n           y =\n          Im (g2 y - z) / Re (g2 y - z)", "apply (intro exI[where x=\"1/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 \\<and>\n    (\\<forall>y>0.\n        y < 1 / 2 \\<longrightarrow>\n        ((\\<lambda>t.\n             Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n         (\\<lambda>x. x / 2 + 1 / 2))\n         y =\n        Im (g2 y - z) / Re (g2 y - z))", "unfolding joinpaths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 \\<and>\n    (\\<forall>y>0.\n        y < 1 / 2 \\<longrightarrow>\n        ((\\<lambda>t.\n             Im ((if t \\<le> 1 / 2 then g1 (2 * t) else g2 (2 * t - 1)) -\n                 z) /\n             Re ((if t \\<le> 1 / 2 then g1 (2 * t) else g2 (2 * t - 1)) -\n                 z)) \\<circ>\n         (\\<lambda>x. x / 2 + 1 / 2))\n         y =\n        Im (g2 y - z) / Re (g2 y - z))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right 0.\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2 + 1 / 2))\n      x =\n     Im (g2 x - z) / Re (g2 x - z)\n\ngoal (1 subgoal):\n 1. at_right 0 = at_right 0", "qed simp"], ["proof (state)\nthis:\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) (at_right 0) =\n  jumpF_pathstart g2 z\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "finally"], ["proof (chain)\npicking this:\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z", "."], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "moreover"], ["proof (state)\nthis:\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "have \"jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "have \"jumpF h12 (at_left (1 / 2)) = jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) =\n    jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1)", "using jumpF_linear_comp[of \"1/2\" h12 0 1,simplified]"], ["proof (prove)\nusing this:\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1) =\n  jumpF h12 (at_left (1 / 2))\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_right 1) =\n  jumpF h12 (at_right (1 / 2))\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) =\n    jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1)", "by simp"], ["proof (state)\nthis:\n  jumpF h12 (at_left (1 / 2)) =\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "also"], ["proof (state)\nthis:\n  jumpF h12 (at_left (1 / 2)) =\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "have \"jumpF (h12 \\<circ> (\\<lambda>x. x / 2 )) (at_left 1) = jumpF_pathfinish g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1) =\n    jumpF_pathfinish g1 z", "unfolding h12_def jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2))\n     (at_left 1) =\n    jumpF (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) (at_left 1)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_left 1 = at_left 1\n 2. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2))\n        x =\n       Im (g1 x - z) / Re (g1 x - z)", "show \" \\<forall>\\<^sub>F x in at_left 1. ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \n              \\<circ> (\\<lambda>x. x / 2)) x = Im (g1 x - z) / Re (g1 x - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2))\n        x =\n       Im (g1 x - z) / Re (g1 x - z)", "unfolding eventually_at_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b<1.\n       \\<forall>y>b.\n          y < 1 \\<longrightarrow>\n          ((\\<lambda>t.\n               Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n           (\\<lambda>x. x / 2))\n           y =\n          Im (g1 y - z) / Re (g1 y - z)", "apply (intro exI[where x=\"1/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 < 1 \\<and>\n    (\\<forall>y>1 / 2.\n        y < 1 \\<longrightarrow>\n        ((\\<lambda>t.\n             Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n         (\\<lambda>x. x / 2))\n         y =\n        Im (g1 y - z) / Re (g1 y - z))", "unfolding joinpaths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 < 1 \\<and>\n    (\\<forall>y>1 / 2.\n        y < 1 \\<longrightarrow>\n        ((\\<lambda>t.\n             Im ((if t \\<le> 1 / 2 then g1 (2 * t) else g2 (2 * t - 1)) -\n                 z) /\n             Re ((if t \\<le> 1 / 2 then g1 (2 * t) else g2 (2 * t - 1)) -\n                 z)) \\<circ>\n         (\\<lambda>x. x / 2))\n         y =\n        Im (g1 y - z) / Re (g1 y - z))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1.\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2))\n      x =\n     Im (g1 x - z) / Re (g1 x - z)\n\ngoal (1 subgoal):\n 1. at_left 1 = at_left 1", "qed simp"], ["proof (state)\nthis:\n  jumpF (h12 \\<circ> (\\<lambda>x. x / 2)) (at_left 1) =\n  jumpF_pathfinish g1 z\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "finally"], ["proof (chain)\npicking this:\n  jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z\n\ngoal (1 subgoal):\n 1. jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "."], ["proof (state)\nthis:\n  jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "ultimately"], ["proof (chain)\npicking this:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z\n  jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF h12 (at_right (1 / 2)) - jumpF h12 (at_left (1 / 2))\n  jumpF h12 (at_right (1 / 2)) = jumpF_pathstart g2 z\n  jumpF h12 (at_left (1 / 2)) = jumpF_pathfinish g1 z\n\ngoal (1 subgoal):\n 1. real_of_int (jump h12 (1 / 2)) =\n    jumpF_pathstart g2 z - jumpF_pathfinish g1 z", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF_pathstart g2 z - jumpF_pathfinish g1 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF_pathstart g2 z - jumpF_pathfinish g1 z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "moreover"], ["proof (state)\nthis:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF_pathstart g2 z - jumpF_pathfinish g1 z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "have \"cindex 0 (1 / 2) h12 = cindex_path g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex_path g1 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex_path g1 z", "have \"cindex 0 (1 / 2) h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2))", "using cindex_linear_comp[of \"1/2\" 0 1 h12 0,simplified,symmetric]"], ["proof (prove)\nusing this:\n  cindex 0 (1 / 2) h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2))\n\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2))", "."], ["proof (state)\nthis:\n  cindex 0 (1 / 2) h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2))\n\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex_path g1 z", "also"], ["proof (state)\nthis:\n  cindex 0 (1 / 2) h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2))\n\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex_path g1 z", "have \"... = cindex_path g1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z", "let ?g = \" (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z", "have *:\"jump (h12 \\<circ> (\\<lambda>x. x / 2)) x = jump ?g x\" when \"0<x\" \"x<1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x =\n    jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x", "unfolding h12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2))\n     x =\n    jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x", "proof (rule jump_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x\n 2. \\<forall>\\<^sub>F x in at x.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2))\n        x =\n       Im (g1 x - z) / Re (g1 x - z)", "show \"\\<forall>\\<^sub>F x in at x. ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \n              \\<circ> (\\<lambda>x. x / 2)) x = Im (g1 x - z) / Re (g1 x - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2))\n        x =\n       Im (g1 x - z) / Re (g1 x - z)", "unfolding eventually_at joinpaths_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>xa\\<in>UNIV.\n          xa \\<noteq> x \\<and> dist xa x < d \\<longrightarrow>\n          Im ((if xa / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2))\n               else g2 (2 * (xa / 2) - 1)) -\n              z) /\n          Re ((if xa / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2))\n               else g2 (2 * (xa / 2) - 1)) -\n              z) =\n          Im (g1 xa - z) / Re (g1 xa - z)", "using that"], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>xa\\<in>UNIV.\n          xa \\<noteq> x \\<and> dist xa x < d \\<longrightarrow>\n          Im ((if xa / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2))\n               else g2 (2 * (xa / 2) - 1)) -\n              z) /\n          Re ((if xa / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2))\n               else g2 (2 * (xa / 2) - 1)) -\n              z) =\n          Im (g1 xa - z) / Re (g1 xa - z)", "apply (intro exI[where x=\"(1-x)/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x < 1\\<rbrakk>\n    \\<Longrightarrow> 0 < (1 - x) / 2 \\<and>\n                      (\\<forall>xa\\<in>UNIV.\n                          xa \\<noteq> x \\<and>\n                          dist xa x < (1 - x) / 2 \\<longrightarrow>\n                          Im ((if xa / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2))\n                               else g2 (2 * (xa / 2) - 1)) -\n                              z) /\n                          Re ((if xa / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2))\n                               else g2 (2 * (xa / 2) - 1)) -\n                              z) =\n                          Im (g1 xa - z) / Re (g1 xa - z))", "by (auto simp add: dist_norm)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x.\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2))\n      x =\n     Im (g1 x - z) / Re (g1 x - z)\n\ngoal (1 subgoal):\n 1. x = x", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?x1; ?x1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump (h12 \\<circ> (\\<lambda>x. x / 2)) ?x1 =\n                    jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) ?x1\n\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?x1; ?x1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump (h12 \\<circ> (\\<lambda>x. x / 2)) ?x1 =\n                    jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) ?x1", "have \"{x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} \n            = {x. jump ?g x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?x1; ?x1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump (h12 \\<circ> (\\<lambda>x. x / 2)) ?x1 =\n                    jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) ?x1\n\ngoal (1 subgoal):\n 1. {x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and>\n        0 < x \\<and> x < 1} =\n    {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x \\<noteq> 0 \\<and>\n        0 < x \\<and> x < 1}", "by auto"], ["proof (state)\nthis:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z", "then"], ["proof (chain)\npicking this:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z", "unfolding cindex_def cindex_path_def"], ["proof (prove)\nusing this:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. sum (jump (h12 \\<circ> (\\<lambda>x. x / 2)))\n     {x. jump (h12 \\<circ> (\\<lambda>x. x / 2)) x \\<noteq> 0 \\<and>\n         0 < x \\<and> x < 1} =\n    sum (jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)))\n     {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x \\<noteq>\n         0 \\<and>\n         0 < x \\<and> x < 1}", "apply (elim sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z))\n                    x \\<noteq>\n                   0 \\<and>\n                   0 < x \\<and> x < 1} \\<Longrightarrow>\n       jump (h12 \\<circ> (\\<lambda>x. x / 2)) x =\n       jump (\\<lambda>t. Im (g1 t - z) / Re (g1 t - z)) x", "by (auto simp add:*)"], ["proof (state)\nthis:\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2)) = cindex_path g1 z\n\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex_path g1 z", "finally"], ["proof (chain)\npicking this:\n  cindex 0 (1 / 2) h12 = cindex_path g1 z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex 0 (1 / 2) h12 = cindex_path g1 z\n\ngoal (1 subgoal):\n 1. cindex 0 (1 / 2) h12 = cindex_path g1 z", "."], ["proof (state)\nthis:\n  cindex 0 (1 / 2) h12 = cindex_path g1 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex 0 (1 / 2) h12 = cindex_path g1 z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "moreover"], ["proof (state)\nthis:\n  cindex 0 (1 / 2) h12 = cindex_path g1 z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "have \"cindex (1 / 2) 1 h12 = cindex_path g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 = cindex_path g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 = cindex_path g2 z", "have \"cindex (1 / 2) 1 h12 = cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 =\n    cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2))", "using cindex_linear_comp[of \"1/2\" 0 1 h12 \"1/2\",simplified,symmetric]"], ["proof (prove)\nusing this:\n  cindex (1 / 2) 1 h12 =\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2))\n\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 =\n    cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2))", "."], ["proof (state)\nthis:\n  cindex (1 / 2) 1 h12 =\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2))\n\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 = cindex_path g2 z", "also"], ["proof (state)\nthis:\n  cindex (1 / 2) 1 h12 =\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2))\n\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 = cindex_path g2 z", "have \"... = cindex_path g2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z", "let ?g = \" (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z", "have *:\"jump (h12 \\<circ> (\\<lambda>x. x / 2+1/2)) x = jump ?g x\" when \"0<x\" \"x<1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x =\n    jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x", "unfolding h12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2 + 1 / 2))\n     x =\n    jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x", "proof (rule jump_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x\n 2. \\<forall>\\<^sub>F x in at x.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2 + 1 / 2))\n        x =\n       Im (g2 x - z) / Re (g2 x - z)", "show \"\\<forall>\\<^sub>F x in at x. ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \n              \\<circ> (\\<lambda>x. x / 2+1/2)) x = Im (g2 x - z) / Re (g2 x - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x.\n       ((\\<lambda>t.\n            Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n        (\\<lambda>x. x / 2 + 1 / 2))\n        x =\n       Im (g2 x - z) / Re (g2 x - z)", "unfolding eventually_at joinpaths_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>xa\\<in>UNIV.\n          xa \\<noteq> x \\<and> dist xa x < d \\<longrightarrow>\n          Im ((if xa / 2 + 1 / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2 + 1 / 2))\n               else g2 (2 * (xa / 2 + 1 / 2) - 1)) -\n              z) /\n          Re ((if xa / 2 + 1 / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2 + 1 / 2))\n               else g2 (2 * (xa / 2 + 1 / 2) - 1)) -\n              z) =\n          Im (g2 xa - z) / Re (g2 xa - z)", "using that"], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>xa\\<in>UNIV.\n          xa \\<noteq> x \\<and> dist xa x < d \\<longrightarrow>\n          Im ((if xa / 2 + 1 / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2 + 1 / 2))\n               else g2 (2 * (xa / 2 + 1 / 2) - 1)) -\n              z) /\n          Re ((if xa / 2 + 1 / 2 \\<le> 1 / 2 then g1 (2 * (xa / 2 + 1 / 2))\n               else g2 (2 * (xa / 2 + 1 / 2) - 1)) -\n              z) =\n          Im (g2 xa - z) / Re (g2 xa - z)", "apply (intro exI[where x=\"x/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x < 1\\<rbrakk>\n    \\<Longrightarrow> 0 < x / 2 \\<and>\n                      (\\<forall>xa\\<in>UNIV.\n                          xa \\<noteq> x \\<and>\n                          dist xa x < x / 2 \\<longrightarrow>\n                          Im ((if xa / 2 + 1 / 2 \\<le> 1 / 2\n                               then g1 (2 * (xa / 2 + 1 / 2))\n                               else g2 (2 * (xa / 2 + 1 / 2) - 1)) -\n                              z) /\n                          Re ((if xa / 2 + 1 / 2 \\<le> 1 / 2\n                               then g1 (2 * (xa / 2 + 1 / 2))\n                               else g2 (2 * (xa / 2 + 1 / 2) - 1)) -\n                              z) =\n                          Im (g2 xa - z) / Re (g2 xa - z))", "by (auto simp add: dist_norm)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x.\n     ((\\<lambda>t. Im ((g1 +++ g2) t - z) / Re ((g1 +++ g2) t - z)) \\<circ>\n      (\\<lambda>x. x / 2 + 1 / 2))\n      x =\n     Im (g2 x - z) / Re (g2 x - z)\n\ngoal (1 subgoal):\n 1. x = x", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?x1; ?x1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) ?x1 =\n                    jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) ?x1\n\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?x1; ?x1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) ?x1 =\n                    jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) ?x1", "have \"{x. jump (h12 \\<circ> (\\<lambda>x. x / 2+1/2)) x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} \n            = {x. jump ?g x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?x1; ?x1 < 1\\<rbrakk>\n  \\<Longrightarrow> jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) ?x1 =\n                    jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) ?x1\n\ngoal (1 subgoal):\n 1. {x. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x \\<noteq> 0 \\<and>\n        0 < x \\<and> x < 1} =\n    {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x \\<noteq> 0 \\<and>\n        0 < x \\<and> x < 1}", "by auto"], ["proof (state)\nthis:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z", "then"], ["proof (chain)\npicking this:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z", "unfolding cindex_def cindex_path_def"], ["proof (prove)\nusing this:\n  {x. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1} =\n  {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x \\<noteq> 0 \\<and>\n      0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. sum (jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)))\n     {x. jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x \\<noteq> 0 \\<and>\n         0 < x \\<and> x < 1} =\n    sum (jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)))\n     {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x \\<noteq>\n         0 \\<and>\n         0 < x \\<and> x < 1}", "apply (elim sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z))\n                    x \\<noteq>\n                   0 \\<and>\n                   0 < x \\<and> x < 1} \\<Longrightarrow>\n       jump (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) x =\n       jump (\\<lambda>t. Im (g2 t - z) / Re (g2 t - z)) x", "by (auto simp add:*)"], ["proof (state)\nthis:\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex 0 1 (h12 \\<circ> (\\<lambda>x. x / 2 + 1 / 2)) = cindex_path g2 z\n\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 = cindex_path g2 z", "finally"], ["proof (chain)\npicking this:\n  cindex (1 / 2) 1 h12 = cindex_path g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex (1 / 2) 1 h12 = cindex_path g2 z\n\ngoal (1 subgoal):\n 1. cindex (1 / 2) 1 h12 = cindex_path g2 z", "."], ["proof (state)\nthis:\n  cindex (1 / 2) 1 h12 = cindex_path g2 z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex (1 / 2) 1 h12 = cindex_path g2 z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "ultimately"], ["proof (chain)\npicking this:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF_pathstart g2 z - jumpF_pathfinish g1 z\n  cindex 0 (1 / 2) h12 = cindex_path g1 z\n  cindex (1 / 2) 1 h12 = cindex_path g2 z", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (jump h12 (1 / 2)) =\n  jumpF_pathstart g2 z - jumpF_pathfinish g1 z\n  cindex 0 (1 / 2) h12 = cindex_path g1 z\n  cindex (1 / 2) 1 h12 = cindex_path g2 z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "by simp"], ["proof (state)\nthis:\n  real_of_int\n   (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n  real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n  jumpF_pathfinish g1 z +\n  real_of_int (cindex_path g2 z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int\n   (cindex 0 (1 / 2) h12 + jump h12 (1 / 2) + cindex (1 / 2) 1 h12) =\n  real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n  jumpF_pathfinish g1 z +\n  real_of_int (cindex_path g2 z)\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "finally"], ["proof (chain)\npicking this:\n  real_of_int (cindex_path (g1 +++ g2) z) =\n  real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n  jumpF_pathfinish g1 z +\n  real_of_int (cindex_path g2 z)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (cindex_path (g1 +++ g2) z) =\n  real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n  jumpF_pathfinish g1 z +\n  real_of_int (cindex_path g2 z)\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_path (g1 +++ g2) z) =\n    real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n    jumpF_pathfinish g1 z +\n    real_of_int (cindex_path g2 z)", "."], ["proof (state)\nthis:\n  real_of_int (cindex_path (g1 +++ g2) z) =\n  real_of_int (cindex_path g1 z) + jumpF_pathstart g2 z -\n  jumpF_pathfinish g1 z +\n  real_of_int (cindex_path g2 z)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More lemmas related @{term cindex_pathE} / @{term jumpF_pathstart} / @{term jumpF_pathfinish}\\<close>"], ["", "lemma cindex_pathE_linepath:\n  assumes \"z\\<notin>closed_segment a b\"\n  shows \"cindex_pathE (linepath a b) z = (\n    let c1 = Re a - Re z; \n        c2 = Re b - Re z; \n        c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a - Re z * Im a;\n        d1 = Im a - Im z;\n        d2 = Im b - Im z\n    in if (c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0) then \n          (if c3>0 then 1 else -1) \n       else \n          (if (c1=0 \\<longleftrightarrow> c2\\<noteq>0) \\<and> (c1=0 \\<longrightarrow>d1\\<noteq>0) \\<and> (c2=0 \\<longrightarrow> d2\\<noteq>0) then \n            if (c1=0 \\<and> (c2 >0 \\<longleftrightarrow> d1>0)) \\<or> (c2=0 \\<and> (c1 >0 \\<longleftrightarrow> d2<0))  then 1/2 else -1/2\n          else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define c1 c2 where \"c1=Re a - Re z\" and \"c2=Re b - Re z\""], ["proof (state)\nthis:\n  c1 = Re a - Re z\n  c2 = Re b - Re z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define d1 d2 where \"d1=Im a - Im z\" and \"d2=Im b - Im z\""], ["proof (state)\nthis:\n  d1 = Im a - Im z\n  d2 = Im b - Im z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "let ?g = \"linepath a b\""], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have ?thesis when \"\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"Re a= Re z \\<and> Re b=Re z\"\n      when \"0<t\" \"t<1\" and asm:\"(1-t)*Re a + t * Re b = Re z\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "unfolding c1_def c2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  0 < t\n  t < 1\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c1\\<le>0\" \"c1\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have \"Re a=Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z", "using that"], ["proof (prove)\nusing this:\n  c1 \\<le> 0\n  0 \\<le> c1\n\ngoal (1 subgoal):\n 1. Re a = Re z", "unfolding c1_def"], ["proof (prove)\nusing this:\n  Re a - Re z \\<le> 0\n  0 \\<le> Re a - Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z", "by auto"], ["proof (state)\nthis:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  Re a = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using \\<open>0<t\\<close> \\<open>t<1\\<close> asm"], ["proof (prove)\nusing this:\n  Re a = Re z\n  0 < t\n  t < 1\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "apply (cases \"Re b\" \"Re z\" rule:linorder_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a = Re z; 0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z;\n     Re b < Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n 2. \\<lbrakk>Re a = Re z; 0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z;\n     Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n 3. \\<lbrakk>Re a = Re z; 0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z;\n     Re z < Re b\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c1\\<le>0\" \"c2\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c1<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a < (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re a < (1 - t) * Re z", "using \\<open>t<1\\<close> \\<open>c1<0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  c1 < 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a < (1 - t) * Re z", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  Re a - Re z < 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a < (1 - t) * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a < (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re a < (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b \\<le> t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re b \\<le> t * Re z", "using \\<open>t>0\\<close> \\<open>c2\\<le>0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. t * Re b \\<le> t * Re z", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  Re b - Re z \\<le> 0\n\ngoal (1 subgoal):\n 1. t * Re b \\<le> t * Re z", "by auto"], ["proof (state)\nthis:\n  t * Re b \\<le> t * Re z\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re a < (1 - t) * Re z\n  t * Re b \\<le> t * Re z", "have \"(1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re a < (1 - t) * Re z\n  t * Re b \\<le> t * Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c1 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  c1 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c2<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a \\<le> (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re a \\<le> (1 - t) * Re z", "using \\<open>t<1\\<close> \\<open>c1\\<le>0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  c1 \\<le> 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a \\<le> (1 - t) * Re z", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  Re a - Re z \\<le> 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a \\<le> (1 - t) * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b < t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re b < t * Re z", "using \\<open>t>0\\<close> \\<open>c2<0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  c2 < 0\n\ngoal (1 subgoal):\n 1. t * Re b < t * Re z", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  Re b - Re z < 0\n\ngoal (1 subgoal):\n 1. t * Re b < t * Re z", "by auto"], ["proof (state)\nthis:\n  t * Re b < t * Re z\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n  t * Re b < t * Re z", "have \"(1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n  t * Re b < t * Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c2 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "ultimately"], ["proof (chain)\npicking this:\n  c1 < 0 \\<Longrightarrow> False\n  c2 < 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 < 0 \\<Longrightarrow> False\n  c2 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  c1 < 0 \\<Longrightarrow> False\n  c2 < 0 \\<Longrightarrow> False\n  c1 \\<le> 0\n  c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "unfolding c1_def c2_def"], ["proof (prove)\nusing this:\n  Re a - Re z < 0 \\<Longrightarrow> False\n  Re b - Re z < 0 \\<Longrightarrow> False\n  Re a - Re z \\<le> 0\n  Re b - Re z \\<le> 0\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by argo"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c2\\<le>0\" \"c2\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have \"Re b=Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  c2 \\<le> 0\n  0 \\<le> c2\n\ngoal (1 subgoal):\n 1. Re b = Re z", "unfolding c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z \\<le> 0\n  0 \\<le> Re b - Re z\n\ngoal (1 subgoal):\n 1. Re b = Re z", "by auto"], ["proof (state)\nthis:\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  Re b = Re z", "have \"(1 - t) * Re a = (1-t)*Re z\""], ["proof (prove)\nusing this:\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a = (1 - t) * Re z", "using asm"], ["proof (prove)\nusing this:\n  Re b = Re z\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a = (1 - t) * Re z", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (1 - t) * Re a = (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  (1 - t) * Re a = (1 - t) * Re z", "have \"Re a= Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re a = (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z", "using \\<open>t<1\\<close>"], ["proof (prove)\nusing this:\n  (1 - t) * Re a = (1 - t) * Re z\n  t < 1\n\ngoal (1 subgoal):\n 1. Re a = Re z", "by auto"], ["proof (state)\nthis:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  Re a = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using \\<open>Re b=Re z\\<close>"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by auto"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c1\\<ge>0\" \"c2\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c1>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a > (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re z < (1 - t) * Re a", "using \\<open>t<1\\<close> \\<open>c1>0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  0 < c1\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z < (1 - t) * Re a", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  0 < Re a - Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z < (1 - t) * Re a", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z < (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re z < (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b \\<ge> t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re z \\<le> t * Re b", "using \\<open>t>0\\<close> \\<open>c2\\<ge>0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  0 \\<le> c2\n\ngoal (1 subgoal):\n 1. t * Re z \\<le> t * Re b", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  0 \\<le> Re b - Re z\n\ngoal (1 subgoal):\n 1. t * Re z \\<le> t * Re b", "by auto"], ["proof (state)\nthis:\n  t * Re z \\<le> t * Re b\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re z < (1 - t) * Re a\n  t * Re z \\<le> t * Re b", "have \"(1 - t) * Re a + t * Re b > (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re z < (1 - t) * Re a\n  t * Re z \\<le> t * Re b\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  0 < c1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c2>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a \\<ge> (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re z \\<le> (1 - t) * Re a", "using \\<open>t<1\\<close> \\<open>c1\\<ge>0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  0 \\<le> c1\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z \\<le> (1 - t) * Re a", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  0 \\<le> Re a - Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z \\<le> (1 - t) * Re a", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b > t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re z < t * Re b", "using \\<open>t>0\\<close> \\<open>c2>0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  0 < c2\n\ngoal (1 subgoal):\n 1. t * Re z < t * Re b", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  0 < Re b - Re z\n\ngoal (1 subgoal):\n 1. t * Re z < t * Re b", "by auto"], ["proof (state)\nthis:\n  t * Re z < t * Re b\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n  t * Re z < t * Re b", "have \"(1 - t) * Re a + t * Re b > (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n  t * Re z < t * Re b\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "ultimately"], ["proof (chain)\npicking this:\n  0 < c1 \\<Longrightarrow> False\n  0 < c2 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c1 \\<Longrightarrow> False\n  0 < c2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  0 < c1 \\<Longrightarrow> False\n  0 < c2 \\<Longrightarrow> False\n  0 \\<le> c1\n  0 \\<le> c2\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "unfolding c1_def c2_def"], ["proof (prove)\nusing this:\n  0 < Re a - Re z \\<Longrightarrow> False\n  0 < Re b - Re z \\<Longrightarrow> False\n  0 \\<le> Re a - Re z\n  0 \\<le> Re b - Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by argo"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have \"c1\\<le>0 \\<or> c2\\<ge>0\" \"c1\\<ge>0 \\<or> c2\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 \\<le> 0 \\<or> 0 \\<le> c2 &&& 0 \\<le> c1 \\<or> c2 \\<le> 0", "using \\<open>\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. c1 \\<le> 0 \\<or> 0 \\<le> c2 &&& 0 \\<le> c1 \\<or> c2 \\<le> 0", "by auto"], ["proof (state)\nthis:\n  c1 \\<le> 0 \\<or> 0 \\<le> c2\n  0 \\<le> c1 \\<or> c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  c1 \\<le> 0 \\<or> 0 \\<le> c2\n  0 \\<le> c1 \\<or> c2 \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  c1 \\<le> 0 \\<or> 0 \\<le> c2\n  0 \\<le> c1 \\<or> c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by fast"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have \"(\\<forall>t. 0<t \\<and> t<1 \\<longrightarrow> Re(linepath a b t - z) \\<noteq> 0) \\<or> (c1=0 \\<and> c2=0)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < t \\<and> t < 1 \\<longrightarrow>\n        Re (linepath a b t - z) \\<noteq> 0) \\<or>\n    c1 = 0 \\<and> c2 = 0", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < t \\<and> t < 1 \\<longrightarrow>\n        Re (linepath a b t - z) \\<noteq> 0) \\<or>\n    c1 = 0 \\<and> c2 = 0", "unfolding linepath_def c1_def c2_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<not> (0 < Re a - Re z \\<and> Re b - Re z < 0 \\<or>\n          Re a - Re z < 0 \\<and> 0 < Re b - Re z)\n\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < t \\<and> t < 1 \\<longrightarrow>\n        Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) \\<noteq> 0) \\<or>\n    Re a - Re z = 0 \\<and> Re b - Re z = 0", "by auto"], ["proof (state)\nthis:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  c1 = 0 \\<and> c2 = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  c1 = 0 \\<and> c2 = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have ?thesis when asm:\"\\<forall>t. 0<t \\<and> t<1 \\<longrightarrow> Re(linepath a b t - z) \\<noteq> 0\"\n      and \"\\<not> (c1=0 \\<and> c2=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have cindex_ends:\"cindex_pathE ?g z = jumpF_pathstart ?g z - jumpF_pathfinish ?g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "define f where \"f=(\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "define left where \"left = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\""], ["proof (state)\nthis:\n  left = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "define right where \"right = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\""], ["proof (state)\nthis:\n  right = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "have jumpF_nz:\"jumpF f (at_left x) = 0\" \"jumpF f (at_right x) = 0\"\n          when \"0<x\" \"x<1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "have \"isCont f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f x", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) x", "using asm[rule_format,of x] that"], ["proof (prove)\nusing this:\n  0 < x \\<and> x < 1 \\<Longrightarrow> Re (linepath a b x - z) \\<noteq> 0\n  0 < x\n  x < 1\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) x", "by (auto intro!:continuous_intros isCont_Im isCont_Re)"], ["proof (state)\nthis:\n  isCont f x\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  isCont f x", "have \"continuous (at_left x) f\" \"continuous (at_right x) f\""], ["proof (prove)\nusing this:\n  isCont f x\n\ngoal (1 subgoal):\n 1. continuous (at_left x) f &&& continuous (at_right x) f", "using continuous_at_split"], ["proof (prove)\nusing this:\n  isCont f x\n  isCont ?f ?x =\n  (continuous (at_left ?x) ?f \\<and> continuous (at_right ?x) ?f)\n\ngoal (1 subgoal):\n 1. continuous (at_left x) f &&& continuous (at_right x) f", "by blast+"], ["proof (state)\nthis:\n  continuous (at_left x) f\n  continuous (at_right x) f\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  continuous (at_left x) f\n  continuous (at_right x) f", "show \"jumpF f (at_left x) = 0\" \"jumpF f (at_right x) = 0\""], ["proof (prove)\nusing this:\n  continuous (at_left x) f\n  continuous (at_right x) f\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "using jumpF_not_infinity"], ["proof (prove)\nusing this:\n  continuous (at_left x) f\n  continuous (at_right x) f\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?x; ?x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  \\<lbrakk>0 < ?x; ?x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "have \"cindex_pathE ?g z = sum (\\<lambda>x. jumpF f (at_right x)) right \n            - sum (\\<lambda>x. jumpF f (at_left x)) left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF f (at_left x))", "unfolding cindex_pathE_def cindexE_def right_def left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF\n                (\\<lambda>t.\n                    Im (linepath a b t - z) / Re (linepath a b t - z))\n                (at_right x) \\<noteq>\n               0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n        (at_right x)) -\n    (\\<Sum>x | jumpF\n                (\\<lambda>t.\n                    Im (linepath a b t - z) / Re (linepath a b t - z))\n                (at_left x) \\<noteq>\n               0 \\<and>\n               0 < x \\<and> x \\<le> 1.\n       jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n        (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF f (at_left x))", "by (fold f_def,simp)"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF f (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "have \"sum (\\<lambda>x. jumpF f (at_right x)) right = jumpF_pathstart ?g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "proof (cases \" jumpF f (at_right 0) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "case True"], ["proof (state)\nthis:\n  jumpF f (at_right 0) = 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "hence False if \"x \\<in> right\" for x"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) = 0\n  x \\<in> right\n\ngoal (1 subgoal):\n 1. False", "by (cases \"x = 0\") (auto simp: jumpF_nz right_def)"], ["proof (state)\nthis:\n  ?x \\<in> right \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> right \\<Longrightarrow> False", "have \"right = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> right \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. right = {}", "by blast"], ["proof (state)\nthis:\n  right = {}\n\ngoal (2 subgoals):\n 1. jumpF f (at_right 0) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z\n 2. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  right = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  right = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "unfolding jumpF_pathstart_def"], ["proof (prove)\nusing this:\n  right = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_right 0)", "using True"], ["proof (prove)\nusing this:\n  right = {}\n  jumpF f (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_right 0)", "apply (fold f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right = {}; jumpF f (at_right 0) = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n                      jumpF f (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n  jumpF_pathstart (linepath a b) z\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "case False"], ["proof (state)\nthis:\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "hence \"x \\<in> right \\<longleftrightarrow> x = 0\" for x"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x \\<in> right) = (x = 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF f (at_right 0) \\<noteq> 0\n  \\<forall>t.\n     0 < t \\<and> t < 1 \\<longrightarrow> Re (linepath a b t - z) \\<noteq> 0\n  \\<not> (c1 = 0 \\<and> c2 = 0)\n\ngoal (1 subgoal):\n 1. (x \\<in> right) = (x = 0)", "by (cases \"x = 0\") (auto simp: jumpF_nz right_def)"], ["proof (state)\nthis:\n  (?x \\<in> right) = (?x = 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  (?x \\<in> right) = (?x = 0)", "have \"right = {0}\""], ["proof (prove)\nusing this:\n  (?x \\<in> right) = (?x = 0)\n\ngoal (1 subgoal):\n 1. right = {0}", "by blast"], ["proof (state)\nthis:\n  right = {0}\n\ngoal (1 subgoal):\n 1. jumpF f (at_right 0) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  right = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  right = {0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF_pathstart (linepath a b) z", "unfolding jumpF_pathstart_def"], ["proof (prove)\nusing this:\n  right = {0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_right 0)", "using False"], ["proof (prove)\nusing this:\n  right = {0}\n  jumpF f (at_right 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_right 0)", "apply (fold f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right = {0}; jumpF f (at_right 0) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n                      jumpF f (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n  jumpF_pathstart (linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n  jumpF_pathstart (linepath a b) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n  jumpF_pathstart (linepath a b) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "have \"sum (\\<lambda>x. jumpF f (at_left x)) left = jumpF_pathfinish ?g z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "proof (cases \" jumpF f (at_left 1) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "case True"], ["proof (state)\nthis:\n  jumpF f (at_left 1) = 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_left 1) = 0", "have \"left = {}\""], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. left = {}", "unfolding left_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "using jumpF_nz"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) = 0\n  \\<lbrakk>0 < ?x; ?x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  \\<lbrakk>0 < ?x; ?x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "by force"], ["proof (state)\nthis:\n  left = {}\n\ngoal (2 subgoals):\n 1. jumpF f (at_left 1) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z\n 2. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  left = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  left = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "unfolding jumpF_pathfinish_def"], ["proof (prove)\nusing this:\n  left = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_left 1)", "using True"], ["proof (prove)\nusing this:\n  left = {}\n  jumpF f (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_left 1)", "apply (fold f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left = {}; jumpF f (at_left 1) = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n                      jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n  jumpF_pathfinish (linepath a b) z\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "case False"], ["proof (state)\nthis:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  jumpF f (at_left 1) \\<noteq> 0", "have \"left = {1}\""], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. left = {1}", "unfolding left_def"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {1}", "using jumpF_nz"], ["proof (prove)\nusing this:\n  jumpF f (at_left 1) \\<noteq> 0\n  \\<lbrakk>0 < ?x; ?x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  \\<lbrakk>0 < ?x; ?x < 1\\<rbrakk>\n  \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {1}", "by force"], ["proof (state)\nthis:\n  left = {1}\n\ngoal (1 subgoal):\n 1. jumpF f (at_left 1) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "then"], ["proof (chain)\npicking this:\n  left = {1}", "show ?thesis"], ["proof (prove)\nusing this:\n  left = {1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF_pathfinish (linepath a b) z", "unfolding jumpF_pathfinish_def"], ["proof (prove)\nusing this:\n  left = {1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_left 1)", "using False"], ["proof (prove)\nusing this:\n  left = {1}\n  jumpF f (at_left 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n    jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_left 1)", "apply (fold f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left = {1}; jumpF f (at_left 1) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n                      jumpF f (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n  jumpF_pathfinish (linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n  jumpF_pathfinish (linepath a b) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF f (at_left x))\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n  jumpF_pathstart (linepath a b) z\n  (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n  jumpF_pathfinish (linepath a b) z", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF f (at_left x))\n  (\\<Sum>x\\<in>right. jumpF f (at_right x)) =\n  jumpF_pathstart (linepath a b) z\n  (\\<Sum>x\\<in>left. jumpF f (at_left x)) =\n  jumpF_pathfinish (linepath a b) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have jF_start:\"jumpF_pathstart ?g z = \n          (if c1=0 \\<and> c2 \\<noteq>0 \\<and> d1 \\<noteq>0 then \n            if c2 >0 \\<longleftrightarrow> d1 > 0 then 1/2 else -1/2\n          else \n            0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "define f where \"f=(\\<lambda>t. (Im b - Im a )* t + d1)\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. (Im b - Im a) * t + d1)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "define g where \"g=(\\<lambda>t. (Re b - Re a )* t + c1)\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. (Re b - Re a) * t + c1)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have jump_eq:\"jumpF_pathstart (linepath a b) z = jumpF (\\<lambda>t. f t/g t) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    jumpF (\\<lambda>t. f t / g t) (at_right 0)", "unfolding jumpF_pathstart_def f_def linepath_def g_def d1_def c1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) /\n         Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z))\n     (at_right 0) =\n    jumpF\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n     (at_right 0)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"\\<not> (c1 =0 \\<and> c2 \\<noteq>0 \\<and> d1 \\<noteq>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have \"c2=0 \\<longrightarrow> c1\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 = 0 \\<longrightarrow> c1 \\<noteq> 0", "using \\<open>\\<not> (c1=0 \\<and> c2=0)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (c1 = 0 \\<and> c2 = 0)\n\ngoal (1 subgoal):\n 1. c2 = 0 \\<longrightarrow> c1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c2 = 0 \\<longrightarrow> c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  c2 = 0 \\<longrightarrow> c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have \"d1 =0 \\<longrightarrow> c1\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d1 = 0 \\<longrightarrow> c1 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0) \\<Longrightarrow> False", "assume \"\\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0)", "have \"a=z\""], ["proof (prove)\nusing this:\n  \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. a = z", "unfolding d1_def c1_def"], ["proof (prove)\nusing this:\n  \\<not> (Im a - Im z = 0 \\<longrightarrow> Re a - Re z \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. a = z", "by (simp add: complex_eqI)"], ["proof (state)\nthis:\n  a = z\n\ngoal (1 subgoal):\n 1. \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a = z", "have \"z\\<in>path_image (linepath a b)\""], ["proof (prove)\nusing this:\n  a = z\n\ngoal (1 subgoal):\n 1. z \\<in> path_image (linepath a b)", "by auto"], ["proof (state)\nthis:\n  z \\<in> path_image (linepath a b)\n\ngoal (1 subgoal):\n 1. \\<not> (d1 = 0 \\<longrightarrow> c1 \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z \\<in> path_image (linepath a b)", "show False"], ["proof (prove)\nusing this:\n  z \\<in> path_image (linepath a b)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z\\<notin>closed_segment a b\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> path_image (linepath a b)\n  z \\<notin> closed_segment a b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d1 = 0 \\<longrightarrow> c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  d1 = 0 \\<longrightarrow> c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"c1\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) = 0", "apply (rule jumpF_not_infinity)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous (at_right 0) (\\<lambda>t. f t / g t)\n 2. at_right 0 \\<noteq> bot", "apply (unfold f_def g_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous (at_right 0)\n     (\\<lambda>t. ((Im b - Im a) * t + d1) / ((Re b - Re a) * t + c1))\n 2. at_right 0 \\<noteq> bot", "using that"], ["proof (prove)\nusing this:\n  c1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. continuous (at_right 0)\n     (\\<lambda>t. ((Im b - Im a) * t + d1) / ((Re b - Re a) * t + c1))\n 2. at_right 0 \\<noteq> bot", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "using jump_eq"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 0\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 0\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n  c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c1 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  c2 = 0 \\<longrightarrow> c1 \\<noteq> 0\n  d1 = 0 \\<longrightarrow> c1 \\<noteq> 0\n  c1 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  c2 = 0 \\<longrightarrow> c1 \\<noteq> 0\n  d1 = 0 \\<longrightarrow> c1 \\<noteq> 0\n  c1 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "using that"], ["proof (prove)\nusing this:\n  c2 = 0 \\<longrightarrow> c1 \\<noteq> 0\n  d1 = 0 \\<longrightarrow> c1 \\<noteq> 0\n  c1 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n  \\<not> (c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "by blast"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (c1 = 0 \\<and>\n          c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<not> (c1 = 0 \\<and>\n          c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"c1=0\" \"c2 \\<noteq>0\" \"d1 \\<noteq>0\" \"c2 >0 \\<longleftrightarrow> d1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have \"(LIM x at_right 0. f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "have \"(f \\<longlongrightarrow> d1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> d1) (at_right 0)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Im b - Im a) * t + d1) \\<longlongrightarrow> d1)\n     (at_right 0)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "have \"(g \\<longlongrightarrow> 0) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_right 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) \\<longlongrightarrow> 0)\n     (at_right 0)", "using \\<open>c1=0\\<close>"], ["proof (prove)\nusing this:\n  c1 = 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) \\<longlongrightarrow> 0)\n     (at_right 0)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "have \"(g has_sgnx sgn d1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d1) (at_right 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d1) (at_right 0)", "have \"(g has_sgnx sgn (c2-c1)) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (c2 - c1)) (at_right 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) has_sgnx sgn (c2 - c1))\n     (at_right 0)", "apply (rule has_sgnx_derivative_at_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) has_real_derivative c2 - c1)\n     (at 0)\n 2. (Re b - Re a) * 0 + c1 = 0\n 3. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) has_real_derivative c2 - c1)\n     (at 0)", "unfolding c2_def c1_def d1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re z - (Re a - Re z))\n     (at 0)", "by (auto intro!: derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Re b - Re a) * 0 + c1 = 0\n 2. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re b - Re a) * 0 + c1 = 0", "using \\<open>c1=0\\<close>"], ["proof (prove)\nusing this:\n  c1 = 0\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * 0 + c1 = 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "using \\<open>c1=0\\<close> \\<open>c2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c1 = 0\n  c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d1) (at_right 0)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d1) (at_right 0)", "have \"sgn (c2-c1) = sgn d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (c2 - c1) = sgn d1", "using that"], ["proof (prove)\nusing this:\n  c1 = 0\n  c2 \\<noteq> 0\n  d1 \\<noteq> 0\n  (0 < c2) = (0 < d1)\n\ngoal (1 subgoal):\n 1. sgn (c2 - c1) = sgn d1", "by fastforce"], ["proof (state)\nthis:\n  sgn (c2 - c1) = sgn d1\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d1) (at_right 0)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n  sgn (c2 - c1) = sgn d1", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n  sgn (c2 - c1) = sgn d1\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d1) (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn d1) (at_right 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx sgn d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n  (g \\<longlongrightarrow> 0) (at_right 0)\n  (g has_sgnx sgn d1) (at_right 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n  (g \\<longlongrightarrow> 0) (at_right 0)\n  (g has_sgnx sgn d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "using filterlim_divide_at_bot_at_top_iff[of f d1 \"at_right 0\" g] \\<open>d1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n  (g \\<longlongrightarrow> 0) (at_right 0)\n  (g has_sgnx sgn d1) (at_right 0)\n  \\<lbrakk>(f \\<longlongrightarrow> d1) (at_right 0); d1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_right 0. f x / g x :> at_bot) =\n                    ((g \\<longlongrightarrow> 0) (at_right 0) \\<and>\n                     (g has_sgnx - sgn d1) (at_right 0))\n  \\<lbrakk>(f \\<longlongrightarrow> d1) (at_right 0); d1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_right 0. f x / g x :> at_top) =\n                    ((g \\<longlongrightarrow> 0) (at_right 0) \\<and>\n                     (g has_sgnx sgn d1) (at_right 0))\n  d1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "by auto"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. f x / g x :> at_top", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. f t / g t :> at_top then 1 / 2\n     else if LIM t at_right 0. f t / g t :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "using that jump_eq"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2\n  c1 = 0\n  c2 \\<noteq> 0\n  d1 \\<noteq> 0\n  (0 < c2) = (0 < d1)\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"c1=0\" \"c2 \\<noteq>0\" \"d1 \\<noteq>0\" \"\\<not> c2 >0 \\<longleftrightarrow> d1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "have \"(LIM x at_right 0. f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "have \"(f \\<longlongrightarrow> d1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> d1) (at_right 0)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Im b - Im a) * t + d1) \\<longlongrightarrow> d1)\n     (at_right 0)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "have \"(g \\<longlongrightarrow> 0) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_right 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) \\<longlongrightarrow> 0)\n     (at_right 0)", "using \\<open>c1=0\\<close>"], ["proof (prove)\nusing this:\n  c1 = 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) \\<longlongrightarrow> 0)\n     (at_right 0)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "have \"(g has_sgnx - sgn d1) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d1) (at_right 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d1) (at_right 0)", "have \"(g has_sgnx sgn (c2-c1)) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (c2 - c1)) (at_right 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) has_sgnx sgn (c2 - c1))\n     (at_right 0)", "apply (rule has_sgnx_derivative_at_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) has_real_derivative c2 - c1)\n     (at 0)\n 2. (Re b - Re a) * 0 + c1 = 0\n 3. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + c1) has_real_derivative c2 - c1)\n     (at 0)", "unfolding c2_def c1_def d1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re z - (Re a - Re z))\n     (at 0)", "by (auto intro!: derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Re b - Re a) * 0 + c1 = 0\n 2. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re b - Re a) * 0 + c1 = 0", "using \\<open>c1=0\\<close>"], ["proof (prove)\nusing this:\n  c1 = 0\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * 0 + c1 = 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "using \\<open>c1=0\\<close> \\<open>c2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c1 = 0\n  c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d1) (at_right 0)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d1) (at_right 0)", "have \"sgn (c2-c1) = - sgn d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (c2 - c1) = - sgn d1", "using that"], ["proof (prove)\nusing this:\n  c1 = 0\n  c2 \\<noteq> 0\n  d1 \\<noteq> 0\n  (\\<not> 0 < c2) = (0 < d1)\n\ngoal (1 subgoal):\n 1. sgn (c2 - c1) = - sgn d1", "by fastforce"], ["proof (state)\nthis:\n  sgn (c2 - c1) = - sgn d1\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d1) (at_right 0)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n  sgn (c2 - c1) = - sgn d1", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (c2 - c1)) (at_right 0)\n  sgn (c2 - c1) = - sgn d1\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d1) (at_right 0)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn d1) (at_right 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx - sgn d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n  (g \\<longlongrightarrow> 0) (at_right 0)\n  (g has_sgnx - sgn d1) (at_right 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n  (g \\<longlongrightarrow> 0) (at_right 0)\n  (g has_sgnx - sgn d1) (at_right 0)\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "using filterlim_divide_at_bot_at_top_iff[of f d1 \"at_right 0\" g] \\<open>d1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d1) (at_right 0)\n  (g \\<longlongrightarrow> 0) (at_right 0)\n  (g has_sgnx - sgn d1) (at_right 0)\n  \\<lbrakk>(f \\<longlongrightarrow> d1) (at_right 0); d1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_right 0. f x / g x :> at_bot) =\n                    ((g \\<longlongrightarrow> 0) (at_right 0) \\<and>\n                     (g has_sgnx - sgn d1) (at_right 0))\n  \\<lbrakk>(f \\<longlongrightarrow> d1) (at_right 0); d1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_right 0. f x / g x :> at_top) =\n                    ((g \\<longlongrightarrow> 0) (at_right 0) \\<and>\n                     (g has_sgnx sgn d1) (at_right 0))\n  d1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. f x / g x :> at_bot", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. f t / g t :> at_top then 1 / 2\n     else if LIM t at_right 0. f t / g t :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "using that jump_eq"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2\n  c1 = 0\n  c2 \\<noteq> 0\n  d1 \\<noteq> 0\n  (\\<not> 0 < c2) = (0 < d1)\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (\\<not> 0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (c1 = 0 \\<and>\n          c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (\\<not> 0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (c1 = 0 \\<and>\n          c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>c1 = 0; c2 \\<noteq> 0; d1 \\<noteq> 0;\n   (\\<not> 0 < c2) = (0 < d1)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n                     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n     then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)", "by fast"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have jF_finish:\"jumpF_pathfinish ?g z = \n          (if c2=0 \\<and> c1 \\<noteq>0 \\<and> d2 \\<noteq>0 then \n            if c1 >0 \\<longleftrightarrow> d2 > 0 then 1/2 else -1/2\n          else \n            0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "define f where \"f=(\\<lambda>t. (Im b - Im a )* t + (Im a - Im z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. (Im b - Im a) * t + (Im a - Im z))\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "define g where \"g=(\\<lambda>t. (Re b - Re a )* t + (Re a - Re z))\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. (Re b - Re a) * t + (Re a - Re z))\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have jump_eq:\"jumpF_pathfinish (linepath a b) z = jumpF (\\<lambda>t. f t/g t) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    jumpF (\\<lambda>t. f t / g t) (at_left 1)", "unfolding jumpF_pathfinish_def f_def linepath_def g_def d1_def c1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) /\n         Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z))\n     (at_left 1) =\n    jumpF\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n     (at_left 1)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"\\<not> (c2 =0 \\<and> c1 \\<noteq>0 \\<and> d2 \\<noteq>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have \"c1=0 \\<longrightarrow> c2\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 = 0 \\<longrightarrow> c2 \\<noteq> 0", "using \\<open>\\<not> (c1=0 \\<and> c2=0)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (c1 = 0 \\<and> c2 = 0)\n\ngoal (1 subgoal):\n 1. c1 = 0 \\<longrightarrow> c2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c1 = 0 \\<longrightarrow> c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  c1 = 0 \\<longrightarrow> c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have \"d2 =0 \\<longrightarrow> c2\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d2 = 0 \\<longrightarrow> c2 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0) \\<Longrightarrow> False", "assume \"\\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0)", "have \"b=z\""], ["proof (prove)\nusing this:\n  \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. b = z", "unfolding d2_def c2_def"], ["proof (prove)\nusing this:\n  \\<not> (Im b - Im z = 0 \\<longrightarrow> Re b - Re z \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. b = z", "by (simp add: complex_eqI)"], ["proof (state)\nthis:\n  b = z\n\ngoal (1 subgoal):\n 1. \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b = z", "have \"z\\<in>path_image (linepath a b)\""], ["proof (prove)\nusing this:\n  b = z\n\ngoal (1 subgoal):\n 1. z \\<in> path_image (linepath a b)", "by auto"], ["proof (state)\nthis:\n  z \\<in> path_image (linepath a b)\n\ngoal (1 subgoal):\n 1. \\<not> (d2 = 0 \\<longrightarrow> c2 \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z \\<in> path_image (linepath a b)", "show False"], ["proof (prove)\nusing this:\n  z \\<in> path_image (linepath a b)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z\\<notin>closed_segment a b\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> path_image (linepath a b)\n  z \\<notin> closed_segment a b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d2 = 0 \\<longrightarrow> c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  d2 = 0 \\<longrightarrow> c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"c2\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) = 0", "apply (rule jumpF_not_infinity)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous (at_left 1) (\\<lambda>t. f t / g t)\n 2. at_left 1 \\<noteq> bot", "apply (unfold f_def g_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous (at_left 1)\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n 2. at_left 1 \\<noteq> bot", "using that"], ["proof (prove)\nusing this:\n  c2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. continuous (at_left 1)\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n 2. at_left 1 \\<noteq> bot", "unfolding c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. continuous (at_left 1)\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n 2. at_left 1 \\<noteq> bot", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "using jump_eq"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 0\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 0\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n  c2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c2 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  c1 = 0 \\<longrightarrow> c2 \\<noteq> 0\n  d2 = 0 \\<longrightarrow> c2 \\<noteq> 0\n  c2 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 = 0 \\<longrightarrow> c2 \\<noteq> 0\n  d2 = 0 \\<longrightarrow> c2 \\<noteq> 0\n  c2 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "using that"], ["proof (prove)\nusing this:\n  c1 = 0 \\<longrightarrow> c2 \\<noteq> 0\n  d2 = 0 \\<longrightarrow> c2 \\<noteq> 0\n  c2 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n  \\<not> (c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "by blast"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (c2 = 0 \\<and>\n          c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<not> (c2 = 0 \\<and>\n          c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"c2=0\" \"c1 \\<noteq>0\" \"d2 \\<noteq>0\" \"c1 >0 \\<longleftrightarrow> d2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have \"(LIM x at_left 1. f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "have \"(f \\<longlongrightarrow> d2) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> d2) (at_left 1)", "unfolding f_def d2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im b - Im z)\n     (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "have \"(g \\<longlongrightarrow> 0) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_left 1)", "using \\<open>c2=0\\<close>"], ["proof (prove)\nusing this:\n  c2 = 0\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_left 1)", "unfolding g_def c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z = 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "have \"(g has_sgnx sgn d2) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d2) (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d2) (at_left 1)", "have \"(g has_sgnx - sgn (c2-c1)) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left 1)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (c2 - c1))\n     (at_left 1)", "apply (rule has_sgnx_derivative_at_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     c2 - c1)\n     (at 1)\n 2. (Re b - Re a) * 1 + (Re a - Re z) = 0\n 3. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     c2 - c1)\n     (at 1)", "unfolding c2_def c1_def d1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re z - (Re a - Re z))\n     (at 1)", "by (auto intro!: derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0\n 2. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0", "using \\<open>c2=0\\<close>"], ["proof (prove)\nusing this:\n  c2 = 0\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0", "unfolding c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z = 0\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "using \\<open>c2=0\\<close> \\<open>c1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c2 = 0\n  c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d2) (at_left 1)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d2) (at_left 1)", "have \"- sgn (c2-c1) = sgn d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - sgn (c2 - c1) = sgn d2", "using that"], ["proof (prove)\nusing this:\n  c2 = 0\n  c1 \\<noteq> 0\n  d2 \\<noteq> 0\n  (0 < c1) = (0 < d2)\n\ngoal (1 subgoal):\n 1. - sgn (c2 - c1) = sgn d2", "by fastforce"], ["proof (state)\nthis:\n  - sgn (c2 - c1) = sgn d2\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d2) (at_left 1)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n  - sgn (c2 - c1) = sgn d2", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n  - sgn (c2 - c1) = sgn d2\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn d2) (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn d2) (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx sgn d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n  (g \\<longlongrightarrow> 0) (at_left 1)\n  (g has_sgnx sgn d2) (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n  (g \\<longlongrightarrow> 0) (at_left 1)\n  (g has_sgnx sgn d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "using filterlim_divide_at_bot_at_top_iff[of f d2 \"at_left 1\" g] \\<open>d2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n  (g \\<longlongrightarrow> 0) (at_left 1)\n  (g has_sgnx sgn d2) (at_left 1)\n  \\<lbrakk>(f \\<longlongrightarrow> d2) (at_left 1); d2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_left 1. f x / g x :> at_bot) =\n                    ((g \\<longlongrightarrow> 0) (at_left 1) \\<and>\n                     (g has_sgnx - sgn d2) (at_left 1))\n  \\<lbrakk>(f \\<longlongrightarrow> d2) (at_left 1); d2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_left 1. f x / g x :> at_top) =\n                    ((g \\<longlongrightarrow> 0) (at_left 1) \\<and>\n                     (g has_sgnx sgn d2) (at_left 1))\n  d2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "by auto"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. f x / g x :> at_top", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. f t / g t :> at_top then 1 / 2\n     else if LIM t at_left 1. f t / g t :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "using that jump_eq"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2\n  c2 = 0\n  c1 \\<noteq> 0\n  d2 \\<noteq> 0\n  (0 < c1) = (0 < d2)\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"c2=0\" \"c1 \\<noteq>0\" \"d2 \\<noteq>0\" \"\\<not> c1 >0 \\<longleftrightarrow> d2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "have \"(LIM x at_left 1. f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "have \"(f \\<longlongrightarrow> d2) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> d2) (at_left 1)", "unfolding f_def d2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im b - Im z)\n     (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "have \"(g \\<longlongrightarrow> 0) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_left 1)", "using \\<open>c2=0\\<close>"], ["proof (prove)\nusing this:\n  c2 = 0\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> 0) (at_left 1)", "unfolding g_def c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z = 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "moreover"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "have \"(g has_sgnx - sgn d2) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d2) (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d2) (at_left 1)", "have \"(g has_sgnx - sgn (c2-c1)) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left 1)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (c2 - c1))\n     (at_left 1)", "apply (rule has_sgnx_derivative_at_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     c2 - c1)\n     (at 1)\n 2. (Re b - Re a) * 1 + (Re a - Re z) = 0\n 3. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     c2 - c1)\n     (at 1)", "unfolding c2_def c1_def d1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re z - (Re a - Re z))\n     (at 1)", "by (auto intro!: derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0\n 2. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0", "using \\<open>c2=0\\<close>"], ["proof (prove)\nusing this:\n  c2 = 0\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0", "unfolding c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z = 0\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * 1 + (Re a - Re z) = 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "using \\<open>c2=0\\<close> \\<open>c1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c2 = 0\n  c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d2) (at_left 1)", "moreover"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d2) (at_left 1)", "have \"sgn (c2-c1) = sgn d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (c2 - c1) = sgn d2", "using that"], ["proof (prove)\nusing this:\n  c2 = 0\n  c1 \\<noteq> 0\n  d2 \\<noteq> 0\n  (\\<not> 0 < c1) = (0 < d2)\n\ngoal (1 subgoal):\n 1. sgn (c2 - c1) = sgn d2", "by fastforce"], ["proof (state)\nthis:\n  sgn (c2 - c1) = sgn d2\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d2) (at_left 1)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n  sgn (c2 - c1) = sgn d2", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (c2 - c1)) (at_left 1)\n  sgn (c2 - c1) = sgn d2\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn d2) (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn d2) (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx - sgn d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n  (g \\<longlongrightarrow> 0) (at_left 1)\n  (g has_sgnx - sgn d2) (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n  (g \\<longlongrightarrow> 0) (at_left 1)\n  (g has_sgnx - sgn d2) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "using filterlim_divide_at_bot_at_top_iff[of f d2 \"at_left 1\" g] \\<open>d2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d2) (at_left 1)\n  (g \\<longlongrightarrow> 0) (at_left 1)\n  (g has_sgnx - sgn d2) (at_left 1)\n  \\<lbrakk>(f \\<longlongrightarrow> d2) (at_left 1); d2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_left 1. f x / g x :> at_bot) =\n                    ((g \\<longlongrightarrow> 0) (at_left 1) \\<and>\n                     (g has_sgnx - sgn d2) (at_left 1))\n  \\<lbrakk>(f \\<longlongrightarrow> d2) (at_left 1); d2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_left 1. f x / g x :> at_top) =\n                    ((g \\<longlongrightarrow> 0) (at_left 1) \\<and>\n                     (g has_sgnx sgn d2) (at_left 1))\n  d2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. f x / g x :> at_bot", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. f t / g t :> at_top then 1 / 2\n     else if LIM t at_left 1. f t / g t :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "using that jump_eq"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2\n  c2 = 0\n  c1 \\<noteq> 0\n  d2 \\<noteq> 0\n  (\\<not> 0 < c1) = (0 < d2)\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (\\<not> 0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (c2 = 0 \\<and>\n          c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (\\<not> 0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (c2 = 0 \\<and>\n          c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0) \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>c2 = 0; c1 \\<noteq> 0; d2 \\<noteq> 0;\n   (\\<not> 0 < c1) = (0 < d2)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n                     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n     then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "by fast"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath a b) z =\n  jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z =\n  jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "using \\<open>\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\\<close>"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z =\n  jumpF_pathstart (linepath a b) z - jumpF_pathfinish (linepath a b) z\n  jumpF_pathstart (linepath a b) z =\n  (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n   then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0)\n  jumpF_pathfinish (linepath a b) z =\n  (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n   then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0)\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "apply (fold c1_def c2_def d1_def d2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex_pathE (linepath a b) z =\n             jumpF_pathstart (linepath a b) z -\n             jumpF_pathfinish (linepath a b) z;\n     jumpF_pathstart (linepath a b) z =\n     (if c1 = 0 \\<and> c2 \\<noteq> 0 \\<and> d1 \\<noteq> 0\n      then if (0 < c2) = (0 < d1) then 1 / 2 else - 1 / 2 else 0);\n     jumpF_pathfinish (linepath a b) z =\n     (if c2 = 0 \\<and> c1 \\<noteq> 0 \\<and> d2 \\<noteq> 0\n      then if (0 < c1) = (0 < d2) then 1 / 2 else - 1 / 2 else 0);\n     \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\\<rbrakk>\n    \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                      (let c1 = c1; c2 = c2;\n                           c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                                Im z * Re b -\n                                Im b * Re a -\n                                Re z * Im a;\n                           d1 = d1; d2 = d2\n                       in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                          then if 0 < c3 then 1 else - 1\n                          else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                  (c1 = 0 \\<longrightarrow>\n                                   d1 \\<noteq> 0) \\<and>\n                                  (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                               then if c1 = 0 \\<and>\n (0 < c2) = (0 < d1) \\<or>\n c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                    then 1 / 2 else - 1 / 2\n                               else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t.\n              0 < t \\<and> t < 1 \\<longrightarrow>\n              Re (linepath a b t - z) \\<noteq> 0;\n   \\<not> (c1 = 0 \\<and> c2 = 0)\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t.\n              0 < t \\<and> t < 1 \\<longrightarrow>\n              Re (linepath a b t - z) \\<noteq> 0;\n   \\<not> (c1 = 0 \\<and> c2 = 0)\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have ?thesis when \"c1=0\" \"c2=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"(\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)", "using that"], ["proof (prove)\nusing this:\n  c1 = 0\n  c2 = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)", "unfolding linepath_def c1_def c2_def"], ["proof (prove)\nusing this:\n  Re a - Re z = 0\n  Re b - Re z = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) =\n    (\\<lambda>_. 0)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)", "have \"(\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    (\\<lambda>_. 0)", "by (metis div_by_0)"], ["proof (state)\nthis:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)", "have \"cindex_pathE (linepath a b) z = 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z = 0", "unfolding cindex_pathE_def"], ["proof (prove)\nusing this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    0", "by (auto intro: cindexE_constI)"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "using \\<open>\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\\<close> that"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z = 0\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n  c1 = 0\n  c2 = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "apply (fold c1_def c2_def d1_def d2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex_pathE (linepath a b) z = 0;\n     \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2); c1 = 0;\n     c2 = 0\\<rbrakk>\n    \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                      (let c1 = c1; c2 = c2;\n                           c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                                Im z * Re b -\n                                Im b * Re a -\n                                Re z * Im a;\n                           d1 = d1; d2 = d2\n                       in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                          then if 0 < c3 then 1 else - 1\n                          else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                  (c1 = 0 \\<longrightarrow>\n                                   d1 \\<noteq> 0) \\<and>\n                                  (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                               then if c1 = 0 \\<and>\n (0 < c2) = (0 < d1) \\<or>\n c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                    then 1 / 2 else - 1 / 2\n                               else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 = 0; c2 = 0\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  c1 = 0 \\<and> c2 = 0\n  \\<lbrakk>\\<forall>t.\n              0 < t \\<and> t < 1 \\<longrightarrow>\n              Re (linepath a b t - z) \\<noteq> 0;\n   \\<not> (c1 = 0 \\<and> c2 = 0)\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)\n  \\<lbrakk>c1 = 0; c2 = 0\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  c1 = 0 \\<and> c2 = 0\n  \\<lbrakk>\\<forall>t.\n              0 < t \\<and> t < 1 \\<longrightarrow>\n              Re (linepath a b t - z) \\<noteq> 0;\n   \\<not> (c1 = 0 \\<and> c2 = 0)\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)\n  \\<lbrakk>c1 = 0; c2 = 0\\<rbrakk>\n  \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a;\n                         d1 = Im a - Im z; d2 = Im b - Im z\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1\n                        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                (c1 = 0 \\<longrightarrow>\n                                 d1 \\<noteq> 0) \\<and>\n                                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                  then 1 / 2 else - 1 / 2\n                             else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "by fast"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have ?thesis when c1c2_diff_sgn:\"(c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define f where \"f=(\\<lambda>t. (Im b - Im a )* t + (Im a - Im z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. (Im b - Im a) * t + (Im a - Im z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define g where \"g=(\\<lambda>t. (Re b - Re a )* t + (Re a - Re z))\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. (Re b - Re a) * t + (Re a - Re z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define h where \"h=(\\<lambda>t. f t/ g t)\""], ["proof (state)\nthis:\n  h = (\\<lambda>t. f t / g t)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define c3 where \"c3=Im(a)*Re(b)+Re(z)*Im(b)+Im(z)*Re(a) -Im(z)*Re(b) - Im(b)*Re(a) - Re(z)*Im(a)\""], ["proof (state)\nthis:\n  c3 =\n  Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a -\n  Re z * Im a\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "define u where \"u = (Re z - Re a) / (Re b - Re a)\""], ["proof (state)\nthis:\n  u = (Re z - Re a) / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "let ?g = \"\\<lambda>t. linepath a b t - z\""], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"0<u\" \"u<1\" \"Re b - Re a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < u &&& u < 1 &&& Re b - Re a \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. 0 < u &&& u < 1 &&& Re b - Re a \\<noteq> 0", "unfolding u_def c1_def c2_def"], ["proof (prove)\nusing this:\n  0 < Re a - Re z \\<and> Re b - Re z < 0 \\<or>\n  Re a - Re z < 0 \\<and> 0 < Re b - Re z\n\ngoal (1 subgoal):\n 1. 0 < (Re z - Re a) / (Re b - Re a) &&&\n    (Re z - Re a) / (Re b - Re a) < 1 &&& Re b - Re a \\<noteq> 0", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 < u\n  u < 1\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"Re(?g u) = 0\" \"g u=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b u - z) = 0 &&& g u = 0", "unfolding linepath_def u_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((1 - (Re z - Re a) / (Re b - Re a)) *\\<^sub>R a +\n        ((Re z - Re a) / (Re b - Re a)) *\\<^sub>R b -\n        z) =\n    0 &&&\n    (Re b - Re a) * ((Re z - Re a) / (Re b - Re a)) + (Re a - Re z) = 0", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re a + (Re b * Re z - Re a * Re b) / (Re b - Re a) =\n    Re z + (Re a * Re z - Re a * Re a) / (Re b - Re a)\n 2. Re a +\n    (Re a * Re a + Re b * Re z - (Re a * Re b + Re a * Re z)) /\n    (Re b - Re a) =\n    Re z", "using \\<open>Re b - Re a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Re a + (Re b * Re z - Re a * Re b) / (Re b - Re a) =\n    Re z + (Re a * Re z - Re a * Re a) / (Re b - Re a)\n 2. Re a +\n    (Re a * Re a + Re b * Re z - (Re a * Re b + Re a * Re z)) /\n    (Re b - Re a) =\n    Re z", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  Re (linepath a b u - z) = 0\n  g u = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  Re (linepath a b u - z) = 0\n  g u = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"u1 = u2\" when \"Re(?g u1) = 0\" \"Re(?g u2) = 0\" for u1 u2"], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 = u2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u1 = u2", "have \" (u1 - u2) * (Re b - Re a) = Re(?g u1) - Re(?g u2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u1 - u2) * (Re b - Re a) =\n    Re (linepath a b u1 - z) - Re (linepath a b u2 - z)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u1 - u2) * (Re b - Re a) =\n    Re ((1 - u1) *\\<^sub>R a + u1 *\\<^sub>R b - z) -\n    Re ((1 - u2) *\\<^sub>R a + u2 *\\<^sub>R b - z)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (u1 - u2) * (Re b - Re a) =\n  Re (linepath a b u1 - z) - Re (linepath a b u2 - z)\n\ngoal (1 subgoal):\n 1. u1 = u2", "also"], ["proof (state)\nthis:\n  (u1 - u2) * (Re b - Re a) =\n  Re (linepath a b u1 - z) - Re (linepath a b u2 - z)\n\ngoal (1 subgoal):\n 1. u1 = u2", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b u1 - z) - Re (linepath a b u2 - z) = 0", "using that"], ["proof (prove)\nusing this:\n  Re (linepath a b u1 - z) = 0\n  Re (linepath a b u2 - z) = 0\n\ngoal (1 subgoal):\n 1. Re (linepath a b u1 - z) - Re (linepath a b u2 - z) = 0", "by auto"], ["proof (state)\nthis:\n  Re (linepath a b u1 - z) - Re (linepath a b u2 - z) = 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "finally"], ["proof (chain)\npicking this:\n  (u1 - u2) * (Re b - Re a) = 0", "have \"(u1 - u2) * (Re b - Re a) = 0\""], ["proof (prove)\nusing this:\n  (u1 - u2) * (Re b - Re a) = 0\n\ngoal (1 subgoal):\n 1. (u1 - u2) * (Re b - Re a) = 0", "."], ["proof (state)\nthis:\n  (u1 - u2) * (Re b - Re a) = 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u1 - u2) * (Re b - Re a) = 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "using \\<open>Re b - Re a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (u1 - u2) * (Re b - Re a) = 0\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "by auto"], ["proof (state)\nthis:\n  u1 = u2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re (linepath a b ?u1.0 - z) = 0;\n   Re (linepath a b ?u2.0 - z) = 0\\<rbrakk>\n  \\<Longrightarrow> ?u1.0 = ?u2.0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "ultimately"], ["proof (chain)\npicking this:\n  Re (linepath a b u - z) = 0\n  g u = 0\n  \\<lbrakk>Re (linepath a b ?u1.0 - z) = 0;\n   Re (linepath a b ?u2.0 - z) = 0\\<rbrakk>\n  \\<Longrightarrow> ?u1.0 = ?u2.0", "have re_g_iff:\"Re(?g t) = 0 \\<longleftrightarrow> t=u\" for t"], ["proof (prove)\nusing this:\n  Re (linepath a b u - z) = 0\n  g u = 0\n  \\<lbrakk>Re (linepath a b ?u1.0 - z) = 0;\n   Re (linepath a b ?u2.0 - z) = 0\\<rbrakk>\n  \\<Longrightarrow> ?u1.0 = ?u2.0\n\ngoal (1 subgoal):\n 1. (Re (linepath a b t - z) = 0) = (t = u)", "by blast"], ["proof (state)\nthis:\n  (Re (linepath a b ?t - z) = 0) = (?t = u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "define left where \"left = {x. jumpF h (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\""], ["proof (state)\nthis:\n  left = {x. jumpF h (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "define right where \"right = {x. jumpF h (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\""], ["proof (state)\nthis:\n  right = {x. jumpF h (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "have jumpF_nz:\"jumpF h (at_left x) = 0\" \"jumpF h (at_right x) = 0\"\n        when \"0\\<le>x\" \"x\\<le>1\" \"x\\<noteq>u\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_left x) = 0\n 2. jumpF h (at_right x) = 0", "have \"g x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x \\<noteq> 0", "using re_g_iff \\<open>x\\<noteq>u\\<close>"], ["proof (prove)\nusing this:\n  (Re (linepath a b ?t - z) = 0) = (?t = u)\n  x \\<noteq> u\n\ngoal (1 subgoal):\n 1. g x \\<noteq> 0", "unfolding g_def linepath_def"], ["proof (prove)\nusing this:\n  (Re ((1 - ?t) *\\<^sub>R a + ?t *\\<^sub>R b - z) = 0) = (?t = u)\n  x \\<noteq> u\n\ngoal (1 subgoal):\n 1. (Re b - Re a) * x + (Re a - Re z) \\<noteq> 0", "by (metis \\<open>Re b - Re a \\<noteq> 0\\<close> add_diff_cancel_left' diff_diff_eq2 diff_zero \n              nonzero_mult_div_cancel_left u_def)"], ["proof (state)\nthis:\n  g x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_left x) = 0\n 2. jumpF h (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  g x \\<noteq> 0", "have \"isCont h x\""], ["proof (prove)\nusing this:\n  g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont h x", "unfolding h_def f_def g_def"], ["proof (prove)\nusing this:\n  (Re b - Re a) * x + (Re a - Re z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n     x", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  isCont h x\n\ngoal (2 subgoals):\n 1. jumpF h (at_left x) = 0\n 2. jumpF h (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  isCont h x", "have \"continuous (at_left x) h\" \"continuous (at_right x) h\""], ["proof (prove)\nusing this:\n  isCont h x\n\ngoal (1 subgoal):\n 1. continuous (at_left x) h &&& continuous (at_right x) h", "using continuous_at_split"], ["proof (prove)\nusing this:\n  isCont h x\n  isCont ?f ?x =\n  (continuous (at_left ?x) ?f \\<and> continuous (at_right ?x) ?f)\n\ngoal (1 subgoal):\n 1. continuous (at_left x) h &&& continuous (at_right x) h", "by blast+"], ["proof (state)\nthis:\n  continuous (at_left x) h\n  continuous (at_right x) h\n\ngoal (2 subgoals):\n 1. jumpF h (at_left x) = 0\n 2. jumpF h (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  continuous (at_left x) h\n  continuous (at_right x) h", "show \"jumpF h (at_left x) = 0\" \"jumpF h(at_right x) = 0\""], ["proof (prove)\nusing this:\n  continuous (at_left x) h\n  continuous (at_right x) h\n\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0", "using jumpF_not_infinity"], ["proof (prove)\nusing this:\n  continuous (at_left x) h\n  continuous (at_right x) h\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_left x) = 0 &&& jumpF h (at_right x) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_left x) = 0\n  jumpF h (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "have \"cindex_pathE (linepath a b) z = sum (\\<lambda>x. jumpF h (at_right x)) right \n            - sum (\\<lambda>x. jumpF h (at_left x)) left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "have \"cindex_pathE (linepath a b) z = cindexE 0 1 (\\<lambda>t. Im (?g t) / Re (?g t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  cindexE 0 1\n   (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "also"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  cindexE 0 1\n   (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "have \"... = cindexE 0 1 h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    cindexE 0 1 h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    cindexE 0 1 h", "have \"(\\<lambda>t. Im (?g t) / Re (?g t)) = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = h", "unfolding h_def f_def g_def linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        Im ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) /\n        Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) =\n    (\\<lambda>t.\n        ((Im b - Im a) * t + (Im a - Im z)) /\n        ((Re b - Re a) * t + (Re a - Re z)))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = h\n\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    cindexE 0 1 h", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = h", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = h\n\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    cindexE 0 1 h", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1\n   (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  cindexE 0 1 h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE 0 1\n   (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  cindexE 0 1 h\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "also"], ["proof (state)\nthis:\n  cindexE 0 1\n   (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  cindexE 0 1 h\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "have \"... = sum (\\<lambda>x. jumpF h (at_right x)) right - sum (\\<lambda>x. jumpF h (at_left x)) left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 h =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "unfolding cindexE_def left_def right_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF h (at_left x)) =\n    (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and>\n               0 \\<le> x \\<and> x < 1.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1.\n       jumpF h (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 h =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n    (\\<Sum>x\\<in>left. jumpF h (at_left x))", "."], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "have \"sum (\\<lambda>x. jumpF h (at_right x)) right = jumpF h (at_right u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "proof (cases \" jumpF h (at_right u) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_right u) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n 2. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "case True"], ["proof (state)\nthis:\n  jumpF h (at_right u) = 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_right u) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n 2. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right u) = 0", "have \"right = {}\""], ["proof (prove)\nusing this:\n  jumpF h (at_right u) = 0\n\ngoal (1 subgoal):\n 1. right = {}", "unfolding right_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right u) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1} = {}", "using jumpF_nz"], ["proof (prove)\nusing this:\n  jumpF h (at_right u) = 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1} = {}", "by force"], ["proof (state)\nthis:\n  right = {}\n\ngoal (2 subgoals):\n 1. jumpF h (at_right u) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n 2. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "then"], ["proof (chain)\npicking this:\n  right = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  right = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "using True"], ["proof (prove)\nusing this:\n  right = {}\n  jumpF h (at_right u) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n\ngoal (1 subgoal):\n 1. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "case False"], ["proof (state)\nthis:\n  jumpF h (at_right u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right u) \\<noteq> 0", "have \"right = {u}\""], ["proof (prove)\nusing this:\n  jumpF h (at_right u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. right = {u}", "unfolding right_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1} = {u}", "using jumpF_nz \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  jumpF h (at_right u) \\<noteq> 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> 0 \\<le> x \\<and> x < 1} = {u}", "by fastforce"], ["proof (state)\nthis:\n  right = {u}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "then"], ["proof (chain)\npicking this:\n  right = {u}", "show ?thesis"], ["proof (prove)\nusing this:\n  right = {u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "have \"sum (\\<lambda>x. jumpF h (at_left x)) left = jumpF h (at_left u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "proof (cases \" jumpF h (at_left u) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_left u) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n 2. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "case True"], ["proof (state)\nthis:\n  jumpF h (at_left u) = 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_left u) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n 2. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_left u) = 0", "have \"left = {}\""], ["proof (prove)\nusing this:\n  jumpF h (at_left u) = 0\n\ngoal (1 subgoal):\n 1. left = {}", "unfolding left_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left u) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) = 0; jumpF h (at_left x) \\<noteq> 0;\n        0 < x; x \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "apply (case_tac \"x=u\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) = 0; jumpF h (at_left x) \\<noteq> 0;\n        0 < x; x \\<le> 1; x = u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 2. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) = 0; jumpF h (at_left x) \\<noteq> 0;\n        0 < x; x \\<le> 1; x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "using jumpF_nz \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  0 < u\n  u < 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) = 0; jumpF h (at_left x) \\<noteq> 0;\n        0 < x; x \\<le> 1; x = u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 2. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) = 0; jumpF h (at_left x) \\<noteq> 0;\n        0 < x; x \\<le> 1; x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "by auto"], ["proof (state)\nthis:\n  left = {}\n\ngoal (2 subgoals):\n 1. jumpF h (at_left u) = 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n 2. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "then"], ["proof (chain)\npicking this:\n  left = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  left = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "using True"], ["proof (prove)\nusing this:\n  left = {}\n  jumpF h (at_left u) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "case False"], ["proof (state)\nthis:\n  jumpF h (at_left u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_left u) \\<noteq> 0", "have \"left = {u}\""], ["proof (prove)\nusing this:\n  jumpF h (at_left u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. left = {u}", "unfolding left_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> 0 < x \\<and> x \\<le> 1} = {u}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) \\<noteq> 0; x \\<notin> {};\n        jumpF h (at_left x) \\<noteq> 0; 0 < x; x \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> x = u\n 2. \\<And>x. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow> 0 < u\n 3. \\<And>x. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow> u \\<le> 1", "apply (case_tac \"x=u\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) \\<noteq> 0; x \\<notin> {};\n        jumpF h (at_left x) \\<noteq> 0; 0 < x; x \\<le> 1; x = u\\<rbrakk>\n       \\<Longrightarrow> x = u\n 2. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) \\<noteq> 0; x \\<notin> {};\n        jumpF h (at_left x) \\<noteq> 0; 0 < x; x \\<le> 1;\n        x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> x = u\n 3. \\<And>x. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow> 0 < u\n 4. \\<And>x. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow> u \\<le> 1", "using jumpF_nz \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_left ?x) = 0\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; ?x \\<noteq> u\\<rbrakk>\n  \\<Longrightarrow> jumpF h (at_right ?x) = 0\n  0 < u\n  u < 1\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) \\<noteq> 0; x \\<notin> {};\n        jumpF h (at_left x) \\<noteq> 0; 0 < x; x \\<le> 1; x = u\\<rbrakk>\n       \\<Longrightarrow> x = u\n 2. \\<And>x.\n       \\<lbrakk>jumpF h (at_left u) \\<noteq> 0; x \\<notin> {};\n        jumpF h (at_left x) \\<noteq> 0; 0 < x; x \\<le> 1;\n        x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> x = u\n 3. \\<And>x. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow> 0 < u\n 4. \\<And>x. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow> u \\<le> 1", "by auto"], ["proof (state)\nthis:\n  left = {u}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left u) \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "then"], ["proof (chain)\npicking this:\n  left = {u}", "show ?thesis"], ["proof (prove)\nusing this:\n  left = {u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n  (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z =\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) -\n  (\\<Sum>x\\<in>left. jumpF h (at_left x))\n  (\\<Sum>x\\<in>right. jumpF h (at_right x)) = jumpF h (at_right u)\n  (\\<Sum>x\\<in>left. jumpF h (at_left x)) = jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    jumpF h (at_right u) - jumpF h (at_left u)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"jump h u = (if c3>0 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "have \"Re b-Re a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "using c1c2_diff_sgn"], ["proof (prove)\nusing this:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "unfolding c1_def c2_def"], ["proof (prove)\nusing this:\n  0 < Re a - Re z \\<and> Re b - Re z < 0 \\<or>\n  Re a - Re z < 0 \\<and> 0 < Re b - Re z\n\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "have \"jump (\\<lambda>t. Im(?g t) / Re(?g t)) u = jump h u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    jump h u", "apply (rule arg_cong2[where f=jump])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = h\n 2. u = u", "unfolding linepath_def h_def f_def g_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>t.\n        Im ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) /\n        Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) =\n    (\\<lambda>t.\n        ((Im b - Im a) * t + (Im a - Im z)) /\n        ((Re b - Re a) * t + (Re a - Re z)))\n 2. u = u", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  jump h u\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  jump h u\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "have \"jump (\\<lambda>t. Im(?g t) / Re(?g t)) u \n          = (if sgn (Re b -Re a) = sgn (Im(?g u)) then 1 else - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)", "proof (rule jump_divide_derivative)"], ["proof (state)\ngoal (5 subgoals):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u\n 2. Re (linepath a b u - z) = 0\n 3. Im (linepath a b u - z) \\<noteq> 0\n 4. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 5. Re b - Re a \\<noteq> 0", "have \"path ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (\\<lambda>t. linepath a b t - z)", "using path_offset"], ["proof (prove)\nusing this:\n  path (\\<lambda>t. ?g t - ?z) = path ?g\n\ngoal (1 subgoal):\n 1. path (\\<lambda>t. linepath a b t - z)", "by auto"], ["proof (state)\nthis:\n  path (\\<lambda>t. linepath a b t - z)\n\ngoal (5 subgoals):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u\n 2. Re (linepath a b u - z) = 0\n 3. Im (linepath a b u - z) \\<noteq> 0\n 4. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 5. Re b - Re a \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  path (\\<lambda>t. linepath a b t - z)", "have \"continuous_on {0..1} (\\<lambda>t. Im(?g t))\""], ["proof (prove)\nusing this:\n  path (\\<lambda>t. linepath a b t - z)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))", "using continuous_on_Im path_def"], ["proof (prove)\nusing this:\n  path (\\<lambda>t. linepath a b t - z)\n  continuous_on ?s ?g \\<Longrightarrow>\n  continuous_on ?s (\\<lambda>x. Im (?g x))\n  path ?g = continuous_on {0..1} ?g\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))", "by blast"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))\n\ngoal (5 subgoals):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u\n 2. Re (linepath a b u - z) = 0\n 3. Im (linepath a b u - z) \\<noteq> 0\n 4. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 5. Re b - Re a \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))", "show \"isCont (\\<lambda>t. Im (?g t)) u\""], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u", "apply (elim continuous_on_interior)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> interior {0..1}", "using \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. u \\<in> interior {0..1}", "by auto"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. Im (linepath a b t - z)) u\n\ngoal (4 subgoals):\n 1. Re (linepath a b u - z) = 0\n 2. Im (linepath a b u - z) \\<noteq> 0\n 3. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 4. Re b - Re a \\<noteq> 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Re (linepath a b u - z) = 0\n 2. Im (linepath a b u - z) \\<noteq> 0\n 3. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 4. Re b - Re a \\<noteq> 0", "show \"Re(?g u) = 0\" \"Re b - Re a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b u - z) = 0 &&& Re b - Re a \\<noteq> 0", "using \\<open>Re(?g u) = 0\\<close> \\<open>Re b - Re a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Re (linepath a b u - z) = 0\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (linepath a b u - z) = 0 &&& Re b - Re a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Re (linepath a b u - z) = 0\n  Re b - Re a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Im (linepath a b u - z) \\<noteq> 0\n 2. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)", "show \"Im(?g u) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> Im (linepath a b u - z) \\<noteq> 0 \""], ["proof (state)\nthis:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0", "have \"?g u = 0\""], ["proof (prove)\nusing this:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. linepath a b u - z = 0", "using \\<open>Re(?g u) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0\n  Re (linepath a b u - z) = 0\n\ngoal (1 subgoal):\n 1. linepath a b u - z = 0", "by (simp add: complex_eq_iff)"], ["proof (state)\nthis:\n  linepath a b u - z = 0\n\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  linepath a b u - z = 0", "have \"z \\<in> closed_segment a b\""], ["proof (prove)\nusing this:\n  linepath a b u - z = 0\n\ngoal (1 subgoal):\n 1. z \\<in> closed_segment a b", "using \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  linepath a b u - z = 0\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. z \\<in> closed_segment a b", "by (auto intro:linepath_in_path)"], ["proof (state)\nthis:\n  z \\<in> closed_segment a b\n\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  z \\<in> closed_segment a b\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z \\<notin> closed_segment a b\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> closed_segment a b\n  z \\<notin> closed_segment a b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (linepath a b u - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)", "show \"((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a) (at u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) has_real_derivative\n     Re b - Re a)\n     (at u)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n   (at u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "have \"sgn (Re b - Re a) = sgn (Im(?g u)) \\<longleftrightarrow> c3 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "have \"Im(?g u) = c3/(Re b-Re a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "define ba where \"ba = Re b-Re a\""], ["proof (state)\nthis:\n  ba = Re b - Re a\n\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "have \"ba\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ba \\<noteq> 0", "using \\<open>Re b - Re a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ba \\<noteq> 0", "unfolding ba_def"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ba \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "then"], ["proof (chain)\npicking this:\n  ba \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ba \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "unfolding linepath_def u_def c3_def"], ["proof (prove)\nusing this:\n  ba \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im ((1 - (Re z - Re a) / (Re b - Re a)) *\\<^sub>R a +\n        ((Re z - Re a) / (Re b - Re a)) *\\<^sub>R b -\n        z) =\n    (Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a -\n     Re z * Im a) /\n    (Re b - Re a)", "apply (fold ba_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ba \\<noteq> 0 \\<Longrightarrow>\n    Im ((1 - (Re z - Re a) / ba) *\\<^sub>R a +\n        ((Re z - Re a) / ba) *\\<^sub>R b -\n        z) =\n    (Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a -\n     Re z * Im a) /\n    ba", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ba \\<noteq> 0 \\<Longrightarrow>\n    ba * Im a + (Im a * Re a + Im z * Re b) =\n    ba * Im z + (Im a * Re b + Im z * Re a)", "by (auto simp add:algebra_simps ba_def)"], ["proof (state)\nthis:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "then"], ["proof (chain)\npicking this:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)", "have \"sgn (Re b - Re a) = sgn (Im(?g u)) \\<longleftrightarrow> sgn (Re b - Re a) = sgn (c3/(Re b-Re a))\""], ["proof (prove)\nusing this:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) =\n    (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a)))", "by auto"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) =\n  (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a)))\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "also"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) =\n  (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a)))\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "have \"... \\<longleftrightarrow> c3>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) = (0 < c3)", "using \\<open>Re b-Re a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) = (0 < c3)", "apply (cases \"0::real\" c3 rule:linorder_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Re b - Re a \\<noteq> 0; 0 < c3\\<rbrakk>\n    \\<Longrightarrow> (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) =\n                      (0 < c3)\n 2. \\<lbrakk>Re b - Re a \\<noteq> 0; 0 = c3\\<rbrakk>\n    \\<Longrightarrow> (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) =\n                      (0 < c3)\n 3. \\<lbrakk>Re b - Re a \\<noteq> 0; c3 < 0\\<rbrakk>\n    \\<Longrightarrow> (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) =\n                      (0 < c3)", "by (auto simp add:sgn_zero_iff)"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "finally"], ["proof (chain)\npicking this:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "show ?thesis"], ["proof (prove)\nusing this:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "."], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  jump h u\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "show ?thesis"], ["proof (prove)\nusing this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  jump h u\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. jump h u = (if 0 < c3 then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  jump h u = (if 0 < c3 then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jump h u = (if 0 < c3 then 1 else - 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "moreover"], ["proof (state)\nthis:\n  jump h u = (if 0 < c3 then 1 else - 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "have \"jump h u = jumpF h (at_right u) - jumpF h (at_left u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump h u) = jumpF h (at_right u) - jumpF h (at_left u)", "proof (rule jump_jumpF)"], ["proof (state)\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h) u\n 2. (h has_sgnx ?l) (at_left u)\n 3. (h has_sgnx ?r) (at_right u)\n 4. ?l \\<noteq> 0\n 5. ?r \\<noteq> 0", "have \"f u\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f u \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f u \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> f u \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> f u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> f u \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> f u \\<noteq> 0", "have \"z\\<in>path_image (linepath a b)\""], ["proof (prove)\nusing this:\n  \\<not> f u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<in> path_image (linepath a b)", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<not> f u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<in> linepath a b ` {0..1}", "apply (rule_tac rev_image_eqI[of u])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> f u \\<noteq> 0 \\<Longrightarrow> u \\<in> {0..1}\n 2. \\<not> f u \\<noteq> 0 \\<Longrightarrow> z = linepath a b u", "using re_g_iff[of u,simplified] \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  Re (linepath a b u) = Re z\n  0 < u\n  u < 1\n\ngoal (2 subgoals):\n 1. \\<not> f u \\<noteq> 0 \\<Longrightarrow> u \\<in> {0..1}\n 2. \\<not> f u \\<noteq> 0 \\<Longrightarrow> z = linepath a b u", "unfolding f_def linepath_def"], ["proof (prove)\nusing this:\n  Re ((1 - u) *\\<^sub>R a + u *\\<^sub>R b) = Re z\n  0 < u\n  u < 1\n\ngoal (2 subgoals):\n 1. \\<not> (Im b - Im a) * u + (Im a - Im z) \\<noteq> 0 \\<Longrightarrow>\n    u \\<in> {0..1}\n 2. \\<not> (Im b - Im a) * u + (Im a - Im z) \\<noteq> 0 \\<Longrightarrow>\n    z = (1 - u) *\\<^sub>R a + u *\\<^sub>R b", "by (auto simp add:algebra_simps complex.expand)"], ["proof (state)\nthis:\n  z \\<in> path_image (linepath a b)\n\ngoal (1 subgoal):\n 1. \\<not> f u \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z \\<in> path_image (linepath a b)", "show False"], ["proof (prove)\nusing this:\n  z \\<in> path_image (linepath a b)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z\\<notin>closed_segment a b\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> path_image (linepath a b)\n  z \\<notin> closed_segment a b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f u \\<noteq> 0\n\ngoal (5 subgoals):\n 1. isCont (inverse \\<circ> h) u\n 2. (h has_sgnx ?l) (at_left u)\n 3. (h has_sgnx ?r) (at_right u)\n 4. ?l \\<noteq> 0\n 5. ?r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  f u \\<noteq> 0", "show \"isCont (inverse \\<circ> h) u\""], ["proof (prove)\nusing this:\n  f u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (inverse \\<circ> h) u", "unfolding h_def comp_def f_def g_def"], ["proof (prove)\nusing this:\n  (Im b - Im a) * u + (Im a - Im z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>x.\n         inverse\n          (((Im b - Im a) * x + (Im a - Im z)) /\n           ((Re b - Re a) * x + (Re a - Re z))))\n     u", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  isCont (inverse \\<circ> h) u\n\ngoal (4 subgoals):\n 1. (h has_sgnx ?l) (at_left u)\n 2. (h has_sgnx ?r) (at_right u)\n 3. ?l \\<noteq> 0\n 4. ?r \\<noteq> 0", "define hs where \"hs = sgn ((f u) / (c2 -c1))\""], ["proof (state)\nthis:\n  hs = sgn (f u / (c2 - c1))\n\ngoal (4 subgoals):\n 1. (h has_sgnx ?l) (at_left u)\n 2. (h has_sgnx ?r) (at_right u)\n 3. ?l \\<noteq> 0\n 4. ?r \\<noteq> 0", "show \"(h has_sgnx -hs) (at_left u)\" \"(h has_sgnx hs) (at_right u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h has_sgnx - hs) (at_left u) &&& (h has_sgnx hs) (at_right u)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (h has_sgnx - hs) (at_left u)\n 2. (h has_sgnx hs) (at_right u)", "have ff:\"(f has_sgnx sgn (f u)) (at_left u)\" \"(f has_sgnx sgn (f u)) (at_right u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f u)) (at_left u) &&&\n    (f has_sgnx sgn (f u)) (at_right u)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (f has_sgnx sgn (f u)) (at_left u)\n 2. (f has_sgnx sgn (f u)) (at_right u)", "have \"(f \\<longlongrightarrow> f u) (at u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<midarrow>u\\<rightarrow> f u", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<midarrow>u\n    \\<rightarrow> (Im b - Im a) * u + (Im a - Im z)", "by (auto intro!:tendsto_intros)"], ["proof (state)\nthis:\n  f \\<midarrow>u\\<rightarrow> f u\n\ngoal (2 subgoals):\n 1. (f has_sgnx sgn (f u)) (at_left u)\n 2. (f has_sgnx sgn (f u)) (at_right u)", "then"], ["proof (chain)\npicking this:\n  f \\<midarrow>u\\<rightarrow> f u", "have \" (f has_sgnx sgn (f u)) (at u)\""], ["proof (prove)\nusing this:\n  f \\<midarrow>u\\<rightarrow> f u\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f u)) (at u)", "using tendsto_nonzero_has_sgnx[of f, OF _ \\<open>f u\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  f \\<midarrow>u\\<rightarrow> f u\n  (f \\<longlongrightarrow> f u) ?F \\<Longrightarrow>\n  (f has_sgnx sgn (f u)) ?F\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f u)) (at u)", "by auto"], ["proof (state)\nthis:\n  (f has_sgnx sgn (f u)) (at u)\n\ngoal (2 subgoals):\n 1. (f has_sgnx sgn (f u)) (at_left u)\n 2. (f has_sgnx sgn (f u)) (at_right u)", "then"], ["proof (chain)\npicking this:\n  (f has_sgnx sgn (f u)) (at u)", "show \"(f has_sgnx sgn (f u)) (at_left u)\" \"(f has_sgnx sgn (f u)) (at_right u)\""], ["proof (prove)\nusing this:\n  (f has_sgnx sgn (f u)) (at u)\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f u)) (at_left u) &&&\n    (f has_sgnx sgn (f u)) (at_right u)", "using has_sgnx_split"], ["proof (prove)\nusing this:\n  (f has_sgnx sgn (f u)) (at u)\n  (?f has_sgnx ?c) (at ?x) =\n  ((?f has_sgnx ?c) (at_left ?x) \\<and> (?f has_sgnx ?c) (at_right ?x))\n\ngoal (1 subgoal):\n 1. (f has_sgnx sgn (f u)) (at_left u) &&&\n    (f has_sgnx sgn (f u)) (at_right u)", "by blast+"], ["proof (state)\nthis:\n  (f has_sgnx sgn (f u)) (at_left u)\n  (f has_sgnx sgn (f u)) (at_right u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f has_sgnx sgn (f u)) (at_left u)\n  (f has_sgnx sgn (f u)) (at_right u)\n\ngoal (2 subgoals):\n 1. (h has_sgnx - hs) (at_left u)\n 2. (h has_sgnx hs) (at_right u)", "have gg:\"(g has_sgnx - sgn (c2 - c1)) (at_left u)\" \"(g has_sgnx sgn (c2 - c1)) (at_right u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left u) &&&\n    (g has_sgnx sgn (c2 - c1)) (at_right u)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left u)\n 2. (g has_sgnx sgn (c2 - c1)) (at_right u)", "have \"(g has_real_derivative c2 - c1) (at u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative c2 - c1) (at u)", "unfolding g_def c1_def c2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re z - (Re a - Re z))\n     (at u)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  (g has_real_derivative c2 - c1) (at u)\n\ngoal (2 subgoals):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left u)\n 2. (g has_sgnx sgn (c2 - c1)) (at_right u)", "moreover"], ["proof (state)\nthis:\n  (g has_real_derivative c2 - c1) (at u)\n\ngoal (2 subgoals):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left u)\n 2. (g has_sgnx sgn (c2 - c1)) (at_right u)", "have \"c2 - c1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. c2 - c1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c2 - c1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (g has_sgnx - sgn (c2 - c1)) (at_left u)\n 2. (g has_sgnx sgn (c2 - c1)) (at_right u)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_real_derivative c2 - c1) (at u)\n  c2 - c1 \\<noteq> 0", "show \"(g has_sgnx sgn (c2 - c1)) (at_right u)\" \n              \"(g has_sgnx - sgn (c2 - c1)) (at_left u)\""], ["proof (prove)\nusing this:\n  (g has_real_derivative c2 - c1) (at u)\n  c2 - c1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (c2 - c1)) (at_right u) &&&\n    (g has_sgnx - sgn (c2 - c1)) (at_left u)", "using has_sgnx_derivative_at_right[of g \"c2-c1\" u] \n                has_sgnx_derivative_at_left[of g \"c2-c1\" u] \\<open>g u=0\\<close>"], ["proof (prove)\nusing this:\n  (g has_real_derivative c2 - c1) (at u)\n  c2 - c1 \\<noteq> 0\n  \\<lbrakk>(g has_real_derivative c2 - c1) (at u); g u = 0;\n   c2 - c1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx sgn (c2 - c1)) (at_right u)\n  \\<lbrakk>(g has_real_derivative c2 - c1) (at u); g u = 0;\n   c2 - c1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (c2 - c1)) (at_left u)\n  g u = 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (c2 - c1)) (at_right u) &&&\n    (g has_sgnx - sgn (c2 - c1)) (at_left u)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (c2 - c1)) (at_right u)\n  (g has_sgnx - sgn (c2 - c1)) (at_left u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (c2 - c1)) (at_left u)\n  (g has_sgnx sgn (c2 - c1)) (at_right u)\n\ngoal (2 subgoals):\n 1. (h has_sgnx - hs) (at_left u)\n 2. (h has_sgnx hs) (at_right u)", "show \"(h has_sgnx - hs) (at_left u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h has_sgnx - hs) (at_left u)", "using has_sgnx_divide[OF ff(1) gg(1)]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x / g x) has_sgnx sgn (f u) / - sgn (c2 - c1)) (at_left u)\n\ngoal (1 subgoal):\n 1. (h has_sgnx - hs) (at_left u)", "unfolding h_def hs_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x / g x) has_sgnx sgn (f u) / - sgn (c2 - c1)) (at_left u)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. f t / g t) has_sgnx - sgn (f u / (c2 - c1))) (at_left u)", "by auto"], ["proof (state)\nthis:\n  (h has_sgnx - hs) (at_left u)\n\ngoal (1 subgoal):\n 1. (h has_sgnx hs) (at_right u)", "show \"(h has_sgnx hs) (at_right u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h has_sgnx hs) (at_right u)", "using has_sgnx_divide[OF ff(2) gg(2)]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x / g x) has_sgnx sgn (f u) / sgn (c2 - c1)) (at_right u)\n\ngoal (1 subgoal):\n 1. (h has_sgnx hs) (at_right u)", "unfolding h_def hs_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. f x / g x) has_sgnx sgn (f u) / sgn (c2 - c1)) (at_right u)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. f t / g t) has_sgnx sgn (f u / (c2 - c1))) (at_right u)", "by auto"], ["proof (state)\nthis:\n  (h has_sgnx hs) (at_right u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (h has_sgnx - hs) (at_left u)\n  (h has_sgnx hs) (at_right u)\n\ngoal (2 subgoals):\n 1. - sgn (f u / (c2 - c1)) \\<noteq> 0\n 2. sgn (f u / (c2 - c1)) \\<noteq> 0", "show \"hs\\<noteq>0\" \"-hs\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs \\<noteq> 0 &&& - hs \\<noteq> 0", "unfolding hs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (f u / (c2 - c1)) \\<noteq> 0 &&& - sgn (f u / (c2 - c1)) \\<noteq> 0", "using \\<open>f u\\<noteq>0\\<close> that"], ["proof (prove)\nusing this:\n  f u \\<noteq> 0\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. sgn (f u / (c2 - c1)) \\<noteq> 0 &&& - sgn (f u / (c2 - c1)) \\<noteq> 0", "by (auto simp add:sgn_if)"], ["proof (state)\nthis:\n  hs \\<noteq> 0\n  - hs \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (jump h u) = jumpF h (at_right u) - jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\n  jump h u = (if 0 < c3 then 1 else - 1)\n  real_of_int (jump h u) = jumpF h (at_right u) - jumpF h (at_left u)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\n  jump h u = (if 0 < c3 then 1 else - 1)\n  real_of_int (jump h u) = jumpF h (at_right u) - jumpF h (at_left u)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "using that"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath a b) z = jumpF h (at_right u) - jumpF h (at_left u)\n  jump h u = (if 0 < c3 then 1 else - 1)\n  real_of_int (jump h u) = jumpF h (at_right u) - jumpF h (at_left u)\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "apply (fold c1_def c2_def c3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex_pathE (linepath a b) z =\n             jumpF h (at_right u) - jumpF h (at_left u);\n     jump h u = (if 0 < c3 then 1 else - 1);\n     real_of_int (jump h u) = jumpF h (at_right u) - jumpF h (at_left u);\n     0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\\<rbrakk>\n    \\<Longrightarrow> cindex_pathE (linepath a b) z =\n                      (let c1 = c1; c2 = c2; c3 = c3; d1 = Im a - Im z;\n                           d2 = Im b - Im z\n                       in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                          then if 0 < c3 then 1 else - 1\n                          else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                                  (c1 = 0 \\<longrightarrow>\n                                   d1 \\<noteq> 0) \\<and>\n                                  (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n                               then if c1 = 0 \\<and>\n (0 < c2) = (0 < d1) \\<or>\n c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                                    then 1 / 2 else - 1 / 2\n                               else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2 \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2 \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2 \\<Longrightarrow>\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a;\n         d1 = Im a - Im z; d2 = Im b - Im z\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0)", "by fast"], ["proof (state)\nthis:\n  cindex_pathE (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a;\n       d1 = Im a - Im z; d2 = Im b - Im z\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1\n      else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n              (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n              (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n           then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                   c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                then 1 / 2 else - 1 / 2\n           else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_path_linepath:\n  assumes \"z\\<notin>path_image (linepath a b)\"\n  shows \"cindex_path (linepath a b) z = (\n    let c1=Re(a)-Re(z) ; c2=Re(b)-Re(z) ; \n        c3 = Im(a)*Re(b)+Re(z)*Im(b)+Im(z)*Re(a) -Im(z)*Re(b) - Im(b)*Re(a) - Re(z)*Im(a)\n    in if (c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0) then (if c3>0 then 1 else -1) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "define c1 c2 where \"c1=Re(a)-Re(z)\" and \"c2=Re(b)-Re(z)\""], ["proof (state)\nthis:\n  c1 = Re a - Re z\n  c2 = Re b - Re z\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "let ?g = \"linepath a b\""], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have ?thesis when \"\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"Re a= Re z \\<and> Re b=Re z\"\n      when \"0<t\" \"t<1\" and asm:\"(1-t)*Re a + t * Re b = Re z\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "unfolding c1_def c2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  0 < t\n  t < 1\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c1\\<le>0\" \"c1\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have \"Re a=Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z", "using that"], ["proof (prove)\nusing this:\n  c1 \\<le> 0\n  0 \\<le> c1\n\ngoal (1 subgoal):\n 1. Re a = Re z", "unfolding c1_def"], ["proof (prove)\nusing this:\n  Re a - Re z \\<le> 0\n  0 \\<le> Re a - Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z", "by auto"], ["proof (state)\nthis:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  Re a = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using \\<open>0<t\\<close> \\<open>t<1\\<close> asm"], ["proof (prove)\nusing this:\n  Re a = Re z\n  0 < t\n  t < 1\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "apply (cases \"Re b\" \"Re z\" rule:linorder_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Re a = Re z; 0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z;\n     Re b < Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n 2. \\<lbrakk>Re a = Re z; 0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z;\n     Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n 3. \\<lbrakk>Re a = Re z; 0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z;\n     Re z < Re b\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c1\\<le>0\" \"c2\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c1<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a < (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re a < (1 - t) * Re z", "using \\<open>t<1\\<close> \\<open>c1<0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  c1 < 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a < (1 - t) * Re z", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  Re a - Re z < 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a < (1 - t) * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a < (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re a < (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b \\<le> t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re b \\<le> t * Re z", "using \\<open>t>0\\<close> \\<open>c2\\<le>0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. t * Re b \\<le> t * Re z", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  Re b - Re z \\<le> 0\n\ngoal (1 subgoal):\n 1. t * Re b \\<le> t * Re z", "by auto"], ["proof (state)\nthis:\n  t * Re b \\<le> t * Re z\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re a < (1 - t) * Re z\n  t * Re b \\<le> t * Re z", "have \"(1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re a < (1 - t) * Re z\n  t * Re b \\<le> t * Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c1 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  c1 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c2<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a \\<le> (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re a \\<le> (1 - t) * Re z", "using \\<open>t<1\\<close> \\<open>c1\\<le>0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  c1 \\<le> 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a \\<le> (1 - t) * Re z", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  Re a - Re z \\<le> 0\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a \\<le> (1 - t) * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b < t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re b < t * Re z", "using \\<open>t>0\\<close> \\<open>c2<0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  c2 < 0\n\ngoal (1 subgoal):\n 1. t * Re b < t * Re z", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  Re b - Re z < 0\n\ngoal (1 subgoal):\n 1. t * Re b < t * Re z", "by auto"], ["proof (state)\nthis:\n  t * Re b < t * Re z\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n  t * Re b < t * Re z", "have \"(1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re a \\<le> (1 - t) * Re z\n  t * Re b < t * Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re a + t * Re b < (1 - t) * Re z + t * Re z\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c2 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "ultimately"], ["proof (chain)\npicking this:\n  c1 < 0 \\<Longrightarrow> False\n  c2 < 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 < 0 \\<Longrightarrow> False\n  c2 < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  c1 < 0 \\<Longrightarrow> False\n  c2 < 0 \\<Longrightarrow> False\n  c1 \\<le> 0\n  c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "unfolding c1_def c2_def"], ["proof (prove)\nusing this:\n  Re a - Re z < 0 \\<Longrightarrow> False\n  Re b - Re z < 0 \\<Longrightarrow> False\n  Re a - Re z \\<le> 0\n  Re b - Re z \\<le> 0\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by argo"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c2\\<le>0\" \"c2\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have \"Re b=Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  c2 \\<le> 0\n  0 \\<le> c2\n\ngoal (1 subgoal):\n 1. Re b = Re z", "unfolding c2_def"], ["proof (prove)\nusing this:\n  Re b - Re z \\<le> 0\n  0 \\<le> Re b - Re z\n\ngoal (1 subgoal):\n 1. Re b = Re z", "by auto"], ["proof (state)\nthis:\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  Re b = Re z", "have \"(1 - t) * Re a = (1-t)*Re z\""], ["proof (prove)\nusing this:\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a = (1 - t) * Re z", "using asm"], ["proof (prove)\nusing this:\n  Re b = Re z\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re a = (1 - t) * Re z", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (1 - t) * Re a = (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  (1 - t) * Re a = (1 - t) * Re z", "have \"Re a= Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re a = (1 - t) * Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z", "using \\<open>t<1\\<close>"], ["proof (prove)\nusing this:\n  (1 - t) * Re a = (1 - t) * Re z\n  t < 1\n\ngoal (1 subgoal):\n 1. Re a = Re z", "by auto"], ["proof (state)\nthis:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "then"], ["proof (chain)\npicking this:\n  Re a = Re z", "show ?thesis"], ["proof (prove)\nusing this:\n  Re a = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using \\<open>Re b=Re z\\<close>"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by auto"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have ?thesis when \"c1\\<ge>0\" \"c2\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c1>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a > (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re z < (1 - t) * Re a", "using \\<open>t<1\\<close> \\<open>c1>0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  0 < c1\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z < (1 - t) * Re a", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  0 < Re a - Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z < (1 - t) * Re a", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z < (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re z < (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b \\<ge> t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re z \\<le> t * Re b", "using \\<open>t>0\\<close> \\<open>c2\\<ge>0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  0 \\<le> c2\n\ngoal (1 subgoal):\n 1. t * Re z \\<le> t * Re b", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  0 \\<le> Re b - Re z\n\ngoal (1 subgoal):\n 1. t * Re z \\<le> t * Re b", "by auto"], ["proof (state)\nthis:\n  t * Re z \\<le> t * Re b\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re z < (1 - t) * Re a\n  t * Re z \\<le> t * Re b", "have \"(1 - t) * Re a + t * Re b > (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re z < (1 - t) * Re a\n  t * Re z \\<le> t * Re b\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  0 < c1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "have False when \"c2>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(1 - t) * Re a \\<ge> (1 - t) * Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - t) * Re z \\<le> (1 - t) * Re a", "using \\<open>t<1\\<close> \\<open>c1\\<ge>0\\<close>"], ["proof (prove)\nusing this:\n  t < 1\n  0 \\<le> c1\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z \\<le> (1 - t) * Re a", "unfolding c1_def"], ["proof (prove)\nusing this:\n  t < 1\n  0 \\<le> Re a - Re z\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z \\<le> (1 - t) * Re a", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n\ngoal (1 subgoal):\n 1. False", "have \"t * Re b > t* Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t * Re z < t * Re b", "using \\<open>t>0\\<close> \\<open>c2>0\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  0 < c2\n\ngoal (1 subgoal):\n 1. t * Re z < t * Re b", "unfolding c2_def"], ["proof (prove)\nusing this:\n  0 < t\n  0 < Re b - Re z\n\ngoal (1 subgoal):\n 1. t * Re z < t * Re b", "by auto"], ["proof (state)\nthis:\n  t * Re z < t * Re b\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n  t * Re z < t * Re b", "have \"(1 - t) * Re a + t * Re b > (1 - t) * Re z + t * Re z\""], ["proof (prove)\nusing this:\n  (1 - t) * Re z \\<le> (1 - t) * Re a\n  t * Re z < t * Re b\n\ngoal (1 subgoal):\n 1. (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b", "by auto"], ["proof (state)\nthis:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  (1 - t) * Re z + t * Re z < (1 - t) * Re a + t * Re b\n  (1 - t) * Re a + t * Re b = Re z\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "ultimately"], ["proof (chain)\npicking this:\n  0 < c1 \\<Longrightarrow> False\n  0 < c2 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c1 \\<Longrightarrow> False\n  0 < c2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  0 < c1 \\<Longrightarrow> False\n  0 < c2 \\<Longrightarrow> False\n  0 \\<le> c1\n  0 \\<le> c2\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "unfolding c1_def c2_def"], ["proof (prove)\nusing this:\n  0 < Re a - Re z \\<Longrightarrow> False\n  0 < Re b - Re z \\<Longrightarrow> False\n  0 \\<le> Re a - Re z\n  0 \\<le> Re b - Re z\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by argo"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have \"c1\\<le>0 \\<or> c2\\<ge>0\" \"c1\\<ge>0 \\<or> c2\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 \\<le> 0 \\<or> 0 \\<le> c2 &&& 0 \\<le> c1 \\<or> c2 \\<le> 0", "using \\<open>\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. c1 \\<le> 0 \\<or> 0 \\<le> c2 &&& 0 \\<le> c1 \\<or> c2 \\<le> 0", "by auto"], ["proof (state)\nthis:\n  c1 \\<le> 0 \\<or> 0 \\<le> c2\n  0 \\<le> c1 \\<or> c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; t < 1; (1 - t) * Re a + t * Re b = Re z\\<rbrakk>\n    \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  c1 \\<le> 0 \\<or> 0 \\<le> c2\n  0 \\<le> c1 \\<or> c2 \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>c1 \\<le> 0; 0 \\<le> c1\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c1 \\<le> 0; c2 \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>c2 \\<le> 0; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<lbrakk>0 \\<le> c1; 0 \\<le> c2\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  c1 \\<le> 0 \\<or> 0 \\<le> c2\n  0 \\<le> c1 \\<or> c2 \\<le> 0\n\ngoal (1 subgoal):\n 1. Re a = Re z \\<and> Re b = Re z", "by fast"], ["proof (state)\nthis:\n  Re a = Re z \\<and> Re b = Re z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z", "have \"(\\<forall>t. 0<t \\<and> t<1 \\<longrightarrow> Re(linepath a b t - z) \\<noteq> 0) \\<or> (Re a= Re z \\<and> Re b=Re z)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < t \\<and> t < 1 \\<longrightarrow>\n        Re (linepath a b t - z) \\<noteq> 0) \\<or>\n    Re a = Re z \\<and> Re b = Re z", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < t \\<and> t < 1 \\<longrightarrow>\n        Re (linepath a b t - z) \\<noteq> 0) \\<or>\n    Re a = Re z \\<and> Re b = Re z", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1; (1 - ?t) * Re a + ?t * Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> Re a = Re z \\<and> Re b = Re z\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        0 < t \\<and> t < 1 \\<longrightarrow>\n        Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) \\<noteq> 0) \\<or>\n    Re a = Re z \\<and> Re b = Re z", "by auto"], ["proof (state)\nthis:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  Re a = Re z \\<and> Re b = Re z\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have ?thesis when asm:\"\\<forall>t. 0<t \\<and> t<1 \\<longrightarrow> Re(linepath a b t - z) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) t = 0\" \n        when \"0<t\" \"t<1\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) t =\n    0", "apply (rule jump_Im_divide_Re_0[of \"\\<lambda>t. linepath a b t - z\", \n              OF _ asm[rule_format]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. linepath a b t - z)\n 2. 0 < t \\<and> t < 1\n 3. 0 < t\n 4. t < 1", "by (auto simp add:path_offset that)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump\n                     (\\<lambda>t.\n                         Im (linepath a b t - z) / Re (linepath a b t - z))\n                     ?t =\n                    0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump\n                     (\\<lambda>t.\n                         Im (linepath a b t - z) / Re (linepath a b t - z))\n                     ?t =\n                    0", "have \"cindex_path (linepath a b) z = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump\n                     (\\<lambda>t.\n                         Im (linepath a b t - z) / Re (linepath a b t - z))\n                     ?t =\n                    0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z = 0", "unfolding cindex_path_def cindex_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump\n                     (\\<lambda>t.\n                         Im (linepath a b t - z) / Re (linepath a b t - z))\n                     ?t =\n                    0\n\ngoal (1 subgoal):\n 1. sum (jump\n          (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)))\n     {x. jump\n          (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n          x \\<noteq>\n         0 \\<and>\n         0 < x \\<and> x < 1} =\n    0", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cindex_path (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "using \\<open>\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\\<close>"], ["proof (prove)\nusing this:\n  cindex_path (linepath a b) z = 0\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "apply (fold c1_def c2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex_path (linepath a b) z = 0;\n     \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\\<rbrakk>\n    \\<Longrightarrow> cindex_path (linepath a b) z =\n                      (let c1 = c1; c2 = c2;\n                           c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                                Im z * Re b -\n                                Im b * Re a -\n                                Re z * Im a\n                       in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                          then if 0 < c3 then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t.\n     0 < t \\<and> t < 1 \\<longrightarrow>\n     Re (linepath a b t - z) \\<noteq> 0 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>t.\n     0 < t \\<and> t < 1 \\<longrightarrow>\n     Re (linepath a b t - z) \\<noteq> 0 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have ?thesis when \"Re a= Re z\" \"Re b=Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"(\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) =\n    (\\<lambda>_. 0)", "using \\<open>Re a= Re z\\<close> \\<open>Re b=Re z\\<close>"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re z\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) =\n    (\\<lambda>_. 0)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)", "have \"(\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) = (\\<lambda>_. 0)\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. Re (linepath a b t - z)) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n    (\\<lambda>_. 0)", "by (metis div_by_0)"], ["proof (state)\nthis:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)", "have \"jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) t = 0\" for t"], ["proof (prove)\nusing this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) t =\n    0", "using jump_const"], ["proof (prove)\nusing this:\n  (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) =\n  (\\<lambda>_. 0)\n  jump (\\<lambda>_. ?c) ?a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) t =\n    0", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) ?t =\n  0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "then"], ["proof (chain)\npicking this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) ?t =\n  0", "have \"cindex_path (linepath a b) z = 0\""], ["proof (prove)\nusing this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) ?t =\n  0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z = 0", "unfolding cindex_path_def cindex_def"], ["proof (prove)\nusing this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) ?t =\n  0\n\ngoal (1 subgoal):\n 1. sum (jump\n          (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)))\n     {x. jump\n          (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n          x \\<noteq>\n         0 \\<and>\n         0 < x \\<and> x < 1} =\n    0", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cindex_path (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "using \\<open>\\<not> ((c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0))\\<close>"], ["proof (prove)\nusing this:\n  cindex_path (linepath a b) z = 0\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "apply (fold c1_def c2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex_path (linepath a b) z = 0;\n     \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2)\\<rbrakk>\n    \\<Longrightarrow> cindex_path (linepath a b) z =\n                      (let c1 = c1; c2 = c2;\n                           c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                                Im z * Re b -\n                                Im b * Re a -\n                                Re z * Im a\n                       in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                          then if 0 < c3 then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> cindex_path (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  Re a = Re z \\<and> Re b = Re z\n  \\<forall>t.\n     0 < t \\<and> t < 1 \\<longrightarrow>\n     Re (linepath a b t - z) \\<noteq> 0 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n  \\<lbrakk>Re a = Re z; Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> cindex_path (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>t.\n      0 < t \\<and> t < 1 \\<longrightarrow>\n      Re (linepath a b t - z) \\<noteq> 0) \\<or>\n  Re a = Re z \\<and> Re b = Re z\n  \\<forall>t.\n     0 < t \\<and> t < 1 \\<longrightarrow>\n     Re (linepath a b t - z) \\<noteq> 0 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n  \\<lbrakk>Re a = Re z; Re b = Re z\\<rbrakk>\n  \\<Longrightarrow> cindex_path (linepath a b) z =\n                    (let c1 = Re a - Re z; c2 = Re b - Re z;\n                         c3 = Im a * Re b + Re z * Im b + Im z * Re a -\n                              Im z * Re b -\n                              Im b * Re a -\n                              Re z * Im a\n                     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                        then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have ?thesis when c1c2_diff_sgn:\"(c1>0 \\<and> c2<0) \\<or> (c1<0 \\<and> c2>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "define c3 where \"c3=Im(a)*Re(b)+Re(z)*Im(b)+Im(z)*Re(a) -Im(z)*Re(b) - Im(b)*Re(a) - Re(z)*Im(a)\""], ["proof (state)\nthis:\n  c3 =\n  Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a -\n  Re z * Im a\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "define u where \"u = (Re z - Re a) / (Re b - Re a)\""], ["proof (state)\nthis:\n  u = (Re z - Re a) / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "let ?g = \"\\<lambda>t. linepath a b t - z\""], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"0<u\" \"u<1\" \"Re b - Re a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < u &&& u < 1 &&& Re b - Re a \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. 0 < u &&& u < 1 &&& Re b - Re a \\<noteq> 0", "unfolding u_def c1_def c2_def"], ["proof (prove)\nusing this:\n  0 < Re a - Re z \\<and> Re b - Re z < 0 \\<or>\n  Re a - Re z < 0 \\<and> 0 < Re b - Re z\n\ngoal (1 subgoal):\n 1. 0 < (Re z - Re a) / (Re b - Re a) &&&\n    (Re z - Re a) / (Re b - Re a) < 1 &&& Re b - Re a \\<noteq> 0", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 < u\n  u < 1\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"Re(?g u) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b u - z) = 0", "unfolding linepath_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((1 - (Re z - Re a) / (Re b - Re a)) *\\<^sub>R a +\n        ((Re z - Re a) / (Re b - Re a)) *\\<^sub>R b -\n        z) =\n    0", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re a + (Re b * Re z - Re a * Re b) / (Re b - Re a) =\n    Re z + (Re a * Re z - Re a * Re a) / (Re b - Re a)", "using \\<open>Re b - Re a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re a + (Re b * Re z - Re a * Re b) / (Re b - Re a) =\n    Re z + (Re a * Re z - Re a * Re a) / (Re b - Re a)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  Re (linepath a b u - z) = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "moreover"], ["proof (state)\nthis:\n  Re (linepath a b u - z) = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"u1 = u2\" when \"Re(?g u1) = 0\" \"Re(?g u2) = 0\" for u1 u2"], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 = u2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u1 = u2", "have \" (u1 - u2) * (Re b - Re a) = Re(?g u1) - Re(?g u2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u1 - u2) * (Re b - Re a) =\n    Re (linepath a b u1 - z) - Re (linepath a b u2 - z)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u1 - u2) * (Re b - Re a) =\n    Re ((1 - u1) *\\<^sub>R a + u1 *\\<^sub>R b - z) -\n    Re ((1 - u2) *\\<^sub>R a + u2 *\\<^sub>R b - z)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (u1 - u2) * (Re b - Re a) =\n  Re (linepath a b u1 - z) - Re (linepath a b u2 - z)\n\ngoal (1 subgoal):\n 1. u1 = u2", "also"], ["proof (state)\nthis:\n  (u1 - u2) * (Re b - Re a) =\n  Re (linepath a b u1 - z) - Re (linepath a b u2 - z)\n\ngoal (1 subgoal):\n 1. u1 = u2", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b u1 - z) - Re (linepath a b u2 - z) = 0", "using that"], ["proof (prove)\nusing this:\n  Re (linepath a b u1 - z) = 0\n  Re (linepath a b u2 - z) = 0\n\ngoal (1 subgoal):\n 1. Re (linepath a b u1 - z) - Re (linepath a b u2 - z) = 0", "by auto"], ["proof (state)\nthis:\n  Re (linepath a b u1 - z) - Re (linepath a b u2 - z) = 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "finally"], ["proof (chain)\npicking this:\n  (u1 - u2) * (Re b - Re a) = 0", "have \"(u1 - u2) * (Re b - Re a) = 0\""], ["proof (prove)\nusing this:\n  (u1 - u2) * (Re b - Re a) = 0\n\ngoal (1 subgoal):\n 1. (u1 - u2) * (Re b - Re a) = 0", "."], ["proof (state)\nthis:\n  (u1 - u2) * (Re b - Re a) = 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u1 - u2) * (Re b - Re a) = 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "using \\<open>Re b - Re a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (u1 - u2) * (Re b - Re a) = 0\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u1 = u2", "by auto"], ["proof (state)\nthis:\n  u1 = u2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re (linepath a b ?u1.0 - z) = 0;\n   Re (linepath a b ?u2.0 - z) = 0\\<rbrakk>\n  \\<Longrightarrow> ?u1.0 = ?u2.0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  Re (linepath a b u - z) = 0\n  \\<lbrakk>Re (linepath a b ?u1.0 - z) = 0;\n   Re (linepath a b ?u2.0 - z) = 0\\<rbrakk>\n  \\<Longrightarrow> ?u1.0 = ?u2.0", "have re_g_iff:\"Re(?g t) = 0 \\<longleftrightarrow> t=u\" for t"], ["proof (prove)\nusing this:\n  Re (linepath a b u - z) = 0\n  \\<lbrakk>Re (linepath a b ?u1.0 - z) = 0;\n   Re (linepath a b ?u2.0 - z) = 0\\<rbrakk>\n  \\<Longrightarrow> ?u1.0 = ?u2.0\n\ngoal (1 subgoal):\n 1. (Re (linepath a b t - z) = 0) = (t = u)", "by blast"], ["proof (state)\nthis:\n  (Re (linepath a b ?t - z) = 0) = (?t = u)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"cindex_path (linepath a b) z = jump (\\<lambda>t. Im (?g t)/Re(?g t)) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "define f where \"f=(\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "have \"jump f t =0\" when \"t\\<noteq>u\" \"0<t\" \"t<1\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump f t = 0", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) t =\n    0", "apply (rule jump_Im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. linepath a b t - z)\n 2. Re (linepath a b t - z) \\<noteq> 0\n 3. 0 < t\n 4. t < 1", "using that re_g_iff"], ["proof (prove)\nusing this:\n  t \\<noteq> u\n  0 < t\n  t < 1\n  (Re (linepath a b ?t - z) = 0) = (?t = u)\n\ngoal (4 subgoals):\n 1. path (\\<lambda>t. linepath a b t - z)\n 2. Re (linepath a b t - z) \\<noteq> 0\n 3. 0 < t\n 4. t < 1", "by (auto simp add: path_offset)"], ["proof (state)\nthis:\n  \\<lbrakk>?t \\<noteq> u; 0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump f ?t = 0\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?t \\<noteq> u; 0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump f ?t = 0", "have \"{x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} = (if jump f u=0 then {} else {u})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<noteq> u; 0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump f ?t = 0\n\ngoal (1 subgoal):\n 1. {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n    (if jump f u = 0 then {} else {u})", "using \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<noteq> u; 0 < ?t; ?t < 1\\<rbrakk>\n  \\<Longrightarrow> jump f ?t = 0\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n    (if jump f u = 0 then {} else {u})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<noteq> u; 0 < t; t < 1\\<rbrakk>\n                   \\<Longrightarrow> jump f t = 0;\n        0 < u; u < 1; jump f u = 0; 0 < x; jump f x \\<noteq> 0;\n        x < 1\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n  (if jump f u = 0 then {} else {u})\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "then"], ["proof (chain)\npicking this:\n  {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n  (if jump f u = 0 then {} else {u})", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n  (if jump f u = 0 then {} else {u})\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "unfolding cindex_path_def cindex_def"], ["proof (prove)\nusing this:\n  {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n  (if jump f u = 0 then {} else {u})\n\ngoal (1 subgoal):\n 1. sum (jump\n          (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)))\n     {x. jump\n          (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n          x \\<noteq>\n         0 \\<and>\n         0 < x \\<and> x < 1} =\n    jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u", "apply (fold f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n    (if jump f u = 0 then {} else {u}) \\<Longrightarrow>\n    sum (jump f) {x. jump f x \\<noteq> 0 \\<and> 0 < x \\<and> x < 1} =\n    jump f u", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "moreover"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "have \"jump (\\<lambda>t. Im (?g t)/Re(?g t)) u = (if c3>0 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "have \"Re b-Re a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "using c1c2_diff_sgn"], ["proof (prove)\nusing this:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "unfolding c1_def c2_def"], ["proof (prove)\nusing this:\n  0 < Re a - Re z \\<and> Re b - Re z < 0 \\<or>\n  Re a - Re z < 0 \\<and> 0 < Re b - Re z\n\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "have \"jump (\\<lambda>t. Im(?g t) / Re(?g t)) u \n          = (if sgn (Re b -Re a) = sgn (Im(?g u)) then 1 else - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)", "proof (rule jump_divide_derivative)"], ["proof (state)\ngoal (5 subgoals):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u\n 2. Re (linepath a b u - z) = 0\n 3. Im (linepath a b u - z) \\<noteq> 0\n 4. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 5. Re b - Re a \\<noteq> 0", "have \"path ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (\\<lambda>t. linepath a b t - z)", "using path_offset"], ["proof (prove)\nusing this:\n  path (\\<lambda>t. ?g t - ?z) = path ?g\n\ngoal (1 subgoal):\n 1. path (\\<lambda>t. linepath a b t - z)", "by auto"], ["proof (state)\nthis:\n  path (\\<lambda>t. linepath a b t - z)\n\ngoal (5 subgoals):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u\n 2. Re (linepath a b u - z) = 0\n 3. Im (linepath a b u - z) \\<noteq> 0\n 4. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 5. Re b - Re a \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  path (\\<lambda>t. linepath a b t - z)", "have \"continuous_on {0..1} (\\<lambda>t. Im(?g t))\""], ["proof (prove)\nusing this:\n  path (\\<lambda>t. linepath a b t - z)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))", "using continuous_on_Im path_def"], ["proof (prove)\nusing this:\n  path (\\<lambda>t. linepath a b t - z)\n  continuous_on ?s ?g \\<Longrightarrow>\n  continuous_on ?s (\\<lambda>x. Im (?g x))\n  path ?g = continuous_on {0..1} ?g\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))", "by blast"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))\n\ngoal (5 subgoals):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u\n 2. Re (linepath a b u - z) = 0\n 3. Im (linepath a b u - z) \\<noteq> 0\n 4. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 5. Re b - Re a \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))", "show \"isCont (\\<lambda>t. Im (?g t)) u\""], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>t. Im (linepath a b t - z))\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. Im (linepath a b t - z)) u", "apply (elim continuous_on_interior)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> interior {0..1}", "using \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. u \\<in> interior {0..1}", "by auto"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. Im (linepath a b t - z)) u\n\ngoal (4 subgoals):\n 1. Re (linepath a b u - z) = 0\n 2. Im (linepath a b u - z) \\<noteq> 0\n 3. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 4. Re b - Re a \\<noteq> 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Re (linepath a b u - z) = 0\n 2. Im (linepath a b u - z) \\<noteq> 0\n 3. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)\n 4. Re b - Re a \\<noteq> 0", "show \"Re(?g u) = 0\" \"Re b - Re a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b u - z) = 0 &&& Re b - Re a \\<noteq> 0", "using \\<open>Re(?g u) = 0\\<close> \\<open>Re b - Re a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Re (linepath a b u - z) = 0\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (linepath a b u - z) = 0 &&& Re b - Re a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Re (linepath a b u - z) = 0\n  Re b - Re a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Im (linepath a b u - z) \\<noteq> 0\n 2. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)", "show \"Im(?g u) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> Im (linepath a b u - z) \\<noteq> 0 \""], ["proof (state)\nthis:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0", "have \"?g u = 0\""], ["proof (prove)\nusing this:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. linepath a b u - z = 0", "using \\<open>Re(?g u) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Im (linepath a b u - z) \\<noteq> 0\n  Re (linepath a b u - z) = 0\n\ngoal (1 subgoal):\n 1. linepath a b u - z = 0", "by (simp add: complex_eq_iff)"], ["proof (state)\nthis:\n  linepath a b u - z = 0\n\ngoal (1 subgoal):\n 1. \\<not> Im (linepath a b u - z) \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  linepath a b u - z = 0\n\ngoal (1 subgoal):\n 1. False", "using assms \\<open>0<u\\<close> \\<open>u<1\\<close>"], ["proof (prove)\nusing this:\n  linepath a b u - z = 0\n  z \\<notin> path_image (linepath a b)\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. False", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  linepath a b u - z = 0\n  z \\<notin> linepath a b ` {0..1}\n  0 < u\n  u < 1\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (linepath a b u - z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)", "show \"((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a) (at u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n     (at u)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z)) has_real_derivative\n     Re b - Re a)\n     (at u)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>t. Re (linepath a b t - z)) has_real_derivative Re b - Re a)\n   (at u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "have \"sgn (Re b - Re a) = sgn (Im(?g u)) \\<longleftrightarrow> c3 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "have \"Im(?g u) = c3/(Re b-Re a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "define ba where \"ba = Re b-Re a\""], ["proof (state)\nthis:\n  ba = Re b - Re a\n\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "have \"ba\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ba \\<noteq> 0", "using \\<open>Re b - Re a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ba \\<noteq> 0", "unfolding ba_def"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re b - Re a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ba \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "then"], ["proof (chain)\npicking this:\n  ba \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ba \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (linepath a b u - z) = c3 / (Re b - Re a)", "unfolding linepath_def u_def c3_def"], ["proof (prove)\nusing this:\n  ba \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im ((1 - (Re z - Re a) / (Re b - Re a)) *\\<^sub>R a +\n        ((Re z - Re a) / (Re b - Re a)) *\\<^sub>R b -\n        z) =\n    (Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a -\n     Re z * Im a) /\n    (Re b - Re a)", "apply (fold ba_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ba \\<noteq> 0 \\<Longrightarrow>\n    Im ((1 - (Re z - Re a) / ba) *\\<^sub>R a +\n        ((Re z - Re a) / ba) *\\<^sub>R b -\n        z) =\n    (Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b - Im b * Re a -\n     Re z * Im a) /\n    ba", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ba \\<noteq> 0 \\<Longrightarrow>\n    ba * Im a + (Im a * Re a + Im z * Re b) =\n    ba * Im z + (Im a * Re b + Im z * Re a)", "by (auto simp add:algebra_simps ba_def)"], ["proof (state)\nthis:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "then"], ["proof (chain)\npicking this:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)", "have \"sgn (Re b - Re a) = sgn (Im(?g u)) \\<longleftrightarrow> sgn (Re b - Re a) = sgn (c3/(Re b-Re a))\""], ["proof (prove)\nusing this:\n  Im (linepath a b u - z) = c3 / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) =\n    (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a)))", "by auto"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) =\n  (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a)))\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "also"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) =\n  (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a)))\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "have \"... \\<longleftrightarrow> c3>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) = (0 < c3)", "using \\<open>Re b-Re a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re b - Re a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) = (0 < c3)", "apply (cases \"0::real\" c3 rule:linorder_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Re b - Re a \\<noteq> 0; 0 < c3\\<rbrakk>\n    \\<Longrightarrow> (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) =\n                      (0 < c3)\n 2. \\<lbrakk>Re b - Re a \\<noteq> 0; 0 = c3\\<rbrakk>\n    \\<Longrightarrow> (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) =\n                      (0 < c3)\n 3. \\<lbrakk>Re b - Re a \\<noteq> 0; c3 < 0\\<rbrakk>\n    \\<Longrightarrow> (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) =\n                      (0 < c3)", "by (auto simp add:sgn_zero_iff)"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (c3 / (Re b - Re a))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "finally"], ["proof (chain)\npicking this:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "show ?thesis"], ["proof (prove)\nusing this:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "."], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)", "show ?thesis"], ["proof (prove)\nusing this:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if sgn (Re b - Re a) = sgn (Im (linepath a b u - z)) then 1 else - 1)\n  (sgn (Re b - Re a) = sgn (Im (linepath a b u - z))) = (0 < c3)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n    (if 0 < c3 then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if 0 < c3 then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if 0 < c3 then 1 else - 1)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_path (linepath a b) z =\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if 0 < c3 then 1 else - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_path (linepath a b) z =\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if 0 < c3 then 1 else - 1)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "using c1c2_diff_sgn"], ["proof (prove)\nusing this:\n  cindex_path (linepath a b) z =\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u\n  jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z)) u =\n  (if 0 < c3 then 1 else - 1)\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "apply (fold c1_def c2_def c3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cindex_path (linepath a b) z =\n             jump\n              (\\<lambda>t.\n                  Im (linepath a b t - z) / Re (linepath a b t - z))\n              u;\n     jump (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n      u =\n     (if 0 < c3 then 1 else - 1);\n     0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\\<rbrakk>\n    \\<Longrightarrow> cindex_path (linepath a b) z =\n                      (let c1 = c1; c2 = c2; c3 = c3\n                       in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n                          then if 0 < c3 then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2) \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n  0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2 \\<Longrightarrow>\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. cindex_path (linepath a b) z =\n    (let c1 = Re a - Re z; c2 = Re b - Re z;\n         c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n              Im b * Re a -\n              Re z * Im a\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1 else 0)", "by blast"], ["proof (state)\nthis:\n  cindex_path (linepath a b) z =\n  (let c1 = Re a - Re z; c2 = Re b - Re z;\n       c3 = Im a * Re b + Re z * Im b + Im z * Re a - Im z * Re b -\n            Im b * Re a -\n            Re z * Im a\n   in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n      then if 0 < c3 then 1 else - 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_pathE_part_circlepath:\n  assumes \"cmod (z-z0) \\<noteq>r\" and \"r>0\" \"0\\<le>st\" \"st<tt\" \"tt\\<le>2*pi\"\n  shows \"cindex_pathE (part_circlepath z r st tt) z0 = (\n    if \\<bar>Re z - Re z0\\<bar> < r then \n      (let\n          \\<theta> = arccos ((Re z0 - Re z)/r);\n          \\<beta> = 2*pi - \\<theta>\n        in\n          jumpF_pathstart (part_circlepath z r st tt) z0\n          +\n          (if st<\\<theta> \\<and> \\<theta><tt then if r * sin \\<theta> + Im z > Im z0 then -1 else 1 else 0)\n          +\n          (if st<\\<beta> \\<and> \\<beta> < tt then if r * sin \\<beta> + Im z > Im z0 then 1 else -1 else 0)\n          - \n          jumpF_pathfinish (part_circlepath z r st tt) z0\n      )\n    else \n      if \\<bar>Re z - Re z0\\<bar> = r then \n        jumpF_pathstart (part_circlepath z r st tt) z0 \n        - jumpF_pathfinish (part_circlepath z r st tt) z0 \n      else 0\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define f where \"f=(\\<lambda>i. r * sin i + Im z - Im z0)\""], ["proof (state)\nthis:\n  f = (\\<lambda>i. r * sin i + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define g where \"g=(\\<lambda>i. r * cos i + Re z - Re z0)\""], ["proof (state)\nthis:\n  g = (\\<lambda>i. r * cos i + Re z - Re z0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define h where \"h=(\\<lambda>t. f t / g t)\""], ["proof (state)\nthis:\n  h = (\\<lambda>t. f t / g t)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have index_eq:\"cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "have \"cindex_pathE (part_circlepath z r st tt) z0 \n      = cindexE 0 1 ((\\<lambda>i. f i/g i) o (linepath st tt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    cindexE 0 1 ((\\<lambda>i. f i / g i) \\<circ> linepath st tt)", "unfolding cindex_pathE_def part_circlepath_def exp_Euler f_def g_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t.\n         Im (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0) /\n         Re (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0)) =\n    cindexE 0 1\n     (\\<lambda>x.\n         (r * sin (linepath st tt x) + Im z - Im z0) /\n         (r * cos (linepath st tt x) + Re z - Re z0))", "by (simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  cindexE 0 1 ((\\<lambda>i. f i / g i) \\<circ> linepath st tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "also"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  cindexE 0 1 ((\\<lambda>i. f i / g i) \\<circ> linepath st tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "have \"... = cindexE st tt (\\<lambda>i. f i/g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) =\n    cindexE st tt (\\<lambda>i. f i / g i)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt)) =\n    cindexE st tt (\\<lambda>i. f i / g i)", "using cindexE_linear_comp[of \"tt-st\" 0 1 _ st] \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  cindexE 0 1 (?f \\<circ> (\\<lambda>x. (tt - st) * x + st)) =\n  (if 0 < tt - st then cindexE ((tt - st) * 0 + st) ((tt - st) * 1 + st) ?f\n   else - cindexE ((tt - st) * 1 + st) ((tt - st) * 0 + st) ?f)\n  st < tt\n\ngoal (1 subgoal):\n 1. cindexE 0 1\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt)) =\n    cindexE st tt (\\<lambda>i. f i / g i)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindexE 0 1 ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) =\n  cindexE st tt (\\<lambda>i. f i / g i)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "also"], ["proof (state)\nthis:\n  cindexE 0 1 ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) =\n  cindexE st tt (\\<lambda>i. f i / g i)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "have \"... = cindexE st tt h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE st tt (\\<lambda>i. f i / g i) = cindexE st tt h", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE st tt (\\<lambda>i. f i / g i) =\n    cindexE st tt (\\<lambda>t. f t / g t)", "by simp"], ["proof (state)\nthis:\n  cindexE st tt (\\<lambda>i. f i / g i) = cindexE st tt h\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "."], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have jstart_eq:\"jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "have \"jumpF_pathstart (part_circlepath z r st tt) z0 \n            = jumpF ((\\<lambda>i. f i/g i) o (linepath st tt)) (at_right 0) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0)", "unfolding jumpF_pathstart_def part_circlepath_def exp_Euler f_def g_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0) /\n         Re (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0))\n     (at_right 0) =\n    jumpF\n     (\\<lambda>x.\n         (r * sin (linepath st tt x) + Im z - Im z0) /\n         (r * cos (linepath st tt x) + Re z - Re z0))\n     (at_right 0)", "by (simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "also"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "have \"... = jumpF (\\<lambda>i. f i/g i) (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0) =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n     (at_right 0) =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "using jumpF_linear_comp(2)[of \"tt-st\" _ st 0] \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  jumpF (?f \\<circ> (\\<lambda>x. (tt - st) * x + st)) (at_right 0) =\n  (if 0 < tt - st then jumpF ?f (at_right ((tt - st) * 0 + st))\n   else jumpF ?f (at_left ((tt - st) * 0 + st)))\n  st < tt\n\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n     (at_right 0) =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0) =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "also"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0) =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "have \"... = jumpF h (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_right st) = jumpF h (at_right st)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_right st) =\n    jumpF (\\<lambda>t. f t / g t) (at_right st)", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = jumpF h (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "finally"], ["proof (chain)\npicking this:\n  jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)", "."], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have jfinish_eq:\"jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "have \"jumpF_pathfinish (part_circlepath z r st tt) z0 \n            = jumpF ((\\<lambda>i. f i/g i) o (linepath st tt)) (at_left 1) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1)", "unfolding jumpF_pathfinish_def part_circlepath_def exp_Euler f_def g_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0) /\n         Re (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0))\n     (at_left 1) =\n    jumpF\n     (\\<lambda>x.\n         (r * sin (linepath st tt x) + Im z - Im z0) /\n         (r * cos (linepath st tt x) + Re z - Re z0))\n     (at_left 1)", "by (simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "also"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "have \"... = jumpF (\\<lambda>i. f i/g i) (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1) =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "unfolding linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n     (at_left 1) =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "using jumpF_linear_comp(1)[of \"tt-st\" _ st 1] \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  jumpF (?f \\<circ> (\\<lambda>x. (tt - st) * x + st)) (at_left 1) =\n  (if 0 < tt - st then jumpF ?f (at_left ((tt - st) * 1 + st))\n   else jumpF ?f (at_right ((tt - st) * 1 + st)))\n  st < tt\n\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n     (at_left 1) =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1) =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "also"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1) =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "have \"... = jumpF h (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_left tt) = jumpF h (at_left tt)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_left tt) =\n    jumpF (\\<lambda>t. f t / g t) (at_left tt)", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "finally"], ["proof (chain)\npicking this:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)", "."], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have finite_jFs:\"finite_jumpFs h st tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_jumpFs h st tt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_jumpFs h st tt", "note finite_ReZ_segments_imp_jumpFs[OF finite_ReZ_segments_part_circlepath\n          ,of  z r st tt z0,simplified]"], ["proof (state)\nthis:\n  finite_jumpFs\n   (\\<lambda>t.\n       (Im (part_circlepath z r st tt t) - Im z0) /\n       (Re (part_circlepath z r st tt t) - Re z0))\n   0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs h st tt", "then"], ["proof (chain)\npicking this:\n  finite_jumpFs\n   (\\<lambda>t.\n       (Im (part_circlepath z r st tt t) - Im z0) /\n       (Re (part_circlepath z r st tt t) - Re z0))\n   0 1", "have \"finite_jumpFs ((\\<lambda>i. f i/g i) o (linepath st tt)) 0 1\""], ["proof (prove)\nusing this:\n  finite_jumpFs\n   (\\<lambda>t.\n       (Im (part_circlepath z r st tt t) - Im z0) /\n       (Re (part_circlepath z r st tt t) - Re z0))\n   0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) 0 1", "unfolding h_def f_def g_def part_circlepath_def exp_Euler comp_def"], ["proof (prove)\nusing this:\n  finite_jumpFs\n   (\\<lambda>t.\n       (Im (z +\n            complex_of_real r *\n            (cos (complex_of_real (linepath st tt t)) +\n             \\<i> * sin (complex_of_real (linepath st tt t)))) -\n        Im z0) /\n       (Re (z +\n            complex_of_real r *\n            (cos (complex_of_real (linepath st tt t)) +\n             \\<i> * sin (complex_of_real (linepath st tt t)))) -\n        Re z0))\n   0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs\n     (\\<lambda>x.\n         (r * sin (linepath st tt x) + Im z - Im z0) /\n         (r * cos (linepath st tt x) + Re z - Re z0))\n     0 1", "by (simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  finite_jumpFs ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) 0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs h st tt", "then"], ["proof (chain)\npicking this:\n  finite_jumpFs ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) 0 1", "have \"finite_jumpFs (\\<lambda>i. f i/g i) st tt\""], ["proof (prove)\nusing this:\n  finite_jumpFs ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) 0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>i. f i / g i) st tt", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  finite_jumpFs\n   ((\\<lambda>i. f i / g i) \\<circ>\n    (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n   0 1\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>i. f i / g i) st tt", "using finite_jumpFs_linear_pos[of \"tt-st\" _ st 0 1] \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  finite_jumpFs\n   ((\\<lambda>i. f i / g i) \\<circ>\n    (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n   0 1\n  0 < tt - st \\<Longrightarrow>\n  finite_jumpFs (?f \\<circ> (\\<lambda>x. (tt - st) * x + st)) 0 1 =\n  finite_jumpFs ?f ((tt - st) * 0 + st) ((tt - st) * 1 + st)\n  st < tt\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>i. f i / g i) st tt", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  finite_jumpFs (\\<lambda>i. f i / g i) st tt\n\ngoal (1 subgoal):\n 1. finite_jumpFs h st tt", "then"], ["proof (chain)\npicking this:\n  finite_jumpFs (\\<lambda>i. f i / g i) st tt", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>i. f i / g i) st tt\n\ngoal (1 subgoal):\n 1. finite_jumpFs h st tt", "unfolding h_def"], ["proof (prove)\nusing this:\n  finite_jumpFs (\\<lambda>i. f i / g i) st tt\n\ngoal (1 subgoal):\n 1. finite_jumpFs (\\<lambda>t. f t / g t) st tt", "by auto"], ["proof (state)\nthis:\n  finite_jumpFs h st tt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_jumpFs h st tt\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have g_imp_f:\"g i = 0 \\<Longrightarrow> f i\\<noteq>0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. g i = 0 \\<Longrightarrow> f i \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "assume \"g i = 0\" \"\\<not> f i \\<noteq> 0 \""], ["proof (state)\nthis:\n  g i = 0\n  \\<not> f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g i = 0\n  \\<not> f i \\<noteq> 0", "have \"r * sin i = Im (z0 - z)\" \"r * cos i = Re (z0 - z)\""], ["proof (prove)\nusing this:\n  g i = 0\n  \\<not> f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * sin i = Im (z0 - z) &&& r * cos i = Re (z0 - z)", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * cos i + Re z - Re z0 = 0\n  \\<not> r * sin i + Im z - Im z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * sin i = Im (z0 - z) &&& r * cos i = Re (z0 - z)", "by auto"], ["proof (state)\nthis:\n  r * sin i = Im (z0 - z)\n  r * cos i = Re (z0 - z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r * sin i = Im (z0 - z)\n  r * cos i = Re (z0 - z)", "have \"(r * sin i) ^2 + (r * cos i)^2 = Im (z0 - z) ^ 2 +  Re (z0 - z) ^2\""], ["proof (prove)\nusing this:\n  r * sin i = Im (z0 - z)\n  r * cos i = Re (z0 - z)\n\ngoal (1 subgoal):\n 1. (r * sin i)\\<^sup>2 + (r * cos i)\\<^sup>2 =\n    (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (r * sin i)\\<^sup>2 + (r * cos i)\\<^sup>2 =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (r * sin i)\\<^sup>2 + (r * cos i)\\<^sup>2 =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2", "have \"r^2 * (sin i ^2  + cos i^2) = Im (z0 - z) ^ 2 +  Re (z0 - z) ^2\""], ["proof (prove)\nusing this:\n  (r * sin i)\\<^sup>2 + (r * cos i)\\<^sup>2 =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. r\\<^sup>2 * ((sin i)\\<^sup>2 + (cos i)\\<^sup>2) =\n    (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2", "by (auto simp only:algebra_simps power_mult_distrib)"], ["proof (state)\nthis:\n  r\\<^sup>2 * ((sin i)\\<^sup>2 + (cos i)\\<^sup>2) =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r\\<^sup>2 * ((sin i)\\<^sup>2 + (cos i)\\<^sup>2) =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2", "have \"r^2 = cmod (z0-z) ^ 2\""], ["proof (prove)\nusing this:\n  r\\<^sup>2 * ((sin i)\\<^sup>2 + (cos i)\\<^sup>2) =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. r\\<^sup>2 = (cmod (z0 - z))\\<^sup>2", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  r\\<^sup>2 * ((sin i)\\<^sup>2 + (cos i)\\<^sup>2) =\n  (Im (z0 - z))\\<^sup>2 + (Re (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. r\\<^sup>2 =\n    (sqrt ((Re (z0 - z))\\<^sup>2 + (Im (z0 - z))\\<^sup>2))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  r\\<^sup>2 = (cmod (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r\\<^sup>2 = (cmod (z0 - z))\\<^sup>2", "have \"r = cmod (z0-z)\""], ["proof (prove)\nusing this:\n  r\\<^sup>2 = (cmod (z0 - z))\\<^sup>2\n\ngoal (1 subgoal):\n 1. r = cmod (z0 - z)", "using \\<open>r>0\\<close> power2_eq_imp_eq"], ["proof (prove)\nusing this:\n  r\\<^sup>2 = (cmod (z0 - z))\\<^sup>2\n  0 < r\n  \\<lbrakk>?x\\<^sup>2 = ?y\\<^sup>2; (0::?'a) \\<le> ?x;\n   (0::?'a) \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. r = cmod (z0 - z)", "by fastforce"], ["proof (state)\nthis:\n  r = cmod (z0 - z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g i = 0; \\<not> f i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r = cmod (z0 - z)", "show False"], ["proof (prove)\nusing this:\n  r = cmod (z0 - z)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cmod (z-z0) \\<noteq>r\\<close>"], ["proof (prove)\nusing this:\n  r = cmod (z0 - z)\n  cmod (z - z0) \\<noteq> r\n\ngoal (1 subgoal):\n 1. False", "using norm_minus_commute"], ["proof (prove)\nusing this:\n  r = cmod (z0 - z)\n  cmod (z - z0) \\<noteq> r\n  norm (?a - ?b) = norm (?b - ?a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g ?i = 0 \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have ?thesis when \"\\<bar>Re z - Re z0\\<bar> > r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"jumpF h (at_right x) = 0\" \"jumpF h (at_left x) = 0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right x) = 0 &&& jumpF h (at_left x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_right x) = 0\n 2. jumpF h (at_left x) = 0", "have \"g x \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> g x \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> g x \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> g x \\<noteq> 0", "have \"cos x = (Re z0 - Re z) / r\""], ["proof (prove)\nusing this:\n  \\<not> g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cos x = (Re z0 - Re z) / r", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<not> r * cos x + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cos x = (Re z0 - Re z) / r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> r * cos x + Re z - Re z0 \\<noteq> 0\n  0 < r\n\ngoal (1 subgoal):\n 1. cos x = (Re z0 - Re z) / r", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  cos x = (Re z0 - Re z) / r\n\ngoal (1 subgoal):\n 1. \\<not> g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cos x = (Re z0 - Re z) / r", "have \"\\<bar>(Re z0 - Re z)/r\\<bar> \\<le> 1\""], ["proof (prove)\nusing this:\n  cos x = (Re z0 - Re z) / r\n\ngoal (1 subgoal):\n 1. \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1", "by (metis abs_cos_le_one)"], ["proof (state)\nthis:\n  \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1", "have \"\\<bar>Re z0 - Re z\\<bar> \\<le> r\""], ["proof (prove)\nusing this:\n  \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>Re z0 - Re z\\<bar> \\<le> r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<bar>Re z0 - Re z\\<bar> \\<le> r", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  \\<bar>Re z0 - Re z\\<bar> \\<le> r\n\ngoal (1 subgoal):\n 1. \\<not> g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<bar>Re z0 - Re z\\<bar> \\<le> r", "show False"], ["proof (prove)\nusing this:\n  \\<bar>Re z0 - Re z\\<bar> \\<le> r\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  \\<bar>Re z0 - Re z\\<bar> \\<le> r\n  r < \\<bar>Re z - Re z0\\<bar>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_right x) = 0\n 2. jumpF h (at_left x) = 0", "then"], ["proof (chain)\npicking this:\n  g x \\<noteq> 0", "have \"isCont h x\""], ["proof (prove)\nusing this:\n  g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont h x", "unfolding h_def f_def g_def"], ["proof (prove)\nusing this:\n  r * cos x + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>t. (r * sin t + Im z - Im z0) / (r * cos t + Re z - Re z0)) x", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  isCont h x\n\ngoal (2 subgoals):\n 1. jumpF h (at_right x) = 0\n 2. jumpF h (at_left x) = 0", "then"], ["proof (chain)\npicking this:\n  isCont h x", "show \"jumpF h (at_right x) = 0\" \"jumpF h (at_left x) = 0\""], ["proof (prove)\nusing this:\n  isCont h x\n\ngoal (1 subgoal):\n 1. jumpF h (at_right x) = 0 &&& jumpF h (at_left x) = 0", "using jumpF_not_infinity"], ["proof (prove)\nusing this:\n  isCont h x\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right x) = 0 &&& jumpF h (at_left x) = 0", "unfolding continuous_at_split"], ["proof (prove)\nusing this:\n  continuous (at_left x) h \\<and> continuous (at_right x) h\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right x) = 0 &&& jumpF h (at_left x) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right x) = 0\n  jumpF h (at_left x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF h (at_right ?x) = 0\n  jumpF h (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right ?x) = 0\n  jumpF h (at_left ?x) = 0", "have \"cindexE st tt h = 0\""], ["proof (prove)\nusing this:\n  jumpF h (at_right ?x) = 0\n  jumpF h (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. cindexE st tt h = 0", "unfolding cindexE_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right ?x) = 0\n  jumpF h (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and>\n               st \\<le> x \\<and> x < tt.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and>\n               st < x \\<and> x \\<le> tt.\n       jumpF h (at_left x)) =\n    0", "by auto"], ["proof (state)\nthis:\n  cindexE st tt h = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "then"], ["proof (chain)\npicking this:\n  cindexE st tt h = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE st tt h = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "using index_eq that"], ["proof (prove)\nusing this:\n  cindexE st tt h = 0\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n  r < \\<bar>Re z - Re z0\\<bar>\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r < \\<bar>Re z - Re z0\\<bar> \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "moreover"], ["proof (state)\nthis:\n  r < \\<bar>Re z - Re z0\\<bar> \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have ?thesis when \"\\<bar>Re z - Re z0\\<bar> = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define R where \"R=(\\<lambda>S.{x. jumpF h (at_right x) \\<noteq> 0 \\<and> x\\<in>S})\""], ["proof (state)\nthis:\n  R = (\\<lambda>S. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> S})\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define L where \"L=(\\<lambda>S.{x. jumpF h (at_left x) \\<noteq> 0 \\<and> x\\<in>S})\""], ["proof (state)\nthis:\n  L = (\\<lambda>S. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> S})\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define right where \n      \"right = (\\<lambda>S. (\\<Sum>x\\<in>R S. jumpF h (at_right x)))\""], ["proof (state)\nthis:\n  right = (\\<lambda>S. \\<Sum>x\\<in>R S. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define left where \n      \"left = (\\<lambda>S. (\\<Sum>x\\<in>L S. jumpF h (at_left x)))\""], ["proof (state)\nthis:\n  left = (\\<lambda>S. \\<Sum>x\\<in>L S. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "using index_eq"], ["proof (prove)\nusing this:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h", "by simp"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "also"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"... = right {st..<tt} - left {st<..tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE st tt h = right {st..<tt} - left {st<..tt}", "unfolding cindexE_def right_def left_def R_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and>\n               st \\<le> x \\<and> x < tt.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and>\n               st < x \\<and> x \\<le> tt.\n       jumpF h (at_left x)) =\n    (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st..<tt}.\n       jumpF h (at_right x)) -\n    (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..tt}.\n       jumpF h (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE st tt h = right {st..<tt} - left {st<..tt}\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "also"], ["proof (state)\nthis:\n  cindexE st tt h = right {st..<tt} - left {st<..tt}\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"... = jumpF h (at_right st) +  right {st<..<tt} - left {st<..<tt} - jumpF h (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right {st..<tt} - left {st<..tt} =\n    jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. right {st..<tt} - left {st<..tt} =\n    jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt)", "have \"right {st..<tt} = jumpF h (at_right st) +  right {st<..<tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "proof (cases \"jumpF h (at_right st) =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_right st) = 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n 2. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "case True"], ["proof (state)\nthis:\n  jumpF h (at_right st) = 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_right st) = 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n 2. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right st) = 0", "have \"R {st..<tt} = R {st<..<tt}\""], ["proof (prove)\nusing this:\n  jumpF h (at_right st) = 0\n\ngoal (1 subgoal):\n 1. R {st..<tt} = R {st<..<tt}", "unfolding R_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right st) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st..<tt}} =\n    {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}", "using less_eq_real_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right st) = 0\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st..<tt}} =\n    {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}", "by auto"], ["proof (state)\nthis:\n  R {st..<tt} = R {st<..<tt}\n\ngoal (2 subgoals):\n 1. jumpF h (at_right st) = 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n 2. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "then"], ["proof (chain)\npicking this:\n  R {st..<tt} = R {st<..<tt}", "have \"right {st..<tt} = right {st<..<tt}\""], ["proof (prove)\nusing this:\n  R {st..<tt} = R {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} = right {st<..<tt}", "unfolding right_def"], ["proof (prove)\nusing this:\n  R {st..<tt} = R {st<..<tt}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>R {st..<tt}. jumpF h (at_right x)) =\n    (\\<Sum>x\\<in>R {st<..<tt}. jumpF h (at_right x))", "by auto"], ["proof (state)\nthis:\n  right {st..<tt} = right {st<..<tt}\n\ngoal (2 subgoals):\n 1. jumpF h (at_right st) = 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n 2. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "then"], ["proof (chain)\npicking this:\n  right {st..<tt} = right {st<..<tt}", "show ?thesis"], ["proof (prove)\nusing this:\n  right {st..<tt} = right {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "using True"], ["proof (prove)\nusing this:\n  right {st..<tt} = right {st<..<tt}\n  jumpF h (at_right st) = 0\n\ngoal (1 subgoal):\n 1. right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "by auto"], ["proof (state)\nthis:\n  right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "case False"], ["proof (state)\nthis:\n  jumpF h (at_right st) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "have \"finite (R {st..<tt})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R {st..<tt})", "using finite_jFs"], ["proof (prove)\nusing this:\n  finite_jumpFs h st tt\n\ngoal (1 subgoal):\n 1. finite (R {st..<tt})", "unfolding R_def finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       st \\<le> x \\<and> x \\<le> tt}\n\ngoal (1 subgoal):\n 1. finite {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st..<tt}}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite (R {st..<tt})\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "moreover"], ["proof (state)\nthis:\n  finite (R {st..<tt})\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "have \"st \\<in> R {st..<tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st \\<in> R {st..<tt}", "using False \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  jumpF h (at_right st) \\<noteq> 0\n  st < tt\n\ngoal (1 subgoal):\n 1. st \\<in> R {st..<tt}", "unfolding R_def"], ["proof (prove)\nusing this:\n  jumpF h (at_right st) \\<noteq> 0\n  st < tt\n\ngoal (1 subgoal):\n 1. st \\<in> {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st..<tt}}", "by auto"], ["proof (state)\nthis:\n  st \\<in> R {st..<tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "moreover"], ["proof (state)\nthis:\n  st \\<in> R {st..<tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "have \"R {st..<tt} - {st} = R {st<..<tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R {st..<tt} - {st} = R {st<..<tt}", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st..<tt}} - {st} =\n    {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}", "by auto"], ["proof (state)\nthis:\n  R {st..<tt} - {st} = R {st<..<tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) \\<noteq> 0 \\<Longrightarrow>\n    right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "ultimately"], ["proof (chain)\npicking this:\n  finite (R {st..<tt})\n  st \\<in> R {st..<tt}\n  R {st..<tt} - {st} = R {st<..<tt}", "show \"right {st..<tt}= jumpF h (at_right st) \n            + right {st<..<tt}\""], ["proof (prove)\nusing this:\n  finite (R {st..<tt})\n  st \\<in> R {st..<tt}\n  R {st..<tt} - {st} = R {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "using sum.remove[of \"R {st..<tt}\" st \"\\<lambda>x. jumpF h (at_right x)\"]"], ["proof (prove)\nusing this:\n  finite (R {st..<tt})\n  st \\<in> R {st..<tt}\n  R {st..<tt} - {st} = R {st<..<tt}\n  \\<lbrakk>finite (R {st..<tt}); st \\<in> R {st..<tt}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>R {st..<tt}. jumpF h (at_right x)) =\n                    jumpF h (at_right st) +\n                    (\\<Sum>x\\<in>R {st..<tt} - {st}. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}", "unfolding right_def"], ["proof (prove)\nusing this:\n  finite (R {st..<tt})\n  st \\<in> R {st..<tt}\n  R {st..<tt} - {st} = R {st<..<tt}\n  \\<lbrakk>finite (R {st..<tt}); st \\<in> R {st..<tt}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>R {st..<tt}. jumpF h (at_right x)) =\n                    jumpF h (at_right st) +\n                    (\\<Sum>x\\<in>R {st..<tt} - {st}. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>R {st..<tt}. jumpF h (at_right x)) =\n    jumpF h (at_right st) + (\\<Sum>x\\<in>R {st<..<tt}. jumpF h (at_right x))", "by simp"], ["proof (state)\nthis:\n  right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} - left {st<..tt} =\n    jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt)", "moreover"], ["proof (state)\nthis:\n  right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} - left {st<..tt} =\n    jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt)", "have \"left {st<..tt} = jumpF h (at_left tt) +  left {st<..<tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "proof (cases \"jumpF h (at_left tt) =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF h (at_left tt) = 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n 2. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "case True"], ["proof (state)\nthis:\n  jumpF h (at_left tt) = 0\n\ngoal (2 subgoals):\n 1. jumpF h (at_left tt) = 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n 2. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_left tt) = 0", "have \"L {st<..tt} = L {st<..<tt}\""], ["proof (prove)\nusing this:\n  jumpF h (at_left tt) = 0\n\ngoal (1 subgoal):\n 1. L {st<..tt} = L {st<..<tt}", "unfolding L_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left tt) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..tt}} =\n    {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}", "using less_eq_real_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left tt) = 0\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..tt}} =\n    {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}", "by auto"], ["proof (state)\nthis:\n  L {st<..tt} = L {st<..<tt}\n\ngoal (2 subgoals):\n 1. jumpF h (at_left tt) = 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n 2. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "then"], ["proof (chain)\npicking this:\n  L {st<..tt} = L {st<..<tt}", "have \"left {st<..tt} = left {st<..<tt}\""], ["proof (prove)\nusing this:\n  L {st<..tt} = L {st<..<tt}\n\ngoal (1 subgoal):\n 1. left {st<..tt} = left {st<..<tt}", "unfolding left_def"], ["proof (prove)\nusing this:\n  L {st<..tt} = L {st<..<tt}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>L {st<..tt}. jumpF h (at_left x)) =\n    (\\<Sum>x\\<in>L {st<..<tt}. jumpF h (at_left x))", "by auto"], ["proof (state)\nthis:\n  left {st<..tt} = left {st<..<tt}\n\ngoal (2 subgoals):\n 1. jumpF h (at_left tt) = 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n 2. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "then"], ["proof (chain)\npicking this:\n  left {st<..tt} = left {st<..<tt}", "show ?thesis"], ["proof (prove)\nusing this:\n  left {st<..tt} = left {st<..<tt}\n\ngoal (1 subgoal):\n 1. left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "using True"], ["proof (prove)\nusing this:\n  left {st<..tt} = left {st<..<tt}\n  jumpF h (at_left tt) = 0\n\ngoal (1 subgoal):\n 1. left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "by auto"], ["proof (state)\nthis:\n  left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "case False"], ["proof (state)\nthis:\n  jumpF h (at_left tt) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "have \"finite (L {st<..tt})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (L {st<..tt})", "using finite_jFs"], ["proof (prove)\nusing this:\n  finite_jumpFs h st tt\n\ngoal (1 subgoal):\n 1. finite (L {st<..tt})", "unfolding L_def finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       st \\<le> x \\<and> x \\<le> tt}\n\ngoal (1 subgoal):\n 1. finite {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..tt}}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite (L {st<..tt})\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "moreover"], ["proof (state)\nthis:\n  finite (L {st<..tt})\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "have \"tt \\<in> L {st<..tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tt \\<in> L {st<..tt}", "using False \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  jumpF h (at_left tt) \\<noteq> 0\n  st < tt\n\ngoal (1 subgoal):\n 1. tt \\<in> L {st<..tt}", "unfolding L_def"], ["proof (prove)\nusing this:\n  jumpF h (at_left tt) \\<noteq> 0\n  st < tt\n\ngoal (1 subgoal):\n 1. tt \\<in> {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..tt}}", "by auto"], ["proof (state)\nthis:\n  tt \\<in> L {st<..tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "moreover"], ["proof (state)\nthis:\n  tt \\<in> L {st<..tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "have \"L {st<..tt} - {tt} = L {st<..<tt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L {st<..tt} - {tt} = L {st<..<tt}", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..tt}} - {tt} =\n    {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}", "by auto"], ["proof (state)\nthis:\n  L {st<..tt} - {tt} = L {st<..<tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_left tt) \\<noteq> 0 \\<Longrightarrow>\n    left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "ultimately"], ["proof (chain)\npicking this:\n  finite (L {st<..tt})\n  tt \\<in> L {st<..tt}\n  L {st<..tt} - {tt} = L {st<..<tt}", "show \"left {st<..tt}= jumpF h (at_left tt) + left {st<..<tt}\""], ["proof (prove)\nusing this:\n  finite (L {st<..tt})\n  tt \\<in> L {st<..tt}\n  L {st<..tt} - {tt} = L {st<..<tt}\n\ngoal (1 subgoal):\n 1. left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "using sum.remove[of \"L {st<..tt}\" tt \"\\<lambda>x. jumpF h (at_left x)\"]"], ["proof (prove)\nusing this:\n  finite (L {st<..tt})\n  tt \\<in> L {st<..tt}\n  L {st<..tt} - {tt} = L {st<..<tt}\n  \\<lbrakk>finite (L {st<..tt}); tt \\<in> L {st<..tt}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>L {st<..tt}. jumpF h (at_left x)) =\n                    jumpF h (at_left tt) +\n                    (\\<Sum>x\\<in>L {st<..tt} - {tt}. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "unfolding left_def"], ["proof (prove)\nusing this:\n  finite (L {st<..tt})\n  tt \\<in> L {st<..tt}\n  L {st<..tt} - {tt} = L {st<..<tt}\n  \\<lbrakk>finite (L {st<..tt}); tt \\<in> L {st<..tt}\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>x\\<in>L {st<..tt}. jumpF h (at_left x)) =\n                    jumpF h (at_left tt) +\n                    (\\<Sum>x\\<in>L {st<..tt} - {tt}. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>L {st<..tt}. jumpF h (at_left x)) =\n    jumpF h (at_left tt) + (\\<Sum>x\\<in>L {st<..<tt}. jumpF h (at_left x))", "by simp"], ["proof (state)\nthis:\n  left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} - left {st<..tt} =\n    jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt)", "ultimately"], ["proof (chain)\npicking this:\n  right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n  left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}", "show ?thesis"], ["proof (prove)\nusing this:\n  right {st..<tt} = jumpF h (at_right st) + right {st<..<tt}\n  left {st<..tt} = jumpF h (at_left tt) + left {st<..<tt}\n\ngoal (1 subgoal):\n 1. right {st..<tt} - left {st<..tt} =\n    jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt)", "by simp"], ["proof (state)\nthis:\n  right {st..<tt} - left {st<..tt} =\n  jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n  jumpF h (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right {st..<tt} - left {st<..tt} =\n  jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n  jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "also"], ["proof (state)\nthis:\n  right {st..<tt} - left {st<..tt} =\n  jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n  jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"... =  jumpF h (at_right st) - jumpF h (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "define S where \"S={x. (jumpF h (at_left x) \\<noteq> 0 \\<or> jumpF h (at_right x) \\<noteq> 0) \\<and> st < x \\<and> x < tt}\""], ["proof (state)\nthis:\n  S =\n  {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n       jumpF h (at_right x) \\<noteq> 0) \\<and>\n      st < x \\<and> x < tt}\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "have \"right {st<..<tt} = sum (\\<lambda>x. jumpF h (at_right x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_right x))", "unfolding right_def S_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}.\n       jumpF h (at_right x)) =\n    (\\<Sum>x | (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                jumpF h (at_right x) \\<noteq> 0) \\<and>\n               st < x \\<and> x < tt.\n       jumpF h (at_right x))", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}\n 2. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}\n    \\<subseteq> {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                     jumpF h (at_right x) \\<noteq> 0) \\<and>\n                    st < x \\<and> x < tt}\n 3. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_right i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}", "using finite_jFs"], ["proof (prove)\nusing this:\n  finite_jumpFs h st tt\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}", "unfolding finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       st \\<le> x \\<and> x \\<le> tt}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}", "by (auto elim:rev_finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}\n    \\<subseteq> {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                     jumpF h (at_right x) \\<noteq> 0) \\<and>\n                    st < x \\<and> x < tt}\n 2. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_right i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_right x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}\n    \\<subseteq> {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                     jumpF h (at_right x) \\<noteq> 0) \\<and>\n                    st < x \\<and> x < tt}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_right i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_right x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_right i) = 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  right {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "moreover"], ["proof (state)\nthis:\n  right {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "have \"left {st<..<tt} = sum (\\<lambda>x. jumpF h (at_left x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_left x))", "unfolding left_def S_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}.\n       jumpF h (at_left x)) =\n    (\\<Sum>x | (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                jumpF h (at_right x) \\<noteq> 0) \\<and>\n               st < x \\<and> x < tt.\n       jumpF h (at_left x))", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}\n 2. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}\n    \\<subseteq> {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                     jumpF h (at_right x) \\<noteq> 0) \\<and>\n                    st < x \\<and> x < tt}\n 3. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_left i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}", "using finite_jFs"], ["proof (prove)\nusing this:\n  finite_jumpFs h st tt\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}", "unfolding finite_jumpFs_def"], ["proof (prove)\nusing this:\n  finite\n   {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n        jumpF h (at_right x) \\<noteq> 0) \\<and>\n       st \\<le> x \\<and> x \\<le> tt}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n          jumpF h (at_right x) \\<noteq> 0) \\<and>\n         st < x \\<and> x < tt}", "by (auto elim:rev_finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}\n    \\<subseteq> {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                     jumpF h (at_right x) \\<noteq> 0) \\<and>\n                    st < x \\<and> x < tt}\n 2. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_left i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF h (at_left x) \\<noteq> 0 \\<and> x \\<in> {st<..<tt}}\n    \\<subseteq> {x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                     jumpF h (at_right x) \\<noteq> 0) \\<and>\n                    st < x \\<and> x < tt}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_left i) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. (jumpF h (at_left x) \\<noteq> 0 \\<or>\n                        jumpF h (at_right x) \\<noteq> 0) \\<and>\n                       st < x \\<and> x < tt} -\n                   {x. jumpF h (at_left x) \\<noteq> 0 \\<and>\n                       x \\<in> {st<..<tt}}.\n       jumpF h (at_left i) = 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  left {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "ultimately"], ["proof (chain)\npicking this:\n  right {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n  left {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_left x))", "have \"right {st<..<tt} - left {st<..<tt} \n          = sum (\\<lambda>x. jumpF h (at_right x) - jumpF h (at_left x)) S\""], ["proof (prove)\nusing this:\n  right {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_right x))\n  left {st<..<tt} = (\\<Sum>x\\<in>S. jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. right {st<..<tt} - left {st<..<tt} =\n    (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x))", "by (simp add: sum_subtractf)"], ["proof (state)\nthis:\n  right {st<..<tt} - left {st<..<tt} =\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "also"], ["proof (state)\nthis:\n  right {st<..<tt} - left {st<..<tt} =\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x))\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0", "have \"jumpF h (at_right i) - jumpF h (at_left i) = 0\" when \"g i=0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "have \"(LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have *: \"f \\<midarrow>i\\<rightarrow> f i\" \"g \\<midarrow>i\\<rightarrow> 0\" \"f i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<midarrow>i\\<rightarrow> f i &&&\n    g \\<midarrow>i\\<rightarrow> 0 &&& f i \\<noteq> 0", "using g_imp_f[OF \\<open>g i=0\\<close>] \\<open>g i=0\\<close>"], ["proof (prove)\nusing this:\n  f i \\<noteq> 0\n  g i = 0\n\ngoal (1 subgoal):\n 1. f \\<midarrow>i\\<rightarrow> f i &&&\n    g \\<midarrow>i\\<rightarrow> 0 &&& f i \\<noteq> 0", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * sin i + Im z - Im z0 \\<noteq> 0\n  r * cos i + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * sin i + Im z - Im z0) \\<midarrow>i\n    \\<rightarrow> r * sin i + Im z - Im z0 &&&\n    (\\<lambda>i. r * cos i + Re z - Re z0) \\<midarrow>i\\<rightarrow> 0 &&&\n    r * sin i + Im z - Im z0 \\<noteq> 0", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  f \\<midarrow>i\\<rightarrow> f i\n  g \\<midarrow>i\\<rightarrow> 0\n  f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have ?thesis when \"Re z > Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have g_alt:\"g = (\\<lambda>t. r * cos t + r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = (\\<lambda>t. r * cos t + r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * cos i + Re z - Re z0) = (\\<lambda>t. r * cos t + r)", "using \\<open>\\<bar>Re z - Re z0\\<bar> = r\\<close> that"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> = r\n  Re z0 < Re z\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * cos i + Re z - Re z0) = (\\<lambda>t. r * cos t + r)", "by auto"], ["proof (state)\nthis:\n  g = (\\<lambda>t. r * cos t + r)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have \"(g has_sgnx 1) (at i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at i)", "have \"sgn (g t) = 1\" when \"t \\<noteq> i \" \"dist t i < pi\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (g t) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (g t) = 1", "have \"cos i = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos i = - 1", "using \\<open>g i =0\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  g i = 0\n  0 < r\n\ngoal (1 subgoal):\n 1. cos i = - 1", "unfolding g_alt"], ["proof (prove)\nusing this:\n  r * cos i + r = 0\n  0 < r\n\ngoal (1 subgoal):\n 1. cos i = - 1", "by (metis add.inverse_inverse less_numeral_extra(3) mult_cancel_left \n                        mult_minus1_right real_add_minus_iff)"], ["proof (state)\nthis:\n  cos i = - 1\n\ngoal (1 subgoal):\n 1. sgn (g t) = 1", "then"], ["proof (chain)\npicking this:\n  cos i = - 1", "obtain k::int where k_def:\"i = (2 * k + 1) * pi\""], ["proof (prove)\nusing this:\n  cos i = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        i = real_of_int (2 * k + 1) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cos_eq_minus1[of i]"], ["proof (prove)\nusing this:\n  cos i = - 1\n  (cos i = - 1) = (\\<exists>x. i = (2 * real_of_int x + 1) * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        i = real_of_int (2 * k + 1) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i = real_of_int (2 * k + 1) * pi\n\ngoal (1 subgoal):\n 1. sgn (g t) = 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (g t) = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "assume \"sgn (g t) \\<noteq> 1\""], ["proof (state)\nthis:\n  sgn (g t) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sgn (g t) \\<noteq> 1", "have \"cos t + 1\\<le>0\""], ["proof (prove)\nusing this:\n  sgn (g t) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. cos t + 1 \\<le> 0", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  sgn (g t) \\<noteq> 1\n  0 < r\n\ngoal (1 subgoal):\n 1. cos t + 1 \\<le> 0", "unfolding g_alt"], ["proof (prove)\nusing this:\n  sgn (r * cos t + r) \\<noteq> 1\n  0 < r\n\ngoal (1 subgoal):\n 1. cos t + 1 \\<le> 0", "by (metis (no_types, hide_lams) add_le_same_cancel1 add_minus_cancel \n                          mult_le_cancel_left1 mult_le_cancel_right1 mult_minus_right mult_zero_left \n                          sgn_pos zero_le_one)"], ["proof (state)\nthis:\n  cos t + 1 \\<le> 0\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cos t + 1 \\<le> 0", "have \"cos t = -1\""], ["proof (prove)\nusing this:\n  cos t + 1 \\<le> 0\n\ngoal (1 subgoal):\n 1. cos t = - 1", "by (metis add.commute cos_ge_minus_one le_less not_less real_add_le_0_iff)"], ["proof (state)\nthis:\n  cos t = - 1\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cos t = - 1", "obtain k'::int where k'_def:\"t = (2 * k' + 1) * pi\""], ["proof (prove)\nusing this:\n  cos t = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        t = real_of_int (2 * k' + 1) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cos_eq_minus1[of t]"], ["proof (prove)\nusing this:\n  cos t = - 1\n  (cos t = - 1) = (\\<exists>x. t = (2 * real_of_int x + 1) * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        t = real_of_int (2 * k' + 1) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = real_of_int (2 * k' + 1) * pi\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t = real_of_int (2 * k' + 1) * pi", "have \"t - i = 2 * pi*(k' - k)\""], ["proof (prove)\nusing this:\n  t = real_of_int (2 * k' + 1) * pi\n\ngoal (1 subgoal):\n 1. t - i = 2 * pi * real_of_int (k' - k)", "using k_def"], ["proof (prove)\nusing this:\n  t = real_of_int (2 * k' + 1) * pi\n  i = real_of_int (2 * k + 1) * pi\n\ngoal (1 subgoal):\n 1. t - i = 2 * pi * real_of_int (k' - k)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  t - i = 2 * pi * real_of_int (k' - k)\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t - i = 2 * pi * real_of_int (k' - k)", "have \"2  * pi * \\<bar>  (k' - k)\\<bar> < pi\""], ["proof (prove)\nusing this:\n  t - i = 2 * pi * real_of_int (k' - k)\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int \\<bar>k' - k\\<bar> < pi", "using \\<open>dist t i < pi\\<close>"], ["proof (prove)\nusing this:\n  t - i = 2 * pi * real_of_int (k' - k)\n  dist t i < pi\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int \\<bar>k' - k\\<bar> < pi", "by (simp add:dist_norm abs_mult)"], ["proof (state)\nthis:\n  2 * pi * real_of_int \\<bar>k' - k\\<bar> < pi\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "from divide_strict_right_mono[OF this, of \"2*pi\",simplified]"], ["proof (chain)\npicking this:\n  \\<bar>real_of_int k' - real_of_int k\\<bar> * 2 < 1", "have \"\\<bar>k' - k \\<bar> < 1/2\""], ["proof (prove)\nusing this:\n  \\<bar>real_of_int k' - real_of_int k\\<bar> * 2 < 1\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>k' - k\\<bar> < 1 / 2", "by auto"], ["proof (state)\nthis:\n  real_of_int \\<bar>k' - k\\<bar> < 1 / 2\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>k' - k\\<bar> < 1 / 2", "have \"k=k'\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>k' - k\\<bar> < 1 / 2\n\ngoal (1 subgoal):\n 1. k = k'", "by linarith"], ["proof (state)\nthis:\n  k = k'\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k = k'", "have \"t=i\""], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. t = i", "using k_def k'_def"], ["proof (prove)\nusing this:\n  k = k'\n  i = real_of_int (2 * k + 1) * pi\n  t = real_of_int (2 * k' + 1) * pi\n\ngoal (1 subgoal):\n 1. t = i", "by auto"], ["proof (state)\nthis:\n  t = i\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t = i", "show False"], ["proof (prove)\nusing this:\n  t = i\n\ngoal (1 subgoal):\n 1. False", "using \\<open>t\\<noteq>i\\<close>"], ["proof (prove)\nusing this:\n  t = i\n  t \\<noteq> i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (g t) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at i)", "unfolding has_sgnx_def eventually_at"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = 1\n\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>x\\<in>UNIV.\n          x \\<noteq> i \\<and> dist x i < d \\<longrightarrow> sgn (g x) = 1", "apply(intro exI[where x=\"pi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<noteq> i; dist t i < pi\\<rbrakk>\n        \\<Longrightarrow> sgn (g t) = 1) \\<Longrightarrow>\n    0 < pi \\<and>\n    (\\<forall>x\\<in>UNIV.\n        x \\<noteq> i \\<and> dist x i < pi \\<longrightarrow> sgn (g x) = 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at i)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx 1) (at i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx 1) (at i)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "using * filterlim_divide_at_bot_at_top_iff[of f \"f i\" \"at i\" g]"], ["proof (prove)\nusing this:\n  (g has_sgnx 1) (at i)\n  f \\<midarrow>i\\<rightarrow> f i\n  g \\<midarrow>i\\<rightarrow> 0\n  f i \\<noteq> 0\n  \\<lbrakk>f \\<midarrow>i\\<rightarrow> f i; f i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at i. f x / g x :> at_bot) =\n                    (g \\<midarrow>i\\<rightarrow> 0 \\<and>\n                     (g has_sgnx - sgn (f i)) (at i))\n  \\<lbrakk>f \\<midarrow>i\\<rightarrow> f i; f i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at i. f x / g x :> at_top) =\n                    (g \\<midarrow>i\\<rightarrow> 0 \\<and>\n                     (g has_sgnx sgn (f i)) (at i))\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "by (simp add: sgn_if)"], ["proof (state)\nthis:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re z0 < Re z \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "moreover"], ["proof (state)\nthis:\n  Re z0 < Re z \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have ?thesis when \"Re z < Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have g_alt:\"g = (\\<lambda>t. r * cos t - r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = (\\<lambda>t. r * cos t - r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * cos i + Re z - Re z0) = (\\<lambda>t. r * cos t - r)", "using \\<open>\\<bar>Re z - Re z0\\<bar> = r\\<close> that"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> = r\n  Re z < Re z0\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * cos i + Re z - Re z0) = (\\<lambda>t. r * cos t - r)", "by auto"], ["proof (state)\nthis:\n  g = (\\<lambda>t. r * cos t - r)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have \"(g has_sgnx - 1) (at i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at i)", "have \"sgn (g t) = - 1\" when \"t \\<noteq> i \" \"dist t i < pi\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (g t) = - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (g t) = - 1", "have \"cos i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos i = 1", "using \\<open>g i =0\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  g i = 0\n  0 < r\n\ngoal (1 subgoal):\n 1. cos i = 1", "unfolding g_alt"], ["proof (prove)\nusing this:\n  r * cos i - r = 0\n  0 < r\n\ngoal (1 subgoal):\n 1. cos i = 1", "by simp"], ["proof (state)\nthis:\n  cos i = 1\n\ngoal (1 subgoal):\n 1. sgn (g t) = - 1", "then"], ["proof (chain)\npicking this:\n  cos i = 1", "obtain k::int where k_def:\"i = (2 * k  * pi)\""], ["proof (prove)\nusing this:\n  cos i = 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        i = real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cos_one_2pi_int[of i]"], ["proof (prove)\nusing this:\n  cos i = 1\n  (cos i = 1) = (\\<exists>x. i = real_of_int x * 2 * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        i = real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i = real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. sgn (g t) = - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (g t) = - 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "assume \"sgn (g t) \\<noteq> - 1\""], ["proof (state)\nthis:\n  sgn (g t) \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sgn (g t) \\<noteq> - 1", "have \"cos t - 1\\<ge>0\""], ["proof (prove)\nusing this:\n  sgn (g t) \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> cos t - 1", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  sgn (g t) \\<noteq> - 1\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 \\<le> cos t - 1", "unfolding g_alt"], ["proof (prove)\nusing this:\n  sgn (r * cos t - r) \\<noteq> - 1\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 \\<le> cos t - 1", "using mult_le_cancel_left1"], ["proof (prove)\nusing this:\n  sgn (r * cos t - r) \\<noteq> - 1\n  0 < r\n  (?c \\<le> ?c * ?b) =\n  (((0::?'a) < ?c \\<longrightarrow> (1::?'a) \\<le> ?b) \\<and>\n   (?c < (0::?'a) \\<longrightarrow> ?b \\<le> (1::?'a)))\n\ngoal (1 subgoal):\n 1. 0 \\<le> cos t - 1", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> cos t - 1\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 \\<le> cos t - 1", "have \"cos t = 1\""], ["proof (prove)\nusing this:\n  0 \\<le> cos t - 1\n\ngoal (1 subgoal):\n 1. cos t = 1", "by (meson cos_le_one diff_ge_0_iff_ge le_less not_less)"], ["proof (state)\nthis:\n  cos t = 1\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cos t = 1", "obtain k'::int where k'_def:\"t = 2 * k'* pi\""], ["proof (prove)\nusing this:\n  cos t = 1\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        t = real_of_int (2 * k') * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cos_one_2pi_int[of t]"], ["proof (prove)\nusing this:\n  cos t = 1\n  (cos t = 1) = (\\<exists>x. t = real_of_int x * 2 * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        t = real_of_int (2 * k') * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = real_of_int (2 * k') * pi\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t = real_of_int (2 * k') * pi", "have \"t - i = 2 * pi*(k' - k)\""], ["proof (prove)\nusing this:\n  t = real_of_int (2 * k') * pi\n\ngoal (1 subgoal):\n 1. t - i = 2 * pi * real_of_int (k' - k)", "using k_def"], ["proof (prove)\nusing this:\n  t = real_of_int (2 * k') * pi\n  i = real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. t - i = 2 * pi * real_of_int (k' - k)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  t - i = 2 * pi * real_of_int (k' - k)\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t - i = 2 * pi * real_of_int (k' - k)", "have \"2  * pi * \\<bar>  (k' - k)\\<bar> < pi\""], ["proof (prove)\nusing this:\n  t - i = 2 * pi * real_of_int (k' - k)\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int \\<bar>k' - k\\<bar> < pi", "using \\<open>dist t i < pi\\<close>"], ["proof (prove)\nusing this:\n  t - i = 2 * pi * real_of_int (k' - k)\n  dist t i < pi\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int \\<bar>k' - k\\<bar> < pi", "by (simp add:dist_norm abs_mult)"], ["proof (state)\nthis:\n  2 * pi * real_of_int \\<bar>k' - k\\<bar> < pi\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "from divide_strict_right_mono[OF this, of \"2*pi\",simplified]"], ["proof (chain)\npicking this:\n  \\<bar>real_of_int k' - real_of_int k\\<bar> * 2 < 1", "have \"\\<bar>k' - k \\<bar> < 1/2\""], ["proof (prove)\nusing this:\n  \\<bar>real_of_int k' - real_of_int k\\<bar> * 2 < 1\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>k' - k\\<bar> < 1 / 2", "by auto"], ["proof (state)\nthis:\n  real_of_int \\<bar>k' - k\\<bar> < 1 / 2\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>k' - k\\<bar> < 1 / 2", "have \"k=k'\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>k' - k\\<bar> < 1 / 2\n\ngoal (1 subgoal):\n 1. k = k'", "by linarith"], ["proof (state)\nthis:\n  k = k'\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k = k'", "have \"t=i\""], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. t = i", "using k_def k'_def"], ["proof (prove)\nusing this:\n  k = k'\n  i = real_of_int (2 * k) * pi\n  t = real_of_int (2 * k') * pi\n\ngoal (1 subgoal):\n 1. t = i", "by auto"], ["proof (state)\nthis:\n  t = i\n\ngoal (1 subgoal):\n 1. sgn (g t) \\<noteq> - 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t = i", "show False"], ["proof (prove)\nusing this:\n  t = i\n\ngoal (1 subgoal):\n 1. False", "using \\<open>t\\<noteq>i\\<close>"], ["proof (prove)\nusing this:\n  t = i\n  t \\<noteq> i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (g t) = - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = - 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = - 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at i)", "unfolding has_sgnx_def eventually_at"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<noteq> i; dist ?t i < pi\\<rbrakk>\n  \\<Longrightarrow> sgn (g ?t) = - 1\n\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>x\\<in>UNIV.\n          x \\<noteq> i \\<and> dist x i < d \\<longrightarrow> sgn (g x) = - 1", "apply(intro exI[where x=\"pi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<noteq> i; dist t i < pi\\<rbrakk>\n        \\<Longrightarrow> sgn (g t) = - 1) \\<Longrightarrow>\n    0 < pi \\<and>\n    (\\<forall>x\\<in>UNIV.\n        x \\<noteq> i \\<and> dist x i < pi \\<longrightarrow> sgn (g x) = - 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at i)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx - 1) (at i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - 1) (at i)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "using * filterlim_divide_at_bot_at_top_iff[of f \"f i\" \"at i\" g]"], ["proof (prove)\nusing this:\n  (g has_sgnx - 1) (at i)\n  f \\<midarrow>i\\<rightarrow> f i\n  g \\<midarrow>i\\<rightarrow> 0\n  f i \\<noteq> 0\n  \\<lbrakk>f \\<midarrow>i\\<rightarrow> f i; f i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at i. f x / g x :> at_bot) =\n                    (g \\<midarrow>i\\<rightarrow> 0 \\<and>\n                     (g has_sgnx - sgn (f i)) (at i))\n  \\<lbrakk>f \\<midarrow>i\\<rightarrow> f i; f i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (LIM x at i. f x / g x :> at_top) =\n                    (g \\<midarrow>i\\<rightarrow> 0 \\<and>\n                     (g has_sgnx sgn (f i)) (at i))\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "by (simp add: sgn_if)"], ["proof (state)\nthis:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re z < Re z0 \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "moreover"], ["proof (state)\nthis:\n  Re z < Re z0 \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "have \"Re z\\<noteq> Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re z \\<noteq> Re z0", "using \\<open>\\<bar>Re z - Re z0\\<bar> = r\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> = r\n  0 < r\n\ngoal (1 subgoal):\n 1. Re z \\<noteq> Re z0", "by fastforce"], ["proof (state)\nthis:\n  Re z \\<noteq> Re z0\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "ultimately"], ["proof (chain)\npicking this:\n  Re z0 < Re z \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n  Re z < Re z0 \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n  Re z \\<noteq> Re z0", "show ?thesis"], ["proof (prove)\nusing this:\n  Re z0 < Re z \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n  Re z < Re z0 \\<Longrightarrow>\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n  Re z \\<noteq> Re z0\n\ngoal (1 subgoal):\n 1. (LIM x at i. f x / g x :> at_bot) \\<or>\n    (LIM x at i. f x / g x :> at_top)", "by fastforce"], ["proof (state)\nthis:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "moreover"], ["proof (state)\nthis:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "have ?thesis when \"(LIM x at i. f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "have \"jumpF h (at_right i) = - 1/2\" \"jumpF h (at_left i) = -1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = - 1 / 2 &&& jumpF h (at_left i) = - 1 / 2", "using that"], ["proof (prove)\nusing this:\n  LIM x at i. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = - 1 / 2 &&& jumpF h (at_left i) = - 1 / 2", "unfolding jumpF_def h_def filterlim_at_split"], ["proof (prove)\nusing this:\n  (LIM x at_left i. f x / g x :> at_bot) \\<and>\n  (LIM x at_right i. f x / g x :> at_bot)\n\ngoal (1 subgoal):\n 1. (if LIM t at_right i. f t / g t :> at_top then 1 / 2\n     else if LIM t at_right i. f t / g t :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2 &&&\n    (if LIM t at_left i. f t / g t :> at_top then 1 / 2\n     else if LIM t at_left i. f t / g t :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) = - 1 / 2\n  jumpF h (at_left i) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right i) = - 1 / 2\n  jumpF h (at_left i) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF h (at_right i) = - 1 / 2\n  jumpF h (at_left i) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at i. f x / g x :> at_bot \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "moreover"], ["proof (state)\nthis:\n  LIM x at i. f x / g x :> at_bot \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "have ?thesis when \"(LIM x at i. f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "have \"jumpF h (at_right i) =  1/2\" \"jumpF h (at_left i) = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = 1 / 2 &&& jumpF h (at_left i) = 1 / 2", "using that"], ["proof (prove)\nusing this:\n  LIM x at i. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = 1 / 2 &&& jumpF h (at_left i) = 1 / 2", "unfolding jumpF_def h_def filterlim_at_split"], ["proof (prove)\nusing this:\n  (LIM x at_left i. f x / g x :> at_top) \\<and>\n  (LIM x at_right i. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (if LIM t at_right i. f t / g t :> at_top then 1 / 2\n     else if LIM t at_right i. f t / g t :> at_bot then - 1 / 2 else 0) =\n    1 / 2 &&&\n    (if LIM t at_left i. f t / g t :> at_top then 1 / 2\n     else if LIM t at_left i. f t / g t :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) = 1 / 2\n  jumpF h (at_left i) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right i) = 1 / 2\n  jumpF h (at_left i) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF h (at_right i) = 1 / 2\n  jumpF h (at_left i) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at i. f x / g x :> at_top \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "ultimately"], ["proof (chain)\npicking this:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n  LIM x at i. f x / g x :> at_bot \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n  LIM x at i. f x / g x :> at_top \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM x at i. f x / g x :> at_bot) \\<or> (LIM x at i. f x / g x :> at_top)\n  LIM x at i. f x / g x :> at_bot \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n  LIM x at i. f x / g x :> at_top \\<Longrightarrow>\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g ?i = 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0", "moreover"], ["proof (state)\nthis:\n  g ?i = 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0", "have \"jumpF h (at_right i) - jumpF h (at_left i) = 0\" when \"g i\\<noteq>0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "have \"isCont h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont h i", "using that"], ["proof (prove)\nusing this:\n  g i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont h i", "unfolding h_def f_def g_def"], ["proof (prove)\nusing this:\n  r * cos i + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>t. (r * sin t + Im z - Im z0) / (r * cos t + Re z - Re z0)) i", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  isCont h i\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "then"], ["proof (chain)\npicking this:\n  isCont h i", "have \"jumpF h (at_right i) = 0\" \"jumpF h (at_left i) = 0\""], ["proof (prove)\nusing this:\n  isCont h i\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = 0 &&& jumpF h (at_left i) = 0", "using jumpF_not_infinity"], ["proof (prove)\nusing this:\n  isCont h i\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = 0 &&& jumpF h (at_left i) = 0", "unfolding continuous_at_split"], ["proof (prove)\nusing this:\n  continuous (at_left i) h \\<and> continuous (at_right i) h\n  \\<lbrakk>continuous ?F ?g; ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF ?g ?F = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) = 0 &&& jumpF h (at_left i) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) = 0\n  jumpF h (at_left i) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "then"], ["proof (chain)\npicking this:\n  jumpF h (at_right i) = 0\n  jumpF h (at_left i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF h (at_right i) = 0\n  jumpF h (at_left i) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right i) - jumpF h (at_left i) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right i) - jumpF h (at_left i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g ?i \\<noteq> 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0", "ultimately"], ["proof (chain)\npicking this:\n  g ?i = 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0\n  g ?i \\<noteq> 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  g ?i = 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0\n  g ?i \\<noteq> 0 \\<Longrightarrow>\n  jumpF h (at_right ?i) - jumpF h (at_left ?i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0", "by (intro sum.neutral,auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S. jumpF h (at_right x) - jumpF h (at_left x)) = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "finally"], ["proof (chain)\npicking this:\n  right {st<..<tt} - left {st<..<tt} = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  right {st<..<tt} - left {st<..<tt} = 0\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n    jumpF h (at_left tt) =\n    jumpF h (at_right st) - jumpF h (at_left tt)", "by simp"], ["proof (state)\nthis:\n  jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n  jumpF h (at_left tt) =\n  jumpF h (at_right st) - jumpF h (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n  jumpF h (at_left tt) =\n  jumpF h (at_right st) - jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "also"], ["proof (state)\nthis:\n  jumpF h (at_right st) + right {st<..<tt} - left {st<..<tt} -\n  jumpF h (at_left tt) =\n  jumpF h (at_right st) - jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"... = jumpF_pathstart (part_circlepath z r st tt) z0 \n        - jumpF_pathfinish (part_circlepath z r st tt) z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF h (at_right st) - jumpF h (at_left tt) =\n    jumpF_pathstart (part_circlepath z r st tt) z0 -\n    jumpF_pathfinish (part_circlepath z r st tt) z0", "using jstart_eq jfinish_eq"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)\n  jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF h (at_right st) - jumpF h (at_left tt) =\n    jumpF_pathstart (part_circlepath z r st tt) z0 -\n    jumpF_pathfinish (part_circlepath z r st tt) z0", "by auto"], ["proof (state)\nthis:\n  jumpF h (at_right st) - jumpF h (at_left tt) =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0", "have \"cindex_pathE (part_circlepath z r st tt) z0 = \n        jumpF_pathstart (part_circlepath z r st tt) z0 \n        - jumpF_pathfinish (part_circlepath z r st tt) z0\""], ["proof (prove)\nusing this:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    jumpF_pathstart (part_circlepath z r st tt) z0 -\n    jumpF_pathfinish (part_circlepath z r st tt) z0", "."], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "then"], ["proof (chain)\npicking this:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "using that"], ["proof (prove)\nusing this:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  jumpF_pathstart (part_circlepath z r st tt) z0 -\n  jumpF_pathfinish (part_circlepath z r st tt) z0\n  \\<bar>Re z - Re z0\\<bar> = r\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>Re z - Re z0\\<bar> = r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "moreover"], ["proof (state)\nthis:\n  \\<bar>Re z - Re z0\\<bar> = r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have ?thesis when \"\\<bar>Re z - Re z0\\<bar> < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define zr where \"zr= (Re z0 - Re z)/r\""], ["proof (state)\nthis:\n  zr = (Re z0 - Re z) / r\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define \\<theta> where \"\\<theta> = arccos zr\""], ["proof (state)\nthis:\n  \\<theta> = arccos zr\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define \\<beta> where \"\\<beta> = 2*pi - \\<theta>\""], ["proof (state)\nthis:\n  \\<beta> = 2 * pi - \\<theta>\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"0<\\<theta>\" \"\\<theta><pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<theta> &&& \\<theta> < pi", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<theta>\n 2. \\<theta> < pi", "have \"- 1 < zr\" \"zr < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 < zr &&& zr < 1", "using that \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> < r\n  0 < r\n\ngoal (1 subgoal):\n 1. - 1 < zr &&& zr < 1", "unfolding zr_def"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> < r\n  0 < r\n\ngoal (1 subgoal):\n 1. - 1 < (Re z0 - Re z) / r &&& (Re z0 - Re z) / r < 1", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  - 1 < zr\n  zr < 1\n\ngoal (2 subgoals):\n 1. 0 < \\<theta>\n 2. \\<theta> < pi", "from arccos_lt_bounded[OF this]"], ["proof (chain)\npicking this:\n  0 < arccos zr \\<and> arccos zr < pi", "show \"0<\\<theta>\" \"\\<theta><pi\""], ["proof (prove)\nusing this:\n  0 < arccos zr \\<and> arccos zr < pi\n\ngoal (1 subgoal):\n 1. 0 < \\<theta> &&& \\<theta> < pi", "unfolding \\<theta>_def"], ["proof (prove)\nusing this:\n  0 < arccos zr \\<and> arccos zr < pi\n\ngoal (1 subgoal):\n 1. 0 < arccos zr &&& arccos zr < pi", "by auto"], ["proof (state)\nthis:\n  0 < \\<theta>\n  \\<theta> < pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < \\<theta>\n  \\<theta> < pi\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"g \\<theta> = 0\" \"g \\<beta> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<theta> = 0 &&& g \\<beta> = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<theta> = 0\n 2. g \\<beta> = 0", "have \"\\<bar>zr\\<bar>\\<le>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>zr\\<bar> \\<le> 1", "using that"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<bar>zr\\<bar> \\<le> 1", "unfolding zr_def"], ["proof (prove)\nusing this:\n  \\<bar>Re z - Re z0\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1", "by auto"], ["proof (state)\nthis:\n  \\<bar>zr\\<bar> \\<le> 1\n\ngoal (2 subgoals):\n 1. g \\<theta> = 0\n 2. g \\<beta> = 0", "then"], ["proof (chain)\npicking this:\n  \\<bar>zr\\<bar> \\<le> 1", "have \"cos \\<theta> = zr\" \"cos \\<beta> = cos \\<theta>\""], ["proof (prove)\nusing this:\n  \\<bar>zr\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. cos \\<theta> = zr &&& cos \\<beta> = cos \\<theta>", "unfolding \\<theta>_def[folded zr_def] \\<beta>_def"], ["proof (prove)\nusing this:\n  \\<bar>zr\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. cos (arccos zr) = zr &&& cos (2 * pi - arccos zr) = cos (arccos zr)", "by auto"], ["proof (state)\nthis:\n  cos \\<theta> = zr\n  cos \\<beta> = cos \\<theta>\n\ngoal (2 subgoals):\n 1. g \\<theta> = 0\n 2. g \\<beta> = 0", "then"], ["proof (chain)\npicking this:\n  cos \\<theta> = zr\n  cos \\<beta> = cos \\<theta>", "show \"g \\<theta> = 0\" \"g \\<beta> = 0\""], ["proof (prove)\nusing this:\n  cos \\<theta> = zr\n  cos \\<beta> = cos \\<theta>\n\ngoal (1 subgoal):\n 1. g \\<theta> = 0 &&& g \\<beta> = 0", "unfolding zr_def g_def"], ["proof (prove)\nusing this:\n  cos \\<theta> = (Re z0 - Re z) / r\n  cos \\<beta> = cos \\<theta>\n\ngoal (1 subgoal):\n 1. r * cos \\<theta> + Re z - Re z0 = 0 &&&\n    r * cos \\<beta> + Re z - Re z0 = 0", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  cos \\<theta> = (Re z0 - Re z) / r\n  cos \\<beta> = cos \\<theta>\n  0 < r\n\ngoal (1 subgoal):\n 1. r * cos \\<theta> + Re z - Re z0 = 0 &&&\n    r * cos \\<beta> + Re z - Re z0 = 0", "by auto"], ["proof (state)\nthis:\n  g \\<theta> = 0\n  g \\<beta> = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<theta> = 0\n  g \\<beta> = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have g_sgnx_\\<theta>:\"(g has_sgnx 1) (at_left \\<theta>)\" \"(g has_sgnx -1) (at_right \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left \\<theta>) &&&\n    (g has_sgnx - 1) (at_right \\<theta>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (g has_sgnx 1) (at_left \\<theta>)\n 2. (g has_sgnx - 1) (at_right \\<theta>)", "have \"(g has_real_derivative - r * sin \\<theta>) (at \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative - r * sin \\<theta>) (at \\<theta>)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. r * cos i + Re z - Re z0) has_real_derivative\n     - r * sin \\<theta>)\n     (at \\<theta>)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  (g has_real_derivative - r * sin \\<theta>) (at \\<theta>)\n\ngoal (2 subgoals):\n 1. (g has_sgnx 1) (at_left \\<theta>)\n 2. (g has_sgnx - 1) (at_right \\<theta>)", "moreover"], ["proof (state)\nthis:\n  (g has_real_derivative - r * sin \\<theta>) (at \\<theta>)\n\ngoal (2 subgoals):\n 1. (g has_sgnx 1) (at_left \\<theta>)\n 2. (g has_sgnx - 1) (at_right \\<theta>)", "have \"- r * sin \\<theta> <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin \\<theta> < 0", "using sin_gt_zero[OF \\<open>0<\\<theta>\\<close> \\<open>\\<theta><pi\\<close>] \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < sin \\<theta>\n  0 < r\n\ngoal (1 subgoal):\n 1. - r * sin \\<theta> < 0", "by auto"], ["proof (state)\nthis:\n  - r * sin \\<theta> < 0\n\ngoal (2 subgoals):\n 1. (g has_sgnx 1) (at_left \\<theta>)\n 2. (g has_sgnx - 1) (at_right \\<theta>)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_real_derivative - r * sin \\<theta>) (at \\<theta>)\n  - r * sin \\<theta> < 0", "show \"(g has_sgnx 1) (at_left \\<theta>)\" \"(g has_sgnx -1) (at_right \\<theta>)\""], ["proof (prove)\nusing this:\n  (g has_real_derivative - r * sin \\<theta>) (at \\<theta>)\n  - r * sin \\<theta> < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left \\<theta>) &&&\n    (g has_sgnx - 1) (at_right \\<theta>)", "using has_sgnx_derivative_at_left[of g \"- r * sin \\<theta>\", OF _ \\<open>g \\<theta>=0\\<close>] \n              has_sgnx_derivative_at_right[of g \"- r * sin \\<theta>\", OF _ \\<open>g \\<theta>=0\\<close>]"], ["proof (prove)\nusing this:\n  (g has_real_derivative - r * sin \\<theta>) (at \\<theta>)\n  - r * sin \\<theta> < 0\n  \\<lbrakk>(g has_real_derivative - r * sin \\<theta>) (at \\<theta>);\n   - r * sin \\<theta> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (- r * sin \\<theta>))\n                     (at_left \\<theta>)\n  \\<lbrakk>(g has_real_derivative - r * sin \\<theta>) (at \\<theta>);\n   - r * sin \\<theta> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx sgn (- r * sin \\<theta>))\n                     (at_right \\<theta>)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left \\<theta>) &&&\n    (g has_sgnx - 1) (at_right \\<theta>)", "by force+"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left \\<theta>)\n  (g has_sgnx - 1) (at_right \\<theta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left \\<theta>)\n  (g has_sgnx - 1) (at_right \\<theta>)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have g_sgnx_\\<beta>:\"(g has_sgnx -1) (at_left \\<beta>)\" \"(g has_sgnx 1) (at_right \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left \\<beta>) &&& (g has_sgnx 1) (at_right \\<beta>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (g has_sgnx - 1) (at_left \\<beta>)\n 2. (g has_sgnx 1) (at_right \\<beta>)", "have \"(g has_real_derivative - r * sin \\<beta>) (at \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative - r * sin \\<beta>) (at \\<beta>)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. r * cos i + Re z - Re z0) has_real_derivative\n     - r * sin \\<beta>)\n     (at \\<beta>)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  (g has_real_derivative - r * sin \\<beta>) (at \\<beta>)\n\ngoal (2 subgoals):\n 1. (g has_sgnx - 1) (at_left \\<beta>)\n 2. (g has_sgnx 1) (at_right \\<beta>)", "moreover"], ["proof (state)\nthis:\n  (g has_real_derivative - r * sin \\<beta>) (at \\<beta>)\n\ngoal (2 subgoals):\n 1. (g has_sgnx - 1) (at_left \\<beta>)\n 2. (g has_sgnx 1) (at_right \\<beta>)", "have \"pi<\\<beta>\" \"\\<beta><2*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi < \\<beta> &&& \\<beta> < 2 * pi", "unfolding \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pi < 2 * pi - \\<theta> &&& 2 * pi - \\<theta> < 2 * pi", "using \\<open>0<\\<theta>\\<close> \\<open>\\<theta><pi\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<theta>\n  \\<theta> < pi\n\ngoal (1 subgoal):\n 1. pi < 2 * pi - \\<theta> &&& 2 * pi - \\<theta> < 2 * pi", "by auto"], ["proof (state)\nthis:\n  pi < \\<beta>\n  \\<beta> < 2 * pi\n\ngoal (2 subgoals):\n 1. (g has_sgnx - 1) (at_left \\<beta>)\n 2. (g has_sgnx 1) (at_right \\<beta>)", "from sin_lt_zero[OF this] \\<open>r>0\\<close>"], ["proof (chain)\npicking this:\n  sin \\<beta> < 0\n  0 < r", "have \"- r * sin \\<beta> >0\""], ["proof (prove)\nusing this:\n  sin \\<beta> < 0\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 < - r * sin \\<beta>", "by (simp add: mult_pos_neg)"], ["proof (state)\nthis:\n  0 < - r * sin \\<beta>\n\ngoal (2 subgoals):\n 1. (g has_sgnx - 1) (at_left \\<beta>)\n 2. (g has_sgnx 1) (at_right \\<beta>)", "ultimately"], ["proof (chain)\npicking this:\n  (g has_real_derivative - r * sin \\<beta>) (at \\<beta>)\n  0 < - r * sin \\<beta>", "show \"(g has_sgnx -1) (at_left \\<beta>)\" \"(g has_sgnx 1) (at_right \\<beta>)\""], ["proof (prove)\nusing this:\n  (g has_real_derivative - r * sin \\<beta>) (at \\<beta>)\n  0 < - r * sin \\<beta>\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left \\<beta>) &&& (g has_sgnx 1) (at_right \\<beta>)", "using has_sgnx_derivative_at_left[of g \"- r * sin \\<beta>\", OF _ \\<open>g \\<beta>=0\\<close>] \n              has_sgnx_derivative_at_right[of g \"- r * sin \\<beta>\", OF _ \\<open>g \\<beta>=0\\<close>]"], ["proof (prove)\nusing this:\n  (g has_real_derivative - r * sin \\<beta>) (at \\<beta>)\n  0 < - r * sin \\<beta>\n  \\<lbrakk>(g has_real_derivative - r * sin \\<beta>) (at \\<beta>);\n   - r * sin \\<beta> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (- r * sin \\<beta>)) (at_left \\<beta>)\n  \\<lbrakk>(g has_real_derivative - r * sin \\<beta>) (at \\<beta>);\n   - r * sin \\<beta> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx sgn (- r * sin \\<beta>)) (at_right \\<beta>)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left \\<beta>) &&& (g has_sgnx 1) (at_right \\<beta>)", "by force+"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left \\<beta>)\n  (g has_sgnx 1) (at_right \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left \\<beta>)\n  (g has_sgnx 1) (at_right \\<beta>)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have f_tendsto: \"(f \\<longlongrightarrow> f i) (at_left i)\" \"(f \\<longlongrightarrow> f i) (at_right i)\" \n     and g_tendsto: \"(g \\<longlongrightarrow> g i) (at_left i)\" \"(g \\<longlongrightarrow> g i) (at_right i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f \\<longlongrightarrow> f i) (at_left i) &&&\n     (f \\<longlongrightarrow> f i) (at_right i)) &&&\n    (g \\<longlongrightarrow> g i) (at_left i) &&&\n    (g \\<longlongrightarrow> g i) (at_right i)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. (f \\<longlongrightarrow> f i) (at_left i)\n 2. (f \\<longlongrightarrow> f i) (at_right i)\n 3. (g \\<longlongrightarrow> g i) (at_left i)\n 4. (g \\<longlongrightarrow> g i) (at_right i)", "have \"(f \\<longlongrightarrow> f i) (at i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<midarrow>i\\<rightarrow> f i", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * sin i + Im z - Im z0) \\<midarrow>i\n    \\<rightarrow> r * sin i + Im z - Im z0", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  f \\<midarrow>i\\<rightarrow> f i\n\ngoal (4 subgoals):\n 1. (f \\<longlongrightarrow> f i) (at_left i)\n 2. (f \\<longlongrightarrow> f i) (at_right i)\n 3. (g \\<longlongrightarrow> g i) (at_left i)\n 4. (g \\<longlongrightarrow> g i) (at_right i)", "then"], ["proof (chain)\npicking this:\n  f \\<midarrow>i\\<rightarrow> f i", "show \"(f \\<longlongrightarrow> f i) (at_left i)\" \"(f \\<longlongrightarrow> f i) (at_right i)\""], ["proof (prove)\nusing this:\n  f \\<midarrow>i\\<rightarrow> f i\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f i) (at_left i) &&&\n    (f \\<longlongrightarrow> f i) (at_right i)", "by (auto simp add: filterlim_at_split)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f i) (at_left i)\n  (f \\<longlongrightarrow> f i) (at_right i)\n\ngoal (2 subgoals):\n 1. (g \\<longlongrightarrow> g i) (at_left i)\n 2. (g \\<longlongrightarrow> g i) (at_right i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (g \\<longlongrightarrow> g i) (at_left i)\n 2. (g \\<longlongrightarrow> g i) (at_right i)", "have \"(g \\<longlongrightarrow> g i) (at i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<midarrow>i\\<rightarrow> g i", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. r * cos i + Re z - Re z0) \\<midarrow>i\n    \\<rightarrow> r * cos i + Re z - Re z0", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  g \\<midarrow>i\\<rightarrow> g i\n\ngoal (2 subgoals):\n 1. (g \\<longlongrightarrow> g i) (at_left i)\n 2. (g \\<longlongrightarrow> g i) (at_right i)", "then"], ["proof (chain)\npicking this:\n  g \\<midarrow>i\\<rightarrow> g i", "show \"(g \\<longlongrightarrow> g i) (at_left i)\" \"(g \\<longlongrightarrow> g i) (at_right i)\""], ["proof (prove)\nusing this:\n  g \\<midarrow>i\\<rightarrow> g i\n\ngoal (1 subgoal):\n 1. (g \\<longlongrightarrow> g i) (at_left i) &&&\n    (g \\<longlongrightarrow> g i) (at_right i)", "by (auto simp add: filterlim_at_split)"], ["proof (state)\nthis:\n  (g \\<longlongrightarrow> g i) (at_left i)\n  (g \\<longlongrightarrow> g i) (at_right i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g ?i) (at_left ?i)\n  (g \\<longlongrightarrow> g ?i) (at_right ?i)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define \\<theta>_if::real where \"\\<theta>_if = (if r * sin \\<theta> + Im z > Im z0 then -1 else 1)\""], ["proof (state)\nthis:\n  \\<theta>_if = (if Im z0 < r * sin \\<theta> + Im z then - 1 else 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "define \\<beta>_if::real where \"\\<beta>_if = (if r * sin \\<beta> + Im z > Im z0 then 1 else -1)\""], ["proof (state)\nthis:\n  \\<beta>_if = (if Im z0 < r * sin \\<beta> + Im z then 1 else - 1)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"jump (\\<lambda>i. f i/g i) \\<theta> = \\<theta>_if\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have ?thesis when \"r * sin \\<theta> + Im z > Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"f \\<theta> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f \\<theta>", "using that"], ["proof (prove)\nusing this:\n  Im z0 < r * sin \\<theta> + Im z\n\ngoal (1 subgoal):\n 1. 0 < f \\<theta>", "unfolding f_def"], ["proof (prove)\nusing this:\n  Im z0 < r * sin \\<theta> + Im z\n\ngoal (1 subgoal):\n 1. 0 < r * sin \\<theta> + Im z - Im z0", "by auto"], ["proof (state)\nthis:\n  0 < f \\<theta>\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"(LIM x (at_left \\<theta>). f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left \\<theta>. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<theta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_left \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<theta>) \\<and>\n    (g has_sgnx sgn (f \\<theta>)) (at_left \\<theta>)", "using \\<open>f \\<theta> > 0\\<close> \\<open>g \\<theta> =0\\<close> f_tendsto g_tendsto[of \\<theta>] g_sgnx_\\<theta>"], ["proof (prove)\nusing this:\n  0 < f \\<theta>\n  g \\<theta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<theta>) (at_left \\<theta>)\n  (g \\<longlongrightarrow> g \\<theta>) (at_right \\<theta>)\n  (g has_sgnx 1) (at_left \\<theta>)\n  (g has_sgnx - 1) (at_right \\<theta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_left \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<theta>) \\<and>\n    (g has_sgnx sgn (f \\<theta>)) (at_left \\<theta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "moreover"], ["proof (state)\nthis:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "then"], ["proof (chain)\npicking this:\n  LIM x at_left \\<theta>. f x / g x :> at_top", "have \"\\<not> (LIM x (at_left \\<theta>). f x / g x :> at_bot)\""], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)", "by auto"], ["proof (state)\nthis:\n  \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "moreover"], ["proof (state)\nthis:\n  \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"(LIM x (at_right \\<theta>). f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right \\<theta>. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<theta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_right \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<theta>) \\<and>\n    (g has_sgnx - sgn (f \\<theta>)) (at_right \\<theta>)", "using \\<open>f \\<theta> > 0\\<close> \\<open>g \\<theta> =0\\<close> f_tendsto g_tendsto[of \\<theta>] g_sgnx_\\<theta>"], ["proof (prove)\nusing this:\n  0 < f \\<theta>\n  g \\<theta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<theta>) (at_left \\<theta>)\n  (g \\<longlongrightarrow> g \\<theta>) (at_right \\<theta>)\n  (g has_sgnx 1) (at_left \\<theta>)\n  (g has_sgnx - 1) (at_right \\<theta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_right \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<theta>) \\<and>\n    (g has_sgnx - sgn (f \\<theta>)) (at_right \\<theta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_right \\<theta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n  \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)\n  LIM x at_right \\<theta>. f x / g x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n  \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)\n  LIM x at_right \\<theta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "using that"], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n  \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)\n  LIM x at_right \\<theta>. f x / g x :> at_bot\n  Im z0 < r * sin \\<theta> + Im z\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "unfolding jump_def \\<theta>_if_def"], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_top\n  \\<not> (LIM x at_left \\<theta>. f x / g x :> at_bot)\n  LIM x at_right \\<theta>. f x / g x :> at_bot\n  Im z0 < r * sin \\<theta> + Im z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if (LIM i at_left \\<theta>. f i / g i :> at_bot) \\<and>\n         (LIM i at_right \\<theta>. f i / g i :> at_top)\n      then 1\n      else if (LIM i at_left \\<theta>. f i / g i :> at_top) \\<and>\n              (LIM i at_right \\<theta>. f i / g i :> at_bot)\n           then - 1 else 0) =\n    (if Im z0 < r * sin \\<theta> + Im z then - 1 else 1)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im z0 < r * sin \\<theta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "moreover"], ["proof (state)\nthis:\n  Im z0 < r * sin \\<theta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have ?thesis when \"r * sin \\<theta> + Im z < Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"f \\<theta> < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<theta> < 0", "using that"], ["proof (prove)\nusing this:\n  r * sin \\<theta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. f \\<theta> < 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  r * sin \\<theta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> + Im z - Im z0 < 0", "by auto"], ["proof (state)\nthis:\n  f \\<theta> < 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"(LIM x (at_left \\<theta>). f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left \\<theta>. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<theta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_left \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<theta>) \\<and>\n    (g has_sgnx - sgn (f \\<theta>)) (at_left \\<theta>)", "using \\<open>f \\<theta> < 0\\<close> \\<open>g \\<theta> =0\\<close> f_tendsto g_tendsto[of \\<theta>] g_sgnx_\\<theta>"], ["proof (prove)\nusing this:\n  f \\<theta> < 0\n  g \\<theta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<theta>) (at_left \\<theta>)\n  (g \\<longlongrightarrow> g \\<theta>) (at_right \\<theta>)\n  (g has_sgnx 1) (at_left \\<theta>)\n  (g has_sgnx - 1) (at_right \\<theta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_left \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<theta>) \\<and>\n    (g has_sgnx - sgn (f \\<theta>)) (at_left \\<theta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_left \\<theta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "moreover"], ["proof (state)\nthis:\n  LIM x at_left \\<theta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"(LIM x (at_right \\<theta>). f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right \\<theta>. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<theta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_right \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<theta>) \\<and>\n    (g has_sgnx sgn (f \\<theta>)) (at_right \\<theta>)", "using \\<open>f \\<theta> < 0\\<close> \\<open>g \\<theta> =0\\<close> f_tendsto g_tendsto[of \\<theta>] g_sgnx_\\<theta>"], ["proof (prove)\nusing this:\n  f \\<theta> < 0\n  g \\<theta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<theta>) (at_left \\<theta>)\n  (g \\<longlongrightarrow> g \\<theta>) (at_right \\<theta>)\n  (g has_sgnx 1) (at_left \\<theta>)\n  (g has_sgnx - 1) (at_right \\<theta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<theta>) (at_right \\<theta>)\n 2. f \\<theta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<theta>) \\<and>\n    (g has_sgnx sgn (f \\<theta>)) (at_right \\<theta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_right \\<theta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_left \\<theta>. f x / g x :> at_bot\n  LIM x at_right \\<theta>. f x / g x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_bot\n  LIM x at_right \\<theta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "using that"], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_bot\n  LIM x at_right \\<theta>. f x / g x :> at_top\n  r * sin \\<theta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "unfolding jump_def \\<theta>_if_def"], ["proof (prove)\nusing this:\n  LIM x at_left \\<theta>. f x / g x :> at_bot\n  LIM x at_right \\<theta>. f x / g x :> at_top\n  r * sin \\<theta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if (LIM i at_left \\<theta>. f i / g i :> at_bot) \\<and>\n         (LIM i at_right \\<theta>. f i / g i :> at_top)\n      then 1\n      else if (LIM i at_left \\<theta>. f i / g i :> at_top) \\<and>\n              (LIM i at_right \\<theta>. f i / g i :> at_bot)\n           then - 1 else 0) =\n    (if Im z0 < r * sin \\<theta> + Im z then - 1 else 1)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r * sin \\<theta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "moreover"], ["proof (state)\nthis:\n  r * sin \\<theta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "have \"r * sin \\<theta> + Im z \\<noteq> Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * sin \\<theta> + Im z \\<noteq> Im z0", "using g_imp_f[OF \\<open>g \\<theta>=0\\<close>]"], ["proof (prove)\nusing this:\n  f \\<theta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> + Im z \\<noteq> Im z0", "unfolding f_def"], ["proof (prove)\nusing this:\n  r * sin \\<theta> + Im z - Im z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> + Im z \\<noteq> Im z0", "by auto"], ["proof (state)\nthis:\n  r * sin \\<theta> + Im z \\<noteq> Im z0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "ultimately"], ["proof (chain)\npicking this:\n  Im z0 < r * sin \\<theta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  r * sin \\<theta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  r * sin \\<theta> + Im z \\<noteq> Im z0", "show ?thesis"], ["proof (prove)\nusing this:\n  Im z0 < r * sin \\<theta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  r * sin \\<theta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  r * sin \\<theta> + Im z \\<noteq> Im z0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if", "by fastforce"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "moreover"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"jump (\\<lambda>i. f i/g i) \\<beta> = \\<beta>_if\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have ?thesis when \"r * sin \\<beta> + Im z > Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"f \\<beta> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f \\<beta>", "using that"], ["proof (prove)\nusing this:\n  Im z0 < r * sin \\<beta> + Im z\n\ngoal (1 subgoal):\n 1. 0 < f \\<beta>", "unfolding f_def"], ["proof (prove)\nusing this:\n  Im z0 < r * sin \\<beta> + Im z\n\ngoal (1 subgoal):\n 1. 0 < r * sin \\<beta> + Im z - Im z0", "by auto"], ["proof (state)\nthis:\n  0 < f \\<beta>\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"(LIM x (at_left \\<beta>). f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left \\<beta>. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<beta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_left \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<beta>) \\<and>\n    (g has_sgnx - sgn (f \\<beta>)) (at_left \\<beta>)", "using \\<open>f \\<beta> > 0\\<close> \\<open>g \\<beta> =0\\<close> f_tendsto g_tendsto[of \\<beta>] g_sgnx_\\<beta>"], ["proof (prove)\nusing this:\n  0 < f \\<beta>\n  g \\<beta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<beta>) (at_left \\<beta>)\n  (g \\<longlongrightarrow> g \\<beta>) (at_right \\<beta>)\n  (g has_sgnx - 1) (at_left \\<beta>)\n  (g has_sgnx 1) (at_right \\<beta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_left \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<beta>) \\<and>\n    (g has_sgnx - sgn (f \\<beta>)) (at_left \\<beta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_left \\<beta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "moreover"], ["proof (state)\nthis:\n  LIM x at_left \\<beta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"(LIM x (at_right \\<beta>). f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right \\<beta>. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<beta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_right \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<beta>) \\<and>\n    (g has_sgnx sgn (f \\<beta>)) (at_right \\<beta>)", "using \\<open>f \\<beta> > 0\\<close> \\<open>g \\<beta> =0\\<close> f_tendsto g_tendsto[of \\<beta>] g_sgnx_\\<beta>"], ["proof (prove)\nusing this:\n  0 < f \\<beta>\n  g \\<beta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<beta>) (at_left \\<beta>)\n  (g \\<longlongrightarrow> g \\<beta>) (at_right \\<beta>)\n  (g has_sgnx - 1) (at_left \\<beta>)\n  (g has_sgnx 1) (at_right \\<beta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_right \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<beta>) \\<and>\n    (g has_sgnx sgn (f \\<beta>)) (at_right \\<beta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_right \\<beta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_left \\<beta>. f x / g x :> at_bot\n  LIM x at_right \\<beta>. f x / g x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left \\<beta>. f x / g x :> at_bot\n  LIM x at_right \\<beta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "using that"], ["proof (prove)\nusing this:\n  LIM x at_left \\<beta>. f x / g x :> at_bot\n  LIM x at_right \\<beta>. f x / g x :> at_top\n  Im z0 < r * sin \\<beta> + Im z\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "unfolding jump_def \\<beta>_if_def"], ["proof (prove)\nusing this:\n  LIM x at_left \\<beta>. f x / g x :> at_bot\n  LIM x at_right \\<beta>. f x / g x :> at_top\n  Im z0 < r * sin \\<beta> + Im z\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if (LIM i at_left \\<beta>. f i / g i :> at_bot) \\<and>\n         (LIM i at_right \\<beta>. f i / g i :> at_top)\n      then 1\n      else if (LIM i at_left \\<beta>. f i / g i :> at_top) \\<and>\n              (LIM i at_right \\<beta>. f i / g i :> at_bot)\n           then - 1 else 0) =\n    (if Im z0 < r * sin \\<beta> + Im z then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im z0 < r * sin \\<beta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "moreover"], ["proof (state)\nthis:\n  Im z0 < r * sin \\<beta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have ?thesis when \"r * sin \\<beta> + Im z < Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"f \\<beta> < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<beta> < 0", "using that"], ["proof (prove)\nusing this:\n  r * sin \\<beta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. f \\<beta> < 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  r * sin \\<beta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. r * sin \\<beta> + Im z - Im z0 < 0", "by auto"], ["proof (state)\nthis:\n  f \\<beta> < 0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"(LIM x (at_left \\<beta>). f x / g x :> at_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left \\<beta>. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<beta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_left \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<beta>) \\<and>\n    (g has_sgnx sgn (f \\<beta>)) (at_left \\<beta>)", "using \\<open>f \\<beta> < 0\\<close> \\<open>g \\<beta> =0\\<close> f_tendsto g_tendsto[of \\<beta>] g_sgnx_\\<beta>"], ["proof (prove)\nusing this:\n  f \\<beta> < 0\n  g \\<beta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<beta>) (at_left \\<beta>)\n  (g \\<longlongrightarrow> g \\<beta>) (at_right \\<beta>)\n  (g has_sgnx - 1) (at_left \\<beta>)\n  (g has_sgnx 1) (at_right \\<beta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_left \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_left \\<beta>) \\<and>\n    (g has_sgnx sgn (f \\<beta>)) (at_left \\<beta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_left \\<beta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "moreover"], ["proof (state)\nthis:\n  LIM x at_left \\<beta>. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"(LIM x (at_right \\<beta>). f x / g x :> at_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right \\<beta>. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f \\<beta>\" _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_right \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<beta>) \\<and>\n    (g has_sgnx - sgn (f \\<beta>)) (at_right \\<beta>)", "using \\<open>f \\<beta> < 0\\<close> \\<open>g \\<beta> =0\\<close> f_tendsto g_tendsto[of \\<beta>] g_sgnx_\\<beta>"], ["proof (prove)\nusing this:\n  f \\<beta> < 0\n  g \\<beta> = 0\n  (f \\<longlongrightarrow> f ?i) (at_left ?i)\n  (f \\<longlongrightarrow> f ?i) (at_right ?i)\n  (g \\<longlongrightarrow> g \\<beta>) (at_left \\<beta>)\n  (g \\<longlongrightarrow> g \\<beta>) (at_right \\<beta>)\n  (g has_sgnx - 1) (at_left \\<beta>)\n  (g has_sgnx 1) (at_right \\<beta>)\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f \\<beta>) (at_right \\<beta>)\n 2. f \\<beta> \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right \\<beta>) \\<and>\n    (g has_sgnx - sgn (f \\<beta>)) (at_right \\<beta>)", "by auto"], ["proof (state)\nthis:\n  LIM x at_right \\<beta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_left \\<beta>. f x / g x :> at_top\n  LIM x at_right \\<beta>. f x / g x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left \\<beta>. f x / g x :> at_top\n  LIM x at_right \\<beta>. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "using that"], ["proof (prove)\nusing this:\n  LIM x at_left \\<beta>. f x / g x :> at_top\n  LIM x at_right \\<beta>. f x / g x :> at_bot\n  r * sin \\<beta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "unfolding jump_def \\<beta>_if_def"], ["proof (prove)\nusing this:\n  LIM x at_left \\<beta>. f x / g x :> at_top\n  LIM x at_right \\<beta>. f x / g x :> at_bot\n  r * sin \\<beta> + Im z < Im z0\n\ngoal (1 subgoal):\n 1. real_of_int\n     (if (LIM i at_left \\<beta>. f i / g i :> at_bot) \\<and>\n         (LIM i at_right \\<beta>. f i / g i :> at_top)\n      then 1\n      else if (LIM i at_left \\<beta>. f i / g i :> at_top) \\<and>\n              (LIM i at_right \\<beta>. f i / g i :> at_bot)\n           then - 1 else 0) =\n    (if Im z0 < r * sin \\<beta> + Im z then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r * sin \\<beta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "moreover"], ["proof (state)\nthis:\n  r * sin \\<beta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "have \"r * sin \\<beta> + Im z \\<noteq> Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * sin \\<beta> + Im z \\<noteq> Im z0", "using g_imp_f[OF \\<open>g \\<beta>=0\\<close>]"], ["proof (prove)\nusing this:\n  f \\<beta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * sin \\<beta> + Im z \\<noteq> Im z0", "unfolding f_def"], ["proof (prove)\nusing this:\n  r * sin \\<beta> + Im z - Im z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * sin \\<beta> + Im z \\<noteq> Im z0", "by auto"], ["proof (state)\nthis:\n  r * sin \\<beta> + Im z \\<noteq> Im z0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "ultimately"], ["proof (chain)\npicking this:\n  Im z0 < r * sin \\<beta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  r * sin \\<beta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  r * sin \\<beta> + Im z \\<noteq> Im z0", "show ?thesis"], ["proof (prove)\nusing this:\n  Im z0 < r * sin \\<beta> + Im z \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  r * sin \\<beta> + Im z < Im z0 \\<Longrightarrow>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  r * sin \\<beta> + Im z \\<noteq> Im z0\n\ngoal (1 subgoal):\n 1. real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if", "by fastforce"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "moreover"], ["proof (state)\nthis:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<longleftrightarrow> x=\\<theta> \\<or> x=\\<beta>\" when \"st<x\" \"x<tt\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (jump (\\<lambda>i. f i / g i) x \\<noteq> 0) =\n    (x = \\<theta> \\<or> x = \\<beta>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>\n 2. x = \\<theta> \\<or> x = \\<beta> \\<Longrightarrow>\n    jump (\\<lambda>i. f i / g i) x \\<noteq> 0", "assume \"x = \\<theta> \\<or> x = \\<beta>\""], ["proof (state)\nthis:\n  x = \\<theta> \\<or> x = \\<beta>\n\ngoal (2 subgoals):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>\n 2. x = \\<theta> \\<or> x = \\<beta> \\<Longrightarrow>\n    jump (\\<lambda>i. f i / g i) x \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  x = \\<theta> \\<or> x = \\<beta>", "show \"jump (\\<lambda>i. f i / g i) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x = \\<theta> \\<or> x = \\<beta>\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0", "using \\<open>jump (\\<lambda>i. f i/g i) \\<theta> = \\<theta>_if\\<close> \\<open>jump (\\<lambda>i. f i/g i) \\<beta> = \\<beta>_if\\<close>"], ["proof (prove)\nusing this:\n  x = \\<theta> \\<or> x = \\<beta>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0", "unfolding \\<theta>_if_def \\<beta>_if_def"], ["proof (prove)\nusing this:\n  x = \\<theta> \\<or> x = \\<beta>\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) =\n  (if Im z0 < r * sin \\<theta> + Im z then - 1 else 1)\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) =\n  (if Im z0 < r * sin \\<beta> + Im z then 1 else - 1)\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0", "by (metis add.inverse_inverse add.inverse_neutral of_int_0 one_neq_zero)"], ["proof (state)\nthis:\n  jump (\\<lambda>i. f i / g i) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "assume asm:\"jump (\\<lambda>i. f i / g i) x \\<noteq> 0\""], ["proof (state)\nthis:\n  jump (\\<lambda>i. f i / g i) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "let ?thesis = \"x = \\<theta> \\<or> x = \\<beta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "have \"g x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. g x \\<noteq> 0 \\<Longrightarrow> False", "assume \"g x \\<noteq> 0\""], ["proof (state)\nthis:\n  g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g x \\<noteq> 0", "have \"isCont (\\<lambda>i. f i / g i) x\""], ["proof (prove)\nusing this:\n  g x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>i. f i / g i) x", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * cos x + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>i. (r * sin i + Im z - Im z0) / (r * cos i + Re z - Re z0)) x", "by (auto intro:continuous_intros)"], ["proof (state)\nthis:\n  isCont (\\<lambda>i. f i / g i) x\n\ngoal (1 subgoal):\n 1. g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  isCont (\\<lambda>i. f i / g i) x", "have \"jump (\\<lambda>i. f i / g i) x = 0\""], ["proof (prove)\nusing this:\n  isCont (\\<lambda>i. f i / g i) x\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x = 0", "using jump_not_infinity"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>i. f i / g i) x\n  isCont ?f ?a \\<Longrightarrow> jump ?f ?a = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x = 0", "by simp"], ["proof (state)\nthis:\n  jump (\\<lambda>i. f i / g i) x = 0\n\ngoal (1 subgoal):\n 1. g x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  jump (\\<lambda>i. f i / g i) x = 0", "show False"], ["proof (prove)\nusing this:\n  jump (\\<lambda>i. f i / g i) x = 0\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  jump (\\<lambda>i. f i / g i) x = 0\n  jump (\\<lambda>i. f i / g i) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g x = 0\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  g x = 0", "have \"cos x = zr\""], ["proof (prove)\nusing this:\n  g x = 0\n\ngoal (1 subgoal):\n 1. cos x = zr", "unfolding g_def zr_def"], ["proof (prove)\nusing this:\n  r * cos x + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. cos x = (Re z0 - Re z) / r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  r * cos x + Re z - Re z0 = 0\n  0 < r\n\ngoal (1 subgoal):\n 1. cos x = (Re z0 - Re z) / r", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  cos x = zr\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "have ?thesis when \"x\\<le>pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "have \"x\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x", "using \\<open>st<x\\<close> \\<open>st\\<ge>0\\<close>"], ["proof (prove)\nusing this:\n  st < x\n  0 \\<le> st\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have \"arccos (cos x) = x\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. arccos (cos x) = x", "using arccos_cos[of x] that"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  \\<lbrakk>0 \\<le> x; x \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arccos (cos x) = x\n  x \\<le> pi\n\ngoal (1 subgoal):\n 1. arccos (cos x) = x", "by auto"], ["proof (state)\nthis:\n  arccos (cos x) = x\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  arccos (cos x) = x", "have \"x=\\<theta>\""], ["proof (prove)\nusing this:\n  arccos (cos x) = x\n\ngoal (1 subgoal):\n 1. x = \\<theta>", "unfolding \\<theta>_def \\<open>cos x=zr\\<close>"], ["proof (prove)\nusing this:\n  arccos zr = x\n\ngoal (1 subgoal):\n 1. x = arccos zr", "by auto"], ["proof (state)\nthis:\n  x = \\<theta>\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  x = \\<theta>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<theta>\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "by auto"], ["proof (state)\nthis:\n  x = \\<theta> \\<or> x = \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "moreover"], ["proof (state)\nthis:\n  x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "have ?thesis when \"\\<not> x\\<le>pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "have \"x-2*pi\\<le>0\" \"-pi\\<le>x-2*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - 2 * pi \\<le> 0 &&& - pi \\<le> x - 2 * pi", "using that \\<open>x<tt\\<close> \\<open>tt\\<le>2*pi\\<close>"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> pi\n  x < tt\n  tt \\<le> 2 * pi\n\ngoal (1 subgoal):\n 1. x - 2 * pi \\<le> 0 &&& - pi \\<le> x - 2 * pi", "by auto"], ["proof (state)\nthis:\n  x - 2 * pi \\<le> 0\n  - pi \\<le> x - 2 * pi\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "from arccos_cos2[OF this]"], ["proof (chain)\npicking this:\n  arccos (cos (x - 2 * pi)) = - (x - 2 * pi)", "have \"arccos (cos (x - 2 * pi)) = 2*pi-x\""], ["proof (prove)\nusing this:\n  arccos (cos (x - 2 * pi)) = - (x - 2 * pi)\n\ngoal (1 subgoal):\n 1. arccos (cos (x - 2 * pi)) = 2 * pi - x", "by auto"], ["proof (state)\nthis:\n  arccos (cos (x - 2 * pi)) = 2 * pi - x\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  arccos (cos (x - 2 * pi)) = 2 * pi - x", "have \"arccos (cos x) = 2*pi-x\""], ["proof (prove)\nusing this:\n  arccos (cos (x - 2 * pi)) = 2 * pi - x\n\ngoal (1 subgoal):\n 1. arccos (cos x) = 2 * pi - x", "by (metis arccos cos_2pi_minus cos_ge_minus_one cos_le_one)"], ["proof (state)\nthis:\n  arccos (cos x) = 2 * pi - x\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  arccos (cos x) = 2 * pi - x", "have \"x=\\<beta>\""], ["proof (prove)\nusing this:\n  arccos (cos x) = 2 * pi - x\n\ngoal (1 subgoal):\n 1. x = \\<beta>", "unfolding \\<beta>_def \\<theta>_def"], ["proof (prove)\nusing this:\n  arccos (cos x) = 2 * pi - x\n\ngoal (1 subgoal):\n 1. x = 2 * pi - arccos zr", "using \\<open>cos x =zr\\<close>"], ["proof (prove)\nusing this:\n  arccos (cos x) = 2 * pi - x\n  cos x = zr\n\ngoal (1 subgoal):\n 1. x = 2 * pi - arccos zr", "by auto"], ["proof (state)\nthis:\n  x = \\<beta>\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "then"], ["proof (chain)\npicking this:\n  x = \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<beta>\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "by auto"], ["proof (state)\nthis:\n  x = \\<theta> \\<or> x = \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>\n\ngoal (1 subgoal):\n 1. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<Longrightarrow>\n    x = \\<theta> \\<or> x = \\<beta>", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>\n  \\<not> x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>\n  \\<not> x \\<le> pi \\<Longrightarrow> x = \\<theta> \\<or> x = \\<beta>\n\ngoal (1 subgoal):\n 1. x = \\<theta> \\<or> x = \\<beta>", "by auto"], ["proof (state)\nthis:\n  x = \\<theta> \\<or> x = \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>st < ?x; ?x < tt\\<rbrakk>\n  \\<Longrightarrow> (jump (\\<lambda>i. f i / g i) ?x \\<noteq> 0) =\n                    (?x = \\<theta> \\<or> ?x = \\<beta>)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>st < ?x; ?x < tt\\<rbrakk>\n  \\<Longrightarrow> (jump (\\<lambda>i. f i / g i) ?x \\<noteq> 0) =\n                    (?x = \\<theta> \\<or> ?x = \\<beta>)", "have \"{x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and> st < x \\<and> x < tt} = {\\<theta>,\\<beta>} \\<inter> {st<..<tt}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>st < ?x; ?x < tt\\<rbrakk>\n  \\<Longrightarrow> (jump (\\<lambda>i. f i / g i) ?x \\<noteq> 0) =\n                    (?x = \\<theta> \\<or> ?x = \\<beta>)\n\ngoal (1 subgoal):\n 1. {x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and>\n        st < x \\<and> x < tt} =\n    {\\<theta>, \\<beta>} \\<inter> {st<..<tt}", "by force"], ["proof (state)\nthis:\n  {x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and>\n      st < x \\<and> x < tt} =\n  {\\<theta>, \\<beta>} \\<inter> {st<..<tt}\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "moreover"], ["proof (state)\nthis:\n  {x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and>\n      st < x \\<and> x < tt} =\n  {\\<theta>, \\<beta>} \\<inter> {st<..<tt}\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"\\<theta>\\<noteq>\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> \\<beta>", "using \\<beta>_def \\<open>\\<theta> < pi\\<close>"], ["proof (prove)\nusing this:\n  \\<beta> = 2 * pi - \\<theta>\n  \\<theta> < pi\n\ngoal (1 subgoal):\n 1. \\<theta> \\<noteq> \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<theta> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  {x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and>\n      st < x \\<and> x < tt} =\n  {\\<theta>, \\<beta>} \\<inter> {st<..<tt}\n  \\<theta> \\<noteq> \\<beta>", "have \"cindex st tt h = \n          (if st<\\<theta> \\<and> \\<theta><tt then \\<theta>_if else 0)\n          +\n          (if st<\\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)\""], ["proof (prove)\nusing this:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  {x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and>\n      st < x \\<and> x < tt} =\n  {\\<theta>, \\<beta>} \\<inter> {st<..<tt}\n  \\<theta> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. real_of_int (cindex st tt h) =\n    (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n    (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)", "unfolding cindex_def h_def"], ["proof (prove)\nusing this:\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<theta>) = \\<theta>_if\n  real_of_int (jump (\\<lambda>i. f i / g i) \\<beta>) = \\<beta>_if\n  {x. jump (\\<lambda>i. f i / g i) x \\<noteq> 0 \\<and>\n      st < x \\<and> x < tt} =\n  {\\<theta>, \\<beta>} \\<inter> {st<..<tt}\n  \\<theta> \\<noteq> \\<beta>\n\ngoal (1 subgoal):\n 1. real_of_int\n     (sum (jump (\\<lambda>t. f t / g t))\n       {x. jump (\\<lambda>t. f t / g t) x \\<noteq> 0 \\<and>\n           st < x \\<and> x < tt}) =\n    (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n    (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)", "by fastforce"], ["proof (state)\nthis:\n  real_of_int (cindex st tt h) =\n  (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n  (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "moreover"], ["proof (state)\nthis:\n  real_of_int (cindex st tt h) =\n  (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n  (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "have \"cindexE st tt h = jumpF h (at_right st) + cindex st tt h - jumpF h (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE st tt h =\n    jumpF h (at_right st) + real_of_int (cindex st tt h) -\n    jumpF h (at_left tt)", "proof (rule cindex_eq_cindexE_divide[of st tt f g,folded h_def])"], ["proof (state)\ngoal (5 subgoals):\n 1. st < tt\n 2. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}\n 3. \\<forall>x\\<in>{st..tt}. g x = 0 \\<longrightarrow> f x \\<noteq> 0\n 4. continuous_on {st..tt} f\n 5. continuous_on {st..tt} g", "show \"st < tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st < tt", "using \\<open>st < tt\\<close>"], ["proof (prove)\nusing this:\n  st < tt\n\ngoal (1 subgoal):\n 1. st < tt", "."], ["proof (state)\nthis:\n  st < tt\n\ngoal (4 subgoals):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}\n 2. \\<forall>x\\<in>{st..tt}. g x = 0 \\<longrightarrow> f x \\<noteq> 0\n 3. continuous_on {st..tt} f\n 4. continuous_on {st..tt} g", "show \"\\<forall>x\\<in>{st..tt}. g x = 0 \\<longrightarrow> f x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{st..tt}. g x = 0 \\<longrightarrow> f x \\<noteq> 0", "using g_imp_f"], ["proof (prove)\nusing this:\n  g ?i = 0 \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{st..tt}. g x = 0 \\<longrightarrow> f x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{st..tt}. g x = 0 \\<longrightarrow> f x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}\n 2. continuous_on {st..tt} f\n 3. continuous_on {st..tt} g", "show \"continuous_on {st..tt} f\" \"continuous_on {st..tt} g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {st..tt} f &&& continuous_on {st..tt} g", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {st..tt} (\\<lambda>i. r * sin i + Im z - Im z0) &&&\n    continuous_on {st..tt} (\\<lambda>i. r * cos i + Re z - Re z0)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {st..tt} f\n  continuous_on {st..tt} g\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "let ?S1=\"{t. Re (part_circlepath z r st tt t-z0) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "let ?S2=\"{t. Im (part_circlepath z r st tt t-z0) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "define G where \"G={t.  g (linepath st tt t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\nthis:\n  G = {t. g (linepath st tt t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "define F where \"F={t.  f (linepath st tt t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (state)\nthis:\n  F = {t. f (linepath st tt t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "define vl where \"vl=(\\<lambda>x. (x-st)/(tt-st))\""], ["proof (state)\nthis:\n  vl = (\\<lambda>x. (x - st) / (tt - st))\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "have \"finite G\" \"finite F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite G &&& finite F", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite G\n 2. finite F", "have \"finite {t. Re (part_circlepath z r st tt t-z0) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\" \n             \"finite {t. Im (part_circlepath z r st tt t-z0) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite\n     {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "using part_circlepath_half_finite_inter[of st tt r \"Complex 1 0\" z \"Re z0\"]\n              part_circlepath_half_finite_inter[of st tt r \"Complex 0 1\" z \"Im z0\"] \\<open>st<tt\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0; Complex 1 0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. part_circlepath z r st tt t \\<bullet> Complex 1 0 =\n                         Re z0 \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  \\<lbrakk>st \\<noteq> tt; r \\<noteq> 0; Complex 0 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {t. part_circlepath z r st tt t \\<bullet> Complex 0 1 =\n                         Im z0 \\<and>\n                         0 \\<le> t \\<and> t \\<le> 1}\n  st < tt\n  0 < r\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite\n     {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by (auto simp add:inner_complex_def Complex_eq_0)"], ["proof (state)\nthis:\n  finite\n   {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. finite G\n 2. finite F", "moreover"], ["proof (state)\nthis:\n  finite\n   {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (2 subgoals):\n 1. finite G\n 2. finite F", "have \n            \"Re (part_circlepath z r st tt t-z0) = 0 \\<longleftrightarrow> g (linepath st tt t) = 0\"\n            \"Im (part_circlepath z r st tt t-z0) = 0 \\<longleftrightarrow> f (linepath st tt t) = 0\"\n            for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (part_circlepath z r st tt t - z0) = 0) =\n    (g (linepath st tt t) = 0) &&&\n    (Im (part_circlepath z r st tt t - z0) = 0) = (f (linepath st tt t) = 0)", "unfolding cindex_pathE_def part_circlepath_def exp_Euler f_def g_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (z +\n         complex_of_real r *\n         (cos (complex_of_real (linepath st tt t)) +\n          \\<i> * sin (complex_of_real (linepath st tt t))) -\n         z0) =\n     0) =\n    (r * cos (linepath st tt t) + Re z - Re z0 = 0) &&&\n    (Im (z +\n         complex_of_real r *\n         (cos (complex_of_real (linepath st tt t)) +\n          \\<i> * sin (complex_of_real (linepath st tt t))) -\n         z0) =\n     0) =\n    (r * sin (linepath st tt t) + Im z - Im z0 = 0)", "by (auto simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  (Re (part_circlepath z r st tt ?t - z0) = 0) = (g (linepath st tt ?t) = 0)\n  (Im (part_circlepath z r st tt ?t - z0) = 0) = (f (linepath st tt ?t) = 0)\n\ngoal (2 subgoals):\n 1. finite G\n 2. finite F", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  (Re (part_circlepath z r st tt ?t - z0) = 0) = (g (linepath st tt ?t) = 0)\n  (Im (part_circlepath z r st tt ?t - z0) = 0) = (f (linepath st tt ?t) = 0)", "show \"finite G\" \"finite F\""], ["proof (prove)\nusing this:\n  finite\n   {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  (Re (part_circlepath z r st tt ?t - z0) = 0) = (g (linepath st tt ?t) = 0)\n  (Im (part_circlepath z r st tt ?t - z0) = 0) = (f (linepath st tt ?t) = 0)\n\ngoal (1 subgoal):\n 1. finite G &&& finite F", "unfolding G_def F_def"], ["proof (prove)\nusing this:\n  finite\n   {t. Re (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  finite\n   {t. Im (part_circlepath z r st tt t - z0) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n  (Re (part_circlepath z r st tt ?t - z0) = 0) = (g (linepath st tt ?t) = 0)\n  (Im (part_circlepath z r st tt ?t - z0) = 0) = (f (linepath st tt ?t) = 0)\n\ngoal (1 subgoal):\n 1. finite\n     {t. g (linepath st tt t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1} &&&\n    finite {t. f (linepath st tt t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite G\n  finite F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite G\n  finite F\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "then"], ["proof (chain)\npicking this:\n  finite G\n  finite F", "have \"finite (linepath st tt ` F)\" \"finite (linepath st tt ` G)\""], ["proof (prove)\nusing this:\n  finite G\n  finite F\n\ngoal (1 subgoal):\n 1. finite (linepath st tt ` F) &&& finite (linepath st tt ` G)", "by auto"], ["proof (state)\nthis:\n  finite (linepath st tt ` F)\n  finite (linepath st tt ` G)\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "moreover"], ["proof (state)\nthis:\n  finite (linepath st tt ` F)\n  finite (linepath st tt ` G)\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "have \n          \"{x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} \\<subseteq> linepath st tt ` F\"\n          \"{x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} \\<subseteq> linepath st tt ` G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` F &&&\n    {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` G", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` F\n 2. {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` G", "have *: \"linepath st tt (vl t) = t\" \"vl t\\<ge>0 \\<longleftrightarrow> t\\<ge>st\" \"vl t\\<le>1 \\<longleftrightarrow>t\\<le>tt\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath st tt (vl t) = t &&&\n    (0 \\<le> vl t) = (st \\<le> t) &&& (vl t \\<le> 1) = (t \\<le> tt)", "unfolding linepath_def vl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (t - st) / (tt - st)) *\\<^sub>R st +\n    ((t - st) / (tt - st)) *\\<^sub>R tt =\n    t &&&\n    (0 \\<le> (t - st) / (tt - st)) = (st \\<le> t) &&&\n    ((t - st) / (tt - st) \\<le> 1) = (t \\<le> tt)", "using \\<open>tt>st\\<close>"], ["proof (prove)\nusing this:\n  st < tt\n\ngoal (1 subgoal):\n 1. (1 - (t - st) / (tt - st)) *\\<^sub>R st +\n    ((t - st) / (tt - st)) *\\<^sub>R tt =\n    t &&&\n    (0 \\<le> (t - st) / (tt - st)) = (st \\<le> t) &&&\n    ((t - st) / (tt - st) \\<le> 1) = (t \\<le> tt)", "apply (auto simp add:divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. st < tt \\<Longrightarrow> (tt - t) * st + (t - st) * tt = t * (tt - st)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  linepath st tt (vl ?t) = ?t\n  (0 \\<le> vl ?t) = (st \\<le> ?t)\n  (vl ?t \\<le> 1) = (?t \\<le> tt)\n\ngoal (2 subgoals):\n 1. {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` F\n 2. {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` G", "then"], ["proof (chain)\npicking this:\n  linepath st tt (vl ?t) = ?t\n  (0 \\<le> vl ?t) = (st \\<le> ?t)\n  (vl ?t \\<le> 1) = (?t \\<le> tt)", "show \n            \"{x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} \\<subseteq> linepath st tt `F\"\n            \"{x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} \\<subseteq> linepath st tt `G\""], ["proof (prove)\nusing this:\n  linepath st tt (vl ?t) = ?t\n  (0 \\<le> vl ?t) = (st \\<le> ?t)\n  (vl ?t \\<le> 1) = (?t \\<le> tt)\n\ngoal (1 subgoal):\n 1. {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` F &&&\n    {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt ` G", "unfolding F_def G_def"], ["proof (prove)\nusing this:\n  linepath st tt (vl ?t) = ?t\n  (0 \\<le> vl ?t) = (st \\<le> ?t)\n  (vl ?t \\<le> 1) = (?t \\<le> tt)\n\ngoal (1 subgoal):\n 1. {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt `\n                {t. f (linepath st tt t) = 0 \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1} &&&\n    {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n    \\<subseteq> linepath st tt `\n                {t. g (linepath st tt t) = 0 \\<and>\n                    0 \\<le> t \\<and> t \\<le> 1}", "by (clarify|rule_tac x=\"vl x\" in rev_image_eqI,auto)+"], ["proof (state)\nthis:\n  {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` F\n  {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` F\n  {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` G\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "ultimately"], ["proof (chain)\npicking this:\n  finite (linepath st tt ` F)\n  finite (linepath st tt ` G)\n  {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` F\n  {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` G", "have \n          \"finite {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\" \n          \"finite {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\""], ["proof (prove)\nusing this:\n  finite (linepath st tt ` F)\n  finite (linepath st tt ` G)\n  {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` F\n  {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  \\<subseteq> linepath st tt ` G\n\ngoal (1 subgoal):\n 1. finite {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} &&&\n    finite {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}", "by (auto elim:rev_finite_subset)"], ["proof (state)\nthis:\n  finite {x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n  finite {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt}\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "from finite_UnI[OF this]"], ["proof (chain)\npicking this:\n  finite\n   ({x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} \\<union>\n    {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt})", "show \"finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}\""], ["proof (prove)\nusing this:\n  finite\n   ({x. f x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt} \\<union>\n    {x. g x = 0 \\<and> st \\<le> x \\<and> x \\<le> tt})\n\ngoal (1 subgoal):\n 1. finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}", "by (elim rev_finite_subset,auto)"], ["proof (state)\nthis:\n  finite {x. (f x = 0 \\<or> g x = 0) \\<and> st \\<le> x \\<and> x \\<le> tt}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE st tt h =\n  jumpF h (at_right st) + real_of_int (cindex st tt h) -\n  jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  real_of_int (cindex st tt h) =\n  (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n  (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)\n  cindexE st tt h =\n  jumpF h (at_right st) + real_of_int (cindex st tt h) -\n  jumpF h (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (cindex st tt h) =\n  (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n  (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)\n  cindexE st tt h =\n  jumpF h (at_right st) + real_of_int (cindex st tt h) -\n  jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "unfolding Let_def"], ["proof (prove)\nusing this:\n  real_of_int (cindex st tt h) =\n  (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n  (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0)\n  cindexE st tt h =\n  jumpF h (at_right st) + real_of_int (cindex st tt h) -\n  jumpF h (at_left tt)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then jumpF_pathstart (part_circlepath z r st tt) z0 +\n          (if st < arccos ((Re z0 - Re z) / r) \\<and>\n              arccos ((Re z0 - Re z) / r) < tt\n           then if Im z0 < r * sin (arccos ((Re z0 - Re z) / r)) + Im z\n                then - 1 else 1\n           else 0) +\n          (if st < 2 * pi - arccos ((Re z0 - Re z) / r) \\<and>\n              2 * pi - arccos ((Re z0 - Re z) / r) < tt\n           then if Im z0\n                   < r * sin (2 * pi - arccos ((Re z0 - Re z) / r)) + Im z\n                then 1 else - 1\n           else 0) -\n          jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "apply (fold zr_def \\<theta>_def \\<beta>_def \\<theta>_if_def \\<beta>_if_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_int (cindex st tt h) =\n             (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0);\n     cindexE st tt h =\n     jumpF h (at_right st) + real_of_int (cindex st tt h) -\n     jumpF h (at_left tt);\n     real_of_int (cindex st tt h) =\n     (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n     (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0);\n     cindexE st tt h =\n     jumpF h (at_right st) + real_of_int (cindex st tt h) -\n     jumpF h (at_left tt);\n     real_of_int (cindex st tt h) =\n     (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n     (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0);\n     cindexE st tt h =\n     jumpF h (at_right st) + real_of_int (cindex st tt h) -\n     jumpF h (at_left tt)\\<rbrakk>\n    \\<Longrightarrow> cindex_pathE (part_circlepath z r st tt) z0 =\n                      (if \\<bar>Re z - Re z0\\<bar> < r\n                       then jumpF_pathstart (part_circlepath z r st tt) z0 +\n                            (if st < \\<theta> \\<and> \\<theta> < tt\n                             then \\<theta>_if else 0) +\n                            (if st < \\<beta> \\<and> \\<beta> < tt\n                             then \\<beta>_if else 0) -\n                            jumpF_pathfinish (part_circlepath z r st tt) z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart (part_circlepath z r st tt)\n                                  z0 -\n                                 jumpF_pathfinish\n                                  (part_circlepath z r st tt) z0\n                            else 0)", "using jstart_eq jfinish_eq index_eq that"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF h (at_right st)\n  jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF h (at_left tt)\n  cindex_pathE (part_circlepath z r st tt) z0 = cindexE st tt h\n  \\<bar>Re z - Re z0\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_int (cindex st tt h) =\n             (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0);\n     cindexE st tt h =\n     jumpF h (at_right st) + real_of_int (cindex st tt h) -\n     jumpF h (at_left tt);\n     real_of_int (cindex st tt h) =\n     (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n     (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0);\n     cindexE st tt h =\n     jumpF h (at_right st) + real_of_int (cindex st tt h) -\n     jumpF h (at_left tt);\n     real_of_int (cindex st tt h) =\n     (if st < \\<theta> \\<and> \\<theta> < tt then \\<theta>_if else 0) +\n     (if st < \\<beta> \\<and> \\<beta> < tt then \\<beta>_if else 0);\n     cindexE st tt h =\n     jumpF h (at_right st) + real_of_int (cindex st tt h) -\n     jumpF h (at_left tt)\\<rbrakk>\n    \\<Longrightarrow> cindex_pathE (part_circlepath z r st tt) z0 =\n                      (if \\<bar>Re z - Re z0\\<bar> < r\n                       then jumpF_pathstart (part_circlepath z r st tt) z0 +\n                            (if st < \\<theta> \\<and> \\<theta> < tt\n                             then \\<theta>_if else 0) +\n                            (if st < \\<beta> \\<and> \\<beta> < tt\n                             then \\<beta>_if else 0) -\n                            jumpF_pathfinish (part_circlepath z r st tt) z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart (part_circlepath z r st tt)\n                                  z0 -\n                                 jumpF_pathfinish\n                                  (part_circlepath z r st tt) z0\n                            else 0)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>Re z - Re z0\\<bar> < r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  r < \\<bar>Re z - Re z0\\<bar> \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n  \\<bar>Re z - Re z0\\<bar> = r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n  \\<bar>Re z - Re z0\\<bar> < r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  r < \\<bar>Re z - Re z0\\<bar> \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n  \\<bar>Re z - Re z0\\<bar> = r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n  \\<bar>Re z - Re z0\\<bar> < r \\<Longrightarrow>\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r st tt) z0 =\n    (if \\<bar>Re z - Re z0\\<bar> < r\n     then let \\<theta> = arccos ((Re z0 - Re z) / r);\n              \\<beta> = 2 * pi - \\<theta>\n          in jumpF_pathstart (part_circlepath z r st tt) z0 +\n             (if st < \\<theta> \\<and> \\<theta> < tt\n              then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n              else 0) +\n             (if st < \\<beta> \\<and> \\<beta> < tt\n              then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1\n              else 0) -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n     else if \\<bar>Re z - Re z0\\<bar> = r\n          then jumpF_pathstart (part_circlepath z r st tt) z0 -\n               jumpF_pathfinish (part_circlepath z r st tt) z0\n          else 0)", "by fastforce"], ["proof (state)\nthis:\n  cindex_pathE (part_circlepath z r st tt) z0 =\n  (if \\<bar>Re z - Re z0\\<bar> < r\n   then let \\<theta> = arccos ((Re z0 - Re z) / r);\n            \\<beta> = 2 * pi - \\<theta>\n        in jumpF_pathstart (part_circlepath z r st tt) z0 +\n           (if st < \\<theta> \\<and> \\<theta> < tt\n            then if Im z0 < r * sin \\<theta> + Im z then - 1 else 1\n            else 0) +\n           (if st < \\<beta> \\<and> \\<beta> < tt\n            then if Im z0 < r * sin \\<beta> + Im z then 1 else - 1 else 0) -\n           jumpF_pathfinish (part_circlepath z r st tt) z0\n   else if \\<bar>Re z - Re z0\\<bar> = r\n        then jumpF_pathstart (part_circlepath z r st tt) z0 -\n             jumpF_pathfinish (part_circlepath z r st tt) z0\n        else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_pathstart_part_circlepath: \n  assumes \"st<tt\" \"r>0\" \"cmod (z-z0) \\<noteq>r\"\n  shows \"jumpF_pathstart (part_circlepath z r st tt) z0 = (\n            if r * cos st + Re z - Re z0 = 0 then \n              (let \n                \\<Delta> = r* sin st + Im z - Im z0\n              in\n                if (sin st > 0 \\<or> cos st=1 ) \\<and> \\<Delta> < 0 \n                    \\<or> (sin st < 0 \\<or>  cos st=-1 ) \\<and> \\<Delta> > 0  then \n                  1/2\n                else \n                  - 1/2)\n            else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "define f where \"f=(\\<lambda>i. r * sin i + Im z - Im z0)\""], ["proof (state)\nthis:\n  f = (\\<lambda>i. r * sin i + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "define g where \"g=(\\<lambda>i. r * cos i + Re z - Re z0)\""], ["proof (state)\nthis:\n  g = (\\<lambda>i. r * cos i + Re z - Re z0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have jumpF_eq:\"jumpF_pathstart (part_circlepath z r st tt) z0 = jumpF (\\<lambda>i. f i/g i) (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "have \"jumpF_pathstart (part_circlepath z r st tt) z0 \n        = jumpF ((\\<lambda>i. f i/g i) o linepath st tt) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0)", "unfolding jumpF_pathstart_def part_circlepath_def exp_Euler f_def g_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0) /\n         Re (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0))\n     (at_right 0) =\n    jumpF\n     (\\<lambda>x.\n         (r * sin (linepath st tt x) + Im z - Im z0) /\n         (r * cos (linepath st tt x) + Re z - Re z0))\n     (at_right 0)", "by (simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "also"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "have \"... = jumpF (\\<lambda>i. f i/g i) (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0) =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "using jumpF_linear_comp(2)[of \"tt-st\" \"(\\<lambda>i. f i/g i)\" st 0,symmetric] \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  (if 0 < tt - st\n   then jumpF (\\<lambda>i. f i / g i) (at_right ((tt - st) * 0 + st))\n   else jumpF (\\<lambda>i. f i / g i) (at_left ((tt - st) * 0 + st))) =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> (\\<lambda>x. (tt - st) * x + st))\n   (at_right 0)\n  st < tt\n\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0) =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  (if 0 < tt - st\n   then jumpF (\\<lambda>i. f i / g i) (at_right ((tt - st) * 0 + st))\n   else jumpF (\\<lambda>i. f i / g i) (at_left ((tt - st) * 0 + st))) =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> (\\<lambda>x. (tt - st) * x + st))\n   (at_right 0)\n  st < tt\n\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n     (at_right 0) =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_right 0) =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "finally"], ["proof (chain)\npicking this:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_right st)", "."], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have g_has_sgnx1:\"(g has_sgnx 1) (at_right st)\" when \"g st=0\" \"sin st < 0 \\<or> cos st=-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "have ?thesis when \"sin st<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "have \"(g has_sgnx sgn (- r * sin st)) (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (- r * sin st)) (at_right st)", "apply (rule has_sgnx_derivative_at_right[of g \"- r * sin st\" st])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_real_derivative - r * sin st) (at st)\n 2. g st = 0\n 3. - r * sin st \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative - r * sin st) (at st)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. r * cos i + Re z - Re z0) has_real_derivative\n     - r * sin st)\n     (at st)", "by (auto intro!:derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g st = 0\n 2. - r * sin st \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. g st = 0", "using \\<open>g st=0\\<close>"], ["proof (prove)\nusing this:\n  g st = 0\n\ngoal (1 subgoal):\n 1. g st = 0", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin st \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin st \\<noteq> 0", "using \\<open>r>0\\<close> \\<open>sin st<0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n  sin st < 0\n\ngoal (1 subgoal):\n 1. - r * sin st \\<noteq> 0", "by (simp add: mult_pos_neg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "using \\<open>r>0\\<close> that"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)\n  0 < r\n  sin st < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sin st < 0 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "moreover"], ["proof (state)\nthis:\n  sin st < 0 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "have ?thesis when \"cos st = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "have \"g i > 0\" when \"st<i\" \"i<st+pi\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < g i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < g i", "obtain k where k_def:\"st = 2 * of_int k * pi+ pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        st = 2 * real_of_int k * pi + pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cos st = -1\\<close>"], ["proof (prove)\nusing this:\n  cos st = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        st = 2 * real_of_int k * pi + pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis cos_eq_minus1 distrib_left mult.commute mult.right_neutral)"], ["proof (state)\nthis:\n  st = 2 * real_of_int k * pi + pi\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"cos (i-st) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - st) < 1", "using cos_monotone_0_pi[of 0 \"i-st\" ] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0; 0 < i - st; i - st \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> cos (i - st) < cos 0\n  st < i\n  i < st + pi\n\ngoal (1 subgoal):\n 1. cos (i - st) < 1", "by auto"], ["proof (state)\nthis:\n  cos (i - st) < 1\n\ngoal (1 subgoal):\n 1. 0 < g i", "moreover"], ["proof (state)\nthis:\n  cos (i - st) < 1\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"cos (i-st) = - cos i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - st) = - cos i", "apply (rule cos_eq_neg_periodic_intro[of _ _ \"-k-1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - st - i = 2 * real_of_int (- k - 1) * pi + pi \\<or>\n    i - st + i = 2 * real_of_int (- k - 1) * pi + pi", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - (2 * real_of_int k * pi + pi) - i =\n    2 * real_of_int (- k - 1) * pi + pi \\<or>\n    i - (2 * real_of_int k * pi + pi) + i =\n    2 * real_of_int (- k - 1) * pi + pi", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cos (i - st) = - cos i\n\ngoal (1 subgoal):\n 1. 0 < g i", "ultimately"], ["proof (chain)\npicking this:\n  cos (i - st) < 1\n  cos (i - st) = - cos i", "have \"cos i>-1\""], ["proof (prove)\nusing this:\n  cos (i - st) < 1\n  cos (i - st) = - cos i\n\ngoal (1 subgoal):\n 1. - 1 < cos i", "by auto"], ["proof (state)\nthis:\n  - 1 < cos i\n\ngoal (1 subgoal):\n 1. 0 < g i", "then"], ["proof (chain)\npicking this:\n  - 1 < cos i", "have \"cos st<cos i\""], ["proof (prove)\nusing this:\n  - 1 < cos i\n\ngoal (1 subgoal):\n 1. cos st < cos i", "using \\<open>cos st=-1\\<close>"], ["proof (prove)\nusing this:\n  - 1 < cos i\n  cos st = - 1\n\ngoal (1 subgoal):\n 1. cos st < cos i", "by auto"], ["proof (state)\nthis:\n  cos st < cos i\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"0 = r * cos st + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = r * cos st + Re z - Re z0", "using \\<open>g st = 0\\<close>"], ["proof (prove)\nusing this:\n  g st = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos st + Re z - Re z0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos st + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  0 = r * cos st + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "also"], ["proof (state)\nthis:\n  0 = r * cos st + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"... < r * cos i + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * cos st + Re z - Re z0 < r * cos i + Re z - Re z0", "using \\<open>cos st < cos i\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  cos st < cos i\n  0 < r\n\ngoal (1 subgoal):\n 1. r * cos st + Re z - Re z0 < r * cos i + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  r * cos st + Re z - Re z0 < r * cos i + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "finally"], ["proof (chain)\npicking this:\n  0 < r * cos i + Re z - Re z0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < r * cos i + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "unfolding g_def"], ["proof (prove)\nusing this:\n  0 < r * cos i + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < r * cos i + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  0 < g i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> 0 < g ?i\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> 0 < g ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> 0 < g ?i\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> 0 < g ?i\n\ngoal (1 subgoal):\n 1. \\<exists>b>st. \\<forall>y>st. y < b \\<longrightarrow> sgn (g y) = 1", "apply (intro exI[where x=\"st+pi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>st < i; i < st + pi\\<rbrakk>\n        \\<Longrightarrow> 0 < g i) \\<Longrightarrow>\n    st < st + pi \\<and>\n    (\\<forall>y>st. y < st + pi \\<longrightarrow> sgn (g y) = 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos st = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "ultimately"], ["proof (chain)\npicking this:\n  sin st < 0 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n  cos st = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_right st)", "show ?thesis"], ["proof (prove)\nusing this:\n  sin st < 0 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n  cos st = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "using that(2)"], ["proof (prove)\nusing this:\n  sin st < 0 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n  cos st = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n  sin st < 0 \\<or> cos st = - 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_right st)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>g st = 0; sin st < 0 \\<or> cos st = - 1\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx 1) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have g_has_sgnx2:\"(g has_sgnx -1) (at_right st)\" when \"g st=0\" \"sin st > 0 \\<or> cos st=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "have ?thesis when \"sin st>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "have \"(g has_sgnx sgn (- r * sin st)) (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (- r * sin st)) (at_right st)", "apply (rule has_sgnx_derivative_at_right[of _ \"- r * sin st\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_real_derivative - r * sin st) (at st)\n 2. g st = 0\n 3. - r * sin st \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative - r * sin st) (at st)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. r * cos i + Re z - Re z0) has_real_derivative\n     - r * sin st)\n     (at st)", "by (auto intro!:derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g st = 0\n 2. - r * sin st \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. g st = 0", "using \\<open>g st=0\\<close>"], ["proof (prove)\nusing this:\n  g st = 0\n\ngoal (1 subgoal):\n 1. g st = 0", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin st \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin st \\<noteq> 0", "using \\<open>r>0\\<close> \\<open>sin st>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n  0 < sin st\n\ngoal (1 subgoal):\n 1. - r * sin st \\<noteq> 0", "by (simp add: mult_pos_neg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "using \\<open>r>0\\<close> that"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (- r * sin st)) (at_right st)\n  0 < r\n  0 < sin st\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < sin st \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "moreover"], ["proof (state)\nthis:\n  0 < sin st \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "have ?thesis when \"cos st=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "have \"g i < 0\" when \"st<i\" \"i<st+pi\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. g i < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g i < 0", "obtain k where k_def:\"st = 2 * of_int k * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        st = 2 * real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cos st=1\\<close> cos_one_2pi_int"], ["proof (prove)\nusing this:\n  cos st = 1\n  (cos ?x = 1) = (\\<exists>x. ?x = real_of_int x * 2 * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        st = 2 * real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  st = 2 * real_of_int k * pi\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"cos (i-st) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - st) < 1", "using cos_monotone_0_pi[of 0 \"i-st\" ] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0; 0 < i - st; i - st \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> cos (i - st) < cos 0\n  st < i\n  i < st + pi\n\ngoal (1 subgoal):\n 1. cos (i - st) < 1", "by auto"], ["proof (state)\nthis:\n  cos (i - st) < 1\n\ngoal (1 subgoal):\n 1. g i < 0", "moreover"], ["proof (state)\nthis:\n  cos (i - st) < 1\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"cos (i-st) = cos i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - st) = cos i", "apply (rule cos_eq_periodic_intro[of _ _ \"-k\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - st - i = 2 * real_of_int (- k) * pi \\<or>\n    i - st + i = 2 * real_of_int (- k) * pi", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 2 * real_of_int k * pi - i = 2 * real_of_int (- k) * pi \\<or>\n    i - 2 * real_of_int k * pi + i = 2 * real_of_int (- k) * pi", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cos (i - st) = cos i\n\ngoal (1 subgoal):\n 1. g i < 0", "ultimately"], ["proof (chain)\npicking this:\n  cos (i - st) < 1\n  cos (i - st) = cos i", "have \"cos i<1\""], ["proof (prove)\nusing this:\n  cos (i - st) < 1\n  cos (i - st) = cos i\n\ngoal (1 subgoal):\n 1. cos i < 1", "by auto"], ["proof (state)\nthis:\n  cos i < 1\n\ngoal (1 subgoal):\n 1. g i < 0", "then"], ["proof (chain)\npicking this:\n  cos i < 1", "have \"cos st>cos i\""], ["proof (prove)\nusing this:\n  cos i < 1\n\ngoal (1 subgoal):\n 1. cos i < cos st", "using \\<open>cos st=1\\<close>"], ["proof (prove)\nusing this:\n  cos i < 1\n  cos st = 1\n\ngoal (1 subgoal):\n 1. cos i < cos st", "by auto"], ["proof (state)\nthis:\n  cos i < cos st\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"0 = r * cos st + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = r * cos st + Re z - Re z0", "using \\<open>g st = 0\\<close>"], ["proof (prove)\nusing this:\n  g st = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos st + Re z - Re z0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos st + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  0 = r * cos st + Re z - Re z0\n\ngoal (1 subgoal):\n 1. g i < 0", "also"], ["proof (state)\nthis:\n  0 = r * cos st + Re z - Re z0\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"... > r * cos i + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * cos i + Re z - Re z0 < r * cos st + Re z - Re z0", "using \\<open>cos st > cos i\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  cos i < cos st\n  0 < r\n\ngoal (1 subgoal):\n 1. r * cos i + Re z - Re z0 < r * cos st + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  r * cos i + Re z - Re z0 < r * cos st + Re z - Re z0\n\ngoal (1 subgoal):\n 1. g i < 0", "finally"], ["proof (chain)\npicking this:\n  r * cos i + Re z - Re z0 < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  r * cos i + Re z - Re z0 < 0\n\ngoal (1 subgoal):\n 1. g i < 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos i + Re z - Re z0 < 0\n\ngoal (1 subgoal):\n 1. r * cos i + Re z - Re z0 < 0", "by auto"], ["proof (state)\nthis:\n  g i < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> g ?i < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> g ?i < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> g ?i < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "unfolding has_sgnx_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>st < ?i; ?i < st + pi\\<rbrakk> \\<Longrightarrow> g ?i < 0\n\ngoal (1 subgoal):\n 1. \\<exists>b>st. \\<forall>y>st. y < b \\<longrightarrow> sgn (g y) = - 1", "apply (intro exI[where x=\"st+pi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>st < i; i < st + pi\\<rbrakk>\n        \\<Longrightarrow> g i < 0) \\<Longrightarrow>\n    st < st + pi \\<and>\n    (\\<forall>y>st. y < st + pi \\<longrightarrow> sgn (g y) = - 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos st = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "ultimately"], ["proof (chain)\npicking this:\n  0 < sin st \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n  cos st = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_right st)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < sin st \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n  cos st = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "using that(2)"], ["proof (prove)\nusing this:\n  0 < sin st \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n  cos st = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n  0 < sin st \\<or> cos st = 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_right st)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_right st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>g st = 0; 0 < sin st \\<or> cos st = 1\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - 1) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"r * cos st + Re z - Re z0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have \"g st \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g st \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g st \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * cos st + Re z - Re z0 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  g st \\<noteq> 0", "have \"continuous (at_right st) (\\<lambda>i. f i / g i)\""], ["proof (prove)\nusing this:\n  g st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_right st) (\\<lambda>i. f i / g i)", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_right st)\n     (\\<lambda>i. (r * sin i + Im z - Im z0) / (r * cos i + Re z - Re z0))", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_right st) (\\<lambda>i. f i / g i)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  continuous (at_right st) (\\<lambda>i. f i / g i)", "have \"jumpF (\\<lambda>i. f i/g i) (at_right st) = 0\""], ["proof (prove)\nusing this:\n  continuous (at_right st) (\\<lambda>i. f i / g i)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_right st) = 0", "using jumpF_not_infinity[of \"at_right st\" \"(\\<lambda>i. f i/g i)\"]"], ["proof (prove)\nusing this:\n  continuous (at_right st) (\\<lambda>i. f i / g i)\n  \\<lbrakk>continuous (at_right st) (\\<lambda>i. f i / g i);\n   at_right st \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF (\\<lambda>i. f i / g i) (at_right st) = 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_right st) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "using jumpF_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 0\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n  r * cos st + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r * cos st + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  r * cos st + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"r * cos st + Re z - Re z0 = 0\" \n    \"(sin st > 0 \\<or> (cos st=1) ) \\<and> f st < 0 \n                    \\<or> (sin st < 0 \\<or>  (cos st=-1) ) \\<and> f st > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have \"g st = 0\" \"f st\\<noteq>0\" and g_cont: \"continuous (at_right st) g\" and f_cont:\"continuous (at_right st) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g st = 0 &&& f st \\<noteq> 0) &&&\n    continuous (at_right st) g &&& continuous (at_right st) f", "using that"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 = 0\n  (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\n\ngoal (1 subgoal):\n 1. (g st = 0 &&& f st \\<noteq> 0) &&&\n    continuous (at_right st) g &&& continuous (at_right st) f", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 = 0\n  (0 < sin st \\<or> cos st = 1) \\<and> r * sin st + Im z - Im z0 < 0 \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < r * sin st + Im z - Im z0\n\ngoal (1 subgoal):\n 1. (r * cos st + Re z - Re z0 = 0 &&&\n     r * sin st + Im z - Im z0 \\<noteq> 0) &&&\n    continuous (at_right st) (\\<lambda>i. r * cos i + Re z - Re z0) &&&\n    continuous (at_right st) (\\<lambda>i. r * sin i + Im z - Im z0)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  g st = 0\n  f st \\<noteq> 0\n  continuous (at_right st) g\n  continuous (at_right st) f\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have \"(g has_sgnx sgn (f st)) (at_right st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f st)) (at_right st)", "using g_has_sgnx1[OF \\<open>g st=0\\<close>] g_has_sgnx2[OF \\<open>g st=0\\<close>] that(2)"], ["proof (prove)\nusing this:\n  sin st < 0 \\<or> cos st = - 1 \\<Longrightarrow>\n  (g has_sgnx 1) (at_right st)\n  0 < sin st \\<or> cos st = 1 \\<Longrightarrow>\n  (g has_sgnx - 1) (at_right st)\n  (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f st)) (at_right st)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f st)) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (f st)) (at_right st)", "have \"LIM x at_right st. f x / g x :> at_top\""], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f st)) (at_right st)\n\ngoal (1 subgoal):\n 1. LIM x at_right st. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f st\" \"at_right st\" g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_sgnx sgn (f st)) (at_right st) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f st) (at_right st)\n 2. (g has_sgnx sgn (f st)) (at_right st) \\<Longrightarrow> f st \\<noteq> 0\n 3. (g has_sgnx sgn (f st)) (at_right st) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_right st) \\<and>\n    (g has_sgnx sgn (f st)) (at_right st)", "using \\<open>f st\\<noteq>0\\<close> \\<open>g st = 0\\<close> g_cont f_cont"], ["proof (prove)\nusing this:\n  f st \\<noteq> 0\n  g st = 0\n  continuous (at_right st) g\n  continuous (at_right st) f\n\ngoal (3 subgoals):\n 1. (g has_sgnx sgn (f st)) (at_right st) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f st) (at_right st)\n 2. (g has_sgnx sgn (f st)) (at_right st) \\<Longrightarrow> f st \\<noteq> 0\n 3. (g has_sgnx sgn (f st)) (at_right st) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_right st) \\<and>\n    (g has_sgnx sgn (f st)) (at_right st)", "by (auto simp add: continuous_within)"], ["proof (state)\nthis:\n  LIM x at_right st. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right st. f x / g x :> at_top", "have \"jumpF (\\<lambda>i. f i/g i) (at_right st) = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right st. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_right st) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right st. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM i at_right st. f i / g i :> at_top then 1 / 2\n     else if LIM i at_right st. f i / g i :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "using jumpF_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = 1 / 2\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n  r * cos st + Re z - Re z0 = 0\n  (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "unfolding f_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_right st) = 1 / 2\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_right st)\n  r * cos st + Re z - Re z0 = 0\n  (0 < sin st \\<or> cos st = 1) \\<and> r * sin st + Im z - Im z0 < 0 \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < r * sin st + Im z - Im z0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n   (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n   (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"r * cos st + Re z - Re z0 = 0\" \n    \"\\<not> ((sin st > 0 \\<or> cos st=1 ) \\<and> f st < 0 \n                    \\<or> (sin st < 0 \\<or>  cos st=-1 ) \\<and> f st > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "define neq1 where \"neq1 = (\\<forall>k::int. st \\<noteq> 2*k*pi)\""], ["proof (state)\nthis:\n  neq1 = (\\<forall>x. st \\<noteq> 2 * real_of_int x * pi)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "define neq2 where \"neq2 = (\\<forall>k::int. st \\<noteq> 2*k*pi+pi)\""], ["proof (state)\nthis:\n  neq2 = (\\<forall>x. st \\<noteq> 2 * real_of_int x * pi + pi)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have \"g st = 0\" and g_cont: \"continuous (at_right st) g\" and f_cont:\"continuous (at_right st) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g st = 0 &&& continuous (at_right st) g &&& continuous (at_right st) f", "using that"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 = 0\n  \\<not> ((0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n          (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st)\n\ngoal (1 subgoal):\n 1. g st = 0 &&& continuous (at_right st) g &&& continuous (at_right st) f", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 = 0\n  \\<not> ((0 < sin st \\<or> cos st = 1) \\<and>\n          r * sin st + Im z - Im z0 < 0 \\<or>\n          (sin st < 0 \\<or> cos st = - 1) \\<and>\n          0 < r * sin st + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. r * cos st + Re z - Re z0 = 0 &&&\n    continuous (at_right st) (\\<lambda>i. r * cos i + Re z - Re z0) &&&\n    continuous (at_right st) (\\<lambda>i. r * sin i + Im z - Im z0)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  g st = 0\n  continuous (at_right st) g\n  continuous (at_right st) f\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have \"f st\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f st \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> f st \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> f st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> f st \\<noteq> 0", "have \"f st = 0\""], ["proof (prove)\nusing this:\n  \\<not> f st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f st = 0", "by auto"], ["proof (state)\nthis:\n  f st = 0\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  f st = 0", "have \"Im (z0 - z) =r * sin st \" \"Re (z0 - z) = r * cos st\""], ["proof (prove)\nusing this:\n  f st = 0\n\ngoal (1 subgoal):\n 1. Im (z0 - z) = r * sin st &&& Re (z0 - z) = r * cos st", "using \\<open>g st=0\\<close>"], ["proof (prove)\nusing this:\n  f st = 0\n  g st = 0\n\ngoal (1 subgoal):\n 1. Im (z0 - z) = r * sin st &&& Re (z0 - z) = r * cos st", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * sin st + Im z - Im z0 = 0\n  r * cos st + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. Im (z0 - z) = r * sin st &&& Re (z0 - z) = r * cos st", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Im (z0 - z) = r * sin st\n  Re (z0 - z) = r * cos st\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Im (z0 - z) = r * sin st\n  Re (z0 - z) = r * cos st", "have \"cmod (z0 - z) = sqrt((r * sin st)^2 + (r * cos st)^2)\""], ["proof (prove)\nusing this:\n  Im (z0 - z) = r * sin st\n  Re (z0 - z) = r * cos st\n\ngoal (1 subgoal):\n 1. cmod (z0 - z) = sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2)", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  Im (z0 - z) = r * sin st\n  Re (z0 - z) = r * cos st\n\ngoal (1 subgoal):\n 1. sqrt ((Re (z0 - z))\\<^sup>2 + (Im (z0 - z))\\<^sup>2) =\n    sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  cmod (z0 - z) = sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  cmod (z0 - z) = sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "have \"... = sqrt (r^2 * ((sin st)^2 + (cos st)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2) =\n    sqrt (r\\<^sup>2 * ((sin st)\\<^sup>2 + (cos st)\\<^sup>2))", "by (auto simp only:algebra_simps power_mult_distrib)"], ["proof (state)\nthis:\n  sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2) =\n  sqrt (r\\<^sup>2 * ((sin st)\\<^sup>2 + (cos st)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sqrt ((r * sin st)\\<^sup>2 + (r * cos st)\\<^sup>2) =\n  sqrt (r\\<^sup>2 * ((sin st)\\<^sup>2 + (cos st)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "have \"... = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (r\\<^sup>2 * ((sin st)\\<^sup>2 + (cos st)\\<^sup>2)) = r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. sqrt (r\\<^sup>2 * ((sin st)\\<^sup>2 + (cos st)\\<^sup>2)) = r", "by simp"], ["proof (state)\nthis:\n  sqrt (r\\<^sup>2 * ((sin st)\\<^sup>2 + (cos st)\\<^sup>2)) = r\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  cmod (z0 - z) = r", "have \"cmod (z0 - z) = r\""], ["proof (prove)\nusing this:\n  cmod (z0 - z) = r\n\ngoal (1 subgoal):\n 1. cmod (z0 - z) = r", "."], ["proof (state)\nthis:\n  cmod (z0 - z) = r\n\ngoal (1 subgoal):\n 1. \\<not> f st \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cmod (z0 - z) = r", "show False"], ["proof (prove)\nusing this:\n  cmod (z0 - z) = r\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cmod (z-z0) \\<noteq>r\\<close>"], ["proof (prove)\nusing this:\n  cmod (z0 - z) = r\n  cmod (z - z0) \\<noteq> r\n\ngoal (1 subgoal):\n 1. False", "by (simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "have \"(sin st > 0 \\<or> (cos st=1) ) \\<and> f st > 0 \\<or> (sin st < 0 \\<or>  (cos st=-1) ) \\<and> f st < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n    (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n    (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "have \"sin st = 0 \\<longleftrightarrow> cos st=-1 \\<or> cos st=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sin st = 0) = (cos st = - 1 \\<or> cos st = 1)", "by (metis (no_types, hide_lams) add.right_neutral cancel_comm_monoid_add_class.diff_cancel \n            cos_diff cos_zero mult_eq_0_iff power2_eq_1_iff power2_eq_square sin_squared_eq)"], ["proof (state)\nthis:\n  (sin st = 0) = (cos st = - 1 \\<or> cos st = 1)\n\ngoal (1 subgoal):\n 1. (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n    (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "moreover"], ["proof (state)\nthis:\n  (sin st = 0) = (cos st = - 1 \\<or> cos st = 1)\n\ngoal (1 subgoal):\n 1. (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n    (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "have \"((sin st \\<le> 0 \\<and> cos st \\<noteq>1 ) \\<or> f st > 0) \\<and> ((sin st \\<ge> 0 \\<and>  cos st\\<noteq>-1) \\<or> f st < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sin st \\<le> 0 \\<and> cos st \\<noteq> 1 \\<or> 0 < f st) \\<and>\n    (0 \\<le> sin st \\<and> cos st \\<noteq> - 1 \\<or> f st < 0)", "using that(2) \\<open>f st\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> ((0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n          (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st)\n  f st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sin st \\<le> 0 \\<and> cos st \\<noteq> 1 \\<or> 0 < f st) \\<and>\n    (0 \\<le> sin st \\<and> cos st \\<noteq> - 1 \\<or> f st < 0)", "by argo"], ["proof (state)\nthis:\n  (sin st \\<le> 0 \\<and> cos st \\<noteq> 1 \\<or> 0 < f st) \\<and>\n  (0 \\<le> sin st \\<and> cos st \\<noteq> - 1 \\<or> f st < 0)\n\ngoal (1 subgoal):\n 1. (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n    (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "ultimately"], ["proof (chain)\npicking this:\n  (sin st = 0) = (cos st = - 1 \\<or> cos st = 1)\n  (sin st \\<le> 0 \\<and> cos st \\<noteq> 1 \\<or> 0 < f st) \\<and>\n  (0 \\<le> sin st \\<and> cos st \\<noteq> - 1 \\<or> f st < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (sin st = 0) = (cos st = - 1 \\<or> cos st = 1)\n  (sin st \\<le> 0 \\<and> cos st \\<noteq> 1 \\<or> 0 < f st) \\<and>\n  (0 \\<le> sin st \\<and> cos st \\<noteq> - 1 \\<or> f st < 0)\n\ngoal (1 subgoal):\n 1. (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n    (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "by (meson linorder_neqE_linordered_idom not_le)"], ["proof (state)\nthis:\n  (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0", "have \"(g has_sgnx - sgn (f st)) (at_right st)\""], ["proof (prove)\nusing this:\n  (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f st)) (at_right st)", "using g_has_sgnx1[OF \\<open>g st=0\\<close>] g_has_sgnx2[OF \\<open>g st=0\\<close>]"], ["proof (prove)\nusing this:\n  (0 < sin st \\<or> cos st = 1) \\<and> 0 < f st \\<or>\n  (sin st < 0 \\<or> cos st = - 1) \\<and> f st < 0\n  sin st < 0 \\<or> cos st = - 1 \\<Longrightarrow>\n  (g has_sgnx 1) (at_right st)\n  0 < sin st \\<or> cos st = 1 \\<Longrightarrow>\n  (g has_sgnx - 1) (at_right st)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f st)) (at_right st)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f st)) (at_right st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (f st)) (at_right st)", "have \"LIM x at_right st. f x / g x :> at_bot\""], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f st)) (at_right st)\n\ngoal (1 subgoal):\n 1. LIM x at_right st. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f st\" \"at_right st\" g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_sgnx - sgn (f st)) (at_right st) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f st) (at_right st)\n 2. (g has_sgnx - sgn (f st)) (at_right st) \\<Longrightarrow>\n    f st \\<noteq> 0\n 3. (g has_sgnx - sgn (f st)) (at_right st) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_right st) \\<and>\n    (g has_sgnx - sgn (f st)) (at_right st)", "using \\<open>f st\\<noteq>0\\<close> \\<open>g st = 0\\<close> g_cont f_cont"], ["proof (prove)\nusing this:\n  f st \\<noteq> 0\n  g st = 0\n  continuous (at_right st) g\n  continuous (at_right st) f\n\ngoal (3 subgoals):\n 1. (g has_sgnx - sgn (f st)) (at_right st) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f st) (at_right st)\n 2. (g has_sgnx - sgn (f st)) (at_right st) \\<Longrightarrow>\n    f st \\<noteq> 0\n 3. (g has_sgnx - sgn (f st)) (at_right st) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_right st) \\<and>\n    (g has_sgnx - sgn (f st)) (at_right st)", "by (auto simp add: continuous_within)"], ["proof (state)\nthis:\n  LIM x at_right st. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right st. f x / g x :> at_bot", "have \"jumpF (\\<lambda>i. f i/g i) (at_right st) = -1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right st. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_right st) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right st. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM i at_right st. f i / g i :> at_top then 1 / 2\n     else if LIM i at_right st. f i / g i :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "using jumpF_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_right st) = - 1 / 2\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_right st)\n  r * cos st + Re z - Re z0 = 0\n  \\<not> ((0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n          (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "unfolding f_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_right st) =\n  - 1 / 2\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_right st)\n  r * cos st + Re z - Re z0 = 0\n  \\<not> ((0 < sin st \\<or> cos st = 1) \\<and>\n          r * sin st + Im z - Im z0 < 0 \\<or>\n          (sin st < 0 \\<or> cos st = - 1) \\<and>\n          0 < r * sin st + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   \\<not> ((0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n           (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  r * cos st + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n   (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   \\<not> ((0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n           (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  r * cos st + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   (0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n   (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>r * cos st + Re z - Re z0 = 0;\n   \\<not> ((0 < sin st \\<or> cos st = 1) \\<and> f st < 0 \\<or>\n           (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < f st)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (part_circlepath z r st tt) z0 =\n                    (if r * cos st + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin st + Im z - Im z0\n                          in if (0 < sin st \\<or> cos st = 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin st < 0 \\<or> cos st = - 1) \\<and>\n                                0 < \\<Delta>\n                             then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r st tt) z0 =\n    (if r * cos st + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin st + Im z - Im z0\n          in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0)", "by fast"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r st tt) z0 =\n  (if r * cos st + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin st + Im z - Im z0\n        in if (0 < sin st \\<or> cos st = 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin st < 0 \\<or> cos st = - 1) \\<and> 0 < \\<Delta>\n           then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_pathfinish_part_circlepath: \n  assumes \"st<tt\" \"r>0\" \"cmod (z-z0) \\<noteq>r\"\n  shows \"jumpF_pathfinish (part_circlepath z r st tt) z0 = (\n            if r * cos tt + Re z - Re z0 = 0 then \n              (let \n                \\<Delta> = r* sin tt + Im z - Im z0\n              in\n                if (sin tt > 0 \\<or> cos tt=-1 ) \\<and> \\<Delta> < 0 \n                    \\<or> (sin tt < 0 \\<or>  cos tt=1 ) \\<and> \\<Delta> > 0  then \n                  - 1/2\n                else \n                  1/2)\n            else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "define f where \"f=(\\<lambda>i. r * sin i + Im z - Im z0)\""], ["proof (state)\nthis:\n  f = (\\<lambda>i. r * sin i + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "define g where \"g=(\\<lambda>i. r * cos i + Re z - Re z0)\""], ["proof (state)\nthis:\n  g = (\\<lambda>i. r * cos i + Re z - Re z0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have jumpF_eq:\"jumpF_pathfinish (part_circlepath z r st tt) z0 = jumpF (\\<lambda>i. f i/g i) (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "have \"jumpF_pathfinish (part_circlepath z r st tt) z0 \n        = jumpF ((\\<lambda>i. f i/g i) o linepath st tt) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1)", "unfolding jumpF_pathfinish_def part_circlepath_def exp_Euler f_def g_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0) /\n         Re (z +\n             complex_of_real r *\n             (cos (complex_of_real (linepath st tt t)) +\n              \\<i> * sin (complex_of_real (linepath st tt t))) -\n             z0))\n     (at_left 1) =\n    jumpF\n     (\\<lambda>x.\n         (r * sin (linepath st tt x) + Im z - Im z0) /\n         (r * cos (linepath st tt x) + Re z - Re z0))\n     (at_left 1)", "by (simp add:cos_of_real sin_of_real algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "also"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "have \"... = jumpF (\\<lambda>i. f i/g i) (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1) =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "using jumpF_linear_comp(1)[of \"tt-st\" \"(\\<lambda>i. f i/g i)\" st 1,symmetric]  \\<open>st<tt\\<close>"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  (if 0 < tt - st\n   then jumpF (\\<lambda>i. f i / g i) (at_left ((tt - st) * 1 + st))\n   else jumpF (\\<lambda>i. f i / g i) (at_right ((tt - st) * 1 + st))) =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> (\\<lambda>x. (tt - st) * x + st))\n   (at_left 1)\n  st < tt\n\ngoal (1 subgoal):\n 1. jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1) =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  tt - st \\<noteq> 0 \\<Longrightarrow>\n  (if 0 < tt - st\n   then jumpF (\\<lambda>i. f i / g i) (at_left ((tt - st) * 1 + st))\n   else jumpF (\\<lambda>i. f i / g i) (at_right ((tt - st) * 1 + st))) =\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> (\\<lambda>x. (tt - st) * x + st))\n   (at_left 1)\n  st < tt\n\ngoal (1 subgoal):\n 1. jumpF\n     ((\\<lambda>i. f i / g i) \\<circ>\n      (\\<lambda>x. (1 - x) *\\<^sub>R st + x *\\<^sub>R tt))\n     (at_left 1) =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF ((\\<lambda>i. f i / g i) \\<circ> linepath st tt) (at_left 1) =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "finally"], ["proof (chain)\npicking this:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    jumpF (\\<lambda>i. f i / g i) (at_left tt)", "."], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have g_has_sgnx1:\"(g has_sgnx -1) (at_left tt)\" when \"g tt=0\" \"sin tt < 0 \\<or> cos tt=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "have ?thesis when \"sin tt<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "have \"(g has_sgnx - sgn (- r * sin tt)) (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (- r * sin tt)) (at_left tt)", "apply (rule has_sgnx_derivative_at_left[of _ \"- r * sin tt\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_real_derivative - r * sin tt) (at tt)\n 2. g tt = 0\n 3. - r * sin tt \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative - r * sin tt) (at tt)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. r * cos i + Re z - Re z0) has_real_derivative\n     - r * sin tt)\n     (at tt)", "by (auto intro!:derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g tt = 0\n 2. - r * sin tt \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. g tt = 0", "using \\<open>g tt=0\\<close>"], ["proof (prove)\nusing this:\n  g tt = 0\n\ngoal (1 subgoal):\n 1. g tt = 0", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin tt \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin tt \\<noteq> 0", "using \\<open>r>0\\<close> \\<open>sin tt<0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n  sin tt < 0\n\ngoal (1 subgoal):\n 1. - r * sin tt \\<noteq> 0", "by (simp add: mult_pos_neg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "using \\<open>r>0\\<close> that"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)\n  0 < r\n  sin tt < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sin tt < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "moreover"], ["proof (state)\nthis:\n  sin tt < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "have ?thesis when \"cos tt=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "have \"g i < 0\" when \"tt-pi<i\" \"i<tt\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. g i < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g i < 0", "obtain k where k_def:\"tt = 2 * of_int k * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tt = 2 * real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cos tt=1\\<close> cos_one_2pi_int"], ["proof (prove)\nusing this:\n  cos tt = 1\n  (cos ?x = 1) = (\\<exists>x. ?x = real_of_int x * 2 * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tt = 2 * real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tt = 2 * real_of_int k * pi\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"cos (i-tt) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - tt) < 1", "using cos_monotone_0_pi[of 0 \"tt-i\" ] that cos_minus[of \"tt-i\",simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0; 0 < tt - i; tt - i \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> cos (tt - i) < cos 0\n  tt - pi < i\n  i < tt\n  cos (i - tt) = cos (tt - i)\n\ngoal (1 subgoal):\n 1. cos (i - tt) < 1", "by auto"], ["proof (state)\nthis:\n  cos (i - tt) < 1\n\ngoal (1 subgoal):\n 1. g i < 0", "moreover"], ["proof (state)\nthis:\n  cos (i - tt) < 1\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"cos (i-tt) = cos i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - tt) = cos i", "apply (rule cos_eq_periodic_intro[of _ _ \"-k\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - tt - i = 2 * real_of_int (- k) * pi \\<or>\n    i - tt + i = 2 * real_of_int (- k) * pi", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 2 * real_of_int k * pi - i = 2 * real_of_int (- k) * pi \\<or>\n    i - 2 * real_of_int k * pi + i = 2 * real_of_int (- k) * pi", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cos (i - tt) = cos i\n\ngoal (1 subgoal):\n 1. g i < 0", "ultimately"], ["proof (chain)\npicking this:\n  cos (i - tt) < 1\n  cos (i - tt) = cos i", "have \"cos i<1\""], ["proof (prove)\nusing this:\n  cos (i - tt) < 1\n  cos (i - tt) = cos i\n\ngoal (1 subgoal):\n 1. cos i < 1", "by auto"], ["proof (state)\nthis:\n  cos i < 1\n\ngoal (1 subgoal):\n 1. g i < 0", "then"], ["proof (chain)\npicking this:\n  cos i < 1", "have \"cos tt>cos i\""], ["proof (prove)\nusing this:\n  cos i < 1\n\ngoal (1 subgoal):\n 1. cos i < cos tt", "using \\<open>cos tt=1\\<close>"], ["proof (prove)\nusing this:\n  cos i < 1\n  cos tt = 1\n\ngoal (1 subgoal):\n 1. cos i < cos tt", "by auto"], ["proof (state)\nthis:\n  cos i < cos tt\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"0 = r * cos tt + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = r * cos tt + Re z - Re z0", "using \\<open>g tt = 0\\<close>"], ["proof (prove)\nusing this:\n  g tt = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos tt + Re z - Re z0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos tt + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  0 = r * cos tt + Re z - Re z0\n\ngoal (1 subgoal):\n 1. g i < 0", "also"], ["proof (state)\nthis:\n  0 = r * cos tt + Re z - Re z0\n\ngoal (1 subgoal):\n 1. g i < 0", "have \"... > r * cos i + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * cos i + Re z - Re z0 < r * cos tt + Re z - Re z0", "using \\<open>cos tt > cos i\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  cos i < cos tt\n  0 < r\n\ngoal (1 subgoal):\n 1. r * cos i + Re z - Re z0 < r * cos tt + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  r * cos i + Re z - Re z0 < r * cos tt + Re z - Re z0\n\ngoal (1 subgoal):\n 1. g i < 0", "finally"], ["proof (chain)\npicking this:\n  r * cos i + Re z - Re z0 < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  r * cos i + Re z - Re z0 < 0\n\ngoal (1 subgoal):\n 1. g i < 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos i + Re z - Re z0 < 0\n\ngoal (1 subgoal):\n 1. r * cos i + Re z - Re z0 < 0", "by auto"], ["proof (state)\nthis:\n  g i < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> g ?i < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> g ?i < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> g ?i < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\nusing this:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> g ?i < 0\n\ngoal (1 subgoal):\n 1. \\<exists>b<tt. \\<forall>y>b. y < tt \\<longrightarrow> sgn (g y) = - 1", "apply (intro exI[where x=\"tt-pi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>tt - pi < i; i < tt\\<rbrakk>\n        \\<Longrightarrow> g i < 0) \\<Longrightarrow>\n    tt - pi < tt \\<and>\n    (\\<forall>y>tt - pi. y < tt \\<longrightarrow> sgn (g y) = - 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos tt = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "ultimately"], ["proof (chain)\npicking this:\n  sin tt < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n  cos tt = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  sin tt < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n  cos tt = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "using that(2)"], ["proof (prove)\nusing this:\n  sin tt < 0 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n  cos tt = 1 \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n  sin tt < 0 \\<or> cos tt = 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx - 1) (at_left tt)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - 1) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>g tt = 0; sin tt < 0 \\<or> cos tt = 1\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have g_has_sgnx2:\"(g has_sgnx 1) (at_left tt)\" when \"g tt=0\" \"sin tt > 0 \\<or> cos tt=-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "have ?thesis when \"sin tt>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "have \"(g has_sgnx - sgn (- r * sin tt)) (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (- r * sin tt)) (at_left tt)", "apply (rule has_sgnx_derivative_at_left[of _ \"- r * sin tt\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_real_derivative - r * sin tt) (at tt)\n 2. g tt = 0\n 3. - r * sin tt \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative - r * sin tt) (at tt)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. r * cos i + Re z - Re z0) has_real_derivative\n     - r * sin tt)\n     (at tt)", "by (auto intro!:derivative_eq_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g tt = 0\n 2. - r * sin tt \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. g tt = 0", "using \\<open>g tt=0\\<close>"], ["proof (prove)\nusing this:\n  g tt = 0\n\ngoal (1 subgoal):\n 1. g tt = 0", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin tt \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * sin tt \\<noteq> 0", "using \\<open>r>0\\<close> \\<open>sin tt>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n  0 < sin tt\n\ngoal (1 subgoal):\n 1. - r * sin tt \\<noteq> 0", "by (simp add: mult_pos_neg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "using \\<open>r>0\\<close> that"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (- r * sin tt)) (at_left tt)\n  0 < r\n  0 < sin tt\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < sin tt \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "moreover"], ["proof (state)\nthis:\n  0 < sin tt \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "have ?thesis when \"cos tt = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "have \"g i > 0\" when \"tt-pi<i\" \"i<tt\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < g i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < g i", "obtain k where k_def:\"tt = 2 * of_int k * pi+ pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tt = 2 * real_of_int k * pi + pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cos tt = -1\\<close>"], ["proof (prove)\nusing this:\n  cos tt = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tt = 2 * real_of_int k * pi + pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis cos_eq_minus1 distrib_left mult.commute mult.right_neutral)"], ["proof (state)\nthis:\n  tt = 2 * real_of_int k * pi + pi\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"cos (i-tt) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - tt) < 1", "using cos_monotone_0_pi[of 0 \"tt-i\" ] that cos_minus[of \"tt-i\",simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 0; 0 < tt - i; tt - i \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> cos (tt - i) < cos 0\n  tt - pi < i\n  i < tt\n  cos (i - tt) = cos (tt - i)\n\ngoal (1 subgoal):\n 1. cos (i - tt) < 1", "by auto"], ["proof (state)\nthis:\n  cos (i - tt) < 1\n\ngoal (1 subgoal):\n 1. 0 < g i", "moreover"], ["proof (state)\nthis:\n  cos (i - tt) < 1\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"cos (i-tt) = - cos i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (i - tt) = - cos i", "apply (rule cos_eq_neg_periodic_intro[of _ _ \"-k-1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - tt - i = 2 * real_of_int (- k - 1) * pi + pi \\<or>\n    i - tt + i = 2 * real_of_int (- k - 1) * pi + pi", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i - (2 * real_of_int k * pi + pi) - i =\n    2 * real_of_int (- k - 1) * pi + pi \\<or>\n    i - (2 * real_of_int k * pi + pi) + i =\n    2 * real_of_int (- k - 1) * pi + pi", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cos (i - tt) = - cos i\n\ngoal (1 subgoal):\n 1. 0 < g i", "ultimately"], ["proof (chain)\npicking this:\n  cos (i - tt) < 1\n  cos (i - tt) = - cos i", "have \"cos i>-1\""], ["proof (prove)\nusing this:\n  cos (i - tt) < 1\n  cos (i - tt) = - cos i\n\ngoal (1 subgoal):\n 1. - 1 < cos i", "by auto"], ["proof (state)\nthis:\n  - 1 < cos i\n\ngoal (1 subgoal):\n 1. 0 < g i", "then"], ["proof (chain)\npicking this:\n  - 1 < cos i", "have \"cos tt<cos i\""], ["proof (prove)\nusing this:\n  - 1 < cos i\n\ngoal (1 subgoal):\n 1. cos tt < cos i", "using \\<open>cos tt=-1\\<close>"], ["proof (prove)\nusing this:\n  - 1 < cos i\n  cos tt = - 1\n\ngoal (1 subgoal):\n 1. cos tt < cos i", "by auto"], ["proof (state)\nthis:\n  cos tt < cos i\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"0 = r * cos tt + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = r * cos tt + Re z - Re z0", "using \\<open>g tt = 0\\<close>"], ["proof (prove)\nusing this:\n  g tt = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos tt + Re z - Re z0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. 0 = r * cos tt + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  0 = r * cos tt + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "also"], ["proof (state)\nthis:\n  0 = r * cos tt + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "have \"... < r * cos i + Re z - Re z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * cos tt + Re z - Re z0 < r * cos i + Re z - Re z0", "using \\<open>cos tt < cos i\\<close> \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  cos tt < cos i\n  0 < r\n\ngoal (1 subgoal):\n 1. r * cos tt + Re z - Re z0 < r * cos i + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  r * cos tt + Re z - Re z0 < r * cos i + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "finally"], ["proof (chain)\npicking this:\n  0 < r * cos i + Re z - Re z0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < r * cos i + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < g i", "unfolding g_def"], ["proof (prove)\nusing this:\n  0 < r * cos i + Re z - Re z0\n\ngoal (1 subgoal):\n 1. 0 < r * cos i + Re z - Re z0", "by auto"], ["proof (state)\nthis:\n  0 < g i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> 0 < g ?i\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> 0 < g ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> 0 < g ?i\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "unfolding has_sgnx_def eventually_at_left"], ["proof (prove)\nusing this:\n  \\<lbrakk>tt - pi < ?i; ?i < tt\\<rbrakk> \\<Longrightarrow> 0 < g ?i\n\ngoal (1 subgoal):\n 1. \\<exists>b<tt. \\<forall>y>b. y < tt \\<longrightarrow> sgn (g y) = 1", "apply (intro exI[where x=\"tt-pi\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>tt - pi < i; i < tt\\<rbrakk>\n        \\<Longrightarrow> 0 < g i) \\<Longrightarrow>\n    tt - pi < tt \\<and>\n    (\\<forall>y>tt - pi. y < tt \\<longrightarrow> sgn (g y) = 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos tt = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "ultimately"], ["proof (chain)\npicking this:\n  0 < sin tt \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n  cos tt = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_left tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < sin tt \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n  cos tt = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "using that(2)"], ["proof (prove)\nusing this:\n  0 < sin tt \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n  cos tt = - 1 \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n  0 < sin tt \\<or> cos tt = - 1\n\ngoal (1 subgoal):\n 1. (g has_sgnx 1) (at_left tt)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx 1) (at_left tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>g tt = 0; 0 < sin tt \\<or> cos tt = - 1\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have ?thesis when \"r * cos tt + Re z - Re z0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have \"g tt \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g tt \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g tt \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r * cos tt + Re z - Re z0 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  g tt \\<noteq> 0", "have \"continuous (at_left tt) (\\<lambda>i. f i / g i)\""], ["proof (prove)\nusing this:\n  g tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_left tt) (\\<lambda>i. f i / g i)", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_left tt)\n     (\\<lambda>i. (r * sin i + Im z - Im z0) / (r * cos i + Re z - Re z0))", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_left tt) (\\<lambda>i. f i / g i)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  continuous (at_left tt) (\\<lambda>i. f i / g i)", "have \"jumpF (\\<lambda>i. f i/g i) (at_left tt) = 0\""], ["proof (prove)\nusing this:\n  continuous (at_left tt) (\\<lambda>i. f i / g i)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0", "using jumpF_not_infinity[of \"at_left tt\" \"(\\<lambda>i. f i/g i)\"]"], ["proof (prove)\nusing this:\n  continuous (at_left tt) (\\<lambda>i. f i / g i)\n  \\<lbrakk>continuous (at_left tt) (\\<lambda>i. f i / g i);\n   at_left tt \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "using jumpF_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 0\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n  r * cos tt + Re z - Re z0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r * cos tt + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  r * cos tt + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have ?thesis when \"r * cos tt + Re z - Re z0 = 0\" \n    \"(sin tt > 0 \\<or> cos tt=-1 ) \\<and> f tt < 0 \n                    \\<or> (sin tt < 0 \\<or> cos tt=1 ) \\<and> f tt > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have \"g tt = 0\" \"f tt\\<noteq>0\" and g_cont: \"continuous (at_left tt) g\" and f_cont:\"continuous (at_left tt) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g tt = 0 &&& f tt \\<noteq> 0) &&&\n    continuous (at_left tt) g &&& continuous (at_left tt) f", "using that"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 = 0\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\n\ngoal (1 subgoal):\n 1. (g tt = 0 &&& f tt \\<noteq> 0) &&&\n    continuous (at_left tt) g &&& continuous (at_left tt) f", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 = 0\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> r * sin tt + Im z - Im z0 < 0 \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < r * sin tt + Im z - Im z0\n\ngoal (1 subgoal):\n 1. (r * cos tt + Re z - Re z0 = 0 &&&\n     r * sin tt + Im z - Im z0 \\<noteq> 0) &&&\n    continuous (at_left tt) (\\<lambda>i. r * cos i + Re z - Re z0) &&&\n    continuous (at_left tt) (\\<lambda>i. r * sin i + Im z - Im z0)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  g tt = 0\n  f tt \\<noteq> 0\n  continuous (at_left tt) g\n  continuous (at_left tt) f\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have \"(g has_sgnx - sgn (f tt)) (at_left tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f tt)) (at_left tt)", "using g_has_sgnx1[OF \\<open>g tt=0\\<close>] g_has_sgnx2[OF \\<open>g tt=0\\<close>] that(2)"], ["proof (prove)\nusing this:\n  sin tt < 0 \\<or> cos tt = 1 \\<Longrightarrow>\n  (g has_sgnx - 1) (at_left tt)\n  0 < sin tt \\<or> cos tt = - 1 \\<Longrightarrow>\n  (g has_sgnx 1) (at_left tt)\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (f tt)) (at_left tt)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (f tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (f tt)) (at_left tt)", "have \"LIM x at_left tt. f x / g x :> at_bot\""], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (f tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. LIM x at_left tt. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f tt\" \"at_left tt\" g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_sgnx - sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f tt) (at_left tt)\n 2. (g has_sgnx - sgn (f tt)) (at_left tt) \\<Longrightarrow> f tt \\<noteq> 0\n 3. (g has_sgnx - sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_left tt) \\<and>\n    (g has_sgnx - sgn (f tt)) (at_left tt)", "using \\<open>f tt\\<noteq>0\\<close> \\<open>g tt = 0\\<close> g_cont f_cont"], ["proof (prove)\nusing this:\n  f tt \\<noteq> 0\n  g tt = 0\n  continuous (at_left tt) g\n  continuous (at_left tt) f\n\ngoal (3 subgoals):\n 1. (g has_sgnx - sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f tt) (at_left tt)\n 2. (g has_sgnx - sgn (f tt)) (at_left tt) \\<Longrightarrow> f tt \\<noteq> 0\n 3. (g has_sgnx - sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_left tt) \\<and>\n    (g has_sgnx - sgn (f tt)) (at_left tt)", "by (auto simp add: continuous_within)"], ["proof (state)\nthis:\n  LIM x at_left tt. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left tt. f x / g x :> at_bot", "have \"jumpF (\\<lambda>i. f i/g i) (at_left tt) = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left tt. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_left tt) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left tt. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM i at_left tt. f i / g i :> at_top then 1 / 2\n     else if LIM i at_left tt. f i / g i :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "using jumpF_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = - 1 / 2\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n  r * cos tt + Re z - Re z0 = 0\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "unfolding f_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_left tt) =\n  - 1 / 2\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_left tt)\n  r * cos tt + Re z - Re z0 = 0\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> r * sin tt + Im z - Im z0 < 0 \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < r * sin tt + Im z - Im z0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n   (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n   (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have ?thesis when \"r * cos tt + Re z - Re z0 = 0\" \n    \"\\<not> ((sin tt > 0 \\<or> cos tt=-1 ) \\<and> f tt < 0 \n                    \\<or> (sin tt < 0 \\<or>  cos tt=1 ) \\<and> f tt > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have \"g tt = 0\" and g_cont: \"continuous (at_left tt) g\" and f_cont:\"continuous (at_left tt) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g tt = 0 &&& continuous (at_left tt) g &&& continuous (at_left tt) f", "using that"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 = 0\n  \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n          (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt)\n\ngoal (1 subgoal):\n 1. g tt = 0 &&& continuous (at_left tt) g &&& continuous (at_left tt) f", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 = 0\n  \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and>\n          r * sin tt + Im z - Im z0 < 0 \\<or>\n          (sin tt < 0 \\<or> cos tt = 1) \\<and>\n          0 < r * sin tt + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. r * cos tt + Re z - Re z0 = 0 &&&\n    continuous (at_left tt) (\\<lambda>i. r * cos i + Re z - Re z0) &&&\n    continuous (at_left tt) (\\<lambda>i. r * sin i + Im z - Im z0)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  g tt = 0\n  continuous (at_left tt) g\n  continuous (at_left tt) f\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have \"f tt\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f tt \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> f tt \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> f tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> f tt \\<noteq> 0", "have \"f tt = 0\""], ["proof (prove)\nusing this:\n  \\<not> f tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f tt = 0", "by auto"], ["proof (state)\nthis:\n  f tt = 0\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  f tt = 0", "have \"Im (z0 - z) =r * sin tt \" \"Re (z0 - z) = r * cos tt\""], ["proof (prove)\nusing this:\n  f tt = 0\n\ngoal (1 subgoal):\n 1. Im (z0 - z) = r * sin tt &&& Re (z0 - z) = r * cos tt", "using \\<open>g tt=0\\<close>"], ["proof (prove)\nusing this:\n  f tt = 0\n  g tt = 0\n\ngoal (1 subgoal):\n 1. Im (z0 - z) = r * sin tt &&& Re (z0 - z) = r * cos tt", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  r * sin tt + Im z - Im z0 = 0\n  r * cos tt + Re z - Re z0 = 0\n\ngoal (1 subgoal):\n 1. Im (z0 - z) = r * sin tt &&& Re (z0 - z) = r * cos tt", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Im (z0 - z) = r * sin tt\n  Re (z0 - z) = r * cos tt\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Im (z0 - z) = r * sin tt\n  Re (z0 - z) = r * cos tt", "have \"cmod (z0 - z) = sqrt((r * sin tt)^2 + (r * cos tt)^2)\""], ["proof (prove)\nusing this:\n  Im (z0 - z) = r * sin tt\n  Re (z0 - z) = r * cos tt\n\ngoal (1 subgoal):\n 1. cmod (z0 - z) = sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2)", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  Im (z0 - z) = r * sin tt\n  Re (z0 - z) = r * cos tt\n\ngoal (1 subgoal):\n 1. sqrt ((Re (z0 - z))\\<^sup>2 + (Im (z0 - z))\\<^sup>2) =\n    sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  cmod (z0 - z) = sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  cmod (z0 - z) = sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "have \"... = sqrt (r^2 * ((sin tt)^2 + (cos tt)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2) =\n    sqrt (r\\<^sup>2 * ((sin tt)\\<^sup>2 + (cos tt)\\<^sup>2))", "by (auto simp only:algebra_simps power_mult_distrib)"], ["proof (state)\nthis:\n  sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2) =\n  sqrt (r\\<^sup>2 * ((sin tt)\\<^sup>2 + (cos tt)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sqrt ((r * sin tt)\\<^sup>2 + (r * cos tt)\\<^sup>2) =\n  sqrt (r\\<^sup>2 * ((sin tt)\\<^sup>2 + (cos tt)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "have \"... = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (r\\<^sup>2 * ((sin tt)\\<^sup>2 + (cos tt)\\<^sup>2)) = r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. sqrt (r\\<^sup>2 * ((sin tt)\\<^sup>2 + (cos tt)\\<^sup>2)) = r", "by simp"], ["proof (state)\nthis:\n  sqrt (r\\<^sup>2 * ((sin tt)\\<^sup>2 + (cos tt)\\<^sup>2)) = r\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  cmod (z0 - z) = r", "have \"cmod (z0 - z) = r\""], ["proof (prove)\nusing this:\n  cmod (z0 - z) = r\n\ngoal (1 subgoal):\n 1. cmod (z0 - z) = r", "."], ["proof (state)\nthis:\n  cmod (z0 - z) = r\n\ngoal (1 subgoal):\n 1. \\<not> f tt \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cmod (z0 - z) = r", "show False"], ["proof (prove)\nusing this:\n  cmod (z0 - z) = r\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cmod (z-z0) \\<noteq>r\\<close>"], ["proof (prove)\nusing this:\n  cmod (z0 - z) = r\n  cmod (z - z0) \\<noteq> r\n\ngoal (1 subgoal):\n 1. False", "by (simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "have \"(sin tt > 0 \\<or> cos tt=-1 ) \\<and> f tt > 0 \\<or> (sin tt < 0 \\<or>  cos tt=1 ) \\<and> f tt < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n    (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n    (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "have \"sin tt = 0 \\<longleftrightarrow> cos tt=-1 \\<or> cos tt=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sin tt = 0) = (cos tt = - 1 \\<or> cos tt = 1)", "by (metis (no_types, hide_lams) add.right_neutral cancel_comm_monoid_add_class.diff_cancel \n            cos_diff cos_zero mult_eq_0_iff power2_eq_1_iff power2_eq_square sin_squared_eq)"], ["proof (state)\nthis:\n  (sin tt = 0) = (cos tt = - 1 \\<or> cos tt = 1)\n\ngoal (1 subgoal):\n 1. (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n    (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "moreover"], ["proof (state)\nthis:\n  (sin tt = 0) = (cos tt = - 1 \\<or> cos tt = 1)\n\ngoal (1 subgoal):\n 1. (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n    (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "have \"((sin tt \\<le> 0 \\<and> cos tt \\<noteq>-1 ) \\<or> f tt > 0) \\<and> ((sin tt \\<ge> 0 \\<and>  cos tt\\<noteq>1) \\<or> f tt < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sin tt \\<le> 0 \\<and> cos tt \\<noteq> - 1 \\<or> 0 < f tt) \\<and>\n    (0 \\<le> sin tt \\<and> cos tt \\<noteq> 1 \\<or> f tt < 0)", "using that(2) \\<open>f tt\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n          (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt)\n  f tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sin tt \\<le> 0 \\<and> cos tt \\<noteq> - 1 \\<or> 0 < f tt) \\<and>\n    (0 \\<le> sin tt \\<and> cos tt \\<noteq> 1 \\<or> f tt < 0)", "by argo"], ["proof (state)\nthis:\n  (sin tt \\<le> 0 \\<and> cos tt \\<noteq> - 1 \\<or> 0 < f tt) \\<and>\n  (0 \\<le> sin tt \\<and> cos tt \\<noteq> 1 \\<or> f tt < 0)\n\ngoal (1 subgoal):\n 1. (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n    (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "ultimately"], ["proof (chain)\npicking this:\n  (sin tt = 0) = (cos tt = - 1 \\<or> cos tt = 1)\n  (sin tt \\<le> 0 \\<and> cos tt \\<noteq> - 1 \\<or> 0 < f tt) \\<and>\n  (0 \\<le> sin tt \\<and> cos tt \\<noteq> 1 \\<or> f tt < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (sin tt = 0) = (cos tt = - 1 \\<or> cos tt = 1)\n  (sin tt \\<le> 0 \\<and> cos tt \\<noteq> - 1 \\<or> 0 < f tt) \\<and>\n  (0 \\<le> sin tt \\<and> cos tt \\<noteq> 1 \\<or> f tt < 0)\n\ngoal (1 subgoal):\n 1. (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n    (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "by (meson linorder_neqE_linordered_idom not_le)"], ["proof (state)\nthis:\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0", "have \"(g has_sgnx sgn (f tt)) (at_left tt)\""], ["proof (prove)\nusing this:\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f tt)) (at_left tt)", "using g_has_sgnx1[OF \\<open>g tt=0\\<close>] g_has_sgnx2[OF \\<open>g tt=0\\<close>]"], ["proof (prove)\nusing this:\n  (0 < sin tt \\<or> cos tt = - 1) \\<and> 0 < f tt \\<or>\n  (sin tt < 0 \\<or> cos tt = 1) \\<and> f tt < 0\n  sin tt < 0 \\<or> cos tt = 1 \\<Longrightarrow>\n  (g has_sgnx - 1) (at_left tt)\n  0 < sin tt \\<or> cos tt = - 1 \\<Longrightarrow>\n  (g has_sgnx 1) (at_left tt)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (f tt)) (at_left tt)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (f tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (f tt)) (at_left tt)", "have \"LIM x at_left tt. f x / g x :> at_top\""], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (f tt)) (at_left tt)\n\ngoal (1 subgoal):\n 1. LIM x at_left tt. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of f \"f tt\" \"at_left tt\" g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_sgnx sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f tt) (at_left tt)\n 2. (g has_sgnx sgn (f tt)) (at_left tt) \\<Longrightarrow> f tt \\<noteq> 0\n 3. (g has_sgnx sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_left tt) \\<and>\n    (g has_sgnx sgn (f tt)) (at_left tt)", "using \\<open>f tt\\<noteq>0\\<close> \\<open>g tt = 0\\<close> g_cont f_cont"], ["proof (prove)\nusing this:\n  f tt \\<noteq> 0\n  g tt = 0\n  continuous (at_left tt) g\n  continuous (at_left tt) f\n\ngoal (3 subgoals):\n 1. (g has_sgnx sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (f \\<longlongrightarrow> f tt) (at_left tt)\n 2. (g has_sgnx sgn (f tt)) (at_left tt) \\<Longrightarrow> f tt \\<noteq> 0\n 3. (g has_sgnx sgn (f tt)) (at_left tt) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_left tt) \\<and>\n    (g has_sgnx sgn (f tt)) (at_left tt)", "by (auto simp add: continuous_within)"], ["proof (state)\nthis:\n  LIM x at_left tt. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left tt. f x / g x :> at_top", "have \"jumpF (\\<lambda>i. f i/g i) (at_left tt) = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left tt. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>i. f i / g i) (at_left tt) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left tt. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM i at_left tt. f i / g i :> at_top then 1 / 2\n     else if LIM i at_left tt. f i / g i :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "using jumpF_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. f i / g i) (at_left tt) = 1 / 2\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. f i / g i) (at_left tt)\n  r * cos tt + Re z - Re z0 = 0\n  \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n          (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "unfolding f_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_left tt) = 1 / 2\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  jumpF (\\<lambda>i. (r * sin i + Im z - Im z0) / g i) (at_left tt)\n  r * cos tt + Re z - Re z0 = 0\n  \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and>\n          r * sin tt + Im z - Im z0 < 0 \\<or>\n          (sin tt < 0 \\<or> cos tt = 1) \\<and>\n          0 < r * sin tt + Im z - Im z0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n           (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  r * cos tt + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n   (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n           (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  r * cos tt + Re z - Re z0 \\<noteq> 0 \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   (0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n   (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)\n  \\<lbrakk>r * cos tt + Re z - Re z0 = 0;\n   \\<not> ((0 < sin tt \\<or> cos tt = - 1) \\<and> f tt < 0 \\<or>\n           (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < f tt)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (part_circlepath z r st tt) z0 =\n                    (if r * cos tt + Re z - Re z0 = 0\n                     then let \\<Delta> = r * sin tt + Im z - Im z0\n                          in if (0 < sin tt \\<or> cos tt = - 1) \\<and>\n                                \\<Delta> < 0 \\<or>\n                                (sin tt < 0 \\<or> cos tt = 1) \\<and>\n                                0 < \\<Delta>\n                             then - 1 / 2 else 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r st tt) z0 =\n    (if r * cos tt + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin tt + Im z - Im z0\n          in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0)", "by fast"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r st tt) z0 =\n  (if r * cos tt + Re z - Re z0 = 0\n   then let \\<Delta> = r * sin tt + Im z - Im z0\n        in if (0 < sin tt \\<or> cos tt = - 1) \\<and> \\<Delta> < 0 \\<or>\n              (sin tt < 0 \\<or> cos tt = 1) \\<and> 0 < \\<Delta>\n           then - 1 / 2 else 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  fixes z0 z::complex and r::real\n  defines \"upper \\<equiv> cindex_pathE (part_circlepath z r 0 pi) z0\"\n      and \"lower \\<equiv> cindex_pathE (part_circlepath z r pi (2*pi)) z0\"\n  shows cindex_pathE_circlepath_upper:\n      \"\\<lbrakk>cmod (z0-z) < r\\<rbrakk>  \\<Longrightarrow> upper = -1\" \n      \"\\<lbrakk>Im (z0-z) > r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> upper = 1\"\n      \"\\<lbrakk>Im (z0-z) < -r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> upper = -1\" \n      \"\\<lbrakk>\\<bar>Re (z0 - z)\\<bar> > r; r>0\\<rbrakk> \\<Longrightarrow> upper = 0\"\n  and cindex_pathE_circlepath_lower: \n      \"\\<lbrakk>cmod (z0-z) < r\\<rbrakk> \\<Longrightarrow> lower = -1\" \n      \"\\<lbrakk>Im (z0-z) > r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> lower = -1\"\n      \"\\<lbrakk>Im (z0-z) < -r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk> \\<Longrightarrow> lower = 1\"\n      \"\\<lbrakk>\\<bar>Re (z0 - z)\\<bar> > r; r>0\\<rbrakk> \\<Longrightarrow> lower = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((cmod (z0 - z) < r \\<Longrightarrow> upper = - 1) &&&\n      (\\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n       \\<Longrightarrow> upper = 1)) &&&\n     (\\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n      \\<Longrightarrow> upper = - 1) &&&\n     (\\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n      \\<Longrightarrow> upper = 0)) &&&\n    ((cmod (z0 - z) < r \\<Longrightarrow> lower = - 1) &&&\n     (\\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n      \\<Longrightarrow> lower = - 1)) &&&\n    (\\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n     \\<Longrightarrow> lower = 1) &&&\n    (\\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n     \\<Longrightarrow> lower = 0)", "proof -"], ["proof (state)\ngoal (8 subgoals):\n 1. cmod (z0 - z) < r \\<Longrightarrow> upper = - 1\n 2. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 3. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 5. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 7. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 8. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "assume assms:\"cmod (z0-z) < r\""], ["proof (state)\nthis:\n  cmod (z0 - z) < r\n\ngoal (8 subgoals):\n 1. cmod (z0 - z) < r \\<Longrightarrow> upper = - 1\n 2. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 3. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 5. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 7. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 8. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "have zz_facts:\"-r<Re z - Re z0\" \"Re z - Re z0<r\" \"r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r < Re z - Re z0 &&& Re z - Re z0 < r &&& 0 < r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. - r < Re z - Re z0", "using assms complex_Re_le_cmod le_less_trans"], ["proof (prove)\nusing this:\n  cmod (z0 - z) < r\n  Re ?x \\<le> cmod ?x\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. - r < Re z - Re z0", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re z - Re z0 < r\n 2. 0 < r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re z - Re z0 < r", "by (metis assms complex_Re_le_cmod le_less_trans minus_complex.simps(1) norm_minus_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r", "using assms le_less_trans norm_ge_zero"], ["proof (prove)\nusing this:\n  cmod (z0 - z) < r\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  0 \\<le> norm ?x\n\ngoal (1 subgoal):\n 1. 0 < r", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n\ngoal (8 subgoals):\n 1. cmod (z0 - z) < r \\<Longrightarrow> upper = - 1\n 2. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 3. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 5. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 7. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 8. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "define \\<theta> where \"\\<theta> = arccos ((Re z0 - Re z) / r)\""], ["proof (state)\nthis:\n  \\<theta> = arccos ((Re z0 - Re z) / r)\n\ngoal (8 subgoals):\n 1. cmod (z0 - z) < r \\<Longrightarrow> upper = - 1\n 2. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 3. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 5. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 7. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 8. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "have \\<theta>_bound:\"0 < \\<theta> \\<and> \\<theta> < pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<theta> \\<and> \\<theta> < pi", "unfolding \\<theta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < arccos ((Re z0 - Re z) / r) \\<and> arccos ((Re z0 - Re z) / r) < pi", "apply (rule arccos_lt_bounded)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - 1 < (Re z0 - Re z) / r\n 2. (Re z0 - Re z) / r < 1", "using zz_facts"], ["proof (prove)\nusing this:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n\ngoal (2 subgoals):\n 1. - 1 < (Re z0 - Re z) / r\n 2. (Re z0 - Re z) / r < 1", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 < \\<theta> \\<and> \\<theta> < pi\n\ngoal (8 subgoals):\n 1. cmod (z0 - z) < r \\<Longrightarrow> upper = - 1\n 2. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 3. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 5. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 7. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 8. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "have Im_sin:\"abs (Im z0 - Im z) < r * sin \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "define zz where \"zz=z0-z\""], ["proof (state)\nthis:\n  zz = z0 - z\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "have \"sqrt ((Re zz)\\<^sup>2 + (Im zz)\\<^sup>2) < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt ((Re zz)\\<^sup>2 + (Im zz)\\<^sup>2) < r", "using assms"], ["proof (prove)\nusing this:\n  cmod (z0 - z) < r\n\ngoal (1 subgoal):\n 1. sqrt ((Re zz)\\<^sup>2 + (Im zz)\\<^sup>2) < r", "unfolding zz_def cmod_def"], ["proof (prove)\nusing this:\n  sqrt ((Re (z0 - z))\\<^sup>2 + (Im (z0 - z))\\<^sup>2) < r\n\ngoal (1 subgoal):\n 1. sqrt ((Re (z0 - z))\\<^sup>2 + (Im (z0 - z))\\<^sup>2) < r", "."], ["proof (state)\nthis:\n  sqrt ((Re zz)\\<^sup>2 + (Im zz)\\<^sup>2) < r\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "then"], ["proof (chain)\npicking this:\n  sqrt ((Re zz)\\<^sup>2 + (Im zz)\\<^sup>2) < r", "have \"(Re zz)\\<^sup>2 + (Im zz)\\<^sup>2 < r^2\""], ["proof (prove)\nusing this:\n  sqrt ((Re zz)\\<^sup>2 + (Im zz)\\<^sup>2) < r\n\ngoal (1 subgoal):\n 1. (Re zz)\\<^sup>2 + (Im zz)\\<^sup>2 < r\\<^sup>2", "by (metis cmod_power2 dvd_refl linorder_not_le norm_complex_def power2_le_imp_le\n            real_sqrt_power zero_le_power_eq_numeral)"], ["proof (state)\nthis:\n  (Re zz)\\<^sup>2 + (Im zz)\\<^sup>2 < r\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "then"], ["proof (chain)\npicking this:\n  (Re zz)\\<^sup>2 + (Im zz)\\<^sup>2 < r\\<^sup>2", "have \"(Im zz)\\<^sup>2 < r^2 - (Re zz)^2\""], ["proof (prove)\nusing this:\n  (Re zz)\\<^sup>2 + (Im zz)\\<^sup>2 < r\\<^sup>2\n\ngoal (1 subgoal):\n 1. (Im zz)\\<^sup>2 < r\\<^sup>2 - (Re zz)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (Im zz)\\<^sup>2 < r\\<^sup>2 - (Re zz)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "then"], ["proof (chain)\npicking this:\n  (Im zz)\\<^sup>2 < r\\<^sup>2 - (Re zz)\\<^sup>2", "have \"abs (Im zz) < sqrt (r^2 - (Re zz)^2)\""], ["proof (prove)\nusing this:\n  (Im zz)\\<^sup>2 < r\\<^sup>2 - (Re zz)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>Im zz\\<bar> < sqrt (r\\<^sup>2 - (Re zz)\\<^sup>2)", "by (simp add: real_less_rsqrt)"], ["proof (state)\nthis:\n  \\<bar>Im zz\\<bar> < sqrt (r\\<^sup>2 - (Re zz)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "then"], ["proof (chain)\npicking this:\n  \\<bar>Im zz\\<bar> < sqrt (r\\<^sup>2 - (Re zz)\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>Im zz\\<bar> < sqrt (r\\<^sup>2 - (Re zz)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>", "unfolding \\<theta>_def zz_def"], ["proof (prove)\nusing this:\n  \\<bar>Im (z0 - z)\\<bar> < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>Im z0 - Im z\\<bar> < r * sin (arccos ((Re z0 - Re z) / r))", "apply (subst sin_arccos_abs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1\n 2. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>Im z0 - Im z\\<bar> < r * sqrt (1 - ((Re z0 - Re z) / r)\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1", "using zz_facts"], ["proof (prove)\nusing this:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>(Re z0 - Re z) / r\\<bar> \\<le> 1", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>Im z0 - Im z\\<bar> < r * sqrt (1 - ((Re z0 - Re z) / r)\\<^sup>2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>Im z0 - Im z\\<bar> < r * sqrt (1 - ((Re z0 - Re z) / r)\\<^sup>2)", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<bar>Im (z0 - z)\\<bar>\n    < sqrt (r\\<^sup>2 - (Re (z0 - z))\\<^sup>2) \\<Longrightarrow>\n    \\<bar>Im z0 - Im z\\<bar> < r * sqrt (1 - ((Re z0 - Re z) / r)\\<^sup>2)", "by (auto simp add:field_simps divide_simps real_sqrt_divide)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\n\ngoal (8 subgoals):\n 1. cmod (z0 - z) < r \\<Longrightarrow> upper = - 1\n 2. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 3. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 5. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 7. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 8. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "show \"upper = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper = - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upper = - 1", "have \"jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0", "apply (subst jumpF_pathstart_part_circlepath)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos 0 + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin 0 + Im z - Im z0\n          in if (0 < sin 0 \\<or> cos 0 = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin 0 < 0 \\<or> cos 0 = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0) =\n    0", "using zz_facts assms"], ["proof (prove)\nusing this:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  cmod (z0 - z) < r\n\ngoal (4 subgoals):\n 1. 0 < pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos 0 + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin 0 + Im z - Im z0\n          in if (0 < sin 0 \\<or> cos 0 = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin 0 < 0 \\<or> cos 0 = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0) =\n    0", "by (auto simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n\ngoal (1 subgoal):\n 1. upper = - 1", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n\ngoal (1 subgoal):\n 1. upper = - 1", "have \"jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0", "apply (subst jumpF_pathfinish_part_circlepath)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos pi + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin pi + Im z - Im z0\n          in if (0 < sin pi \\<or> cos pi = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin pi < 0 \\<or> cos pi = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0) =\n    0", "using zz_facts assms"], ["proof (prove)\nusing this:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  cmod (z0 - z) < r\n\ngoal (4 subgoals):\n 1. 0 < pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos pi + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin pi + Im z - Im z0\n          in if (0 < sin pi \\<or> cos pi = - 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin pi < 0 \\<or> cos pi = 1) \\<and> 0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0) =\n    0", "by (auto simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n\ngoal (1 subgoal):\n 1. upper = - 1", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n\ngoal (1 subgoal):\n 1. upper = - 1", "using assms zz_facts \\<theta>_bound Im_sin"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) < r\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  0 < \\<theta> \\<and> \\<theta> < pi\n  \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. upper = - 1", "unfolding upper_def"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) < r\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  0 < \\<theta> \\<and> \\<theta> < pi\n  \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r 0 pi) z0 = - 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0; cmod (z0 - z) < r;\n     - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0; cmod (z0 - z) < r;\n     - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0; cmod (z0 - z) < r;\n     - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 0\n 4. \\<lbrakk>jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0; cmod (z0 - z) < r;\n     - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> 0 < pi\n 5. \\<lbrakk>jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0; cmod (z0 - z) < r;\n     - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> pi \\<le> 2 * pi\n 6. \\<lbrakk>jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0; cmod (z0 - z) < r;\n     - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart (part_circlepath z r 0 pi)\n                                z0 +\n                               (if 0 < \\<theta> \\<and> \\<theta> < pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if 0 < \\<beta> \\<and> \\<beta> < pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish (part_circlepath z r 0 pi)\n                                z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart (part_circlepath z r 0 pi)\n                                  z0 -\n                                 jumpF_pathfinish (part_circlepath z r 0 pi)\n                                  z0\n                            else 0) =\n                      - 1", "by (fold \\<theta>_def,auto simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  upper = - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upper = - 1\n\ngoal (7 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 4. cmod (z0 - z) < r \\<Longrightarrow> lower = - 1\n 5. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 6. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 7. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "show \"lower = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower = - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lower = - 1", "have \"jumpF_pathstart (part_circlepath z r pi (2*pi)) z0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0", "apply (subst jumpF_pathstart_part_circlepath)"], ["proof (prove)\ngoal (4 subgoals):\n 1. pi < 2 * pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos pi + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin pi + Im z - Im z0\n          in if (0 < sin pi \\<or> cos pi = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin pi < 0 \\<or> cos pi = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0) =\n    0", "using zz_facts assms"], ["proof (prove)\nusing this:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  cmod (z0 - z) < r\n\ngoal (4 subgoals):\n 1. pi < 2 * pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos pi + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin pi + Im z - Im z0\n          in if (0 < sin pi \\<or> cos pi = 1) \\<and> \\<Delta> < 0 \\<or>\n                (sin pi < 0 \\<or> cos pi = - 1) \\<and> 0 < \\<Delta>\n             then 1 / 2 else - 1 / 2\n     else 0) =\n    0", "by (auto simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n\ngoal (1 subgoal):\n 1. lower = - 1", "moreover"], ["proof (state)\nthis:\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n\ngoal (1 subgoal):\n 1. lower = - 1", "have \"jumpF_pathfinish (part_circlepath z r pi (2*pi)) z0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "apply (subst jumpF_pathfinish_part_circlepath)"], ["proof (prove)\ngoal (4 subgoals):\n 1. pi < 2 * pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos (2 * pi) + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin (2 * pi) + Im z - Im z0\n          in if (0 < sin (2 * pi) \\<or> cos (2 * pi) = - 1) \\<and>\n                \\<Delta> < 0 \\<or>\n                (sin (2 * pi) < 0 \\<or> cos (2 * pi) = 1) \\<and>\n                0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0) =\n    0", "using zz_facts assms"], ["proof (prove)\nusing this:\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  cmod (z0 - z) < r\n\ngoal (4 subgoals):\n 1. pi < 2 * pi\n 2. 0 < r\n 3. cmod (z - z0) \\<noteq> r\n 4. (if r * cos (2 * pi) + Re z - Re z0 = 0\n     then let \\<Delta> = r * sin (2 * pi) + Im z - Im z0\n          in if (0 < sin (2 * pi) \\<or> cos (2 * pi) = - 1) \\<and>\n                \\<Delta> < 0 \\<or>\n                (sin (2 * pi) < 0 \\<or> cos (2 * pi) = 1) \\<and>\n                0 < \\<Delta>\n             then - 1 / 2 else 1 / 2\n     else 0) =\n    0", "by (auto simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n\ngoal (1 subgoal):\n 1. lower = - 1", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n\ngoal (1 subgoal):\n 1. lower = - 1", "using assms zz_facts \\<theta>_bound Im_sin"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) < r\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  0 < \\<theta> \\<and> \\<theta> < pi\n  \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. lower = - 1", "unfolding lower_def"], ["proof (prove)\nusing this:\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) < r\n  - r < Re z - Re z0\n  Re z - Re z0 < r\n  0 < r\n  0 < \\<theta> \\<and> \\<theta> < pi\n  \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r pi (2 * pi)) z0 = - 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) < r; - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) < r; - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) < r; - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> pi\n 4. \\<lbrakk>jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) < r; - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> pi < 2 * pi\n 5. \\<lbrakk>jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) < r; - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> 2 * pi \\<le> 2 * pi\n 6. \\<lbrakk>jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) < r; - r < Re z - Re z0; Re z - Re z0 < r; 0 < r;\n     0 < \\<theta> \\<and> \\<theta> < pi;\n     \\<bar>Im z0 - Im z\\<bar> < r * sin \\<theta>\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart\n                                (part_circlepath z r pi (2 * pi)) z0 +\n                               (if pi < \\<theta> \\<and> \\<theta> < 2 * pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if pi < \\<beta> \\<and> \\<beta> < 2 * pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish\n                                (part_circlepath z r pi (2 * pi)) z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart\n                                  (part_circlepath z r pi (2 * pi)) z0 -\n                                 jumpF_pathfinish\n                                  (part_circlepath z r pi (2 * pi)) z0\n                            else 0) =\n                      - 1", "by (fold \\<theta>_def,auto simp add: norm_minus_commute)"], ["proof (state)\nthis:\n  lower = - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lower = - 1\n\ngoal (6 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 4. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 5. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 6. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 4. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 5. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 6. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "assume assms:\"\\<bar>Re (z0 - z)\\<bar> > r\" \"r>0\""], ["proof (state)\nthis:\n  r < \\<bar>Re (z0 - z)\\<bar>\n  0 < r\n\ngoal (6 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> upper = 0\n 4. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 5. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 6. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "show \"upper = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper = 0", "using assms"], ["proof (prove)\nusing this:\n  r < \\<bar>Re (z0 - z)\\<bar>\n  0 < r\n\ngoal (1 subgoal):\n 1. upper = 0", "unfolding upper_def"], ["proof (prove)\nusing this:\n  r < \\<bar>Re (z0 - z)\\<bar>\n  0 < r\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r 0 pi) z0 = 0", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 0\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> 0 < pi\n 5. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> pi \\<le> 2 * pi\n 6. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart (part_circlepath z r 0 pi)\n                                z0 +\n                               (if 0 < \\<theta> \\<and> \\<theta> < pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if 0 < \\<beta> \\<and> \\<beta> < pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish (part_circlepath z r 0 pi)\n                                z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart (part_circlepath z r 0 pi)\n                                  z0 -\n                                 jumpF_pathfinish (part_circlepath z r 0 pi)\n                                  z0\n                            else 0) =\n                      0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod (z - z0) < \\<bar>Re z0 - Re z\\<bar>; z \\<noteq> z0;\n     r = cmod (z - z0)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis abs_Re_le_cmod abs_minus_commute eucl_less_le_not_le minus_complex.simps(1))"], ["proof (state)\nthis:\n  upper = 0\n\ngoal (5 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1\n 5. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> lower = 0", "show \"lower = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower = 0", "using assms"], ["proof (prove)\nusing this:\n  r < \\<bar>Re (z0 - z)\\<bar>\n  0 < r\n\ngoal (1 subgoal):\n 1. lower = 0", "unfolding lower_def"], ["proof (prove)\nusing this:\n  r < \\<bar>Re (z0 - z)\\<bar>\n  0 < r\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r pi (2 * pi)) z0 = 0", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> pi\n 4. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> pi < 2 * pi\n 5. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> 2 * pi \\<le> 2 * pi\n 6. \\<lbrakk>r < \\<bar>Re (z0 - z)\\<bar>; 0 < r\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart\n                                (part_circlepath z r pi (2 * pi)) z0 +\n                               (if pi < \\<theta> \\<and> \\<theta> < 2 * pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if pi < \\<beta> \\<and> \\<beta> < 2 * pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish\n                                (part_circlepath z r pi (2 * pi)) z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart\n                                  (part_circlepath z r pi (2 * pi)) z0 -\n                                 jumpF_pathfinish\n                                  (part_circlepath z r pi (2 * pi)) z0\n                            else 0) =\n                      0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod (z - z0) < \\<bar>Re z0 - Re z\\<bar>; z \\<noteq> z0;\n     r = cmod (z - z0)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis abs_Re_le_cmod abs_minus_commute eucl_less_le_not_le minus_complex.simps(1))"], ["proof (state)\nthis:\n  lower = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "assume assms:\"\\<bar>Re (z0 - z)\\<bar> < r\""], ["proof (state)\nthis:\n  \\<bar>Re (z0 - z)\\<bar> < r\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "then"], ["proof (chain)\npicking this:\n  \\<bar>Re (z0 - z)\\<bar> < r", "have \"r>0\""], ["proof (prove)\nusing this:\n  \\<bar>Re (z0 - z)\\<bar> < r\n\ngoal (1 subgoal):\n 1. 0 < r", "by auto"], ["proof (state)\nthis:\n  0 < r\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "define \\<theta> where \"\\<theta> = arccos ((Re z0 - Re z) / r)\""], ["proof (state)\nthis:\n  \\<theta> = arccos ((Re z0 - Re z) / r)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "have \\<theta>_bound:\"0 < \\<theta> \\<and> \\<theta> < pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<theta> \\<and> \\<theta> < pi", "unfolding \\<theta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < arccos ((Re z0 - Re z) / r) \\<and> arccos ((Re z0 - Re z) / r) < pi", "apply (rule arccos_lt_bounded)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - 1 < (Re z0 - Re z) / r\n 2. (Re z0 - Re z) / r < 1", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>Re (z0 - z)\\<bar> < r\n\ngoal (2 subgoals):\n 1. - 1 < (Re z0 - Re z) / r\n 2. (Re z0 - Re z) / r < 1", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 < \\<theta> \\<and> \\<theta> < pi\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "note norm_minus_commute[simp]"], ["proof (state)\nthis:\n  norm (?a - ?b) = norm (?b - ?a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "have jumpFs:\n      \"jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\"\n      \"jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\"\n      \"jumpF_pathstart (part_circlepath z r pi (2*pi)) z0 = 0\"\n      \"jumpF_pathfinish (part_circlepath z r pi (2*pi)) z0 = 0\"\n      when \"cmod (z0 - z) \\<noteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0 &&&\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0) &&&\n    jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0 &&&\n    jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0", "by (subst jumpF_pathstart_part_circlepath,use assms that in auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n 2. jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n 3. jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0", "by (subst jumpF_pathfinish_part_circlepath,use assms that in auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n 2. jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0", "by (subst jumpF_pathstart_part_circlepath,use assms that in auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0", "by (subst jumpF_pathfinish_part_circlepath,use assms that in auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = 1\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = - 1\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "show \"upper = 1\" \"lower = -1\" when \"Im (z0-z) > r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper = 1 &&& lower = - 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. upper = 1\n 2. lower = - 1", "have \"cmod (z0 - z) \\<noteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (z0 - z) \\<noteq> r", "using that assms abs_Im_le_cmod abs_le_D1 not_le"], ["proof (prove)\nusing this:\n  r < Im (z0 - z)\n  \\<bar>Re (z0 - z)\\<bar> < r\n  \\<bar>Im ?x\\<bar> \\<le> cmod ?x\n  \\<bar>?a\\<bar> \\<le> ?b \\<Longrightarrow> ?a \\<le> ?b\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. cmod (z0 - z) \\<noteq> r", "by blast"], ["proof (state)\nthis:\n  cmod (z0 - z) \\<noteq> r\n\ngoal (2 subgoals):\n 1. upper = 1\n 2. lower = - 1", "moreover"], ["proof (state)\nthis:\n  cmod (z0 - z) \\<noteq> r\n\ngoal (2 subgoals):\n 1. upper = 1\n 2. lower = - 1", "have \"Im z0 - Im z > r * sin \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z0 - Im z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z0 - Im z", "have \"r * sin \\<theta> \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * sin \\<theta> \\<le> r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> \\<le> r", "by auto"], ["proof (state)\nthis:\n  r * sin \\<theta> \\<le> r\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z0 - Im z", "also"], ["proof (state)\nthis:\n  r * sin \\<theta> \\<le> r\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z0 - Im z", "have \"... < Im z0 - Im z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < Im z0 - Im z", "using that"], ["proof (prove)\nusing this:\n  r < Im (z0 - z)\n\ngoal (1 subgoal):\n 1. r < Im z0 - Im z", "by auto"], ["proof (state)\nthis:\n  r < Im z0 - Im z\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z0 - Im z", "finally"], ["proof (chain)\npicking this:\n  r * sin \\<theta> < Im z0 - Im z", "show ?thesis"], ["proof (prove)\nusing this:\n  r * sin \\<theta> < Im z0 - Im z\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z0 - Im z", "."], ["proof (state)\nthis:\n  r * sin \\<theta> < Im z0 - Im z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r * sin \\<theta> < Im z0 - Im z\n\ngoal (2 subgoals):\n 1. upper = 1\n 2. lower = - 1", "ultimately"], ["proof (chain)\npicking this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z0 - Im z", "show \"upper = 1\""], ["proof (prove)\nusing this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z0 - Im z\n\ngoal (1 subgoal):\n 1. upper = 1", "using assms jumpFs \\<theta>_bound that"], ["proof (prove)\nusing this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z0 - Im z\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  r < Im (z0 - z)\n\ngoal (1 subgoal):\n 1. upper = 1", "unfolding upper_def"], ["proof (prove)\nusing this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z0 - Im z\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  r < Im (z0 - z)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r 0 pi) z0 = 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z0 - Im z;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z0 - Im z;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z0 - Im z;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 0\n 4. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z0 - Im z;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> 0 < pi\n 5. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z0 - Im z;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> pi \\<le> 2 * pi\n 6. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z0 - Im z;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart (part_circlepath z r 0 pi)\n                                z0 +\n                               (if 0 < \\<theta> \\<and> \\<theta> < pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if 0 < \\<beta> \\<and> \\<beta> < pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish (part_circlepath z r 0 pi)\n                                z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart (part_circlepath z r 0 pi)\n                                  z0 -\n                                 jumpF_pathfinish (part_circlepath z r 0 pi)\n                                  z0\n                            else 0) =\n                      1", "by (fold \\<theta>_def,auto)"], ["proof (state)\nthis:\n  upper = 1\n\ngoal (1 subgoal):\n 1. lower = - 1", "have \"Im z - Im z0 < r * sin \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z - Im z0 < r * sin \\<theta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im z - Im z0 < r * sin \\<theta>", "have \"Im z - Im z0  <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z - Im z0 < 0", "using that \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  r < Im (z0 - z)\n  0 < r\n\ngoal (1 subgoal):\n 1. Im z - Im z0 < 0", "by auto"], ["proof (state)\nthis:\n  Im z - Im z0 < 0\n\ngoal (1 subgoal):\n 1. Im z - Im z0 < r * sin \\<theta>", "moreover"], ["proof (state)\nthis:\n  Im z - Im z0 < 0\n\ngoal (1 subgoal):\n 1. Im z - Im z0 < r * sin \\<theta>", "have \"r * sin \\<theta>>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r * sin \\<theta>", "using \\<open>r>0\\<close> \\<theta>_bound"], ["proof (prove)\nusing this:\n  0 < r\n  0 < \\<theta> \\<and> \\<theta> < pi\n\ngoal (1 subgoal):\n 1. 0 < r * sin \\<theta>", "by (simp add: sin_gt_zero)"], ["proof (state)\nthis:\n  0 < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. Im z - Im z0 < r * sin \\<theta>", "ultimately"], ["proof (chain)\npicking this:\n  Im z - Im z0 < 0\n  0 < r * sin \\<theta>", "show ?thesis"], ["proof (prove)\nusing this:\n  Im z - Im z0 < 0\n  0 < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. Im z - Im z0 < r * sin \\<theta>", "by auto"], ["proof (state)\nthis:\n  Im z - Im z0 < r * sin \\<theta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im z - Im z0 < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. lower = - 1", "then"], ["proof (chain)\npicking this:\n  Im z - Im z0 < r * sin \\<theta>", "show \"lower = -1\""], ["proof (prove)\nusing this:\n  Im z - Im z0 < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. lower = - 1", "using \\<open>cmod (z0 - z) \\<noteq> r\\<close> \\<open>Im z0 - Im z > r * sin \\<theta>\\<close> \n        assms jumpFs \\<theta>_bound that"], ["proof (prove)\nusing this:\n  Im z - Im z0 < r * sin \\<theta>\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z0 - Im z\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  r < Im (z0 - z)\n\ngoal (1 subgoal):\n 1. lower = - 1", "unfolding lower_def"], ["proof (prove)\nusing this:\n  Im z - Im z0 < r * sin \\<theta>\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z0 - Im z\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  r < Im (z0 - z)\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r pi (2 * pi)) z0 = - 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>Im z - Im z0 < r * sin \\<theta>; cmod (z0 - z) \\<noteq> r;\n     r * sin \\<theta> < Im z0 - Im z; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>Im z - Im z0 < r * sin \\<theta>; cmod (z0 - z) \\<noteq> r;\n     r * sin \\<theta> < Im z0 - Im z; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>Im z - Im z0 < r * sin \\<theta>; cmod (z0 - z) \\<noteq> r;\n     r * sin \\<theta> < Im z0 - Im z; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> pi\n 4. \\<lbrakk>Im z - Im z0 < r * sin \\<theta>; cmod (z0 - z) \\<noteq> r;\n     r * sin \\<theta> < Im z0 - Im z; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> pi < 2 * pi\n 5. \\<lbrakk>Im z - Im z0 < r * sin \\<theta>; cmod (z0 - z) \\<noteq> r;\n     r * sin \\<theta> < Im z0 - Im z; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> 2 * pi \\<le> 2 * pi\n 6. \\<lbrakk>Im z - Im z0 < r * sin \\<theta>; cmod (z0 - z) \\<noteq> r;\n     r * sin \\<theta> < Im z0 - Im z; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; r < Im (z0 - z)\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart\n                                (part_circlepath z r pi (2 * pi)) z0 +\n                               (if pi < \\<theta> \\<and> \\<theta> < 2 * pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if pi < \\<beta> \\<and> \\<beta> < 2 * pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish\n                                (part_circlepath z r pi (2 * pi)) z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart\n                                  (part_circlepath z r pi (2 * pi)) z0 -\n                                 jumpF_pathfinish\n                                  (part_circlepath z r pi (2 * pi)) z0\n                            else 0) =\n                      - 1", "by (fold \\<theta>_def,auto)"], ["proof (state)\nthis:\n  lower = - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r < Im (z0 - z) \\<Longrightarrow> upper = 1\n  r < Im (z0 - z) \\<Longrightarrow> lower = - 1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> r < Im (z0 - z)\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> upper = - 1\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> r < Im (z0 - z)\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> lower = 1", "show \"upper = - 1\" \"lower = 1\" when \"Im (z0-z) < -r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper = - 1 &&& lower = 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. upper = - 1\n 2. lower = 1", "have \"cmod (z0 - z) \\<noteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (z0 - z) \\<noteq> r", "using that assms"], ["proof (prove)\nusing this:\n  Im (z0 - z) < - r\n  \\<bar>Re (z0 - z)\\<bar> < r\n\ngoal (1 subgoal):\n 1. cmod (z0 - z) \\<noteq> r", "by (metis abs_Im_le_cmod abs_le_D1 minus_complex.simps(2) minus_diff_eq neg_less_iff_less \n          norm_minus_cancel not_le)"], ["proof (state)\nthis:\n  cmod (z0 - z) \\<noteq> r\n\ngoal (2 subgoals):\n 1. upper = - 1\n 2. lower = 1", "moreover"], ["proof (state)\nthis:\n  cmod (z0 - z) \\<noteq> r\n\ngoal (2 subgoals):\n 1. upper = - 1\n 2. lower = 1", "have \"Im z - Im z0 > r * sin \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z - Im z0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z - Im z0", "have \"r * sin \\<theta> \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * sin \\<theta> \\<le> r", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> \\<le> r", "by auto"], ["proof (state)\nthis:\n  r * sin \\<theta> \\<le> r\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z - Im z0", "also"], ["proof (state)\nthis:\n  r * sin \\<theta> \\<le> r\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z - Im z0", "have \"... < Im z - Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < Im z - Im z0", "using that"], ["proof (prove)\nusing this:\n  Im (z0 - z) < - r\n\ngoal (1 subgoal):\n 1. r < Im z - Im z0", "by auto"], ["proof (state)\nthis:\n  r < Im z - Im z0\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z - Im z0", "finally"], ["proof (chain)\npicking this:\n  r * sin \\<theta> < Im z - Im z0", "show ?thesis"], ["proof (prove)\nusing this:\n  r * sin \\<theta> < Im z - Im z0\n\ngoal (1 subgoal):\n 1. r * sin \\<theta> < Im z - Im z0", "."], ["proof (state)\nthis:\n  r * sin \\<theta> < Im z - Im z0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r * sin \\<theta> < Im z - Im z0\n\ngoal (2 subgoals):\n 1. upper = - 1\n 2. lower = 1", "moreover"], ["proof (state)\nthis:\n  r * sin \\<theta> < Im z - Im z0\n\ngoal (2 subgoals):\n 1. upper = - 1\n 2. lower = 1", "have \"Im z0 - Im z < r * sin \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z0 - Im z < r * sin \\<theta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im z0 - Im z < r * sin \\<theta>", "have \"Im z0 - Im z<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z0 - Im z < 0", "using that \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  Im (z0 - z) < - r\n  0 < r\n\ngoal (1 subgoal):\n 1. Im z0 - Im z < 0", "by auto"], ["proof (state)\nthis:\n  Im z0 - Im z < 0\n\ngoal (1 subgoal):\n 1. Im z0 - Im z < r * sin \\<theta>", "moreover"], ["proof (state)\nthis:\n  Im z0 - Im z < 0\n\ngoal (1 subgoal):\n 1. Im z0 - Im z < r * sin \\<theta>", "have \"r * sin \\<theta>>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r * sin \\<theta>", "using \\<open>r>0\\<close> \\<theta>_bound"], ["proof (prove)\nusing this:\n  0 < r\n  0 < \\<theta> \\<and> \\<theta> < pi\n\ngoal (1 subgoal):\n 1. 0 < r * sin \\<theta>", "by (simp add: sin_gt_zero)"], ["proof (state)\nthis:\n  0 < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. Im z0 - Im z < r * sin \\<theta>", "ultimately"], ["proof (chain)\npicking this:\n  Im z0 - Im z < 0\n  0 < r * sin \\<theta>", "show ?thesis"], ["proof (prove)\nusing this:\n  Im z0 - Im z < 0\n  0 < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. Im z0 - Im z < r * sin \\<theta>", "by auto"], ["proof (state)\nthis:\n  Im z0 - Im z < r * sin \\<theta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im z0 - Im z < r * sin \\<theta>\n\ngoal (2 subgoals):\n 1. upper = - 1\n 2. lower = 1", "ultimately"], ["proof (chain)\npicking this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z - Im z0\n  Im z0 - Im z < r * sin \\<theta>", "show \"upper = - 1\""], ["proof (prove)\nusing this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z - Im z0\n  Im z0 - Im z < r * sin \\<theta>\n\ngoal (1 subgoal):\n 1. upper = - 1", "using assms jumpFs \\<theta>_bound that"], ["proof (prove)\nusing this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z - Im z0\n  Im z0 - Im z < r * sin \\<theta>\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  Im (z0 - z) < - r\n\ngoal (1 subgoal):\n 1. upper = - 1", "unfolding upper_def"], ["proof (prove)\nusing this:\n  cmod (z0 - z) \\<noteq> r\n  r * sin \\<theta> < Im z - Im z0\n  Im z0 - Im z < r * sin \\<theta>\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  Im (z0 - z) < - r\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r 0 pi) z0 = - 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z - Im z0;\n     Im z0 - Im z < r * sin \\<theta>; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z - Im z0;\n     Im z0 - Im z < r * sin \\<theta>; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z - Im z0;\n     Im z0 - Im z < r * sin \\<theta>; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 0\n 4. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z - Im z0;\n     Im z0 - Im z < r * sin \\<theta>; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> 0 < pi\n 5. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z - Im z0;\n     Im z0 - Im z < r * sin \\<theta>; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> pi \\<le> 2 * pi\n 6. \\<lbrakk>cmod (z0 - z) \\<noteq> r; r * sin \\<theta> < Im z - Im z0;\n     Im z0 - Im z < r * sin \\<theta>; \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart (part_circlepath z r 0 pi)\n                                z0 +\n                               (if 0 < \\<theta> \\<and> \\<theta> < pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if 0 < \\<beta> \\<and> \\<beta> < pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish (part_circlepath z r 0 pi)\n                                z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart (part_circlepath z r 0 pi)\n                                  z0 -\n                                 jumpF_pathfinish (part_circlepath z r 0 pi)\n                                  z0\n                            else 0) =\n                      - 1", "by (fold \\<theta>_def,auto)"], ["proof (state)\nthis:\n  upper = - 1\n\ngoal (1 subgoal):\n 1. lower = 1", "show \"lower = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower = 1", "using \\<open>Im z0 - Im z < r * sin \\<theta>\\<close> \\<open>Im z - Im z0 > r * sin \\<theta>\\<close> \\<open>cmod (z0 - z) \\<noteq> r\\<close>\n        assms jumpFs \\<theta>_bound that"], ["proof (prove)\nusing this:\n  Im z0 - Im z < r * sin \\<theta>\n  r * sin \\<theta> < Im z - Im z0\n  cmod (z0 - z) \\<noteq> r\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  Im (z0 - z) < - r\n\ngoal (1 subgoal):\n 1. lower = 1", "unfolding lower_def"], ["proof (prove)\nusing this:\n  Im z0 - Im z < r * sin \\<theta>\n  r * sin \\<theta> < Im z - Im z0\n  cmod (z0 - z) \\<noteq> r\n  \\<bar>Re (z0 - z)\\<bar> < r\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0\n  cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n  jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0\n  0 < \\<theta> \\<and> \\<theta> < pi\n  Im (z0 - z) < - r\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath z r pi (2 * pi)) z0 = 1", "apply (subst cindex_pathE_part_circlepath)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>Im z0 - Im z < r * sin \\<theta>;\n     r * sin \\<theta> < Im z - Im z0; cmod (z0 - z) \\<noteq> r;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> cmod (z - z0) \\<noteq> r\n 2. \\<lbrakk>Im z0 - Im z < r * sin \\<theta>;\n     r * sin \\<theta> < Im z - Im z0; cmod (z0 - z) \\<noteq> r;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> 0 < r\n 3. \\<lbrakk>Im z0 - Im z < r * sin \\<theta>;\n     r * sin \\<theta> < Im z - Im z0; cmod (z0 - z) \\<noteq> r;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> pi\n 4. \\<lbrakk>Im z0 - Im z < r * sin \\<theta>;\n     r * sin \\<theta> < Im z - Im z0; cmod (z0 - z) \\<noteq> r;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> pi < 2 * pi\n 5. \\<lbrakk>Im z0 - Im z < r * sin \\<theta>;\n     r * sin \\<theta> < Im z - Im z0; cmod (z0 - z) \\<noteq> r;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> 2 * pi \\<le> 2 * pi\n 6. \\<lbrakk>Im z0 - Im z < r * sin \\<theta>;\n     r * sin \\<theta> < Im z - Im z0; cmod (z0 - z) \\<noteq> r;\n     \\<bar>Re (z0 - z)\\<bar> < r;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r 0 pi) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathstart (part_circlepath z r pi (2 * pi)) z0 = 0;\n     cmod (z0 - z) \\<noteq> r \\<Longrightarrow>\n     jumpF_pathfinish (part_circlepath z r pi (2 * pi)) z0 = 0;\n     0 < \\<theta> \\<and> \\<theta> < pi; Im (z0 - z) < - r\\<rbrakk>\n    \\<Longrightarrow> (if \\<bar>Re z - Re z0\\<bar> < r\n                       then let \\<theta> = arccos ((Re z0 - Re z) / r);\n                                \\<beta> = 2 * pi - \\<theta>\n                            in jumpF_pathstart\n                                (part_circlepath z r pi (2 * pi)) z0 +\n                               (if pi < \\<theta> \\<and> \\<theta> < 2 * pi\n                                then if Im z0 < r * sin \\<theta> + Im z\n                                     then - 1 else 1\n                                else 0) +\n                               (if pi < \\<beta> \\<and> \\<beta> < 2 * pi\n                                then if Im z0 < r * sin \\<beta> + Im z\n                                     then 1 else - 1\n                                else 0) -\n                               jumpF_pathfinish\n                                (part_circlepath z r pi (2 * pi)) z0\n                       else if \\<bar>Re z - Re z0\\<bar> = r\n                            then jumpF_pathstart\n                                  (part_circlepath z r pi (2 * pi)) z0 -\n                                 jumpF_pathfinish\n                                  (part_circlepath z r pi (2 * pi)) z0\n                            else 0) =\n                      1", "by (fold \\<theta>_def,auto)"], ["proof (state)\nthis:\n  lower = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (z0 - z) < - r \\<Longrightarrow> upper = - 1\n  Im (z0 - z) < - r \\<Longrightarrow> lower = 1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> r < Im (z0 - z)\n 2. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> Im (z0 - z) < - r\n 3. \\<lbrakk>r < Im (z0 - z); \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> r < Im (z0 - z)\n 4. \\<lbrakk>Im (z0 - z) < - r; \\<bar>Re (z0 - z)\\<bar> < r\\<rbrakk>\n    \\<Longrightarrow> Im (z0 - z) < - r", "qed"], ["", "lemma jumpF_pathstart_linepath:\n  \"jumpF_pathstart (linepath a b) z = \n    (if Re a = Re z \\<and> Im a\\<noteq>Im z \\<and> Re b \\<noteq> Re a then \n        if (Im a>Im z \\<and> Re b > Re a) \\<or> (Im a<Im z \\<and> Re b < Re a) then 1/2 else -1/2 \n     else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "define f where \"f=(\\<lambda>t. (Im b - Im a )* t + (Im a - Im z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. (Im b - Im a) * t + (Im a - Im z))\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "define g where \"g=(\\<lambda>t. (Re b - Re a )* t + (Re a - Re z))\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. (Re b - Re a) * t + (Re a - Re z))\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have jump_eq:\"jumpF_pathstart (linepath a b) z = jumpF (\\<lambda>t. f t/g t) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    jumpF (\\<lambda>t. f t / g t) (at_right 0)", "unfolding jumpF_pathstart_def f_def linepath_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) /\n         Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z))\n     (at_right 0) =\n    jumpF\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n     (at_right 0)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re a\\<noteq>Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"jumpF_pathstart (linepath a b) z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z = 0", "unfolding jumpF_pathstart_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_right 0) =\n    0", "apply (rule jumpF_im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. linepath a b t - z)\n 2. Re (linepath a b 0 - z) \\<noteq> 0\n 3. 0 \\<le> 0\n 4. 0 < 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b 0) = Re z \\<Longrightarrow> False", "by (auto simp add:linepath_def that)"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF_pathstart (linepath a b) z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathstart (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF_pathstart (linepath a b) z = 0\n  Re a \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re a \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  Re a \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re a=Re z\" \"Im a = Im z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "define c where \"c=(Im b - Im a) / (Re b - Re a)\""], ["proof (state)\nthis:\n  c = (Im b - Im a) / (Re b - Re a)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = jumpF (\\<lambda>_. c) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n    jumpF (\\<lambda>_. c) (at_right 0)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_right 0 = at_right 0\n 2. \\<forall>\\<^sub>F x in at_right 0. f x / g x = c", "show \"\\<forall>\\<^sub>F x in at_right 0. f x / g x = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right 0. f x / g x = c", "unfolding eventually_at_right f_def g_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ba>0.\n       \\<forall>y>0.\n          y < ba \\<longrightarrow>\n          ((Im b - Im a) * y + (Im a - Im z)) /\n          ((Re b - Re a) * y + (Re a - Re z)) =\n          (Im b - Im a) / (Re b - Re a)", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Im a = Im z\n\ngoal (1 subgoal):\n 1. \\<exists>ba>0.\n       \\<forall>y>0.\n          y < ba \\<longrightarrow>\n          ((Im b - Im a) * y + (Im a - Im z)) /\n          ((Re b - Re a) * y + (Re a - Re z)) =\n          (Im b - Im a) / (Re b - Re a)", "apply (intro exI[where x=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re a = Re z; Im a = Im z\\<rbrakk>\n    \\<Longrightarrow> 0 < 1 \\<and>\n                      (\\<forall>y>0.\n                          y < 1 \\<longrightarrow>\n                          ((Im b - Im a) * y + (Im a - Im z)) /\n                          ((Re b - Re a) * y + (Re a - Re z)) =\n                          (Im b - Im a) / (Re b - Re a))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right 0. f x / g x = c\n\ngoal (1 subgoal):\n 1. at_right 0 = at_right 0", "qed simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. c) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. c) (at_right 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. c) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. c) (at_right 0)\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n  Re a = Re z\n  Im a = Im z\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Im a = Im z\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Im a = Im z\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re a=Re z\" \"Re b = Re a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"(\\<lambda>t. f t/g t) = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        ((Im b - Im a) * t + (Im a - Im z)) /\n        ((Re b - Re a) * t + (Re a - Re z))) =\n    (\\<lambda>_. 0)", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re a\n\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        ((Im b - Im a) * t + (Im a - Im z)) /\n        ((Re b - Re a) * t + (Re a - Re z))) =\n    (\\<lambda>_. 0)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = jumpF (\\<lambda>_. 0) (at_right 0)\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n    jumpF (\\<lambda>_. 0) (at_right 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. 0) (at_right 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. 0) (at_right 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) =\n  jumpF (\\<lambda>_. 0) (at_right 0)\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n  Re a = Re z\n  Re b = Re a\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re a = Re z\" \"(Im a>Im z \\<and> Re b > Re a) \\<or> (Im a<Im z \\<and> Re b < Re a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_right 0. f x / g x :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"Im a - Im z\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> Im a - Im z) (at_right 0)\n 2. Im a - Im z \\<noteq> 0\n 3. (g \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (g has_sgnx sgn (Im a - Im z)) (at_right 0)", "unfolding f_def g_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im a - Im z)\n     (at_right 0)\n 2. Im a - Im z \\<noteq> 0\n 3. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_right 0) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im a - Im z))\n     (at_right 0)", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Im z < Im a \\<and> Re a < Re b \\<or> Im a < Im z \\<and> Re b < Re a\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im a - Im z)\n     (at_right 0)\n 2. Im a - Im z \\<noteq> 0\n 3. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_right 0) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im a - Im z))\n     (at_right 0)", "by (auto intro!:tendsto_eq_intros sgnx_eq_intros)"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. f x / g x :> at_top", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. f t / g t :> at_top then 1 / 2\n     else if LIM t at_right 0. f t / g t :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = 1 / 2\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n  Re a = Re z\n  Im z < Im a \\<and> Re a < Re b \\<or> Im a < Im z \\<and> Re b < Re a\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z;\n   Im z < Im a \\<and> Re a < Re b \\<or>\n   Im a < Im z \\<and> Re b < Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z;\n   Im z < Im a \\<and> Re a < Re b \\<or>\n   Im a < Im z \\<and> Re b < Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re a = Re z\" \"Im a\\<noteq>Im z\" \"Re b \\<noteq> Re a\" \n      \"\\<not> ((Im a>Im z \\<and> Re b > Re a) \\<or> (Im a<Im z \\<and> Re b < Re a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"(Im a>Im z \\<and> Re b < Re a) \\<or> (Im a<Im z \\<and> Re b > Re a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z < Im a \\<and> Re b < Re a \\<or> Im a < Im z \\<and> Re a < Re b", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Im a \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im a \\<and> Re a < Re b \\<or>\n          Im a < Im z \\<and> Re b < Re a)\n\ngoal (1 subgoal):\n 1. Im z < Im a \\<and> Re b < Re a \\<or> Im a < Im z \\<and> Re a < Re b", "by argo"], ["proof (state)\nthis:\n  Im z < Im a \\<and> Re b < Re a \\<or> Im a < Im z \\<and> Re a < Re b\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  Im z < Im a \\<and> Re b < Re a \\<or> Im a < Im z \\<and> Re a < Re b", "have \"LIM x at_right 0. f x / g x :> at_bot\""], ["proof (prove)\nusing this:\n  Im z < Im a \\<and> Re b < Re a \\<or> Im a < Im z \\<and> Re a < Re b\n\ngoal (1 subgoal):\n 1. LIM x at_right 0. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"Im a - Im z\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    (f \\<longlongrightarrow> Im a - Im z) (at_right 0)\n 2. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    Im a - Im z \\<noteq> 0\n 3. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_right 0) \\<and>\n    (g has_sgnx - sgn (Im a - Im z)) (at_right 0)", "unfolding f_def g_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im a - Im z)\n     (at_right 0)\n 2. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    Im a - Im z \\<noteq> 0\n 3. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_right 0) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im a - Im z))\n     (at_right 0)", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Im a \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im a \\<and> Re a < Re b \\<or>\n          Im a < Im z \\<and> Re b < Re a)\n\ngoal (3 subgoals):\n 1. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im a - Im z)\n     (at_right 0)\n 2. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    Im a - Im z \\<noteq> 0\n 3. Im z < Im a \\<and> Re b < Re a \\<or>\n    Im a < Im z \\<and> Re a < Re b \\<Longrightarrow>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_right 0) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im a - Im z))\n     (at_right 0)", "by (auto intro!:tendsto_eq_intros sgnx_eq_intros)"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right 0. f x / g x :> at_bot", "have \"\\<not> (LIM x at_right 0. f x / g x :> at_top)\""], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_right 0. f x / g x :> at_top)", "using filterlim_at_top_at_bot"], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_bot\n  \\<lbrakk>filterlim ?f at_top ?F; filterlim ?f at_bot ?F;\n   ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_right 0. f x / g x :> at_top)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (LIM x at_right 0. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_right 0. f x / g x :> at_bot\n  \\<not> (LIM x at_right 0. f x / g x :> at_top)", "have \"jumpF (\\<lambda>t. f t/g t) (at_right 0) = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_bot\n  \\<not> (LIM x at_right 0. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right 0. f x / g x :> at_bot\n  \\<not> (LIM x at_right 0. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (if LIM t at_right 0. f t / g t :> at_top then 1 / 2\n     else if LIM t at_right 0. f t / g t :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_right 0) = - 1 / 2\n  jumpF_pathstart (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_right 0)\n  Re a = Re z\n  Im a \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im a \\<and> Re a < Re b \\<or>\n          Im a < Im z \\<and> Re b < Re a)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Im a \\<noteq> Im z; Re b \\<noteq> Re a;\n   \\<not> (Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  Re a \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n  \\<lbrakk>Re a = Re z; Im a = Im z\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z;\n   Im z < Im a \\<and> Re a < Re b \\<or>\n   Im a < Im z \\<and> Re b < Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z; Im a \\<noteq> Im z; Re b \\<noteq> Re a;\n   \\<not> (Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  Re a \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n  \\<lbrakk>Re a = Re z; Im a = Im z\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z;\n   Im z < Im a \\<and> Re a < Re b \\<or>\n   Im a < Im z \\<and> Re b < Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z; Im a \\<noteq> Im z; Re b \\<noteq> Re a;\n   \\<not> (Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathstart (linepath a b) z =\n                    (if Re a = Re z \\<and>\n                        Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im a \\<and> Re a < Re b \\<or>\n                             Im a < Im z \\<and> Re b < Re a\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathstart (linepath a b) z =\n    (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im a \\<and> Re a < Re b \\<or>\n             Im a < Im z \\<and> Re b < Re a\n          then 1 / 2 else - 1 / 2\n     else 0)", "by fast"], ["proof (state)\nthis:\n  jumpF_pathstart (linepath a b) z =\n  (if Re a = Re z \\<and> Im a \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im a \\<and> Re a < Re b \\<or>\n           Im a < Im z \\<and> Re b < Re a\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_pathfinish_linepath:\n  \"jumpF_pathfinish (linepath a b) z = \n    (if Re b = Re z \\<and> Im b \\<noteq>Im z \\<and> Re b \\<noteq> Re a then \n        if (Im b>Im z \\<and> Re a > Re b) \\<or> (Im b<Im z \\<and> Re a < Re b) then 1/2 else -1/2 \n     else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "define f where \"f=(\\<lambda>t. (Im b - Im a )* t + (Im a - Im z))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. (Im b - Im a) * t + (Im a - Im z))\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "define g where \"g=(\\<lambda>t. (Re b - Re a )* t + (Re a - Re z))\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. (Re b - Re a) * t + (Re a - Re z))\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have jump_eq:\"jumpF_pathfinish (linepath a b) z = jumpF (\\<lambda>t. f t/g t) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    jumpF (\\<lambda>t. f t / g t) (at_left 1)", "unfolding jumpF_pathfinish_def f_def linepath_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF\n     (\\<lambda>t.\n         Im ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z) /\n         Re ((1 - t) *\\<^sub>R a + t *\\<^sub>R b - z))\n     (at_left 1) =\n    jumpF\n     (\\<lambda>t.\n         ((Im b - Im a) * t + (Im a - Im z)) /\n         ((Re b - Re a) * t + (Re a - Re z)))\n     (at_left 1)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re b\\<noteq>Re z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"jumpF_pathfinish (linepath a b) z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z = 0", "unfolding jumpF_pathfinish_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. Im (linepath a b t - z) / Re (linepath a b t - z))\n     (at_left 1) =\n    0", "apply (rule jumpF_im_divide_Re_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. path (\\<lambda>t. linepath a b t - z)\n 2. Re (linepath a b 1 - z) \\<noteq> 0\n 3. 0 < 1\n 4. 1 \\<le> 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (linepath a b 1) = Re z \\<Longrightarrow> False", "by (auto simp add:linepath_def that)"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF_pathfinish (linepath a b) z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_pathfinish (linepath a b) z = 0\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "using that"], ["proof (prove)\nusing this:\n  jumpF_pathfinish (linepath a b) z = 0\n  Re b \\<noteq> Re z\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re b \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  Re b \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re z=Re b\" \"Im z = Im b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "define c where \"c=(Im a - Im b) / (Re a - Re b)\""], ["proof (state)\nthis:\n  c = (Im a - Im b) / (Re a - Re b)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = jumpF (\\<lambda>_. c) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n    jumpF (\\<lambda>_. c) (at_left 1)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_left 1 = at_left 1\n 2. \\<forall>\\<^sub>F x in at_left 1. f x / g x = c", "have \"f x / g x = c\" when \"x<1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x / g x = c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x / g x = c", "have \"f x / g x = ((Im a - Im b)*(1-x))/((Re a - Re b)*(1-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x / g x = (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x))", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Im b - Im a) * x + (Im a - Im z)) /\n    ((Re b - Re a) * x + (Re a - Re z)) =\n    (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x))", "by (auto simp add:algebra_simps \\<open>Re z=Re b\\<close> \\<open>Im z = Im b\\<close>)"], ["proof (state)\nthis:\n  f x / g x = (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x))\n\ngoal (1 subgoal):\n 1. f x / g x = c", "also"], ["proof (state)\nthis:\n  f x / g x = (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x))\n\ngoal (1 subgoal):\n 1. f x / g x = c", "have \"... = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x)) = c", "using that"], ["proof (prove)\nusing this:\n  x < 1\n\ngoal (1 subgoal):\n 1. (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x)) = c", "unfolding c_def"], ["proof (prove)\nusing this:\n  x < 1\n\ngoal (1 subgoal):\n 1. (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x)) =\n    (Im a - Im b) / (Re a - Re b)", "by auto"], ["proof (state)\nthis:\n  (Im a - Im b) * (1 - x) / ((Re a - Re b) * (1 - x)) = c\n\ngoal (1 subgoal):\n 1. f x / g x = c", "finally"], ["proof (chain)\npicking this:\n  f x / g x = c", "show ?thesis"], ["proof (prove)\nusing this:\n  f x / g x = c\n\ngoal (1 subgoal):\n 1. f x / g x = c", "."], ["proof (state)\nthis:\n  f x / g x = c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < 1 \\<Longrightarrow> f ?x / g ?x = c\n\ngoal (2 subgoals):\n 1. at_left 1 = at_left 1\n 2. \\<forall>\\<^sub>F x in at_left 1. f x / g x = c", "then"], ["proof (chain)\npicking this:\n  ?x < 1 \\<Longrightarrow> f ?x / g ?x = c", "show \"\\<forall>\\<^sub>F x in at_left 1. f x / g x = c\""], ["proof (prove)\nusing this:\n  ?x < 1 \\<Longrightarrow> f ?x / g ?x = c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. f x / g x = c", "unfolding eventually_at_left"], ["proof (prove)\nusing this:\n  ?x < 1 \\<Longrightarrow> f ?x / g ?x = c\n\ngoal (1 subgoal):\n 1. \\<exists>b<1. \\<forall>y>b. y < 1 \\<longrightarrow> f y / g y = c", "using that"], ["proof (prove)\nusing this:\n  ?x < 1 \\<Longrightarrow> f ?x / g ?x = c\n  Re z = Re b\n  Im z = Im b\n\ngoal (1 subgoal):\n 1. \\<exists>b<1. \\<forall>y>b. y < 1 \\<longrightarrow> f y / g y = c", "apply (intro exI[where x=0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x < 1 \\<Longrightarrow> f x / g x = c; Re z = Re b;\n     Im z = Im b\\<rbrakk>\n    \\<Longrightarrow> 0 < 1 \\<and>\n                      (\\<forall>y>0. y < 1 \\<longrightarrow> f y / g y = c)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. f x / g x = c\n\ngoal (1 subgoal):\n 1. at_left 1 = at_left 1", "qed simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. c) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. c) (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. c) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. c) (at_left 1)\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n  Re z = Re b\n  Im z = Im b\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re z = Re b; Im z = Im b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re z = Re b; Im z = Im b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re a=Re z\" \"Re b = Re a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"(\\<lambda>t. f t/g t) = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        ((Im b - Im a) * t + (Im a - Im z)) /\n        ((Re b - Re a) * t + (Re a - Re z))) =\n    (\\<lambda>_. 0)", "using that"], ["proof (prove)\nusing this:\n  Re a = Re z\n  Re b = Re a\n\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        ((Im b - Im a) * t + (Im a - Im z)) /\n        ((Re b - Re a) * t + (Re a - Re z))) =\n    (\\<lambda>_. 0)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = jumpF (\\<lambda>_. 0) (at_left 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. f t / g t) = (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n    jumpF (\\<lambda>_. 0) (at_left 1)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. 0) (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) =\n  jumpF (\\<lambda>_. 0) (at_left 1)\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n  Re a = Re z\n  Re b = Re a\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re b = Re z\" \"(Im b>Im z \\<and> Re a > Re b) \\<or> (Im b<Im z \\<and> Re a < Re b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_left 1. f x / g x :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "have \"(g has_real_derivative Re b - Re a) (at 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative Re b - Re a) (at 1)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re a)\n     (at 1)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  (g has_real_derivative Re b - Re a) (at 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "from has_sgnx_derivative_at_left[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>g 1 = 0; Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (Re b - Re a)) (at_left 1)", "have \"(g has_sgnx sgn (Im b - Im z)) (at_left 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>g 1 = 0; Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (Re b - Re a)) (at_left 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (Im b - Im z)) (at_left 1)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>g 1 = 0; Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (Re b - Re a)) (at_left 1)\n  Re b = Re z\n  Im z < Im b \\<and> Re b < Re a \\<or> Im b < Im z \\<and> Re a < Re b\n\ngoal (1 subgoal):\n 1. (g has_sgnx sgn (Im b - Im z)) (at_left 1)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Re b - Re a) * 1 + (Re a - Re z) = 0;\n   Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>t.\n                         (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n                     - sgn (Re b - Re a))\n                     (at_left 1)\n  Re b = Re z\n  Im z < Im b \\<and> Re b < Re a \\<or> Im b < Im z \\<and> Re a < Re b\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx sgn (Im b - Im z)) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx sgn (Im b - Im z)) (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx sgn (Im b - Im z)) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"Im b - Im z\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_sgnx sgn (Im b - Im z)) (at_left 1) \\<Longrightarrow>\n    (f \\<longlongrightarrow> Im b - Im z) (at_left 1)\n 2. (g has_sgnx sgn (Im b - Im z)) (at_left 1) \\<Longrightarrow>\n    Im b - Im z \\<noteq> 0\n 3. (g has_sgnx sgn (Im b - Im z)) (at_left 1) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (g has_sgnx sgn (Im b - Im z)) (at_left 1)", "unfolding f_def g_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im b - Im z)\n     (at_left 1)\n 2. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    Im b - Im z \\<noteq> 0\n 3. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_left 1) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1)", "using that"], ["proof (prove)\nusing this:\n  Re b = Re z\n  Im z < Im b \\<and> Re b < Re a \\<or> Im b < Im z \\<and> Re a < Re b\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im b - Im z)\n     (at_left 1)\n 2. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    Im b - Im z \\<noteq> 0\n 3. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_left 1) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     sgn (Im b - Im z))\n     (at_left 1)", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. f x / g x :> at_top", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. f t / g t :> at_top then 1 / 2\n     else if LIM t at_left 1. f t / g t :> at_bot then - 1 / 2 else 0) =\n    1 / 2", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = 1 / 2\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n  Re b = Re z\n  Im z < Im b \\<and> Re b < Re a \\<or> Im b < Im z \\<and> Re a < Re b\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re b = Re z;\n   Im z < Im b \\<and> Re b < Re a \\<or>\n   Im b < Im z \\<and> Re a < Re b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re b = Re z;\n   Im z < Im b \\<and> Re b < Re a \\<or>\n   Im b < Im z \\<and> Re a < Re b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"Re b = Re z\" \"Im b\\<noteq>Im z\" \"Re b \\<noteq> Re a\" \n      \"\\<not> ((Im b>Im z \\<and> Re a > Re b) \\<or> (Im b<Im z \\<and> Re a < Re b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"(Im b>Im z \\<and> Re a < Re b) \\<or> (Im b<Im z \\<and> Re a > Re b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z < Im b \\<and> Re a < Re b \\<or> Im b < Im z \\<and> Re b < Re a", "using that"], ["proof (prove)\nusing this:\n  Re b = Re z\n  Im b \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n          Im b < Im z \\<and> Re a < Re b)\n\ngoal (1 subgoal):\n 1. Im z < Im b \\<and> Re a < Re b \\<or> Im b < Im z \\<and> Re b < Re a", "by argo"], ["proof (state)\nthis:\n  Im z < Im b \\<and> Re a < Re b \\<or> Im b < Im z \\<and> Re b < Re a\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_left 1. f x / g x :> at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "have \"(g has_real_derivative Re b - Re a) (at 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_real_derivative Re b - Re a) (at 1)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_real_derivative\n     Re b - Re a)\n     (at 1)", "by (auto intro!:derivative_eq_intros)"], ["proof (state)\nthis:\n  (g has_real_derivative Re b - Re a) (at 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "from has_sgnx_derivative_at_left[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>g 1 = 0; Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (Re b - Re a)) (at_left 1)", "have \"(g has_sgnx - sgn (Im b - Im z)) (at_left 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>g 1 = 0; Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (Re b - Re a)) (at_left 1)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (Im b - Im z)) (at_left 1)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>g 1 = 0; Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (g has_sgnx - sgn (Re b - Re a)) (at_left 1)\n  Re b = Re z\n  Im b \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n          Im b < Im z \\<and> Re a < Re b)\n\ngoal (1 subgoal):\n 1. (g has_sgnx - sgn (Im b - Im z)) (at_left 1)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Re b - Re a) * 1 + (Re a - Re z) = 0;\n   Re b - Re a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>t.\n                         (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n                     - sgn (Re b - Re a))\n                     (at_left 1)\n  Re b = Re z\n  Im b \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n          Im b < Im z \\<and> Re a < Re b)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1)", "by auto"], ["proof (state)\nthis:\n  (g has_sgnx - sgn (Im b - Im z)) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "then"], ["proof (chain)\npicking this:\n  (g has_sgnx - sgn (Im b - Im z)) (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (g has_sgnx - sgn (Im b - Im z)) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. f x / g x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"Im b - Im z\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (g has_sgnx - sgn (Im b - Im z)) (at_left 1) \\<Longrightarrow>\n    (f \\<longlongrightarrow> Im b - Im z) (at_left 1)\n 2. (g has_sgnx - sgn (Im b - Im z)) (at_left 1) \\<Longrightarrow>\n    Im b - Im z \\<noteq> 0\n 3. (g has_sgnx - sgn (Im b - Im z)) (at_left 1) \\<Longrightarrow>\n    (g \\<longlongrightarrow> 0) (at_left 1) \\<and>\n    (g has_sgnx - sgn (Im b - Im z)) (at_left 1)", "unfolding f_def g_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im b - Im z)\n     (at_left 1)\n 2. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    Im b - Im z \\<noteq> 0\n 3. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_left 1) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1)", "using that"], ["proof (prove)\nusing this:\n  Re b = Re z\n  Im b \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n          Im b < Im z \\<and> Re a < Re b)\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Im b - Im a) * t + (Im a - Im z)) \\<longlongrightarrow>\n     Im b - Im z)\n     (at_left 1)\n 2. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    Im b - Im z \\<noteq> 0\n 3. ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1) \\<Longrightarrow>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) \\<longlongrightarrow>\n     0)\n     (at_left 1) \\<and>\n    ((\\<lambda>t. (Re b - Re a) * t + (Re a - Re z)) has_sgnx\n     - sgn (Im b - Im z))\n     (at_left 1)", "by (auto intro!:tendsto_eq_intros )"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. f x / g x :> at_bot", "have \"\\<not> (LIM x at_left 1. f x / g x :> at_top)\""], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_bot\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_left 1. f x / g x :> at_top)", "using filterlim_at_top_at_bot"], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_bot\n  \\<lbrakk>filterlim ?f at_top ?F; filterlim ?f at_bot ?F;\n   ?F \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_left 1. f x / g x :> at_top)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (LIM x at_left 1. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  LIM x at_left 1. f x / g x :> at_bot\n  \\<not> (LIM x at_left 1. f x / g x :> at_top)", "have \"jumpF (\\<lambda>t. f t/g t) (at_left 1) = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_bot\n  \\<not> (LIM x at_left 1. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. f x / g x :> at_bot\n  \\<not> (LIM x at_left 1. f x / g x :> at_top)\n\ngoal (1 subgoal):\n 1. (if LIM t at_left 1. f t / g t :> at_top then 1 / 2\n     else if LIM t at_left 1. f t / g t :> at_bot then - 1 / 2 else 0) =\n    - 1 / 2", "by simp"], ["proof (state)\nthis:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "using jump_eq that"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>t. f t / g t) (at_left 1) = - 1 / 2\n  jumpF_pathfinish (linepath a b) z =\n  jumpF (\\<lambda>t. f t / g t) (at_left 1)\n  Re b = Re z\n  Im b \\<noteq> Im z\n  Re b \\<noteq> Re a\n  \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n          Im b < Im z \\<and> Re a < Re b)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re b = Re z; Im b \\<noteq> Im z; Re b \\<noteq> Re a;\n   \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  Re b \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n  \\<lbrakk>Re z = Re b; Im z = Im b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re b = Re z;\n   Im z < Im b \\<and> Re b < Re a \\<or>\n   Im b < Im z \\<and> Re a < Re b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re b = Re z; Im b \\<noteq> Im z; Re b \\<noteq> Re a;\n   \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  Re b \\<noteq> Re z \\<Longrightarrow>\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n  \\<lbrakk>Re z = Re b; Im z = Im b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re a = Re z; Re b = Re a\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re b = Re z;\n   Im z < Im b \\<and> Re b < Re a \\<or>\n   Im b < Im z \\<and> Re a < Re b\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n  \\<lbrakk>Re b = Re z; Im b \\<noteq> Im z; Re b \\<noteq> Re a;\n   \\<not> (Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b)\\<rbrakk>\n  \\<Longrightarrow> jumpF_pathfinish (linepath a b) z =\n                    (if Re b = Re z \\<and>\n                        Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n                     then if Im z < Im b \\<and> Re b < Re a \\<or>\n                             Im b < Im z \\<and> Re a < Re b\n                          then 1 / 2 else - 1 / 2\n                     else 0)\n\ngoal (1 subgoal):\n 1. jumpF_pathfinish (linepath a b) z =\n    (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n     then if Im z < Im b \\<and> Re b < Re a \\<or>\n             Im b < Im z \\<and> Re a < Re b\n          then 1 / 2 else - 1 / 2\n     else 0)", "by argo"], ["proof (state)\nthis:\n  jumpF_pathfinish (linepath a b) z =\n  (if Re b = Re z \\<and> Im b \\<noteq> Im z \\<and> Re b \\<noteq> Re a\n   then if Im z < Im b \\<and> Re b < Re a \\<or>\n           Im b < Im z \\<and> Re a < Re b\n        then 1 / 2 else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Setting up the method for evaluating winding numbers\\<close>"], ["", "lemma pathfinish_pathstart_partcirclepath_simps:\n  \"pathstart (part_circlepath z0 r (3*pi/2) tt) = z0 - Complex 0 r\"\n  \"pathstart (part_circlepath z0 r (2*pi) tt) = z0 + r\"\n  \"pathfinish (part_circlepath z0 r st (3*pi/2)) = z0 - Complex 0 r\"\n  \"pathfinish (part_circlepath z0 r st (2*pi)) = z0 + r\"\n  \"pathstart (part_circlepath z0 r 0 tt) = z0 + r\"\n  \"pathstart (part_circlepath z0 r (pi/2) tt) = z0 + Complex 0 r\"\n  \"pathstart (part_circlepath z0 r (pi) tt) = z0 - r\"\n  \"pathfinish (part_circlepath z0 r st 0) = z0+r\"\n  \"pathfinish (part_circlepath z0 r st (pi/2)) = z0 + Complex 0 r\"\n  \"pathfinish (part_circlepath z0 r st (pi)) = z0 - r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((pathstart (part_circlepath z0 r (3 * pi / 2) tt) =\n      z0 - Complex 0 r &&&\n      pathstart (part_circlepath z0 r (2 * pi) tt) =\n      z0 + complex_of_real r) &&&\n     pathfinish (part_circlepath z0 r st (3 * pi / 2)) =\n     z0 - Complex 0 r &&&\n     pathfinish (part_circlepath z0 r st (2 * pi)) =\n     z0 + complex_of_real r &&&\n     pathstart (part_circlepath z0 r 0 tt) = z0 + complex_of_real r) &&&\n    (pathstart (part_circlepath z0 r (pi / 2) tt) = z0 + Complex 0 r &&&\n     pathstart (part_circlepath z0 r pi tt) = z0 - complex_of_real r) &&&\n    pathfinish (part_circlepath z0 r st 0) = z0 + complex_of_real r &&&\n    pathfinish (part_circlepath z0 r st (pi / 2)) = z0 + Complex 0 r &&&\n    pathfinish (part_circlepath z0 r st pi) = z0 - complex_of_real r", "unfolding part_circlepath_def linepath_def pathstart_def pathfinish_def exp_Euler"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((z0 +\n      complex_of_real r *\n      (cos (complex_of_real\n             ((1 - 0) *\\<^sub>R (3 * pi / 2) + 0 *\\<^sub>R tt)) +\n       \\<i> *\n       sin (complex_of_real\n             ((1 - 0) *\\<^sub>R (3 * pi / 2) + 0 *\\<^sub>R tt))) =\n      z0 - Complex 0 r &&&\n      z0 +\n      complex_of_real r *\n      (cos (complex_of_real ((1 - 0) *\\<^sub>R (2 * pi) + 0 *\\<^sub>R tt)) +\n       \\<i> *\n       sin (complex_of_real\n             ((1 - 0) *\\<^sub>R (2 * pi) + 0 *\\<^sub>R tt))) =\n      z0 + complex_of_real r) &&&\n     z0 +\n     complex_of_real r *\n     (cos (complex_of_real\n            ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2))) +\n      \\<i> *\n      sin (complex_of_real\n            ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2)))) =\n     z0 - Complex 0 r &&&\n     z0 +\n     complex_of_real r *\n     (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi))) +\n      \\<i> *\n      sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi)))) =\n     z0 + complex_of_real r &&&\n     z0 +\n     complex_of_real r *\n     (cos (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt)) +\n      \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt))) =\n     z0 + complex_of_real r) &&&\n    (z0 +\n     complex_of_real r *\n     (cos (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt)) +\n      \\<i> *\n      sin (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt))) =\n     z0 + Complex 0 r &&&\n     z0 +\n     complex_of_real r *\n     (cos (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt)) +\n      \\<i> *\n      sin (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt))) =\n     z0 - complex_of_real r) &&&\n    z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0))) =\n    z0 + complex_of_real r &&&\n    z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2)))) =\n    z0 + Complex 0 r &&&\n    z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi))) =\n    z0 - complex_of_real r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z0 +\n    complex_of_real r *\n    (cos (complex_of_real\n           ((1 - 0) *\\<^sub>R (3 * pi / 2) + 0 *\\<^sub>R tt)) +\n     \\<i> *\n     sin (complex_of_real\n           ((1 - 0) *\\<^sub>R (3 * pi / 2) + 0 *\\<^sub>R tt))) =\n    z0 - Complex 0 r", "apply(simp, subst sin.minus_1[symmetric],subst cos.minus_1[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real r *\n    (cos (3 * complex_of_real pi / 2 - 2 * complex_of_real pi) +\n     \\<i> * sin (3 * complex_of_real pi / 2 - 2 * complex_of_real pi)) =\n    - Complex 0 r", "by (simp add: complex_of_real_i)"], ["proof (prove)\ngoal (9 subgoals):\n 1. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R (2 * pi) + 0 *\\<^sub>R tt)) +\n     \\<i> *\n     sin (complex_of_real ((1 - 0) *\\<^sub>R (2 * pi) + 0 *\\<^sub>R tt))) =\n    z0 + complex_of_real r\n 2. z0 +\n    complex_of_real r *\n    (cos (complex_of_real\n           ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2))) +\n     \\<i> *\n     sin (complex_of_real\n           ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2)))) =\n    z0 - Complex 0 r\n 3. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi)))) =\n    z0 + complex_of_real r\n 4. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt)) +\n     \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt))) =\n    z0 + complex_of_real r\n 5. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt)) +\n     \\<i> *\n     sin (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt))) =\n    z0 + Complex 0 r\n 6. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt)) +\n     \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt))) =\n    z0 - complex_of_real r\n 7. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0))) =\n    z0 + complex_of_real r\n 8. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2)))) =\n    z0 + Complex 0 r\n 9. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi))) =\n    z0 - complex_of_real r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R (2 * pi) + 0 *\\<^sub>R tt)) +\n     \\<i> *\n     sin (complex_of_real ((1 - 0) *\\<^sub>R (2 * pi) + 0 *\\<^sub>R tt))) =\n    z0 + complex_of_real r", "by (simp add: complex_of_real_i)"], ["proof (prove)\ngoal (8 subgoals):\n 1. z0 +\n    complex_of_real r *\n    (cos (complex_of_real\n           ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2))) +\n     \\<i> *\n     sin (complex_of_real\n           ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2)))) =\n    z0 - Complex 0 r\n 2. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi)))) =\n    z0 + complex_of_real r\n 3. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt)) +\n     \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt))) =\n    z0 + complex_of_real r\n 4. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt)) +\n     \\<i> *\n     sin (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt))) =\n    z0 + Complex 0 r\n 5. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt)) +\n     \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt))) =\n    z0 - complex_of_real r\n 6. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0))) =\n    z0 + complex_of_real r\n 7. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2)))) =\n    z0 + Complex 0 r\n 8. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi))) =\n    z0 - complex_of_real r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z0 +\n    complex_of_real r *\n    (cos (complex_of_real\n           ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2))) +\n     \\<i> *\n     sin (complex_of_real\n           ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (3 * pi / 2)))) =\n    z0 - Complex 0 r", "apply(simp, subst sin.minus_1[symmetric],subst cos.minus_1[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real r *\n    (cos (3 * complex_of_real pi / 2 - 2 * complex_of_real pi) +\n     \\<i> * sin (3 * complex_of_real pi / 2 - 2 * complex_of_real pi)) =\n    - Complex 0 r", "by (simp add: complex_of_real_i)"], ["proof (prove)\ngoal (7 subgoals):\n 1. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (2 * pi)))) =\n    z0 + complex_of_real r\n 2. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt)) +\n     \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R 0 + 0 *\\<^sub>R tt))) =\n    z0 + complex_of_real r\n 3. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt)) +\n     \\<i> *\n     sin (complex_of_real ((1 - 0) *\\<^sub>R (pi / 2) + 0 *\\<^sub>R tt))) =\n    z0 + Complex 0 r\n 4. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt)) +\n     \\<i> * sin (complex_of_real ((1 - 0) *\\<^sub>R pi + 0 *\\<^sub>R tt))) =\n    z0 - complex_of_real r\n 5. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R 0))) =\n    z0 + complex_of_real r\n 6. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2))) +\n     \\<i> *\n     sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R (pi / 2)))) =\n    z0 + Complex 0 r\n 7. z0 +\n    complex_of_real r *\n    (cos (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi)) +\n     \\<i> * sin (complex_of_real ((1 - 1) *\\<^sub>R st + 1 *\\<^sub>R pi))) =\n    z0 - complex_of_real r", "by (simp_all add: complex_of_real_i)"], ["", "lemma winding_eq_intro:\n  \"finite_ReZ_segments g z \\<Longrightarrow>\n  valid_path g \\<Longrightarrow>\n  z \\<notin> path_image g \\<Longrightarrow>\n  pathfinish g = pathstart g \\<Longrightarrow>  \n  - of_real(cindex_pathE g z) =2*n \\<Longrightarrow>\n  winding_number g z = (n::complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n     pathfinish g = pathstart g;\n     - complex_of_real (cindex_pathE g z) = 2 * n\\<rbrakk>\n    \\<Longrightarrow> winding_number g z = n", "apply (subst winding_number_cindex_pathE[of g z])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n     pathfinish g = pathstart g;\n     - complex_of_real (cindex_pathE g z) = 2 * n\\<rbrakk>\n    \\<Longrightarrow> finite_ReZ_segments g z\n 2. \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n     pathfinish g = pathstart g;\n     - complex_of_real (cindex_pathE g z) = 2 * n\\<rbrakk>\n    \\<Longrightarrow> valid_path g\n 3. \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n     pathfinish g = pathstart g;\n     - complex_of_real (cindex_pathE g z) = 2 * n\\<rbrakk>\n    \\<Longrightarrow> z \\<notin> path_image g\n 4. \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n     pathfinish g = pathstart g;\n     - complex_of_real (cindex_pathE g z) = 2 * n\\<rbrakk>\n    \\<Longrightarrow> pathfinish g = pathstart g\n 5. \\<lbrakk>finite_ReZ_segments g z; valid_path g; z \\<notin> path_image g;\n     pathfinish g = pathstart g;\n     - complex_of_real (cindex_pathE g z) = 2 * n\\<rbrakk>\n    \\<Longrightarrow> complex_of_real (- cindex_pathE g z / 2) = n", "by (auto simp add:field_simps)"], ["", "named_theorems winding_intros and winding_simps"], ["", "lemmas [winding_intros] = \n  finite_ReZ_segments_joinpaths\n  valid_path_join\n  path_join_imp\n  not_in_path_image_join"], ["", "lemmas [winding_simps] =\n  finite_ReZ_segments_linepath\n  finite_ReZ_segments_part_circlepath\n  jumpF_pathfinish_joinpaths\n  jumpF_pathstart_joinpaths\n  pathfinish_linepath\n  pathstart_linepath\n  pathfinish_join\n  pathstart_join\n  valid_path_linepath\n  valid_path_part_circlepath\n  path_part_circlepath\n  Re_complex_of_real\n  Im_complex_of_real\n  of_real_linepath\n  pathfinish_pathstart_partcirclepath_simps"], ["", "method rep_subst  =\n  (subst cindex_pathE_joinpaths; rep_subst)?"], ["", "text \\<open>\nThe method \"eval\\_winding\" @{term 1} will try to simplify of the form @{term \"winding_number g z = n\"} where \n@{term n} is an integer and @{term g} is a closed path comprised of @{term linepath}, \n@{term part_circlepath} and @{term joinpaths}.\n\nSuppose @{term \"g=l1+++l2\"}, usually, the key behind the success of this framework is whether we can prove \n@{term \"z \\<notin> path_image l1\"}, @{term \"z \\<notin> path_image l2\"} and calculate @{term \"cindex_pathE l1 z\"} \nand @{term \"cindex_pathE l2 z\"}.\n\\<close>"], ["", "method eval_winding = \n  ((rule_tac winding_eq_intro;\n    rep_subst\n    )\n  , auto simp only:winding_simps del:notI intro!:winding_intros\n  , tactic \\<open>distinct_subgoals_tac\\<close>)"], ["", "end"]]}