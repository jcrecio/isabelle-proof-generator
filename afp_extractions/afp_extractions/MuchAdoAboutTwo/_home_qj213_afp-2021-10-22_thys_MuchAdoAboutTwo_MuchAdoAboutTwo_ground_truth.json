{"file_name": "/home/qj213/afp-2021-10-22/thys/MuchAdoAboutTwo/MuchAdoAboutTwo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MuchAdoAboutTwo", "problem_names": ["lemma non_empty_n2l: \"n2l xs \\<noteq> []\"", "lemma n2l_l2n_id: \"x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x\"", "lemma n2l_l2n_map_id:\n  assumes \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []\"\n  shows \"map (n2l \\<circ> l2n) zs = zs\"", "lemma Lemma_1:\n  assumes A1: \"\\<And>(x::'a list) (y::'a list). \n                 x \\<noteq> [] \\<Longrightarrow> y \\<noteq> [] \\<Longrightarrow> h (f x y) = g (h x) (h y)\"\n      and A2: \"\\<And>x y. x \\<noteq> [] \\<Longrightarrow> y \\<noteq> [] \\<Longrightarrow> f x y \\<noteq> []\"\n      and A3: \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []\"\n  shows \"map h (candidate f zs) = candidate g (map h zs)\"", "lemma upt_map_Suc:\n  \"k > 0 \\<Longrightarrow> [0..<k + 1] = 0 # map Suc [0..<k]\"", "lemma divide_and_conquer_induct:\n  assumes A1: \"P []\"\n      and A2: \"\\<And>x. P [x]\"\n      and A3: \"\\<And>xs ys. \\<lbrakk> xs \\<noteq> [] ; ys \\<noteq> [] ; P xs ; P ys \\<rbrakk> \\<Longrightarrow> P (xs @ ys)\"\n  shows \"P zs\"", "lemmas divide_and_conquer \n  = divide_and_conquer_induct [case_names Nil One Partition]", "lemma all_set_inter_empty_distinct:\n  assumes \"\\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}\"\n  shows \"distinct js\"", "lemma partitions_sorted:\n  assumes \"\\<And>xs ys x y. \\<lbrakk> js = xs @ ys ; x \\<in> set xs ; y \\<in> set ys \\<rbrakk> \\<Longrightarrow> x \\<le> y\"\n  shows \"sorted js\"", "lemma L1: \"map g (map f xs) = map (g \\<circ> f) xs\"", "lemma L2: \"length (map f xs) = length xs\"", "lemma L3: \"take k (map f xs) = map f (take k xs)\"", "lemma L4: \"map f \\<circ> wrap = wrap \\<circ> f\"", "lemma L5: \"map f (xs @ ys) = (map f xs) @ (map f ys)\"", "lemma L6: \"k < length xs \\<Longrightarrow> (map f xs) ! k = f (xs ! k)\"", "lemma L7: \"\\<And>k. k < length xs \\<Longrightarrow> map (nth xs) [0..<k + 1] = take (k + 1) xs\"", "lemma foldl1_append:\n  assumes \"xs \\<noteq> []\"\n  shows \"foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)\"", "lemma foldl1_induct':\n  assumes \"\\<And>f x. P f [x]\"\n      and \"\\<And>f x y. P f [x, y]\" \n      and \"\\<And>f x y z zs. P f (f x y # z # zs) \\<Longrightarrow> P f (x # y # z # zs)\"\n      and \"\\<And>f. P f []\"\n  shows \"P f xs\"", "lemmas foldl1_induct = foldl1_induct' [case_names One Two More Nil]", "lemma L8:\n  assumes \"associative f\"\n      and \"xs \\<noteq> []\"\n      and \"ys \\<noteq> []\"\n  shows \"foldl1 f (xs @ ys) = f (foldl1 f xs) (foldl1 f ys)\"", "lemma Lemma_2:\n  assumes \"length xs = length ys\"\n      and \"\\<And>k. k < length xs \\<Longrightarrow> xs ! k = ys ! k\"\n  shows \"xs = ys\"", "lemma foldl1_map:\n  assumes \"associative f\"\n      and \"xs \\<noteq> []\"\n      and \"ys \\<noteq> []\"\n  shows \"foldl1 f (map h (xs @ ys)) \n         = f (foldl1 f (map h xs)) (foldl1 f (map h ys))\"", "lemma Lemma_3:\n  fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n    and h :: \"nat \\<Rightarrow> 'a\"\n  assumes \"associative f\"\n  shows \"map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n+1])) \n         = candidate f (map h [0..<n+1])\"", "lemma f1_assoc: \"associative f1\"", "lemma f2_assoc: \"associative f2\"", "lemma Figure_2: \n  assumes \"i \\<le> k\"\n  shows \"foldl1 f1 (map (h1 k i) [0..<k + 1]) = One\"", "lemma Figure_3: \n  assumes \"i < k\"\n  shows \"foldl1 f2 (map (h2 i) [0..<k + 1]) = Two\"", "lemma L9:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f \n             \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and \"i \\<le> k\"\n  shows \"foldl1 f1 (map (h1 k i) js) = One\"", "lemma L10:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f \n             \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and \"i < k\"\n  shows \"foldl1 f2 (map (h2 i) js) = Two\"", "lemma Figure_4:\n  assumes \"foldl1 f1 (map (h1 k i) js) = One\"\n      and \"js \\<noteq> []\"\n  shows \"i \\<in> set js\"", "lemma Figure_5:\n  assumes \"foldl1 f1 (map (h1 k i) js) = One\"\n      and \"js = xs @ ys\"\n  shows \"\\<not>(i \\<in> set xs \\<and> i \\<in> set ys)\"", "lemma Figure_6:\n  assumes \"\\<And>i. i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k i) js) = One\"\n      and \"i > k\"\n  shows \"i \\<notin> set js\"", "lemma Figure_7:\n  assumes \"foldl1 f2 (map (h2 i) js) = Two\"\n      and \"js = xs @ ys\"\n      and \"xs \\<noteq> []\"\n      and \"i = last xs\"\n  shows \"(i + 1) \\<in> set ys\"", "lemma js_is_a_permutation:\n  assumes A1: \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f\n                \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and A2: \"js \\<noteq> []\"\n  shows \"js <~~> [0..<k + 1]\"", "lemma Figure_7_trans:\n  assumes A1: \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                         \\<Longrightarrow> (i + 1) \\<in> set ys\"\n      and A2: \"(r::nat) > 0\"\n      and A3: \"i + r \\<le> k\"\n      and A4: \"js = xs @ ys\"\n      and A5: \"xs \\<noteq> []\"\n      and A6: \"i = last xs\"\n  shows \"(i + r) \\<in> set ys\"", "lemma js_partition_order:\n  assumes A1: \"js <~~> [0..<k + 1]\"\n      and A2: \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                         \\<Longrightarrow> (i + 1) \\<in> set ys\"\n      and A3: \"js = xs @ ys\"\n      and A4: \"i \\<in> set xs\" \n      and A5: \"j \\<in> set ys\"\n  shows \"i \\<le> j\"", "lemma js_equals_upt_k:\n  assumes A1: \"js <~~> [0..<k + 1]\"\n      and A2: \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                         \\<Longrightarrow> (i + 1) \\<in> set ys\"\n  shows \"js = [0..<k + 1]\"", "lemma Lemma_4:\n  assumes \"\\<And>(f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f  \n             \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and \"js \\<noteq> []\"\n  shows \"js = [0..<k + 1]\"", "lemma Lemma_5:\n  assumes \"\\<And>(f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f\n             \\<Longrightarrow> map (foldl1 f \\<circ> map h) jss = scanl1 f (map h [0..<n + 1])\"\n      and \"\\<And>js. js \\<in> set jss \\<Longrightarrow> js \\<noteq> []\"\n  shows \"jss = ups n\"", "lemma non_empty_candidate_results:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) (xs :: three list). \n             \\<lbrakk> associative f ; xs \\<noteq> [] \\<rbrakk>  \\<Longrightarrow> candidate f xs = scanl1 f xs\"\n      and \"js \\<in> set (candidate (@) (map wrap [0..<n + 1]))\"\n  shows   \"js \\<noteq> []\"", "lemma Proposition_1:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) (xs :: three list). \n             \\<lbrakk> associative f ; xs \\<noteq> [] \\<rbrakk>  \\<Longrightarrow> candidate f xs = scanl1 f xs\"\n  shows \"candidate (@) (map wrap [0..<n + 1]) = ups n\"", "lemma Prop_2_step_L7:\n  \"map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs]\n   = map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]\"", "lemma Proposition_2:\n  assumes A1: \"\\<And> n. candidate (@) (map wrap [0..<n + 1]) = ups n\"\n      and A2: \"associative g\"\n      and A3: \"xs \\<noteq> []\"\n  shows \"candidate g xs = scanl1 g xs\"", "theorem The_0_1_2_Principle:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) (xs :: three list). \n             \\<lbrakk> associative f ; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow> candidate f xs = scanl1 f xs\"\n      and \"associative g\"\n      and \"ys \\<noteq> []\"\n  shows \"candidate g ys = scanl1 g ys\""], "translations": [["", "lemma non_empty_n2l: \"n2l xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n2l xs \\<noteq> []", "by (cases xs, auto)"], ["", "lemma n2l_l2n_id: \"x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x", "proof (induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> n2l (l2n []) = []\n 2. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x;\n        a # x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> n2l (l2n (a # x)) = a # x", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> n2l (l2n []) = []\n 2. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x;\n        a # x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> n2l (l2n (a # x)) = a # x", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. n2l (l2n []) = []", "by simp"], ["proof (state)\nthis:\n  n2l (l2n []) = []\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x;\n        a # x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> n2l (l2n (a # x)) = a # x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x;\n        a # x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> n2l (l2n (a # x)) = a # x", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> n2l (l2n xs) = xs\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow> n2l (l2n x) = x;\n        a # x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> n2l (l2n (a # x)) = a # x", "thus ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow> n2l (l2n xs) = xs\n  x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. n2l (l2n (x # xs)) = x # xs", "by (cases xs, auto)"], ["proof (state)\nthis:\n  n2l (l2n (x # xs)) = x # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma n2l_l2n_map_id:\n  assumes \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []\"\n  shows \"map (n2l \\<circ> l2n) zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (n2l \\<circ> l2n) zs = zs", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set zs \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (n2l \\<circ> l2n) zs = zs", "proof (induct zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n    map (n2l \\<circ> l2n) [] = []\n 2. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "case Nil"], ["proof (state)\nthis:\n  ?x \\<in> set [] \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n    map (n2l \\<circ> l2n) [] = []\n 2. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "thus ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set [] \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (n2l \\<circ> l2n) [] = []", "by simp"], ["proof (state)\nthis:\n  map (n2l \\<circ> l2n) [] = []\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "case (Cons z zs)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "hence \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []", "using List.set_subset_Cons"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> []\n  set ?xs \\<subseteq> set (?x # ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set zs \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "with Cons"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> []\n  ?x \\<in> set zs \\<Longrightarrow> ?x \\<noteq> []", "have IH: \"map (n2l \\<circ> l2n) zs = zs\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> []\n  ?x \\<in> set zs \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (n2l \\<circ> l2n) zs = zs", "by blast"], ["proof (state)\nthis:\n  map (n2l \\<circ> l2n) zs = zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "have \n  \"map (n2l \\<circ> l2n) (z # zs)\n   = (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (n2l \\<circ> l2n) (z # zs) =\n    (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs", "by simp"], ["proof (state)\nthis:\n  map (n2l \\<circ> l2n) (z # zs) =\n  (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "also"], ["proof (state)\nthis:\n  map (n2l \\<circ> l2n) (z # zs) =\n  (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "have \n  \"\\<dots> = z # map (n2l \\<circ> l2n) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs =\n    z # map (n2l \\<circ> l2n) zs", "using Cons and n2l_l2n_id"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set (z # zs) \\<Longrightarrow> ?x \\<noteq> []\n  ?x \\<noteq> [] \\<Longrightarrow> n2l (l2n ?x) = ?x\n\ngoal (1 subgoal):\n 1. (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs =\n    z # map (n2l \\<circ> l2n) zs", "by auto"], ["proof (state)\nthis:\n  (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs =\n  z # map (n2l \\<circ> l2n) zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "also"], ["proof (state)\nthis:\n  (n2l \\<circ> l2n) z # map (n2l \\<circ> l2n) zs =\n  z # map (n2l \\<circ> l2n) zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "have \n  \"\\<dots> = z # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z # map (n2l \\<circ> l2n) zs = z # zs", "using IH"], ["proof (prove)\nusing this:\n  map (n2l \\<circ> l2n) zs = zs\n\ngoal (1 subgoal):\n 1. z # map (n2l \\<circ> l2n) zs = z # zs", "by simp"], ["proof (state)\nthis:\n  z # map (n2l \\<circ> l2n) zs = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set zs \\<Longrightarrow>\n                    x \\<noteq> []) \\<Longrightarrow>\n                map (n2l \\<circ> l2n) zs = zs;\n        \\<And>x.\n           x \\<in> set (a # zs) \\<Longrightarrow> x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> map (n2l \\<circ> l2n) (a # zs) = a # zs", "finally"], ["proof (chain)\npicking this:\n  map (n2l \\<circ> l2n) (z # zs) = z # zs", "show ?case"], ["proof (prove)\nusing this:\n  map (n2l \\<circ> l2n) (z # zs) = z # zs\n\ngoal (1 subgoal):\n 1. map (n2l \\<circ> l2n) (z # zs) = z # zs", "."], ["proof (state)\nthis:\n  map (n2l \\<circ> l2n) (z # zs) = z # zs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nBased on the previous lemmas, we can state and proof a specialised version\nof \\<open>candidate\\<close>'s free theorem, suitable for our setting as explained \nbefore.\n\\<close>"], ["", "lemma Lemma_1:\n  assumes A1: \"\\<And>(x::'a list) (y::'a list). \n                 x \\<noteq> [] \\<Longrightarrow> y \\<noteq> [] \\<Longrightarrow> h (f x y) = g (h x) (h y)\"\n      and A2: \"\\<And>x y. x \\<noteq> [] \\<Longrightarrow> y \\<noteq> [] \\<Longrightarrow> f x y \\<noteq> []\"\n      and A3: \"\\<And>x. x \\<in> set zs \\<Longrightarrow> x \\<noteq> []\"\n  shows \"map h (candidate f zs) = candidate g (map h zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "proof -\n  \\<comment> \\<open>We define two functions, @{text \"fn :: 'a nel \\<Rightarrow> 'a nel \\<Rightarrow> 'a nel\"} and\\<close>\n  \\<comment> \\<open>@{text \"hn :: 'a nel \\<Rightarrow> b\"}, which wrap @{text f} and @{text h} in the\\<close>\n  \\<comment> \\<open>setting of non-empty lists.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "let ?fn = \"\\<lambda>x y. l2n (f (n2l x) (n2l y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "let ?hn = \"h \\<circ> n2l\"\n\n  \\<comment> \\<open>Our new functions fulfill the preconditions of @{text candidate}'s\\<close>\n  \\<comment> \\<open>free theorem:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \"\\<And>(x::'a nel) (y::'a nel). ?hn (?fn x y) = g (?hn x) (?hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "let ?xl = \"n2l (x :: 'a nel)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "let ?yl = \"n2l (y :: 'a nel)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "have \n      \"?hn (?fn x y)\n       = h (n2l (l2n (f (n2l x) (n2l y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n    h (n2l (l2n (f (n2l x) (n2l y))))", "by simp"], ["proof (state)\nthis:\n  (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n  h (n2l (l2n (f (n2l x) (n2l y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "also"], ["proof (state)\nthis:\n  (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n  h (n2l (l2n (f (n2l x) (n2l y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "have \n      \"\\<dots> = h (f ?xl ?yl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (n2l (l2n (f (n2l x) (n2l y)))) = h (f (n2l x) (n2l y))", "using A2 [where x=\"?xl\" and y=\"?yl\"]\n          and n2l_l2n_id [where x=\"f (n2l x) (n2l y)\"] \n          and non_empty_n2l [where xs=x] \n          and non_empty_n2l [where xs=y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n2l x \\<noteq> []; n2l y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f (n2l x) (n2l y) \\<noteq> []\n  f (n2l x) (n2l y) \\<noteq> [] \\<Longrightarrow>\n  n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)\n  n2l x \\<noteq> []\n  n2l y \\<noteq> []\n\ngoal (1 subgoal):\n 1. h (n2l (l2n (f (n2l x) (n2l y)))) = h (f (n2l x) (n2l y))", "by simp"], ["proof (state)\nthis:\n  h (n2l (l2n (f (n2l x) (n2l y)))) = h (f (n2l x) (n2l y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "also"], ["proof (state)\nthis:\n  h (n2l (l2n (f (n2l x) (n2l y)))) = h (f (n2l x) (n2l y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "have \n      \"\\<dots> = g (h ?xl) (h ?yl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (f (n2l x) (n2l y)) = g (h (n2l x)) (h (n2l y))", "using A1 and non_empty_n2l and non_empty_n2l"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> h (f ?x ?y) = g (h ?x) (h ?y)\n  n2l ?xs \\<noteq> []\n  n2l ?xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. h (f (n2l x) (n2l y)) = g (h (n2l x)) (h (n2l y))", "by auto"], ["proof (state)\nthis:\n  h (f (n2l x) (n2l y)) = g (h (n2l x)) (h (n2l y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "also"], ["proof (state)\nthis:\n  h (f (n2l x) (n2l y)) = g (h (n2l x)) (h (n2l y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "have \n      \"\\<dots> = g (?hn x) (?hn y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (h (n2l x)) (h (n2l y)) = g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "by simp"], ["proof (state)\nthis:\n  g (h (n2l x)) (h (n2l y)) = g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n       g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "finally"], ["proof (chain)\npicking this:\n  (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n  g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "show \"?hn (?fn x y) = g (?hn x) (?hn y)\""], ["proof (prove)\nusing this:\n  (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n  g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)\n\ngoal (1 subgoal):\n 1. (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n    g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)", "."], ["proof (state)\nthis:\n  (h \\<circ> n2l) (l2n (f (n2l x) (n2l y))) =\n  g ((h \\<circ> n2l) x) ((h \\<circ> n2l) y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (h \\<circ> n2l) (l2n (f (n2l ?x) (n2l ?y))) =\n  g ((h \\<circ> n2l) ?x) ((h \\<circ> n2l) ?y)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "with candidate_free_theorem [where f=\"?fn\" and h=\"?hn\" and g = g]"], ["proof (chain)\npicking this:\n  (h \\<circ> n2l) (l2n (f (n2l ?x) (n2l ?y))) =\n  g ((h \\<circ> n2l) ?x) ((h \\<circ> n2l) ?y) \\<Longrightarrow>\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) ?zs) =\n  candidate g (map (h \\<circ> n2l) ?zs)\n  (h \\<circ> n2l) (l2n (f (n2l ?x) (n2l ?y))) =\n  g ((h \\<circ> n2l) ?x) ((h \\<circ> n2l) ?y)", "have ne_free_theorem: \n  \"map ?hn (candidate ?fn (map l2n zs)) = candidate g (map ?hn (map l2n zs))\""], ["proof (prove)\nusing this:\n  (h \\<circ> n2l) (l2n (f (n2l ?x) (n2l ?y))) =\n  g ((h \\<circ> n2l) ?x) ((h \\<circ> n2l) ?y) \\<Longrightarrow>\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) ?zs) =\n  candidate g (map (h \\<circ> n2l) ?zs)\n  (h \\<circ> n2l) (l2n (f (n2l ?x) (n2l ?y))) =\n  g ((h \\<circ> n2l) ?x) ((h \\<circ> n2l) ?y)\n\ngoal (1 subgoal):\n 1. map (h \\<circ> n2l)\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n    candidate g (map (h \\<circ> n2l) (map l2n zs))", "by auto\n\n  \\<comment> \\<open>We use @{text candidate}'s free theorem again to show the following\\<close>\n  \\<comment> \\<open>property:\\<close>"], ["proof (state)\nthis:\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n  candidate g (map (h \\<circ> n2l) (map l2n zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have n2l_candidate: \n    \"\\<And>zs. map n2l (candidate ?fn zs) = candidate f (map n2l zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) zs) =\n       candidate f (map n2l zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) zs) =\n       candidate f (map n2l zs)", "fix zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) zs) =\n       candidate f (map n2l zs)", "have \"\\<And>x y. n2l (?fn x y) = f (n2l x) (n2l y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)", "show \"n2l (?fn x y) = f (n2l x) (n2l y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)", "using n2l_l2n_id [where x=\"f (n2l x) (n2l y)\"] \n              and A2 [where x=\"n2l x\" and y=\"n2l y\"]\n              and non_empty_n2l [where xs=x] and non_empty_n2l [where xs=y]"], ["proof (prove)\nusing this:\n  f (n2l x) (n2l y) \\<noteq> [] \\<Longrightarrow>\n  n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)\n  \\<lbrakk>n2l x \\<noteq> []; n2l y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f (n2l x) (n2l y) \\<noteq> []\n  n2l x \\<noteq> []\n  n2l y \\<noteq> []\n\ngoal (1 subgoal):\n 1. n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)", "by simp"], ["proof (state)\nthis:\n  n2l (l2n (f (n2l x) (n2l y))) = f (n2l x) (n2l y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n2l (l2n (f (n2l ?x) (n2l ?y))) = f (n2l ?x) (n2l ?y)\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) zs) =\n       candidate f (map n2l zs)", "with candidate_free_theorem [where h=n2l and f=\"?fn\" and g=f]"], ["proof (chain)\npicking this:\n  n2l (l2n (f (n2l ?x) (n2l ?y))) = f (n2l ?x) (n2l ?y) \\<Longrightarrow>\n  map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) ?zs) =\n  candidate f (map n2l ?zs)\n  n2l (l2n (f (n2l ?x) (n2l ?y))) = f (n2l ?x) (n2l ?y)", "show \"map n2l (candidate ?fn zs) = candidate f (map n2l zs)\""], ["proof (prove)\nusing this:\n  n2l (l2n (f (n2l ?x) (n2l ?y))) = f (n2l ?x) (n2l ?y) \\<Longrightarrow>\n  map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) ?zs) =\n  candidate f (map n2l ?zs)\n  n2l (l2n (f (n2l ?x) (n2l ?y))) = f (n2l ?x) (n2l ?y)\n\ngoal (1 subgoal):\n 1. map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) zs) =\n    candidate f (map n2l zs)", "by simp"], ["proof (state)\nthis:\n  map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) zs) =\n  candidate f (map n2l zs)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Now, with the previous preparations, we conclude the thesis by the\\<close>\n  \\<comment> \\<open>following rewriting:\\<close>"], ["proof (state)\nthis:\n  map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) ?zs) =\n  candidate f (map n2l ?zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"map h (candidate f zs)\n   = map h (candidate f (map (n2l \\<circ> l2n) zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map h (candidate f zs) = map h (candidate f (map (n2l \\<circ> l2n) zs))", "using n2l_l2n_map_id [where zs=zs] and A3"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set zs \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = map h (candidate f (map (n2l \\<circ> l2n) zs))", "by simp"], ["proof (state)\nthis:\n  map h (candidate f zs) = map h (candidate f (map (n2l \\<circ> l2n) zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  map h (candidate f zs) = map h (candidate f (map (n2l \\<circ> l2n) zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots> = map h (candidate f (map n2l (map l2n zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map h (candidate f (map (n2l \\<circ> l2n) zs)) =\n    map h (candidate f (map n2l (map l2n zs)))", "using List.map_map [where f=n2l and g=l2n and xs=zs]"], ["proof (prove)\nusing this:\n  map n2l (map l2n zs) = map (n2l \\<circ> l2n) zs\n\ngoal (1 subgoal):\n 1. map h (candidate f (map (n2l \\<circ> l2n) zs)) =\n    map h (candidate f (map n2l (map l2n zs)))", "by simp"], ["proof (state)\nthis:\n  map h (candidate f (map (n2l \\<circ> l2n) zs)) =\n  map h (candidate f (map n2l (map l2n zs)))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  map h (candidate f (map (n2l \\<circ> l2n) zs)) =\n  map h (candidate f (map n2l (map l2n zs)))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots>= map h (map n2l (candidate ?fn (map l2n zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map h (candidate f (map n2l (map l2n zs))) =\n    map h\n     (map n2l\n       (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)))", "using n2l_candidate"], ["proof (prove)\nusing this:\n  map n2l (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) ?zs) =\n  candidate f (map n2l ?zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f (map n2l (map l2n zs))) =\n    map h\n     (map n2l\n       (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)))", "by auto"], ["proof (state)\nthis:\n  map h (candidate f (map n2l (map l2n zs))) =\n  map h\n   (map n2l\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  map h (candidate f (map n2l (map l2n zs))) =\n  map h\n   (map n2l\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots> = map ?hn (candidate ?fn (map l2n zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map h\n     (map n2l\n       (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))) =\n    map (h \\<circ> n2l)\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))", "using List.map_map"], ["proof (prove)\nusing this:\n  map ?f (map ?g ?xs) = map (?f \\<circ> ?g) ?xs\n\ngoal (1 subgoal):\n 1. map h\n     (map n2l\n       (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))) =\n    map (h \\<circ> n2l)\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))", "by auto"], ["proof (state)\nthis:\n  map h\n   (map n2l\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))) =\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  map h\n   (map n2l\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))) =\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have\n  \"\\<dots> = candidate g (map ?hn (map l2n zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h \\<circ> n2l)\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n    candidate g (map (h \\<circ> n2l) (map l2n zs))", "using ne_free_theorem"], ["proof (prove)\nusing this:\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n  candidate g (map (h \\<circ> n2l) (map l2n zs))\n\ngoal (1 subgoal):\n 1. map (h \\<circ> n2l)\n     (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n    candidate g (map (h \\<circ> n2l) (map l2n zs))", "by simp"], ["proof (state)\nthis:\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n  candidate g (map (h \\<circ> n2l) (map l2n zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  map (h \\<circ> n2l)\n   (candidate (\\<lambda>x y. l2n (f (n2l x) (n2l y))) (map l2n zs)) =\n  candidate g (map (h \\<circ> n2l) (map l2n zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots> = candidate g (map ((h \\<circ> n2l) \\<circ> l2n) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g (map (h \\<circ> n2l) (map l2n zs)) =\n    candidate g (map (h \\<circ> n2l \\<circ> l2n) zs)", "using List.map_map [where f=\"h \\<circ> n2l\" and g=l2n]"], ["proof (prove)\nusing this:\n  map (h \\<circ> n2l) (map l2n ?xs) = map (h \\<circ> n2l \\<circ> l2n) ?xs\n\ngoal (1 subgoal):\n 1. candidate g (map (h \\<circ> n2l) (map l2n zs)) =\n    candidate g (map (h \\<circ> n2l \\<circ> l2n) zs)", "by simp"], ["proof (state)\nthis:\n  candidate g (map (h \\<circ> n2l) (map l2n zs)) =\n  candidate g (map (h \\<circ> n2l \\<circ> l2n) zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  candidate g (map (h \\<circ> n2l) (map l2n zs)) =\n  candidate g (map (h \\<circ> n2l \\<circ> l2n) zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots> = candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g (map (h \\<circ> n2l \\<circ> l2n) zs) =\n    candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs)", "using Fun.o_assoc [symmetric, where f=h and g=n2l and h=l2n]"], ["proof (prove)\nusing this:\n  h \\<circ> n2l \\<circ> l2n = h \\<circ> (n2l \\<circ> l2n)\n\ngoal (1 subgoal):\n 1. candidate g (map (h \\<circ> n2l \\<circ> l2n) zs) =\n    candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs)", "by simp"], ["proof (state)\nthis:\n  candidate g (map (h \\<circ> n2l \\<circ> l2n) zs) =\n  candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  candidate g (map (h \\<circ> n2l \\<circ> l2n) zs) =\n  candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots> = candidate g (map h (map (n2l \\<circ> l2n) zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs) =\n    candidate g (map h (map (n2l \\<circ> l2n) zs))", "using List.map_map [where f=h and g=\"n2l \\<circ> l2n\"]"], ["proof (prove)\nusing this:\n  map h (map (n2l \\<circ> l2n) ?xs) = map (h \\<circ> (n2l \\<circ> l2n)) ?xs\n\ngoal (1 subgoal):\n 1. candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs) =\n    candidate g (map h (map (n2l \\<circ> l2n) zs))", "by simp"], ["proof (state)\nthis:\n  candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs) =\n  candidate g (map h (map (n2l \\<circ> l2n) zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "also"], ["proof (state)\nthis:\n  candidate g (map (h \\<circ> (n2l \\<circ> l2n)) zs) =\n  candidate g (map h (map (n2l \\<circ> l2n) zs))\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "have \n  \"\\<dots> = candidate g (map h zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g (map h (map (n2l \\<circ> l2n) zs)) = candidate g (map h zs)", "using n2l_l2n_map_id [where zs=zs] and A3"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set zs \\<Longrightarrow> x \\<noteq> []) \\<Longrightarrow>\n  map (n2l \\<circ> l2n) zs = zs\n  ?x \\<in> set zs \\<Longrightarrow> ?x \\<noteq> []\n\ngoal (1 subgoal):\n 1. candidate g (map h (map (n2l \\<circ> l2n) zs)) = candidate g (map h zs)", "by auto"], ["proof (state)\nthis:\n  candidate g (map h (map (n2l \\<circ> l2n) zs)) = candidate g (map h zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "finally"], ["proof (chain)\npicking this:\n  map h (candidate f zs) = candidate g (map h zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  map h (candidate f zs) = candidate g (map h zs)\n\ngoal (1 subgoal):\n 1. map h (candidate f zs) = candidate g (map h zs)", "."], ["proof (state)\nthis:\n  map h (candidate f zs) = candidate g (map h zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Useful lemmas\\<close>"], ["", "text \\<open>\nIn this section, we state and proof several lemmas, which neither occur in the\noriginal paper nor in Isabelle's libraries.\n\\<close>"], ["", "lemma upt_map_Suc:\n  \"k > 0 \\<Longrightarrow> [0..<k + 1] = 0 # map Suc [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> [0..<k + 1] = 0 # map Suc [0..<k]", "using List.upt_conv_Cons and List.map_Suc_upt"], ["proof (prove)\nusing this:\n  ?i < ?j \\<Longrightarrow> [?i..<?j] = ?i # [Suc ?i..<?j]\n  map Suc [?m..<?n] = [Suc ?m..<Suc ?n]\n\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> [0..<k + 1] = 0 # map Suc [0..<k]", "by simp"], ["", "lemma divide_and_conquer_induct:\n  assumes A1: \"P []\"\n      and A2: \"\\<And>x. P [x]\"\n      and A3: \"\\<And>xs ys. \\<lbrakk> xs \\<noteq> [] ; ys \\<noteq> [] ; P xs ; P ys \\<rbrakk> \\<Longrightarrow> P (xs @ ys)\"\n  shows \"P zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P zs", "proof (induct zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. P []\n 2. \\<And>a zs. P zs \\<Longrightarrow> P (a # zs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P []\n 2. \\<And>a zs. P zs \\<Longrightarrow> P (a # zs)", "with A1"], ["proof (chain)\npicking this:\n  P []", "show ?case"], ["proof (prove)\nusing this:\n  P []\n\ngoal (1 subgoal):\n 1. P []", "by simp"], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>a zs. P zs \\<Longrightarrow> P (a # zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a zs. P zs \\<Longrightarrow> P (a # zs)", "case (Cons z zs)"], ["proof (state)\nthis:\n  P zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs. P zs \\<Longrightarrow> P (a # zs)", "hence IH: \"P zs\""], ["proof (prove)\nusing this:\n  P zs\n\ngoal (1 subgoal):\n 1. P zs", "by simp"], ["proof (state)\nthis:\n  P zs\n\ngoal (1 subgoal):\n 1. \\<And>a zs. P zs \\<Longrightarrow> P (a # zs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (z # zs)", "proof (cases zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. zs = [] \\<Longrightarrow> P (z # zs)\n 2. \\<And>a list. zs = a # list \\<Longrightarrow> P (z # zs)", "case Nil"], ["proof (state)\nthis:\n  zs = []\n\ngoal (2 subgoals):\n 1. zs = [] \\<Longrightarrow> P (z # zs)\n 2. \\<And>a list. zs = a # list \\<Longrightarrow> P (z # zs)", "with A2"], ["proof (chain)\npicking this:\n  P [?x]\n  zs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P [?x]\n  zs = []\n\ngoal (1 subgoal):\n 1. P (z # zs)", "by simp"], ["proof (state)\nthis:\n  P (z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> P (z # zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> P (z # zs)", "case Cons"], ["proof (state)\nthis:\n  zs = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> P (z # zs)", "with IH and A2 and A3 [where xs=\"[z]\" and ys=zs]"], ["proof (chain)\npicking this:\n  P zs\n  P [?x]\n  \\<lbrakk>[z] \\<noteq> []; zs \\<noteq> []; P [z]; P zs\\<rbrakk>\n  \\<Longrightarrow> P ([z] @ zs)\n  zs = a_ # list_", "show ?thesis"], ["proof (prove)\nusing this:\n  P zs\n  P [?x]\n  \\<lbrakk>[z] \\<noteq> []; zs \\<noteq> []; P [z]; P zs\\<rbrakk>\n  \\<Longrightarrow> P ([z] @ zs)\n  zs = a_ # list_\n\ngoal (1 subgoal):\n 1. P (z # zs)", "by auto"], ["proof (state)\nthis:\n  P (z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas divide_and_conquer \n  = divide_and_conquer_induct [case_names Nil One Partition]"], ["", "lemma all_set_inter_empty_distinct:\n  assumes \"\\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}\"\n  shows \"distinct js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct js", "using assms"], ["proof (prove)\nusing this:\n  js = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. distinct js", "proof (induct js rule: divide_and_conquer)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>xs ys.\n        [] = xs @ ys \\<Longrightarrow>\n        set xs \\<inter> set ys = {}) \\<Longrightarrow>\n    distinct []\n 2. \\<And>x.\n       (\\<And>xs ys.\n           [x] = xs @ ys \\<Longrightarrow>\n           set xs \\<inter> set ys = {}) \\<Longrightarrow>\n       distinct [x]\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "case Nil"], ["proof (state)\nthis:\n  [] = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (3 subgoals):\n 1. (\\<And>xs ys.\n        [] = xs @ ys \\<Longrightarrow>\n        set xs \\<inter> set ys = {}) \\<Longrightarrow>\n    distinct []\n 2. \\<And>x.\n       (\\<And>xs ys.\n           [x] = xs @ ys \\<Longrightarrow>\n           set xs \\<inter> set ys = {}) \\<Longrightarrow>\n       distinct [x]\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "thus ?case"], ["proof (prove)\nusing this:\n  [] = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. distinct []", "by simp"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xs ys.\n           [x] = xs @ ys \\<Longrightarrow>\n           set xs \\<inter> set ys = {}) \\<Longrightarrow>\n       distinct [x]\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xs ys.\n           [x] = xs @ ys \\<Longrightarrow>\n           set xs \\<inter> set ys = {}) \\<Longrightarrow>\n       distinct [x]\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "case One"], ["proof (state)\nthis:\n  [x_] = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xs ys.\n           [x] = xs @ ys \\<Longrightarrow>\n           set xs \\<inter> set ys = {}) \\<Longrightarrow>\n       distinct [x]\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "thus ?case"], ["proof (prove)\nusing this:\n  [x_] = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. distinct [x_]", "by simp"], ["proof (state)\nthis:\n  distinct [x_]\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "case (Partition xs ys)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "hence P: \"\\<And>as bs. xs @ ys = as @ bs \\<Longrightarrow> set as \\<inter> set bs = {}\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       xs @ ys = as @ bs \\<Longrightarrow> set as \\<inter> set bs = {}", "by simp"], ["proof (state)\nthis:\n  xs @ ys = ?as @ ?bs \\<Longrightarrow> set ?as \\<inter> set ?bs = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "have \"\\<And>xs1 xs2. xs = xs1 @ xs2 \\<Longrightarrow> set xs1 \\<inter> set xs2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2.\n       xs = xs1 @ xs2 \\<Longrightarrow> set xs1 \\<inter> set xs2 = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2.\n       xs = xs1 @ xs2 \\<Longrightarrow> set xs1 \\<inter> set xs2 = {}", "fix xs1 xs2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2.\n       xs = xs1 @ xs2 \\<Longrightarrow> set xs1 \\<inter> set xs2 = {}", "assume \"xs = xs1 @ xs2\""], ["proof (state)\nthis:\n  xs = xs1 @ xs2\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2.\n       xs = xs1 @ xs2 \\<Longrightarrow> set xs1 \\<inter> set xs2 = {}", "hence \"set xs1 \\<inter> set (xs2 @ ys) = {}\""], ["proof (prove)\nusing this:\n  xs = xs1 @ xs2\n\ngoal (1 subgoal):\n 1. set xs1 \\<inter> set (xs2 @ ys) = {}", "using P [where as=xs1 and bs=\"xs2 @ ys\"]"], ["proof (prove)\nusing this:\n  xs = xs1 @ xs2\n  xs @ ys = xs1 @ xs2 @ ys \\<Longrightarrow>\n  set xs1 \\<inter> set (xs2 @ ys) = {}\n\ngoal (1 subgoal):\n 1. set xs1 \\<inter> set (xs2 @ ys) = {}", "by simp"], ["proof (state)\nthis:\n  set xs1 \\<inter> set (xs2 @ ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2.\n       xs = xs1 @ xs2 \\<Longrightarrow> set xs1 \\<inter> set xs2 = {}", "thus \"set xs1 \\<inter> set xs2 = {}\""], ["proof (prove)\nusing this:\n  set xs1 \\<inter> set (xs2 @ ys) = {}\n\ngoal (1 subgoal):\n 1. set xs1 \\<inter> set xs2 = {}", "using List.set_append and Set.Int_Un_distrib"], ["proof (prove)\nusing this:\n  set xs1 \\<inter> set (xs2 @ ys) = {}\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n  ?A \\<inter> (?B \\<union> ?C) = ?A \\<inter> ?B \\<union> ?A \\<inter> ?C\n\ngoal (1 subgoal):\n 1. set xs1 \\<inter> set xs2 = {}", "by auto"], ["proof (state)\nthis:\n  set xs1 \\<inter> set xs2 = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ?xs1.0 @ ?xs2.0 \\<Longrightarrow> set ?xs1.0 \\<inter> set ?xs2.0 = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "with Partition"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  xs = ?xs1.0 @ ?xs2.0 \\<Longrightarrow> set ?xs1.0 \\<inter> set ?xs2.0 = {}", "have distinct_xs: \"distinct xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  xs = ?xs1.0 @ ?xs2.0 \\<Longrightarrow> set ?xs1.0 \\<inter> set ?xs2.0 = {}\n\ngoal (1 subgoal):\n 1. distinct xs", "by simp"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "have \"\\<And>ys1 ys2. ys = ys1 @ ys2 \\<Longrightarrow> set ys1 \\<inter> set ys2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2.\n       ys = ys1 @ ys2 \\<Longrightarrow> set ys1 \\<inter> set ys2 = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2.\n       ys = ys1 @ ys2 \\<Longrightarrow> set ys1 \\<inter> set ys2 = {}", "fix ys1 ys2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2.\n       ys = ys1 @ ys2 \\<Longrightarrow> set ys1 \\<inter> set ys2 = {}", "assume \"ys = ys1 @ ys2\""], ["proof (state)\nthis:\n  ys = ys1 @ ys2\n\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2.\n       ys = ys1 @ ys2 \\<Longrightarrow> set ys1 \\<inter> set ys2 = {}", "hence \"set (xs @ ys1) \\<inter> set ys2 = {}\""], ["proof (prove)\nusing this:\n  ys = ys1 @ ys2\n\ngoal (1 subgoal):\n 1. set (xs @ ys1) \\<inter> set ys2 = {}", "using P [where as=\"xs @ ys1\" and bs=ys2]"], ["proof (prove)\nusing this:\n  ys = ys1 @ ys2\n  xs @ ys = (xs @ ys1) @ ys2 \\<Longrightarrow>\n  set (xs @ ys1) \\<inter> set ys2 = {}\n\ngoal (1 subgoal):\n 1. set (xs @ ys1) \\<inter> set ys2 = {}", "by simp"], ["proof (state)\nthis:\n  set (xs @ ys1) \\<inter> set ys2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2.\n       ys = ys1 @ ys2 \\<Longrightarrow> set ys1 \\<inter> set ys2 = {}", "thus \"set ys1 \\<inter> set ys2 = {}\""], ["proof (prove)\nusing this:\n  set (xs @ ys1) \\<inter> set ys2 = {}\n\ngoal (1 subgoal):\n 1. set ys1 \\<inter> set ys2 = {}", "using List.set_append and Set.Int_Un_distrib"], ["proof (prove)\nusing this:\n  set (xs @ ys1) \\<inter> set ys2 = {}\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n  ?A \\<inter> (?B \\<union> ?C) = ?A \\<inter> ?B \\<union> ?A \\<inter> ?C\n\ngoal (1 subgoal):\n 1. set ys1 \\<inter> set ys2 = {}", "by auto"], ["proof (state)\nthis:\n  set ys1 \\<inter> set ys2 = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ys = ?ys1.0 @ ?ys2.0 \\<Longrightarrow> set ?ys1.0 \\<inter> set ?ys2.0 = {}\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "with Partition"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  ys = ?ys1.0 @ ?ys2.0 \\<Longrightarrow> set ?ys1.0 \\<inter> set ?ys2.0 = {}", "have distinct_ys: \"distinct ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  ys = ?ys1.0 @ ?ys2.0 \\<Longrightarrow> set ?ys1.0 \\<inter> set ?ys2.0 = {}\n\ngoal (1 subgoal):\n 1. distinct ys", "by simp"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys.\n            xs = xsa @ ys \\<Longrightarrow>\n            set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n        distinct xs;\n        (\\<And>xs ysa.\n            ys = xs @ ysa \\<Longrightarrow>\n            set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n        distinct ys;\n        \\<And>xsa ysa.\n           xs @ ys = xsa @ ysa \\<Longrightarrow>\n           set xsa \\<inter> set ysa = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (xs @ ys)", "from Partition and distinct_xs and distinct_ys"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  distinct xs\n  distinct ys", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys.\n      xs = xsa @ ys \\<Longrightarrow>\n      set xsa \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct xs\n  (\\<And>xs ysa.\n      ys = xs @ ysa \\<Longrightarrow>\n      set xs \\<inter> set ysa = {}) \\<Longrightarrow>\n  distinct ys\n  xs @ ys = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  distinct xs\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  distinct (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partitions_sorted:\n  assumes \"\\<And>xs ys x y. \\<lbrakk> js = xs @ ys ; x \\<in> set xs ; y \\<in> set ys \\<rbrakk> \\<Longrightarrow> x \\<le> y\"\n  shows \"sorted js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted js", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>js = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted js", "proof (induct js rule: divide_and_conquer)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>xs ys x y.\n        \\<lbrakk>[] = xs @ ys; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n    sorted []\n 2. \\<And>x.\n       (\\<And>xs ys xa y.\n           \\<lbrakk>[x] = xs @ ys; xa \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> xa \\<le> y) \\<Longrightarrow>\n       sorted [x]\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>[] = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (3 subgoals):\n 1. (\\<And>xs ys x y.\n        \\<lbrakk>[] = xs @ ys; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n    sorted []\n 2. \\<And>x.\n       (\\<And>xs ys xa y.\n           \\<lbrakk>[x] = xs @ ys; xa \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> xa \\<le> y) \\<Longrightarrow>\n       sorted [x]\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted []", "by simp"], ["proof (state)\nthis:\n  sorted []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xs ys xa y.\n           \\<lbrakk>[x] = xs @ ys; xa \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> xa \\<le> y) \\<Longrightarrow>\n       sorted [x]\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xs ys xa y.\n           \\<lbrakk>[x] = xs @ ys; xa \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> xa \\<le> y) \\<Longrightarrow>\n       sorted [x]\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "case One"], ["proof (state)\nthis:\n  \\<lbrakk>[x_] = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>xs ys xa y.\n           \\<lbrakk>[x] = xs @ ys; xa \\<in> set xs; y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> xa \\<le> y) \\<Longrightarrow>\n       sorted [x]\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[x_] = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted [x_]", "by simp"], ["proof (state)\nthis:\n  sorted [x_]\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "case (Partition xs ys)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys x y.\n      \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted xs\n  (\\<And>xs ysa x y.\n      \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ys\n  \\<lbrakk>xs @ ys = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "hence P: \"\\<And>as bs x y. \\<lbrakk> xs @ ys = as @ bs ; x \\<in> set as ; y \\<in> set bs\\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys x y.\n      \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted xs\n  (\\<And>xs ysa x y.\n      \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ys\n  \\<lbrakk>xs @ ys = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>as bs x y.\n       \\<lbrakk>xs @ ys = as @ bs; x \\<in> set as; y \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>xs @ ys = ?as @ ?bs; ?x \\<in> set ?as; ?y \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "have \"\\<And>xs1 xs2 x y. \\<lbrakk> xs = xs1 @ xs2 ; x \\<in> set xs1 ; y \\<in> set xs2 \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 x y.\n       \\<lbrakk>xs = xs1 @ xs2; x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 x y.\n       \\<lbrakk>xs = xs1 @ xs2; x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "fix xs1 xs2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 x y.\n       \\<lbrakk>xs = xs1 @ xs2; x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "assume \"xs = xs1 @ xs2\""], ["proof (state)\nthis:\n  xs = xs1 @ xs2\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 x y.\n       \\<lbrakk>xs = xs1 @ xs2; x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "hence \"\\<And>x y. \\<lbrakk> x \\<in> set xs1 ; y \\<in> set (xs2 @ ys) \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  xs = xs1 @ xs2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs1; y \\<in> set (xs2 @ ys)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "using P [where as=xs1 and bs=\"xs2 @ ys\"]"], ["proof (prove)\nusing this:\n  xs = xs1 @ xs2\n  \\<lbrakk>xs @ ys = xs1 @ xs2 @ ys; ?x \\<in> set xs1;\n   ?y \\<in> set (xs2 @ ys)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs1; y \\<in> set (xs2 @ ys)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs1; ?y \\<in> set (xs2 @ ys)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs1 xs2 x y.\n       \\<lbrakk>xs = xs1 @ xs2; x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "thus \"\\<And>x y. \\<lbrakk> x \\<in> set xs1 ; y \\<in> set xs2 \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs1; ?y \\<in> set (xs2 @ ys)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "using List.set_append"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs1; ?y \\<in> set (xs2 @ ys)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set xs1; y \\<in> set xs2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs1; ?y \\<in> set xs2\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?xs1.0 @ ?xs2.0; ?x \\<in> set ?xs1.0;\n   ?y \\<in> set ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "with Partition"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys x y.\n      \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted xs\n  (\\<And>xs ysa x y.\n      \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ys\n  \\<lbrakk>xs @ ys = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  \\<lbrakk>xs = ?xs1.0 @ ?xs2.0; ?x \\<in> set ?xs1.0;\n   ?y \\<in> set ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y", "have sorted_xs: \"sorted xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys x y.\n      \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted xs\n  (\\<And>xs ysa x y.\n      \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ys\n  \\<lbrakk>xs @ ys = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  \\<lbrakk>xs = ?xs1.0 @ ?xs2.0; ?x \\<in> set ?xs1.0;\n   ?y \\<in> set ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted xs", "by simp"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "have \"\\<And>ys1 ys2 x y. \\<lbrakk> ys = ys1 @ ys2 ; x \\<in> set ys1 ; y \\<in> set ys2 \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2 x y.\n       \\<lbrakk>ys = ys1 @ ys2; x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2 x y.\n       \\<lbrakk>ys = ys1 @ ys2; x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "fix ys1 ys2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2 x y.\n       \\<lbrakk>ys = ys1 @ ys2; x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "assume \"ys = ys1 @ ys2\""], ["proof (state)\nthis:\n  ys = ys1 @ ys2\n\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2 x y.\n       \\<lbrakk>ys = ys1 @ ys2; x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "hence \"\\<And>x y. \\<lbrakk> x \\<in> set (xs @ ys1) ; y \\<in> set ys2 \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  ys = ys1 @ ys2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (xs @ ys1); y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "using P [where as=\"xs @ ys1\" and bs=ys2]"], ["proof (prove)\nusing this:\n  ys = ys1 @ ys2\n  \\<lbrakk>xs @ ys = (xs @ ys1) @ ys2; ?x \\<in> set (xs @ ys1);\n   ?y \\<in> set ys2\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (xs @ ys1); y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (xs @ ys1); ?y \\<in> set ys2\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>ys1 ys2 x y.\n       \\<lbrakk>ys = ys1 @ ys2; x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "thus \"\\<And>x y. \\<lbrakk> x \\<in> set ys1 ; y \\<in> set ys2 \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (xs @ ys1); ?y \\<in> set ys2\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "using List.set_append"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (xs @ ys1); ?y \\<in> set ys2\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set ys1; y \\<in> set ys2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set ys1; ?y \\<in> set ys2\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ys = ?ys1.0 @ ?ys2.0; ?x \\<in> set ?ys1.0;\n   ?y \\<in> set ?ys2.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "with Partition"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys x y.\n      \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted xs\n  (\\<And>xs ysa x y.\n      \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ys\n  \\<lbrakk>xs @ ys = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  \\<lbrakk>ys = ?ys1.0 @ ?ys2.0; ?x \\<in> set ?ys1.0;\n   ?y \\<in> set ?ys2.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y", "have sorted_ys: \"sorted ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  (\\<And>xsa ys x y.\n      \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted xs\n  (\\<And>xs ysa x y.\n      \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ys\n  \\<lbrakk>xs @ ys = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  \\<lbrakk>ys = ?ys1.0 @ ?ys2.0; ?x \\<in> set ?ys1.0;\n   ?y \\<in> set ?ys2.0\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted ys", "by simp"], ["proof (state)\nthis:\n  sorted ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "have \"\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y", "using P [where as=xs and bs=ys]"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs @ ys = xs @ ys; ?x \\<in> set xs; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        (\\<And>xsa ys x y.\n            \\<lbrakk>xs = xsa @ ys; x \\<in> set xsa; y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted xs;\n        (\\<And>xs ysa x y.\n            \\<lbrakk>ys = xs @ ysa; x \\<in> set xs; y \\<in> set ysa\\<rbrakk>\n            \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n        sorted ys;\n        \\<And>xsa ysa x y.\n           \\<lbrakk>xs @ ys = xsa @ ysa; x \\<in> set xsa;\n            y \\<in> set ysa\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (xs @ ys)", "with sorted_xs and sorted_ys"], ["proof (chain)\npicking this:\n  sorted xs\n  sorted ys\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y", "show ?case"], ["proof (prove)\nusing this:\n  sorted xs\n  sorted ys\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\n\ngoal (1 subgoal):\n 1. sorted (xs @ ys)", "using List.sorted_append"], ["proof (prove)\nusing this:\n  sorted xs\n  sorted ys\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\n  sorted (?xs @ ?ys) =\n  (sorted ?xs \\<and>\n   sorted ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. x \\<le> y))\n\ngoal (1 subgoal):\n 1. sorted (xs @ ys)", "by auto"], ["proof (state)\nthis:\n  sorted (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Preparatory Material\\<close>"], ["", "text \\<open>\nIn the original paper, the following lemmas L1 to L8 are given without a proof,\nalthough it is hinted there that most of them follow from parametricity\nproperties \\cite{TypesAbstractionsAndParametricPolymorphism,TheoremsForFree}.\nAlternatively, most of them can be shown by induction over lists.\nHowever, since we are using Isabelle's list datatype, we rely on already\nexisting results.\n\\<close>"], ["", "lemma L1: \"map g (map f xs) = map (g \\<circ> f) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (map f xs) = map (g \\<circ> f) xs", "using List.map_map"], ["proof (prove)\nusing this:\n  map ?f (map ?g ?xs) = map (?f \\<circ> ?g) ?xs\n\ngoal (1 subgoal):\n 1. map g (map f xs) = map (g \\<circ> f) xs", "by auto"], ["", "lemma L2: \"length (map f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map f xs) = length xs", "using List.length_map"], ["proof (prove)\nusing this:\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (map f xs) = length xs", "by simp"], ["", "lemma L3: \"take k (map f xs) = map f (take k xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (map f xs) = map f (take k xs)", "using List.take_map"], ["proof (prove)\nusing this:\n  take ?n (map ?f ?xs) = map ?f (take ?n ?xs)\n\ngoal (1 subgoal):\n 1. take k (map f xs) = map f (take k xs)", "by auto"], ["", "lemma L4: \"map f \\<circ> wrap = wrap \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f \\<circ> wrap = wrap \\<circ> f", "by (simp add: fun_eq_iff)"], ["", "lemma L5: \"map f (xs @ ys) = (map f xs) @ (map f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (xs @ ys) = map f xs @ map f ys", "using List.map_append"], ["proof (prove)\nusing this:\n  map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys\n\ngoal (1 subgoal):\n 1. map f (xs @ ys) = map f xs @ map f ys", "by simp"], ["", "lemma L6: \"k < length xs \\<Longrightarrow> (map f xs) ! k = f (xs ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length xs \\<Longrightarrow> map f xs ! k = f (xs ! k)", "using List.nth_map"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. k < length xs \\<Longrightarrow> map f xs ! k = f (xs ! k)", "by simp"], ["", "lemma L7: \"\\<And>k. k < length xs \\<Longrightarrow> map (nth xs) [0..<k + 1] = take (k + 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       map ((!) xs) [0..<k + 1] = take (k + 1) xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < length [] \\<Longrightarrow>\n       map ((!) []) [0..<k + 1] = take (k + 1) []\n 2. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> map ((!) (a # xs)) [0..<k + 1] =\n                         take (k + 1) (a # xs)", "case Nil"], ["proof (state)\nthis:\n  k < length []\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k < length [] \\<Longrightarrow>\n       map ((!) []) [0..<k + 1] = take (k + 1) []\n 2. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> map ((!) (a # xs)) [0..<k + 1] =\n                         take (k + 1) (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  k < length []\n\ngoal (1 subgoal):\n 1. map ((!) []) [0..<k + 1] = take (k + 1) []", "by simp"], ["proof (state)\nthis:\n  map ((!) []) [0..<k + 1] = take (k + 1) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> map ((!) (a # xs)) [0..<k + 1] =\n                         take (k + 1) (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> map ((!) (a # xs)) [0..<k + 1] =\n                         take (k + 1) (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?k < length xs \\<Longrightarrow>\n  map ((!) xs) [0..<?k + 1] = take (?k + 1) xs\n  k < length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> map ((!) (a # xs)) [0..<k + 1] =\n                         take (k + 1) (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  ?k < length xs \\<Longrightarrow>\n  map ((!) xs) [0..<?k + 1] = take (?k + 1) xs\n  k < length (x # xs)\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k.\n                k < length xs \\<Longrightarrow>\n                map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n     k < length (x # xs); k = 0\\<rbrakk>\n    \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k.\n                k < length xs \\<Longrightarrow>\n                map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n     k < length (x # xs); k = 0\\<rbrakk>\n    \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)", "by simp"], ["proof (state)\nthis:\n  map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "hence \"k > 0\""], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "hence \"map (nth (x # xs)) [0..<k + 1] \n           = map (nth (x # xs)) (0 # map Suc [0..<k])\""], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [0..<k + 1] =\n    map ((!) (x # xs)) (0 # map Suc [0..<k])", "using upt_map_Suc"], ["proof (prove)\nusing this:\n  0 < k\n  0 < ?k \\<Longrightarrow> [0..<?k + 1] = 0 # map Suc [0..<?k]\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [0..<k + 1] =\n    map ((!) (x # xs)) (0 # map Suc [0..<k])", "by simp"], ["proof (state)\nthis:\n  map ((!) (x # xs)) [0..<k + 1] = map ((!) (x # xs)) (0 # map Suc [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "also"], ["proof (state)\nthis:\n  map ((!) (x # xs)) [0..<k + 1] = map ((!) (x # xs)) (0 # map Suc [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "have \"\\<dots> = ((x # xs) ! 0) # (map (nth (x # xs) \\<circ> Suc) [0..<k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) (0 # map Suc [0..<k]) =\n    (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k]", "using L1"], ["proof (prove)\nusing this:\n  map ?g (map ?f ?xs) = map (?g \\<circ> ?f) ?xs\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) (0 # map Suc [0..<k]) =\n    (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k]", "by simp"], ["proof (state)\nthis:\n  map ((!) (x # xs)) (0 # map Suc [0..<k]) =\n  (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "also"], ["proof (state)\nthis:\n  map ((!) (x # xs)) (0 # map Suc [0..<k]) =\n  (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "have \"\\<dots> = x # map (nth xs) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k] =\n    x # map ((!) xs) [0..<k]", "by simp"], ["proof (state)\nthis:\n  (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k] =\n  x # map ((!) xs) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "also"], ["proof (state)\nthis:\n  (x # xs) ! 0 # map ((!) (x # xs) \\<circ> Suc) [0..<k] =\n  x # map ((!) xs) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "have \"\\<dots> = x # map (nth xs) [0..<k' + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # map ((!) xs) [0..<k] = x # map ((!) xs) [0..<k' + 1]", "using Suc"], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. x # map ((!) xs) [0..<k] = x # map ((!) xs) [0..<k' + 1]", "by simp"], ["proof (state)\nthis:\n  x # map ((!) xs) [0..<k] = x # map ((!) xs) [0..<k' + 1]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "also"], ["proof (state)\nthis:\n  x # map ((!) xs) [0..<k] = x # map ((!) xs) [0..<k' + 1]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "have \"\\<dots> = x # take (k' + 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # map ((!) xs) [0..<k' + 1] = x # take (k' + 1) xs", "using Cons and Suc"], ["proof (prove)\nusing this:\n  ?k < length xs \\<Longrightarrow>\n  map ((!) xs) [0..<?k + 1] = take (?k + 1) xs\n  k < length (x # xs)\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. x # map ((!) xs) [0..<k' + 1] = x # take (k' + 1) xs", "by simp"], ["proof (state)\nthis:\n  x # map ((!) xs) [0..<k' + 1] = x # take (k' + 1) xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "also"], ["proof (state)\nthis:\n  x # map ((!) xs) [0..<k' + 1] = x # take (k' + 1) xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "have \"\\<dots> = take (k + 1) (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # take (k' + 1) xs = take (k + 1) (x # xs)", "using Suc"], ["proof (prove)\nusing this:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. x # take (k' + 1) xs = take (k + 1) (x # xs)", "by simp"], ["proof (state)\nthis:\n  x # take (k' + 1) xs = take (k + 1) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>k.\n                   k < length xs \\<Longrightarrow>\n                   map ((!) xs) [0..<k + 1] = take (k + 1) xs;\n        k < length (x # xs); k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map ((!) (x # xs)) [0..<k + 1] =\n                         take (k + 1) (x # xs)", "finally"], ["proof (chain)\npicking this:\n  map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)\n\ngoal (1 subgoal):\n 1. map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)", "."], ["proof (state)\nthis:\n  map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((!) (x # xs)) [0..<k + 1] = take (k + 1) (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIn Isabelle's list theory, a similar result for \\<open>foldl\\<close> already exists.\nTherefore, it is easy to prove the following lemma for \\<open>foldl1\\<close>.\nNote that this lemma does not occur in the original paper.\n\\<close>"], ["", "lemma foldl1_append:\n  assumes \"xs \\<noteq> []\"\n  shows \"foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "have non_empty_list: \"xs \\<noteq> [] \\<Longrightarrow> \\<exists>y ys. xs = y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> \\<exists>y ys. xs = y # ys", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> \\<exists>y ys. xs = y # ys\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "with assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  xs \\<noteq> [] \\<Longrightarrow> \\<exists>y ys. xs = y # ys", "obtain x xs' where x_xs_def: \"xs = x # xs'\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  xs \\<noteq> [] \\<Longrightarrow> \\<exists>y ys. xs = y # ys\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'. xs = x # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "have \"foldl1 f (xs @ ys) = foldl f x (xs' @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl f x (xs' @ ys)", "using x_xs_def"], ["proof (prove)\nusing this:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl f x (xs' @ ys)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (xs @ ys) = foldl f x (xs' @ ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "also"], ["proof (state)\nthis:\n  foldl1 f (xs @ ys) = foldl f x (xs' @ ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "have \"\\<dots> = foldl f (foldl f x xs') ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f x (xs' @ ys) = foldl f (foldl f x xs') ys", "using List.foldl_append"], ["proof (prove)\nusing this:\n  foldl ?f ?a (?xs @ ?ys) = foldl ?f (foldl ?f ?a ?xs) ?ys\n\ngoal (1 subgoal):\n 1. foldl f x (xs' @ ys) = foldl f (foldl f x xs') ys", "by simp"], ["proof (state)\nthis:\n  foldl f x (xs' @ ys) = foldl f (foldl f x xs') ys\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "also"], ["proof (state)\nthis:\n  foldl f x (xs' @ ys) = foldl f (foldl f x xs') ys\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "have \"\\<dots> = foldl f (foldl1 f (x # xs')) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f (foldl f x xs') ys = foldl f (foldl1 f (x # xs')) ys", "by simp"], ["proof (state)\nthis:\n  foldl f (foldl f x xs') ys = foldl f (foldl1 f (x # xs')) ys\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "also"], ["proof (state)\nthis:\n  foldl f (foldl f x xs') ys = foldl f (foldl1 f (x # xs')) ys\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "have \"\\<dots> = foldl1 f (foldl1 f xs # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f (foldl1 f (x # xs')) ys = foldl1 f (foldl1 f xs # ys)", "using x_xs_def"], ["proof (prove)\nusing this:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. foldl f (foldl1 f (x # xs')) ys = foldl1 f (foldl1 f xs # ys)", "by simp"], ["proof (state)\nthis:\n  foldl f (foldl1 f (x # xs')) ys = foldl1 f (foldl1 f xs # ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "finally"], ["proof (chain)\npicking this:\n  foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)", "."], ["proof (state)\nthis:\n  foldl1 f (xs @ ys) = foldl1 f (foldl1 f xs # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThis is a special induction scheme suitable for proving L8. It is not mentioned\nin the original paper.\n\\<close>"], ["", "lemma foldl1_induct':\n  assumes \"\\<And>f x. P f [x]\"\n      and \"\\<And>f x y. P f [x, y]\" \n      and \"\\<And>f x y z zs. P f (f x y # z # zs) \\<Longrightarrow> P f (x # y # z # zs)\"\n      and \"\\<And>f. P f []\"\n  shows \"P f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P f xs", "proof (induct xs rule: List.length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P f ys \\<Longrightarrow>\n       P f xs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P f ys \\<Longrightarrow>\n       P f xs", "assume A: \"\\<forall>ys::'a list. length ys < length (xs::'a list) \\<longrightarrow> P f ys\""], ["proof (state)\nthis:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P f ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow> P f ys \\<Longrightarrow>\n       P f xs", "thus \"P f xs\""], ["proof (prove)\nusing this:\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P f ys\n\ngoal (1 subgoal):\n 1. P f xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> P f xs\n 2. \\<And>a list.\n       \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> P f xs\n 2. \\<And>a list.\n       \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "with assms"], ["proof (chain)\npicking this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = []\n\ngoal (1 subgoal):\n 1. P f xs", "by simp"], ["proof (state)\nthis:\n  P f xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "case (Cons x1 xs1)"], ["proof (state)\nthis:\n  xs = x1 # xs1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "hence xs1: \"xs = x1 # xs1\""], ["proof (prove)\nusing this:\n  xs = x1 # xs1\n\ngoal (1 subgoal):\n 1. xs = x1 # xs1", "by simp"], ["proof (state)\nthis:\n  xs = x1 # xs1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys. length ys < length xs \\<longrightarrow> P f ys;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = x1 # xs1\n\ngoal (1 subgoal):\n 1. P f xs", "proof (cases xs1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x1 # xs1; xs1 = []\\<rbrakk> \\<Longrightarrow> P f xs\n 2. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs1; xs1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "case Nil"], ["proof (state)\nthis:\n  xs1 = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x1 # xs1; xs1 = []\\<rbrakk> \\<Longrightarrow> P f xs\n 2. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs1; xs1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "with assms and xs1"], ["proof (chain)\npicking this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = x1 # xs1\n  xs1 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = x1 # xs1\n  xs1 = []\n\ngoal (1 subgoal):\n 1. P f xs", "by simp"], ["proof (state)\nthis:\n  P f xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs1; xs1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs1; xs1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "case (Cons x2 xs2)"], ["proof (state)\nthis:\n  xs1 = x2 # xs2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs1; xs1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "hence xs2: \"xs1 = x2 # xs2\""], ["proof (prove)\nusing this:\n  xs1 = x2 # xs2\n\ngoal (1 subgoal):\n 1. xs1 = x2 # xs2", "by simp"], ["proof (state)\nthis:\n  xs1 = x2 # xs2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = x1 # xs1; xs1 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs1 = x2 # xs2\n\ngoal (1 subgoal):\n 1. P f xs", "proof (cases xs2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs1 = x2 # xs2; xs2 = []\\<rbrakk> \\<Longrightarrow> P f xs\n 2. \\<And>a list.\n       \\<lbrakk>xs1 = x2 # xs2; xs2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "case Nil"], ["proof (state)\nthis:\n  xs2 = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs1 = x2 # xs2; xs2 = []\\<rbrakk> \\<Longrightarrow> P f xs\n 2. \\<And>a list.\n       \\<lbrakk>xs1 = x2 # xs2; xs2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "with assms and xs1 and xs2"], ["proof (chain)\npicking this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = x1 # xs1\n  xs1 = x2 # xs2\n  xs2 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = x1 # xs1\n  xs1 = x2 # xs2\n  xs2 = []\n\ngoal (1 subgoal):\n 1. P f xs", "by simp"], ["proof (state)\nthis:\n  P f xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs1 = x2 # xs2; xs2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs1 = x2 # xs2; xs2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "case (Cons x3 xs3)"], ["proof (state)\nthis:\n  xs2 = x3 # xs3\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs1 = x2 # xs2; xs2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "hence \"xs2 = x3 # xs3\""], ["proof (prove)\nusing this:\n  xs2 = x3 # xs3\n\ngoal (1 subgoal):\n 1. xs2 = x3 # xs3", "by simp"], ["proof (state)\nthis:\n  xs2 = x3 # xs3\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs1 = x2 # xs2; xs2 = a # list\\<rbrakk>\n       \\<Longrightarrow> P f xs", "with assms and xs1 xs2 and A"], ["proof (chain)\npicking this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = x1 # xs1\n  xs1 = x2 # xs2\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P f ys\n  xs2 = x3 # xs3", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?f [?x]\n  P ?f [?x, ?y]\n  P ?f (?f ?x ?y # ?z # ?zs) \\<Longrightarrow> P ?f (?x # ?y # ?z # ?zs)\n  P ?f []\n  xs = x1 # xs1\n  xs1 = x2 # xs2\n  \\<forall>ys. length ys < length xs \\<longrightarrow> P f ys\n  xs2 = x3 # xs3\n\ngoal (1 subgoal):\n 1. P f xs", "by simp"], ["proof (state)\nthis:\n  P f xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P f xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P f xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P f xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas foldl1_induct = foldl1_induct' [case_names One Two More Nil]"], ["", "lemma L8:\n  assumes \"associative f\"\n      and \"xs \\<noteq> []\"\n      and \"ys \\<noteq> []\"\n  shows \"foldl1 f (xs @ ys) = f (foldl1 f xs) (foldl1 f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = f (foldl1 f xs) (foldl1 f ys)", "using assms"], ["proof (prove)\nusing this:\n  associative f\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ ys) = f (foldl1 f xs) (foldl1 f ys)", "proof (induct f ys rule: foldl1_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "case (One f y)"], ["proof (state)\nthis:\n  associative f\n  xs \\<noteq> []\n  [y] \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"foldl1 f (xs @ [y]) \n   = foldl1 f (foldl1 f xs # [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ [y]) = foldl1 f [foldl1 f xs, y]", "using foldl1_append [where xs=xs] and One"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  foldl1 ?f (xs @ ?ys) = foldl1 ?f (foldl1 ?f xs # ?ys)\n  associative f\n  xs \\<noteq> []\n  [y] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ [y]) = foldl1 f [foldl1 f xs, y]", "by simp"], ["proof (state)\nthis:\n  foldl1 f (xs @ [y]) = foldl1 f [foldl1 f xs, y]\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (xs @ [y]) = foldl1 f [foldl1 f xs, y]\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = f (foldl1 f xs) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f [foldl1 f xs, y] = f (foldl1 f xs) y", "by simp"], ["proof (state)\nthis:\n  foldl1 f [foldl1 f xs, y] = f (foldl1 f xs) y\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f [foldl1 f xs, y] = f (foldl1 f xs) y\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = f (foldl1 f xs) (foldl1 f [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (foldl1 f xs) y = f (foldl1 f xs) (foldl1 f [y])", "by simp"], ["proof (state)\nthis:\n  f (foldl1 f xs) y = f (foldl1 f xs) (foldl1 f [y])\n\ngoal (4 subgoals):\n 1. \\<And>f x.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x]) =\n                         f (foldl1 f xs) (foldl1 f [x])\n 2. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 3. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 4. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "finally"], ["proof (chain)\npicking this:\n  foldl1 f (xs @ [y]) = f (foldl1 f xs) (foldl1 f [y])", "show ?case"], ["proof (prove)\nusing this:\n  foldl1 f (xs @ [y]) = f (foldl1 f xs) (foldl1 f [y])\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ [y]) = f (foldl1 f xs) (foldl1 f [y])", "."], ["proof (state)\nthis:\n  foldl1 f (xs @ [y]) = f (foldl1 f xs) (foldl1 f [y])\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "case (Two f x y)"], ["proof (state)\nthis:\n  associative f\n  xs \\<noteq> []\n  [x, y] \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"foldl1 f (xs @ [x, y]) \n   = foldl1 f (foldl1 f xs # [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ [x, y]) = foldl1 f [foldl1 f xs, x, y]", "using foldl1_append [where xs=xs] and Two"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  foldl1 ?f (xs @ ?ys) = foldl1 ?f (foldl1 ?f xs # ?ys)\n  associative f\n  xs \\<noteq> []\n  [x, y] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ [x, y]) = foldl1 f [foldl1 f xs, x, y]", "by simp"], ["proof (state)\nthis:\n  foldl1 f (xs @ [x, y]) = foldl1 f [foldl1 f xs, x, y]\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (xs @ [x, y]) = foldl1 f [foldl1 f xs, x, y]\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = foldl1 f (f (foldl1 f xs) x # [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f [foldl1 f xs, x, y] = foldl1 f [f (foldl1 f xs) x, y]", "by simp"], ["proof (state)\nthis:\n  foldl1 f [foldl1 f xs, x, y] = foldl1 f [f (foldl1 f xs) x, y]\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f [foldl1 f xs, x, y] = foldl1 f [f (foldl1 f xs) x, y]\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = f (f (foldl1 f xs) x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f [f (foldl1 f xs) x, y] = f (f (foldl1 f xs) x) y", "by simp"], ["proof (state)\nthis:\n  foldl1 f [f (foldl1 f xs) x, y] = f (f (foldl1 f xs) x) y\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f [f (foldl1 f xs) x, y] = f (f (foldl1 f xs) x) y\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = f (foldl1 f xs) (f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (f (foldl1 f xs) x) y = f (foldl1 f xs) (f x y)", "using Two"], ["proof (prove)\nusing this:\n  associative f\n  xs \\<noteq> []\n  [x, y] \\<noteq> []\n\ngoal (1 subgoal):\n 1. f (f (foldl1 f xs) x) y = f (foldl1 f xs) (f x y)", "unfolding associative_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z. f x (f y z) = f (f x y) z\n  xs \\<noteq> []\n  [x, y] \\<noteq> []\n\ngoal (1 subgoal):\n 1. f (f (foldl1 f xs) x) y = f (foldl1 f xs) (f x y)", "by simp"], ["proof (state)\nthis:\n  f (f (foldl1 f xs) x) y = f (foldl1 f xs) (f x y)\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  f (f (foldl1 f xs) x) y = f (foldl1 f xs) (f x y)\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = f (foldl1 f xs) (foldl1 f [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (foldl1 f xs) (f x y) = f (foldl1 f xs) (foldl1 f [x, y])", "by simp"], ["proof (state)\nthis:\n  f (foldl1 f xs) (f x y) = f (foldl1 f xs) (foldl1 f [x, y])\n\ngoal (3 subgoals):\n 1. \\<And>f x y.\n       \\<lbrakk>associative f; xs \\<noteq> []; [x, y] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ [x, y]) =\n                         f (foldl1 f xs) (foldl1 f [x, y])\n 2. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 3. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "finally"], ["proof (chain)\npicking this:\n  foldl1 f (xs @ [x, y]) = f (foldl1 f xs) (foldl1 f [x, y])", "show ?case"], ["proof (prove)\nusing this:\n  foldl1 f (xs @ [x, y]) = f (foldl1 f xs) (foldl1 f [x, y])\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ [x, y]) = f (foldl1 f xs) (foldl1 f [x, y])", "."], ["proof (state)\nthis:\n  foldl1 f (xs @ [x, y]) = f (foldl1 f xs) (foldl1 f [x, y])\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "case (More f x y z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>associative f; xs \\<noteq> [];\n   f x y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                    f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n  associative f\n  xs \\<noteq> []\n  x # y # z # zs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "hence IH: \"foldl1 f (xs @ f x y # z # zs) \n             = f (foldl1 f xs) (foldl1 f (f x y # z # zs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>associative f; xs \\<noteq> [];\n   f x y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                    f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n  associative f\n  xs \\<noteq> []\n  x # y # z # zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ f x y # z # zs) =\n    f (foldl1 f xs) (foldl1 f (f x y # z # zs))", "by simp"], ["proof (state)\nthis:\n  foldl1 f (xs @ f x y # z # zs) =\n  f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"foldl1 f (xs @ x # y # z # zs) \n   = foldl1 f (foldl1 f xs # x # y # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ x # y # z # zs) = foldl1 f (foldl1 f xs # x # y # z # zs)", "using foldl1_append [where xs=xs] and More"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  foldl1 ?f (xs @ ?ys) = foldl1 ?f (foldl1 ?f xs # ?ys)\n  \\<lbrakk>associative f; xs \\<noteq> [];\n   f x y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                    f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n  associative f\n  xs \\<noteq> []\n  x # y # z # zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ x # y # z # zs) = foldl1 f (foldl1 f xs # x # y # z # zs)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (xs @ x # y # z # zs) = foldl1 f (foldl1 f xs # x # y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (xs @ x # y # z # zs) = foldl1 f (foldl1 f xs # x # y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = foldl1 f (f (foldl1 f xs) x # y # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (foldl1 f xs # x # y # z # zs) =\n    foldl1 f (f (foldl1 f xs) x # y # z # zs)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (foldl1 f xs # x # y # z # zs) =\n  foldl1 f (f (foldl1 f xs) x # y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (foldl1 f xs # x # y # z # zs) =\n  foldl1 f (f (foldl1 f xs) x # y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = foldl1 f (f (f (foldl1 f xs) x) y # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (f (foldl1 f xs) x # y # z # zs) =\n    foldl1 f (f (f (foldl1 f xs) x) y # z # zs)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (f (foldl1 f xs) x # y # z # zs) =\n  foldl1 f (f (f (foldl1 f xs) x) y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (f (foldl1 f xs) x # y # z # zs) =\n  foldl1 f (f (f (foldl1 f xs) x) y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = foldl1 f (f (foldl1 f xs) (f x y) # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (f (f (foldl1 f xs) x) y # z # zs) =\n    foldl1 f (f (foldl1 f xs) (f x y) # z # zs)", "using More"], ["proof (prove)\nusing this:\n  \\<lbrakk>associative f; xs \\<noteq> [];\n   f x y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                    f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n  associative f\n  xs \\<noteq> []\n  x # y # z # zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (f (f (foldl1 f xs) x) y # z # zs) =\n    foldl1 f (f (foldl1 f xs) (f x y) # z # zs)", "unfolding associative_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x y z. f x (f y z) = f (f x y) z; xs \\<noteq> [];\n   f x y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                    f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n  \\<forall>x y z. f x (f y z) = f (f x y) z\n  xs \\<noteq> []\n  x # y # z # zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (f (f (foldl1 f xs) x) y # z # zs) =\n    foldl1 f (f (foldl1 f xs) (f x y) # z # zs)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (f (f (foldl1 f xs) x) y # z # zs) =\n  foldl1 f (f (foldl1 f xs) (f x y) # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (f (f (foldl1 f xs) x) y # z # zs) =\n  foldl1 f (f (foldl1 f xs) (f x y) # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = foldl1 f (foldl1 f xs # f x y # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (f (foldl1 f xs) (f x y) # z # zs) =\n    foldl1 f (foldl1 f xs # f x y # z # zs)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (f (foldl1 f xs) (f x y) # z # zs) =\n  foldl1 f (foldl1 f xs # f x y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (f (foldl1 f xs) (f x y) # z # zs) =\n  foldl1 f (foldl1 f xs # f x y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = foldl1 f (xs @ f x y # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (foldl1 f xs # f x y # z # zs) = foldl1 f (xs @ f x y # z # zs)", "using foldl1_append [where xs=xs] and More"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  foldl1 ?f (xs @ ?ys) = foldl1 ?f (foldl1 ?f xs # ?ys)\n  \\<lbrakk>associative f; xs \\<noteq> [];\n   f x y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                    f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n  associative f\n  xs \\<noteq> []\n  x # y # z # zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f (foldl1 f xs # f x y # z # zs) = foldl1 f (xs @ f x y # z # zs)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (foldl1 f xs # f x y # z # zs) = foldl1 f (xs @ f x y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "also"], ["proof (state)\nthis:\n  foldl1 f (foldl1 f xs # f x y # z # zs) = foldl1 f (xs @ f x y # z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "have \n  \"\\<dots> = f (foldl1 f xs) (foldl1 f (x # y # z # zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (xs @ f x y # z # zs) =\n    f (foldl1 f xs) (foldl1 f (x # y # z # zs))", "using IH"], ["proof (prove)\nusing this:\n  foldl1 f (xs @ f x y # z # zs) =\n  f (foldl1 f xs) (foldl1 f (f x y # z # zs))\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ f x y # z # zs) =\n    f (foldl1 f xs) (foldl1 f (x # y # z # zs))", "by simp"], ["proof (state)\nthis:\n  foldl1 f (xs @ f x y # z # zs) =\n  f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n\ngoal (2 subgoals):\n 1. \\<And>f x y z zs.\n       \\<lbrakk>\\<lbrakk>associative f; xs \\<noteq> [];\n                 f x y # z # zs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> foldl1 f (xs @ f x y # z # zs) =\n                                  f (foldl1 f xs)\n                                   (foldl1 f (f x y # z # zs));\n        associative f; xs \\<noteq> []; x # y # z # zs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ x # y # z # zs) =\n                         f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n 2. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "finally"], ["proof (chain)\npicking this:\n  foldl1 f (xs @ x # y # z # zs) =\n  f (foldl1 f xs) (foldl1 f (x # y # z # zs))", "show ?case"], ["proof (prove)\nusing this:\n  foldl1 f (xs @ x # y # z # zs) =\n  f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n\ngoal (1 subgoal):\n 1. foldl1 f (xs @ x # y # z # zs) =\n    f (foldl1 f xs) (foldl1 f (x # y # z # zs))", "."], ["proof (state)\nthis:\n  foldl1 f (xs @ x # y # z # zs) =\n  f (foldl1 f xs) (foldl1 f (x # y # z # zs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "case Nil"], ["proof (state)\nthis:\n  associative f_\n  xs \\<noteq> []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>associative f; xs \\<noteq> []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (xs @ []) = f (foldl1 f xs) (foldl1 f [])", "thus ?case"], ["proof (prove)\nusing this:\n  associative f_\n  xs \\<noteq> []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f_ (xs @ []) = f_ (foldl1 f_ xs) (foldl1 f_ [])", "by simp"], ["proof (state)\nthis:\n  foldl1 f_ (xs @ []) = f_ (foldl1 f_ xs) (foldl1 f_ [])\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe next lemma is applied in several following proofs whenever the equivalence\nof two lists is shown.\n\\<close>"], ["", "lemma Lemma_2:\n  assumes \"length xs = length ys\"\n      and \"\\<And>k. k < length xs \\<Longrightarrow> xs ! k = ys ! k\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  ?k < length xs \\<Longrightarrow> xs ! ?k = ys ! ?k\n\ngoal (1 subgoal):\n 1. xs = ys", "by (auto simp: List.list_eq_iff_nth_eq)"], ["", "text \\<open>\nIn the original paper, this lemma and its proof appear inside of Lemma 3.\nHowever, this property will be useful also in later proofs and is thus \nseparated.\n\\<close>"], ["", "lemma foldl1_map:\n  assumes \"associative f\"\n      and \"xs \\<noteq> []\"\n      and \"ys \\<noteq> []\"\n  shows \"foldl1 f (map h (xs @ ys)) \n         = f (foldl1 f (map h xs)) (foldl1 f (map h ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "have \n  \"foldl1 f (map h (xs @ ys)) \n   = foldl1 f (map h xs @ map h ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) = foldl1 f (map h xs @ map h ys)", "using L5"], ["proof (prove)\nusing this:\n  map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) = foldl1 f (map h xs @ map h ys)", "by simp"], ["proof (state)\nthis:\n  foldl1 f (map h (xs @ ys)) = foldl1 f (map h xs @ map h ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "also"], ["proof (state)\nthis:\n  foldl1 f (map h (xs @ ys)) = foldl1 f (map h xs @ map h ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "have \n  \"\\<dots> = f (foldl1 f (map h xs)) (foldl1 f (map h ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (map h xs @ map h ys) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "using assms and L8 [where f=f]"], ["proof (prove)\nusing this:\n  associative f\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>associative f; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (?xs @ ?ys) = f (foldl1 f ?xs) (foldl1 f ?ys)\n\ngoal (1 subgoal):\n 1. foldl1 f (map h xs @ map h ys) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "by auto"], ["proof (state)\nthis:\n  foldl1 f (map h xs @ map h ys) =\n  f (foldl1 f (map h xs)) (foldl1 f (map h ys))\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "finally"], ["proof (chain)\npicking this:\n  foldl1 f (map h (xs @ ys)) = f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl1 f (map h (xs @ ys)) = f (foldl1 f (map h xs)) (foldl1 f (map h ys))\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (xs @ ys)) =\n    f (foldl1 f (map h xs)) (foldl1 f (map h ys))", "."], ["proof (state)\nthis:\n  foldl1 f (map h (xs @ ys)) = f (foldl1 f (map h xs)) (foldl1 f (map h ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lemma_3:\n  fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n    and h :: \"nat \\<Rightarrow> 'a\"\n  assumes \"associative f\"\n  shows \"map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n+1])) \n         = candidate f (map h [0..<n+1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "proof - \n  \\<comment> \\<open>The following three properties @{text P1}, @{text P2} and @{text P3}\\<close>\n  \\<comment> \\<open>are preconditions of Lemma 1.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "have P1: \n  \"\\<And>x y. \\<lbrakk> x \\<noteq> [] ; y \\<noteq> [] \\<rbrakk>\n   \\<Longrightarrow> foldl1 f (map h (x @ y)) = f (foldl1 f (map h x)) (foldl1 f (map h y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (map h (x @ y)) =\n                         f (foldl1 f (map h x)) (foldl1 f (map h y))", "using assms and foldl1_map"], ["proof (prove)\nusing this:\n  associative f\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 ?f (map ?h (?xs @ ?ys)) =\n                    ?f (foldl1 ?f (map ?h ?xs)) (foldl1 ?f (map ?h ?ys))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f (map h (x @ y)) =\n                         f (foldl1 f (map h x)) (foldl1 f (map h y))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (map h (?x @ ?y)) =\n                    f (foldl1 f (map h ?x)) (foldl1 f (map h ?y))\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "have P2: \"\\<And>x y. x \\<noteq> [] \\<Longrightarrow> y \\<noteq> [] \\<Longrightarrow> x @ y  \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> x @ y \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?x @ ?y \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "have P3: \"\\<And>x. x \\<in> set (map wrap [0..<n+1]) \\<Longrightarrow> x \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map wrap [0..<n + 1]) \\<Longrightarrow> x \\<noteq> []", "by auto\n\n  \\<comment> \\<open>The proof for the thesis is now equal to the one of the original paper:\\<close>"], ["proof (state)\nthis:\n  ?x1 \\<in> set (map wrap [0..<n + 1]) \\<Longrightarrow> ?x1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "from Lemma_1 [where h=\"foldl1 f \\<circ> map h\" and zs=\"map wrap [0..<n+1]\"\n       and f=\"(@)\"] and P1 P2 P3"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n              \\<Longrightarrow> (foldl1 f \\<circ> map h) (x @ y) =\n                                ?g ((foldl1 f \\<circ> map h) x)\n                                 ((foldl1 f \\<circ> map h) y);\n   \\<And>x y.\n      \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> x @ y \\<noteq> [];\n   \\<And>x.\n      x \\<in> set (map wrap [0..<n + 1]) \\<Longrightarrow>\n      x \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> map (foldl1 f \\<circ> map h)\n                     (candidate (@) (map wrap [0..<n + 1])) =\n                    candidate ?g\n                     (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1]))\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (map h (?x @ ?y)) =\n                    f (foldl1 f (map h ?x)) (foldl1 f (map h ?y))\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?x @ ?y \\<noteq> []\n  ?x1 \\<in> set (map wrap [0..<n + 1]) \\<Longrightarrow> ?x1 \\<noteq> []", "have \n  \"map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n+1])) \n   = candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n+1]))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n              \\<Longrightarrow> (foldl1 f \\<circ> map h) (x @ y) =\n                                ?g ((foldl1 f \\<circ> map h) x)\n                                 ((foldl1 f \\<circ> map h) y);\n   \\<And>x y.\n      \\<lbrakk>x \\<noteq> []; y \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> x @ y \\<noteq> [];\n   \\<And>x.\n      x \\<in> set (map wrap [0..<n + 1]) \\<Longrightarrow>\n      x \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> map (foldl1 f \\<circ> map h)\n                     (candidate (@) (map wrap [0..<n + 1])) =\n                    candidate ?g\n                     (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1]))\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f (map h (?x @ ?y)) =\n                    f (foldl1 f (map h ?x)) (foldl1 f (map h ?y))\n  \\<lbrakk>?x \\<noteq> []; ?y \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?x @ ?y \\<noteq> []\n  ?x1 \\<in> set (map wrap [0..<n + 1]) \\<Longrightarrow> ?x1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1]))", "by auto"], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "also"], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "have \n  \"\\<dots> = candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n+1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1])) =\n    candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1])", "by (simp add: L1)"], ["proof (state)\nthis:\n  candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1])) =\n  candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "also"], ["proof (state)\nthis:\n  candidate f (map (foldl1 f \\<circ> map h) (map wrap [0..<n + 1])) =\n  candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "have\n  \"\\<dots> = candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n+1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1]) =\n    candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n + 1])", "using L4"], ["proof (prove)\nusing this:\n  map ?f \\<circ> wrap = wrap \\<circ> ?f\n\ngoal (1 subgoal):\n 1. candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1]) =\n    candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n + 1])", "by (simp add: Fun.o_def)"], ["proof (state)\nthis:\n  candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1]) =\n  candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "also"], ["proof (state)\nthis:\n  candidate f (map (foldl1 f \\<circ> map h \\<circ> wrap) [0..<n + 1]) =\n  candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "have \n  \"\\<dots> = candidate f (map h [0..<n+1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n + 1]) =\n    candidate f (map h [0..<n + 1])", "by (simp add: Fun.o_def)"], ["proof (state)\nthis:\n  candidate f (map (foldl1 f \\<circ> wrap \\<circ> h) [0..<n + 1]) =\n  candidate f (map h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "finally"], ["proof (chain)\npicking this:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map h [0..<n + 1])", "show ?thesis"], ["proof (prove)\nusing this:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "."], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map h [0..<n + 1])\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Proving Proposition 1\\<close>"], ["", "subsection \\<open>Definitions of Lemma 4\\<close>"], ["", "text \\<open>\nIn the same way as in the original paper, the following two functions are \ndefined:\n\\<close>"], ["", "fun f1 :: \"three \\<Rightarrow> three \\<Rightarrow> three\"\nwhere\n  \"f1 x    Zero = x\"\n| \"f1 Zero One  = One\"\n| \"f1 x    y    = Two\""], ["", "fun f2 :: \"three \\<Rightarrow> three \\<Rightarrow> three\"\nwhere\n  \"f2 x Zero = x\"\n| \"f2 x One  = One\"\n| \"f2 x Two  = Two\""], ["", "text \\<open>\nBoth functions are associative as is proved by case analysis:\n\\<close>"], ["", "lemma f1_assoc: \"associative f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. associative f1", "unfolding associative_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z. f1 x (f1 y z) = f1 (f1 x y) z", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. f1 x (f1 y z) = f1 (f1 x y) z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. f1 x (f1 y z) = f1 (f1 x y) z", "show \"f1 x (f1 y z) = f1 (f1 x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 x (f1 y z) = f1 (f1 x y) z", "proof (cases z)"], ["proof (state)\ngoal (3 subgoals):\n 1. z = Zero \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 2. z = One \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 3. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "case Zero"], ["proof (state)\nthis:\n  z = Zero\n\ngoal (3 subgoals):\n 1. z = Zero \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 2. z = One \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 3. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = Zero\n\ngoal (1 subgoal):\n 1. f1 x (f1 y z) = f1 (f1 x y) z", "by simp"], ["proof (state)\nthis:\n  f1 x (f1 y z) = f1 (f1 x y) z\n\ngoal (2 subgoals):\n 1. z = One \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 2. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. z = One \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 2. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "case One"], ["proof (state)\nthis:\n  z = One\n\ngoal (2 subgoals):\n 1. z = One \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 2. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "hence z_One: \"z = One\""], ["proof (prove)\nusing this:\n  z = One\n\ngoal (1 subgoal):\n 1. z = One", "by simp"], ["proof (state)\nthis:\n  z = One\n\ngoal (2 subgoals):\n 1. z = One \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z\n 2. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = One\n\ngoal (1 subgoal):\n 1. f1 x (f1 y z) = f1 (f1 x y) z", "by (cases y, simp_all, cases x, simp_all)"], ["proof (state)\nthis:\n  f1 x (f1 y z) = f1 (f1 x y) z\n\ngoal (1 subgoal):\n 1. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "case Two"], ["proof (state)\nthis:\n  z = Two\n\ngoal (1 subgoal):\n 1. z = Two \\<Longrightarrow> f1 x (f1 y z) = f1 (f1 x y) z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = Two\n\ngoal (1 subgoal):\n 1. f1 x (f1 y z) = f1 (f1 x y) z", "by simp"], ["proof (state)\nthis:\n  f1 x (f1 y z) = f1 (f1 x y) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f1 x (f1 y z) = f1 (f1 x y) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma f2_assoc: \"associative f2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. associative f2", "unfolding associative_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z. f2 x (f2 y z) = f2 (f2 x y) z", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. f2 x (f2 y z) = f2 (f2 x y) z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z. f2 x (f2 y z) = f2 (f2 x y) z", "show \"f2 x (f2 y z) = f2 (f2 x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f2 x (f2 y z) = f2 (f2 x y) z", "by (cases z, auto)"], ["proof (state)\nthis:\n  f2 x (f2 y z) = f2 (f2 x y) z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nNext, we define two other functions, again according to the original paper.\nNote that \\<open>h1\\<close> has an extra parameter \\<open>k\\<close> which is only implicit in\nthe original paper.\n\\<close>"], ["", "fun h1 :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> three\"\nwhere\n  \"h1 k i j = (if i = j then One\n               else if j \\<le> k then Zero\n               else Two)\""], ["", "fun h2 :: \"nat \\<Rightarrow> nat \\<Rightarrow> three\"\nwhere\n  \"h2 i j = (if i = j then One\n             else if i + 1 = j then Two\n             else Zero)\""], ["", "subsection \\<open>Figures and Proofs\\<close>"], ["", "text \\<open>\nIn the original paper, this lemma is depicted in (and proved by) Figure~2.\nTherefore, it carries this unusual name here.\n\\<close>"], ["", "lemma Figure_2: \n  assumes \"i \\<le> k\"\n  shows \"foldl1 f1 (map (h1 k i) [0..<k + 1]) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "let ?mr = \"replicate i Zero @ [One] @ replicate (k - i) Zero\""], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "have P1: \"map (h1 k i) [0..<k + 1] = ?mr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] =\n    replicate i Zero @ [One] @ replicate (k - i) Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] =\n    replicate i Zero @ [One] @ replicate (k - i) Zero", "have Q1: \"length (map (h1 k i) [0..<k + 1]) = length ?mr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (h1 k i) [0..<k + 1]) =\n    length (replicate i Zero @ [One] @ replicate (k - i) Zero)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. length (map (h1 k i) [0..<k + 1]) =\n    length (replicate i Zero @ [One] @ replicate (k - i) Zero)", "by simp"], ["proof (state)\nthis:\n  length (map (h1 k i) [0..<k + 1]) =\n  length (replicate i Zero @ [One] @ replicate (k - i) Zero)\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] =\n    replicate i Zero @ [One] @ replicate (k - i) Zero", "have Q2: \"\\<And>j. j < length (map (h1 k i) [0..<k + 1])\n                    \\<Longrightarrow> (map (h1 k i) [0..<k + 1]) ! j = ?mr ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "assume \"j < length (map (h1 k i) [0..<k + 1])\""], ["proof (state)\nthis:\n  j < length (map (h1 k i) [0..<k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "hence j_k: \"j < k + 1\""], ["proof (prove)\nusing this:\n  j < length (map (h1 k i) [0..<k + 1])\n\ngoal (1 subgoal):\n 1. j < k + 1", "by simp"], ["proof (state)\nthis:\n  j < k + 1\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "have M1: \"(map (h1 k i) [0..<k + 1]) ! i = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! i = One", "using L6 [where f=\"h1 k i\" and xs=\"[0..<k + 1]\"] and assms\n              and List.nth_upt [where i=0 and k=i and j=\"k + 1\"]"], ["proof (prove)\nusing this:\n  ?k < length [0..<k + 1] \\<Longrightarrow>\n  map (h1 k i) [0..<k + 1] ! ?k = h1 k i ([0..<k + 1] ! ?k)\n  i \\<le> k\n  0 + i < k + 1 \\<Longrightarrow> [0..<k + 1] ! i = 0 + i\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! i = One", "by simp"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] ! i = One\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "have M2: \"j \\<noteq> i \\<Longrightarrow> (map (h1 k i) [0..<k + 1]) ! j = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero", "using L6 [where f=\"h1 k i\" and xs=\"[0..<k + 1]\"] and j_k\n              and List.nth_upt [where i=0 and j=\"k + 1\"]"], ["proof (prove)\nusing this:\n  ?k < length [0..<k + 1] \\<Longrightarrow>\n  map (h1 k i) [0..<k + 1] ! ?k = h1 k i ([0..<k + 1] ! ?k)\n  j < k + 1\n  0 + ?k < k + 1 \\<Longrightarrow> [0..<k + 1] ! ?k = 0 + ?k\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero", "by simp"], ["proof (state)\nthis:\n  j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "have R1: \"?mr ! i = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate i Zero @ [One] @ replicate (k - i) Zero) ! i = One", "using List.nth_append [where xs=\"replicate i Zero\"]"], ["proof (prove)\nusing this:\n  (replicate i Zero @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero) then replicate i Zero ! ?n\n   else ?ys ! (?n - length (replicate i Zero)))\n\ngoal (1 subgoal):\n 1. (replicate i Zero @ [One] @ replicate (k - i) Zero) ! i = One", "by simp"], ["proof (state)\nthis:\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! i = One\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "have R2: \"j < i \\<Longrightarrow> ?mr ! j = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero", "using List.nth_append [where xs=\"replicate i Zero\"]"], ["proof (prove)\nusing this:\n  (replicate i Zero @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero) then replicate i Zero ! ?n\n   else ?ys ! (?n - length (replicate i Zero)))\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero", "by simp"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow>\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "have R3: \"j > i \\<Longrightarrow> ?mr ! j = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero", "using List.nth_append [where xs=\"replicate i Zero @ [One]\"]\n              and j_k"], ["proof (prove)\nusing this:\n  ((replicate i Zero @ [One]) @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero @ [One])\n   then (replicate i Zero @ [One]) ! ?n\n   else ?ys ! (?n - length (replicate i Zero @ [One])))\n  j < k + 1\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero", "by simp"], ["proof (state)\nthis:\n  i < j \\<Longrightarrow>\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n       map (h1 k i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "show \"(map (h1 k i) [0..<k + 1]) ! j = ?mr ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n 2. i \\<noteq> j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n 2. i \\<noteq> j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "with M1 and R1"], ["proof (chain)\npicking this:\n  map (h1 k i) [0..<k + 1] ! i = One\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! i = One\n  i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  map (h1 k i) [0..<k + 1] ! i = One\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! i = One\n  i = j\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "assume i_ne_j: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "proof (cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> j; i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j\n 2. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> j; i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j\n 2. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j", "with M2 and R3"], ["proof (chain)\npicking this:\n  j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero\n  i < j \\<Longrightarrow>\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero\n  i < j", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero\n  i < j \\<Longrightarrow>\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero\n  i < j\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j", "assume \"\\<not>(i < j)\""], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j", "with i_ne_j"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  \\<not> i < j", "have \"i > j\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j =\n                      (replicate i Zero @ [One] @ replicate (k - i) Zero) !\n                      j", "with M2 and R2"], ["proof (chain)\npicking this:\n  j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero\n  j < i \\<Longrightarrow>\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero\n  j < i", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<noteq> i \\<Longrightarrow> map (h1 k i) [0..<k + 1] ! j = Zero\n  j < i \\<Longrightarrow>\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j = Zero\n  j < i\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n  map (h1 k i) [0..<k + 1] ! ?j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! ?j\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] =\n    replicate i Zero @ [One] @ replicate (k - i) Zero", "from Q1 Q2 and Lemma_2"], ["proof (chain)\npicking this:\n  length (map (h1 k i) [0..<k + 1]) =\n  length (replicate i Zero @ [One] @ replicate (k - i) Zero)\n  ?j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n  map (h1 k i) [0..<k + 1] ! ?j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! ?j\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys", "show ?thesis"], ["proof (prove)\nusing this:\n  length (map (h1 k i) [0..<k + 1]) =\n  length (replicate i Zero @ [One] @ replicate (k - i) Zero)\n  ?j < length (map (h1 k i) [0..<k + 1]) \\<Longrightarrow>\n  map (h1 k i) [0..<k + 1] ! ?j =\n  (replicate i Zero @ [One] @ replicate (k - i) Zero) ! ?j\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. map (h1 k i) [0..<k + 1] =\n    replicate i Zero @ [One] @ replicate (k - i) Zero", "by blast"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] =\n  replicate i Zero @ [One] @ replicate (k - i) Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h1 k i) [0..<k + 1] =\n  replicate i Zero @ [One] @ replicate (k - i) Zero\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "have P2: \"\\<And>j. j > 0 \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero", "assume \"(j::nat) > 0\""], ["proof (state)\nthis:\n  0 < j\n\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero", "thus \"foldl1 f1 (replicate j Zero) = Zero\""], ["proof (prove)\nusing this:\n  0 < j\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate j Zero) = Zero", "proof (induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> foldl1 f1 (replicate 0 Zero) = Zero\n 2. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (replicate (Suc j) Zero) = Zero", "case 0"], ["proof (state)\nthis:\n  0 < 0\n\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> foldl1 f1 (replicate 0 Zero) = Zero\n 2. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (replicate (Suc j) Zero) = Zero", "thus ?case"], ["proof (prove)\nusing this:\n  0 < 0\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate 0 Zero) = Zero", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (replicate 0 Zero) = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (replicate (Suc j) Zero) = Zero", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (replicate (Suc j) Zero) = Zero", "case (Suc j)"], ["proof (state)\nthis:\n  0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero\n  0 < Suc j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (replicate (Suc j) Zero) = Zero", "thus ?case"], ["proof (prove)\nusing this:\n  0 < j \\<Longrightarrow> foldl1 f1 (replicate j Zero) = Zero\n  0 < Suc j\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate (Suc j) Zero) = Zero", "by (cases j, auto)"], ["proof (state)\nthis:\n  foldl1 f1 (replicate (Suc j) Zero) = Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f1 (replicate j Zero) = Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?j \\<Longrightarrow> foldl1 f1 (replicate ?j Zero) = Zero\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "have P3: \"\\<And>j. foldl1 f1 ([One] @ replicate j Zero) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. foldl1 f1 ([One] @ replicate j Zero) = One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. foldl1 f1 ([One] @ replicate j Zero) = One", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. foldl1 f1 ([One] @ replicate j Zero) = One", "show \"foldl1 f1 ([One] @ replicate j Zero) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f1 ([One] @ replicate j Zero) = One", "using L8 [where f=f1 and xs=\"[One]\" and ys=\"replicate (Suc j) Zero\"] \n          and f1_assoc and P2 [where j=\"Suc j\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>associative f1; [One] \\<noteq> [];\n   replicate (Suc j) Zero \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ([One] @ replicate (Suc j) Zero) =\n                    f1 (foldl1 f1 [One])\n                     (foldl1 f1 (replicate (Suc j) Zero))\n  associative f1\n  0 < Suc j \\<Longrightarrow> foldl1 f1 (replicate (Suc j) Zero) = Zero\n\ngoal (1 subgoal):\n 1. foldl1 f1 ([One] @ replicate j Zero) = One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 ([One] @ replicate j Zero) = One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f1 ([One] @ replicate ?j Zero) = One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "have \"foldl1 f1 ?mr = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "using P3"], ["proof (prove)\nusing this:\n  i = 0\n  foldl1 f1 ([One] @ replicate ?j Zero) = One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "case (Suc i)"], ["proof (state)\nthis:\n  i = Suc i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "hence \n      \"foldl1 f1 (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero)\n       = f1 (foldl1 f1 (replicate (Suc i) Zero))\n            (foldl1 f1 ([One] @ replicate (k - Suc i) Zero))\""], ["proof (prove)\nusing this:\n  i = Suc i\n\ngoal (1 subgoal):\n 1. foldl1 f1\n     (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n    f1 (foldl1 f1 (replicate (Suc i) Zero))\n     (foldl1 f1 ([One] @ replicate (k - Suc i) Zero))", "using L8 [where xs=\"replicate (Suc i) Zero\" \n                    and ys=\"[One] @ replicate (k - Suc i) Zero\"] \n          and f1_assoc"], ["proof (prove)\nusing this:\n  i = Suc i\n  \\<lbrakk>associative ?f; replicate (Suc i) Zero \\<noteq> [];\n   [One] @ replicate (k - Suc i) Zero \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 ?f\n                     (replicate (Suc i) Zero @\n                      [One] @ replicate (k - Suc i) Zero) =\n                    ?f (foldl1 ?f (replicate (Suc i) Zero))\n                     (foldl1 ?f ([One] @ replicate (k - Suc i) Zero))\n  associative f1\n\ngoal (1 subgoal):\n 1. foldl1 f1\n     (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n    f1 (foldl1 f1 (replicate (Suc i) Zero))\n     (foldl1 f1 ([One] @ replicate (k - Suc i) Zero))", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n  f1 (foldl1 f1 (replicate (Suc i) Zero))\n   (foldl1 f1 ([One] @ replicate (k - Suc i) Zero))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "also"], ["proof (state)\nthis:\n  foldl1 f1 (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n  f1 (foldl1 f1 (replicate (Suc i) Zero))\n   (foldl1 f1 ([One] @ replicate (k - Suc i) Zero))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "have \n      \"\\<dots> = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 (replicate (Suc i) Zero))\n     (foldl1 f1 ([One] @ replicate (k - Suc i) Zero)) =\n    One", "using P2 [where j=\"Suc i\"] and P3 [where j=\"k - Suc i\"]"], ["proof (prove)\nusing this:\n  0 < Suc i \\<Longrightarrow> foldl1 f1 (replicate (Suc i) Zero) = Zero\n  foldl1 f1 ([One] @ replicate (k - Suc i) Zero) = One\n\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 (replicate (Suc i) Zero))\n     (foldl1 f1 ([One] @ replicate (k - Suc i) Zero)) =\n    One", "by simp"], ["proof (state)\nthis:\n  f1 (foldl1 f1 (replicate (Suc i) Zero))\n   (foldl1 f1 ([One] @ replicate (k - Suc i) Zero)) =\n  One\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "finally"], ["proof (chain)\npicking this:\n  foldl1 f1 (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n  One", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl1 f1 (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n  One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "using Suc"], ["proof (prove)\nusing this:\n  foldl1 f1 (replicate (Suc i) Zero @ [One] @ replicate (k - Suc i) Zero) =\n  One\n  i = Suc i\n\ngoal (1 subgoal):\n 1. foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "with P1"], ["proof (chain)\npicking this:\n  map (h1 k i) [0..<k + 1] =\n  replicate i Zero @ [One] @ replicate (k - i) Zero\n  foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One", "show ?thesis"], ["proof (prove)\nusing this:\n  map (h1 k i) [0..<k + 1] =\n  replicate i Zero @ [One] @ replicate (k - i) Zero\n  foldl1 f1 (replicate i Zero @ [One] @ replicate (k - i) Zero) = One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) [0..<k + 1]) = One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (map (h1 k i) [0..<k + 1]) = One\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIn the original paper, this lemma is depicted in (and proved by) Figure~3.\nTherefore, it carries this unusual name here.\n\\<close>"], ["", "lemma Figure_3: \n  assumes \"i < k\"\n  shows \"foldl1 f2 (map (h2 i) [0..<k + 1]) = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "let ?mr = \"replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero\""], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "have P1: \"map (h2 i) [0..<k + 1] = ?mr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] =\n    replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] =\n    replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero", "have Q1: \"length (map (h2 i) [0..<k + 1]) = length ?mr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (h2 i) [0..<k + 1]) =\n    length (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero)", "using assms"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. length (map (h2 i) [0..<k + 1]) =\n    length (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero)", "by simp"], ["proof (state)\nthis:\n  length (map (h2 i) [0..<k + 1]) =\n  length (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero)\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] =\n    replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero", "have Q2: \"\\<And>j. j < length (map (h2 i) [0..<k + 1])\n                    \\<Longrightarrow> (map (h2 i) [0..<k + 1]) ! j = ?mr ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "assume \"j < length (map (h2 i) [0..<k + 1])\""], ["proof (state)\nthis:\n  j < length (map (h2 i) [0..<k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "hence j_k: \"j < k + 1\""], ["proof (prove)\nusing this:\n  j < length (map (h2 i) [0..<k + 1])\n\ngoal (1 subgoal):\n 1. j < k + 1", "by simp"], ["proof (state)\nthis:\n  j < k + 1\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have M1: \"(map (h2 i) [0..<k + 1]) ! i = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! i = One", "using L6 [where xs=\"[0..<k + 1]\" and f=\"h2 i\" and k=i] and assms \n            and List.nth_upt [where i=0 and k=i and j=\"k + 1\"]"], ["proof (prove)\nusing this:\n  i < length [0..<k + 1] \\<Longrightarrow>\n  map (h2 i) [0..<k + 1] ! i = h2 i ([0..<k + 1] ! i)\n  i < k\n  0 + i < k + 1 \\<Longrightarrow> [0..<k + 1] ! i = 0 + i\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! i = One", "by simp"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! i = One\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have M2: \"(map (h2 i) [0..<k + 1]) ! (i + 1) = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! (i + 1) = Two", "using L6 [where xs=\"[0..<k + 1]\" and f=\"h2 i\" and k=\"i + 1\"] \n            and assms and List.nth_upt [where i=0 and k=\"i + 1\" and j=\"k + 1\"]"], ["proof (prove)\nusing this:\n  i + 1 < length [0..<k + 1] \\<Longrightarrow>\n  map (h2 i) [0..<k + 1] ! (i + 1) = h2 i ([0..<k + 1] ! (i + 1))\n  i < k\n  0 + (i + 1) < k + 1 \\<Longrightarrow> [0..<k + 1] ! (i + 1) = 0 + (i + 1)\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! (i + 1) = Two", "by simp"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! (i + 1) = Two\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have M3: \"j < i \\<or> j > i + 1 \\<Longrightarrow> (map (h2 i) [0..<k + 1]) ! j = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i \\<or> i + 1 < j \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j = Zero", "using L6 [where xs=\"[0..<k + 1]\" and f=\"h2 i\" and k=j] \n            and assms and List.nth_upt [where i=0 and k=j and j=\"k + 1\"]\n            and j_k"], ["proof (prove)\nusing this:\n  j < length [0..<k + 1] \\<Longrightarrow>\n  map (h2 i) [0..<k + 1] ! j = h2 i ([0..<k + 1] ! j)\n  i < k\n  0 + j < k + 1 \\<Longrightarrow> [0..<k + 1] ! j = 0 + j\n  j < k + 1\n\ngoal (1 subgoal):\n 1. j < i \\<or> i + 1 < j \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j = Zero", "by auto"], ["proof (state)\nthis:\n  j < i \\<or> i + 1 < j \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have R1: \"j < i \\<Longrightarrow> ?mr ! j = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero", "using List.nth_append [where xs=\"replicate i Zero\"]"], ["proof (prove)\nusing this:\n  (replicate i Zero @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero) then replicate i Zero ! ?n\n   else ?ys ! (?n - length (replicate i Zero)))\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow>\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero", "by simp"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow>\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have R2: \"?mr ! i = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! i = One", "using List.nth_append [where xs=\"replicate i Zero\"]"], ["proof (prove)\nusing this:\n  (replicate i Zero @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero) then replicate i Zero ! ?n\n   else ?ys ! (?n - length (replicate i Zero)))\n\ngoal (1 subgoal):\n 1. (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! i = One", "by simp"], ["proof (state)\nthis:\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! i = One\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have R3: \"?mr ! (i + 1) = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! (i + 1) =\n    Two", "using List.nth_append [where xs=\"replicate i Zero @ [One]\"]"], ["proof (prove)\nusing this:\n  ((replicate i Zero @ [One]) @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero @ [One])\n   then (replicate i Zero @ [One]) ! ?n\n   else ?ys ! (?n - length (replicate i Zero @ [One])))\n\ngoal (1 subgoal):\n 1. (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! (i + 1) =\n    Two", "by simp"], ["proof (state)\nthis:\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! (i + 1) =\n  Two\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "have R4: \"j > i + 1 \\<Longrightarrow> ?mr ! j = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 1 < j \\<Longrightarrow>\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero", "using List.nth_append [where xs=\"replicate i Zero @ [One,Two]\"]\n            and j_k"], ["proof (prove)\nusing this:\n  ((replicate i Zero @ [One, Two]) @ ?ys) ! ?n =\n  (if ?n < length (replicate i Zero @ [One, Two])\n   then (replicate i Zero @ [One, Two]) ! ?n\n   else ?ys ! (?n - length (replicate i Zero @ [One, Two])))\n  j < k + 1\n\ngoal (1 subgoal):\n 1. i + 1 < j \\<Longrightarrow>\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero", "by simp"], ["proof (state)\nthis:\n  i + 1 < j \\<Longrightarrow>\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n       map (h2 i) [0..<k + 1] ! j =\n       (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "show \"(map (h2 i) [0..<k + 1]) ! j = ?mr ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n 2. \\<not> j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n 2. \\<not> j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "with M3 and R1"], ["proof (chain)\npicking this:\n  j < i \\<or> i + 1 < j \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j = Zero\n  j < i \\<Longrightarrow>\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero\n  j < i", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i \\<or> i + 1 < j \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j = Zero\n  j < i \\<Longrightarrow>\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero\n  j < i\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "assume \"\\<not>(j < i)\""], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "hence j_ge_i: \"j \\<ge> i\""], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by simp"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "proof (cases \"j = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; j = i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j\n 2. \\<lbrakk>i \\<le> j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "assume \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; j = i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j\n 2. \\<lbrakk>i \\<le> j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "with M1 and R2"], ["proof (chain)\npicking this:\n  map (h2 i) [0..<k + 1] ! i = One\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! i = One\n  j = i", "show ?thesis"], ["proof (prove)\nusing this:\n  map (h2 i) [0..<k + 1] ! i = One\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! i = One\n  j = i\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "assume \"\\<not>(j = i)\""], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "with j_ge_i"], ["proof (chain)\npicking this:\n  i \\<le> j\n  j \\<noteq> i", "have j_gt_i: \"j > i\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "proof (cases \"j = i + 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < j; j = i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j\n 2. \\<lbrakk>i < j; j \\<noteq> i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "assume \"j = i + 1\""], ["proof (state)\nthis:\n  j = i + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < j; j = i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j\n 2. \\<lbrakk>i < j; j \\<noteq> i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "with M2 and R3"], ["proof (chain)\npicking this:\n  map (h2 i) [0..<k + 1] ! (i + 1) = Two\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! (i + 1) =\n  Two\n  j = i + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  map (h2 i) [0..<k + 1] ! (i + 1) = Two\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! (i + 1) =\n  Two\n  j = i + 1\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<noteq> i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<noteq> i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "assume \"\\<not>(j = i + 1)\""], ["proof (state)\nthis:\n  j \\<noteq> i + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<noteq> i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "with j_gt_i"], ["proof (chain)\npicking this:\n  i < j\n  j \\<noteq> i + 1", "have \"j > i + 1\""], ["proof (prove)\nusing this:\n  i < j\n  j \\<noteq> i + 1\n\ngoal (1 subgoal):\n 1. i + 1 < j", "by simp"], ["proof (state)\nthis:\n  i + 1 < j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j \\<noteq> i + 1\\<rbrakk>\n    \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j =\n                      (replicate i Zero @\n                       [One, Two] @ replicate (k - i - 1) Zero) !\n                      j", "with M3 and R4"], ["proof (chain)\npicking this:\n  j < i \\<or> i + 1 < j \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j = Zero\n  i + 1 < j \\<Longrightarrow>\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero\n  i + 1 < j", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i \\<or> i + 1 < j \\<Longrightarrow> map (h2 i) [0..<k + 1] ! j = Zero\n  i + 1 < j \\<Longrightarrow>\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j = Zero\n  i + 1 < j\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] ! j =\n    (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j", "by simp"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] ! j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n  map (h2 i) [0..<k + 1] ! ?j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! ?j\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] =\n    replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero", "from Q1 Q2 and Lemma_2"], ["proof (chain)\npicking this:\n  length (map (h2 i) [0..<k + 1]) =\n  length (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero)\n  ?j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n  map (h2 i) [0..<k + 1] ! ?j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! ?j\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys", "show ?thesis"], ["proof (prove)\nusing this:\n  length (map (h2 i) [0..<k + 1]) =\n  length (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero)\n  ?j < length (map (h2 i) [0..<k + 1]) \\<Longrightarrow>\n  map (h2 i) [0..<k + 1] ! ?j =\n  (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) ! ?j\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. map (h2 i) [0..<k + 1] =\n    replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero", "by blast"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] =\n  replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (h2 i) [0..<k + 1] =\n  replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "have P2: \"\\<And>j. j > 0 \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero", "assume j_0: \"(j::nat) > 0\""], ["proof (state)\nthis:\n  0 < j\n\ngoal (1 subgoal):\n 1. \\<And>j. 0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero", "show \"foldl1 f2 (replicate j Zero) = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate j Zero) = Zero", "using j_0"], ["proof (prove)\nusing this:\n  0 < j\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate j Zero) = Zero", "proof (induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> foldl1 f2 (replicate 0 Zero) = Zero\n 2. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (replicate (Suc j) Zero) = Zero", "case 0"], ["proof (state)\nthis:\n  0 < 0\n\ngoal (2 subgoals):\n 1. 0 < 0 \\<Longrightarrow> foldl1 f2 (replicate 0 Zero) = Zero\n 2. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (replicate (Suc j) Zero) = Zero", "thus ?case"], ["proof (prove)\nusing this:\n  0 < 0\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate 0 Zero) = Zero", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (replicate 0 Zero) = Zero\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (replicate (Suc j) Zero) = Zero", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (replicate (Suc j) Zero) = Zero", "case (Suc j)"], ["proof (state)\nthis:\n  0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero\n  0 < Suc j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero;\n        0 < Suc j\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (replicate (Suc j) Zero) = Zero", "thus ?case"], ["proof (prove)\nusing this:\n  0 < j \\<Longrightarrow> foldl1 f2 (replicate j Zero) = Zero\n  0 < Suc j\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate (Suc j) Zero) = Zero", "by (cases j, auto)"], ["proof (state)\nthis:\n  foldl1 f2 (replicate (Suc j) Zero) = Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f2 (replicate j Zero) = Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?j \\<Longrightarrow> foldl1 f2 (replicate ?j Zero) = Zero\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "have P3: \"\\<And>j. foldl1 f2 ([One, Two] @ replicate j Zero) = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. foldl1 f2 ([One, Two] @ replicate j Zero) = Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. foldl1 f2 ([One, Two] @ replicate j Zero) = Two", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. foldl1 f2 ([One, Two] @ replicate j Zero) = Two", "show \"foldl1 f2 ([One, Two] @ replicate j Zero) = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 ([One, Two] @ replicate j Zero) = Two", "using L8 [where f=f2 and xs=\"[One,Two]\" \n        and ys=\"replicate (Suc j) Zero\"] and f2_assoc and P2 [where j=\"Suc j\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>associative f2; [One, Two] \\<noteq> [];\n   replicate (Suc j) Zero \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ([One, Two] @ replicate (Suc j) Zero) =\n                    f2 (foldl1 f2 [One, Two])\n                     (foldl1 f2 (replicate (Suc j) Zero))\n  associative f2\n  0 < Suc j \\<Longrightarrow> foldl1 f2 (replicate (Suc j) Zero) = Zero\n\ngoal (1 subgoal):\n 1. foldl1 f2 ([One, Two] @ replicate j Zero) = Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 ([One, Two] @ replicate j Zero) = Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f2 ([One, Two] @ replicate ?j Zero) = Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "have \"foldl1 f2 ?mr = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two", "using P3"], ["proof (prove)\nusing this:\n  i = 0\n  foldl1 f2 ([One, Two] @ replicate ?j Zero) = Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n  Two\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "case (Suc i)"], ["proof (state)\nthis:\n  i = Suc i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "hence \n      \"foldl1 f2 (replicate (Suc i) Zero @ [One, Two] \n                                         @ replicate (k - Suc i - 1) Zero)\n       = f2 (foldl1 f2 (replicate (Suc i) Zero))\n            (foldl1 f2 ([One, Two] @  replicate (k - Suc i - 1) Zero))\""], ["proof (prove)\nusing this:\n  i = Suc i\n\ngoal (1 subgoal):\n 1. foldl1 f2\n     (replicate (Suc i) Zero @\n      [One, Two] @ replicate (k - Suc i - 1) Zero) =\n    f2 (foldl1 f2 (replicate (Suc i) Zero))\n     (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero))", "using L8 [where f=f2 and xs=\"replicate (Suc i) Zero\" \n                    and ys=\"[One, Two] @ replicate (k - Suc i - 1) Zero\"] \n          and f2_assoc"], ["proof (prove)\nusing this:\n  i = Suc i\n  \\<lbrakk>associative f2; replicate (Suc i) Zero \\<noteq> [];\n   [One, Two] @ replicate (k - Suc i - 1) Zero \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2\n                     (replicate (Suc i) Zero @\n                      [One, Two] @ replicate (k - Suc i - 1) Zero) =\n                    f2 (foldl1 f2 (replicate (Suc i) Zero))\n                     (foldl1 f2\n                       ([One, Two] @ replicate (k - Suc i - 1) Zero))\n  associative f2\n\ngoal (1 subgoal):\n 1. foldl1 f2\n     (replicate (Suc i) Zero @\n      [One, Two] @ replicate (k - Suc i - 1) Zero) =\n    f2 (foldl1 f2 (replicate (Suc i) Zero))\n     (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero))", "by simp"], ["proof (state)\nthis:\n  foldl1 f2\n   (replicate (Suc i) Zero @ [One, Two] @ replicate (k - Suc i - 1) Zero) =\n  f2 (foldl1 f2 (replicate (Suc i) Zero))\n   (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "also"], ["proof (state)\nthis:\n  foldl1 f2\n   (replicate (Suc i) Zero @ [One, Two] @ replicate (k - Suc i - 1) Zero) =\n  f2 (foldl1 f2 (replicate (Suc i) Zero))\n   (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "have \n      \"\\<dots> = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 (replicate (Suc i) Zero))\n     (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero)) =\n    Two", "using P2 [where j=\"Suc i\"] and P3 [where j=\"k - Suc i - 1\"]"], ["proof (prove)\nusing this:\n  0 < Suc i \\<Longrightarrow> foldl1 f2 (replicate (Suc i) Zero) = Zero\n  foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero) = Two\n\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 (replicate (Suc i) Zero))\n     (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero)) =\n    Two", "by simp"], ["proof (state)\nthis:\n  f2 (foldl1 f2 (replicate (Suc i) Zero))\n   (foldl1 f2 ([One, Two] @ replicate (k - Suc i - 1) Zero)) =\n  Two\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       foldl1 f2\n        (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n       Two", "finally"], ["proof (chain)\npicking this:\n  foldl1 f2\n   (replicate (Suc i) Zero @ [One, Two] @ replicate (k - Suc i - 1) Zero) =\n  Two", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl1 f2\n   (replicate (Suc i) Zero @ [One, Two] @ replicate (k - Suc i - 1) Zero) =\n  Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two", "using Suc"], ["proof (prove)\nusing this:\n  foldl1 f2\n   (replicate (Suc i) Zero @ [One, Two] @ replicate (k - Suc i - 1) Zero) =\n  Two\n  i = Suc i\n\ngoal (1 subgoal):\n 1. foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n    Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n  Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n  Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "with P1"], ["proof (chain)\npicking this:\n  map (h2 i) [0..<k + 1] =\n  replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero\n  foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n  Two", "show ?thesis"], ["proof (prove)\nusing this:\n  map (h2 i) [0..<k + 1] =\n  replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero\n  foldl1 f2 (replicate i Zero @ [One, Two] @ replicate (k - i - 1) Zero) =\n  Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) [0..<k + 1]) = Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (map (h2 i) [0..<k + 1]) = Two\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nCounterparts of the following two lemmas are shown in the proof of Lemma 4 in\nthe original paper. Since here, the proof of Lemma 4 is seperated in several\nsmaller lemmas, also these two properties are given separately.\n\\<close>"], ["", "lemma L9:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f \n             \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and \"i \\<le> k\"\n  shows \"foldl1 f1 (map (h1 k i) js) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) js) = One", "using assms and f1_assoc and Figure_2"], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  i \\<le> k\n  associative f1\n  ?i \\<le> ?k \\<Longrightarrow>\n  foldl1 f1 (map (h1 ?k ?i) [0..<?k + 1]) = One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) js) = One", "by auto"], ["", "lemma L10:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f \n             \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and \"i < k\"\n  shows \"foldl1 f2 (map (h2 i) js) = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) js) = Two", "using assms and f2_assoc and Figure_3"], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  i < k\n  associative f2\n  ?i < ?k \\<Longrightarrow> foldl1 f2 (map (h2 ?i) [0..<?k + 1]) = Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) js) = Two", "by auto"], ["", "text \\<open>\nIn the original paper, this lemma is depicted in (and proved by) Figure~4.\nTherefore, it carries this unusual name here. This lemma expresses that every\n\\<open>i \\<le> k\\<close> is contained in \\<open>js\\<close> at least once.\n\\<close>"], ["", "lemma Figure_4:\n  assumes \"foldl1 f1 (map (h1 k i) js) = One\"\n      and \"js \\<noteq> []\"\n  shows \"i \\<in> set js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set js", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> set js \\<Longrightarrow> False", "assume i_not_in_js: \"i \\<notin> set js\""], ["proof (state)\nthis:\n  i \\<notin> set js\n\ngoal (1 subgoal):\n 1. i \\<notin> set js \\<Longrightarrow> False", "have One_not_in_map_js: \"One \\<notin> set (map (h1 k i) js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. One \\<notin> set (map (h1 k i) js)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. One \\<in> set (map (h1 k i) js) \\<Longrightarrow> False", "assume \"One \\<in> set (map (h1 k i) js)\""], ["proof (state)\nthis:\n  One \\<in> set (map (h1 k i) js)\n\ngoal (1 subgoal):\n 1. One \\<in> set (map (h1 k i) js) \\<Longrightarrow> False", "hence \"One \\<in> (h1 k i) ` (set js)\""], ["proof (prove)\nusing this:\n  One \\<in> set (map (h1 k i) js)\n\ngoal (1 subgoal):\n 1. One \\<in> h1 k i ` set js", "by simp"], ["proof (state)\nthis:\n  One \\<in> h1 k i ` set js\n\ngoal (1 subgoal):\n 1. One \\<in> set (map (h1 k i) js) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  One \\<in> h1 k i ` set js", "obtain j where j_def: \"j \\<in> set js \\<and> One = h1 k i j\""], ["proof (prove)\nusing this:\n  One \\<in> h1 k i ` set js\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> set js \\<and> One = h1 k i j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Set.image_iff [where f=\"h1 k i\"]"], ["proof (prove)\nusing this:\n  One \\<in> h1 k i ` set js\n  (?z \\<in> h1 k i ` ?A) = (\\<exists>x\\<in>?A. ?z = h1 k i x)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> set js \\<and> One = h1 k i j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<in> set js \\<and> One = h1 k i j\n\ngoal (1 subgoal):\n 1. One \\<in> set (map (h1 k i) js) \\<Longrightarrow> False", "hence \"i = j\""], ["proof (prove)\nusing this:\n  j \\<in> set js \\<and> One = h1 k i j\n\ngoal (1 subgoal):\n 1. i = j", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. One \\<in> set (map (h1 k i) js) \\<Longrightarrow> False", "with i_not_in_js and j_def"], ["proof (chain)\npicking this:\n  i \\<notin> set js\n  j \\<in> set js \\<and> One = h1 k i j\n  i = j", "show False"], ["proof (prove)\nusing this:\n  i \\<notin> set js\n  j \\<in> set js \\<and> One = h1 k i j\n  i = j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  One \\<notin> set (map (h1 k i) js)\n\ngoal (1 subgoal):\n 1. i \\<notin> set js \\<Longrightarrow> False", "have f1_One: \"\\<And>x y. x \\<noteq> One \\<and> y \\<noteq> One \\<Longrightarrow> f1 x y \\<noteq> One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> One \\<and> y \\<noteq> One \\<Longrightarrow>\n       f1 x y \\<noteq> One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> One \\<and> y \\<noteq> One \\<Longrightarrow>\n       f1 x y \\<noteq> One", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> One \\<and> y \\<noteq> One \\<Longrightarrow>\n       f1 x y \\<noteq> One", "assume \"x \\<noteq> One \\<and> y \\<noteq> One\""], ["proof (state)\nthis:\n  x \\<noteq> One \\<and> y \\<noteq> One\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> One \\<and> y \\<noteq> One \\<Longrightarrow>\n       f1 x y \\<noteq> One", "thus \"f1 x y \\<noteq> One\""], ["proof (prove)\nusing this:\n  x \\<noteq> One \\<and> y \\<noteq> One\n\ngoal (1 subgoal):\n 1. f1 x y \\<noteq> One", "by (cases y, cases x, auto)"], ["proof (state)\nthis:\n  f1 x y \\<noteq> One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<noteq> One \\<and> ?y \\<noteq> One \\<Longrightarrow>\n  f1 ?x ?y \\<noteq> One\n\ngoal (1 subgoal):\n 1. i \\<notin> set js \\<Longrightarrow> False", "have \"\\<And>xs. \\<lbrakk> xs \\<noteq> [] ; One \\<notin> set xs \\<rbrakk> \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; One \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 xs \\<noteq> One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; One \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 xs \\<noteq> One", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; One \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 xs \\<noteq> One", "assume A: \"(xs :: three list) \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; One \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 xs \\<noteq> One", "thus \"One \\<notin> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. One \\<notin> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> One", "proof (induct xs rule: divide_and_conquer)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>One \\<notin> set []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldl1 f1 [] \\<noteq> One\n 2. \\<And>x.\n       \\<lbrakk>One \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] \\<noteq> One\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "case Nil"], ["proof (state)\nthis:\n  One \\<notin> set []\n  [] \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>One \\<notin> set []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldl1 f1 [] \\<noteq> One\n 2. \\<And>x.\n       \\<lbrakk>One \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] \\<noteq> One\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "thus ?case"], ["proof (prove)\nusing this:\n  One \\<notin> set []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f1 [] \\<noteq> One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 [] \\<noteq> One\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>One \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] \\<noteq> One\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>One \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] \\<noteq> One\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "case (One x)"], ["proof (state)\nthis:\n  One \\<notin> set [x]\n  [x] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>One \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] \\<noteq> One\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "thus \"foldl1 f1 [x] \\<noteq> One\""], ["proof (prove)\nusing this:\n  One \\<notin> set [x]\n  [x] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f1 [x] \\<noteq> One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 [x] \\<noteq> One\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "case (Partition xs ys)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n  \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys \\<noteq> One\n  One \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "hence \"One \\<notin> set xs \\<and> One \\<notin> set ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n  \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys \\<noteq> One\n  One \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. One \\<notin> set xs \\<and> One \\<notin> set ys", "by simp"], ["proof (state)\nthis:\n  One \\<notin> set xs \\<and> One \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "with Partition"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n  \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys \\<noteq> One\n  One \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n  One \\<notin> set xs \\<and> One \\<notin> set ys", "have \"foldl1 f1 xs \\<noteq> One \\<and> foldl1 f1 ys \\<noteq> One\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n  \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys \\<noteq> One\n  One \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n  One \\<notin> set xs \\<and> One \\<notin> set ys\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs \\<noteq> One \\<and> foldl1 f1 ys \\<noteq> One", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 xs \\<noteq> One \\<and> foldl1 f1 ys \\<noteq> One\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "with f1_One"], ["proof (chain)\npicking this:\n  ?x \\<noteq> One \\<and> ?y \\<noteq> One \\<Longrightarrow>\n  f1 ?x ?y \\<noteq> One\n  foldl1 f1 xs \\<noteq> One \\<and> foldl1 f1 ys \\<noteq> One", "have \"f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> One\""], ["proof (prove)\nusing this:\n  ?x \\<noteq> One \\<and> ?y \\<noteq> One \\<Longrightarrow>\n  f1 ?x ?y \\<noteq> One\n  foldl1 f1 xs \\<noteq> One \\<and> foldl1 f1 ys \\<noteq> One\n\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> One", "by simp"], ["proof (state)\nthis:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> One\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs \\<noteq> One;\n        \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys \\<noteq> One;\n        One \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> One", "with L8 [symmetric, where f=f1] and f1_assoc and Partition"], ["proof (chain)\npicking this:\n  \\<lbrakk>associative f1; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f1 (foldl1 f1 ?xs) (foldl1 f1 ?ys) =\n                    foldl1 f1 (?xs @ ?ys)\n  associative f1\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n  \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys \\<noteq> One\n  One \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> One", "show \"foldl1 f1 (xs @ ys) \\<noteq> One\""], ["proof (prove)\nusing this:\n  \\<lbrakk>associative f1; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f1 (foldl1 f1 ?xs) (foldl1 f1 ?ys) =\n                    foldl1 f1 (?xs @ ?ys)\n  associative f1\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>One \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n  \\<lbrakk>One \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys \\<noteq> One\n  One \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> One\n\ngoal (1 subgoal):\n 1. foldl1 f1 (xs @ ys) \\<noteq> One", "by auto"], ["proof (state)\nthis:\n  foldl1 f1 (xs @ ys) \\<noteq> One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  One \\<notin> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?xs \\<noteq> []; One \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ?xs \\<noteq> One\n\ngoal (1 subgoal):\n 1. i \\<notin> set js \\<Longrightarrow> False", "with One_not_in_map_js and assms"], ["proof (chain)\npicking this:\n  One \\<notin> set (map (h1 k i) js)\n  foldl1 f1 (map (h1 k i) js) = One\n  js \\<noteq> []\n  \\<lbrakk>?xs \\<noteq> []; One \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ?xs \\<noteq> One", "show False"], ["proof (prove)\nusing this:\n  One \\<notin> set (map (h1 k i) js)\n  foldl1 f1 (map (h1 k i) js) = One\n  js \\<noteq> []\n  \\<lbrakk>?xs \\<noteq> []; One \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ?xs \\<noteq> One\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIn the original paper, this lemma is depicted in (and proved by) Figure~5.\nTherefore, it carries this unusual name here. This lemma expresses that every\n\\<open>i \\<le> k\\<close> is contained in \\<open>js\\<close> at most once.\n\\<close>"], ["", "lemma Figure_5:\n  assumes \"foldl1 f1 (map (h1 k i) js) = One\"\n      and \"js = xs @ ys\"\n  shows \"\\<not>(i \\<in> set xs \\<and> i \\<in> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (i \\<in> set xs \\<and> i \\<in> set ys)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "assume \"\\<not>\\<not>(i \\<in> set xs \\<and> i \\<in> set ys)\""], ["proof (state)\nthis:\n  \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "hence i_xs_ys: \"i \\<in> set xs \\<and> i \\<in> set ys\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys)\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<and> i \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  i \\<in> set xs \\<and> i \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "from i_xs_ys"], ["proof (chain)\npicking this:\n  i \\<in> set xs \\<and> i \\<in> set ys", "have xs_not_empty: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<in> set xs \\<and> i \\<in> set ys\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "from i_xs_ys"], ["proof (chain)\npicking this:\n  i \\<in> set xs \\<and> i \\<in> set ys", "have ys_not_empty: \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<in> set xs \\<and> i \\<in> set ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "have f1_Zero: \"\\<And>x y. x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow> f1 x y \\<noteq> Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow>\n       f1 x y \\<noteq> Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow>\n       f1 x y \\<noteq> Zero", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow>\n       f1 x y \\<noteq> Zero", "show \"x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow> f1 x y \\<noteq> Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow>\n    f1 x y \\<noteq> Zero", "by (cases y, simp_all, cases x, simp_all)"], ["proof (state)\nthis:\n  x \\<noteq> Zero \\<or> y \\<noteq> Zero \\<Longrightarrow>\n  f1 x y \\<noteq> Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<noteq> Zero \\<or> ?y \\<noteq> Zero \\<Longrightarrow>\n  f1 ?x ?y \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "have One_foldl1: \"\\<And>xs. One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero", "assume One_xs: \"One \\<in> set xs\""], ["proof (state)\nthis:\n  One \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero", "thus \"foldl1 f1 xs \\<noteq> Zero\""], ["proof (prove)\nusing this:\n  One \\<in> set xs\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs \\<noteq> Zero", "proof (induct xs rule: divide_and_conquer)"], ["proof (state)\ngoal (3 subgoals):\n 1. One \\<in> set [] \\<Longrightarrow> foldl1 f1 [] \\<noteq> Zero\n 2. \\<And>x. One \\<in> set [x] \\<Longrightarrow> foldl1 f1 [x] \\<noteq> Zero\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "case Nil"], ["proof (state)\nthis:\n  One \\<in> set []\n\ngoal (3 subgoals):\n 1. One \\<in> set [] \\<Longrightarrow> foldl1 f1 [] \\<noteq> Zero\n 2. \\<And>x. One \\<in> set [x] \\<Longrightarrow> foldl1 f1 [x] \\<noteq> Zero\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "thus ?case"], ["proof (prove)\nusing this:\n  One \\<in> set []\n\ngoal (1 subgoal):\n 1. foldl1 f1 [] \\<noteq> Zero", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 [] \\<noteq> Zero\n\ngoal (2 subgoals):\n 1. \\<And>x. One \\<in> set [x] \\<Longrightarrow> foldl1 f1 [x] \\<noteq> Zero\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. One \\<in> set [x] \\<Longrightarrow> foldl1 f1 [x] \\<noteq> Zero\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "case One"], ["proof (state)\nthis:\n  One \\<in> set [x_]\n\ngoal (2 subgoals):\n 1. \\<And>x. One \\<in> set [x] \\<Longrightarrow> foldl1 f1 [x] \\<noteq> Zero\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "thus ?case"], ["proof (prove)\nusing this:\n  One \\<in> set [x_]\n\ngoal (1 subgoal):\n 1. foldl1 f1 [x_] \\<noteq> Zero", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 [x_] \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "case (Partition xs ys)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero\n  One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero\n  One \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "hence \"One \\<in> set xs \\<or> One \\<in> set ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero\n  One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero\n  One \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. One \\<in> set xs \\<or> One \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  One \\<in> set xs \\<or> One \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "with Partition"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero\n  One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero\n  One \\<in> set (xs @ ys)\n  One \\<in> set xs \\<or> One \\<in> set ys", "have \"foldl1 f1 xs \\<noteq> Zero \\<or> foldl1 f1 ys \\<noteq> Zero\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero\n  One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero\n  One \\<in> set (xs @ ys)\n  One \\<in> set xs \\<or> One \\<in> set ys\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs \\<noteq> Zero \\<or> foldl1 f1 ys \\<noteq> Zero", "by auto"], ["proof (state)\nthis:\n  foldl1 f1 xs \\<noteq> Zero \\<or> foldl1 f1 ys \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "with f1_Zero"], ["proof (chain)\npicking this:\n  ?x \\<noteq> Zero \\<or> ?y \\<noteq> Zero \\<Longrightarrow>\n  f1 ?x ?y \\<noteq> Zero\n  foldl1 f1 xs \\<noteq> Zero \\<or> foldl1 f1 ys \\<noteq> Zero", "have \"f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> Zero\""], ["proof (prove)\nusing this:\n  ?x \\<noteq> Zero \\<or> ?y \\<noteq> Zero \\<Longrightarrow>\n  f1 ?x ?y \\<noteq> Zero\n  foldl1 f1 xs \\<noteq> Zero \\<or> foldl1 f1 ys \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> Zero", "by simp"], ["proof (state)\nthis:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero;\n        One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero;\n        One \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) \\<noteq> Zero", "thus ?case"], ["proof (prove)\nusing this:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. foldl1 f1 (xs @ ys) \\<noteq> Zero", "using L8 [symmetric, where f=f1] and f1_assoc and Partition"], ["proof (prove)\nusing this:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) \\<noteq> Zero\n  \\<lbrakk>associative f1; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f1 (foldl1 f1 ?xs) (foldl1 f1 ?ys) =\n                    foldl1 f1 (?xs @ ?ys)\n  associative f1\n  xs \\<noteq> []\n  ys \\<noteq> []\n  One \\<in> set xs \\<Longrightarrow> foldl1 f1 xs \\<noteq> Zero\n  One \\<in> set ys \\<Longrightarrow> foldl1 f1 ys \\<noteq> Zero\n  One \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. foldl1 f1 (xs @ ys) \\<noteq> Zero", "by auto"], ["proof (state)\nthis:\n  foldl1 f1 (xs @ ys) \\<noteq> Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f1 xs \\<noteq> Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  One \\<in> set ?xs \\<Longrightarrow> foldl1 f1 ?xs \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "have f1_Two: \"\\<And>x y. x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two", "show \"x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two", "by (cases y, simp_all, cases x, simp_all)"], ["proof (state)\nthis:\n  x \\<noteq> Zero \\<and> y \\<noteq> Zero \\<Longrightarrow> f1 x y = Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<noteq> Zero \\<and> ?y \\<noteq> Zero \\<Longrightarrow> f1 ?x ?y = Two\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "from i_xs_ys"], ["proof (chain)\npicking this:\n  i \\<in> set xs \\<and> i \\<in> set ys", "have \"One \\<in> set (map (h1 k i) xs) \\<and> One \\<in> set (map (h1 k i) ys)\""], ["proof (prove)\nusing this:\n  i \\<in> set xs \\<and> i \\<in> set ys\n\ngoal (1 subgoal):\n 1. One \\<in> set (map (h1 k i) xs) \\<and> One \\<in> set (map (h1 k i) ys)", "by simp"], ["proof (state)\nthis:\n  One \\<in> set (map (h1 k i) xs) \\<and> One \\<in> set (map (h1 k i) ys)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "hence \"foldl1 f1 (map (h1 k i) xs) \\<noteq> Zero \n         \\<and> foldl1 f1 (map (h1 k i) ys) \\<noteq> Zero\""], ["proof (prove)\nusing this:\n  One \\<in> set (map (h1 k i) xs) \\<and> One \\<in> set (map (h1 k i) ys)\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) xs) \\<noteq> Zero \\<and>\n    foldl1 f1 (map (h1 k i) ys) \\<noteq> Zero", "using One_foldl1"], ["proof (prove)\nusing this:\n  One \\<in> set (map (h1 k i) xs) \\<and> One \\<in> set (map (h1 k i) ys)\n  One \\<in> set ?xs \\<Longrightarrow> foldl1 f1 ?xs \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) xs) \\<noteq> Zero \\<and>\n    foldl1 f1 (map (h1 k i) ys) \\<noteq> Zero", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (map (h1 k i) xs) \\<noteq> Zero \\<and>\n  foldl1 f1 (map (h1 k i) ys) \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "hence \"f1 (foldl1 f1 (map (h1 k i) xs)) (foldl1 f1 (map (h1 k i) ys)) = Two\""], ["proof (prove)\nusing this:\n  foldl1 f1 (map (h1 k i) xs) \\<noteq> Zero \\<and>\n  foldl1 f1 (map (h1 k i) ys) \\<noteq> Zero\n\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 (map (h1 k i) xs)) (foldl1 f1 (map (h1 k i) ys)) = Two", "using f1_Two"], ["proof (prove)\nusing this:\n  foldl1 f1 (map (h1 k i) xs) \\<noteq> Zero \\<and>\n  foldl1 f1 (map (h1 k i) ys) \\<noteq> Zero\n  ?x \\<noteq> Zero \\<and> ?y \\<noteq> Zero \\<Longrightarrow> f1 ?x ?y = Two\n\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 (map (h1 k i) xs)) (foldl1 f1 (map (h1 k i) ys)) = Two", "by simp"], ["proof (state)\nthis:\n  f1 (foldl1 f1 (map (h1 k i) xs)) (foldl1 f1 (map (h1 k i) ys)) = Two\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "hence \"foldl1 f1 (map (h1 k i) (xs @ ys)) = Two\""], ["proof (prove)\nusing this:\n  f1 (foldl1 f1 (map (h1 k i) xs)) (foldl1 f1 (map (h1 k i) ys)) = Two\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) (xs @ ys)) = Two", "using foldl1_map [symmetric, where h=\"h1 k i\"] and f1_assoc \n      and xs_not_empty and ys_not_empty"], ["proof (prove)\nusing this:\n  f1 (foldl1 f1 (map (h1 k i) xs)) (foldl1 f1 (map (h1 k i) ys)) = Two\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?f (foldl1 ?f (map (h1 k i) ?xs))\n                     (foldl1 ?f (map (h1 k i) ?ys)) =\n                    foldl1 ?f (map (h1 k i) (?xs @ ?ys))\n  associative f1\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k i) (xs @ ys)) = Two", "by auto"], ["proof (state)\nthis:\n  foldl1 f1 (map (h1 k i) (xs @ ys)) = Two\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys) \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  foldl1 f1 (map (h1 k i) js) = One\n  js = xs @ ys\n  foldl1 f1 (map (h1 k i) (xs @ ys)) = Two", "show False"], ["proof (prove)\nusing this:\n  foldl1 f1 (map (h1 k i) js) = One\n  js = xs @ ys\n  foldl1 f1 (map (h1 k i) (xs @ ys)) = Two\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIn the original paper, this lemma is depicted in (and proved by) Figure~6.\nTherefore, it carries this unusual name here. This lemma expresses that\n\\<open>js\\<close> contains only elements of \\<open>[0..<k + 1]\\<close>.\n\\<close>"], ["", "lemma Figure_6:\n  assumes \"\\<And>i. i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k i) js) = One\"\n      and \"i > k\"\n  shows \"i \\<notin> set js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> set js", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> set js \\<Longrightarrow> False", "assume i_in_js: \"i \\<in> set js\""], ["proof (state)\nthis:\n  i \\<in> set js\n\ngoal (1 subgoal):\n 1. i \\<in> set js \\<Longrightarrow> False", "have Two_map: \"Two \\<in> set (map (h1 k 0) js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h1 k 0) js)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h1 k 0) js)", "have \"Two = h1 k 0 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Two = h1 k 0 i", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  k < i\n\ngoal (1 subgoal):\n 1. Two = h1 k 0 i", "by simp"], ["proof (state)\nthis:\n  Two = h1 k 0 i\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h1 k 0) js)", "with i_in_js"], ["proof (chain)\npicking this:\n  i \\<in> set js\n  Two = h1 k 0 i", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set js\n  Two = h1 k 0 i\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h1 k 0) js)", "using IntI"], ["proof (prove)\nusing this:\n  i \\<in> set js\n  Two = h1 k 0 i\n  \\<lbrakk>?c \\<in> ?A; ?c \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?A \\<inter> ?B\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h1 k 0) js)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  Two \\<in> set (map (h1 k 0) js)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Two \\<in> set (map (h1 k 0) js)\n\ngoal (1 subgoal):\n 1. i \\<in> set js \\<Longrightarrow> False", "have f1_Two: \"\\<And>x y. x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two", "show \"x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two", "by (cases y, auto)"], ["proof (state)\nthis:\n  x = Two \\<or> y = Two \\<Longrightarrow> f1 x y = Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x = Two \\<or> ?y = Two \\<Longrightarrow> f1 ?x ?y = Two\n\ngoal (1 subgoal):\n 1. i \\<in> set js \\<Longrightarrow> False", "have \"\\<And>xs. Two \\<in> set xs \\<Longrightarrow> foldl1 f1 xs = Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. Two \\<in> set xs \\<Longrightarrow> foldl1 f1 xs = Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. Two \\<in> set xs \\<Longrightarrow> foldl1 f1 xs = Two", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. Two \\<in> set xs \\<Longrightarrow> foldl1 f1 xs = Two", "assume Two_xs: \"Two \\<in> set xs\""], ["proof (state)\nthis:\n  Two \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. Two \\<in> set xs \\<Longrightarrow> foldl1 f1 xs = Two", "thus \"foldl1 f1 xs = Two\""], ["proof (prove)\nusing this:\n  Two \\<in> set xs\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs = Two", "using Two_xs"], ["proof (prove)\nusing this:\n  Two \\<in> set xs\n  Two \\<in> set xs\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs = Two", "proof (induct xs rule: divide_and_conquer)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>Two \\<in> set []; Two \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldl1 f1 [] = Two\n 2. \\<And>x.\n       \\<lbrakk>Two \\<in> set [x]; Two \\<in> set [x]\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] = Two\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "case Nil"], ["proof (state)\nthis:\n  Two \\<in> set []\n  Two \\<in> set []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Two \\<in> set []; Two \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldl1 f1 [] = Two\n 2. \\<And>x.\n       \\<lbrakk>Two \\<in> set [x]; Two \\<in> set [x]\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] = Two\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "thus ?case"], ["proof (prove)\nusing this:\n  Two \\<in> set []\n  Two \\<in> set []\n\ngoal (1 subgoal):\n 1. foldl1 f1 [] = Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 [] = Two\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Two \\<in> set [x]; Two \\<in> set [x]\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] = Two\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Two \\<in> set [x]; Two \\<in> set [x]\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] = Two\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "case One"], ["proof (state)\nthis:\n  Two \\<in> set [x_]\n  Two \\<in> set [x_]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Two \\<in> set [x]; Two \\<in> set [x]\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 [x] = Two\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "thus ?case"], ["proof (prove)\nusing this:\n  Two \\<in> set [x_]\n  Two \\<in> set [x_]\n\ngoal (1 subgoal):\n 1. foldl1 f1 [x_] = Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 [x_] = Two\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "case (Partition xs ys)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs = Two\n  \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys = Two\n  Two \\<in> set (xs @ ys)\n  Two \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "hence \"Two \\<in> set xs \\<or> Two \\<in> set ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs = Two\n  \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys = Two\n  Two \\<in> set (xs @ ys)\n  Two \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. Two \\<in> set xs \\<or> Two \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  Two \\<in> set xs \\<or> Two \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "hence \"foldl1 f1 xs = Two \\<or> foldl1 f1 ys = Two\""], ["proof (prove)\nusing this:\n  Two \\<in> set xs \\<or> Two \\<in> set ys\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs = Two \\<or> foldl1 f1 ys = Two", "using Partition"], ["proof (prove)\nusing this:\n  Two \\<in> set xs \\<or> Two \\<in> set ys\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs = Two\n  \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys = Two\n  Two \\<in> set (xs @ ys)\n  Two \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. foldl1 f1 xs = Two \\<or> foldl1 f1 ys = Two", "by auto"], ["proof (state)\nthis:\n  foldl1 f1 xs = Two \\<or> foldl1 f1 ys = Two\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "with f1_Two"], ["proof (chain)\npicking this:\n  ?x = Two \\<or> ?y = Two \\<Longrightarrow> f1 ?x ?y = Two\n  foldl1 f1 xs = Two \\<or> foldl1 f1 ys = Two", "have \"f1 (foldl1 f1 xs) (foldl1 f1 ys) = Two\""], ["proof (prove)\nusing this:\n  ?x = Two \\<or> ?y = Two \\<Longrightarrow> f1 ?x ?y = Two\n  foldl1 f1 xs = Two \\<or> foldl1 f1 ys = Two\n\ngoal (1 subgoal):\n 1. f1 (foldl1 f1 xs) (foldl1 f1 ys) = Two", "by simp"], ["proof (state)\nthis:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) = Two\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 xs = Two;\n        \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> foldl1 f1 ys = Two;\n        Two \\<in> set (xs @ ys); Two \\<in> set (xs @ ys)\\<rbrakk>\n       \\<Longrightarrow> foldl1 f1 (xs @ ys) = Two", "thus \"foldl1 f1 (xs @ ys) = Two\""], ["proof (prove)\nusing this:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) = Two\n\ngoal (1 subgoal):\n 1. foldl1 f1 (xs @ ys) = Two", "using L8 [symmetric, where f=f1] and f1_assoc and Partition"], ["proof (prove)\nusing this:\n  f1 (foldl1 f1 xs) (foldl1 f1 ys) = Two\n  \\<lbrakk>associative f1; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f1 (foldl1 f1 ?xs) (foldl1 f1 ?ys) =\n                    foldl1 f1 (?xs @ ?ys)\n  associative f1\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<in> set xs; Two \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 xs = Two\n  \\<lbrakk>Two \\<in> set ys; Two \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 ys = Two\n  Two \\<in> set (xs @ ys)\n  Two \\<in> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. foldl1 f1 (xs @ ys) = Two", "by auto"], ["proof (state)\nthis:\n  foldl1 f1 (xs @ ys) = Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f1 xs = Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Two \\<in> set ?xs \\<Longrightarrow> foldl1 f1 ?xs = Two\n\ngoal (1 subgoal):\n 1. i \\<in> set js \\<Longrightarrow> False", "with Two_map"], ["proof (chain)\npicking this:\n  Two \\<in> set (map (h1 k 0) js)\n  Two \\<in> set ?xs \\<Longrightarrow> foldl1 f1 ?xs = Two", "have \"foldl1 f1 (map (h1 k 0) js) = Two\""], ["proof (prove)\nusing this:\n  Two \\<in> set (map (h1 k 0) js)\n  Two \\<in> set ?xs \\<Longrightarrow> foldl1 f1 ?xs = Two\n\ngoal (1 subgoal):\n 1. foldl1 f1 (map (h1 k 0) js) = Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f1 (map (h1 k 0) js) = Two\n\ngoal (1 subgoal):\n 1. i \\<in> set js \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  k < i\n  foldl1 f1 (map (h1 k 0) js) = Two", "show False"], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  k < i\n  foldl1 f1 (map (h1 k 0) js) = Two\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIn the original paper, this lemma is depicted in (and proved by) Figure~7.\nTherefore, it carries this unusual name here. This lemma expresses that every\n\\<open>i \\<le> k\\<close> in \\<open>js\\<close> is eventually followed by \\<open>i + 1\\<close>.\n\\<close>"], ["", "lemma Figure_7:\n  assumes \"foldl1 f2 (map (h2 i) js) = Two\"\n      and \"js = xs @ ys\"\n      and \"xs \\<noteq> []\"\n      and \"i = last xs\"\n  shows \"(i + 1) \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 1 \\<in> set ys", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "assume Suc_i_not_in_ys: \"(i + 1) \\<notin> set ys\""], ["proof (state)\nthis:\n  i + 1 \\<notin> set ys\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "have last_map_One: \"last (map (h2 i) xs) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "have \n      \"last (map (h2 i) xs) \n        = (map (h2 i) xs) ! (length (map (h2 i) xs) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = map (h2 i) xs ! (length (map (h2 i) xs) - 1)", "using List.last_conv_nth [where xs=\"map (h2 i) xs\"] and assms"], ["proof (prove)\nusing this:\n  map (h2 i) xs \\<noteq> [] \\<Longrightarrow>\n  last (map (h2 i) xs) = map (h2 i) xs ! (length (map (h2 i) xs) - 1)\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = map (h2 i) xs ! (length (map (h2 i) xs) - 1)", "by simp"], ["proof (state)\nthis:\n  last (map (h2 i) xs) = map (h2 i) xs ! (length (map (h2 i) xs) - 1)\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "also"], ["proof (state)\nthis:\n  last (map (h2 i) xs) = map (h2 i) xs ! (length (map (h2 i) xs) - 1)\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "have \n      \"\\<dots> = (map (h2 i) xs) ! (length xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h2 i) xs ! (length (map (h2 i) xs) - 1) =\n    map (h2 i) xs ! (length xs - 1)", "using L2"], ["proof (prove)\nusing this:\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. map (h2 i) xs ! (length (map (h2 i) xs) - 1) =\n    map (h2 i) xs ! (length xs - 1)", "by simp"], ["proof (state)\nthis:\n  map (h2 i) xs ! (length (map (h2 i) xs) - 1) =\n  map (h2 i) xs ! (length xs - 1)\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "also"], ["proof (state)\nthis:\n  map (h2 i) xs ! (length (map (h2 i) xs) - 1) =\n  map (h2 i) xs ! (length xs - 1)\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "have \n      \"\\<dots> = h2 i (xs ! (length xs - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (h2 i) xs ! (length xs - 1) = h2 i (xs ! (length xs - 1))", "using L6 and assms"], ["proof (prove)\nusing this:\n  ?k < length ?xs \\<Longrightarrow> map ?f ?xs ! ?k = ?f (?xs ! ?k)\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. map (h2 i) xs ! (length xs - 1) = h2 i (xs ! (length xs - 1))", "by simp"], ["proof (state)\nthis:\n  map (h2 i) xs ! (length xs - 1) = h2 i (xs ! (length xs - 1))\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "also"], ["proof (state)\nthis:\n  map (h2 i) xs ! (length xs - 1) = h2 i (xs ! (length xs - 1))\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "have \n      \"\\<dots> = h2 i (last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h2 i (xs ! (length xs - 1)) = h2 i (last xs)", "using List.last_conv_nth [symmetric,where xs=xs] and assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow> xs ! (length xs - 1) = last xs\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. h2 i (xs ! (length xs - 1)) = h2 i (last xs)", "by simp"], ["proof (state)\nthis:\n  h2 i (xs ! (length xs - 1)) = h2 i (last xs)\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "also"], ["proof (state)\nthis:\n  h2 i (xs ! (length xs - 1)) = h2 i (last xs)\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "have \n      \"\\<dots> = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h2 i (last xs) = One", "using assms"], ["proof (prove)\nusing this:\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. h2 i (last xs) = One", "by simp"], ["proof (state)\nthis:\n  h2 i (last xs) = One\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "finally"], ["proof (chain)\npicking this:\n  last (map (h2 i) xs) = One", "show ?thesis"], ["proof (prove)\nusing this:\n  last (map (h2 i) xs) = One\n\ngoal (1 subgoal):\n 1. last (map (h2 i) xs) = One", "."], ["proof (state)\nthis:\n  last (map (h2 i) xs) = One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (map (h2 i) xs) = One\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "have \"\\<And>xs. \\<lbrakk>  xs \\<noteq> [] ; last xs = One \\<rbrakk> \\<Longrightarrow> foldl1 f2 xs = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; last xs = One\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs = One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; last xs = One\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs = One", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; last xs = One\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs = One", "assume last_xs_One: \"last xs = One\""], ["proof (state)\nthis:\n  last xs = One\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; last xs = One\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs = One", "assume xs_not_empty: \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; last xs = One\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs = One", "hence xs_partition: \"xs = butlast xs @ [last xs]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs = butlast xs @ [last xs]", "by simp"], ["proof (state)\nthis:\n  xs = butlast xs @ [last xs]\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; last xs = One\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs = One", "show \"foldl1 f2 xs = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 xs = One", "proof (cases \"butlast xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. butlast xs = [] \\<Longrightarrow> foldl1 f2 xs = One\n 2. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "case Nil"], ["proof (state)\nthis:\n  butlast xs = []\n\ngoal (2 subgoals):\n 1. butlast xs = [] \\<Longrightarrow> foldl1 f2 xs = One\n 2. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "with xs_partition and last_xs_One"], ["proof (chain)\npicking this:\n  xs = butlast xs @ [last xs]\n  last xs = One\n  butlast xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = butlast xs @ [last xs]\n  last xs = One\n  butlast xs = []\n\ngoal (1 subgoal):\n 1. foldl1 f2 xs = One", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 xs = One\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "case Cons"], ["proof (state)\nthis:\n  butlast xs = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "hence butlast_not_empty: \"butlast xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  butlast xs = a_ # list_\n\ngoal (1 subgoal):\n 1. butlast xs \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  butlast xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "have \n        \"foldl1 f2 xs = foldl1 f2 (butlast xs @ [last xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 xs = foldl1 f2 (butlast xs @ [last xs])", "using xs_partition"], ["proof (prove)\nusing this:\n  xs = butlast xs @ [last xs]\n\ngoal (1 subgoal):\n 1. foldl1 f2 xs = foldl1 f2 (butlast xs @ [last xs])", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 xs = foldl1 f2 (butlast xs @ [last xs])\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "also"], ["proof (state)\nthis:\n  foldl1 f2 xs = foldl1 f2 (butlast xs @ [last xs])\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "have \n        \"\\<dots> = f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f2 (butlast xs @ [last xs]) =\n    f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs])", "using L8 [where f=f2] and f2_assoc and butlast_not_empty"], ["proof (prove)\nusing this:\n  \\<lbrakk>associative f2; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 (?xs @ ?ys) =\n                    f2 (foldl1 f2 ?xs) (foldl1 f2 ?ys)\n  associative f2\n  butlast xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 (butlast xs @ [last xs]) =\n    f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs])", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (butlast xs @ [last xs]) =\n  f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs])\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "also"], ["proof (state)\nthis:\n  foldl1 f2 (butlast xs @ [last xs]) =\n  f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs])\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "have \n        \"\\<dots> = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs]) = One", "using last_xs_One"], ["proof (prove)\nusing this:\n  last xs = One\n\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs]) = One", "by simp"], ["proof (state)\nthis:\n  f2 (foldl1 f2 (butlast xs)) (foldl1 f2 [last xs]) = One\n\ngoal (1 subgoal):\n 1. \\<And>a list. butlast xs = a # list \\<Longrightarrow> foldl1 f2 xs = One", "finally"], ["proof (chain)\npicking this:\n  foldl1 f2 xs = One", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl1 f2 xs = One\n\ngoal (1 subgoal):\n 1. foldl1 f2 xs = One", "."], ["proof (state)\nthis:\n  foldl1 f2 xs = One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f2 xs = One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?xs \\<noteq> []; last ?xs = One\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs = One\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "with last_map_One"], ["proof (chain)\npicking this:\n  last (map (h2 i) xs) = One\n  \\<lbrakk>?xs \\<noteq> []; last ?xs = One\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs = One", "have foldl1_map_xs: \"foldl1 f2 (map (h2 i) xs) = One\""], ["proof (prove)\nusing this:\n  last (map (h2 i) xs) = One\n  \\<lbrakk>?xs \\<noteq> []; last ?xs = One\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs = One\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) xs) = One", "using assms"], ["proof (prove)\nusing this:\n  last (map (h2 i) xs) = One\n  \\<lbrakk>?xs \\<noteq> []; last ?xs = One\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs = One\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) xs) = One", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (map (h2 i) xs) = One\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "have ys_not_empty: \"ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "using foldl1_map_xs and assms"], ["proof (prove)\nusing this:\n  foldl1 f2 (map (h2 i) xs) = One\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "have Two_map_ys: \"Two \\<notin> set (map (h2 i) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Two \\<notin> set (map (h2 i) ys)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h2 i) ys) \\<Longrightarrow> False", "assume \"Two \\<in> set (map (h2 i) ys)\""], ["proof (state)\nthis:\n  Two \\<in> set (map (h2 i) ys)\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h2 i) ys) \\<Longrightarrow> False", "hence \"Two \\<in> (h2 i) ` (set ys)\""], ["proof (prove)\nusing this:\n  Two \\<in> set (map (h2 i) ys)\n\ngoal (1 subgoal):\n 1. Two \\<in> h2 i ` set ys", "by simp"], ["proof (state)\nthis:\n  Two \\<in> h2 i ` set ys\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h2 i) ys) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Two \\<in> h2 i ` set ys", "obtain j where j_def: \"j \\<in> set ys \\<and> Two = h2 i j\""], ["proof (prove)\nusing this:\n  Two \\<in> h2 i ` set ys\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> set ys \\<and> Two = h2 i j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Set.image_iff [where f=\"h2 i\"]"], ["proof (prove)\nusing this:\n  Two \\<in> h2 i ` set ys\n  (?z \\<in> h2 i ` ?A) = (\\<exists>x\\<in>?A. ?z = h2 i x)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<in> set ys \\<and> Two = h2 i j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<in> set ys \\<and> Two = h2 i j\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h2 i) ys) \\<Longrightarrow> False", "hence \"i + 1 = j\""], ["proof (prove)\nusing this:\n  j \\<in> set ys \\<and> Two = h2 i j\n\ngoal (1 subgoal):\n 1. i + 1 = j", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  i + 1 = j\n\ngoal (1 subgoal):\n 1. Two \\<in> set (map (h2 i) ys) \\<Longrightarrow> False", "with Suc_i_not_in_ys and j_def"], ["proof (chain)\npicking this:\n  i + 1 \\<notin> set ys\n  j \\<in> set ys \\<and> Two = h2 i j\n  i + 1 = j", "show False"], ["proof (prove)\nusing this:\n  i + 1 \\<notin> set ys\n  j \\<in> set ys \\<and> Two = h2 i j\n  i + 1 = j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Two \\<notin> set (map (h2 i) ys)\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "have f2_One: \"\\<And>x y. x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow> f2 x y \\<noteq> Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow>\n       f2 x y \\<noteq> Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow>\n       f2 x y \\<noteq> Two", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow>\n       f2 x y \\<noteq> Two", "show \"x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow> f2 x y \\<noteq> Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow>\n    f2 x y \\<noteq> Two", "by (cases y, auto)"], ["proof (state)\nthis:\n  x \\<noteq> Two \\<and> y \\<noteq> Two \\<Longrightarrow> f2 x y \\<noteq> Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<noteq> Two \\<and> ?y \\<noteq> Two \\<Longrightarrow>\n  f2 ?x ?y \\<noteq> Two\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "have \"\\<And>xs. \\<lbrakk> xs \\<noteq> [] ; Two \\<notin> set xs \\<rbrakk> \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; Two \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; Two \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; Two \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two", "assume xs_not_empty: \"(xs :: three list) \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; Two \\<notin> set xs\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two", "thus \"Two \\<notin> set xs \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Two \\<notin> set xs \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two", "proof (induct xs rule: divide_and_conquer)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>Two \\<notin> set []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldl1 f2 [] \\<noteq> Two\n 2. \\<And>x.\n       \\<lbrakk>Two \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 [x] \\<noteq> Two\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "case Nil"], ["proof (state)\nthis:\n  Two \\<notin> set []\n  [] \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Two \\<notin> set []; [] \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> foldl1 f2 [] \\<noteq> Two\n 2. \\<And>x.\n       \\<lbrakk>Two \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 [x] \\<noteq> Two\n 3. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "thus ?case"], ["proof (prove)\nusing this:\n  Two \\<notin> set []\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 [] \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 [] \\<noteq> Two\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Two \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 [x] \\<noteq> Two\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Two \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 [x] \\<noteq> Two\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "case One"], ["proof (state)\nthis:\n  Two \\<notin> set [x_]\n  [x_] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Two \\<notin> set [x]; [x] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 [x] \\<noteq> Two\n 2. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "thus ?case"], ["proof (prove)\nusing this:\n  Two \\<notin> set [x_]\n  [x_] \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 [x_] \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 [x_] \\<noteq> Two\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "case (Partition xs ys)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\n  \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two\n  Two \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "hence \"Two \\<notin> set xs \\<and> Two \\<notin> set ys\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\n  \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two\n  Two \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. Two \\<notin> set xs \\<and> Two \\<notin> set ys", "by simp"], ["proof (state)\nthis:\n  Two \\<notin> set xs \\<and> Two \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "hence \"foldl1 f2 xs \\<noteq> Two \\<and> foldl1 f2 ys \\<noteq> Two\""], ["proof (prove)\nusing this:\n  Two \\<notin> set xs \\<and> Two \\<notin> set ys\n\ngoal (1 subgoal):\n 1. foldl1 f2 xs \\<noteq> Two \\<and> foldl1 f2 ys \\<noteq> Two", "using Partition"], ["proof (prove)\nusing this:\n  Two \\<notin> set xs \\<and> Two \\<notin> set ys\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\n  \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two\n  Two \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 xs \\<noteq> Two \\<and> foldl1 f2 ys \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 xs \\<noteq> Two \\<and> foldl1 f2 ys \\<noteq> Two\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "hence \"f2 (foldl1 f2 xs) (foldl1 f2 ys) \\<noteq> Two\""], ["proof (prove)\nusing this:\n  foldl1 f2 xs \\<noteq> Two \\<and> foldl1 f2 ys \\<noteq> Two\n\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 xs) (foldl1 f2 ys) \\<noteq> Two", "using f2_One"], ["proof (prove)\nusing this:\n  foldl1 f2 xs \\<noteq> Two \\<and> foldl1 f2 ys \\<noteq> Two\n  ?x \\<noteq> Two \\<and> ?y \\<noteq> Two \\<Longrightarrow>\n  f2 ?x ?y \\<noteq> Two\n\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 xs) (foldl1 f2 ys) \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  f2 (foldl1 f2 xs) (foldl1 f2 ys) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n        \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two;\n        \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two;\n        Two \\<notin> set (xs @ ys); xs @ ys \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> foldl1 f2 (xs @ ys) \\<noteq> Two", "thus \"foldl1 f2 (xs @ ys) \\<noteq> Two\""], ["proof (prove)\nusing this:\n  f2 (foldl1 f2 xs) (foldl1 f2 ys) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (xs @ ys) \\<noteq> Two", "using L8 [symmetric, where f=f2] and f2_assoc and Partition"], ["proof (prove)\nusing this:\n  f2 (foldl1 f2 xs) (foldl1 f2 ys) \\<noteq> Two\n  \\<lbrakk>associative f2; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f2 (foldl1 f2 ?xs) (foldl1 f2 ?ys) =\n                    foldl1 f2 (?xs @ ?ys)\n  associative f2\n  xs \\<noteq> []\n  ys \\<noteq> []\n  \\<lbrakk>Two \\<notin> set xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\n  \\<lbrakk>Two \\<notin> set ys; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ys \\<noteq> Two\n  Two \\<notin> set (xs @ ys)\n  xs @ ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 (xs @ ys) \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (xs @ ys) \\<noteq> Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Two \\<notin> set xs \\<Longrightarrow> foldl1 f2 xs \\<noteq> Two\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?xs \\<noteq> []; Two \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs \\<noteq> Two\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "with Two_map_ys"], ["proof (chain)\npicking this:\n  Two \\<notin> set (map (h2 i) ys)\n  \\<lbrakk>?xs \\<noteq> []; Two \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs \\<noteq> Two", "have foldl1_map_ys: \"foldl1 f2 (map (h2 i) ys) \\<noteq> Two\""], ["proof (prove)\nusing this:\n  Two \\<notin> set (map (h2 i) ys)\n  \\<lbrakk>?xs \\<noteq> []; Two \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs \\<noteq> Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) ys) \\<noteq> Two", "using ys_not_empty"], ["proof (prove)\nusing this:\n  Two \\<notin> set (map (h2 i) ys)\n  \\<lbrakk>?xs \\<noteq> []; Two \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 ?xs \\<noteq> Two\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) ys) \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (map (h2 i) ys) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "from f2_One"], ["proof (chain)\npicking this:\n  ?x \\<noteq> Two \\<and> ?y \\<noteq> Two \\<Longrightarrow>\n  f2 ?x ?y \\<noteq> Two", "have \"f2 (foldl1 f2 (map (h2 i) xs)) (foldl1 f2 (map (h2 i) ys)) \\<noteq> Two\""], ["proof (prove)\nusing this:\n  ?x \\<noteq> Two \\<and> ?y \\<noteq> Two \\<Longrightarrow>\n  f2 ?x ?y \\<noteq> Two\n\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 (map (h2 i) xs)) (foldl1 f2 (map (h2 i) ys)) \\<noteq> Two", "using foldl1_map_xs and foldl1_map_ys"], ["proof (prove)\nusing this:\n  ?x \\<noteq> Two \\<and> ?y \\<noteq> Two \\<Longrightarrow>\n  f2 ?x ?y \\<noteq> Two\n  foldl1 f2 (map (h2 i) xs) = One\n  foldl1 f2 (map (h2 i) ys) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. f2 (foldl1 f2 (map (h2 i) xs)) (foldl1 f2 (map (h2 i) ys)) \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  f2 (foldl1 f2 (map (h2 i) xs)) (foldl1 f2 (map (h2 i) ys)) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "hence \"foldl1 f2 (map (h2 i) (xs @ ys)) \\<noteq> Two\""], ["proof (prove)\nusing this:\n  f2 (foldl1 f2 (map (h2 i) xs)) (foldl1 f2 (map (h2 i) ys)) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) (xs @ ys)) \\<noteq> Two", "using foldl1_map [symmetric, where h=\"h2 i\" and f=f2] and f2_assoc \n      and assms and ys_not_empty"], ["proof (prove)\nusing this:\n  f2 (foldl1 f2 (map (h2 i) xs)) (foldl1 f2 (map (h2 i) ys)) \\<noteq> Two\n  \\<lbrakk>associative f2; ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> f2 (foldl1 f2 (map (h2 i) ?xs))\n                     (foldl1 f2 (map (h2 i) ?ys)) =\n                    foldl1 f2 (map (h2 i) (?xs @ ?ys))\n  associative f2\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. foldl1 f2 (map (h2 i) (xs @ ys)) \\<noteq> Two", "by simp"], ["proof (state)\nthis:\n  foldl1 f2 (map (h2 i) (xs @ ys)) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. i + 1 \\<notin> set ys \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n  foldl1 f2 (map (h2 i) (xs @ ys)) \\<noteq> Two", "show False"], ["proof (prove)\nusing this:\n  foldl1 f2 (map (h2 i) js) = Two\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n  foldl1 f2 (map (h2 i) (xs @ ys)) \\<noteq> Two\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Permutations and Lemma 4\\<close>"], ["", "text \\<open>\nIn the original paper, the argumentation goes as follows:\nFrom \\<open>Figure_4\\<close> and \\<open>Figure_5\\<close> we can show that \\<open>js\\<close>\ncontains every \\<open>i \\<le> k\\<close> exactly once, and from \\<open>Figure_6\\<close> we can\nfurthermore show that \\<open>js\\<close> contains no other elements. Thus, \\<open>js\\<close>\nmust be a permutation of \\<open>[0..<k + 1]\\<close>.\n\nHere, however, the argumentation is different, because we want to use already\nexisting results. Therefore, we show first, that the sets of \\<open>js\\<close> and\n\\<open>[0..<k + 1]\\<close> are equal using the results of \\<open>Figure_4\\<close> and\n\\<open>Figure_6\\<close>. Second, we show that \\<open>js\\<close> is a distinct list, i.e. no\nelement occurs twice in \\<open>js\\<close>. Since also \\<open>[0..<k + 1]\\<close> is\ndistinct, the multisets of \\<open>js\\<close> and \\<open>[0..<k + 1]\\<close> are equal,\nand therefore, both lists are permutations.\n\\<close>"], ["", "lemma js_is_a_permutation:\n  assumes A1: \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f\n                \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and A2: \"js \\<noteq> []\"\n  shows \"js <~~> [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "from A1 and L9"], ["proof (chain)\npicking this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?i \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 (map (h1 ?k ?i) ?js) = One", "have L9': \n  \"\\<And>i. i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k i) js) = One\""], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?i \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> foldl1 f1 (map (h1 ?k ?i) ?js) = One\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k i) js) = One", "by auto"], ["proof (state)\nthis:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "from L9' and Figure_4 and A2"], ["proof (chain)\npicking this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  \\<lbrakk>foldl1 f1 (map (h1 ?k ?i) ?js) = One; ?js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> set ?js\n  js \\<noteq> []", "have P1: \"\\<And>i. i \\<le> k \\<Longrightarrow> i \\<in> set js\""], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  \\<lbrakk>foldl1 f1 (map (h1 ?k ?i) ?js) = One; ?js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> set ?js\n  js \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> k \\<Longrightarrow> i \\<in> set js", "by auto"], ["proof (state)\nthis:\n  ?i \\<le> k \\<Longrightarrow> ?i \\<in> set js\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "from L9' and Figure_5"], ["proof (chain)\npicking this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  \\<lbrakk>foldl1 f1 (map (h1 ?k ?i) ?js) = One; ?js = ?xs @ ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<not> (?i \\<in> set ?xs \\<and> ?i \\<in> set ?ys)", "have P2:\n    \"\\<And>i xs ys. \\<lbrakk> i \\<le> k ; js = xs @ ys \\<rbrakk> \\<Longrightarrow> \\<not>(i \\<in> set xs \\<and> i \\<in> set ys)\""], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  \\<lbrakk>foldl1 f1 (map (h1 ?k ?i) ?js) = One; ?js = ?xs @ ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<not> (?i \\<in> set ?xs \\<and> ?i \\<in> set ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>i \\<le> k; js = xs @ ys\\<rbrakk>\n       \\<Longrightarrow> \\<not> (i \\<in> set xs \\<and> i \\<in> set ys)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> k; js = ?xs @ ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<not> (?i \\<in> set ?xs \\<and> ?i \\<in> set ?ys)\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "from L9' and Figure_6"], ["proof (chain)\npicking this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  \\<lbrakk>\\<And>i.\n              i \\<le> ?k \\<Longrightarrow>\n              foldl1 f1 (map (h1 ?k i) ?js) = One;\n   ?k < ?i\\<rbrakk>\n  \\<Longrightarrow> ?i \\<notin> set ?js", "have P3: \"\\<And>i. i > k \\<Longrightarrow> i \\<notin> set js\""], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> foldl1 f1 (map (h1 k ?i) js) = One\n  \\<lbrakk>\\<And>i.\n              i \\<le> ?k \\<Longrightarrow>\n              foldl1 f1 (map (h1 ?k i) ?js) = One;\n   ?k < ?i\\<rbrakk>\n  \\<Longrightarrow> ?i \\<notin> set ?js\n\ngoal (1 subgoal):\n 1. \\<And>i. k < i \\<Longrightarrow> i \\<notin> set js", "by auto"], ["proof (state)\nthis:\n  k < ?i \\<Longrightarrow> ?i \\<notin> set js\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "have set_eq: \"set [0..<k + 1] = set js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [0..<k + 1] = set js", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set [0..<k + 1] \\<subseteq> set js\n 2. set js \\<subseteq> set [0..<k + 1]", "from P1"], ["proof (chain)\npicking this:\n  ?i \\<le> k \\<Longrightarrow> ?i \\<in> set js", "show \"set [0..<k + 1] \\<subseteq> set js\""], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> ?i \\<in> set js\n\ngoal (1 subgoal):\n 1. set [0..<k + 1] \\<subseteq> set js", "by auto"], ["proof (state)\nthis:\n  set [0..<k + 1] \\<subseteq> set js\n\ngoal (1 subgoal):\n 1. set js \\<subseteq> set [0..<k + 1]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set js \\<subseteq> set [0..<k + 1]", "show \"set js \\<subseteq> set [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set js \\<subseteq> set [0..<k + 1]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set js \\<Longrightarrow> x \\<in> set [0..<k + 1]", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set js \\<Longrightarrow> x \\<in> set [0..<k + 1]", "assume \"j \\<in> set js\""], ["proof (state)\nthis:\n  j \\<in> set js\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set js \\<Longrightarrow> x \\<in> set [0..<k + 1]", "hence \"\\<not>(j \\<notin> set js)\""], ["proof (prove)\nusing this:\n  j \\<in> set js\n\ngoal (1 subgoal):\n 1. \\<not> j \\<notin> set js", "by simp"], ["proof (state)\nthis:\n  \\<not> j \\<notin> set js\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set js \\<Longrightarrow> x \\<in> set [0..<k + 1]", "with P3"], ["proof (chain)\npicking this:\n  k < ?i \\<Longrightarrow> ?i \\<notin> set js\n  \\<not> j \\<notin> set js", "have \"\\<not>(j > k)\""], ["proof (prove)\nusing this:\n  k < ?i \\<Longrightarrow> ?i \\<notin> set js\n  \\<not> j \\<notin> set js\n\ngoal (1 subgoal):\n 1. \\<not> k < j", "using HOL.contrapos_nn"], ["proof (prove)\nusing this:\n  k < ?i \\<Longrightarrow> ?i \\<notin> set js\n  \\<not> j \\<notin> set js\n  \\<lbrakk>\\<not> ?Q; ?P \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?P\n\ngoal (1 subgoal):\n 1. \\<not> k < j", "by auto"], ["proof (state)\nthis:\n  \\<not> k < j\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set js \\<Longrightarrow> x \\<in> set [0..<k + 1]", "hence \"j \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k < j\n\ngoal (1 subgoal):\n 1. j \\<le> k", "by simp"], ["proof (state)\nthis:\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set js \\<Longrightarrow> x \\<in> set [0..<k + 1]", "thus \"j \\<in> set [0..<k + 1]\""], ["proof (prove)\nusing this:\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. j \\<in> set [0..<k + 1]", "by auto"], ["proof (state)\nthis:\n  j \\<in> set [0..<k + 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set js \\<subseteq> set [0..<k + 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set [0..<k + 1] = set js\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "have \"\\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}", "assume js_xs_ys: \"js = xs @ ys\""], ["proof (state)\nthis:\n  js = xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}", "with set_eq"], ["proof (chain)\npicking this:\n  set [0..<k + 1] = set js\n  js = xs @ ys", "have i_xs_ys: \"\\<And>i. i \\<in> set xs \\<or> i \\<in> set ys \\<Longrightarrow> i \\<le> k\""], ["proof (prove)\nusing this:\n  set [0..<k + 1] = set js\n  js = xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set xs \\<or> i \\<in> set ys \\<Longrightarrow> i \\<le> k", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> set xs \\<or> ?i \\<in> set ys \\<Longrightarrow> ?i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}", "have \"\\<And>i. i \\<le> k \\<Longrightarrow> (i \\<in> set xs) = (i \\<notin> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> k \\<Longrightarrow> (i \\<in> set xs) = (i \\<notin> set ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set ys\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set ys\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "assume \"i \\<in> set xs\""], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set ys\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "moreover"], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set ys\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "assume \"i \\<le> k\""], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set ys\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> set xs\n  i \\<le> k", "show \"i \\<notin> set ys\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<notin> set ys", "using js_xs_ys and P2"], ["proof (prove)\nusing this:\n  i \\<in> set xs\n  i \\<le> k\n  js = xs @ ys\n  \\<lbrakk>?i \\<le> k; js = ?xs @ ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<not> (?i \\<in> set ?xs \\<and> ?i \\<in> set ?ys)\n\ngoal (1 subgoal):\n 1. i \\<notin> set ys", "by simp"], ["proof (state)\nthis:\n  i \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "assume \"i \\<notin> set ys\""], ["proof (state)\nthis:\n  i \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "moreover"], ["proof (state)\nthis:\n  i \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "assume \"i \\<le> k\""], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> k; i \\<notin> set ys\\<rbrakk>\n       \\<Longrightarrow> i \\<in> set xs", "ultimately"], ["proof (chain)\npicking this:\n  i \\<notin> set ys\n  i \\<le> k", "show \"i \\<in> set xs\""], ["proof (prove)\nusing this:\n  i \\<notin> set ys\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<in> set xs", "using js_xs_ys and P2 and P1"], ["proof (prove)\nusing this:\n  i \\<notin> set ys\n  i \\<le> k\n  js = xs @ ys\n  \\<lbrakk>?i \\<le> k; js = ?xs @ ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<not> (?i \\<in> set ?xs \\<and> ?i \\<in> set ?ys)\n  ?i \\<le> k \\<Longrightarrow> ?i \\<in> set js\n\ngoal (1 subgoal):\n 1. i \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<le> k \\<Longrightarrow> (?i \\<in> set xs) = (?i \\<notin> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys. js = xs @ ys \\<Longrightarrow> set xs \\<inter> set ys = {}", "thus \"set xs \\<inter> set ys = {}\""], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> (?i \\<in> set xs) = (?i \\<notin> set ys)\n\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys = {}", "using i_xs_ys"], ["proof (prove)\nusing this:\n  ?i \\<le> k \\<Longrightarrow> (?i \\<in> set xs) = (?i \\<notin> set ys)\n  ?i \\<in> set xs \\<or> ?i \\<in> set ys \\<Longrightarrow> ?i \\<le> k\n\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys = {}", "by auto"], ["proof (state)\nthis:\n  set xs \\<inter> set ys = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  js = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "with all_set_inter_empty_distinct"], ["proof (chain)\npicking this:\n  (\\<And>xs ys.\n      ?js = xs @ ys \\<Longrightarrow>\n      set xs \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct ?js\n  js = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}", "have \"distinct js\""], ["proof (prove)\nusing this:\n  (\\<And>xs ys.\n      ?js = xs @ ys \\<Longrightarrow>\n      set xs \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct ?js\n  js = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. distinct js", "using A2"], ["proof (prove)\nusing this:\n  (\\<And>xs ys.\n      ?js = xs @ ys \\<Longrightarrow>\n      set xs \\<inter> set ys = {}) \\<Longrightarrow>\n  distinct ?js\n  js = ?xs @ ?ys \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  js \\<noteq> []\n\ngoal (1 subgoal):\n 1. distinct js", "by auto"], ["proof (state)\nthis:\n  distinct js\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "with set_eq"], ["proof (chain)\npicking this:\n  set [0..<k + 1] = set js\n  distinct js", "have \"mset js = mset [0..<k + 1]\""], ["proof (prove)\nusing this:\n  set [0..<k + 1] = set js\n  distinct js\n\ngoal (1 subgoal):\n 1. mset js = mset [0..<k + 1]", "using Multiset.set_eq_iff_mset_eq_distinct \n          [where x=js and y=\"[0..<k + 1]\"]"], ["proof (prove)\nusing this:\n  set [0..<k + 1] = set js\n  distinct js\n  \\<lbrakk>distinct js; distinct [0..<k + 1]\\<rbrakk>\n  \\<Longrightarrow> (set js = set [0..<k + 1]) =\n                    (mset js = mset [0..<k + 1])\n\ngoal (1 subgoal):\n 1. mset js = mset [0..<k + 1]", "by simp"], ["proof (state)\nthis:\n  mset js = mset [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "thus \"js <~~> [0..<k + 1]\""], ["proof (prove)\nusing this:\n  mset js = mset [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "using Permutation.mset_eq_perm [where xs=js and ys=\"[0..<k + 1]\"]"], ["proof (prove)\nusing this:\n  mset js = mset [0..<k + 1]\n  (mset js = mset [0..<k + 1]) = (js <~~> [0..<k + 1])\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "by simp"], ["proof (state)\nthis:\n  js <~~> [0..<k + 1]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe result of \\<open>Figure_7\\<close> is too specific. Instead of having that every\n\\<open>i\\<close> is eventually followed by \\<open>i + 1\\<close>, it more useful to know\nthat every \\<open>i\\<close> is followed by all \\<open>i + r\\<close>, where \n\\<open>r > 0\\<close>. This result follows easily by induction from \n\\<open>Figure_7\\<close>.\n\\<close>"], ["", "lemma Figure_7_trans:\n  assumes A1: \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                         \\<Longrightarrow> (i + 1) \\<in> set ys\"\n      and A2: \"(r::nat) > 0\"\n      and A3: \"i + r \\<le> k\"\n      and A4: \"js = xs @ ys\"\n      and A5: \"xs \\<noteq> []\"\n      and A6: \"i = last xs\"\n  shows \"(i + r) \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + r \\<in> set ys", "using A2 A3"], ["proof (prove)\nusing this:\n  0 < r\n  i + r \\<le> k\n\ngoal (1 subgoal):\n 1. i + r \\<in> set ys", "proof (induct r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; i + 0 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> i + 0 \\<in> set ys\n 2. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "case 0"], ["proof (state)\nthis:\n  0 < 0\n  i + 0 \\<le> k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; i + 0 \\<le> k\\<rbrakk>\n    \\<Longrightarrow> i + 0 \\<in> set ys\n 2. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "thus ?case"], ["proof (prove)\nusing this:\n  0 < 0\n  i + 0 \\<le> k\n\ngoal (1 subgoal):\n 1. i + 0 \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  i + 0 \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "case (Suc r)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n  \\<Longrightarrow> i + r \\<in> set ys\n  0 < Suc r\n  i + Suc r \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "hence IH: \"0 < r \\<Longrightarrow> (i + r) \\<in> set ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n  \\<Longrightarrow> i + r \\<in> set ys\n  0 < Suc r\n  i + Suc r \\<le> k\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> i + r \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  0 < r \\<Longrightarrow> i + r \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n  \\<Longrightarrow> i + r \\<in> set ys\n  0 < Suc r\n  i + Suc r \\<le> k", "have i_r_k: \"i + Suc r \\<le> k\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n  \\<Longrightarrow> i + r \\<in> set ys\n  0 < Suc r\n  i + Suc r \\<le> k\n\ngoal (1 subgoal):\n 1. i + Suc r \\<le> k", "by simp"], ["proof (state)\nthis:\n  i + Suc r \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<lbrakk>0 < r; i + r \\<le> k\\<rbrakk>\n                \\<Longrightarrow> i + r \\<in> set ys;\n        0 < Suc r; i + Suc r \\<le> k\\<rbrakk>\n       \\<Longrightarrow> i + Suc r \\<in> set ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set ys", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> i + Suc r \\<in> set ys\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "case 0"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> i + Suc r \\<in> set ys\n 2. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set ys", "using A1 and i_r_k and A4 and A5 and A6"], ["proof (prove)\nusing this:\n  r = 0\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n  i + Suc r \\<le> k\n  js = xs @ ys\n  xs \\<noteq> []\n  i = last xs\n\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  i + Suc r \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "case Suc"], ["proof (state)\nthis:\n  r = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "with IH"], ["proof (chain)\npicking this:\n  0 < r \\<Longrightarrow> i + r \\<in> set ys\n  r = Suc nat_", "have \"(i + r) \\<in> set ys\""], ["proof (prove)\nusing this:\n  0 < r \\<Longrightarrow> i + r \\<in> set ys\n  r = Suc nat_\n\ngoal (1 subgoal):\n 1. i + r \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  i + r \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  i + r \\<in> set ys", "obtain p where p_def: \"p < length ys \\<and> ys ! p = i + r\""], ["proof (prove)\nusing this:\n  i + r \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p < length ys \\<and> ys ! p = i + r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using List.in_set_conv_nth [where x=\"i + r\"]"], ["proof (prove)\nusing this:\n  i + r \\<in> set ys\n  (i + r \\<in> set ?xs) = (\\<exists>ia<length ?xs. ?xs ! ia = i + r)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p < length ys \\<and> ys ! p = i + r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p < length ys \\<and> ys ! p = i + r\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "let ?xs = \"xs @ take (p + 1) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "let ?ys = \"drop (p + 1) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "have \"i + r < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + r < k", "using i_r_k"], ["proof (prove)\nusing this:\n  i + Suc r \\<le> k\n\ngoal (1 subgoal):\n 1. i + r < k", "by simp"], ["proof (state)\nthis:\n  i + r < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "moreover"], ["proof (state)\nthis:\n  i + r < k\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "have \"js = ?xs @ ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. js = (xs @ take (p + 1) ys) @ drop (p + 1) ys", "using A4"], ["proof (prove)\nusing this:\n  js = xs @ ys\n\ngoal (1 subgoal):\n 1. js = (xs @ take (p + 1) ys) @ drop (p + 1) ys", "by simp"], ["proof (state)\nthis:\n  js = (xs @ take (p + 1) ys) @ drop (p + 1) ys\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "moreover"], ["proof (state)\nthis:\n  js = (xs @ take (p + 1) ys) @ drop (p + 1) ys\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "have \"?xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ take (p + 1) ys \\<noteq> []", "using A5"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs @ take (p + 1) ys \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xs @ take (p + 1) ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "moreover"], ["proof (state)\nthis:\n  xs @ take (p + 1) ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "have \"i + r = last ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + r = last (xs @ take (p + 1) ys)", "using p_def and List.take_Suc_conv_app_nth [where i=p and xs=ys]"], ["proof (prove)\nusing this:\n  p < length ys \\<and> ys ! p = i + r\n  p < length ys \\<Longrightarrow> take (Suc p) ys = take p ys @ [ys ! p]\n\ngoal (1 subgoal):\n 1. i + r = last (xs @ take (p + 1) ys)", "by simp"], ["proof (state)\nthis:\n  i + r = last (xs @ take (p + 1) ys)\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "ultimately"], ["proof (chain)\npicking this:\n  i + r < k\n  js = (xs @ take (p + 1) ys) @ drop (p + 1) ys\n  xs @ take (p + 1) ys \\<noteq> []\n  i + r = last (xs @ take (p + 1) ys)", "have \"(i + Suc r) \\<in> set ?ys\""], ["proof (prove)\nusing this:\n  i + r < k\n  js = (xs @ take (p + 1) ys) @ drop (p + 1) ys\n  xs @ take (p + 1) ys \\<noteq> []\n  i + r = last (xs @ take (p + 1) ys)\n\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set (drop (p + 1) ys)", "using A1 [where i=\"i + r\"]"], ["proof (prove)\nusing this:\n  i + r < k\n  js = (xs @ take (p + 1) ys) @ drop (p + 1) ys\n  xs @ take (p + 1) ys \\<noteq> []\n  i + r = last (xs @ take (p + 1) ys)\n  \\<lbrakk>i + r < k; js = ?xs @ ?ys; ?xs \\<noteq> [];\n   i + r = last ?xs\\<rbrakk>\n  \\<Longrightarrow> i + r + 1 \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set (drop (p + 1) ys)", "by auto"], ["proof (state)\nthis:\n  i + Suc r \\<in> set (drop (p + 1) ys)\n\ngoal (1 subgoal):\n 1. \\<And>nat. r = Suc nat \\<Longrightarrow> i + Suc r \\<in> set ys", "thus \"(i + Suc r) \\<in> set ys\""], ["proof (prove)\nusing this:\n  i + Suc r \\<in> set (drop (p + 1) ys)\n\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set ys", "using List.set_drop_subset [where xs=ys]"], ["proof (prove)\nusing this:\n  i + Suc r \\<in> set (drop (p + 1) ys)\n  set (drop ?n ys) \\<subseteq> set ys\n\ngoal (1 subgoal):\n 1. i + Suc r \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  i + Suc r \\<in> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i + Suc r \\<in> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nSince we want to use Lemma \\<open>partitions_sorted\\<close> to show that \\<open>js\\<close>\nis sorted, we need yet another result which can be obtained using the\nprevious lemma and some further argumentation:\n\\<close>"], ["", "lemma js_partition_order:\n  assumes A1: \"js <~~> [0..<k + 1]\"\n      and A2: \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                         \\<Longrightarrow> (i + 1) \\<in> set ys\"\n      and A3: \"js = xs @ ys\"\n      and A4: \"i \\<in> set xs\" \n      and A5: \"j \\<in> set ys\"\n  shows \"i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "assume \"\\<not>(i \\<le> j)\""], ["proof (state)\nthis:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "hence i_j: \"i > j\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "from A5"], ["proof (chain)\npicking this:\n  j \\<in> set ys", "obtain pj where pj_def: \"pj < length ys \\<and> ys ! pj = j\""], ["proof (prove)\nusing this:\n  j \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>pj.\n        pj < length ys \\<and> ys ! pj = j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using List.in_set_conv_nth [where x=j]"], ["proof (prove)\nusing this:\n  j \\<in> set ys\n  (j \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = j)\n\ngoal (1 subgoal):\n 1. (\\<And>pj.\n        pj < length ys \\<and> ys ! pj = j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pj < length ys \\<and> ys ! pj = j\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "let ?xs = \"xs @ take (pj + 1) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "let ?ys = \"drop (pj + 1) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "let ?r = \"i - j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "from A1 and A3"], ["proof (chain)\npicking this:\n  js <~~> [0..<k + 1]\n  js = xs @ ys", "have \"distinct (xs @ ys)\""], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  js = xs @ ys\n\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "using Permutation.perm_distinct_iff [where xs=\"xs @ ys\"]"], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  js = xs @ ys\n  xs @ ys <~~> ?ys \\<Longrightarrow> distinct (xs @ ys) = distinct ?ys\n\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "by auto"], ["proof (state)\nthis:\n  distinct (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "hence xs_ys_inter_empty: \"set xs \\<inter> set ys = {}\""], ["proof (prove)\nusing this:\n  distinct (xs @ ys)\n\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys = {}", "by simp"], ["proof (state)\nthis:\n  set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "from A2 and Figure_7_trans"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n  \\<lbrakk>\\<And>i xs ys.\n              \\<lbrakk>i < ?k; ?js = xs @ ys; xs \\<noteq> [];\n               i = last xs\\<rbrakk>\n              \\<Longrightarrow> i + 1 \\<in> set ys;\n   0 < ?r; ?i + ?r \\<le> ?k; ?js = ?xs @ ?ys; ?xs \\<noteq> [];\n   ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + ?r \\<in> set ?ys", "have\n  \"\\<And>i r xs ys. \\<lbrakk> r > 0 ; i + r \\<le> k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n               \\<Longrightarrow> (i + r) \\<in> set ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n  \\<lbrakk>\\<And>i xs ys.\n              \\<lbrakk>i < ?k; ?js = xs @ ys; xs \\<noteq> [];\n               i = last xs\\<rbrakk>\n              \\<Longrightarrow> i + 1 \\<in> set ys;\n   0 < ?r; ?i + ?r \\<le> ?k; ?js = ?xs @ ?ys; ?xs \\<noteq> [];\n   ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + ?r \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>i r xs ys.\n       \\<lbrakk>0 < r; i + r \\<le> k; js = xs @ ys; xs \\<noteq> [];\n        i = last xs\\<rbrakk>\n       \\<Longrightarrow> i + r \\<in> set ys", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?r; ?i + ?r \\<le> k; js = ?xs @ ?ys; ?xs \\<noteq> [];\n   ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + ?r \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?r; ?i + ?r \\<le> k; js = ?xs @ ?ys; ?xs \\<noteq> [];\n   ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + ?r \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "from i_j"], ["proof (chain)\npicking this:\n  j < i", "have \"?r > 0\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. 0 < i - j", "by simp"], ["proof (state)\nthis:\n  0 < i - j\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < i - j\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "have \"j + ?r \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "have \"i \\<in> set js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set js", "using A4 and A3"], ["proof (prove)\nusing this:\n  i \\<in> set xs\n  js = xs @ ys\n\ngoal (1 subgoal):\n 1. i \\<in> set js", "by simp"], ["proof (state)\nthis:\n  i \\<in> set js\n\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "hence \"i \\<in> set [0..<k + 1]\""], ["proof (prove)\nusing this:\n  i \\<in> set js\n\ngoal (1 subgoal):\n 1. i \\<in> set [0..<k + 1]", "using A1 and Permutation.perm_set_eq"], ["proof (prove)\nusing this:\n  i \\<in> set js\n  js <~~> [0..<k + 1]\n  ?xs <~~> ?ys \\<Longrightarrow> set ?xs = set ?ys\n\ngoal (1 subgoal):\n 1. i \\<in> set [0..<k + 1]", "by blast"], ["proof (state)\nthis:\n  i \\<in> set [0..<k + 1]\n\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "hence \"i \\<le> k\""], ["proof (prove)\nusing this:\n  i \\<in> set [0..<k + 1]\n\ngoal (1 subgoal):\n 1. i \\<le> k", "by auto"], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "using i_j"], ["proof (prove)\nusing this:\n  i \\<le> k\n  j < i\n\ngoal (1 subgoal):\n 1. j + (i - j) \\<le> k", "by simp"], ["proof (state)\nthis:\n  j + (i - j) \\<le> k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j + (i - j) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j + (i - j) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "have \"js = ?xs @ ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. js = (xs @ take (pj + 1) ys) @ drop (pj + 1) ys", "using A3"], ["proof (prove)\nusing this:\n  js = xs @ ys\n\ngoal (1 subgoal):\n 1. js = (xs @ take (pj + 1) ys) @ drop (pj + 1) ys", "by simp"], ["proof (state)\nthis:\n  js = (xs @ take (pj + 1) ys) @ drop (pj + 1) ys\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  js = (xs @ take (pj + 1) ys) @ drop (pj + 1) ys\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "have \"?xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ take (pj + 1) ys \\<noteq> []", "using A4"], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs @ take (pj + 1) ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs @ take (pj + 1) ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  xs @ take (pj + 1) ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "have \"j = last (?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = last (xs @ take (pj + 1) ys)", "using pj_def and List.take_Suc_conv_app_nth [where i=pj and xs=ys]"], ["proof (prove)\nusing this:\n  pj < length ys \\<and> ys ! pj = j\n  pj < length ys \\<Longrightarrow> take (Suc pj) ys = take pj ys @ [ys ! pj]\n\ngoal (1 subgoal):\n 1. j = last (xs @ take (pj + 1) ys)", "by simp"], ["proof (state)\nthis:\n  j = last (xs @ take (pj + 1) ys)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?r; ?i + ?r \\<le> k; js = ?xs @ ?ys; ?xs \\<noteq> [];\n   ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + ?r \\<in> set ?ys\n  0 < i - j\n  j + (i - j) \\<le> k\n  js = (xs @ take (pj + 1) ys) @ drop (pj + 1) ys\n  xs @ take (pj + 1) ys \\<noteq> []\n  j = last (xs @ take (pj + 1) ys)", "have \"(j + ?r) \\<in> set ?ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?r; ?i + ?r \\<le> k; js = ?xs @ ?ys; ?xs \\<noteq> [];\n   ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + ?r \\<in> set ?ys\n  0 < i - j\n  j + (i - j) \\<le> k\n  js = (xs @ take (pj + 1) ys) @ drop (pj + 1) ys\n  xs @ take (pj + 1) ys \\<noteq> []\n  j = last (xs @ take (pj + 1) ys)\n\ngoal (1 subgoal):\n 1. j + (i - j) \\<in> set (drop (pj + 1) ys)", "by blast"], ["proof (state)\nthis:\n  j + (i - j) \\<in> set (drop (pj + 1) ys)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "hence \"i \\<in> set ys\""], ["proof (prove)\nusing this:\n  j + (i - j) \\<in> set (drop (pj + 1) ys)\n\ngoal (1 subgoal):\n 1. i \\<in> set ys", "using i_j and List.set_drop_subset [where xs=ys]"], ["proof (prove)\nusing this:\n  j + (i - j) \\<in> set (drop (pj + 1) ys)\n  j < i\n  set (drop ?n ys) \\<subseteq> set ys\n\ngoal (1 subgoal):\n 1. i \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  i \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow> False", "with A4 and xs_ys_inter_empty"], ["proof (chain)\npicking this:\n  i \\<in> set xs\n  set xs \\<inter> set ys = {}\n  i \\<in> set ys", "show False"], ["proof (prove)\nusing this:\n  i \\<in> set xs\n  set xs \\<inter> set ys = {}\n  i \\<in> set ys\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWith the help of the previous lemma, we show now that \\<open>js\\<close> equals\n\\<open>[0..<k + 1]\\<close>, if both lists are permutations and every \\<open>i\\<close> is\neventually followed by \\<open>i + 1\\<close> in \\<open>js\\<close>.\n\\<close>"], ["", "lemma js_equals_upt_k:\n  assumes A1: \"js <~~> [0..<k + 1]\"\n      and A2: \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                         \\<Longrightarrow> (i + 1) \\<in> set ys\"\n  shows \"js = [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "from A1 and A2 and js_partition_order"], ["proof (chain)\npicking this:\n  js <~~> [0..<k + 1]\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n  \\<lbrakk>?js <~~> [0..<?k + 1];\n   \\<And>i xs ys.\n      \\<lbrakk>i < ?k; ?js = xs @ ys; xs \\<noteq> []; i = last xs\\<rbrakk>\n      \\<Longrightarrow> i + 1 \\<in> set ys;\n   ?js = ?xs @ ?ys; ?i \\<in> set ?xs; ?j \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> ?j", "have \"\\<And>xs ys x y. \\<lbrakk> js = xs @ ys ; x \\<in> set xs ; y \\<in> set ys \\<rbrakk> \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n  \\<lbrakk>?js <~~> [0..<?k + 1];\n   \\<And>i xs ys.\n      \\<lbrakk>i < ?k; ?js = xs @ ys; xs \\<noteq> []; i = last xs\\<rbrakk>\n      \\<Longrightarrow> i + 1 \\<in> set ys;\n   ?js = ?xs @ ?ys; ?i \\<in> set ?xs; ?j \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> ?j\n\ngoal (1 subgoal):\n 1. \\<And>xs ys x y.\n       \\<lbrakk>js = xs @ ys; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>js = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "hence \"sorted js\""], ["proof (prove)\nusing this:\n  \\<lbrakk>js = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted js", "using partitions_sorted"], ["proof (prove)\nusing this:\n  \\<lbrakk>js = ?xs @ ?ys; ?x \\<in> set ?xs; ?y \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  (\\<And>xs ys x y.\n      \\<lbrakk>?js = xs @ ys; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ?js\n\ngoal (1 subgoal):\n 1. sorted js", "by blast"], ["proof (state)\nthis:\n  sorted js\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "moreover"], ["proof (state)\nthis:\n  sorted js\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "have \"distinct js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct js", "using A1 and Permutation.perm_distinct_iff and List.distinct_upt"], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  ?xs <~~> ?ys \\<Longrightarrow> distinct ?xs = distinct ?ys\n  distinct [?i..<?j]\n\ngoal (1 subgoal):\n 1. distinct js", "by blast"], ["proof (state)\nthis:\n  distinct js\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "moreover"], ["proof (state)\nthis:\n  distinct js\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "have \"sorted [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted [0..<k + 1]", "using List.sorted_upt"], ["proof (prove)\nusing this:\n  sorted [?m..<?n]\n\ngoal (1 subgoal):\n 1. sorted [0..<k + 1]", "by blast"], ["proof (state)\nthis:\n  sorted [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "moreover"], ["proof (state)\nthis:\n  sorted [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "have \"distinct [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [0..<k + 1]", "by simp"], ["proof (state)\nthis:\n  distinct [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "moreover"], ["proof (state)\nthis:\n  distinct [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "have \"set js = set [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set js = set [0..<k + 1]", "using A1 and Permutation.perm_set_eq"], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  ?xs <~~> ?ys \\<Longrightarrow> set ?xs = set ?ys\n\ngoal (1 subgoal):\n 1. set js = set [0..<k + 1]", "by blast"], ["proof (state)\nthis:\n  set js = set [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "ultimately"], ["proof (chain)\npicking this:\n  sorted js\n  distinct js\n  sorted [0..<k + 1]\n  distinct [0..<k + 1]\n  set js = set [0..<k + 1]", "show \"js = [0..<k + 1]\""], ["proof (prove)\nusing this:\n  sorted js\n  distinct js\n  sorted [0..<k + 1]\n  distinct [0..<k + 1]\n  set js = set [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "using List.sorted_distinct_set_unique"], ["proof (prove)\nusing this:\n  sorted js\n  distinct js\n  sorted [0..<k + 1]\n  distinct [0..<k + 1]\n  set js = set [0..<k + 1]\n  \\<lbrakk>sorted ?xs; distinct ?xs; sorted ?ys; distinct ?ys;\n   set ?xs = set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "by blast"], ["proof (state)\nthis:\n  js = [0..<k + 1]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nFrom all the work done before, we conclude now Lemma 4:\n\\<close>"], ["", "lemma Lemma_4:\n  assumes \"\\<And>(f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f  \n             \\<Longrightarrow> foldl1 f (map h js) = foldl1 f (map h [0..<k + 1])\"\n      and \"js \\<noteq> []\"\n  shows \"js = [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "from assms and js_is_a_permutation"], ["proof (chain)\npicking this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  js \\<noteq> []\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?js <~~> [0..<?k + 1]", "have \"js <~~> [0..<k + 1]\""], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  js \\<noteq> []\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?js <~~> [0..<?k + 1]\n\ngoal (1 subgoal):\n 1. js <~~> [0..<k + 1]", "by auto"], ["proof (state)\nthis:\n  js <~~> [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "moreover"], ["proof (state)\nthis:\n  js <~~> [0..<k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "from assms and L10 and Figure_7"], ["proof (chain)\npicking this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  js \\<noteq> []\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?i < ?k\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 (map (h2 ?i) ?js) = Two\n  \\<lbrakk>foldl1 f2 (map (h2 ?i) ?js) = Two; ?js = ?xs @ ?ys;\n   ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys", "have \"\\<And>i xs ys. \\<lbrakk> i < k ; js = xs @ ys ; xs \\<noteq> [] ; i = last xs \\<rbrakk>\n                  \\<Longrightarrow> (i + 1) \\<in> set ys\""], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h js) = foldl1 ?f (map ?h [0..<k + 1])\n  js \\<noteq> []\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?i < ?k\\<rbrakk>\n  \\<Longrightarrow> foldl1 f2 (map (h2 ?i) ?js) = Two\n  \\<lbrakk>foldl1 f2 (map (h2 ?i) ?js) = Two; ?js = ?xs @ ?ys;\n   ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>i xs ys.\n       \\<lbrakk>i < k; js = xs @ ys; xs \\<noteq> []; i = last xs\\<rbrakk>\n       \\<Longrightarrow> i + 1 \\<in> set ys", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "ultimately"], ["proof (chain)\npicking this:\n  js <~~> [0..<k + 1]\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys", "show ?thesis"], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "using js_equals_upt_k"], ["proof (prove)\nusing this:\n  js <~~> [0..<k + 1]\n  \\<lbrakk>?i < k; js = ?xs @ ?ys; ?xs \\<noteq> []; ?i = last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?i + 1 \\<in> set ?ys\n  \\<lbrakk>?js <~~> [0..<?k + 1];\n   \\<And>i xs ys.\n      \\<lbrakk>i < ?k; ?js = xs @ ys; xs \\<noteq> []; i = last xs\\<rbrakk>\n      \\<Longrightarrow> i + 1 \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> ?js = [0..<?k + 1]\n\ngoal (1 subgoal):\n 1. js = [0..<k + 1]", "by auto"], ["proof (state)\nthis:\n  js = [0..<k + 1]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lemma 5\\<close>"], ["", "text \\<open>\nThis lemma is a lifting of Lemma 4 to the overall computation of \n\\<open>scanl1\\<close>. Its proof follows closely the one given in the original paper.\n\\<close>"], ["", "lemma Lemma_5:\n  assumes \"\\<And>(f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f\n             \\<Longrightarrow> map (foldl1 f \\<circ> map h) jss = scanl1 f (map h [0..<n + 1])\"\n      and \"\\<And>js. js \\<in> set jss \\<Longrightarrow> js \\<noteq> []\"\n  shows \"jss = ups n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jss = ups n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jss = ups n", "have P1: \"length jss = length (ups n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "obtain f :: \"three \\<Rightarrow> three \\<Rightarrow> three\" where f_assoc: \"associative f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. associative f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f1_assoc"], ["proof (prove)\nusing this:\n  associative f1\n\ngoal (1 subgoal):\n 1. (\\<And>f. associative f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  associative f\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"length jss = length (map (foldl1 f \\<circ> map h) jss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length jss = length (map (foldl1 f \\<circ> map h) jss)", "by (simp add: L2)"], ["proof (state)\nthis:\n  length jss = length (map (foldl1 f \\<circ> map h) jss)\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length jss = length (map (foldl1 f \\<circ> map h) jss)\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"\\<dots> = length (scanl1 f (map h [0..<n + 1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (foldl1 f \\<circ> map h) jss) =\n    length (scanl1 f (map h [0..<n + 1]))", "using assms and f_assoc"], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) jss = scanl1 ?f (map ?h [0..<n + 1])\n  ?js \\<in> set jss \\<Longrightarrow> ?js \\<noteq> []\n  associative f\n\ngoal (1 subgoal):\n 1. length (map (foldl1 f \\<circ> map h) jss) =\n    length (scanl1 f (map h [0..<n + 1]))", "by simp"], ["proof (state)\nthis:\n  length (map (foldl1 f \\<circ> map h) jss) =\n  length (scanl1 f (map h [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length (map (foldl1 f \\<circ> map h) jss) =\n  length (scanl1 f (map h [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"\\<dots> = length (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n                       [0..<length (map h [0..<n + 1])])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (scanl1 f (map h [0..<n + 1])) =\n    length\n     (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n       [0..<length (map h [0..<n + 1])])", "by simp"], ["proof (state)\nthis:\n  length (scanl1 f (map h [0..<n + 1])) =\n  length\n   (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n     [0..<length (map h [0..<n + 1])])\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length (scanl1 f (map h [0..<n + 1])) =\n  length\n   (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n     [0..<length (map h [0..<n + 1])])\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"\\<dots> = length [0..<length (map h [0..<n + 1])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n       [0..<length (map h [0..<n + 1])]) =\n    length [0..<length (map h [0..<n + 1])]", "by (simp add: L2)"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n     [0..<length (map h [0..<n + 1])]) =\n  length [0..<length (map h [0..<n + 1])]\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>k. foldl1 f (take (k + 1) (map h [0..<n + 1])))\n     [0..<length (map h [0..<n + 1])]) =\n  length [0..<length (map h [0..<n + 1])]\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have\n      \"\\<dots> = length [0..<length [0..<n + 1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<length (map h [0..<n + 1])] =\n    length [0..<length [0..<n + 1]]", "by (simp add: L2)"], ["proof (state)\nthis:\n  length [0..<length (map h [0..<n + 1])] = length [0..<length [0..<n + 1]]\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length [0..<length (map h [0..<n + 1])] = length [0..<length [0..<n + 1]]\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"\\<dots> = length [0..<n + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<length [0..<n + 1]] = length [0..<n + 1]", "by simp"], ["proof (state)\nthis:\n  length [0..<length [0..<n + 1]] = length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length [0..<length [0..<n + 1]] = length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"\\<dots> = length (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<n + 1] = length (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1])", "by (simp add: L2)"], ["proof (state)\nthis:\n  length [0..<n + 1] = length (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "also"], ["proof (state)\nthis:\n  length [0..<n + 1] = length (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "have \n      \"\\<dots> = length (ups n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1]) = length (ups n)", "by simp"], ["proof (state)\nthis:\n  length (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1]) = length (ups n)\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "finally"], ["proof (chain)\npicking this:\n  length jss = length (ups n)", "show ?thesis"], ["proof (prove)\nusing this:\n  length jss = length (ups n)\n\ngoal (1 subgoal):\n 1. length jss = length (ups n)", "."], ["proof (state)\nthis:\n  length jss = length (ups n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length jss = length (ups n)\n\ngoal (1 subgoal):\n 1. jss = ups n", "have P2: \"\\<And>k. k < length jss \\<Longrightarrow> jss ! k = (ups n) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "assume k_length_jss: \"k < length jss\""], ["proof (state)\nthis:\n  k < length jss\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "hence non_empty_jss_k: \"jss ! k \\<noteq> []\""], ["proof (prove)\nusing this:\n  k < length jss\n\ngoal (1 subgoal):\n 1. jss ! k \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  k < length jss\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) jss = scanl1 ?f (map ?h [0..<n + 1])\n  ?js \\<in> set jss \\<Longrightarrow> ?js \\<noteq> []\n\ngoal (1 subgoal):\n 1. jss ! k \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  jss ! k \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "from k_length_jss"], ["proof (chain)\npicking this:\n  k < length jss", "have k_length_length: \"k < length [1..<length [0..<n + 1] + 1]\""], ["proof (prove)\nusing this:\n  k < length jss\n\ngoal (1 subgoal):\n 1. k < length [1..<length [0..<n + 1] + 1]", "using P1"], ["proof (prove)\nusing this:\n  k < length jss\n  length jss = length (ups n)\n\ngoal (1 subgoal):\n 1. k < length [1..<length [0..<n + 1] + 1]", "by simp"], ["proof (state)\nthis:\n  k < length [1..<length [0..<n + 1] + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "hence k_length: \"k < length [0..<n + 1]\""], ["proof (prove)\nusing this:\n  k < length [1..<length [0..<n + 1] + 1]\n\ngoal (1 subgoal):\n 1. k < length [0..<n + 1]", "using List.length_upt [where i=1 and j=\"length [0..<n + 1] + 1\"]"], ["proof (prove)\nusing this:\n  k < length [1..<length [0..<n + 1] + 1]\n  length [1..<length [0..<n + 1] + 1] = length [0..<n + 1] + 1 - 1\n\ngoal (1 subgoal):\n 1. k < length [0..<n + 1]", "by simp"], ["proof (state)\nthis:\n  k < length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "have \"\\<And>(f :: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f\n                  \\<Longrightarrow> foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "fix f h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "assume f_assoc: \"associative (f :: three \\<Rightarrow> three \\<Rightarrow> three)\""], ["proof (state)\nthis:\n  associative f\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"foldl1 f (map h (jss ! k))\n           = (map (foldl1 f \\<circ> map h) jss) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (map h (jss ! k)) = map (foldl1 f \\<circ> map h) jss ! k", "using L6 and k_length_jss"], ["proof (prove)\nusing this:\n  ?k < length ?xs \\<Longrightarrow> map ?f ?xs ! ?k = ?f (?xs ! ?k)\n  k < length jss\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (jss ! k)) = map (foldl1 f \\<circ> map h) jss ! k", "by auto"], ["proof (state)\nthis:\n  foldl1 f (map h (jss ! k)) = map (foldl1 f \\<circ> map h) jss ! k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  foldl1 f (map h (jss ! k)) = map (foldl1 f \\<circ> map h) jss ! k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"\\<dots> = (scanl1 f (map h [0..<n + 1])) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) jss ! k = scanl1 f (map h [0..<n + 1]) ! k", "using assms and f_assoc"], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) jss = scanl1 ?f (map ?h [0..<n + 1])\n  ?js \\<in> set jss \\<Longrightarrow> ?js \\<noteq> []\n  associative f\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) jss ! k = scanl1 f (map h [0..<n + 1]) ! k", "by simp"], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) jss ! k = scanl1 f (map h [0..<n + 1]) ! k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) jss ! k = scanl1 f (map h [0..<n + 1]) ! k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"\\<dots> = (map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n                    [1..<length (map h [0..<n + 1]) + 1]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanl1 f (map h [0..<n + 1]) ! k =\n    map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n     [1..<length (map h [0..<n + 1]) + 1] !\n    k", "by simp"], ["proof (state)\nthis:\n  scanl1 f (map h [0..<n + 1]) ! k =\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length (map h [0..<n + 1]) + 1] !\n  k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  scanl1 f (map h [0..<n + 1]) ! k =\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length (map h [0..<n + 1]) + 1] !\n  k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"\\<dots> = (map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1]))) \n                    [1..<length [0..<n + 1] + 1]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n     [1..<length (map h [0..<n + 1]) + 1] !\n    k =\n    map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n     [1..<length [0..<n + 1] + 1] !\n    k", "by (simp add: L2)"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length (map h [0..<n + 1]) + 1] !\n  k =\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length [0..<n + 1] + 1] !\n  k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length (map h [0..<n + 1]) + 1] !\n  k =\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length [0..<n + 1] + 1] !\n  k\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"\\<dots> = (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n                  ([1..<length [0..<n + 1] + 1] ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n     [1..<length [0..<n + 1] + 1] !\n    k =\n    foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1]))", "using L6 [where xs=\"[1..<length [0..<n + 1] + 1]\"\n              and f=\"(\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\"] \n              and k_length_length"], ["proof (prove)\nusing this:\n  ?k < length [1..<length [0..<n + 1] + 1] \\<Longrightarrow>\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length [0..<n + 1] + 1] !\n  ?k =\n  foldl1 f (take ([1..<length [0..<n + 1] + 1] ! ?k) (map h [0..<n + 1]))\n  k < length [1..<length [0..<n + 1] + 1]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n     [1..<length [0..<n + 1] + 1] !\n    k =\n    foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1]))", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length [0..<n + 1] + 1] !\n  k =\n  foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 f (take k (map h [0..<n + 1])))\n   [1..<length [0..<n + 1] + 1] !\n  k =\n  foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"\\<dots> = foldl1 f (take (k + 1) (map h [0..<n + 1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n    foldl1 f (take (k + 1) (map h [0..<n + 1]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n    foldl1 f (take (k + 1) (map h [0..<n + 1]))", "have \"[1..<length [0..<n + 1] + 1] ! k  = k + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [1..<length [0..<n + 1] + 1] ! k = k + 1", "using List.nth_upt [where i=1 and j=\"length [0..<n + 1] + 1\"]\n                    and k_length"], ["proof (prove)\nusing this:\n  1 + ?k < length [0..<n + 1] + 1 \\<Longrightarrow>\n  [1..<length [0..<n + 1] + 1] ! ?k = 1 + ?k\n  k < length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. [1..<length [0..<n + 1] + 1] ! k = k + 1", "by simp"], ["proof (state)\nthis:\n  [1..<length [0..<n + 1] + 1] ! k = k + 1\n\ngoal (1 subgoal):\n 1. foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n    foldl1 f (take (k + 1) (map h [0..<n + 1]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  [1..<length [0..<n + 1] + 1] ! k = k + 1\n\ngoal (1 subgoal):\n 1. foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n    foldl1 f (take (k + 1) (map h [0..<n + 1]))", "by simp"], ["proof (state)\nthis:\n  foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n  foldl1 f (take (k + 1) (map h [0..<n + 1]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n  foldl1 f (take (k + 1) (map h [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  foldl1 f (take ([1..<length [0..<n + 1] + 1] ! k) (map h [0..<n + 1])) =\n  foldl1 f (take (k + 1) (map h [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \n          \"\\<dots> = foldl1 f (map h (take (k + 1) [0..<n + 1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (take (k + 1) (map h [0..<n + 1])) =\n    foldl1 f (map h (take (k + 1) [0..<n + 1]))", "using L3 [where k=\"k + 1\" and xs=\"[0..<n + 1]\" and f=h]"], ["proof (prove)\nusing this:\n  take (k + 1) (map h [0..<n + 1]) = map h (take (k + 1) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. foldl1 f (take (k + 1) (map h [0..<n + 1])) =\n    foldl1 f (map h (take (k + 1) [0..<n + 1]))", "by simp"], ["proof (state)\nthis:\n  foldl1 f (take (k + 1) (map h [0..<n + 1])) =\n  foldl1 f (map h (take (k + 1) [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "also"], ["proof (state)\nthis:\n  foldl1 f (take (k + 1) (map h [0..<n + 1])) =\n  foldl1 f (map h (take (k + 1) [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "have \"\\<dots> = foldl1 f (map h [0..<k + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 f (map h (take (k + 1) [0..<n + 1])) =\n    foldl1 f (map h [0..<k + 1])", "using List.take_upt [where i=0 and m=\"k + 1\" and n=\"n + 1\"]\n                and k_length"], ["proof (prove)\nusing this:\n  0 + (k + 1) \\<le> n + 1 \\<Longrightarrow>\n  take (k + 1) [0..<n + 1] = [0..<0 + (k + 1)]\n  k < length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (take (k + 1) [0..<n + 1])) =\n    foldl1 f (map h [0..<k + 1])", "by simp"], ["proof (state)\nthis:\n  foldl1 f (map h (take (k + 1) [0..<n + 1])) = foldl1 f (map h [0..<k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "finally"], ["proof (chain)\npicking this:\n  foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "show \n          \"foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])\""], ["proof (prove)\nusing this:\n  foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])\n\ngoal (1 subgoal):\n 1. foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])", "."], ["proof (state)\nthis:\n  foldl1 f (map h (jss ! k)) = foldl1 f (map h [0..<k + 1])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h (jss ! k)) = foldl1 ?f (map ?h [0..<k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "with Lemma_4 and non_empty_jss_k"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?js = [0..<?k + 1]\n  jss ! k \\<noteq> []\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h (jss ! k)) = foldl1 ?f (map ?h [0..<k + 1])", "have P3: \"jss ! k = [0..<k + 1]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              foldl1 f (map h ?js) = foldl1 f (map h [0..<?k + 1]);\n   ?js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?js = [0..<?k + 1]\n  jss ! k \\<noteq> []\n  associative ?f \\<Longrightarrow>\n  foldl1 ?f (map ?h (jss ! k)) = foldl1 ?f (map ?h [0..<k + 1])\n\ngoal (1 subgoal):\n 1. jss ! k = [0..<k + 1]", "by blast"], ["proof (state)\nthis:\n  jss ! k = [0..<k + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "have \n      \"(ups n) ! k \n       = (map (\\<lambda>k. [0..<k + 1]) [0..<n + 1]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ups n ! k = map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k", "by simp"], ["proof (state)\nthis:\n  ups n ! k = map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "also"], ["proof (state)\nthis:\n  ups n ! k = map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "have \n      \"\\<dots> = (\\<lambda>k. [0..<k + 1]) ([0..<n + 1] ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k =\n    [0..<[0..<n + 1] ! k + 1]", "using L6 [where xs=\"[0..<n + 1]\"] and k_length"], ["proof (prove)\nusing this:\n  ?k < length [0..<n + 1] \\<Longrightarrow>\n  map ?f [0..<n + 1] ! ?k = ?f ([0..<n + 1] ! ?k)\n  k < length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k =\n    [0..<[0..<n + 1] ! k + 1]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k = [0..<[0..<n + 1] ! k + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. [0..<k + 1]) [0..<n + 1] ! k = [0..<[0..<n + 1] ! k + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "have \n      \"\\<dots> = [0..<k + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<[0..<n + 1] ! k + 1] = [0..<k + 1]", "using List.nth_upt [where i=0 and j=\"n + 1\"] and k_length"], ["proof (prove)\nusing this:\n  0 + ?k < n + 1 \\<Longrightarrow> [0..<n + 1] ! ?k = 0 + ?k\n  k < length [0..<n + 1]\n\ngoal (1 subgoal):\n 1. [0..<[0..<n + 1] ! k + 1] = [0..<k + 1]", "by simp"], ["proof (state)\nthis:\n  [0..<[0..<n + 1] ! k + 1] = [0..<k + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "finally"], ["proof (chain)\npicking this:\n  ups n ! k = [0..<k + 1]", "have \"(ups n) ! k = [0..<k + 1]\""], ["proof (prove)\nusing this:\n  ups n ! k = [0..<k + 1]\n\ngoal (1 subgoal):\n 1. ups n ! k = [0..<k + 1]", "."], ["proof (state)\nthis:\n  ups n ! k = [0..<k + 1]\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length jss \\<Longrightarrow> jss ! k = ups n ! k", "with P3"], ["proof (chain)\npicking this:\n  jss ! k = [0..<k + 1]\n  ups n ! k = [0..<k + 1]", "show \"jss ! k = (ups n) ! k\""], ["proof (prove)\nusing this:\n  jss ! k = [0..<k + 1]\n  ups n ! k = [0..<k + 1]\n\ngoal (1 subgoal):\n 1. jss ! k = ups n ! k", "by simp"], ["proof (state)\nthis:\n  jss ! k = ups n ! k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k < length jss \\<Longrightarrow> jss ! ?k = ups n ! ?k\n\ngoal (1 subgoal):\n 1. jss = ups n", "from P1 P2 and Lemma_2"], ["proof (chain)\npicking this:\n  length jss = length (ups n)\n  ?k < length jss \\<Longrightarrow> jss ! ?k = ups n ! ?k\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys", "show \"jss = ups n\""], ["proof (prove)\nusing this:\n  length jss = length (ups n)\n  ?k < length jss \\<Longrightarrow> jss ! ?k = ups n ! ?k\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. jss = ups n", "by blast"], ["proof (state)\nthis:\n  jss = ups n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proposition 1\\<close>"], ["", "text \\<open>\nIn the original paper, only non-empty lists where considered, whereas here,\nthe used list datatype allows also for empty lists. Therefore, we need to \nexclude non-empty lists to have a similar setting as in the original paper.\n\nIn the case of Proposition 1, we need to show that every list contained in\nthe result of \\<open>candidate (@) (map wrap [0..<n + 1])\\<close> is non-empty.\nThe idea is to interpret empty lists by the value \\<open>Zero\\<close> and non-empty\nlists by the value \\<open>One\\<close>, and to apply the assumptions.\n\\<close>"], ["", "lemma non_empty_candidate_results:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) (xs :: three list). \n             \\<lbrakk> associative f ; xs \\<noteq> [] \\<rbrakk>  \\<Longrightarrow> candidate f xs = scanl1 f xs\"\n      and \"js \\<in> set (candidate (@) (map wrap [0..<n + 1]))\"\n  shows   \"js \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. js \\<noteq> []", "proof -\n  \\<comment> \\<open>We define a mapping of lists to values of @{text three} as explained\\<close>\n  \\<comment> \\<open>above, and a function which behaves like @{text @} on values of\\<close>\n  \\<comment> \\<open>@{text three}.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. js \\<noteq> []", "let ?h = \"\\<lambda>xs. case xs of [] \\<Rightarrow> Zero | (_#_) \\<Rightarrow> One\""], ["proof (state)\ngoal (1 subgoal):\n 1. js \\<noteq> []", "let ?g = \"\\<lambda>x y. if (x = One \\<or> y = One) then One else Zero\""], ["proof (state)\ngoal (1 subgoal):\n 1. js \\<noteq> []", "have g_assoc: \"associative ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. associative (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)", "unfolding associative_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (if x = One \\<or> (if y = One \\<or> z = One then One else Zero) = One\n        then One else Zero) =\n       (if (if x = One \\<or> y = One then One else Zero) = One \\<or> z = One\n        then One else Zero)", "by auto\n\n  \\<comment> \\<open>Our defined functions fulfill the requirements of the free theorem of\\<close>\n  \\<comment> \\<open>@{text candidate}, that is:\\<close>"], ["proof (state)\nthis:\n  associative (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "have req_free_theorem: \"\\<And>xs ys. ?h (xs @ ys) = ?g (?h xs) (?h ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (case xs @ ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n       (if (case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n           One \\<or>\n           (case ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n           One\n        then One else Zero)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (case xs @ ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n       (if (case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n           One \\<or>\n           (case ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n           One\n        then One else Zero)", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (case xs @ ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n       (if (case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n           One \\<or>\n           (case ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n           One\n        then One else Zero)", "show \"?h (xs @ ys) = ?g (?h xs) (?h ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case xs @ ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n    (if (case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n        One \\<or>\n        (case ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n     then One else Zero)", "by (cases xs, simp_all, cases ys, simp_all)"], ["proof (state)\nthis:\n  (case xs @ ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n  (if (case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n      One \\<or>\n      (case ys of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n   then One else Zero)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Before applying the assumptions, we show that @{text candidate}'s\\<close>\n  \\<comment> \\<open>counterpart @{text scanl1}, applied to a non-empty list, returns only\\<close>\n  \\<comment> \\<open>a repetition of the value @{text One}.\\<close>"], ["proof (state)\nthis:\n  (case ?xs1 @ ?ys1 of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n  (if (case ?xs1 of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n      One \\<or>\n      (case ?ys1 of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n   then One else Zero)\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "have set_scanl1_is_One: \n    \"set (scanl1 ?g (map ?h (map wrap [0..<n + 1]))) = {One}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have const_One: \"map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. map (\\<lambda>x. One) [0..<0 + 1] = replicate (0 + 1) One\n 2. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map (\\<lambda>x. One) [0..<0 + 1] = replicate (0 + 1) One\n 2. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) [0..<0 + 1] = replicate (0 + 1) One", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<0 + 1] = replicate (0 + 1) One\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "case (Suc n)"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "have \n          \"map (\\<lambda>x. One) [0..<Suc n + 1]\n           = map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) [0..<Suc n + 1] =\n    map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n])", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<Suc n + 1] =\n  map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<Suc n + 1] =\n  map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "have \n          \"\\<dots> = map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n]) =\n    map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n]) =\n  map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) ([0..<Suc n] @ [Suc n]) =\n  map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "have \"\\<dots> = replicate (Suc n) One @ replicate 1 One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n] =\n    replicate (Suc n) One @ replicate 1 One", "using Suc"], ["proof (prove)\nusing this:\n  map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n] =\n    replicate (Suc n) One @ replicate 1 One", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n] =\n  replicate (Suc n) One @ replicate 1 One\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<Suc n] @ map (\\<lambda>x. One) [Suc n] =\n  replicate (Suc n) One @ replicate 1 One\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "have \"\\<dots> = replicate (Suc n + 1) One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (Suc n) One @ replicate 1 One = replicate (Suc n + 1) One", "using List.replicate_add \n                      [symmetric, where x=One and n=\"Suc n\" and m=1]"], ["proof (prove)\nusing this:\n  replicate (Suc n) One @ replicate 1 One = replicate (Suc n + 1) One\n\ngoal (1 subgoal):\n 1. replicate (Suc n) One @ replicate 1 One = replicate (Suc n + 1) One", "by simp"], ["proof (state)\nthis:\n  replicate (Suc n) One @ replicate 1 One = replicate (Suc n + 1) One\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       map (\\<lambda>x. One) [0..<n + 1] =\n       replicate (n + 1) One \\<Longrightarrow>\n       map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "show ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One", "."], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<Suc n + 1] = replicate (Suc n + 1) One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have foldl1_One: \"\\<And>xs. foldl1 ?g (One # xs) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (One # xs) =\n       One", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (One # xs) =\n       One", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (One # xs) =\n       One", "show \"foldl1 ?g (One # xs) = One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (One # xs) =\n    One", "proof (induct xs rule: measure_induct [where f=length])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          length y < length x \\<longrightarrow>\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # y) =\n          One \\<Longrightarrow>\n       foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (One # x) =\n       One", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          length y < length x \\<longrightarrow>\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # y) =\n          One \\<Longrightarrow>\n       foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (One # x) =\n       One", "assume \"\\<forall>y. length y < length (x::three list) \n                        \\<longrightarrow> foldl1 ?g (One # y) = One\""], ["proof (state)\nthis:\n  \\<forall>y.\n     length y < length x \\<longrightarrow>\n     foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n      (One # y) =\n     One\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          length y < length x \\<longrightarrow>\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # y) =\n          One \\<Longrightarrow>\n       foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (One # x) =\n       One", "thus \"foldl1 ?g (One # x) = One\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     length y < length x \\<longrightarrow>\n     foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n      (One # y) =\n     One\n\ngoal (1 subgoal):\n 1. foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (One # x) =\n    One", "by (cases x, auto)"], ["proof (state)\nthis:\n  foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (One # x) =\n  One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (One # xs) =\n  One\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (One # ?xs2) =\n  One\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"scanl1 ?g (map ?h (map wrap [0..<n + 1]))\n       = scanl1 ?g (map (?h \\<circ> wrap) [0..<n + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1])) =\n    scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map ((\\<lambda>xs.\n               case xs of [] \\<Rightarrow> Zero\n               | x # xa \\<Rightarrow> One) \\<circ>\n           wrap)\n       [0..<n + 1])", "using L1 [where g=\"?h\" and f=wrap and xs=\"[0..<n + 1]\"]"], ["proof (prove)\nusing this:\n  map (\\<lambda>xs.\n          case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n   (map wrap [0..<n + 1]) =\n  map ((\\<lambda>xs.\n           case xs of [] \\<Rightarrow> Zero\n           | x # xa \\<Rightarrow> One) \\<circ>\n       wrap)\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1])) =\n    scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map ((\\<lambda>xs.\n               case xs of [] \\<Rightarrow> Zero\n               | x # xa \\<Rightarrow> One) \\<circ>\n           wrap)\n       [0..<n + 1])", "by simp"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map ((\\<lambda>xs.\n             case xs of [] \\<Rightarrow> Zero\n             | x # xa \\<Rightarrow> One) \\<circ>\n         wrap)\n     [0..<n + 1])\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map ((\\<lambda>xs.\n             case xs of [] \\<Rightarrow> Zero\n             | x # xa \\<Rightarrow> One) \\<circ>\n         wrap)\n     [0..<n + 1])\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = scanl1 ?g (map (\\<lambda>x. One) [0..<n + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map ((\\<lambda>xs.\n               case xs of [] \\<Rightarrow> Zero\n               | x # xa \\<Rightarrow> One) \\<circ>\n           wrap)\n       [0..<n + 1]) =\n    scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>x. One) [0..<n + 1])", "by (simp add: Fun.o_def)"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map ((\\<lambda>xs.\n             case xs of [] \\<Rightarrow> Zero\n             | x # xa \\<Rightarrow> One) \\<circ>\n         wrap)\n     [0..<n + 1]) =\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>x. One) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map ((\\<lambda>xs.\n             case xs of [] \\<Rightarrow> Zero\n             | x # xa \\<Rightarrow> One) \\<circ>\n         wrap)\n     [0..<n + 1]) =\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>x. One) [0..<n + 1])\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = scanl1 ?g (replicate (n + 1) One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>x. One) [0..<n + 1]) =\n    scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (replicate (n + 1) One)", "using const_One"], ["proof (prove)\nusing this:\n  map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>x. One) [0..<n + 1]) =\n    scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (replicate (n + 1) One)", "by auto"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>x. One) [0..<n + 1]) =\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (replicate (n + 1) One)\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>x. One) [0..<n + 1]) =\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (replicate (n + 1) One)\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = map (\\<lambda>k. foldl1 ?g (take k (replicate (n + 1) One)))\n               [1..<length (replicate (n + 1) One) + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (replicate (n + 1) One) =\n    map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     [1..<length (replicate (n + 1) One) + 1]", "by simp"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (replicate (n + 1) One) =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   [1..<length (replicate (n + 1) One) + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (replicate (n + 1) One) =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   [1..<length (replicate (n + 1) One) + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = map (\\<lambda>k. foldl1 ?g (take k (replicate (n + 1) One)))\n               (map Suc [0..<length (replicate (n + 1) One)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     [1..<length (replicate (n + 1) One) + 1] =\n    map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     (map Suc [0..<length (replicate (n + 1) One)])", "using List.map_Suc_upt"], ["proof (prove)\nusing this:\n  map Suc [?m..<?n] = [Suc ?m..<Suc ?n]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     [1..<length (replicate (n + 1) One) + 1] =\n    map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     (map Suc [0..<length (replicate (n + 1) One)])", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   [1..<length (replicate (n + 1) One) + 1] =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   (map Suc [0..<length (replicate (n + 1) One)])\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   [1..<length (replicate (n + 1) One) + 1] =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   (map Suc [0..<length (replicate (n + 1) One)])\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = map ((\\<lambda>k. foldl1 ?g (take k (replicate (n + 1) One))) \\<circ> Suc)\n               [0..<length (replicate (n + 1) One)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     (map Suc [0..<length (replicate (n + 1) One)]) =\n    map ((\\<lambda>k.\n             foldl1\n              (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n              (take k (replicate (n + 1) One))) \\<circ>\n         Suc)\n     [0..<length (replicate (n + 1) One)]", "using L1"], ["proof (prove)\nusing this:\n  map ?g (map ?f ?xs) = map (?g \\<circ> ?f) ?xs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (take k (replicate (n + 1) One)))\n     (map Suc [0..<length (replicate (n + 1) One)]) =\n    map ((\\<lambda>k.\n             foldl1\n              (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n              (take k (replicate (n + 1) One))) \\<circ>\n         Suc)\n     [0..<length (replicate (n + 1) One)]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   (map Suc [0..<length (replicate (n + 1) One)]) =\n  map ((\\<lambda>k.\n           foldl1\n            (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n            (take k (replicate (n + 1) One))) \\<circ>\n       Suc)\n   [0..<length (replicate (n + 1) One)]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (take k (replicate (n + 1) One)))\n   (map Suc [0..<length (replicate (n + 1) One)]) =\n  map ((\\<lambda>k.\n           foldl1\n            (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n            (take k (replicate (n + 1) One))) \\<circ>\n       Suc)\n   [0..<length (replicate (n + 1) One)]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = map (\\<lambda>k. foldl1 ?g (replicate (min (k + 1) (n + 1)) One))\n               [0..<n + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>k.\n             foldl1\n              (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n              (take k (replicate (n + 1) One))) \\<circ>\n         Suc)\n     [0..<length (replicate (n + 1) One)] =\n    map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (replicate (min (k + 1) (n + 1)) One))\n     [0..<n + 1]", "using Fun.o_def"], ["proof (prove)\nusing this:\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>k.\n             foldl1\n              (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n              (take k (replicate (n + 1) One))) \\<circ>\n         Suc)\n     [0..<length (replicate (n + 1) One)] =\n    map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (replicate (min (k + 1) (n + 1)) One))\n     [0..<n + 1]", "by simp"], ["proof (state)\nthis:\n  map ((\\<lambda>k.\n           foldl1\n            (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n            (take k (replicate (n + 1) One))) \\<circ>\n       Suc)\n   [0..<length (replicate (n + 1) One)] =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (replicate (min (k + 1) (n + 1)) One))\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  map ((\\<lambda>k.\n           foldl1\n            (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n            (take k (replicate (n + 1) One))) \\<circ>\n       Suc)\n   [0..<length (replicate (n + 1) One)] =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (replicate (min (k + 1) (n + 1)) One))\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = map (\\<lambda>k. foldl1 ?g (One # replicate (min k n) One)) \n               [0..<n + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (replicate (min (k + 1) (n + 1)) One))\n     [0..<n + 1] =\n    map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (One # replicate (min k n) One))\n     [0..<n + 1]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (replicate (min (k + 1) (n + 1)) One))\n   [0..<n + 1] =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # replicate (min k n) One))\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (replicate (min (k + 1) (n + 1)) One))\n   [0..<n + 1] =\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # replicate (min k n) One))\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = map (\\<lambda>k. One) [0..<n + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (One # replicate (min k n) One))\n     [0..<n + 1] =\n    map (\\<lambda>k. One) [0..<n + 1]", "using foldl1_One"], ["proof (prove)\nusing this:\n  foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (One # ?xs2) =\n  One\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k.\n            foldl1\n             (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n             (One # replicate (min k n) One))\n     [0..<n + 1] =\n    map (\\<lambda>k. One) [0..<n + 1]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # replicate (min k n) One))\n   [0..<n + 1] =\n  map (\\<lambda>k. One) [0..<n + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k.\n          foldl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n           (One # replicate (min k n) One))\n   [0..<n + 1] =\n  map (\\<lambda>k. One) [0..<n + 1]\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "have \n      \"\\<dots> = replicate (n + 1) One\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. One) [0..<n + 1] = replicate (n + 1) One", "using const_One"], ["proof (prove)\nusing this:\n  map (\\<lambda>x. One) [0..<n + 1] = replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. One) [0..<n + 1] = replicate (n + 1) One", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k. One) [0..<n + 1] = replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "finally"], ["proof (chain)\npicking this:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  replicate (n + 1) One", "show ?thesis"], ["proof (prove)\nusing this:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  replicate (n + 1) One\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "using List.set_replicate [where n=\"n + 1\"]"], ["proof (prove)\nusing this:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  replicate (n + 1) One\n  n + 1 \\<noteq> 0 \\<Longrightarrow> set (replicate (n + 1) ?x) = {?x}\n\ngoal (1 subgoal):\n 1. set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n          (map (\\<lambda>xs.\n                   case xs of [] \\<Rightarrow> Zero\n                   | x # xa \\<Rightarrow> One)\n            (map wrap [0..<n + 1]))) =\n    {One}", "by simp"], ["proof (state)\nthis:\n  set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (map (\\<lambda>xs.\n                 case xs of [] \\<Rightarrow> Zero\n                 | x # xa \\<Rightarrow> One)\n          (map wrap [0..<n + 1]))) =\n  {One}\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Thus, with the assumptions and the free theorem of candidate, we show\\<close>\n  \\<comment> \\<open>that results of @{text candidate}, after applying @{text h}, can only\\<close>\n  \\<comment> \\<open>have the value @{text One}.\\<close>"], ["proof (state)\nthis:\n  set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (map (\\<lambda>xs.\n                 case xs of [] \\<Rightarrow> Zero\n                 | x # xa \\<Rightarrow> One)\n          (map wrap [0..<n + 1]))) =\n  {One}\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "have \n  \"scanl1 ?g (map ?h (map wrap [0..<n + 1])) \n   = candidate ?g (map ?h (map wrap [0..<n + 1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1])) =\n    candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1]))", "using assms and g_assoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f ?xs = scanl1 ?f ?xs\n  js \\<in> set (candidate (@) (map wrap [0..<n + 1]))\n  associative (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n\ngoal (1 subgoal):\n 1. scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1])) =\n    candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1]))", "by auto"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "also"], ["proof (state)\nthis:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "have \n  \"\\<dots> = map ?h (candidate (@) (map wrap [0..<n + 1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1])) =\n    map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (candidate (@) (map wrap [0..<n + 1]))", "using candidate_free_theorem [symmetric, where f=\"(@)\" and g=\"?g\" \n      and h=\"?h\" and zs=\"(map wrap [0..<n + 1])\"] and req_free_theorem"], ["proof (prove)\nusing this:\n  (case ?x @ ?y of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n  (if (case ?x of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n      One \\<or>\n      (case ?y of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n   then One else Zero) \\<Longrightarrow>\n  candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  map (\\<lambda>xs.\n          case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n   (candidate (@) (map wrap [0..<n + 1]))\n  (case ?xs1 @ ?ys1 of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n  (if (case ?xs1 of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) =\n      One \\<or>\n      (case ?ys1 of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n   then One else Zero)\n\ngoal (1 subgoal):\n 1. candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n     (map (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n       (map wrap [0..<n + 1])) =\n    map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (candidate (@) (map wrap [0..<n + 1]))", "by auto"], ["proof (state)\nthis:\n  candidate (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  map (\\<lambda>xs.\n          case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n   (candidate (@) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "finally"], ["proof (chain)\npicking this:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  map (\\<lambda>xs.\n          case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n   (candidate (@) (map wrap [0..<n + 1]))", "have set_is_One: \n  \"\\<And>x. x \\<in> set (map ?h (candidate (@) (map wrap [0..<n + 1])))\n       \\<Longrightarrow> x = One\""], ["proof (prove)\nusing this:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  map (\\<lambda>xs.\n          case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n   (candidate (@) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>xs.\n                            case xs of [] \\<Rightarrow> Zero\n                            | x # xa \\<Rightarrow> One)\n                     (candidate (@)\n                       (map wrap [0..<n + 1]))) \\<Longrightarrow>\n       x = One", "using set_scanl1_is_One"], ["proof (prove)\nusing this:\n  scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n   (map (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n     (map wrap [0..<n + 1])) =\n  map (\\<lambda>xs.\n          case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n   (candidate (@) (map wrap [0..<n + 1]))\n  set (scanl1 (\\<lambda>x y. if x = One \\<or> y = One then One else Zero)\n        (map (\\<lambda>xs.\n                 case xs of [] \\<Rightarrow> Zero\n                 | x # xa \\<Rightarrow> One)\n          (map wrap [0..<n + 1]))) =\n  {One}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>xs.\n                            case xs of [] \\<Rightarrow> Zero\n                            | x # xa \\<Rightarrow> One)\n                     (candidate (@)\n                       (map wrap [0..<n + 1]))) \\<Longrightarrow>\n       x = One", "by auto\n\n  \\<comment> \\<open>Now, it is easy to conclude the thesis.\\<close>"], ["proof (state)\nthis:\n  ?x2\n  \\<in> set (map (\\<lambda>xs.\n                     case xs of [] \\<Rightarrow> Zero\n                     | x # xa \\<Rightarrow> One)\n              (candidate (@) (map wrap [0..<n + 1]))) \\<Longrightarrow>\n  ?x2 = One\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f ?xs = scanl1 ?f ?xs\n  js \\<in> set (candidate (@) (map wrap [0..<n + 1]))", "have \"?h js \\<in> ?h ` set (candidate (@) (map wrap [0..<n + 1]))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f ?xs = scanl1 ?f ?xs\n  js \\<in> set (candidate (@) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n    \\<in> (\\<lambda>xs.\n              case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) `\n          set (candidate (@) (map wrap [0..<n + 1]))", "by auto"], ["proof (state)\nthis:\n  (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n  \\<in> (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) `\n        set (candidate (@) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "with set_is_One"], ["proof (chain)\npicking this:\n  ?x2\n  \\<in> set (map (\\<lambda>xs.\n                     case xs of [] \\<Rightarrow> Zero\n                     | x # xa \\<Rightarrow> One)\n              (candidate (@) (map wrap [0..<n + 1]))) \\<Longrightarrow>\n  ?x2 = One\n  (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n  \\<in> (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) `\n        set (candidate (@) (map wrap [0..<n + 1]))", "have \"?h js = One\""], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> set (map (\\<lambda>xs.\n                     case xs of [] \\<Rightarrow> Zero\n                     | x # xa \\<Rightarrow> One)\n              (candidate (@) (map wrap [0..<n + 1]))) \\<Longrightarrow>\n  ?x2 = One\n  (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One)\n  \\<in> (\\<lambda>xs.\n            case xs of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) `\n        set (candidate (@) (map wrap [0..<n + 1]))\n\ngoal (1 subgoal):\n 1. (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One", "by simp"], ["proof (state)\nthis:\n  (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "thus \"js \\<noteq> []\""], ["proof (prove)\nusing this:\n  (case js of [] \\<Rightarrow> Zero | x # xa \\<Rightarrow> One) = One\n\ngoal (1 subgoal):\n 1. js \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  js \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nProposition 1 is very similar to the corresponding one shown in the original\npaper except of a slight modification due to the choice of using Isabelle's\nlist datatype.\n\nStrictly speaking, the requirement that \\<open>xs\\<close> must be non-empty in the\nassumptions of Proposition 1 is not necessary, because only non-empty lists\nare applied in the proof. However, the additional requirement eases the proof\nobligations of the final theorem, i.e. this additions allows more (or easier)\napplications of the final theorem.\n\\<close>"], ["", "lemma Proposition_1:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) (xs :: three list). \n             \\<lbrakk> associative f ; xs \\<noteq> [] \\<rbrakk>  \\<Longrightarrow> candidate f xs = scanl1 f xs\"\n  shows \"candidate (@) (map wrap [0..<n + 1]) = ups n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate (@) (map wrap [0..<n + 1]) = ups n", "proof -\n  \\<comment> \\<open>This addition is necessary because we are using Isabelle's list datatype\\<close>\n  \\<comment> \\<open>which allows for empty lists.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. candidate (@) (map wrap [0..<n + 1]) = ups n", "from assms and non_empty_candidate_results"], ["proof (chain)\npicking this:\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f ?xs = scanl1 ?f ?xs\n  \\<lbrakk>\\<And>f xs.\n              \\<lbrakk>associative f; xs \\<noteq> []\\<rbrakk>\n              \\<Longrightarrow> candidate f xs = scanl1 f xs;\n   ?js \\<in> set (candidate (@) (map wrap [0..<?n + 1]))\\<rbrakk>\n  \\<Longrightarrow> ?js \\<noteq> []", "have non_empty_candidate: \n  \"\\<And>js. js \\<in> set (candidate (@) (map wrap [0..<n + 1])) \\<Longrightarrow> js \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f ?xs = scanl1 ?f ?xs\n  \\<lbrakk>\\<And>f xs.\n              \\<lbrakk>associative f; xs \\<noteq> []\\<rbrakk>\n              \\<Longrightarrow> candidate f xs = scanl1 f xs;\n   ?js \\<in> set (candidate (@) (map wrap [0..<?n + 1]))\\<rbrakk>\n  \\<Longrightarrow> ?js \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>js.\n       js \\<in> set (candidate (@) (map wrap [0..<n + 1])) \\<Longrightarrow>\n       js \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ?js \\<in> set (candidate (@) (map wrap [0..<n + 1])) \\<Longrightarrow>\n  ?js \\<noteq> []\n\ngoal (1 subgoal):\n 1. candidate (@) (map wrap [0..<n + 1]) = ups n", "have \"\\<And>(f:: three \\<Rightarrow> three \\<Rightarrow> three) h. associative f\n        \\<Longrightarrow> map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) \n           = scanl1 f (map h [0..<n + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "fix f h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "assume f_assoc: \"associative (f :: three \\<Rightarrow> three \\<Rightarrow> three)\""], ["proof (state)\nthis:\n  associative f\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "hence \n      \"map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) \n       = candidate f (map h [0..<n + 1])\""], ["proof (prove)\nusing this:\n  associative f\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "using Lemma_3"], ["proof (prove)\nusing this:\n  associative f\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) (candidate (@) (map wrap [0..<?n + 1])) =\n  candidate ?f (map ?h [0..<?n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    candidate f (map h [0..<n + 1])", "by auto"], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "also"], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  candidate f (map h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "have \n      \"\\<dots> = scanl1 f (map h [0..<n + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate f (map h [0..<n + 1]) = scanl1 f (map h [0..<n + 1])", "using assms [where xs=\"map h [0..<n + 1]\"] and f_assoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>associative ?f; map h [0..<n + 1] \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f (map h [0..<n + 1]) =\n                    scanl1 ?f (map h [0..<n + 1])\n  associative f\n\ngoal (1 subgoal):\n 1. candidate f (map h [0..<n + 1]) = scanl1 f (map h [0..<n + 1])", "by simp"], ["proof (state)\nthis:\n  candidate f (map h [0..<n + 1]) = scanl1 f (map h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. \\<And>f h.\n       associative f \\<Longrightarrow>\n       map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n       scanl1 f (map h [0..<n + 1])", "finally"], ["proof (chain)\npicking this:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  scanl1 f (map h [0..<n + 1])", "show \n      \"map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1]))\n       = scanl1 f (map h [0..<n + 1])\""], ["proof (prove)\nusing this:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  scanl1 f (map h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n    scanl1 f (map h [0..<n + 1])", "."], ["proof (state)\nthis:\n  map (foldl1 f \\<circ> map h) (candidate (@) (map wrap [0..<n + 1])) =\n  scanl1 f (map h [0..<n + 1])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) (candidate (@) (map wrap [0..<n + 1])) =\n  scanl1 ?f (map ?h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. candidate (@) (map wrap [0..<n + 1]) = ups n", "with Lemma_5 and non_empty_candidate"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              map (foldl1 f \\<circ> map h) ?jss =\n              scanl1 f (map h [0..<?n + 1]);\n   \\<And>js. js \\<in> set ?jss \\<Longrightarrow> js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?jss = ups ?n\n  ?js \\<in> set (candidate (@) (map wrap [0..<n + 1])) \\<Longrightarrow>\n  ?js \\<noteq> []\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) (candidate (@) (map wrap [0..<n + 1])) =\n  scanl1 ?f (map ?h [0..<n + 1])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>f h.\n              associative f \\<Longrightarrow>\n              map (foldl1 f \\<circ> map h) ?jss =\n              scanl1 f (map h [0..<?n + 1]);\n   \\<And>js. js \\<in> set ?jss \\<Longrightarrow> js \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?jss = ups ?n\n  ?js \\<in> set (candidate (@) (map wrap [0..<n + 1])) \\<Longrightarrow>\n  ?js \\<noteq> []\n  associative ?f \\<Longrightarrow>\n  map (foldl1 ?f \\<circ> map ?h) (candidate (@) (map wrap [0..<n + 1])) =\n  scanl1 ?f (map ?h [0..<n + 1])\n\ngoal (1 subgoal):\n 1. candidate (@) (map wrap [0..<n + 1]) = ups n", "by auto"], ["proof (state)\nthis:\n  candidate (@) (map wrap [0..<n + 1]) = ups n\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Proving Proposition 2\\<close>"], ["", "text \\<open>\nBefore proving Proposition 2, a non-trivial step of that proof is shown first.\nIn the original paper, the argumentation simply applies L7 and the definition\nof \\<open>map\\<close> and \\<open>[0..<k + 1]\\<close>. However, since, L7 requires that\n\\<open>k\\<close> must be less than \\<open>length [0..<length xs]\\<close> and this does\nnot simply follow for the bound occurrence of \\<open>k\\<close>, a more complicated\nproof is necessary. Here, it is shown based on Lemma 2.\n\\<close>"], ["", "lemma Prop_2_step_L7:\n  \"map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs]\n   = map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "have P1: \n  \"length (map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs])\n   = length (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n       [0..<length xs]) =\n    length (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs])", "by (simp add: L2)"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]) =\n  length (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs])\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "have P2: \n  \"\\<And>k. k < length (map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) \n                       [0..<length xs]) \n       \\<Longrightarrow> (map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs]) ! k\n          = (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "assume k_length: \n        \"k < length (map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1]))\n                         [0..<length xs])\""], ["proof (state)\nthis:\n  k < length\n       (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n         [0..<length xs])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "hence k_length': \"k < length xs\""], ["proof (prove)\nusing this:\n  k < length\n       (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n         [0..<length xs])\n\ngoal (1 subgoal):\n 1. k < length xs", "by (simp add: L2)"], ["proof (state)\nthis:\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "have \n      \"(map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs]) ! k \n       = (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) ([0..<length xs] ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n    k =\n    foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1])", "using L6 and k_length"], ["proof (prove)\nusing this:\n  ?k < length ?xs \\<Longrightarrow> map ?f ?xs ! ?k = ?f (?xs ! ?k)\n  k < length\n       (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n         [0..<length xs])\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n    k =\n    foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1])", "by (simp add: L2)"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  k =\n  foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  k =\n  foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "have \n      \"\\<dots> = foldl1 g (map (nth xs) [0..<k + 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1]) =\n    foldl1 g (map ((!) xs) [0..<k + 1])", "using k_length'"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1]) =\n    foldl1 g (map ((!) xs) [0..<k + 1])", "by (auto simp: L2)"], ["proof (state)\nthis:\n  foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1]) =\n  foldl1 g (map ((!) xs) [0..<k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "also"], ["proof (state)\nthis:\n  foldl1 g (map ((!) xs) [0..<[0..<length xs] ! k + 1]) =\n  foldl1 g (map ((!) xs) [0..<k + 1])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "have \n      \"\\<dots> = foldl1 g (take (k + 1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 g (map ((!) xs) [0..<k + 1]) = foldl1 g (take (k + 1) xs)", "using L7 [where k=k and xs=xs] and k_length'"], ["proof (prove)\nusing this:\n  k < length xs \\<Longrightarrow> map ((!) xs) [0..<k + 1] = take (k + 1) xs\n  k < length xs\n\ngoal (1 subgoal):\n 1. foldl1 g (map ((!) xs) [0..<k + 1]) = foldl1 g (take (k + 1) xs)", "by simp"], ["proof (state)\nthis:\n  foldl1 g (map ((!) xs) [0..<k + 1]) = foldl1 g (take (k + 1) xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "also"], ["proof (state)\nthis:\n  foldl1 g (map ((!) xs) [0..<k + 1]) = foldl1 g (take (k + 1) xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "have \n      \"\\<dots> = (\\<lambda>k. foldl1 g (take (k + 1) xs)) ([0..<length xs] ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 g (take (k + 1) xs) =\n    foldl1 g (take ([0..<length xs] ! k + 1) xs)", "using k_length'"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. foldl1 g (take (k + 1) xs) =\n    foldl1 g (take ([0..<length xs] ! k + 1) xs)", "by (auto simp: L2)"], ["proof (state)\nthis:\n  foldl1 g (take (k + 1) xs) = foldl1 g (take ([0..<length xs] ! k + 1) xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "also"], ["proof (state)\nthis:\n  foldl1 g (take (k + 1) xs) = foldl1 g (take ([0..<length xs] ! k + 1) xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "have \n      \"\\<dots> = (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1 g (take ([0..<length xs] ! k + 1) xs) =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "using L6 [symmetric] and k_length"], ["proof (prove)\nusing this:\n  ?k < length ?xs \\<Longrightarrow> ?f (?xs ! ?k) = map ?f ?xs ! ?k\n  k < length\n       (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n         [0..<length xs])\n\ngoal (1 subgoal):\n 1. foldl1 g (take ([0..<length xs] ! k + 1) xs) =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "by (simp add: L2)"], ["proof (state)\nthis:\n  foldl1 g (take ([0..<length xs] ! k + 1) xs) =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length\n            (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n              [0..<length xs]) \\<Longrightarrow>\n       map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n        [0..<length xs] !\n       k =\n       map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  k =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "show\n      \"(map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs]) ! k \n       = (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]) ! k\""], ["proof (prove)\nusing this:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  k =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n    k =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k", "."], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  k =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k < length\n        (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n          [0..<length xs]) \\<Longrightarrow>\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  ?k =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! ?k\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "from P1 P2 and Lemma_2"], ["proof (chain)\npicking this:\n  length\n   (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]) =\n  length (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs])\n  ?k < length\n        (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n          [0..<length xs]) \\<Longrightarrow>\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  ?k =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! ?k\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]) =\n  length (map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs])\n  ?k < length\n        (map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1]))\n          [0..<length xs]) \\<Longrightarrow>\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] !\n  ?k =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] ! ?k\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "by blast"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nCompared to the original paper, here, Proposition 2 has the additional \nassumption that \\<open>xs\\<close> is non-empty. The proof, however, is identical\nto the the one given in the original paper, except for the non-trivial step\nshown before.\n\\<close>"], ["", "lemma Proposition_2:\n  assumes A1: \"\\<And> n. candidate (@) (map wrap [0..<n + 1]) = ups n\"\n      and A2: \"associative g\"\n      and A3: \"xs \\<noteq> []\"\n  shows \"candidate g xs = scanl1 g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "proof -\n  \\<comment> \\<open>First, based on Lemma 2, we show that\\<close>\n  \\<comment> \\<open>@{term \"xs = map (nth xs) [0..<length xs]\"}\\<close>\n  \\<comment> \\<open>by the following facts P1 and P2.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have P1: \"length xs = length (map (nth xs) [0..<length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length (map ((!) xs) [0..<length xs])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs = length (map ((!) xs) [0..<length xs])", "have \n      \"length xs \n       = length [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length [0..<length xs]", "by simp"], ["proof (state)\nthis:\n  length xs = length [0..<length xs]\n\ngoal (1 subgoal):\n 1. length xs = length (map ((!) xs) [0..<length xs])", "also"], ["proof (state)\nthis:\n  length xs = length [0..<length xs]\n\ngoal (1 subgoal):\n 1. length xs = length (map ((!) xs) [0..<length xs])", "have \n      \"\\<dots> = length (map (nth xs) [0..<length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<length xs] = length (map ((!) xs) [0..<length xs])", "using L2 [symmetric]"], ["proof (prove)\nusing this:\n  length ?xs = length (map ?f ?xs)\n\ngoal (1 subgoal):\n 1. length [0..<length xs] = length (map ((!) xs) [0..<length xs])", "by auto"], ["proof (state)\nthis:\n  length [0..<length xs] = length (map ((!) xs) [0..<length xs])\n\ngoal (1 subgoal):\n 1. length xs = length (map ((!) xs) [0..<length xs])", "finally"], ["proof (chain)\npicking this:\n  length xs = length (map ((!) xs) [0..<length xs])", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs = length (map ((!) xs) [0..<length xs])\n\ngoal (1 subgoal):\n 1. length xs = length (map ((!) xs) [0..<length xs])", "."], ["proof (state)\nthis:\n  length xs = length (map ((!) xs) [0..<length xs])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xs = length (map ((!) xs) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have P2: \"\\<And>k. k < length xs \\<Longrightarrow> xs ! k = (map (nth xs) [0..<length xs]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "assume k_length_xs: \"k < length xs\""], ["proof (state)\nthis:\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "hence k_length_xs': \"k < length [0..<length xs]\""], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. k < length [0..<length xs]", "by simp"], ["proof (state)\nthis:\n  k < length [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "have \n      \"xs ! k = nth xs ([0..<length xs] ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! k = xs ! ([0..<length xs] ! k)", "using k_length_xs"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. xs ! k = xs ! ([0..<length xs] ! k)", "by simp"], ["proof (state)\nthis:\n  xs ! k = xs ! ([0..<length xs] ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "also"], ["proof (state)\nthis:\n  xs ! k = xs ! ([0..<length xs] ! k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "have \n      \"\\<dots> = (map (nth xs) [0..<length xs]) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! ([0..<length xs] ! k) = map ((!) xs) [0..<length xs] ! k", "using L6 [symmetric] and k_length_xs'"], ["proof (prove)\nusing this:\n  ?k < length ?xs \\<Longrightarrow> ?f (?xs ! ?k) = map ?f ?xs ! ?k\n  k < length [0..<length xs]\n\ngoal (1 subgoal):\n 1. xs ! ([0..<length xs] ! k) = map ((!) xs) [0..<length xs] ! k", "by auto"], ["proof (state)\nthis:\n  xs ! ([0..<length xs] ! k) = map ((!) xs) [0..<length xs] ! k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length xs \\<Longrightarrow>\n       xs ! k = map ((!) xs) [0..<length xs] ! k", "finally"], ["proof (chain)\npicking this:\n  xs ! k = map ((!) xs) [0..<length xs] ! k", "show \"xs ! k = (map (nth xs) [0..<length xs]) ! k\""], ["proof (prove)\nusing this:\n  xs ! k = map ((!) xs) [0..<length xs] ! k\n\ngoal (1 subgoal):\n 1. xs ! k = map ((!) xs) [0..<length xs] ! k", "."], ["proof (state)\nthis:\n  xs ! k = map ((!) xs) [0..<length xs] ! k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k < length xs \\<Longrightarrow>\n  xs ! ?k = map ((!) xs) [0..<length xs] ! ?k\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "from P1 P2 and Lemma_2"], ["proof (chain)\npicking this:\n  length xs = length (map ((!) xs) [0..<length xs])\n  ?k < length xs \\<Longrightarrow>\n  xs ! ?k = map ((!) xs) [0..<length xs] ! ?k\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys", "have \"xs = map (nth xs) [0..<length xs]\""], ["proof (prove)\nusing this:\n  length xs = length (map ((!) xs) [0..<length xs])\n  ?k < length xs \\<Longrightarrow>\n  xs ! ?k = map ((!) xs) [0..<length xs] ! ?k\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>k. k < length ?xs \\<Longrightarrow> ?xs ! k = ?ys ! k\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. xs = map ((!) xs) [0..<length xs]", "by blast\n  \n  \\<comment> \\<open>Thus, with some rewriting, we show the thesis.\\<close>"], ["proof (state)\nthis:\n  xs = map ((!) xs) [0..<length xs]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "hence \n  \"candidate g xs \n   = candidate g (map (nth xs) [0..<length xs])\""], ["proof (prove)\nusing this:\n  xs = map ((!) xs) [0..<length xs]\n\ngoal (1 subgoal):\n 1. candidate g xs = candidate g (map ((!) xs) [0..<length xs])", "by simp"], ["proof (state)\nthis:\n  candidate g xs = candidate g (map ((!) xs) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  candidate g xs = candidate g (map ((!) xs) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have \n  \"\\<dots> = map (foldl1 g \\<circ> map (nth xs))\n           (candidate (@) (map wrap [0..<length xs]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g (map ((!) xs) [0..<length xs]) =\n    map (foldl1 g \\<circ> map ((!) xs))\n     (candidate (@) (map wrap [0..<length xs]))", "using Lemma_3 [symmetric, where h=\"nth xs\" and n=\"length xs - 1\"] \n      and A2 and A3"], ["proof (prove)\nusing this:\n  associative ?f \\<Longrightarrow>\n  candidate ?f (map ((!) xs) [0..<length xs - 1 + 1]) =\n  map (foldl1 ?f \\<circ> map ((!) xs))\n   (candidate (@) (map wrap [0..<length xs - 1 + 1]))\n  associative g\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. candidate g (map ((!) xs) [0..<length xs]) =\n    map (foldl1 g \\<circ> map ((!) xs))\n     (candidate (@) (map wrap [0..<length xs]))", "by auto"], ["proof (state)\nthis:\n  candidate g (map ((!) xs) [0..<length xs]) =\n  map (foldl1 g \\<circ> map ((!) xs))\n   (candidate (@) (map wrap [0..<length xs]))\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  candidate g (map ((!) xs) [0..<length xs]) =\n  map (foldl1 g \\<circ> map ((!) xs))\n   (candidate (@) (map wrap [0..<length xs]))\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have \n  \"\\<dots> = map (foldl1 g \\<circ> map (nth xs)) (ups (length xs - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (foldl1 g \\<circ> map ((!) xs))\n     (candidate (@) (map wrap [0..<length xs])) =\n    map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1))", "using A1 [where n=\"length xs - 1\"] and A3"], ["proof (prove)\nusing this:\n  candidate (@) (map wrap [0..<length xs - 1 + 1]) = ups (length xs - 1)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (foldl1 g \\<circ> map ((!) xs))\n     (candidate (@) (map wrap [0..<length xs])) =\n    map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1))", "by simp"], ["proof (state)\nthis:\n  map (foldl1 g \\<circ> map ((!) xs))\n   (candidate (@) (map wrap [0..<length xs])) =\n  map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1))\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  map (foldl1 g \\<circ> map ((!) xs))\n   (candidate (@) (map wrap [0..<length xs])) =\n  map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1))\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have \n  \"\\<dots> = map (foldl1 g \\<circ> map (nth xs)) (map (\\<lambda>k. [0..<k + 1]) [0..<length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1)) =\n    map (foldl1 g \\<circ> map ((!) xs))\n     (map (\\<lambda>k. [0..<k + 1]) [0..<length xs])", "using A3"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1)) =\n    map (foldl1 g \\<circ> map ((!) xs))\n     (map (\\<lambda>k. [0..<k + 1]) [0..<length xs])", "by simp"], ["proof (state)\nthis:\n  map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1)) =\n  map (foldl1 g \\<circ> map ((!) xs))\n   (map (\\<lambda>k. [0..<k + 1]) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  map (foldl1 g \\<circ> map ((!) xs)) (ups (length xs - 1)) =\n  map (foldl1 g \\<circ> map ((!) xs))\n   (map (\\<lambda>k. [0..<k + 1]) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have \n  \"\\<dots> = map (\\<lambda>k. foldl1 g (map (nth xs) [0..<k + 1])) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (foldl1 g \\<circ> map ((!) xs))\n     (map (\\<lambda>k. [0..<k + 1]) [0..<length xs]) =\n    map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]", "using L1 [where g=\"foldl1 g \\<circ> map (nth xs)\" and f=\"(\\<lambda>k. [0..<k + 1])\"]"], ["proof (prove)\nusing this:\n  map (foldl1 g \\<circ> map ((!) xs)) (map (\\<lambda>k. [0..<k + 1]) ?xs) =\n  map (foldl1 g \\<circ> map ((!) xs) \\<circ> (\\<lambda>k. [0..<k + 1])) ?xs\n\ngoal (1 subgoal):\n 1. map (foldl1 g \\<circ> map ((!) xs))\n     (map (\\<lambda>k. [0..<k + 1]) [0..<length xs]) =\n    map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]", "by (simp add: Fun.o_def)"], ["proof (state)\nthis:\n  map (foldl1 g \\<circ> map ((!) xs))\n   (map (\\<lambda>k. [0..<k + 1]) [0..<length xs]) =\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  map (foldl1 g \\<circ> map ((!) xs))\n   (map (\\<lambda>k. [0..<k + 1]) [0..<length xs]) =\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have \n  \"\\<dots> = map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "using Prop_2_step_L7"], ["proof (prove)\nusing this:\n  map (\\<lambda>k. foldl1 ?g (map ((!) ?xs) [0..<k + 1])) [0..<length ?xs] =\n  map (\\<lambda>k. foldl1 ?g (take (k + 1) ?xs)) [0..<length ?xs]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (map ((!) xs) [0..<k + 1])) [0..<length xs] =\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have\n  \"\\<dots> = map (\\<lambda>k. foldl1 g (take k xs)) (map (\\<lambda>k. k + 1) [0..<length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] =\n    map (\\<lambda>k. foldl1 g (take k xs))\n     (map (\\<lambda>k. k + 1) [0..<length xs])", "by (simp add: L1)"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] =\n  map (\\<lambda>k. foldl1 g (take k xs))\n   (map (\\<lambda>k. k + 1) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (take (k + 1) xs)) [0..<length xs] =\n  map (\\<lambda>k. foldl1 g (take k xs))\n   (map (\\<lambda>k. k + 1) [0..<length xs])\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have\n  \"\\<dots> = map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (take k xs))\n     (map (\\<lambda>k. k + 1) [0..<length xs]) =\n    map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1]", "using List.map_Suc_upt"], ["proof (prove)\nusing this:\n  map Suc [?m..<?n] = [Suc ?m..<Suc ?n]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (take k xs))\n     (map (\\<lambda>k. k + 1) [0..<length xs]) =\n    map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (take k xs))\n   (map (\\<lambda>k. k + 1) [0..<length xs]) =\n  map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "also"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (take k xs))\n   (map (\\<lambda>k. k + 1) [0..<length xs]) =\n  map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1]\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "have \n  \"\\<dots> = scanl1 g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1] = scanl1 g xs", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>k. foldl1 g (take k xs)) [1..<length xs + 1] = scanl1 g xs\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "finally"], ["proof (chain)\npicking this:\n  candidate g xs = scanl1 g xs", "show ?thesis"], ["proof (prove)\nusing this:\n  candidate g xs = scanl1 g xs\n\ngoal (1 subgoal):\n 1. candidate g xs = scanl1 g xs", "."], ["proof (state)\nthis:\n  candidate g xs = scanl1 g xs\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The Final Result\\<close>"], ["", "text \\<open>\nFinally, we the main result follows directly from Proposition 1 and \nProposition 2.\n\\<close>"], ["", "theorem The_0_1_2_Principle:\n  assumes \"\\<And> (f :: three \\<Rightarrow> three \\<Rightarrow> three) (xs :: three list). \n             \\<lbrakk> associative f ; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow> candidate f xs = scanl1 f xs\"\n      and \"associative g\"\n      and \"ys \\<noteq> []\"\n  shows \"candidate g ys = scanl1 g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate g ys = scanl1 g ys", "using Proposition_1 Proposition_2 and assms"], ["proof (prove)\nusing this:\n  (\\<And>f xs.\n      \\<lbrakk>associative f; xs \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> candidate f xs = scanl1 f xs) \\<Longrightarrow>\n  candidate (@) (map wrap [0..<?n + 1]) = ups ?n\n  \\<lbrakk>\\<And>n. candidate (@) (map wrap [0..<n + 1]) = ups n;\n   associative ?g; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?g ?xs = scanl1 ?g ?xs\n  \\<lbrakk>associative ?f; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> candidate ?f ?xs = scanl1 ?f ?xs\n  associative g\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. candidate g ys = scanl1 g ys", "by blast"], ["", "text \\<open>\n\\section*{Acknowledgments}\n\nI thank Janis Voigtl\\\"ander for sharing a draft of his paper before its\npublication with me.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}