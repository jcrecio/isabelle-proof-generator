{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Big_Step_Determ.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma evaluate_determ:\n  \"evaluate_match ck env s v pes v' r1a \\<Longrightarrow> evaluate_match ck env s v pes v' r1b \\<Longrightarrow> r1a = r1b\"\n  \"evaluate_list ck env s es r2a \\<Longrightarrow> evaluate_list ck env s es r2b \\<Longrightarrow> r2a = r2b\"\n  \"evaluate ck env s e r3a \\<Longrightarrow> evaluate ck env s e r3b \\<Longrightarrow> r3a = r3b\""], "translations": [["", "lemma evaluate_determ:\n  \"evaluate_match ck env s v pes v' r1a \\<Longrightarrow> evaluate_match ck env s v pes v' r1b \\<Longrightarrow> r1a = r1b\"\n  \"evaluate_list ck env s es r2a \\<Longrightarrow> evaluate_list ck env s es r2b \\<Longrightarrow> r2a = r2b\"\n  \"evaluate ck env s e r3a \\<Longrightarrow> evaluate ck env s e r3b \\<Longrightarrow> r3a = r3b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>evaluate_match ck env s v pes v' r1a;\n      evaluate_match ck env s v pes v' r1b\\<rbrakk>\n     \\<Longrightarrow> r1a = r1b) &&&\n    (\\<lbrakk>evaluate_list ck env s es r2a;\n      evaluate_list ck env s es r2b\\<rbrakk>\n     \\<Longrightarrow> r2a = r2b) &&&\n    (\\<lbrakk>evaluate ck env s e r3a; evaluate ck env s e r3b\\<rbrakk>\n     \\<Longrightarrow> r3a = r3b)", "proof (induction arbitrary: r1b and r2b and r3b rule: evaluate_match_evaluate_list_evaluate.inducts)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env e s1 s2 v1 r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rraise v1)) = r3b\n 3. \\<And>ck env e s1 s2 err r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rerr err) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 4. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 5. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 7. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 8. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env n v1 s r3b.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n         evaluate ck env s (Var n) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rval v1) = r3b\nA total of 42 subgoals...", "case (raise1 ck s1 e env s2 v1)"], ["proof (state)\nthis:\n  evaluate ck env s1 e (s2, Rval v1)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rval v1) = ?r3b\n  evaluate ck env s1 (Raise e) r3b\n\ngoal (42 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env e s1 s2 v1 r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rraise v1)) = r3b\n 3. \\<And>ck env e s1 s2 err r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rerr err) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 4. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 5. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 7. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 8. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env n v1 s r3b.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n         evaluate ck env s (Var n) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rval v1) = r3b\nA total of 42 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s1 e (s2, Rval v1)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rval v1) = ?r3b\n  evaluate ck env s1 (Raise e) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s1 e (s2, Rval v1)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rval v1) = ?r3b\n  evaluate ck env s1 (Raise e) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rraise v1)) = r3b", "by - (ind_cases \"evaluate ck env s1 (Raise e) r3b\", auto)"], ["proof (state)\nthis:\n  (s2, Rerr (Rraise v1)) = r3b\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env e s1 s2 err r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rerr err) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 3. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 4. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 5. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 6. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 7. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 10. \\<And>ck env n s r3b.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None;\n         evaluate ck env s (Var n) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env e s1 s2 err r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rerr err) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 3. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 4. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 5. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 6. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 7. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 10. \\<And>ck env n s r3b.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None;\n         evaluate ck env s (Var n) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\nA total of 41 subgoals...", "case (raise2 ck s1 e env s2 err)"], ["proof (state)\nthis:\n  evaluate ck env s1 e (s2, Rerr err)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rerr err) = ?r3b\n  evaluate ck env s1 (Raise e) r3b\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env e s1 s2 err r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rerr err) = r3b;\n        evaluate ck s1 env (Raise e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 3. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 4. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 5. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 6. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 7. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 10. \\<And>ck env n s r3b.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None;\n         evaluate ck env s (Var n) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\nA total of 41 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s1 e (s2, Rerr err)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rerr err) = ?r3b\n  evaluate ck env s1 (Raise e) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s1 e (s2, Rerr err)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rerr err) = ?r3b\n  evaluate ck env s1 (Raise e) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s1 (Raise e) r3b\", auto)"], ["proof (state)\nthis:\n  (s2, Rerr err) = r3b\n\ngoal (40 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 3. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 4. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 5. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 6. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 9. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env n e s r3b.\n        evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n        (s, Rval (Closure env n e)) = r3b\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 3. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 4. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 5. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 6. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 9. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env n e s r3b.\n        evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n        (s, Rval (Closure env n e)) = r3b\nA total of 40 subgoals...", "case (handle1 ck env s2 s1 e v1 pes)"], ["proof (state)\nthis:\n  evaluate ck env s1 e (s2, Rval v1)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rval v1) = ?r3b\n  evaluate ck env s1 (Handle e pes) r3b\n\ngoal (40 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e v1 pes r3b.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>r3b.\n           evaluate ck s1 env e r3b \\<Longrightarrow> (s2, Rval v1) = r3b;\n        evaluate ck s1 env (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval v1) = r3b\n 3. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 4. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 5. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 6. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 9. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env n e s r3b.\n        evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n        (s, Rval (Closure env n e)) = r3b\nA total of 40 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s1 e (s2, Rval v1)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rval v1) = ?r3b\n  evaluate ck env s1 (Handle e pes) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s1 e (s2, Rval v1)\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rval v1) = ?r3b\n  evaluate ck env s1 (Handle e pes) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rval v1) = r3b", "by - (ind_cases \"evaluate ck env s1 (Handle e pes) r3b\", auto)"], ["proof (state)\nthis:\n  (s2, Rval v1) = r3b\n\ngoal (39 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 3. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 4. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 5. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 8. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 10. \\<And>ck env es vs env' e bv s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = Some (env', e) \\<and>\n                 (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                 evaluate ck env'\n                  (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                   else s2)\n                  e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env'\n                      (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                       else s2)\n                      e x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 3. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 4. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 5. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 8. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 10. \\<And>ck env es vs env' e bv s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = Some (env', e) \\<and>\n                 (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                 evaluate ck env'\n                  (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                   else s2)\n                  e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env'\n                      (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                       else s2)\n                      e x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 39 subgoals...", "case (handle2 ck s1 s2 env e pes v1 bv)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow>\n       (s2, Rerr (Rraise v1)) = x)) \\<and>\n  evaluate_match ck env s2 v1 pes v1 bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (Handle e pes) r3b\n\ngoal (39 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e pes v1 bv r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rerr (Rraise v1)) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes v1 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 3. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 4. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 5. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 8. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 10. \\<And>ck env es vs env' e bv s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = Some (env', e) \\<and>\n                 (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                 evaluate ck env'\n                  (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                   else s2)\n                  e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env'\n                      (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                       else s2)\n                      e x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 39 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow>\n       (s2, Rerr (Rraise v1)) = x)) \\<and>\n  evaluate_match ck env s2 v1 pes v1 bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (Handle e pes) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow>\n       (s2, Rerr (Rraise v1)) = x)) \\<and>\n  evaluate_match ck env s2 v1 pes v1 bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s2 v1 pes v1 x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (Handle e pes) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s1 (Handle e pes) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (38 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 3. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 4. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 5. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 7. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 9. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env es vs env' e s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = Some (env', e) \\<and>\n                 clock s2 = 0 \\<and> ck;\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\nA total of 38 subgoals...", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 3. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 4. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 5. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 7. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 9. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env es vs env' e s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = Some (env', e) \\<and>\n                 clock s2 = 0 \\<and> ck;\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\nA total of 38 subgoals...", "case (handle3 ck s1 s2 env e pes a)"], ["proof (state)\nthis:\n  evaluate ck env s1 e (s2, Rerr (Rabort a))\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rerr (Rabort a)) = ?r3b\n  evaluate ck env s1 (Handle e pes) r3b\n\ngoal (38 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck s1 s2 env e pes a r3b.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>r3b.\n           evaluate ck env s1 e r3b \\<Longrightarrow>\n           (s2, Rerr (Rabort a)) = r3b;\n        evaluate ck env s1 (Handle e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort a)) = r3b\n 3. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 4. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 5. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 7. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 9. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env es vs env' e s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = Some (env', e) \\<and>\n                 clock s2 = 0 \\<and> ck;\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\nA total of 38 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s1 e (s2, Rerr (Rabort a))\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rerr (Rabort a)) = ?r3b\n  evaluate ck env s1 (Handle e pes) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s1 e (s2, Rerr (Rabort a))\n  evaluate ck env s1 e ?r3b \\<Longrightarrow> (s2, Rerr (Rabort a)) = ?r3b\n  evaluate ck env s1 (Handle e pes) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rabort a)) = r3b", "by - (ind_cases \"evaluate ck env s1 (Handle e pes) r3b\"; auto)"], ["proof (state)\nthis:\n  (s2, Rerr (Rabort a)) = r3b\n\ngoal (37 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 3. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 5. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 6. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 8. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 10. \\<And>ck env es vs s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = None;\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 3. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 5. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 6. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 8. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 10. \\<And>ck env es vs s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = None;\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 37 subgoals...", "case (con1 ck env cn es vs s s' v1)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es) \\<and>\n  build_conv (c env) cn (rev vs) = Some v1 \\<and>\n  evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s (rev es) x \\<longrightarrow> (s', Rval vs) = x)\n  evaluate ck env s (Con cn es) r3b\n\ngoal (37 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es vs s s' v1 r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rval vs) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rval v1) = r3b\n 3. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 5. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 6. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 8. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 10. \\<And>ck env es vs s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_opapp (rev vs) = None;\n         evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 37 subgoals...", "then"], ["proof (chain)\npicking this:\n  do_con_check (c env) cn (length es) \\<and>\n  build_conv (c env) cn (rev vs) = Some v1 \\<and>\n  evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s (rev es) x \\<longrightarrow> (s', Rval vs) = x)\n  evaluate ck env s (Con cn es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es) \\<and>\n  build_conv (c env) cn (rev vs) = Some v1 \\<and>\n  evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s (rev es) x \\<longrightarrow> (s', Rval vs) = x)\n  evaluate ck env s (Con cn es) r3b\n\ngoal (1 subgoal):\n 1. (s', Rval v1) = r3b", "by - (ind_cases \"evaluate ck env s (Con cn es) r3b\"; fastforce)"], ["proof (state)\nthis:\n  (s', Rval v1) = r3b\n\ngoal (36 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 3. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 4. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 5. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 7. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 9. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_app (refs s2, ffi s2) op0 (rev vs) =\n                 Some ((refs', ffi'), res) \\<and>\n                 op0 \\<noteq> Opapp;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                            (update_refs (\\<lambda>_. refs') s2),\n                           res) =\n                          r3b\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 3. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 4. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 5. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 7. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 9. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_app (refs s2, ffi s2) op0 (rev vs) =\n                 Some ((refs', ffi'), res) \\<and>\n                 op0 \\<noteq> Opapp;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                            (update_refs (\\<lambda>_. refs') s2),\n                           res) =\n                          r3b\nA total of 36 subgoals...", "case (con2 ck env cn es s)"], ["proof (state)\nthis:\n  \\<not> do_con_check (c env) cn (length es)\n  evaluate ck env s (Con cn es) r3b\n\ngoal (36 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es s r3b.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 3. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 4. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 5. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 7. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 9. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_app (refs s2, ffi s2) op0 (rev vs) =\n                 Some ((refs', ffi'), res) \\<and>\n                 op0 \\<noteq> Opapp;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                            (update_refs (\\<lambda>_. refs') s2),\n                           res) =\n                          r3b\nA total of 36 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<not> do_con_check (c env) cn (length es)\n  evaluate ck env s (Con cn es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> do_con_check (c env) cn (length es)\n  evaluate ck env s (Con cn es) r3b\n\ngoal (1 subgoal):\n 1. (s, Rerr (Rabort Rtype_error)) = r3b", "by - (ind_cases \"evaluate ck env s (Con cn es) r3b\", auto)"], ["proof (state)\nthis:\n  (s, Rerr (Rabort Rtype_error)) = r3b\n\ngoal (35 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 3. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 4. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 5. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 6. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 8. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 10. \\<And>ck env op0 es vs s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                 op0 \\<noteq> Opapp;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 3. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 4. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 5. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 6. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 8. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 10. \\<And>ck env op0 es vs s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                 op0 \\<noteq> Opapp;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 35 subgoals...", "case (con3 ck env cn es err s s')"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es) \\<and>\n  evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s (rev es) x \\<longrightarrow>\n      (s', Rerr err) = x)\n  evaluate ck env s (Con cn es) r3b\n\ngoal (35 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env cn es err s s' r3b.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s (rev es) x \\<longrightarrow>\n                    (s', Rerr err) = x);\n        evaluate ck env s (Con cn es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 3. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 4. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 5. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 6. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 8. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 10. \\<And>ck env op0 es vs s1 s2 r3b.\n        \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                  (\\<forall>x.\n                      evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                      (s2, Rval vs) = x)) \\<and>\n                 do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                 op0 \\<noteq> Opapp;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 35 subgoals...", "then"], ["proof (chain)\npicking this:\n  do_con_check (c env) cn (length es) \\<and>\n  evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s (rev es) x \\<longrightarrow>\n      (s', Rerr err) = x)\n  evaluate ck env s (Con cn es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es) \\<and>\n  evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s (rev es) x \\<longrightarrow>\n      (s', Rerr err) = x)\n  evaluate ck env s (Con cn es) r3b\n\ngoal (1 subgoal):\n 1. (s', Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s (Con cn es) r3b\", auto)"], ["proof (state)\nthis:\n  (s', Rerr err) = r3b\n\ngoal (34 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 7. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 9. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 es err s1 s2 r3b.\n        \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n         \\<And>r2b.\n            evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n            (s2, Rerr err) = r2b;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr err) = r3b\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 7. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 9. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 es err s1 s2 r3b.\n        \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n         \\<And>r2b.\n            evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n            (s2, Rerr err) = r2b;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr err) = r3b\nA total of 34 subgoals...", "case (app1 ck env es vs env' e bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and>\n  (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n  evaluate ck env'\n   (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n   bv \\<and>\n  (\\<forall>x.\n      evaluate ck env'\n       (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (App Opapp es) r3b\n\ngoal (34 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs env' e bv s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n                evaluate ck env'\n                 (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                  else s2)\n                 e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env'\n                     (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2\n                      else s2)\n                     e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 7. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 9. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 es err s1 s2 r3b.\n        \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n         \\<And>r2b.\n            evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n            (s2, Rerr err) = r2b;\n         evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr err) = r3b\nA total of 34 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and>\n  (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n  evaluate ck env'\n   (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n   bv \\<and>\n  (\\<forall>x.\n      evaluate ck env'\n       (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (App Opapp es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and>\n  (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n  evaluate ck env'\n   (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n   bv \\<and>\n  (\\<forall>x.\n      evaluate ck env'\n       (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (App Opapp es) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s1 (App Opapp es) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (33 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 6. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 8. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 10. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = Some (Exp e') \\<and>\n                 evaluate ck env s2 e' bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 6. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 8. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 10. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = Some (Exp e') \\<and>\n                 evaluate ck env s2 e' bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 33 subgoals...", "case (app2 ck env es vs env' e s1 s2)"], ["proof (state)\nthis:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and> clock s2 = 0 \\<and> ck\n  evaluate ck env s1 (App Opapp es) r3b\n\ngoal (33 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs env' e s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = Some (env', e) \\<and>\n                clock s2 = 0 \\<and> ck;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtimeout_error)) = r3b\n 6. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 8. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 10. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = Some (Exp e') \\<and>\n                 evaluate ck env s2 e' bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 33 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and> clock s2 = 0 \\<and> ck\n  evaluate ck env s1 (App Opapp es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and> clock s2 = 0 \\<and> ck\n  evaluate ck env s1 (App Opapp es) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rabort Rtimeout_error)) = r3b", "by - (ind_cases \"evaluate ck env s1 (App Opapp es) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rerr (Rabort Rtimeout_error)) = r3b\n\ngoal (32 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 7. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 9. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = Some (Val bv);\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rval bv) = r3b\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 7. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 9. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = Some (Val bv);\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rval bv) = r3b\nA total of 32 subgoals...", "case (app3 ck env es vs s1 s2)"], ["proof (state)\nthis:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = None\n  evaluate ck env s1 (App Opapp es) r3b\n\ngoal (32 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_opapp (rev vs) = None;\n        evaluate ck env s1 (App Opapp es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 7. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 9. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = Some (Val bv);\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rval bv) = r3b\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = None\n  evaluate ck env s1 (App Opapp es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_opapp (rev vs) = None\n  evaluate ck env s1 (App Opapp es) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rabort Rtype_error)) = r3b", "by - (ind_cases \"evaluate ck env s1 (App Opapp es) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rerr (Rabort Rtype_error)) = r3b\n\ngoal (31 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 6. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 8. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 10. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = None;\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 6. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 8. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 10. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = None;\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 31 subgoals...", "case (app4 ck env op0 es vs res s1 s2 refs' ffi')"], ["proof (state)\nthis:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_app (refs s2, ffi s2) op0 (rev vs) = Some ((refs', ffi'), res) \\<and>\n  op0 \\<noteq> Opapp\n  evaluate ck env s1 (App op0 es) r3b\n\ngoal (31 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es vs res s1 s2 refs' ffi' r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) =\n                Some ((refs', ffi'), res) \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (update_ffi (\\<lambda>_. ffi')\n                           (update_refs (\\<lambda>_. refs') s2),\n                          res) =\n                         r3b\n 6. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 8. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 10. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_log op0 v1 e2 = None;\n         evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 31 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_app (refs s2, ffi s2) op0 (rev vs) = Some ((refs', ffi'), res) \\<and>\n  op0 \\<noteq> Opapp\n  evaluate ck env s1 (App op0 es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_app (refs s2, ffi s2) op0 (rev vs) = Some ((refs', ffi'), res) \\<and>\n  op0 \\<noteq> Opapp\n  evaluate ck env s1 (App op0 es) r3b\n\ngoal (1 subgoal):\n 1. (update_ffi (\\<lambda>_. ffi') (update_refs (\\<lambda>_. refs') s2),\n     res) =\n    r3b", "by - (ind_cases \"evaluate ck env s1 (App op0 es) r3b\"; fastforce)"], ["proof (state)\nthis:\n  (update_ffi (\\<lambda>_. ffi') (update_refs (\\<lambda>_. refs') s2),\n   res) =\n  r3b\n\ngoal (30 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 7. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 9. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 e1 e2 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 7. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 9. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 e1 e2 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 30 subgoals...", "case (app5 ck env op0 es vs s1 s2)"], ["proof (state)\nthis:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and> op0 \\<noteq> Opapp\n  evaluate ck env s1 (App op0 es) r3b\n\ngoal (30 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es vs s1 s2 r3b.\n       \\<lbrakk>(evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n                     (s2, Rval vs) = x)) \\<and>\n                do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and>\n                op0 \\<noteq> Opapp;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 7. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 9. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env op0 e1 e2 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 30 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and> op0 \\<noteq> Opapp\n  evaluate ck env s1 (App op0 es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x.\n       evaluate_list ck env s1 (rev es) x \\<longrightarrow>\n       (s2, Rval vs) = x)) \\<and>\n  do_app (refs s2, ffi s2) op0 (rev vs) = None \\<and> op0 \\<noteq> Opapp\n  evaluate ck env s1 (App op0 es) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rabort Rtype_error)) = r3b", "by - (ind_cases \"evaluate ck env s1 (App op0 es) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rerr (Rabort Rtype_error)) = r3b\n\ngoal (29 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 6. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 8. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_if v1 e2 e3 = Some e' \\<and>\n                 evaluate ck env s2 e' bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n         evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 6. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 8. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_if v1 e2 e3 = Some e' \\<and>\n                 evaluate ck env s2 e' bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n         evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 29 subgoals...", "case (app6 ck env op0 es err s1 s2)"], ["proof (state)\nthis:\n  evaluate_list ck env s1 (rev es) (s2, Rerr err)\n  evaluate_list ck env s1 (rev es) ?r2b \\<Longrightarrow>\n  (s2, Rerr err) = ?r2b\n  evaluate ck env s1 (App op0 es) r3b\n\ngoal (29 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 es err s1 s2 r3b.\n       \\<lbrakk>evaluate_list ck env s1 (rev es) (s2, Rerr err);\n        \\<And>r2b.\n           evaluate_list ck env s1 (rev es) r2b \\<Longrightarrow>\n           (s2, Rerr err) = r2b;\n        evaluate ck env s1 (App op0 es) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr err) = r3b\n 6. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 8. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_if v1 e2 e3 = Some e' \\<and>\n                 evaluate ck env s2 e' bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n         evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 29 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate_list ck env s1 (rev es) (s2, Rerr err)\n  evaluate_list ck env s1 (rev es) ?r2b \\<Longrightarrow>\n  (s2, Rerr err) = ?r2b\n  evaluate ck env s1 (App op0 es) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_list ck env s1 (rev es) (s2, Rerr err)\n  evaluate_list ck env s1 (rev es) ?r2b \\<Longrightarrow>\n  (s2, Rerr err) = ?r2b\n  evaluate ck env s1 (App op0 es) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s1 (App op0 es) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rerr err) = r3b\n\ngoal (28 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 7. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_if v1 e2 e3 = None;\n         evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 7. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_if v1 e2 e3 = None;\n         evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 28 subgoals...", "case (log1 ck env op0 e1 e2 v1 e' bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = Some (Exp e') \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x. evaluate ck env s2 e' x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (Log op0 e1 e2) r3b\n\ngoal (28 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Exp e') \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 7. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 do_if v1 e2 e3 = None;\n         evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\nA total of 28 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = Some (Exp e') \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x. evaluate ck env s2 e' x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (Log op0 e1 e2) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = Some (Exp e') \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x. evaluate ck env s2 e' x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (Log op0 e1 e2) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s1 (Log op0 e1 e2) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (27 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 6. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env e1 e2 e3 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 6. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env e1 e2 e3 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 27 subgoals...", "case (log2 ck env op0 e1 e2 v1 bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = Some (Val bv)\n  evaluate ck env s1 (Log op0 e1 e2) r3b\n\ngoal (27 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = Some (Val bv);\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rval bv) = r3b\n 6. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env e1 e2 e3 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 27 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = Some (Val bv)\n  evaluate ck env s1 (Log op0 e1 e2) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = Some (Val bv)\n  evaluate ck env s1 (Log op0 e1 e2) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rval bv) = r3b", "by - (ind_cases \"evaluate ck env s1 (Log op0 e1 e2) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rval bv) = r3b\n\ngoal (26 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env e pes v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_match ck env s2 v1 pes\n                  (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                  bv \\<and>\n                 (\\<forall>x.\n                     evaluate_match ck env s2 v1 pes\n                      (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                      x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env e pes v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_match ck env s2 v1 pes\n                  (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                  bv \\<and>\n                 (\\<forall>x.\n                     evaluate_match ck env s2 v1 pes\n                      (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                      x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 26 subgoals...", "case (log3 ck env op0 e1 e2 v1 s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = None\n  evaluate ck env s1 (Log op0 e1 e2) r3b\n\ngoal (26 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_log op0 v1 e2 = None;\n        evaluate ck env s1 (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env e pes v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_match ck env s2 v1 pes\n                  (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                  bv \\<and>\n                 (\\<forall>x.\n                     evaluate_match ck env s2 v1 pes\n                      (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                      x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 26 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = None\n  evaluate ck env s1 (Log op0 e1 e2) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_log op0 v1 e2 = None\n  evaluate ck env s1 (Log op0 e1 e2) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rabort Rtype_error)) = r3b", "by - (ind_cases \"evaluate ck env s1 (Log op0 e1 e2) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rerr (Rabort Rtype_error)) = r3b\n\ngoal (25 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e pes err s s' r3b.\n        \\<lbrakk>evaluate ck env s e (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e pes err s s' r3b.\n        \\<lbrakk>evaluate ck env s e (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 25 subgoals...", "case (log4 ck env op0 e1 e2 err s s')"], ["proof (state)\nthis:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (Log op0 e1 e2) r3b\n\ngoal (25 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env op0 e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Log op0 e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e pes err s s' r3b.\n        \\<lbrakk>evaluate ck env s e (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (Log op0 e1 e2) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (Log op0 e1 e2) r3b\n\ngoal (1 subgoal):\n 1. (s', Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s (Log op0 e1 e2) r3b\"; auto)"], ["proof (state)\nthis:\n  (s', Rerr err) = r3b\n\ngoal (24 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate ck\n                  (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                    env)\n                  s2 e2 bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                        env)\n                      s2 e2 x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate ck\n                  (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                    env)\n                  s2 e2 bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                        env)\n                      s2 e2 x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 24 subgoals...", "case (if1 ck env e1 e2 e3 v1 e' bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_if v1 e2 e3 = Some e' \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x. evaluate ck env s2 e' x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (exp0.If e1 e2 e3) r3b\n\ngoal (24 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 v1 e' bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = Some e' \\<and>\n                evaluate ck env s2 e' bv \\<and>\n                (\\<forall>x.\n                    evaluate ck env s2 e' x \\<longrightarrow> bv = x);\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n        \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e1 x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate ck\n                  (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                    env)\n                  s2 e2 bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                        env)\n                      s2 e2 x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_if v1 e2 e3 = Some e' \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x. evaluate ck env s2 e' x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (exp0.If e1 e2 e3) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_if v1 e2 e3 = Some e' \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x. evaluate ck env s2 e' x \\<longrightarrow> bv = x)\n  evaluate ck env s1 (exp0.If e1 e2 e3) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s1 (If e1 e2 e3) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (23 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env n e1 e2 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env n e1 e2 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 23 subgoals...", "case (if2 ck env e1 e2 e3 v1 s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_if v1 e2 e3 = None\n  evaluate ck env s1 (exp0.If e1 e2 e3) r3b\n\ngoal (23 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 v1 s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                do_if v1 e2 e3 = None;\n        evaluate ck env s1 (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s2, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env n e1 e2 err s s' r3b.\n        \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r3b\nA total of 23 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_if v1 e2 e3 = None\n  evaluate ck env s1 (exp0.If e1 e2 e3) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  do_if v1 e2 e3 = None\n  evaluate ck env s1 (exp0.If e1 e2 e3) r3b\n\ngoal (1 subgoal):\n 1. (s2, Rerr (Rabort Rtype_error)) = r3b", "by - (ind_cases \"evaluate ck env s1 (If e1 e2 e3) r3b\"; force)"], ["proof (state)\nthis:\n  (s2, Rerr (Rabort Rtype_error)) = r3b\n\ngoal (22 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env funs e bv s r3b.\n        \\<lbrakk>allDistinct\n                  (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                    funs) \\<and>\n                 evaluate ck\n                  (update_v\n                    (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                    env)\n                  s e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                        env)\n                      s e x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env funs e bv s r3b.\n        \\<lbrakk>allDistinct\n                  (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                    funs) \\<and>\n                 evaluate ck\n                  (update_v\n                    (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                    env)\n                  s e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                        env)\n                      s e x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 22 subgoals...", "case (if3 ck env e1 e2 e3 err s s')"], ["proof (state)\nthis:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (exp0.If e1 e2 e3) r3b\n\ngoal (22 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e1 e2 e3 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.If e1 e2 e3) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 10. \\<And>ck env funs e bv s r3b.\n        \\<lbrakk>allDistinct\n                  (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                    funs) \\<and>\n                 evaluate ck\n                  (update_v\n                    (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                    env)\n                  s e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                        env)\n                      s e x \\<longrightarrow>\n                     bv = x);\n         evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 22 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (exp0.If e1 e2 e3) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (exp0.If e1 e2 e3) r3b\n\ngoal (1 subgoal):\n 1. (s', Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s (If e1 e2 e3) r3b\", auto)"], ["proof (state)\nthis:\n  (s', Rerr err) = r3b\n\ngoal (21 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env funs e s r3b.\n        \\<lbrakk>\\<not> allDistinct\n                         (map (\\<lambda>x.\n                                  case x of (x, y, z) \\<Rightarrow> x)\n                           funs);\n         evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env funs e s r3b.\n        \\<lbrakk>\\<not> allDistinct\n                         (map (\\<lambda>x.\n                                  case x of (x, y, z) \\<Rightarrow> x)\n                           funs);\n         evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\nA total of 21 subgoals...", "case (mat1 ck env e pes v1 bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s2 v1 pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (Mat e pes) r3b\n\ngoal (21 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e pes v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_match ck env s2 v1 pes\n                 (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                 bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s2 v1 pes\n                     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n                     x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 9. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env funs e s r3b.\n        \\<lbrakk>\\<not> allDistinct\n                         (map (\\<lambda>x.\n                                  case x of (x, y, z) \\<Rightarrow> x)\n                           funs);\n         evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\nA total of 21 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s2 v1 pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (Mat e pes) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s2 v1 pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (Mat e pes) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s1 (Mat e pes) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (20 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env e t0 s bv r3b.\n        \\<lbrakk>evaluate ck env s e bv;\n         \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n         evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env e t0 s bv r3b.\n        \\<lbrakk>evaluate ck env s e bv;\n         \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n         evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 20 subgoals...", "case (mat2 ck env e pes err s s')"], ["proof (state)\nthis:\n  evaluate ck env s e (s', Rerr err)\n  evaluate ck env s e ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (Mat e pes) r3b\n\ngoal (20 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e pes err s s' r3b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (Mat e pes) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 8. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 10. \\<And>ck env e t0 s bv r3b.\n        \\<lbrakk>evaluate ck env s e bv;\n         \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n         evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e (s', Rerr err)\n  evaluate ck env s e ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (Mat e pes) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e (s', Rerr err)\n  evaluate ck env s e ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (Mat e pes) r3b\n\ngoal (1 subgoal):\n 1. (s', Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s (Mat e pes) r3b\", auto)"], ["proof (state)\nthis:\n  (s', Rerr err) = r3b\n\ngoal (19 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e l s bv r3b.\n        \\<lbrakk>evaluate ck env s e bv;\n         \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n         evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e l s bv r3b.\n        \\<lbrakk>evaluate ck env s e bv;\n         \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n         evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 19 subgoals...", "case (let1 ck env n e1 e2 v1 bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate ck (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2\n   e2 bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (exp0.Let n e1 e2) r3b\n\ngoal (19 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env n e1 e2 v1 bv s1 s2 r3b.\n       \\<lbrakk>(evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e1 x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate ck\n                 (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n                 s2 e2 bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env))\n                       env)\n                     s2 e2 x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s1 (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 7. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 9. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env e l s bv r3b.\n        \\<lbrakk>evaluate ck env s e bv;\n         \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n         evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n        \\<Longrightarrow> bv = r3b\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate ck (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2\n   e2 bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (exp0.Let n e1 e2) r3b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e1 x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate ck (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2\n   e2 bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n       x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s1 (exp0.Let n e1 e2) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s1 (Let n e1 e2) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (18 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env s r2b.\n        evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env s r2b.\n        evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\nA total of 18 subgoals...", "case (let2 ck env n e1 e2 err s s')"], ["proof (state)\nthis:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (exp0.Let n e1 e2) r3b\n\ngoal (18 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env n e1 e2 err s s' r3b.\n       \\<lbrakk>evaluate ck env s e1 (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e1 r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate ck env s (exp0.Let n e1 e2) r3b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r3b\n 6. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 8. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 10. \\<And>ck env s r2b.\n        evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (exp0.Let n e1 e2) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e1 (s', Rerr err)\n  evaluate ck env s e1 ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate ck env s (exp0.Let n e1 e2) r3b\n\ngoal (1 subgoal):\n 1. (s', Rerr err) = r3b", "by - (ind_cases \"evaluate ck env s (Let n e1 e2) r3b\", auto)"], ["proof (state)\nthis:\n  (s', Rerr err) = r3b\n\ngoal (17 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 10. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s2 es x \\<longrightarrow>\n                     (s3, Rval vs) = x);\n         evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 10. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s2 es x \\<longrightarrow>\n                     (s3, Rval vs) = x);\n         evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\nA total of 17 subgoals...", "case (letrec1 ck env funs e bv s)"], ["proof (state)\nthis:\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs) \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) s e\n   bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) s\n       e x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s (Letrec funs e) r3b\n\ngoal (17 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env funs e bv s r3b.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs) \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 7. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 9. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 10. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s2 es x \\<longrightarrow>\n                     (s3, Rval vs) = x);\n         evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs) \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) s e\n   bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) s\n       e x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s (Letrec funs e) r3b", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs) \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) s e\n   bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) s\n       e x \\<longrightarrow>\n      bv = x)\n  evaluate ck env s (Letrec funs e) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s (Letrec funs e) r3b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (16 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 9. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 10. \\<And>ck env e es err s s' r2b.\n        \\<lbrakk>evaluate ck env s e (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate_list ck env s (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r2b\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 9. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 10. \\<And>ck env e es err s s' r2b.\n        \\<lbrakk>evaluate ck env s e (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate_list ck env s (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r2b\nA total of 16 subgoals...", "case (letrec2 ck env funs e s)"], ["proof (state)\nthis:\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs)\n  evaluate ck env s (Letrec funs e) r3b\n\ngoal (16 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env funs e s r3b.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        evaluate ck env s (Letrec funs e) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 6. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 8. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 9. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 10. \\<And>ck env e es err s s' r2b.\n        \\<lbrakk>evaluate ck env s e (s', Rerr err);\n         \\<And>r3b.\n            evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n         evaluate_list ck env s (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s', Rerr err) = r2b\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs)\n  evaluate ck env s (Letrec funs e) r3b", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs)\n  evaluate ck env s (Letrec funs e) r3b\n\ngoal (1 subgoal):\n 1. (s, Rerr (Rabort Rtype_error)) = r3b", "by - (ind_cases \"evaluate ck env s (Letrec funs e) r3b\", auto)"], ["proof (state)\nthis:\n  (s, Rerr (Rabort Rtype_error)) = r3b\n\ngoal (15 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 8. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 9. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 10. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s2 es x \\<longrightarrow>\n                     (s3, Rerr err) = x);\n         evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s3, Rerr err) = r2b\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 8. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 9. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 10. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s2 es x \\<longrightarrow>\n                     (s3, Rerr err) = x);\n         evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s3, Rerr err) = r2b\nA total of 15 subgoals...", "case (tannot ck env e t0 s bv)"], ["proof (state)\nthis:\n  evaluate ck env s e bv\n  evaluate ck env s e ?r3b \\<Longrightarrow> bv = ?r3b\n  evaluate ck env s (Tannot e t0) r3b\n\ngoal (15 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e t0 s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Tannot e t0) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 7. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 8. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 9. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 10. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n        \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                  (\\<forall>x.\n                      evaluate ck env s1 e x \\<longrightarrow>\n                      (s2, Rval v1) = x)) \\<and>\n                 evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                 (\\<forall>x.\n                     evaluate_list ck env s2 es x \\<longrightarrow>\n                     (s3, Rerr err) = x);\n         evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n        \\<Longrightarrow> (s3, Rerr err) = r2b\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e bv\n  evaluate ck env s e ?r3b \\<Longrightarrow> bv = ?r3b\n  evaluate ck env s (Tannot e t0) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e bv\n  evaluate ck env s e ?r3b \\<Longrightarrow> bv = ?r3b\n  evaluate ck env s (Tannot e t0) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s (Tannot e t0) r3b\", auto)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (14 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 7. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 8. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 9. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 10. \\<And>ck env v1 err_v s r1b.\n        evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n        (s, Rerr (Rraise err_v)) = r1b\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 7. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 8. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 9. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 10. \\<And>ck env v1 err_v s r1b.\n        evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n        (s, Rerr (Rraise err_v)) = r1b\nA total of 14 subgoals...", "case (locannot ck env e l s bv)"], ["proof (state)\nthis:\n  evaluate ck env s e bv\n  evaluate ck env s e ?r3b \\<Longrightarrow> bv = ?r3b\n  evaluate ck env s (Lannot e l) r3b\n\ngoal (14 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env e l s bv r3b.\n       \\<lbrakk>evaluate ck env s e bv;\n        \\<And>r3b. evaluate ck env s e r3b \\<Longrightarrow> bv = r3b;\n        evaluate ck env s (Lannot e l) r3b\\<rbrakk>\n       \\<Longrightarrow> bv = r3b\n 6. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 7. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 8. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 9. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 10. \\<And>ck env v1 err_v s r1b.\n        evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n        (s, Rerr (Rraise err_v)) = r1b\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e bv\n  evaluate ck env s e ?r3b \\<Longrightarrow> bv = ?r3b\n  evaluate ck env s (Lannot e l) r3b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e bv\n  evaluate ck env s e ?r3b \\<Longrightarrow> bv = ?r3b\n  evaluate ck env s (Lannot e l) r3b\n\ngoal (1 subgoal):\n 1. bv = r3b", "by - (ind_cases \"evaluate ck env s (Lannot e l) r3b\", auto)"], ["proof (state)\nthis:\n  bv = r3b\n\ngoal (13 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 7. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 8. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 9. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 10. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n        \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                 pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                 evaluate ck\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)\n                  s e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env)\n                      s e x \\<longrightarrow>\n                     bv = x);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> bv = r1b\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 7. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 8. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 9. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 10. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n        \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                 pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                 evaluate ck\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)\n                  s e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env)\n                      s e x \\<longrightarrow>\n                     bv = x);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> bv = r1b\nA total of 13 subgoals...", "case (cons1 ck env e es v1 vs s1 s2 s3)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s2 es x \\<longrightarrow> (s3, Rval vs) = x)\n  evaluate_list ck env s1 (e # es) r2b\n\ngoal (13 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es v1 vs s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rval vs) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rval (v1 # vs)) = r2b\n 7. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 8. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 9. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 10. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n        \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                 pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                 evaluate ck\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)\n                  s e bv \\<and>\n                 (\\<forall>x.\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env)\n                      s e x \\<longrightarrow>\n                     bv = x);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> bv = r1b\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s2 es x \\<longrightarrow> (s3, Rval vs) = x)\n  evaluate_list ck env s1 (e # es) r2b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s2 es x \\<longrightarrow> (s3, Rval vs) = x)\n  evaluate_list ck env s1 (e # es) r2b\n\ngoal (1 subgoal):\n 1. (s3, Rval (v1 # vs)) = r2b", "by - (ind_cases \"evaluate_list ck env s1 (e # es) r2b\", auto)"], ["proof (state)\nthis:\n  (s3, Rval (v1 # vs)) = r2b\n\ngoal (12 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 7. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 8. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 9. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 10. \\<And>ck env v1 p e pes bv s err_v r1b.\n        \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                 pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                 evaluate_match ck env s v1 pes err_v bv \\<and>\n                 (\\<forall>x.\n                     evaluate_match ck env s v1 pes err_v\n                      x \\<longrightarrow>\n                     bv = x);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> bv = r1b\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 7. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 8. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 9. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 10. \\<And>ck env v1 p e pes bv s err_v r1b.\n        \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                 pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                 evaluate_match ck env s v1 pes err_v bv \\<and>\n                 (\\<forall>x.\n                     evaluate_match ck env s v1 pes err_v\n                      x \\<longrightarrow>\n                     bv = x);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> bv = r1b\nA total of 12 subgoals...", "case (cons2 ck env e es err s s')"], ["proof (state)\nthis:\n  evaluate ck env s e (s', Rerr err)\n  evaluate ck env s e ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate_list ck env s (e # es) r2b\n\ngoal (12 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es err s s' r2b.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err);\n        \\<And>r3b.\n           evaluate ck env s e r3b \\<Longrightarrow> (s', Rerr err) = r3b;\n        evaluate_list ck env s (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s', Rerr err) = r2b\n 7. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 8. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 9. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 10. \\<And>ck env v1 p e pes bv s err_v r1b.\n        \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                 pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                 evaluate_match ck env s v1 pes err_v bv \\<and>\n                 (\\<forall>x.\n                     evaluate_match ck env s v1 pes err_v\n                      x \\<longrightarrow>\n                     bv = x);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> bv = r1b\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck env s e (s', Rerr err)\n  evaluate ck env s e ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate_list ck env s (e # es) r2b", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck env s e (s', Rerr err)\n  evaluate ck env s e ?r3b \\<Longrightarrow> (s', Rerr err) = ?r3b\n  evaluate_list ck env s (e # es) r2b\n\ngoal (1 subgoal):\n 1. (s', Rerr err) = r2b", "by - (ind_cases \"evaluate_list ck env s (e # es) r2b\", auto)"], ["proof (state)\nthis:\n  (s', Rerr err) = r2b\n\ngoal (11 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 7. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 8. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 9. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 10. \\<And>ck env v1 p e pes s err_v r1b.\n        \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 7. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 8. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 9. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 10. \\<And>ck env v1 p e pes s err_v r1b.\n        \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\nA total of 11 subgoals...", "case (cons3 ck env e es v1 err s1 s2 s3)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s2 es x \\<longrightarrow> (s3, Rerr err) = x)\n  evaluate_list ck env s1 (e # es) r2b\n\ngoal (11 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env e es v1 err s1 s2 s3 r2b.\n       \\<lbrakk>(evaluate ck env s1 e (s2, Rval v1) \\<and>\n                 (\\<forall>x.\n                     evaluate ck env s1 e x \\<longrightarrow>\n                     (s2, Rval v1) = x)) \\<and>\n                evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n                (\\<forall>x.\n                    evaluate_list ck env s2 es x \\<longrightarrow>\n                    (s3, Rerr err) = x);\n        evaluate_list ck env s1 (e # es) r2b\\<rbrakk>\n       \\<Longrightarrow> (s3, Rerr err) = r2b\n 7. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 8. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 9. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 10. \\<And>ck env v1 p e pes s err_v r1b.\n        \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s2 es x \\<longrightarrow> (s3, Rerr err) = x)\n  evaluate_list ck env s1 (e # es) r2b", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x.\n       evaluate ck env s1 e x \\<longrightarrow> (s2, Rval v1) = x)) \\<and>\n  evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n  (\\<forall>x.\n      evaluate_list ck env s2 es x \\<longrightarrow> (s3, Rerr err) = x)\n  evaluate_list ck env s1 (e # es) r2b\n\ngoal (1 subgoal):\n 1. (s3, Rerr err) = r2b", "by - (ind_cases \"evaluate_list ck env s1 (e # es) r2b\", auto)"], ["proof (state)\nthis:\n  (s3, Rerr err) = r2b\n\ngoal (10 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 8. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 9. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 10. \\<And>ck env v1 p e pes s err_v r1b.\n        \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 8. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 9. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 10. \\<And>ck env v1 p e pes s err_v r1b.\n        \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "case (mat_cons1 ck env env' v1 p pes e bv err_v s)"], ["proof (state)\nthis:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n         env)\n       s e x \\<longrightarrow>\n      bv = x)\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (10 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env env' v1 p pes e bv err_v s r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n                evaluate ck\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)\n                 s e bv \\<and>\n                (\\<forall>x.\n                    evaluate ck\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     s e x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 8. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 9. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 10. \\<And>ck env v1 p e pes s err_v r1b.\n        \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n         evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n        \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "then"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n         env)\n       s e x \\<longrightarrow>\n      bv = x)\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e bv \\<and>\n  (\\<forall>x.\n      evaluate ck\n       (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n         env)\n       s e x \\<longrightarrow>\n      bv = x)\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (1 subgoal):\n 1. bv = r1b", "by - (ind_cases \"evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r1b\n\ngoal (9 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 8. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 9. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 8. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 9. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "case (mat_cons2 ck env v1 p e pes bv s err_v)"], ["proof (state)\nthis:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n  evaluate_match ck env s v1 pes err_v bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s v1 pes err_v x \\<longrightarrow> bv = x)\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (9 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes bv s err_v r1b.\n       \\<lbrakk>allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n                evaluate_match ck env s v1 pes err_v bv \\<and>\n                (\\<forall>x.\n                    evaluate_match ck env s v1 pes err_v x \\<longrightarrow>\n                    bv = x);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> bv = r1b\n 8. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 9. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "then"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n  evaluate_match ck env s v1 pes err_v bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s v1 pes err_v x \\<longrightarrow> bv = x)\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n  evaluate_match ck env s v1 pes err_v bv \\<and>\n  (\\<forall>x.\n      evaluate_match ck env s v1 pes err_v x \\<longrightarrow> bv = x)\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (1 subgoal):\n 1. bv = r1b", "by - (ind_cases \"evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\"; fastforce)"], ["proof (state)\nthis:\n  bv = r1b\n\ngoal (8 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 8. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 8. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "case (mat_cons3 ck env v1 p e pes s err_v)"], ["proof (state)\nthis:\n  pmatch (c env) (refs s) p v1 [] = Match_type_error\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (8 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>pmatch (c env) (refs s) p v1 [] = Match_type_error;\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b\n 8. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "then"], ["proof (chain)\npicking this:\n  pmatch (c env) (refs s) p v1 [] = Match_type_error\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b", "show ?case"], ["proof (prove)\nusing this:\n  pmatch (c env) (refs s) p v1 [] = Match_type_error\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (1 subgoal):\n 1. (s, Rerr (Rabort Rtype_error)) = r1b", "by - (ind_cases \"evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\", auto)"], ["proof (state)\nthis:\n  (s, Rerr (Rabort Rtype_error)) = r1b\n\ngoal (7 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "case (mat_cons4 ck env v1 p e pes s err_v)"], ["proof (state)\nthis:\n  \\<not> allDistinct (pat_bindings p [])\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (7 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b\n 7. \\<And>ck env v1 p e pes s err_v r1b.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []);\n        evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r1b", "then"], ["proof (chain)\npicking this:\n  \\<not> allDistinct (pat_bindings p [])\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> allDistinct (pat_bindings p [])\n  evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\n\ngoal (1 subgoal):\n 1. (s, Rerr (Rabort Rtype_error)) = r1b", "by - (ind_cases \"evaluate_match ck env s v1 ((p, e) # pes) err_v r1b\", auto)"], ["proof (state)\nthis:\n  (s, Rerr (Rabort Rtype_error)) = r1b\n\ngoal (6 subgoals):\n 1. \\<And>ck env l s r3b.\n       evaluate ck env s (Lit l) r3b \\<Longrightarrow>\n       (s, Rval (Litv l)) = r3b\n 2. \\<And>ck env n v1 s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rval v1) = r3b\n 3. \\<And>ck env n s r3b.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None;\n        evaluate ck env s (Var n) r3b\\<rbrakk>\n       \\<Longrightarrow> (s, Rerr (Rabort Rtype_error)) = r3b\n 4. \\<And>ck env n e s r3b.\n       evaluate ck env s (Fun n e) r3b \\<Longrightarrow>\n       (s, Rval (Closure env n e)) = r3b\n 5. \\<And>ck env s r2b.\n       evaluate_list ck env s [] r2b \\<Longrightarrow> (s, Rval []) = r2b\n 6. \\<And>ck env v1 err_v s r1b.\n       evaluate_match ck env s v1 [] err_v r1b \\<Longrightarrow>\n       (s, Rerr (Rraise err_v)) = r1b", "qed (auto elim: evaluate.cases evaluate_list.cases evaluate_match.cases)"], ["", "end"]]}