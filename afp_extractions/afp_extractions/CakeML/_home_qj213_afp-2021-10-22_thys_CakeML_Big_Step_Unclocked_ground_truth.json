{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Big_Step_Unclocked.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma unclocked_sound:\n  \"evaluate_list v s es bv \\<Longrightarrow> BigStep.evaluate_list False v s es bv\"\n  \"evaluate v s e bv' \\<Longrightarrow> BigStep.evaluate False v s e bv'\"", "lemma unclocked_complete0:\n  \"BigStep.evaluate_match ck env s v0 pes err_v (s', bv) \\<Longrightarrow> \\<not> ck \\<Longrightarrow> (\n    case bv of\n        Rval v \\<Rightarrow>\n          \\<exists>e env'.\n            match_result env s v0 pes err_v = Rval (e, env') \\<and>\n            evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rval v)\n      | Rerr err \\<Rightarrow>\n          (match_result env s v0 pes err_v = Rerr err) \\<or>\n          (\\<exists>e env'.\n            match_result env s v0 pes err_v = Rval (e, env') \\<and>\n            evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rerr err)))\"\n  \"BigStep.evaluate_list ck v s es (s', bv0) \\<Longrightarrow> \\<not> ck \\<Longrightarrow> evaluate_list v s es (s', bv0)\"\n  \"BigStep.evaluate ck v s e (s', bv) \\<Longrightarrow> \\<not> ck \\<Longrightarrow> evaluate v s e (s', bv)\"", "lemma unclocked_complete:\n  \"BigStep.evaluate_list False v s es bv' \\<Longrightarrow> evaluate_list v s es bv'\"\n  \"BigStep.evaluate False v s e bv \\<Longrightarrow> evaluate v s e bv\"", "lemma unclocked_eq:\n  \"evaluate_list = BigStep.evaluate_list False\"\n  \"evaluate = BigStep.evaluate False\"", "lemma unclocked_determ:\n  \"evaluate_list env s es r2a \\<Longrightarrow> evaluate_list env s es r2b \\<Longrightarrow> r2a = r2b\"\n  \"evaluate env s e r3a \\<Longrightarrow> evaluate env s e r3b \\<Longrightarrow> r3a = r3b\""], "translations": [["", "lemma unclocked_sound:\n  \"evaluate_list v s es bv \\<Longrightarrow> BigStep.evaluate_list False v s es bv\"\n  \"evaluate v s e bv' \\<Longrightarrow> BigStep.evaluate False v s e bv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Big_Step_Unclocked.evaluate_list v s es bv \\<Longrightarrow>\n     BigStep.evaluate_list False v s es bv) &&&\n    (Big_Step_Unclocked.evaluate v s e bv' \\<Longrightarrow>\n     BigStep.evaluate False v s e bv')", "proof (induction rule: evaluate_list_evaluate.inducts)"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>e' env' s1 s2 env e pes v1 bv.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rval (e', env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        BigStep.evaluate False\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes) bv\n 6. \\<And>err s1 s2 env e pes v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rerr err\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr err)\n 7. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 8. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 9. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 10. \\<And>env cn es err s s'.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n         BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n        \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                           (s', Rerr err)\nA total of 38 subgoals...", "case (handle2 e' env' s1 s2 env e pes v1 bv)"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1))\n  match_result env s2 v1 pes v1 = Rval (e', env')\n  Big_Step_Unclocked.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1))\n  BigStep.evaluate False\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n\ngoal (38 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>e' env' s1 s2 env e pes v1 bv.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rval (e', env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        BigStep.evaluate False\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes) bv\n 6. \\<And>err s1 s2 env e pes v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rerr err\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr err)\n 7. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 8. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 9. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 10. \\<And>env cn es err s s'.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n         BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n        \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                           (s', Rerr err)\nA total of 38 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. BigStep.evaluate False env s1 (Handle e pes) bv", "apply (rule BigStep.handle2, intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BigStep.evaluate False env s1 e (?s2.0, Rerr (Rraise ?v1.0))\n 2. evaluate_match False env ?s2.0 ?v1.0 pes ?v1.0 bv", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match False env s2 v1 pes v1 bv", "apply (rule match_result_sound_val)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rval (?e4, ?env'4)\n 2. BigStep.evaluate False\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env'4) (sem_env.v env))\n       env)\n     s2 ?e4 bv", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  BigStep.evaluate False env s1 (Handle e pes) bv\n\ngoal (37 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>err s1 s2 env e pes v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rerr err\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr err)\n 6. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 7. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 8. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 10. \\<And>env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rval v1)\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>err s1 s2 env e pes v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rerr err\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr err)\n 6. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 7. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 8. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 10. \\<And>env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rval v1)\nA total of 37 subgoals...", "case (handle2b err s1 s2 env e pes v1)"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1))\n  match_result env s2 v1 pes v1 = Rerr err\n  BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1))\n\ngoal (37 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>err s1 s2 env e pes v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rraise v1));\n        match_result env s2 v1 pes v1 = Rerr err\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr err)\n 6. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 7. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 8. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 10. \\<And>env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rval v1)\nA total of 37 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. BigStep.evaluate False env s1 (Handle e pes) (s2, Rerr err)", "apply (rule BigStep.handle2, intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BigStep.evaluate False env s1 e (?s2.0, Rerr (Rraise ?v1.0))\n 2. evaluate_match False env ?s2.0 ?v1.0 pes ?v1.0 (s2, Rerr err)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match False env s2 v1 pes v1 (s2, Rerr err)", "apply (rule match_result_sound_err)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result env s2 v1 pes v1 = Rerr err", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  BigStep.evaluate False env s1 (Handle e pes) (s2, Rerr err)\n\ngoal (36 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 36 subgoals...", "case (mat1 e' env' env e pes v1 bv s1 s2)"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  BigStep.evaluate False env s1 e (s2, Rval v1)\n  BigStep.evaluate False\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n\ngoal (36 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 36 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. BigStep.evaluate False env s1 (Mat e pes) bv", "apply (rule BigStep.mat1, fold Bindv_def, intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BigStep.evaluate False env s1 e (?s2.0, Rval ?v1.0)\n 2. evaluate_match False env ?s2.0 ?v1.0 pes Bindv bv", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match False env s2 v1 pes Bindv bv", "apply (rule match_result_sound_val)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes Bindv = Rval (?e4, ?env'4)\n 2. BigStep.evaluate False\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env'4) (sem_env.v env))\n       env)\n     s2 ?e4 bv", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  BigStep.evaluate False env s1 (Mat e pes) bv\n\ngoal (35 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 35 subgoals...", "case (mat1b err env e pes v1 s1 s2)"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rerr err\n  BigStep.evaluate False env s1 e (s2, Rval v1)\n\ngoal (35 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 35 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. BigStep.evaluate False env s1 (Mat e pes) (s2, Rerr err)", "apply (rule BigStep.mat1, fold Bindv_def, intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BigStep.evaluate False env s1 e (?s2.0, Rval ?v1.0)\n 2. evaluate_match False env ?s2.0 ?v1.0 pes Bindv (s2, Rerr err)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match False env s2 v1 pes Bindv (s2, Rerr err)", "apply (rule match_result_sound_err)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result env s2 v1 pes Bindv = Rerr err", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  BigStep.evaluate False env s1 (Mat e pes) (s2, Rerr err)\n\ngoal (34 subgoals):\n 1. \\<And>env l s. BigStep.evaluate False env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>env e s1 s2 v1.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>env e s1 s2 err.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        BigStep.evaluate False s1 env e (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>s1 s2 env e v1 pes.\n       \\<lbrakk>Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        BigStep.evaluate False s1 env e (s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>s1 s2 env e pes a.\n       \\<lbrakk>Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        BigStep.evaluate False env s1 e (s2, Rerr (Rabort a))\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v1;\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rval vs);\n        BigStep.evaluate_list False env s (rev es) (s', Rval vs)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       BigStep.evaluate False env s (Con cn es)\n        (s, Rerr (Rabort Rtype_error))\n 8. \\<And>env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked.evaluate_list env s (rev es) (s', Rerr err);\n        BigStep.evaluate_list False env s (rev es) (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> BigStep.evaluate False env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>env n v1 s.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       BigStep.evaluate False env s (Var n) (s, Rval v1)\n 10. \\<And>env n s.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        BigStep.evaluate False env s (Var n) (s, Rerr (Rabort Rtype_error))\nA total of 34 subgoals...", "qed (fastforce simp: all_distinct_alt_def[symmetric] intro: evaluate_match_evaluate_list_evaluate.intros)+"], ["", "context begin"], ["", "private"], ["", "lemma unclocked_complete0:\n  \"BigStep.evaluate_match ck env s v0 pes err_v (s', bv) \\<Longrightarrow> \\<not> ck \\<Longrightarrow> (\n    case bv of\n        Rval v \\<Rightarrow>\n          \\<exists>e env'.\n            match_result env s v0 pes err_v = Rval (e, env') \\<and>\n            evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rval v)\n      | Rerr err \\<Rightarrow>\n          (match_result env s v0 pes err_v = Rerr err) \\<or>\n          (\\<exists>e env'.\n            match_result env s v0 pes err_v = Rval (e, env') \\<and>\n            evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rerr err)))\"\n  \"BigStep.evaluate_list ck v s es (s', bv0) \\<Longrightarrow> \\<not> ck \\<Longrightarrow> evaluate_list v s es (s', bv0)\"\n  \"BigStep.evaluate ck v s e (s', bv) \\<Longrightarrow> \\<not> ck \\<Longrightarrow> evaluate v s e (s', bv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>evaluate_match ck env s v0 pes err_v (s', bv);\n      \\<not> ck\\<rbrakk>\n     \\<Longrightarrow> case bv of\n                       Rval va \\<Rightarrow>\n                         \\<exists>e env'.\n                            match_result env s v0 pes err_v =\n                            Rval (e, env') \\<and>\n                            Big_Step_Unclocked.evaluate\n                             (update_v\n                               (\\<lambda>_.\n                                   nsAppend (alist_to_ns env')\n                                    (sem_env.v env))\n                               env)\n                             s e (s', Rval va)\n                       | Rerr err \\<Rightarrow>\n                           match_result env s v0 pes err_v = Rerr err \\<or>\n                           (\\<exists>e env'.\n                               match_result env s v0 pes err_v =\n                               Rval (e, env') \\<and>\n                               Big_Step_Unclocked.evaluate\n                                (update_v\n                                  (\\<lambda>_.\nnsAppend (alist_to_ns env') (sem_env.v env))\n                                  env)\n                                s e (s', Rerr err))) &&&\n    (\\<lbrakk>BigStep.evaluate_list ck v s es (s', bv0); \\<not> ck\\<rbrakk>\n     \\<Longrightarrow> Big_Step_Unclocked.evaluate_list v s es\n                        (s', bv0)) &&&\n    (\\<lbrakk>BigStep.evaluate ck v s e (s', bv); \\<not> ck\\<rbrakk>\n     \\<Longrightarrow> Big_Step_Unclocked.evaluate v s e (s', bv))", "proof (induction rule: evaluate_induct)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes v1 a b.\n       \\<lbrakk>(BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<not> ck \\<longrightarrow>\n                  Big_Step_Unclocked.evaluate env s1 e\n                   (s2, Rerr (Rraise v1)))) \\<and>\n                evaluate_match ck env s2 v1 pes v1 (a, b) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 (case b of\n                  Rval va \\<Rightarrow>\n                    \\<exists>e env'.\n                       match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n                       Big_Step_Unclocked.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        s2 e (a, Rval va)\n                  | Rerr err \\<Rightarrow>\n                      match_result env s2 v1 pes v1 = Rerr err \\<or>\n                      (\\<exists>e env'.\n                          match_result env s2 v1 pes v1 =\n                          Rval (e, env') \\<and>\n                          Big_Step_Unclocked.evaluate\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           s2 e (a, Rerr err))));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (a, b)\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 7. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 8. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 9. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 10. \\<And>ck env n v1 s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rval v1)\nA total of 42 subgoals...", "case (handle2 ck s1 s2 env e pes v1 s3 bv)"], ["proof (state)\nthis:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (42 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes v1 a b.\n       \\<lbrakk>(BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n                 (\\<not> ck \\<longrightarrow>\n                  Big_Step_Unclocked.evaluate env s1 e\n                   (s2, Rerr (Rraise v1)))) \\<and>\n                evaluate_match ck env s2 v1 pes v1 (a, b) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 (case b of\n                  Rval va \\<Rightarrow>\n                    \\<exists>e env'.\n                       match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n                       Big_Step_Unclocked.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        s2 e (a, Rval va)\n                  | Rerr err \\<Rightarrow>\n                      match_result env s2 v1 pes v1 = Rerr err \\<or>\n                      (\\<exists>e env'.\n                          match_result env s2 v1 pes v1 =\n                          Rval (e, env') \\<and>\n                          Big_Step_Unclocked.evaluate\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           s2 e (a, Rerr err))));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (a, b)\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 7. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 8. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 9. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 10. \\<And>ck env n v1 s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rval v1)\nA total of 42 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "proof (cases bv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       bv = Rval x1 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "case (Rval v)"], ["proof (state)\nthis:\n  bv = Rval v\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       bv = Rval x1 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "with handle2"], ["proof (chain)\npicking this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n  bv = Rval v", "obtain e env' where\n        \"match_result env s2 v1 pes v1 = Rval (e, env')\"\n        \"evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s2 e (s3, Rval v)\""], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n  bv = Rval v\n\ngoal (1 subgoal):\n 1. (\\<And>e env'.\n        \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match_result env s2 v1 pes v1 = Rval (e, env')\n  Big_Step_Unclocked.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e (s3, Rval v)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       bv = Rval x1 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)\n 2. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, Rval v)", "apply (rule evaluate_list_evaluate.handle2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 ea__ (?s2.0, Rerr (Rraise ?v1.0))\n 2. match_result env ?s2.0 ?v1.0 pes ?v1.0 = Rval (?e', ?env')\n 3. Big_Step_Unclocked.evaluate\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env') (sem_env.v env))\n       env)\n     ?s2.0 ?e' (s3, Rval v)", "using handle2"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 ea__ (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 ea__ (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (3 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 ea__ (?s2.0, Rerr (Rraise ?v1.0))\n 2. match_result env ?s2.0 ?v1.0 pes ?v1.0 = Rval (?e', ?env')\n 3. Big_Step_Unclocked.evaluate\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env') (sem_env.v env))\n       env)\n     ?s2.0 ?e' (s3, Rval v)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rval (?e', ?env')\n 2. Big_Step_Unclocked.evaluate\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env') (sem_env.v env))\n       env)\n     s2 ?e' (s3, Rval v)", "by fact+"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "case (Rerr err)"], ["proof (state)\nthis:\n  bv = Rerr err\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "with handle2"], ["proof (chain)\npicking this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n  bv = Rerr err", "consider\n        (match_err) \"match_result env s2 v1 pes v1 = Rerr err\" |\n        (eval_err) e env' where\n          \"match_result env s2 v1 pes v1 = Rval (e, env')\"\n          \"evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s2 e (s3, Rerr err)\""], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n  bv = Rerr err\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n             thesis;\n     \\<And>e env'.\n        \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rerr err)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n           ?thesis;\n   \\<And>e env'.\n      \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n       Big_Step_Unclocked.evaluate\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s2 e (s3, Rerr err)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       bv = Rerr x2 \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n           ?thesis;\n   \\<And>e env'.\n      \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n       Big_Step_Unclocked.evaluate\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s2 e (s3, Rerr err)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n           ?thesis;\n   \\<And>e env'.\n      \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n       Big_Step_Unclocked.evaluate\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s2 e (s3, Rerr err)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "case match_err"], ["proof (state)\nthis:\n  match_result env s2 v1 pes v1 = Rerr err\n\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "then"], ["proof (chain)\npicking this:\n  match_result env s2 v1 pes v1 = Rerr err", "have \"evaluate_match ck env s2 v1 pes v1 (s2, Rerr err)\""], ["proof (prove)\nusing this:\n  match_result env s2 v1 pes v1 = Rerr err\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s2 v1 pes v1 (s2, Rerr err)", "by (metis match_result_sound_err)"], ["proof (state)\nthis:\n  evaluate_match ck env s2 v1 pes v1 (s2, Rerr err)\n\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "moreover"], ["proof (state)\nthis:\n  evaluate_match ck env s2 v1 pes v1 (s2, Rerr err)\n\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "have \"evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)", "using handle2"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, Rerr err) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case Rerr err of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)", "by blast"], ["proof (state)\nthis:\n  evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)\n\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "ultimately"], ["proof (chain)\npicking this:\n  evaluate_match ck env s2 v1 pes v1 (s2, Rerr err)\n  evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)", "have \"s2 = s3\""], ["proof (prove)\nusing this:\n  evaluate_match ck env s2 v1 pes v1 (s2, Rerr err)\n  evaluate_match ck env s2 v1 pes v1 (s3, Rerr err)\n\ngoal (1 subgoal):\n 1. s2 = s3", "by (metis evaluate_determ fst_conv)"], ["proof (state)\nthis:\n  s2 = s3\n\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rerr err \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n 2. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, Rerr err)", "apply (rule evaluate_list_evaluate.handle2b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 e (s3, Rerr (Rraise ?v1.0))\n 2. match_result env s3 ?v1.0 pes ?v1.0 = Rerr err", "using handle2"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (2 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 e (s3, Rerr (Rraise ?v1.0))\n 2. match_result env s3 ?v1.0 pes ?v1.0 = Rerr err", "unfolding \\<open>s2 = _\\<close>"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s3, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s3, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s3 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s3 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s3 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s3 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s3 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s3 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (2 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 e (s3, Rerr (Rraise ?v1.0))\n 2. match_result env s3 ?v1.0 pes ?v1.0 = Rerr err", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result env s3 v1 pes v1 = Rerr err", "using match_err"], ["proof (prove)\nusing this:\n  match_result env s2 v1 pes v1 = Rerr err\n\ngoal (1 subgoal):\n 1. match_result env s3 v1 pes v1 = Rerr err", "unfolding \\<open>s2 = _\\<close>"], ["proof (prove)\nusing this:\n  match_result env s3 v1 pes v1 = Rerr err\n\ngoal (1 subgoal):\n 1. match_result env s3 v1 pes v1 = Rerr err", "."], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n\ngoal (1 subgoal):\n 1. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s3, bv)", "case eval_err"], ["proof (state)\nthis:\n  match_result env s2 v1 pes v1 = Rval (e, env')\n  Big_Step_Unclocked.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e (s3, Rerr err)\n\ngoal (1 subgoal):\n 1. \\<And>e env'.\n       \\<lbrakk>match_result env s2 v1 pes v1 = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1\n                          (Handle ea__ pes) (s3, bv)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, Rerr err)", "apply (rule evaluate_list_evaluate.handle2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 ea__ (?s2.0, Rerr (Rraise ?v1.0))\n 2. match_result env ?s2.0 ?v1.0 pes ?v1.0 = Rval (?e', ?env')\n 3. Big_Step_Unclocked.evaluate\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env') (sem_env.v env))\n       env)\n     ?s2.0 ?e' (s3, Rerr err)", "using handle2"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 ea__ (s2, Rerr (Rraise v1)) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 ea__ (s2, Rerr (Rraise v1)))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 (s3, bv) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes v1 = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes v1 = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (3 subgoals):\n 1. Big_Step_Unclocked.evaluate env s1 ea__ (?s2.0, Rerr (Rraise ?v1.0))\n 2. match_result env ?s2.0 ?v1.0 pes ?v1.0 = Rval (?e', ?env')\n 3. Big_Step_Unclocked.evaluate\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env') (sem_env.v env))\n       env)\n     ?s2.0 ?e' (s3, Rerr err)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. match_result env s2 v1 pes v1 = Rval (?e', ?env')\n 2. Big_Step_Unclocked.evaluate\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns ?env') (sem_env.v env))\n       env)\n     s2 ?e' (s3, Rerr err)", "by fact+"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 (Handle ea__ pes) (s3, bv)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 (Handle e pes) (s3, bv)\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 41 subgoals...", "case (mat1 ck env e pes v1 s3 v' s1 s2)"], ["proof (state)\nthis:\n  (BigStep.evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s3, v') \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case v' of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes\n          (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n         Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n        Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes\n             (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n            Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 41 subgoals...", "then"], ["proof (chain)\npicking this:\n  (BigStep.evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s3, v') \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case v' of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes\n          (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n         Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n        Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes\n             (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n            Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck", "show ?case"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s3, v') \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case v' of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes\n          (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n         Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n        Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes\n             (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n            Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Mat e pes) (s3, v')", "(* this is the same proof as above, but with less Isar and more apply *)"], ["proof (prove)\nusing this:\n  (BigStep.evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<not> ck \\<longrightarrow>\n    Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s3, v') \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case v' of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s2 v1 pes\n          (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n         Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s2 e (s3, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n        Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s2 v1 pes\n             (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) =\n            Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s2 e (s3, Rerr err))))\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate env s1 (Mat e pes) (s3, v')", "apply (auto split: result.splits simp: Bindv_def[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 e env'.\n       \\<lbrakk>\\<not> ck; v' = Rval x1;\n        BigStep.evaluate False env s1 e (s2, Rval v1);\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n        evaluate_match False env s2 v1 pes Bindv (s3, Rval x1);\n        match_result env s2 v1 pes Bindv = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rval x1)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                          (s3, Rval x1)\n 2. \\<And>x2.\n       \\<lbrakk>\\<not> ck; v' = Rerr x2;\n        BigStep.evaluate False env s1 e (s2, Rval v1);\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n        evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2);\n        match_result env s2 v1 pes Bindv = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                          (s3, Rerr x2)\n 3. \\<And>x2 e env'.\n       \\<lbrakk>\\<not> ck; v' = Rerr x2;\n        BigStep.evaluate False env s1 e (s2, Rval v1);\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n        evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2);\n        match_result env s2 v1 pes Bindv = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr x2)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                          (s3, Rerr x2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ck; v' = Rval x1_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rval x1_);\n     match_result env s2 v1 pes Bindv = Rval (e_, env'_);\n     Big_Step_Unclocked.evaluate\n      (update_v (\\<lambda>_. nsAppend (alist_to_ns env'_) (sem_env.v env))\n        env)\n      s2 e_ (s3, Rval x1_)\\<rbrakk>\n    \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                       (s3, Rval x1_)", "by (rule evaluate_list_evaluate.mat1) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<not> ck; v' = Rerr x2;\n        BigStep.evaluate False env s1 e (s2, Rval v1);\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n        evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2);\n        match_result env s2 v1 pes Bindv = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                          (s3, Rerr x2)\n 2. \\<And>x2 e env'.\n       \\<lbrakk>\\<not> ck; v' = Rerr x2;\n        BigStep.evaluate False env s1 e (s2, Rval v1);\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n        evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2);\n        match_result env s2 v1 pes Bindv = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr x2)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                          (s3, Rerr x2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_\\<rbrakk>\n    \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                       (s3, Rerr x2_)", "apply (frule match_result_sound_err)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                       (s3, Rerr x2_)", "apply (subgoal_tac \"s2 = s3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_); s2 = s3\\<rbrakk>\n    \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                       (s3, Rerr x2_)\n 2. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "apply (rule evaluate_list_evaluate.mat1b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_); s2 = s3\\<rbrakk>\n    \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 e (s3, Rval ?v1.3)\n 2. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_); s2 = s3\\<rbrakk>\n    \\<Longrightarrow> match_result env s3 ?v1.3 pes Bindv = Rerr x2_\n 3. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_); s2 = s3\\<rbrakk>\n    \\<Longrightarrow> match_result env s3 v1 pes Bindv = Rerr x2_\n 2. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "apply (drule evaluate_determ)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_match False env s2 v1 pes Bindv ?r1b14\n 2. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match ?ck env s2 v1 pes Bindv (s2, Rerr x2_);\n     (s3, Rerr x2_) = ?r1b14\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     match_result env s2 v1 pes Bindv = Rerr x2_;\n     evaluate_match False env s2 v1 pes Bindv (s2, Rerr x2_);\n     (s3, Rerr x2_) = (s2, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 e env'.\n       \\<lbrakk>\\<not> ck; v' = Rerr x2;\n        BigStep.evaluate False env s1 e (s2, Rval v1);\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n        evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2);\n        match_result env s2 v1 pes Bindv = Rval (e, env');\n        Big_Step_Unclocked.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e (s3, Rerr x2)\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                          (s3, Rerr x2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ck; v' = Rerr x2_;\n     BigStep.evaluate False env s1 e (s2, Rval v1);\n     Big_Step_Unclocked.evaluate env s1 e (s2, Rval v1);\n     evaluate_match False env s2 v1 pes Bindv (s3, Rerr x2_);\n     match_result env s2 v1 pes Bindv = Rval (e_, env'_);\n     Big_Step_Unclocked.evaluate\n      (update_v (\\<lambda>_. nsAppend (alist_to_ns env'_) (sem_env.v env))\n        env)\n      s2 e_ (s3, Rerr x2_)\\<rbrakk>\n    \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Mat e pes)\n                       (s3, Rerr x2_)", "by (rule evaluate_list_evaluate.mat1) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Big_Step_Unclocked.evaluate env s1 (Mat e pes) (s3, v')\n\ngoal (40 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 40 subgoals...", "case (mat_cons1 ck env env' v1 p pes e a b err_v s)"], ["proof (state)\nthis:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n  BigStep.evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e (a, b) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   Big_Step_Unclocked.evaluate\n    (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n    s e (a, b))\n  \\<not> ck\n\ngoal (40 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 40 subgoals...", "then"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n  BigStep.evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e (a, b) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   Big_Step_Unclocked.evaluate\n    (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n    s e (a, b))\n  \\<not> ck", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = Match env' \\<and>\n  BigStep.evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e (a, b) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   Big_Step_Unclocked.evaluate\n    (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n    s e (a, b))\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. case b of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v1 ((p, e) # pes) err_v = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (a, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v1 ((p, e) # pes) err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v1 ((p, e) # pes) err_v =\n            Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (a, Rerr err))", "by (auto split: result.splits)"], ["proof (state)\nthis:\n  case b of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v1 ((p, e) # pes) err_v = Rval (e, env') \\<and>\n       Big_Step_Unclocked.evaluate\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (a, Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v1 ((p, e) # pes) err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v1 ((p, e) # pes) err_v = Rval (e, env') \\<and>\n          Big_Step_Unclocked.evaluate\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (a, Rerr err))\n\ngoal (39 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 39 subgoals...", "case (mat_cons2 ck env v1 p e pes a b s err_v)"], ["proof (state)\nthis:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n  evaluate_match ck env s v1 pes err_v (a, b) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case b of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v1 pes err_v = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (a, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v1 pes err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v1 pes err_v = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (a, Rerr err))))\n  \\<not> ck\n\ngoal (39 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 39 subgoals...", "then"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n  evaluate_match ck env s v1 pes err_v (a, b) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case b of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v1 pes err_v = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (a, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v1 pes err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v1 pes err_v = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (a, Rerr err))))\n  \\<not> ck", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v1 [] = No_match \\<and>\n  evaluate_match ck env s v1 pes err_v (a, b) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   (case b of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v1 pes err_v = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (a, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v1 pes err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v1 pes err_v = Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (a, Rerr err))))\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. case b of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v1 ((p, e) # pes) err_v = Rval (e, env') \\<and>\n         Big_Step_Unclocked.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (a, Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v1 ((p, e) # pes) err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v1 ((p, e) # pes) err_v =\n            Rval (e, env') \\<and>\n            Big_Step_Unclocked.evaluate\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (a, Rerr err))", "by (auto split: result.splits)"], ["proof (state)\nthis:\n  case b of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v1 ((p, e) # pes) err_v = Rval (e, env') \\<and>\n       Big_Step_Unclocked.evaluate\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (a, Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v1 ((p, e) # pes) err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v1 ((p, e) # pes) err_v = Rval (e, env') \\<and>\n          Big_Step_Unclocked.evaluate\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (a, Rerr err))\n\ngoal (38 subgoals):\n 1. \\<And>ck env l s.\n       \\<not> ck \\<Longrightarrow>\n       Big_Step_Unclocked.evaluate env s (Lit l) (s, Rval (Litv l))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr (Rraise v1))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rerr err);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Raise e)\n                          (s2, Rerr err)\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>BigStep.evaluate ck s1 env e (s2, Rval v1);\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate s1 env e (s2, Rval v1);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate s1 env (Handle e pes)\n                          (s2, Rval v1)\n 5. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>BigStep.evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck \\<Longrightarrow>\n        Big_Step_Unclocked.evaluate env s1 e (s2, Rerr (Rabort a));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s1 (Handle e pes)\n                          (s2, Rerr (Rabort a))\n 6. \\<And>ck env cn es vs s s' v1.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                build_conv (c env) cn (rev vs) = Some v1 \\<and>\n                BigStep.evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rval vs));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rval v1)\n 7. \\<And>ck env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s, Rerr (Rabort Rtype_error))\n 8. \\<And>ck env cn es err s s'.\n       \\<lbrakk>do_con_check (c env) cn (length es) \\<and>\n                BigStep.evaluate_list ck env s (rev es)\n                 (s', Rerr err) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 Big_Step_Unclocked.evaluate_list env s (rev es)\n                  (s', Rerr err));\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Con cn es)\n                          (s', Rerr err)\n 9. \\<And>ck env n v1 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v1; \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                          (s, Rval v1)\n 10. \\<And>ck env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; \\<not> ck\\<rbrakk>\n        \\<Longrightarrow> Big_Step_Unclocked.evaluate env s (Var n)\n                           (s, Rerr (Rabort Rtype_error))\nA total of 38 subgoals...", "qed (fastforce simp: all_distinct_alt_def intro: evaluate_list_evaluate.intros)+"], ["", "lemma unclocked_complete:\n  \"BigStep.evaluate_list False v s es bv' \\<Longrightarrow> evaluate_list v s es bv'\"\n  \"BigStep.evaluate False v s e bv \\<Longrightarrow> evaluate v s e bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BigStep.evaluate_list False v s es bv' \\<Longrightarrow>\n     Big_Step_Unclocked.evaluate_list v s es bv') &&&\n    (BigStep.evaluate False v s e bv \\<Longrightarrow>\n     Big_Step_Unclocked.evaluate v s e bv)", "apply (cases bv'; metis unclocked_complete0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. BigStep.evaluate False v s e bv \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate v s e bv", "apply (cases bv; metis unclocked_complete0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma unclocked_eq:\n  \"evaluate_list = BigStep.evaluate_list False\"\n  \"evaluate = BigStep.evaluate False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked.evaluate_list = BigStep.evaluate_list False &&&\n    Big_Step_Unclocked.evaluate = BigStep.evaluate False", "by (auto intro: unclocked_sound unclocked_complete intro!: ext)"], ["", "lemma unclocked_determ:\n  \"evaluate_list env s es r2a \\<Longrightarrow> evaluate_list env s es r2b \\<Longrightarrow> r2a = r2b\"\n  \"evaluate env s e r3a \\<Longrightarrow> evaluate env s e r3b \\<Longrightarrow> r3a = r3b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Big_Step_Unclocked.evaluate_list env s es r2a;\n      Big_Step_Unclocked.evaluate_list env s es r2b\\<rbrakk>\n     \\<Longrightarrow> r2a = r2b) &&&\n    (\\<lbrakk>Big_Step_Unclocked.evaluate env s e r3a;\n      Big_Step_Unclocked.evaluate env s e r3b\\<rbrakk>\n     \\<Longrightarrow> r3a = r3b)", "by (metis unclocked_eq evaluate_determ)+"], ["", "end"]]}