{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Big_Step_Unclocked_Single.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma evaluate_list_mono_strong[intro?]:\n  assumes \"evaluate_list R s es r\"\n  assumes \"\\<And>s e r. e \\<in> set es \\<Longrightarrow> R s e r \\<Longrightarrow> Q s e r\"\n  shows \"evaluate_list Q s es r\"", "lemma evaluate_list_mono[mono]:\n  assumes \"R \\<le> Q\"\n  shows \"evaluate_list R \\<le> evaluate_list Q\"", "lemma unclocked_single_list_sound:\n  \"evaluate_list (Big_Step_Unclocked.evaluate v) s es bv \\<Longrightarrow> Big_Step_Unclocked.evaluate_list v s es bv\"", "lemma unclocked_single_sound:\n  \"evaluate v s e bv \\<Longrightarrow> Big_Step_Unclocked.evaluate v s e bv\"", "lemma unclocked_single_complete:\n  \"Big_Step_Unclocked.evaluate_list v s es bv1 \\<Longrightarrow> evaluate_list (evaluate v) s es bv1\"\n  \"Big_Step_Unclocked.evaluate v s e bv2 \\<Longrightarrow> evaluate v s e bv2\"", "lemma unclocked_single_fun_eq:\n  \"((\\<exists>k. Evaluate_Single.evaluate env (s \\<lparr> clock:= k \\<rparr>) e = (s', r)) \\<and> r \\<noteq>  Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock s')) =\n    evaluate env s e (s',r)\""], "translations": [["", "lemma evaluate_list_mono_strong[intro?]:\n  assumes \"evaluate_list R s es r\"\n  assumes \"\\<And>s e r. e \\<in> set es \\<Longrightarrow> R s e r \\<Longrightarrow> Q s e r\"\n  shows \"evaluate_list Q s es r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate_list Q s es r", "using assms"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate_list R s es r\n  \\<lbrakk>?e \\<in> set es; R ?s ?e ?r\\<rbrakk> \\<Longrightarrow> Q ?s ?e ?r\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate_list Q s es r", "by (induction; fastforce intro: evaluate_list.intros)"], ["", "lemma evaluate_list_mono[mono]:\n  assumes \"R \\<le> Q\"\n  shows \"evaluate_list R \\<le> evaluate_list Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate_list R\n    \\<le> Big_Step_Unclocked_Single.evaluate_list Q", "using assms"], ["proof (prove)\nusing this:\n  R \\<le> Q\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate_list R\n    \\<le> Big_Step_Unclocked_Single.evaluate_list Q", "unfolding le_fun_def le_bool_def"], ["proof (prove)\nusing this:\n  \\<forall>x xa xb. R x xa xb \\<longrightarrow> Q x xa xb\n\ngoal (1 subgoal):\n 1. \\<forall>x xa xb.\n       Big_Step_Unclocked_Single.evaluate_list R x xa xb \\<longrightarrow>\n       Big_Step_Unclocked_Single.evaluate_list Q x xa xb", "by (metis evaluate_list_mono_strong)"], ["", "inductive evaluate :: \"v sem_env \\<Rightarrow> 'ffi state \\<Rightarrow> exp \\<Rightarrow> 'ffi state*(v,v) result \\<Rightarrow> bool\" where\n\nlit:\n  \"evaluate env s (Lit l) (s, Rval (Litv l))\" |\n\nraise1:\n  \"evaluate env s1 e (s2, Rval v) \\<Longrightarrow>\n   evaluate env s1 (Raise e) (s2, Rerr (Rraise v))\" |\n\nraise2:\n  \"evaluate env s1 e (s2, Rerr err) \\<Longrightarrow>\n   evaluate env s1 (Raise e) (s2, Rerr err)\" |\n\nhandle1:\n  \"evaluate env s1 e (s2, Rval v) \\<Longrightarrow>\n   evaluate env s1 (Handle e pes) (s2, Rval v)\" |\n\nhandle2:\n  \"evaluate env s1 e (s2, Rerr (Rraise v)) \\<Longrightarrow>\n   match_result env s2 v pes v = Rval (e', env') \\<Longrightarrow>\n   evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s2 e' bv \\<Longrightarrow>\n   evaluate env s1 (Handle e pes) bv\" |\n\nhandle2b:\n  \"evaluate env s1 e (s2, Rerr (Rraise v)) \\<Longrightarrow>\n   match_result env s2 v pes v = Rerr err \\<Longrightarrow>\n   evaluate env s1 (Handle e pes) (s2, Rerr err)\" |\n\nhandle3:\n  \"evaluate env s1 e (s2, Rerr (Rabort a)) \\<Longrightarrow>\n   evaluate env s1 (Handle e pes) (s2, Rerr (Rabort a))\" |\n\ncon1:\n  \"do_con_check (c env) cn (length es) \\<Longrightarrow>\n   build_conv (c env) cn (rev vs) = Some v \\<Longrightarrow>\n   evaluate_list (evaluate env) s1 (rev es) (s2, Rval vs) \\<Longrightarrow>\n   evaluate env s1 (Con cn es) (s2, Rval v)\" |\n\ncon2:\n  \"\\<not>(do_con_check (c env) cn (length es)) \\<Longrightarrow>\n   evaluate env s (Con cn es) (s, Rerr (Rabort Rtype_error))\" |\n\ncon3:\n  \"do_con_check (c env) cn (length es) \\<Longrightarrow>\n   evaluate_list (evaluate env) s1 (rev es) (s2, Rerr err) \\<Longrightarrow>\n   evaluate env s1 (Con cn es) (s2, Rerr err)\" |\n\nvar1:\n  \"nsLookup (sem_env.v env) n = Some v \\<Longrightarrow>\n   evaluate env s (Var n) (s, Rval v)\" |\n\nvar2:\n  \"nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n   evaluate env s (Var n) (s, Rerr (Rabort Rtype_error))\" |\n\nfn:\n  \"evaluate env s (Fun n e) (s, Rval (Closure env n e))\" |\n\napp1:\n  \"evaluate_list (evaluate env) s1 (rev es) (s2, Rval vs) \\<Longrightarrow>\n   do_opapp (rev vs) = Some (env', e) \\<Longrightarrow>\n   evaluate env' s2 e bv \\<Longrightarrow>\n   evaluate env s1 (App Opapp es) bv\" |\n\napp3:\n  \"evaluate_list (evaluate env) s1 (rev es) (s2, Rval vs) \\<Longrightarrow>\n   (do_opapp (rev vs) = None) \\<Longrightarrow>\n   evaluate env s1 (App Opapp es) (s2, Rerr (Rabort Rtype_error))\" |\n\napp4:\n  \"evaluate_list (evaluate env) s1 (rev es) (s2, Rval vs) \\<Longrightarrow>\n   do_app (refs s2, ffi s2) op0 (rev vs) = Some ((refs',ffi'), res) \\<Longrightarrow>\n   op0 \\<noteq> Opapp \\<Longrightarrow>\n   evaluate env s1 (App op0 es) (s2 \\<lparr>refs:=refs',ffi:=ffi'\\<rparr>, res)\" |\n\napp5:\n  \"evaluate_list (evaluate env) s1 (rev es) (s2, Rval vs) \\<Longrightarrow>\n   do_app (refs s2, ffi s2) op0 (rev vs) = None \\<Longrightarrow>\n   op0 \\<noteq> Opapp \\<Longrightarrow>\n   evaluate env s1 (App op0 es) (s2, Rerr (Rabort Rtype_error))\" |\n\napp6:\n  \"evaluate_list (evaluate env) s1 (rev es) (s2, Rerr err) \\<Longrightarrow>\n   evaluate env s1 (App op0 es) (s2, Rerr err)\" |\n\nlog1:\n  \"evaluate env s1 e1 (s2, Rval v1) \\<Longrightarrow>\n   do_log op0 v1 e2 = Some (Exp e') \\<Longrightarrow>\n   evaluate env s2 e' bv \\<Longrightarrow>\n   evaluate env s1 (Log op0 e1 e2) bv \" |\n\nlog2:\n  \"evaluate env s1 e1 (s2, Rval v1) \\<Longrightarrow>\n   (do_log op0 v1 e2 = Some (Val bv)) \\<Longrightarrow>\n   evaluate env s1 (Log op0 e1 e2) (s2, Rval bv)\" |\n\nlog3:\n  \"evaluate env s1 e1 (s2, Rval v1) \\<Longrightarrow>\n   (do_log op0 v1 e2 = None) \\<Longrightarrow>\n   evaluate env s1 (Log op0 e1 e2) (s2, Rerr (Rabort Rtype_error))\" |\n\nlog4:\n  \"evaluate env s e1 (s', Rerr err) \\<Longrightarrow>\n   evaluate env s (Log op0 e1 e2) (s', Rerr err)\" |\n\nif1:\n  \"evaluate env s1 e1 (s2, Rval v1) \\<Longrightarrow>\n   do_if v1 e2 e3 = Some e' \\<Longrightarrow>\n   evaluate env s2 e' bv \\<Longrightarrow>\n   evaluate env s1 (If e1 e2 e3) bv \" |\n\nif2:\n  \"evaluate env s1 e1 (s2, Rval v1) \\<Longrightarrow>\n   (do_if v1 e2 e3 = None) \\<Longrightarrow>\n   evaluate env s1 (If e1 e2 e3) (s2, Rerr (Rabort Rtype_error))\" |\n\nif3:\n  \"evaluate env s e1 (s', Rerr err) \\<Longrightarrow>\n   evaluate env s (If e1 e2 e3) (s', Rerr err)\" |\n\nmat1:\n  \"evaluate env s1 e (s2, Rval v1) \\<Longrightarrow>\n   match_result env s2 v1 pes Bindv = Rval (e', env') \\<Longrightarrow>\n   evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s2 e' bv \\<Longrightarrow>\n   evaluate env s1 (Mat e pes) bv \" |\n\nmat1b:\n  \"evaluate env s1 e (s2, Rval v1) \\<Longrightarrow>\n   match_result env s2 v1 pes Bindv = Rerr err \\<Longrightarrow>\n   evaluate env s1 (Mat e pes) (s2, Rerr err)\" |\n\nmat2:\n  \"evaluate env s e (s', Rerr err) \\<Longrightarrow>\n   evaluate env s (Mat e pes) (s', Rerr err)\" |\n\nlet1:\n  \"evaluate env s1 e1 (s2, Rval v1) \\<Longrightarrow>\n   evaluate ( env \\<lparr> sem_env.v := (nsOptBind n v1(sem_env.v env)) \\<rparr>) s2 e2 bv \\<Longrightarrow>\n   evaluate env s1 (Let n e1 e2) bv \" |\n\nlet2:\n  \"evaluate env s e1 (s', Rerr err) \\<Longrightarrow>\n   evaluate env s (Let n e1 e2) (s', Rerr err)\" |\n\nletrec1:\n  \"distinct (List.map ( \\<lambda>x .\n     (case  x of (x,y,z) => x )) funs) \\<Longrightarrow>\n   evaluate ( env \\<lparr> sem_env.v := (build_rec_env funs env(sem_env.v env)) \\<rparr>) s e bv \\<Longrightarrow>\n   evaluate env s (Letrec funs e) bv \" |\n\nletrec2:\n  \"\\<not> (distinct (List.map ( \\<lambda>x .\n     (case  x of (x,y,z) => x )) funs)) \\<Longrightarrow>\n   evaluate env s (Letrec funs e) (s, Rerr (Rabort Rtype_error))\" |\n\ntannot:\n  \"evaluate env s e bv \\<Longrightarrow>\n   evaluate env s (Tannot e t0) bv \" |\n\nlocannot:\n  \"evaluate env s e bv \\<Longrightarrow>\n   evaluate env s (Lannot e l) bv \""], ["", "lemma unclocked_single_list_sound:\n  \"evaluate_list (Big_Step_Unclocked.evaluate v) s es bv \\<Longrightarrow> Big_Step_Unclocked.evaluate_list v s es bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate_list (Big_Step_Unclocked.evaluate v)\n     s es bv \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate_list v s es bv", "by (induction rule: evaluate_list.induct) (auto intro: evaluate_list_evaluate.intros)"], ["", "lemma unclocked_single_sound:\n  \"evaluate v s e bv \\<Longrightarrow> Big_Step_Unclocked.evaluate v s e bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate v s e bv \\<Longrightarrow>\n    Big_Step_Unclocked.evaluate v s e bv", "by (induction rule:evaluate.induct)\n   (auto simp del: do_app.simps intro: Big_Step_Unclocked.evaluate_list_evaluate.intros unclocked_single_list_sound\n         evaluate_list_mono_strong)"], ["", "lemma unclocked_single_complete:\n  \"Big_Step_Unclocked.evaluate_list v s es bv1 \\<Longrightarrow> evaluate_list (evaluate v) s es bv1\"\n  \"Big_Step_Unclocked.evaluate v s e bv2 \\<Longrightarrow> evaluate v s e bv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Big_Step_Unclocked.evaluate_list v s es bv1 \\<Longrightarrow>\n     Big_Step_Unclocked_Single.evaluate_list\n      (Big_Step_Unclocked_Single.evaluate v) s es bv1) &&&\n    (Big_Step_Unclocked.evaluate v s e bv2 \\<Longrightarrow>\n     Big_Step_Unclocked_Single.evaluate v s e bv2)", "by (induction rule: evaluate_list_evaluate.inducts)\n   (auto intro: evaluate.intros evaluate_list.intros)"], ["", "corollary unclocked_single_eq:\n  \"evaluate = Big_Step_Unclocked.evaluate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate = Big_Step_Unclocked.evaluate", "by (rule ext)+ (metis unclocked_single_sound unclocked_single_complete)"], ["", "corollary unclocked_single_eq':\n  \"evaluate = BigStep.evaluate False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate = BigStep.evaluate False", "by (simp add: unclocked_single_eq unclocked_eq)"], ["", "corollary unclocked_single_determ:\n  \"evaluate env s e r3a \\<Longrightarrow> evaluate env s e r3b \\<Longrightarrow> r3a = r3b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s e r3a;\n     Big_Step_Unclocked_Single.evaluate env s e r3b\\<rbrakk>\n    \\<Longrightarrow> r3a = r3b", "by (metis unclocked_single_eq unclocked_determ)"], ["", "lemma unclocked_single_fun_eq:\n  \"((\\<exists>k. Evaluate_Single.evaluate env (s \\<lparr> clock:= k \\<rparr>) e = (s', r)) \\<and> r \\<noteq>  Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock s')) =\n    evaluate env s e (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         Evaluate_Single.evaluate env (update_clock (\\<lambda>_. k) s) e =\n         (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    Big_Step_Unclocked_Single.evaluate env s e (s', r)", "apply (subst fun_evaluate_equiv')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         map_prod id (map_result hd id)\n          (fun_evaluate (update_clock (\\<lambda>_. k) s) env [e]) =\n         (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    Big_Step_Unclocked_Single.evaluate env s e (s', r)", "apply (subst unclocked_single_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         map_prod id (map_result hd id)\n          (fun_evaluate (update_clock (\\<lambda>_. k) s) env [e]) =\n         (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    Big_Step_Unclocked.evaluate env s e (s', r)", "apply (subst unclocked_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         map_prod id (map_result hd id)\n          (fun_evaluate (update_clock (\\<lambda>_. k) s) env [e]) =\n         (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    BigStep.evaluate False env s e (s', r)", "apply (subst fun.evaluate_iff_sym(1)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e\n          (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    BigStep.evaluate False env s e (s', r)", "apply (subst big_clocked_unclocked_equiv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e\n          (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    (\\<exists>c.\n        BigStep.evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (update_clock (\\<lambda>_. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s')", "using clocked_evaluate"], ["proof (prove)\nusing this:\n  (\\<exists>k.\n      BigStep.evaluate True ?env (update_clock (\\<lambda>_. k) ?s) ?e\n       (?s', ?r) \\<and>\n      ?r \\<noteq> Rerr (Rabort Rtimeout_error)) =\n  (\\<exists>k.\n      BigStep.evaluate True ?env (update_clock (\\<lambda>_. k) ?s) ?e\n       (update_clock (\\<lambda>_. 0) ?s', ?r) \\<and>\n      ?r \\<noteq> Rerr (Rabort Rtimeout_error))\n\ngoal (1 subgoal):\n 1. ((\\<exists>k.\n         BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e\n          (s', r)) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s') =\n    (\\<exists>c.\n        BigStep.evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (update_clock (\\<lambda>_. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s')", "by metis"], ["", "end"]]}