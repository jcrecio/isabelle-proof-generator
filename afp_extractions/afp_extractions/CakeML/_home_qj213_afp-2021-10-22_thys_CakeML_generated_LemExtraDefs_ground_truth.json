{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/generated/LemExtraDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma index_eq_some [simp]:\n   \"index l n = Some x \\<longleftrightarrow> (n < length l \\<and> (x = l ! n))\"", "lemma index_eq_none [simp]:\n   \"index l n = None \\<longleftrightarrow> length l \\<le> n\"", "lemma index_simps [simp]:\n   \"length l \\<le> n \\<Longrightarrow> index l n = None\"\n   \"n < length l \\<Longrightarrow> index l n = Some (l ! n)\"", "lemma length_find_indices :\n  \"length (find_indices P l) \\<le> length l\"", "lemma sorted_map_suc :\n  \"sorted l \\<Longrightarrow> sorted (map Suc l)\"", "lemma sorted_find_indices :\n  \"sorted (find_indices P xs)\"", "lemma find_indices_set [simp] :\n  \"set (find_indices P l) = {i. i < length l \\<and> P (l ! i)}\"", "lemma find_index_eq_some [simp] :\n  \"(find_index P xs = Some ii) \\<longleftrightarrow> (ii < length xs \\<and> P (xs ! ii) \\<and> (\\<forall>i' < ii. \\<not>(P (xs ! i'))))\"\n  (is \"?lhs = ?rhs\")", "lemma find_index_eq_none [simp] :\n  \"(find_index P xs = None) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. \\<not>(P x))\" (is \"?lhs = ?rhs\")", "lemma genlist_length [simp] :\n  \"length (genlist f n) = n\"", "lemma genlist_simps [simp]:\n   \"genlist f 0 = []\"\n   \"genlist f (Suc n) = genlist f n @ [f n]\"", "lemma delete_first_simps [simp] :\n   \"delete_first P [] = None\"\n   \"P x \\<Longrightarrow> delete_first P (x # xs) = Some xs\"\n   \"\\<not>(P x) \\<Longrightarrow> delete_first P (x # xs) = map_option (\\<lambda>xs'. x # xs') (delete_first P xs)\"", "lemmas delete_first_unroll = delete_first.simps(2)", "lemma delete_first_eq_none [simp] :\n  \"delete_first P l = None \\<longleftrightarrow> (\\<forall>x \\<in> set l. \\<not> (P x))\"", "lemma delete_first_eq_some :\n  \"delete_first P l = (Some l') \\<longleftrightarrow> (\\<exists>l1 x l2. P x \\<and> (\\<forall>x \\<in> set l1. \\<not>(P x)) \\<and> (l = l1 @ (x # l2)) \\<and> (l' = l1 @ l2))\"\n  (is \"?lhs l l' = (\\<exists>l1 x l2. ?rhs_body l1 x l2 l l')\")", "lemma perm_eval [code] :\n  \"perm [] l \\<longleftrightarrow> l = []\" (is ?g1)\n  \"perm (x # xs) l \\<longleftrightarrow> (case delete_first (\\<lambda>e. e = x) l of\n       None => False\n     | Some l' => perm xs l')\" (is ?g2)", "lemma sorted_by_lesseq [simp] :\n  \"sorted_by ((\\<le>) :: ('a::{linorder}) => 'a => bool) = sorted\"", "lemma sorted_by_cons_imp :\n  \"sorted_by cmp (x # xs) \\<Longrightarrow> sorted_by cmp xs\"", "lemma sorted_by_cons_trans :\n  assumes trans_cmp: \"transp cmp\"\n  shows \"sorted_by cmp (x # xs) = ((\\<forall>x' \\<in> set xs . cmp x x') \\<and> sorted_by cmp xs)\"", "lemma insert_sort_insert_by_length [simp] :\n  \"length (insert_sort_insert_by cmp e l) = Suc (length l)\"", "lemma insert_sort_insert_by_set [simp] :\n  \"set (insert_sort_insert_by cmp e l) = insert e (set l)\"", "lemma insert_sort_insert_by_perm :\n  \"(insert_sort_insert_by cmp e l) <~~> (e # l)\"", "lemma insert_sort_insert_by_sorted_by :\nassumes cmp_cases: \"\\<And>y. y \\<in> set l \\<Longrightarrow> \\<not> (cmp e y) \\<Longrightarrow> cmp y e\"\nassumes cmp_trans: \"transp cmp\"\nshows \"sorted_by cmp l \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e l)\"", "lemma insert_sort_by_perm :\n  \"(insert_sort_by cmp l) <~~> l\"", "lemma insert_sort_by_length [simp]:\n  \"length (insert_sort_by cmp l) = length l\"", "lemma insert_sort_by_set [simp]:\n  \"set (insert_sort_by cmp l) = set l\"", "lemma sort_by_simps [simp]:\n  \"length (sort_by cmp l) = length l\"\n  \"set (sort_by cmp l) = set l\"", "lemma sort_by_perm :\n  \"sort_by cmp l <~~> l\"", "lemma map_image_simps [simp]:\n  \"(map_image f m) k = None \\<longleftrightarrow> m k = None\"\n  \"(map_image f m) k = Some x \\<longleftrightarrow> (\\<exists>x'. (m k = Some x') \\<and> (x = f x'))\"\n  \"(map_image f Map.empty) = Map.empty\"\n  \"(map_image f (m (k \\<mapsto> v)) = (map_image f m) (k \\<mapsto> f v))\"", "lemma map_image_dom_ran [simp]:\n  \"dom (map_image f m) = dom m\"\n  \"ran (map_image f m) = f ` (ran m)\"", "lemma map_to_set_simps [simp] :\n  \"map_to_set Map.empty = {}\"  (is ?g1)\n  \"map_to_set (m ((k::'k) \\<mapsto> (v::'v))) = (insert (k, v) (map_to_set (m |` (- {k}))))\" (is ?g2)", "lemma set_choose_thm[simp]:\n  \"s \\<noteq> {} \\<Longrightarrow> (set_choose s) \\<in> s\"", "lemma set_choose_sing [simp]:\n  \"set_choose {x} = x\"", "lemma set_choose_code [code]:\n  \"set_choose (set [x]) = x\"", "lemma set_choose_in [intro] :\n  assumes \"s \\<noteq> {}\"\n  shows \"set_choose s \\<in> s\"", "lemma set_case_simps [simp] :\n  \"set_case {} c_empty c_sing c_else = c_empty\"\n  \"set_case {x} c_empty c_sing c_else = c_sing x\"\n  \"card s > 1 \\<Longrightarrow> set_case s c_empty c_sing c_else = c_else\"\n  \"\\<not>(finite s) \\<Longrightarrow> set_case s c_empty c_sing c_else = c_else\"", "lemma set_case_simp_insert2 [simp] :\nassumes x12_neq: \"x1 \\<noteq> x2\"\nshows \"set_case (insert x1 (insert x2 xs))  c_empty c_sing c_else = c_else\"", "lemma set_case_code [code] :\n  \"set_case (set []) c_empty c_sing c_else = c_empty\"\n  \"set_case (set [x]) c_empty c_sing c_else = c_sing x\"\n  \"set_case (set (x1 # x2 # xs)) c_empty c_sing c_else =\n   (if (x1 = x2) then\n     set_case (set (x2 # xs)) c_empty c_sing c_else\n   else\n     c_else)\"", "lemma set_lfp_tail_rec_def :\nassumes mono_f: \"mono f\"\nshows \"set_lfp s f = (if (f s) \\<subseteq> s then s else (set_lfp (s \\<union> f s) f))\" (is \"?ls = ?rs\")", "lemma set_lfp_simps [simp] :\n\"mono f \\<Longrightarrow> f s \\<subseteq> s \\<Longrightarrow> set_lfp s f = s\"\n\"mono f \\<Longrightarrow> \\<not>(f s \\<subseteq> s) \\<Longrightarrow> set_lfp s f = (set_lfp (s \\<union> f s) f)\"", "lemma insert_in_list_at_arbitrary_pos_thm :\n  \"xl \\<in> insert_in_list_at_arbitrary_pos x l \\<longleftrightarrow>\n   (\\<exists>l1 l2. l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)\"", "lemma list_of_set_set_empty [simp]:\n  \"list_of_set_set {} = {[]}\"", "lemma list_of_set_set_insert [simp] :\n  \"list_of_set_set (insert x s) =\n     \\<Union> ((insert_in_list_at_arbitrary_pos x) ` (list_of_set_set (s - {x})))\"\n   (is \"?lhs = ?rhs\")", "lemma list_of_set_set_code [code]:\n  \"list_of_set_set (set []) = {[]}\"\n  \"list_of_set_set (set (x # xs)) =\n     \\<Union> ((insert_in_list_at_arbitrary_pos x) ` (list_of_set_set ((set xs) - {x})))\"", "lemma list_of_set_set_is_empty :\n  \"list_of_set_set s = {} \\<longleftrightarrow> \\<not> (finite s)\"", "lemma list_of_set [simp] :\n  assumes fin_s: \"finite s\"\n  shows \"set (list_of_set s) = s\"\n        \"distinct (list_of_set s)\"", "lemma list_of_set_in:\n  \"finite s \\<Longrightarrow> list_of_set s \\<in> list_of_set_set s\"", "lemma sum_partition_length :\n  \"List.length lrs = List.length (fst (sum_partition lrs)) + List.length (snd (sum_partition lrs))\"", "lemma is_digit_simps[simp] :\n  \"n < 10 \\<Longrightarrow> is_digit n\"\n  \"\\<not>(n < 10) \\<Longrightarrow> \\<not>(is_digit n)\"", "lemma is_digit_expand :\n  \"is_digit n \\<longleftrightarrow>\n     (n = 0) \\<or> (n = 1) \\<or> (n = 2) \\<or> (n = 3) \\<or>  (n = 4) \\<or>\n     (n = 5) \\<or> (n = 6) \\<or> (n = 7) \\<or> (n = 8) \\<or>  (n = 9)\"", "lemmas is_digitE = is_digit_expand[THEN iffD1,elim_format]", "lemmas is_digitI = is_digit_expand[THEN iffD2,rule_format]", "lemma is_digit_char_simps[simp] :\n  \"is_digit_char (CHR ''0'')\"\n  \"is_digit_char (CHR ''1'')\"\n  \"is_digit_char (CHR ''2'')\"\n  \"is_digit_char (CHR ''3'')\"\n  \"is_digit_char (CHR ''4'')\"\n  \"is_digit_char (CHR ''5'')\"\n  \"is_digit_char (CHR ''6'')\"\n  \"is_digit_char (CHR ''7'')\"\n  \"is_digit_char (CHR ''8'')\"\n  \"is_digit_char (CHR ''9'')\"", "lemmas is_digit_charE = is_digit_char_def[THEN iffD1,elim_format]", "lemmas is_digit_charI = is_digit_char_def[THEN iffD2,rule_format]", "lemma digit_to_char_simps [simp]:\n  \"digit_to_char 0 = CHR ''0''\"\n  \"digit_to_char (Suc 0) = CHR ''1''\"\n  \"digit_to_char 2 = CHR ''2''\"\n  \"digit_to_char 3 = CHR ''3''\"\n  \"digit_to_char 4 = CHR ''4''\"\n  \"digit_to_char 5 = CHR ''5''\"\n  \"digit_to_char 6 = CHR ''6''\"\n  \"digit_to_char 7 = CHR ''7''\"\n  \"digit_to_char 8 = CHR ''8''\"\n  \"digit_to_char 9 = CHR ''9''\"\n  \"n > 9 \\<Longrightarrow> digit_to_char n = CHR ''X''\"", "lemma char_to_digit_simps [simp]:\n  \"char_to_digit (CHR ''0'') = 0\"\n  \"char_to_digit (CHR ''1'') = 1\"\n  \"char_to_digit (CHR ''2'') = 2\"\n  \"char_to_digit (CHR ''3'') = 3\"\n  \"char_to_digit (CHR ''4'') = 4\"\n  \"char_to_digit (CHR ''5'') = 5\"\n  \"char_to_digit (CHR ''6'') = 6\"\n  \"char_to_digit (CHR ''7'') = 7\"\n  \"char_to_digit (CHR ''8'') = 8\"\n  \"char_to_digit (CHR ''9'') = 9\"", "lemma diget_to_char_inv[simp]:\nassumes is_digit: \"is_digit n\"\nshows \"char_to_digit (digit_to_char n) = n\"", "lemma char_to_diget_inv[simp]:\nassumes is_digit: \"is_digit_char c\"\nshows \"digit_to_char (char_to_digit c) = c\"", "lemma char_to_digit_div_mod [simp]:\nassumes is_digit: \"is_digit_char c\"\nshows \"char_to_digit c < 10\"", "lemma is_digit_char_intro[simp]:\n  \"is_digit (char_to_digit c) = is_digit_char c\"", "lemma is_digit_intro[simp]:\n  \"is_digit_char (digit_to_char n) = is_digit n\"", "lemma digit_to_char_11:\n\"digit_to_char n1 = digit_to_char n2 \\<Longrightarrow>\n (is_digit n1 = is_digit n2) \\<and> (is_digit n1 \\<longrightarrow> (n1 = n2))\"", "lemma char_to_digit_11:\n\"char_to_digit c1 = char_to_digit c2 \\<Longrightarrow>\n (is_digit_char c1 = is_digit_char c2) \\<and> (is_digit_char c1 \\<longrightarrow> (c1 = c2))\"", "lemma nat_to_string_simps[simp]:\n   \"is_digit n \\<Longrightarrow> nat_to_string n = [digit_to_char n]\"\n  \"\\<not>(is_digit n) \\<Longrightarrow> nat_to_string n = nat_to_string (n div 10) @ [digit_to_char (n mod 10)]\"", "lemma nat_to_string_neq_nil[simp]:\n  \"nat_to_string n \\<noteq> []\"", "lemmas nat_to_string_neq_nil2[simp] = nat_to_string_neq_nil[symmetric]", "lemma nat_to_string_char_to_digit [simp]:\n  \"is_digit_char c \\<Longrightarrow> nat_to_string (char_to_digit c) = [c]\"", "lemma nat_to_string_11[simp] :\n  \"(nat_to_string n1 = nat_to_string n2) \\<longleftrightarrow> n1 = n2\"", "lemma is_nat_string_simps[simp]:\n  \"is_nat_string []\"\n  \"is_nat_string (c # s) \\<longleftrightarrow> is_digit_char c \\<and> is_nat_string s\"", "lemma is_strong_nat_string_simps[simp]:\n  \"\\<not>(is_strong_nat_string [])\"\n  \"is_strong_nat_string (c # s) \\<longleftrightarrow> is_digit_char c \\<and> is_nat_string s \\<and>\n                                    (c = CHR ''0'' \\<longrightarrow> s = [])\"", "lemma string_to_nat_aux_inv :\nassumes \"is_nat_string s\"\nassumes \"n > 0 \\<or> is_strong_nat_string s\"\nshows \"nat_to_string (string_to_nat_aux n s) =\n(if n = 0 then '''' else nat_to_string n) @ s\"", "lemma string_to_nat_inv :\nassumes strong_nat_s: \"is_strong_nat_string s\"\nassumes s2n_s: \"string_to_nat s = Some n\"\nshows \"nat_to_string n = s\"", "lemma nat_to_string_induct [case_names \"digit\" \"non_digit\"]:\nassumes digit: \"\\<And>d. is_digit d \\<Longrightarrow> P d\"\nassumes not_digit: \"\\<And>n. \\<not>(is_digit n) \\<Longrightarrow> P (n div 10) \\<Longrightarrow> P (n mod 10) \\<Longrightarrow> P n\"\nshows \"P n\"", "lemma nat_to_string___is_nat_string [simp]:\n  \"is_nat_string (nat_to_string n)\"", "lemma nat_to_string___eq_0 [simp]:\n  \"(nat_to_string n = (CHR ''0'')#s) \\<longleftrightarrow> (n = 0 \\<and> s = [])\"", "lemma nat_to_string___is_strong_nat_string:\n  \"is_strong_nat_string (nat_to_string n)\"", "lemma nat_to_string_inv :\n  \"string_to_nat (nat_to_string n) = Some n\"", "lemma The_opt_eq_some [simp] :\n\"((The_opt p) = (Some x)) \\<longleftrightarrow> ((p x) \\<and> ((\\<forall> y.  p y \\<longrightarrow> (x = y))))\"\n    (is \"?lhs = ?rhs\")", "lemma The_opt_eq_none [simp] :\n\"((The_opt p) = None) \\<longleftrightarrow> \\<not>(\\<exists>!x. p x)\""], "translations": [["", "lemma index_eq_some [simp]:\n   \"index l n = Some x \\<longleftrightarrow> (n < length l \\<and> (x = l ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index l n = Some x) = (n < length l \\<and> x = l ! n)", "proof (induct l arbitrary: n x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n x. (index [] n = Some x) = (n < length [] \\<and> x = [] ! n)\n 2. \\<And>a l n x.\n       (\\<And>n x.\n           (index l n = Some x) =\n           (n < length l \\<and> x = l ! n)) \\<Longrightarrow>\n       (index (a # l) n = Some x) =\n       (n < length (a # l) \\<and> x = (a # l) ! n)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n x. (index [] n = Some x) = (n < length [] \\<and> x = [] ! n)\n 2. \\<And>a l n x.\n       (\\<And>n x.\n           (index l n = Some x) =\n           (n < length l \\<and> x = l ! n)) \\<Longrightarrow>\n       (index (a # l) n = Some x) =\n       (n < length (a # l) \\<and> x = (a # l) ! n)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index [] n = Some x) = (n < length [] \\<and> x = [] ! n)", "by simp"], ["proof (state)\nthis:\n  (index [] n = Some x) = (n < length [] \\<and> x = [] ! n)\n\ngoal (1 subgoal):\n 1. \\<And>a l n x.\n       (\\<And>n x.\n           (index l n = Some x) =\n           (n < length l \\<and> x = l ! n)) \\<Longrightarrow>\n       (index (a # l) n = Some x) =\n       (n < length (a # l) \\<and> x = (a # l) ! n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l n x.\n       (\\<And>n x.\n           (index l n = Some x) =\n           (n < length l \\<and> x = l ! n)) \\<Longrightarrow>\n       (index (a # l) n = Some x) =\n       (n < length (a # l) \\<and> x = (a # l) ! n)", "case (Cons e es n x)"], ["proof (state)\nthis:\n  (index es ?n = Some ?x) = (?n < length es \\<and> ?x = es ! ?n)\n\ngoal (1 subgoal):\n 1. \\<And>a l n x.\n       (\\<And>n x.\n           (index l n = Some x) =\n           (n < length l \\<and> x = l ! n)) \\<Longrightarrow>\n       (index (a # l) n = Some x) =\n       (n < length (a # l) \\<and> x = (a # l) ! n)", "note ind_hyp = this"], ["proof (state)\nthis:\n  (index es ?n = Some ?x) = (?n < length es \\<and> ?x = es ! ?n)\n\ngoal (1 subgoal):\n 1. \\<And>a l n x.\n       (\\<And>n x.\n           (index l n = Some x) =\n           (n < length l \\<and> x = l ! n)) \\<Longrightarrow>\n       (index (a # l) n = Some x) =\n       (n < length (a # l) \\<and> x = (a # l) ! n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (index (e # es) n = Some x) =\n    (n < length (e # es) \\<and> x = (e # es) ! n)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (index (e # es) n = Some x) =\n    (n < length (e # es) \\<and> x = (e # es) ! n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (index (e # es) n = Some x) =\n       (n < length (e # es) \\<and> x = (e # es) ! n)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (index (e # es) n = Some x) =\n    (n < length (e # es) \\<and> x = (e # es) ! n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (index (e # es) n = Some x) =\n       (n < length (e # es) \\<and> x = (e # es) ! n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (index (e # es) n = Some x) =\n    (n < length (e # es) \\<and> x = (e # es) ! n)", "by auto"], ["proof (state)\nthis:\n  (index (e # es) n = Some x) =\n  (n < length (e # es) \\<and> x = (e # es) ! n)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (index (e # es) n = Some x) =\n       (n < length (e # es) \\<and> x = (e # es) ! n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (index (e # es) n = Some x) =\n       (n < length (e # es) \\<and> x = (e # es) ! n)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (index (e # es) n = Some x) =\n       (n < length (e # es) \\<and> x = (e # es) ! n)", "with ind_hyp"], ["proof (chain)\npicking this:\n  (index es ?n = Some ?x) = (?n < length es \\<and> ?x = es ! ?n)\n  n = Suc n'", "show ?thesis"], ["proof (prove)\nusing this:\n  (index es ?n = Some ?x) = (?n < length es \\<and> ?x = es ! ?n)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. (index (e # es) n = Some x) =\n    (n < length (e # es) \\<and> x = (e # es) ! n)", "by simp"], ["proof (state)\nthis:\n  (index (e # es) n = Some x) =\n  (n < length (e # es) \\<and> x = (e # es) ! n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (index (e # es) n = Some x) =\n  (n < length (e # es) \\<and> x = (e # es) ! n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_eq_none [simp]:\n   \"index l n = None \\<longleftrightarrow> length l \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index l n = None) = (length l \\<le> n)", "by (rule iffD1[OF Not_eq_iff]) auto"], ["", "lemma index_simps [simp]:\n   \"length l \\<le> n \\<Longrightarrow> index l n = None\"\n   \"n < length l \\<Longrightarrow> index l n = Some (l ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l \\<le> n \\<Longrightarrow> index l n = None) &&&\n    (n < length l \\<Longrightarrow> index l n = Some (l ! n))", "by (simp_all)"], ["", "fun find_indices :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> nat list\" where\n   \"find_indices P [] = []\"\n | \"find_indices P (x # xs) = (if P x then 0 # (map Suc (find_indices P xs)) else (map Suc (find_indices P xs)))\""], ["", "lemma length_find_indices :\n  \"length (find_indices P l) \\<le> length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (find_indices P l) \\<le> length l", "by (induct l) auto"], ["", "lemma sorted_map_suc :\n  \"sorted l \\<Longrightarrow> sorted (map Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted l \\<Longrightarrow> sorted (map Suc l)", "by (induct l) (simp_all)"], ["", "lemma sorted_find_indices :\n  \"sorted (find_indices P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (find_indices P xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (find_indices P [])\n 2. \\<And>a xs.\n       sorted (find_indices P xs) \\<Longrightarrow>\n       sorted (find_indices P (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sorted (find_indices P [])\n 2. \\<And>a xs.\n       sorted (find_indices P xs) \\<Longrightarrow>\n       sorted (find_indices P (a # xs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (find_indices P [])", "by simp"], ["proof (state)\nthis:\n  sorted (find_indices P [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       sorted (find_indices P xs) \\<Longrightarrow>\n       sorted (find_indices P (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       sorted (find_indices P xs) \\<Longrightarrow>\n       sorted (find_indices P (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  sorted (find_indices P xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       sorted (find_indices P xs) \\<Longrightarrow>\n       sorted (find_indices P (a # xs))", "from sorted_map_suc[OF this]"], ["proof (chain)\npicking this:\n  sorted (map Suc (find_indices P xs))", "show ?case"], ["proof (prove)\nusing this:\n  sorted (map Suc (find_indices P xs))\n\ngoal (1 subgoal):\n 1. sorted (find_indices P (x # xs))", "by (simp)"], ["proof (state)\nthis:\n  sorted (find_indices P (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_indices_set [simp] :\n  \"set (find_indices P l) = {i. i < length l \\<and> P (l ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_indices P l) = {i. i < length l \\<and> P (l ! i)}", "proof (intro set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (find_indices P l)) =\n       (x \\<in> {i. i < length l \\<and> P (l ! i)})", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (find_indices P l)) =\n       (x \\<in> {i. i < length l \\<and> P (l ! i)})", "show \"i \\<in> set (find_indices P l) \\<longleftrightarrow> (i \\<in> {i. i < length l \\<and> P (l ! i)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> set (find_indices P l)) =\n    (i \\<in> {i. i < length l \\<and> P (l ! i)})", "proof (induct l arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (i \\<in> set (find_indices P [])) =\n       (i \\<in> {i. i < length [] \\<and> P ([] ! i)})\n 2. \\<And>a l i.\n       (\\<And>i.\n           (i \\<in> set (find_indices P l)) =\n           (i \\<in> {i. i < length l \\<and> P (l ! i)})) \\<Longrightarrow>\n       (i \\<in> set (find_indices P (a # l))) =\n       (i \\<in> {i. i < length (a # l) \\<and> P ((a # l) ! i)})", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i.\n       (i \\<in> set (find_indices P [])) =\n       (i \\<in> {i. i < length [] \\<and> P ([] ! i)})\n 2. \\<And>a l i.\n       (\\<And>i.\n           (i \\<in> set (find_indices P l)) =\n           (i \\<in> {i. i < length l \\<and> P (l ! i)})) \\<Longrightarrow>\n       (i \\<in> set (find_indices P (a # l))) =\n       (i \\<in> {i. i < length (a # l) \\<and> P ((a # l) ! i)})", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> set (find_indices P [])) =\n    (i \\<in> {i. i < length [] \\<and> P ([] ! i)})", "by simp"], ["proof (state)\nthis:\n  (i \\<in> set (find_indices P [])) =\n  (i \\<in> {i. i < length [] \\<and> P ([] ! i)})\n\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       (\\<And>i.\n           (i \\<in> set (find_indices P l)) =\n           (i \\<in> {i. i < length l \\<and> P (l ! i)})) \\<Longrightarrow>\n       (i \\<in> set (find_indices P (a # l))) =\n       (i \\<in> {i. i < length (a # l) \\<and> P ((a # l) ! i)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       (\\<And>i.\n           (i \\<in> set (find_indices P l)) =\n           (i \\<in> {i. i < length l \\<and> P (l ! i)})) \\<Longrightarrow>\n       (i \\<in> set (find_indices P (a # l))) =\n       (i \\<in> {i. i < length (a # l) \\<and> P ((a # l) ! i)})", "case (Cons x l' i)"], ["proof (state)\nthis:\n  (?i \\<in> set (find_indices P l')) =\n  (?i \\<in> {i. i < length l' \\<and> P (l' ! i)})\n\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       (\\<And>i.\n           (i \\<in> set (find_indices P l)) =\n           (i \\<in> {i. i < length l \\<and> P (l ! i)})) \\<Longrightarrow>\n       (i \\<in> set (find_indices P (a # l))) =\n       (i \\<in> {i. i < length (a # l) \\<and> P ((a # l) ! i)})", "note ind_hyp = this"], ["proof (state)\nthis:\n  (?i \\<in> set (find_indices P l')) =\n  (?i \\<in> {i. i < length l' \\<and> P (l' ! i)})\n\ngoal (1 subgoal):\n 1. \\<And>a l i.\n       (\\<And>i.\n           (i \\<in> set (find_indices P l)) =\n           (i \\<in> {i. i < length l \\<and> P (l ! i)})) \\<Longrightarrow>\n       (i \\<in> set (find_indices P (a # l))) =\n       (i \\<in> {i. i < length (a # l) \\<and> P ((a # l) ! i)})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> set (find_indices P (x # l'))) =\n    (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (i \\<in> set (find_indices P (x # l'))) =\n    (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (i \\<in> set (find_indices P (x # l'))) =\n       (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (i \\<in> set (find_indices P (x # l'))) =\n    (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (i \\<in> set (find_indices P (x # l'))) =\n       (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. (i \\<in> set (find_indices P (x # l'))) =\n    (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "by auto"], ["proof (state)\nthis:\n  (i \\<in> set (find_indices P (x # l'))) =\n  (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (i \\<in> set (find_indices P (x # l'))) =\n       (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (i \\<in> set (find_indices P (x # l'))) =\n       (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (i \\<in> set (find_indices P (x # l'))) =\n       (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "with ind_hyp[of i']"], ["proof (chain)\npicking this:\n  (i' \\<in> set (find_indices P l')) =\n  (i' \\<in> {i. i < length l' \\<and> P (l' ! i)})\n  i = Suc i'", "show ?thesis"], ["proof (prove)\nusing this:\n  (i' \\<in> set (find_indices P l')) =\n  (i' \\<in> {i. i < length l' \\<and> P (l' ! i)})\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. (i \\<in> set (find_indices P (x # l'))) =\n    (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})", "by auto"], ["proof (state)\nthis:\n  (i \\<in> set (find_indices P (x # l'))) =\n  (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i \\<in> set (find_indices P (x # l'))) =\n  (i \\<in> {i. i < length (x # l') \\<and> P ((x # l') ! i)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i \\<in> set (find_indices P l)) =\n  (i \\<in> {i. i < length l \\<and> P (l ! i)})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition find_index where\n  \"find_index P xs = (case find_indices P xs of\n      []    \\<Rightarrow> None\n    | i # _ \\<Rightarrow> Some i)\""], ["", "lemma find_index_eq_some [simp] :\n  \"(find_index P xs = Some ii) \\<longleftrightarrow> (ii < length xs \\<and> P (xs ! ii) \\<and> (\\<forall>i' < ii. \\<not>(P (xs ! i'))))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_index P xs = Some ii) =\n    (ii < length xs \\<and>\n     P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "proof (cases \"find_indices P xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_indices P xs = [] \\<Longrightarrow>\n    (find_index P xs = Some ii) =\n    (ii < length xs \\<and>\n     P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))\n 2. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "case Nil"], ["proof (state)\nthis:\n  find_indices P xs = []\n\ngoal (2 subgoals):\n 1. find_indices P xs = [] \\<Longrightarrow>\n    (find_index P xs = Some ii) =\n    (ii < length xs \\<and>\n     P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))\n 2. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "with find_indices_set[of P xs]"], ["proof (chain)\npicking this:\n  set (find_indices P xs) = {i. i < length xs \\<and> P (xs ! i)}\n  find_indices P xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  set (find_indices P xs) = {i. i < length xs \\<and> P (xs ! i)}\n  find_indices P xs = []\n\ngoal (1 subgoal):\n 1. (find_index P xs = Some ii) =\n    (ii < length xs \\<and>\n     P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "unfolding find_index_def"], ["proof (prove)\nusing this:\n  set (find_indices P xs) = {i. i < length xs \\<and> P (xs ! i)}\n  find_indices P xs = []\n\ngoal (1 subgoal):\n 1. ((case find_indices P xs of [] \\<Rightarrow> None\n      | i # x \\<Rightarrow> Some i) =\n     Some ii) =\n    (ii < length xs \\<and>\n     P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "by auto"], ["proof (state)\nthis:\n  (find_index P xs = Some ii) =\n  (ii < length xs \\<and>\n   P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "case (Cons i il)"], ["proof (state)\nthis:\n  find_indices P xs = i # il\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "note find_indices_eq = this"], ["proof (state)\nthis:\n  find_indices P xs = i # il\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "from sorted_find_indices[of P xs] find_indices_eq"], ["proof (chain)\npicking this:\n  sorted (find_indices P xs)\n  find_indices P xs = i # il", "have \"sorted (i # il)\""], ["proof (prove)\nusing this:\n  sorted (find_indices P xs)\n  find_indices P xs = i # il\n\ngoal (1 subgoal):\n 1. sorted (i # il)", "by simp"], ["proof (state)\nthis:\n  sorted (i # il)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "hence i_leq: \"\\<And>i'. i' \\<in> set (i # il) \\<Longrightarrow> i \\<le> i'\""], ["proof (prove)\nusing this:\n  sorted (i # il)\n\ngoal (1 subgoal):\n 1. \\<And>i'. i' \\<in> set (i # il) \\<Longrightarrow> i \\<le> i'", "by auto"], ["proof (state)\nthis:\n  ?i' \\<in> set (i # il) \\<Longrightarrow> i \\<le> ?i'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "from find_indices_set[of P xs, unfolded find_indices_eq]"], ["proof (chain)\npicking this:\n  set (i # il) = {i. i < length xs \\<and> P (xs ! i)}", "have set_i_il_eq:\"\\<And>i'. i' \\<in> set (i # il) = (i' < length xs \\<and> P (xs ! i'))\""], ["proof (prove)\nusing this:\n  set (i # il) = {i. i < length xs \\<and> P (xs ! i)}\n\ngoal (1 subgoal):\n 1. \\<And>i'. (i' \\<in> set (i # il)) = (i' < length xs \\<and> P (xs ! i'))", "by simp"], ["proof (state)\nthis:\n  (?i' \\<in> set (i # il)) = (?i' < length xs \\<and> P (xs ! ?i'))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "have lhs_eq: \"find_index P xs = Some i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index P xs = Some i", "unfolding find_index_def find_indices_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case i # il of [] \\<Rightarrow> None | i # x \\<Rightarrow> Some i) =\n    Some i", "by simp"], ["proof (state)\nthis:\n  find_index P xs = Some i\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       find_indices P xs = a # list \\<Longrightarrow>\n       (find_index P xs = Some ii) =\n       (ii < length xs \\<and>\n        P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_index P xs = Some ii) =\n    (ii < length xs \\<and>\n     P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_index P xs = Some ii \\<Longrightarrow>\n    ii < length xs \\<and>\n    P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))\n 2. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "assume ?lhs"], ["proof (state)\nthis:\n  find_index P xs = Some ii\n\ngoal (2 subgoals):\n 1. find_index P xs = Some ii \\<Longrightarrow>\n    ii < length xs \\<and>\n    P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))\n 2. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "with lhs_eq"], ["proof (chain)\npicking this:\n  find_index P xs = Some i\n  find_index P xs = Some ii", "have ii_eq[simp]: \"ii = i\""], ["proof (prove)\nusing this:\n  find_index P xs = Some i\n  find_index P xs = Some ii\n\ngoal (1 subgoal):\n 1. ii = i", "by simp"], ["proof (state)\nthis:\n  ii = i\n\ngoal (2 subgoals):\n 1. find_index P xs = Some ii \\<Longrightarrow>\n    ii < length xs \\<and>\n    P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))\n 2. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "from set_i_il_eq[of i] i_leq[unfolded set_i_il_eq]"], ["proof (chain)\npicking this:\n  (i \\<in> set (i # il)) = (i < length xs \\<and> P (xs ! i))\n  ?i' < length xs \\<and> P (xs ! ?i') \\<Longrightarrow> i \\<le> ?i'", "show ?rhs"], ["proof (prove)\nusing this:\n  (i \\<in> set (i # il)) = (i < length xs \\<and> P (xs ! i))\n  ?i' < length xs \\<and> P (xs ! ?i') \\<Longrightarrow> i \\<le> ?i'\n\ngoal (1 subgoal):\n 1. ii < length xs \\<and>\n    P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))", "by auto (metis leD less_trans)"], ["proof (state)\nthis:\n  ii < length xs \\<and>\n  P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))\n\ngoal (1 subgoal):\n 1. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "assume ?rhs"], ["proof (state)\nthis:\n  ii < length xs \\<and>\n  P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))\n\ngoal (1 subgoal):\n 1. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "with set_i_il_eq[of ii]"], ["proof (chain)\npicking this:\n  (ii \\<in> set (i # il)) = (ii < length xs \\<and> P (xs ! ii))\n  ii < length xs \\<and>\n  P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))", "have \"ii \\<in> set (i # il) \\<and> (ii \\<le> i)\""], ["proof (prove)\nusing this:\n  (ii \\<in> set (i # il)) = (ii < length xs \\<and> P (xs ! ii))\n  ii < length xs \\<and>\n  P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i'))\n\ngoal (1 subgoal):\n 1. ii \\<in> set (i # il) \\<and> ii \\<le> i", "by (metis leI length_pos_if_in_set nth_Cons_0 nth_mem set_i_il_eq)"], ["proof (state)\nthis:\n  ii \\<in> set (i # il) \\<and> ii \\<le> i\n\ngoal (1 subgoal):\n 1. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "with i_leq [of ii]"], ["proof (chain)\npicking this:\n  ii \\<in> set (i # il) \\<Longrightarrow> i \\<le> ii\n  ii \\<in> set (i # il) \\<and> ii \\<le> i", "have \"i = ii\""], ["proof (prove)\nusing this:\n  ii \\<in> set (i # il) \\<Longrightarrow> i \\<le> ii\n  ii \\<in> set (i # il) \\<and> ii \\<le> i\n\ngoal (1 subgoal):\n 1. i = ii", "by simp"], ["proof (state)\nthis:\n  i = ii\n\ngoal (1 subgoal):\n 1. ii < length xs \\<and>\n    P (xs ! ii) \\<and>\n    (\\<forall>i'<ii. \\<not> P (xs ! i')) \\<Longrightarrow>\n    find_index P xs = Some ii", "thus ?lhs"], ["proof (prove)\nusing this:\n  i = ii\n\ngoal (1 subgoal):\n 1. find_index P xs = Some ii", "unfolding lhs_eq"], ["proof (prove)\nusing this:\n  i = ii\n\ngoal (1 subgoal):\n 1. Some i = Some ii", "by simp"], ["proof (state)\nthis:\n  find_index P xs = Some ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (find_index P xs = Some ii) =\n  (ii < length xs \\<and>\n   P (xs ! ii) \\<and> (\\<forall>i'<ii. \\<not> P (xs ! i')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_index_eq_none [simp] :\n  \"(find_index P xs = None) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. \\<not>(P x))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_index P xs = None) = (\\<forall>x\\<in>set xs. \\<not> P x)", "proof (rule iffD1[OF Not_eq_iff], intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_index P xs \\<noteq> None \\<Longrightarrow>\n    \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n 2. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "assume \"\\<not> ?lhs\""], ["proof (state)\nthis:\n  find_index P xs \\<noteq> None\n\ngoal (2 subgoals):\n 1. find_index P xs \\<noteq> None \\<Longrightarrow>\n    \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n 2. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  find_index P xs \\<noteq> None", "obtain i where \"find_index P xs = Some i\""], ["proof (prove)\nusing this:\n  find_index P xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        find_index P xs = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  find_index P xs = Some i\n\ngoal (2 subgoals):\n 1. find_index P xs \\<noteq> None \\<Longrightarrow>\n    \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n 2. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "hence \"i < length xs \\<and> P (xs ! i)\""], ["proof (prove)\nusing this:\n  find_index P xs = Some i\n\ngoal (1 subgoal):\n 1. i < length xs \\<and> P (xs ! i)", "by simp"], ["proof (state)\nthis:\n  i < length xs \\<and> P (xs ! i)\n\ngoal (2 subgoals):\n 1. find_index P xs \\<noteq> None \\<Longrightarrow>\n    \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n 2. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "thus \"\\<not> ?rhs\""], ["proof (prove)\nusing this:\n  i < length xs \\<and> P (xs ! i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "let ?p = \"(\\<lambda>i. i < length xs \\<and> P(xs ! i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "assume \"\\<not> ?rhs\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)", "obtain i where \"?p i\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>set xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length xs \\<and> P (xs ! i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs \\<and> P (xs ! i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "from LeastI [of ?p, OF \\<open>?p i\\<close>]"], ["proof (chain)\npicking this:\n  (LEAST x. x < length xs \\<and> P (xs ! x)) < length xs \\<and>\n  P (xs ! (LEAST x. x < length xs \\<and> P (xs ! x)))", "have \"?p (Least ?p)\""], ["proof (prove)\nusing this:\n  (LEAST x. x < length xs \\<and> P (xs ! x)) < length xs \\<and>\n  P (xs ! (LEAST x. x < length xs \\<and> P (xs ! x)))\n\ngoal (1 subgoal):\n 1. (LEAST i. i < length xs \\<and> P (xs ! i)) < length xs \\<and>\n    P (xs ! (LEAST i. i < length xs \\<and> P (xs ! i)))", "."], ["proof (state)\nthis:\n  (LEAST i. i < length xs \\<and> P (xs ! i)) < length xs \\<and>\n  P (xs ! (LEAST i. i < length xs \\<and> P (xs ! i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "hence \"find_index P xs = Some (Least ?p)\""], ["proof (prove)\nusing this:\n  (LEAST i. i < length xs \\<and> P (xs ! i)) < length xs \\<and>\n  P (xs ! (LEAST i. i < length xs \\<and> P (xs ! i)))\n\ngoal (1 subgoal):\n 1. find_index P xs = Some (LEAST i. i < length xs \\<and> P (xs ! i))", "by (subst find_index_eq_some) (metis (mono_tags) less_trans not_less_Least)"], ["proof (state)\nthis:\n  find_index P xs = Some (LEAST i. i < length xs \\<and> P (xs ! i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>set xs. \\<not> P x) \\<Longrightarrow>\n    find_index P xs \\<noteq> None", "thus \"\\<not> ?lhs\""], ["proof (prove)\nusing this:\n  find_index P xs = Some (LEAST i. i < length xs \\<and> P (xs ! i))\n\ngoal (1 subgoal):\n 1. find_index P xs \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  find_index P xs \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "definition genlist where\n  \"genlist f n = map f (upt 0 n)\""], ["", "lemma genlist_length [simp] :\n  \"length (genlist f n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (genlist f n) = n", "unfolding genlist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map f [0..<n]) = n", "by simp"], ["", "lemma genlist_simps [simp]:\n   \"genlist f 0 = []\"\n   \"genlist f (Suc n) = genlist f n @ [f n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. genlist f 0 = [] &&& genlist f (Suc n) = genlist f n @ [f n]", "unfolding genlist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<0] = [] &&& map f [0..<Suc n] = map f [0..<n] @ [f n]", "by auto"], ["", "definition split_at where\n  \"split_at n l = (take n l, drop n l)\""], ["", "fun delete_first :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> ('a list) option \"  where\n    \"delete_first P [] = None\"\n  | \"delete_first P (x # xs) =\n     (if (P x) then Some xs else\n      map_option (\\<lambda>xs'. x # xs') (delete_first P xs))\""], ["", "declare delete_first.simps [simp del]"], ["", "lemma delete_first_simps [simp] :\n   \"delete_first P [] = None\"\n   \"P x \\<Longrightarrow> delete_first P (x # xs) = Some xs\"\n   \"\\<not>(P x) \\<Longrightarrow> delete_first P (x # xs) = map_option (\\<lambda>xs'. x # xs') (delete_first P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_first P [] = None &&&\n    (P x \\<Longrightarrow> delete_first P (x # xs) = Some xs) &&&\n    (\\<not> P x \\<Longrightarrow>\n     delete_first P (x # xs) = map_option ((#) x) (delete_first P xs))", "unfolding delete_first.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. None = None &&&\n    (P x \\<Longrightarrow>\n     (if P x then Some xs else map_option ((#) x) (delete_first P xs)) =\n     Some xs) &&&\n    (\\<not> P x \\<Longrightarrow>\n     (if P x then Some xs else map_option ((#) x) (delete_first P xs)) =\n     map_option ((#) x) (delete_first P xs))", "by auto"], ["", "lemmas delete_first_unroll = delete_first.simps(2)"], ["", "lemma delete_first_eq_none [simp] :\n  \"delete_first P l = None \\<longleftrightarrow> (\\<forall>x \\<in> set l. \\<not> (P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete_first P l = None) = (\\<forall>x\\<in>set l. \\<not> P x)", "by (induct l) (auto simp add: delete_first_unroll)"], ["", "lemma delete_first_eq_some :\n  \"delete_first P l = (Some l') \\<longleftrightarrow> (\\<exists>l1 x l2. P x \\<and> (\\<forall>x \\<in> set l1. \\<not>(P x)) \\<and> (l = l1 @ (x # l2)) \\<and> (l' = l1 @ l2))\"\n  (is \"?lhs l l' = (\\<exists>l1 x l2. ?rhs_body l1 x l2 l l')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete_first P l = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "proof (induct l arbitrary: l')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l'.\n       (delete_first P [] = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           [] = l1 @ x # l2 \\<and> l' = l1 @ l2)\n 2. \\<And>a l l'.\n       (\\<And>l'.\n           (delete_first P l = Some l') =\n           (\\<exists>l1 x l2.\n               P x \\<and>\n               (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n               l = l1 @ x # l2 \\<and> l' = l1 @ l2)) \\<Longrightarrow>\n       (delete_first P (a # l) = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           a # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       (delete_first P [] = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           [] = l1 @ x # l2 \\<and> l' = l1 @ l2)\n 2. \\<And>a l l'.\n       (\\<And>l'.\n           (delete_first P l = Some l') =\n           (\\<exists>l1 x l2.\n               P x \\<and>\n               (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n               l = l1 @ x # l2 \\<and> l' = l1 @ l2)) \\<Longrightarrow>\n       (delete_first P (a # l) = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           a # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete_first P [] = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        [] = l1 @ x # l2 \\<and> l' = l1 @ l2)", "by simp"], ["proof (state)\nthis:\n  (delete_first P [] = Some l') =\n  (\\<exists>l1 x l2.\n      P x \\<and>\n      (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n      [] = l1 @ x # l2 \\<and> l' = l1 @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l l'.\n       (\\<And>l'.\n           (delete_first P l = Some l') =\n           (\\<exists>l1 x l2.\n               P x \\<and>\n               (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n               l = l1 @ x # l2 \\<and> l' = l1 @ l2)) \\<Longrightarrow>\n       (delete_first P (a # l) = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           a # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l l'.\n       (\\<And>l'.\n           (delete_first P l = Some l') =\n           (\\<exists>l1 x l2.\n               P x \\<and>\n               (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n               l = l1 @ x # l2 \\<and> l' = l1 @ l2)) \\<Longrightarrow>\n       (delete_first P (a # l) = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           a # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "case (Cons e l l')"], ["proof (state)\nthis:\n  (delete_first P l = Some ?l') =\n  (\\<exists>l1 x l2.\n      P x \\<and>\n      (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n      l = l1 @ x # l2 \\<and> ?l' = l1 @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l l'.\n       (\\<And>l'.\n           (delete_first P l = Some l') =\n           (\\<exists>l1 x l2.\n               P x \\<and>\n               (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n               l = l1 @ x # l2 \\<and> l' = l1 @ l2)) \\<Longrightarrow>\n       (delete_first P (a # l) = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           a # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "note ind_hyp = this"], ["proof (state)\nthis:\n  (delete_first P l = Some ?l') =\n  (\\<exists>l1 x l2.\n      P x \\<and>\n      (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n      l = l1 @ x # l2 \\<and> ?l' = l1 @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l l'.\n       (\\<And>l'.\n           (delete_first P l = Some l') =\n           (\\<exists>l1 x l2.\n               P x \\<and>\n               (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n               l = l1 @ x # l2 \\<and> l' = l1 @ l2)) \\<Longrightarrow>\n       (delete_first P (a # l) = Some l') =\n       (\\<exists>l1 x l2.\n           P x \\<and>\n           (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n           a # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "proof (cases \"P e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)\n 2. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "case True"], ["proof (state)\nthis:\n  P e\n\ngoal (2 subgoals):\n 1. P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)\n 2. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. delete_first P (e # l) = Some l' \\<Longrightarrow>\n    \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n 2. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "assume \"?lhs (e # l) l'\""], ["proof (state)\nthis:\n  delete_first P (e # l) = Some l'\n\ngoal (2 subgoals):\n 1. delete_first P (e # l) = Some l' \\<Longrightarrow>\n    \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n 2. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "with \\<open>P e\\<close>"], ["proof (chain)\npicking this:\n  P e\n  delete_first P (e # l) = Some l'", "have \"l = l'\""], ["proof (prove)\nusing this:\n  P e\n  delete_first P (e # l) = Some l'\n\ngoal (1 subgoal):\n 1. l = l'", "by simp"], ["proof (state)\nthis:\n  l = l'\n\ngoal (2 subgoals):\n 1. delete_first P (e # l) = Some l' \\<Longrightarrow>\n    \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n 2. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "with \\<open>P e\\<close>"], ["proof (chain)\npicking this:\n  P e\n  l = l'", "have \"?rhs_body [] e l' (e # l) l'\""], ["proof (prove)\nusing this:\n  P e\n  l = l'\n\ngoal (1 subgoal):\n 1. P e \\<and>\n    (\\<forall>x\\<in>set []. \\<not> P x) \\<and>\n    e # l = [] @ e # l' \\<and> l' = [] @ l'", "by simp"], ["proof (state)\nthis:\n  P e \\<and>\n  (\\<forall>x\\<in>set []. \\<not> P x) \\<and>\n  e # l = [] @ e # l' \\<and> l' = [] @ l'\n\ngoal (2 subgoals):\n 1. delete_first P (e # l) = Some l' \\<Longrightarrow>\n    \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n 2. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "thus \"\\<exists>l1 x l2. ?rhs_body l1 x l2 (e # l) l'\""], ["proof (prove)\nusing this:\n  P e \\<and>\n  (\\<forall>x\\<in>set []. \\<not> P x) \\<and>\n  e # l = [] @ e # l' \\<and> l' = [] @ l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2", "by blast"], ["proof (state)\nthis:\n  \\<exists>l1 x l2.\n     P x \\<and>\n     (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n     e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "assume \"\\<exists>l1 x l2. ?rhs_body l1 x l2 (e # l) l'\""], ["proof (state)\nthis:\n  \\<exists>l1 x l2.\n     P x \\<and>\n     (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n     e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "then"], ["proof (chain)\npicking this:\n  \\<exists>l1 x l2.\n     P x \\<and>\n     (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n     e # l = l1 @ x # l2 \\<and> l' = l1 @ l2", "obtain l1 x l2 where body_ok: \"?rhs_body l1 x l2 (e # l) l'\""], ["proof (prove)\nusing this:\n  \\<exists>l1 x l2.\n     P x \\<and>\n     (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n     e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. (\\<And>x l1 l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P x \\<and>\n  (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n  e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "from body_ok \\<open>P e\\<close>"], ["proof (chain)\npicking this:\n  P x \\<and>\n  (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n  e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n  P e", "have l1_eq[simp]: \"l = l'\""], ["proof (prove)\nusing this:\n  P x \\<and>\n  (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n  e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n  P e\n\ngoal (1 subgoal):\n 1. l = l'", "by (cases l1) (simp_all)"], ["proof (state)\nthis:\n  l = l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2.\n       P x \\<and>\n       (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n       e # l = l1 @ x # l2 \\<and> l' = l1 @ l2 \\<Longrightarrow>\n    delete_first P (e # l) = Some l'", "with \\<open>P e\\<close>"], ["proof (chain)\npicking this:\n  P e\n  l = l'", "show \"?lhs (e # l) l'\""], ["proof (prove)\nusing this:\n  P e\n  l = l'\n\ngoal (1 subgoal):\n 1. delete_first P (e # l) = Some l'", "by simp"], ["proof (state)\nthis:\n  delete_first P (e # l) = Some l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (delete_first P (e # l) = Some l') =\n  (\\<exists>l1 x l2.\n      P x \\<and>\n      (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n      e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)\n\ngoal (1 subgoal):\n 1. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "case False"], ["proof (state)\nthis:\n  \\<not> P e\n\ngoal (1 subgoal):\n 1. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "define rhs_pred where \"rhs_pred \\<equiv> \\<lambda>l1 x l2 l l'. ?rhs_body l1 x l2 l l'\""], ["proof (state)\nthis:\n  rhs_pred \\<equiv>\n  \\<lambda>l1 x l2 l l'.\n     P x \\<and>\n     (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n     l = l1 @ x # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "have rhs_fold: \"\\<And>l1 x l2 l l'. ?rhs_body l1 x l2 l l' = rhs_pred l1 x l2 l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 x l2 l l'.\n       (P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        l = l1 @ x # l2 \\<and> l' = l1 @ l2) =\n       rhs_pred l1 x l2 l l'", "unfolding rhs_pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 x l2 l l'.\n       (P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        l = l1 @ x # l2 \\<and> l' = l1 @ l2) =\n       (P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "by simp"], ["proof (state)\nthis:\n  (P ?x \\<and>\n   (\\<forall>x\\<in>set ?l1.0. \\<not> P x) \\<and>\n   ?l = ?l1.0 @ ?x # ?l2.0 \\<and> ?l' = ?l1.0 @ ?l2.0) =\n  rhs_pred ?l1.0 ?x ?l2.0 ?l ?l'\n\ngoal (1 subgoal):\n 1. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "have \"(\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l') = (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l') =\n    (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z l1 x l2.\n       rhs_pred l1 x l2 l z \\<and> e # z = l' \\<Longrightarrow>\n    \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n 2. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "assume \"\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'\""], ["proof (state)\nthis:\n  \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'\n\ngoal (2 subgoals):\n 1. \\<exists>z l1 x l2.\n       rhs_pred l1 x l2 l z \\<and> e # z = l' \\<Longrightarrow>\n    \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n 2. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "then"], ["proof (chain)\npicking this:\n  \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "obtain z l1 x l2 where \"rhs_pred l1 x l2 l z\" and l'_eq: \"l' = e # z\""], ["proof (prove)\nusing this:\n  \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'\n\ngoal (1 subgoal):\n 1. (\\<And>l1 x l2 z.\n        \\<lbrakk>rhs_pred l1 x l2 l z; l' = e # z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rhs_pred l1 x l2 l z\n  l' = e # z\n\ngoal (2 subgoals):\n 1. \\<exists>z l1 x l2.\n       rhs_pred l1 x l2 l z \\<and> e # z = l' \\<Longrightarrow>\n    \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n 2. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "with \\<open>\\<not>(P e)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> P e\n  rhs_pred l1 x l2 l z\n  l' = e # z", "have \"rhs_pred (e # l1) x l2 (e # l) l'\""], ["proof (prove)\nusing this:\n  \\<not> P e\n  rhs_pred l1 x l2 l z\n  l' = e # z\n\ngoal (1 subgoal):\n 1. rhs_pred (e # l1) x l2 (e # l) l'", "unfolding rhs_pred_def"], ["proof (prove)\nusing this:\n  \\<not> P e\n  P x \\<and>\n  (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n  l = l1 @ x # l2 \\<and> z = l1 @ l2\n  l' = e # z\n\ngoal (1 subgoal):\n 1. P x \\<and>\n    (\\<forall>x\\<in>set (e # l1). \\<not> P x) \\<and>\n    e # l = (e # l1) @ x # l2 \\<and> l' = (e # l1) @ l2", "by simp"], ["proof (state)\nthis:\n  rhs_pred (e # l1) x l2 (e # l) l'\n\ngoal (2 subgoals):\n 1. \\<exists>z l1 x l2.\n       rhs_pred l1 x l2 l z \\<and> e # z = l' \\<Longrightarrow>\n    \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n 2. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "thus \"\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\""], ["proof (prove)\nusing this:\n  rhs_pred (e # l1) x l2 (e # l) l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'", "by blast"], ["proof (state)\nthis:\n  \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "assume \"\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\""], ["proof (state)\nthis:\n  \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "then"], ["proof (chain)\npicking this:\n  \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'", "obtain l1 x l2 where \"rhs_pred l1 x l2 (e # l) l'\""], ["proof (prove)\nusing this:\n  \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l'\n\ngoal (1 subgoal):\n 1. (\\<And>l1 x l2.\n        rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rhs_pred l1 x l2 (e # l) l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "with \\<open>\\<not> (P e)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> P e\n  rhs_pred l1 x l2 (e # l) l'", "obtain l1' where l1_eq[simp]: \"l1 = e # l1'\""], ["proof (prove)\nusing this:\n  \\<not> P e\n  rhs_pred l1 x l2 (e # l) l'\n\ngoal (1 subgoal):\n 1. (\\<And>l1'. l1 = e # l1' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rhs_pred_def"], ["proof (prove)\nusing this:\n  \\<not> P e\n  P x \\<and>\n  (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n  e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. (\\<And>l1'. l1 = e # l1' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l1) (auto)"], ["proof (state)\nthis:\n  l1 = e # l1'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "with \\<open>rhs_pred l1 x l2 (e # l) l'\\<close>"], ["proof (chain)\npicking this:\n  rhs_pred l1 x l2 (e # l) l'\n  l1 = e # l1'", "have \"rhs_pred l1' x l2 l (l1' @ l2) \\<and> e # (l1' @ l2) = l'\""], ["proof (prove)\nusing this:\n  rhs_pred l1 x l2 (e # l) l'\n  l1 = e # l1'\n\ngoal (1 subgoal):\n 1. rhs_pred l1' x l2 l (l1' @ l2) \\<and> e # l1' @ l2 = l'", "unfolding rhs_pred_def"], ["proof (prove)\nusing this:\n  P x \\<and>\n  (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n  e # l = l1 @ x # l2 \\<and> l' = l1 @ l2\n  l1 = e # l1'\n\ngoal (1 subgoal):\n 1. (P x \\<and>\n     (\\<forall>x\\<in>set l1'. \\<not> P x) \\<and>\n     l = l1' @ x # l2 \\<and> l1' @ l2 = l1' @ l2) \\<and>\n    e # l1' @ l2 = l'", "by (simp)"], ["proof (state)\nthis:\n  rhs_pred l1' x l2 l (l1' @ l2) \\<and> e # l1' @ l2 = l'\n\ngoal (1 subgoal):\n 1. \\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l' \\<Longrightarrow>\n    \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "thus \"\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'\""], ["proof (prove)\nusing this:\n  rhs_pred l1' x l2 l (l1' @ l2) \\<and> e # l1' @ l2 = l'\n\ngoal (1 subgoal):\n 1. \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'", "by blast"], ["proof (state)\nthis:\n  \\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l') =\n  (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')\n\ngoal (1 subgoal):\n 1. \\<not> P e \\<Longrightarrow>\n    (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "with \\<open>\\<not> P e\\<close>"], ["proof (chain)\npicking this:\n  \\<not> P e\n  (\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l') =\n  (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> P e\n  (\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l') =\n  (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')\n\ngoal (1 subgoal):\n 1. (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2.\n        P x \\<and>\n        (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n        e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)", "unfolding rhs_fold"], ["proof (prove)\nusing this:\n  \\<not> P e\n  (\\<exists>z l1 x l2. rhs_pred l1 x l2 l z \\<and> e # z = l') =\n  (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')\n\ngoal (1 subgoal):\n 1. (delete_first P (e # l) = Some l') =\n    (\\<exists>l1 x l2. rhs_pred l1 x l2 (e # l) l')", "by (simp add: ind_hyp[unfolded rhs_fold])"], ["proof (state)\nthis:\n  (delete_first P (e # l) = Some l') =\n  (\\<exists>l1 x l2.\n      P x \\<and>\n      (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n      e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (delete_first P (e # l) = Some l') =\n  (\\<exists>l1 x l2.\n      P x \\<and>\n      (\\<forall>x\\<in>set l1. \\<not> P x) \\<and>\n      e # l = l1 @ x # l2 \\<and> l' = l1 @ l2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_eval [code] :\n  \"perm [] l \\<longleftrightarrow> l = []\" (is ?g1)\n  \"perm (x # xs) l \\<longleftrightarrow> (case delete_first (\\<lambda>e. e = x) l of\n       None => False\n     | Some l' => perm xs l')\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] <~~> l) = (l = []) &&&\n    (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ([] <~~> l) = (l = [])\n 2. (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] <~~> l) = (l = [])", "by auto"], ["proof (state)\nthis:\n  ([] <~~> l) = (l = [])\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "show ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "proof (cases \"delete_first (\\<lambda>e. e = x) l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. delete_first (\\<lambda>e. e = x) l = None \\<Longrightarrow>\n    (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')\n 2. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "case None"], ["proof (state)\nthis:\n  delete_first (\\<lambda>e. e = x) l = None\n\ngoal (2 subgoals):\n 1. delete_first (\\<lambda>e. e = x) l = None \\<Longrightarrow>\n    (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')\n 2. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "note del_eq = this"], ["proof (state)\nthis:\n  delete_first (\\<lambda>e. e = x) l = None\n\ngoal (2 subgoals):\n 1. delete_first (\\<lambda>e. e = x) l = None \\<Longrightarrow>\n    (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')\n 2. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "hence \"x \\<notin> set l\""], ["proof (prove)\nusing this:\n  delete_first (\\<lambda>e. e = x) l = None\n\ngoal (1 subgoal):\n 1. x \\<notin> set l", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set l\n\ngoal (2 subgoals):\n 1. delete_first (\\<lambda>e. e = x) l = None \\<Longrightarrow>\n    (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')\n 2. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "with perm_set_eq [of \"x # xs\" l]"], ["proof (chain)\npicking this:\n  x # xs <~~> l \\<Longrightarrow> set (x # xs) = set l\n  x \\<notin> set l", "have \"\\<not> perm (x # xs) l\""], ["proof (prove)\nusing this:\n  x # xs <~~> l \\<Longrightarrow> set (x # xs) = set l\n  x \\<notin> set l\n\ngoal (1 subgoal):\n 1. \\<not> x # xs <~~> l", "by auto"], ["proof (state)\nthis:\n  \\<not> x # xs <~~> l\n\ngoal (2 subgoals):\n 1. delete_first (\\<lambda>e. e = x) l = None \\<Longrightarrow>\n    (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')\n 2. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x # xs <~~> l\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "unfolding del_eq"], ["proof (prove)\nusing this:\n  \\<not> x # xs <~~> l\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l) =\n    (case None of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "by simp"], ["proof (state)\nthis:\n  (x # xs <~~> l) =\n  (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n   | Some l' \\<Rightarrow> xs <~~> l')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "case (Some l')"], ["proof (state)\nthis:\n  delete_first (\\<lambda>e. e = x) l = Some l'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "note del_eq = this"], ["proof (state)\nthis:\n  delete_first (\\<lambda>e. e = x) l = Some l'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "from del_eq[unfolded delete_first_eq_some]"], ["proof (chain)\npicking this:\n  \\<exists>l1 xa l2.\n     xa = x \\<and>\n     (\\<forall>xa\\<in>set l1. xa \\<noteq> x) \\<and>\n     l = l1 @ xa # l2 \\<and> l' = l1 @ l2", "obtain l1 l2 where l_eq: \"l = l1 @ [x] @ l2\" and l'_eq: \"l' = l1 @ l2\""], ["proof (prove)\nusing this:\n  \\<exists>l1 xa l2.\n     xa = x \\<and>\n     (\\<forall>xa\\<in>set l1. xa \\<noteq> x) \\<and>\n     l = l1 @ xa # l2 \\<and> l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>l = l1 @ [x] @ l2; l' = l1 @ l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = l1 @ [x] @ l2\n  l' = l1 @ l2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "have \"(x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)", "from perm_append_swap [of l1 \"[x]\"]\n           perm_append2 [of \"l1 @ [x]\" \"x # l1\" l2]"], ["proof (chain)\npicking this:\n  l1 @ [x] <~~> [x] @ l1\n  l1 @ [x] <~~> x # l1 \\<Longrightarrow> (l1 @ [x]) @ l2 <~~> (x # l1) @ l2", "have \"l1 @ x # l2 <~~> x # (l1 @ l2)\""], ["proof (prove)\nusing this:\n  l1 @ [x] <~~> [x] @ l1\n  l1 @ [x] <~~> x # l1 \\<Longrightarrow> (l1 @ [x]) @ l2 <~~> (x # l1) @ l2\n\ngoal (1 subgoal):\n 1. l1 @ x # l2 <~~> x # l1 @ l2", "by simp"], ["proof (state)\nthis:\n  l1 @ x # l2 <~~> x # l1 @ l2\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)", "hence \"x # xs <~~> l1 @ x # l2 \\<longleftrightarrow> x # xs <~~> x # (l1 @ l2)\""], ["proof (prove)\nusing this:\n  l1 @ x # l2 <~~> x # l1 @ l2\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l1 @ x # l2) = (x # xs <~~> x # l1 @ l2)", "by (metis perm.trans perm_sym)"], ["proof (state)\nthis:\n  (x # xs <~~> l1 @ x # l2) = (x # xs <~~> x # l1 @ l2)\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x # xs <~~> l1 @ x # l2) = (x # xs <~~> x # l1 @ l2)\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)", "by simp"], ["proof (state)\nthis:\n  (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       delete_first (\\<lambda>e. e = x) l = Some a \\<Longrightarrow>\n       (x # xs <~~> l) =\n       (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n        | Some l' \\<Rightarrow> xs <~~> l')", "with del_eq l_eq l'_eq"], ["proof (chain)\npicking this:\n  delete_first (\\<lambda>e. e = x) l = Some l'\n  l = l1 @ [x] @ l2\n  l' = l1 @ l2\n  (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)", "show ?thesis"], ["proof (prove)\nusing this:\n  delete_first (\\<lambda>e. e = x) l = Some l'\n  l = l1 @ [x] @ l2\n  l' = l1 @ l2\n  (x # xs <~~> l1 @ x # l2) = (xs <~~> l1 @ l2)\n\ngoal (1 subgoal):\n 1. (x # xs <~~> l) =\n    (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n     | Some l' \\<Rightarrow> xs <~~> l')", "by simp"], ["proof (state)\nthis:\n  (x # xs <~~> l) =\n  (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n   | Some l' \\<Rightarrow> xs <~~> l')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x # xs <~~> l) =\n  (case delete_first (\\<lambda>e. e = x) l of None \\<Rightarrow> False\n   | Some l' \\<Rightarrow> xs <~~> l')\n\ngoal:\nNo subgoals!", "qed"], ["", "fun sorted_by  :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool)\\<Rightarrow> 'a list \\<Rightarrow> bool \"  where\n   \"sorted_by cmp [] = True\"\n | \"sorted_by cmp [_] = True\"\n | \"sorted_by cmp (x1 # x2 # xs) = ((cmp x1 x2) \\<and> sorted_by cmp (x2 # xs))\""], ["", "lemma sorted_by_lesseq [simp] :\n  \"sorted_by ((\\<le>) :: ('a::{linorder}) => 'a => bool) = sorted\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by (\\<le>) = sorted", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. sorted_by (\\<le>) x = sorted x", "fix l :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. sorted_by (\\<le>) x = sorted x", "show \"sorted_by (\\<le>) l = sorted l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by (\\<le>) l = sorted l", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_by (\\<le>) [] = sorted []\n 2. \\<And>a l.\n       sorted_by (\\<le>) l = sorted l \\<Longrightarrow>\n       sorted_by (\\<le>) (a # l) = sorted (a # l)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sorted_by (\\<le>) [] = sorted []\n 2. \\<And>a l.\n       sorted_by (\\<le>) l = sorted l \\<Longrightarrow>\n       sorted_by (\\<le>) (a # l) = sorted (a # l)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by (\\<le>) [] = sorted []", "by simp"], ["proof (state)\nthis:\n  sorted_by (\\<le>) [] = sorted []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       sorted_by (\\<le>) l = sorted l \\<Longrightarrow>\n       sorted_by (\\<le>) (a # l) = sorted (a # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       sorted_by (\\<le>) l = sorted l \\<Longrightarrow>\n       sorted_by (\\<le>) (a # l) = sorted (a # l)", "case (Cons x xs)"], ["proof (state)\nthis:\n  sorted_by (\\<le>) xs = sorted xs\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       sorted_by (\\<le>) l = sorted l \\<Longrightarrow>\n       sorted_by (\\<le>) (a # l) = sorted (a # l)", "thus ?case"], ["proof (prove)\nusing this:\n  sorted_by (\\<le>) xs = sorted xs\n\ngoal (1 subgoal):\n 1. sorted_by (\\<le>) (x # xs) = sorted (x # xs)", "by (cases xs) (simp_all del: sorted.simps(2) add: sorted2_simps)"], ["proof (state)\nthis:\n  sorted_by (\\<le>) (x # xs) = sorted (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_by (\\<le>) l = sorted l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_by_cons_imp :\n  \"sorted_by cmp (x # xs) \\<Longrightarrow> sorted_by cmp xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by cmp (x # xs) \\<Longrightarrow> sorted_by cmp xs", "by (cases xs) simp_all"], ["", "lemma sorted_by_cons_trans :\n  assumes trans_cmp: \"transp cmp\"\n  shows \"sorted_by cmp (x # xs) = ((\\<forall>x' \\<in> set xs . cmp x x') \\<and> sorted_by cmp xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by cmp (x # xs) =\n    ((\\<forall>x'\\<in>set xs. cmp x x') \\<and> sorted_by cmp xs)", "proof (induct xs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       sorted_by cmp [x] = (Ball (set []) (cmp x) \\<and> sorted_by cmp [])\n 2. \\<And>a xs x.\n       (\\<And>x.\n           sorted_by cmp (x # xs) =\n           (Ball (set xs) (cmp x) \\<and>\n            sorted_by cmp xs)) \\<Longrightarrow>\n       sorted_by cmp (x # a # xs) =\n       (Ball (set (a # xs)) (cmp x) \\<and> sorted_by cmp (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       sorted_by cmp [x] = (Ball (set []) (cmp x) \\<and> sorted_by cmp [])\n 2. \\<And>a xs x.\n       (\\<And>x.\n           sorted_by cmp (x # xs) =\n           (Ball (set xs) (cmp x) \\<and>\n            sorted_by cmp xs)) \\<Longrightarrow>\n       sorted_by cmp (x # a # xs) =\n       (Ball (set (a # xs)) (cmp x) \\<and> sorted_by cmp (a # xs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by cmp [x] =\n    ((\\<forall>a\\<in>set []. cmp x a) \\<and> sorted_by cmp [])", "by simp"], ["proof (state)\nthis:\n  sorted_by cmp [x] =\n  ((\\<forall>a\\<in>set []. cmp x a) \\<and> sorted_by cmp [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           sorted_by cmp (x # xs) =\n           (Ball (set xs) (cmp x) \\<and>\n            sorted_by cmp xs)) \\<Longrightarrow>\n       sorted_by cmp (x # a # xs) =\n       (Ball (set (a # xs)) (cmp x) \\<and> sorted_by cmp (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           sorted_by cmp (x # xs) =\n           (Ball (set xs) (cmp x) \\<and>\n            sorted_by cmp xs)) \\<Longrightarrow>\n       sorted_by cmp (x # a # xs) =\n       (Ball (set (a # xs)) (cmp x) \\<and> sorted_by cmp (a # xs))", "case (Cons x2 xs x1)"], ["proof (state)\nthis:\n  sorted_by cmp (?x # xs) =\n  ((\\<forall>a\\<in>set xs. cmp ?x a) \\<and> sorted_by cmp xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           sorted_by cmp (x # xs) =\n           (Ball (set xs) (cmp x) \\<and>\n            sorted_by cmp xs)) \\<Longrightarrow>\n       sorted_by cmp (x # a # xs) =\n       (Ball (set (a # xs)) (cmp x) \\<and> sorted_by cmp (a # xs))", "note ind_hyp = this"], ["proof (state)\nthis:\n  sorted_by cmp (?x # xs) =\n  ((\\<forall>a\\<in>set xs. cmp ?x a) \\<and> sorted_by cmp xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           sorted_by cmp (x # xs) =\n           (Ball (set xs) (cmp x) \\<and>\n            sorted_by cmp xs)) \\<Longrightarrow>\n       sorted_by cmp (x # a # xs) =\n       (Ball (set (a # xs)) (cmp x) \\<and> sorted_by cmp (a # xs))", "from trans_cmp"], ["proof (chain)\npicking this:\n  transp cmp", "show ?case"], ["proof (prove)\nusing this:\n  transp cmp\n\ngoal (1 subgoal):\n 1. sorted_by cmp (x1 # x2 # xs) =\n    ((\\<forall>a\\<in>set (x2 # xs). cmp x1 a) \\<and>\n     sorted_by cmp (x2 # xs))", "by (auto simp add: ind_hyp transp_def)"], ["proof (state)\nthis:\n  sorted_by cmp (x1 # x2 # xs) =\n  ((\\<forall>a\\<in>set (x2 # xs). cmp x1 a) \\<and> sorted_by cmp (x2 # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun insert_sort_insert_by  :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool)\\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list \"  where\n  \"insert_sort_insert_by cmp e ([]) = ( [e])\"\n| \"insert_sort_insert_by cmp e (x # xs) = ( if cmp e x then (e # (x # xs)) else x # (insert_sort_insert_by cmp e xs))\""], ["", "lemma insert_sort_insert_by_length [simp] :\n  \"length (insert_sort_insert_by cmp e l) = Suc (length l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insert_sort_insert_by cmp e l) = Suc (length l)", "by (induct l) auto"], ["", "lemma insert_sort_insert_by_set [simp] :\n  \"set (insert_sort_insert_by cmp e l) = insert e (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_sort_insert_by cmp e l) = insert e (set l)", "by (induct l) auto"], ["", "lemma insert_sort_insert_by_perm :\n  \"(insert_sort_insert_by cmp e l) <~~> (e # l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_sort_insert_by cmp e l <~~> e # l", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. insert_sort_insert_by cmp e [] <~~> [e]\n 2. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. insert_sort_insert_by cmp e [] <~~> [e]\n 2. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_sort_insert_by cmp e [] <~~> [e]", "by simp"], ["proof (state)\nthis:\n  insert_sort_insert_by cmp e [] <~~> [e]\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "case (Cons e2 l')"], ["proof (state)\nthis:\n  insert_sort_insert_by cmp e l' <~~> e # l'\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "note ind_hyp = this"], ["proof (state)\nthis:\n  insert_sort_insert_by cmp e l' <~~> e # l'\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "have \"e2 # e # l' <~~> e # e2 # l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2 # e # l' <~~> e # e2 # l'", "by (rule perm.swap)"], ["proof (state)\nthis:\n  e2 # e # l' <~~> e # e2 # l'\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "hence \"e2 # insert_sort_insert_by cmp e l' <~~> e # e2 # l'\""], ["proof (prove)\nusing this:\n  e2 # e # l' <~~> e # e2 # l'\n\ngoal (1 subgoal):\n 1. e2 # insert_sort_insert_by cmp e l' <~~> e # e2 # l'", "using ind_hyp"], ["proof (prove)\nusing this:\n  e2 # e # l' <~~> e # e2 # l'\n  insert_sort_insert_by cmp e l' <~~> e # l'\n\ngoal (1 subgoal):\n 1. e2 # insert_sort_insert_by cmp e l' <~~> e # e2 # l'", "by (metis cons_perm_eq perm.trans)"], ["proof (state)\nthis:\n  e2 # insert_sort_insert_by cmp e l' <~~> e # e2 # l'\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_insert_by cmp e l <~~> e # l \\<Longrightarrow>\n       insert_sort_insert_by cmp e (a # l) <~~> e # a # l", "thus ?case"], ["proof (prove)\nusing this:\n  e2 # insert_sort_insert_by cmp e l' <~~> e # e2 # l'\n\ngoal (1 subgoal):\n 1. insert_sort_insert_by cmp e (e2 # l') <~~> e # e2 # l'", "by simp"], ["proof (state)\nthis:\n  insert_sort_insert_by cmp e (e2 # l') <~~> e # e2 # l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_sort_insert_by_sorted_by :\nassumes cmp_cases: \"\\<And>y. y \\<in> set l \\<Longrightarrow> \\<not> (cmp e y) \\<Longrightarrow> cmp y e\"\nassumes cmp_trans: \"transp cmp\"\nshows \"sorted_by cmp l \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by cmp l \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e l)", "using cmp_cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set l; \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (1 subgoal):\n 1. sorted_by cmp l \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e l)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_by cmp [];\n     \\<And>y.\n        \\<lbrakk>y \\<in> set []; \\<not> cmp e y\\<rbrakk>\n        \\<Longrightarrow> cmp y e\\<rbrakk>\n    \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "case Nil"], ["proof (state)\nthis:\n  sorted_by cmp []\n  \\<lbrakk>?y \\<in> set []; \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_by cmp [];\n     \\<And>y.\n        \\<lbrakk>y \\<in> set []; \\<not> cmp e y\\<rbrakk>\n        \\<Longrightarrow> cmp y e\\<rbrakk>\n    \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted_by cmp []\n  \\<lbrakk>?y \\<in> set []; \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (1 subgoal):\n 1. sorted_by cmp (insert_sort_insert_by cmp e [])", "by simp"], ["proof (state)\nthis:\n  sorted_by cmp (insert_sort_insert_by cmp e [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "case (Cons x1 l')"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_by cmp l';\n   \\<And>y.\n      \\<lbrakk>y \\<in> set l'; \\<not> cmp e y\\<rbrakk>\n      \\<Longrightarrow> cmp y e\\<rbrakk>\n  \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e l')\n  sorted_by cmp (x1 # l')\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "note ind_hyp = Cons(1)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_by cmp l';\n   \\<And>y.\n      \\<lbrakk>y \\<in> set l'; \\<not> cmp e y\\<rbrakk>\n      \\<Longrightarrow> cmp y e\\<rbrakk>\n  \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e l')\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "note sorted_x1_l' = Cons(2)"], ["proof (state)\nthis:\n  sorted_by cmp (x1 # l')\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "note cmp_cases = Cons(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>sorted_by cmp l;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set l; \\<not> cmp e y\\<rbrakk>\n                    \\<Longrightarrow> cmp y e\\<rbrakk>\n                \\<Longrightarrow> sorted_by cmp\n                                   (insert_sort_insert_by cmp e l);\n        sorted_by cmp (a # l);\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (a # l); \\<not> cmp e y\\<rbrakk>\n           \\<Longrightarrow> cmp y e\\<rbrakk>\n       \\<Longrightarrow> sorted_by cmp (insert_sort_insert_by cmp e (a # l))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "proof (cases l')"], ["proof (state)\ngoal (2 subgoals):\n 1. l' = [] \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n 2. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "case Nil"], ["proof (state)\nthis:\n  l' = []\n\ngoal (2 subgoals):\n 1. l' = [] \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n 2. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "with cmp_cases"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n  l' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n  l' = []\n\ngoal (1 subgoal):\n 1. sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "by simp"], ["proof (state)\nthis:\n  sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "case (Cons x2 l'')"], ["proof (state)\nthis:\n  l' = x2 # l''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "note l'_eq = this"], ["proof (state)\nthis:\n  l' = x2 # l''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "from l'_eq sorted_x1_l'"], ["proof (chain)\npicking this:\n  l' = x2 # l''\n  sorted_by cmp (x1 # l')", "have \"cmp x1 x2\" \"sorted_by cmp l'\""], ["proof (prove)\nusing this:\n  l' = x2 # l''\n  sorted_by cmp (x1 # l')\n\ngoal (1 subgoal):\n 1. cmp x1 x2 &&& sorted_by cmp l'", "by simp_all"], ["proof (state)\nthis:\n  cmp x1 x2\n  sorted_by cmp l'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow>\n       sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "proof (cases \"cmp e x1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n 2. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "case True"], ["proof (state)\nthis:\n  cmp e x1\n\ngoal (2 subgoals):\n 1. cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n 2. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "with \\<open>cmp x1 x2\\<close> \\<open>sorted_by cmp l'\\<close>"], ["proof (chain)\npicking this:\n  cmp x1 x2\n  sorted_by cmp l'\n  cmp e x1", "have \"sorted_by cmp (x1 # l')\""], ["proof (prove)\nusing this:\n  cmp x1 x2\n  sorted_by cmp l'\n  cmp e x1\n\ngoal (1 subgoal):\n 1. sorted_by cmp (x1 # l')", "unfolding l'_eq"], ["proof (prove)\nusing this:\n  cmp x1 x2\n  sorted_by cmp (x2 # l'')\n  cmp e x1\n\ngoal (1 subgoal):\n 1. sorted_by cmp (x1 # x2 # l'')", "by (simp)"], ["proof (state)\nthis:\n  sorted_by cmp (x1 # l')\n\ngoal (2 subgoals):\n 1. cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n 2. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "with \\<open>cmp e x1\\<close>"], ["proof (chain)\npicking this:\n  cmp e x1\n  sorted_by cmp (x1 # l')", "show ?thesis"], ["proof (prove)\nusing this:\n  cmp e x1\n  sorted_by cmp (x1 # l')\n\ngoal (1 subgoal):\n 1. sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "by simp"], ["proof (state)\nthis:\n  sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n\ngoal (1 subgoal):\n 1. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "case False"], ["proof (state)\nthis:\n  \\<not> cmp e x1\n\ngoal (1 subgoal):\n 1. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "with cmp_cases"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n  \\<not> cmp e x1", "have \"cmp x1 e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n  \\<not> cmp e x1\n\ngoal (1 subgoal):\n 1. cmp x1 e", "by simp"], ["proof (state)\nthis:\n  cmp x1 e\n\ngoal (1 subgoal):\n 1. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "have \"\\<And>x'.  x' \\<in> set l' \\<Longrightarrow> cmp x1 x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> set l' \\<Longrightarrow> cmp x1 x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> set l' \\<Longrightarrow> cmp x1 x'", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> set l' \\<Longrightarrow> cmp x1 x'", "assume \"x' \\<in> set l'\""], ["proof (state)\nthis:\n  x' \\<in> set l'\n\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> set l' \\<Longrightarrow> cmp x1 x'", "hence \"x' = x2 \\<or> cmp x2 x'\""], ["proof (prove)\nusing this:\n  x' \\<in> set l'\n\ngoal (1 subgoal):\n 1. x' = x2 \\<or> cmp x2 x'", "using \\<open>sorted_by cmp l'\\<close> l'_eq sorted_by_cons_trans [OF cmp_trans, of x2 l'']"], ["proof (prove)\nusing this:\n  x' \\<in> set l'\n  sorted_by cmp l'\n  l' = x2 # l''\n  sorted_by cmp (x2 # l'') =\n  ((\\<forall>x'\\<in>set l''. cmp x2 x') \\<and> sorted_by cmp l'')\n\ngoal (1 subgoal):\n 1. x' = x2 \\<or> cmp x2 x'", "by auto"], ["proof (state)\nthis:\n  x' = x2 \\<or> cmp x2 x'\n\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> set l' \\<Longrightarrow> cmp x1 x'", "with transpD[OF cmp_trans, of x1 x2 x'] \\<open>cmp x1 x2\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>cmp x1 x2; cmp x2 x'\\<rbrakk> \\<Longrightarrow> cmp x1 x'\n  cmp x1 x2\n  x' = x2 \\<or> cmp x2 x'", "show \"cmp x1 x'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cmp x1 x2; cmp x2 x'\\<rbrakk> \\<Longrightarrow> cmp x1 x'\n  cmp x1 x2\n  x' = x2 \\<or> cmp x2 x'\n\ngoal (1 subgoal):\n 1. cmp x1 x'", "by blast"], ["proof (state)\nthis:\n  cmp x1 x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x' \\<in> set l' \\<Longrightarrow> cmp x1 ?x'\n\ngoal (1 subgoal):\n 1. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "hence \"sorted_by cmp (x1 # insert_sort_insert_by cmp e l')\""], ["proof (prove)\nusing this:\n  ?x' \\<in> set l' \\<Longrightarrow> cmp x1 ?x'\n\ngoal (1 subgoal):\n 1. sorted_by cmp (x1 # insert_sort_insert_by cmp e l')", "using ind_hyp [OF \\<open>sorted_by cmp l'\\<close>] \\<open>cmp x1 e\\<close> cmp_cases"], ["proof (prove)\nusing this:\n  ?x' \\<in> set l' \\<Longrightarrow> cmp x1 ?x'\n  (\\<And>y.\n      \\<lbrakk>y \\<in> set l'; \\<not> cmp e y\\<rbrakk>\n      \\<Longrightarrow> cmp y e) \\<Longrightarrow>\n  sorted_by cmp (insert_sort_insert_by cmp e l')\n  cmp x1 e\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (1 subgoal):\n 1. sorted_by cmp (x1 # insert_sort_insert_by cmp e l')", "unfolding sorted_by_cons_trans[OF cmp_trans]"], ["proof (prove)\nusing this:\n  ?x' \\<in> set l' \\<Longrightarrow> cmp x1 ?x'\n  (\\<And>y.\n      \\<lbrakk>y \\<in> set l'; \\<not> cmp e y\\<rbrakk>\n      \\<Longrightarrow> cmp y e) \\<Longrightarrow>\n  sorted_by cmp (insert_sort_insert_by cmp e l')\n  cmp x1 e\n  \\<lbrakk>?y \\<in> set (x1 # l'); \\<not> cmp e ?y\\<rbrakk>\n  \\<Longrightarrow> cmp ?y e\n\ngoal (1 subgoal):\n 1. Ball (set (insert_sort_insert_by cmp e l')) (cmp x1) \\<and>\n    sorted_by cmp (insert_sort_insert_by cmp e l')", "by simp"], ["proof (state)\nthis:\n  sorted_by cmp (x1 # insert_sort_insert_by cmp e l')\n\ngoal (1 subgoal):\n 1. \\<not> cmp e x1 \\<Longrightarrow>\n    sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "with \\<open>\\<not>(cmp e x1)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> cmp e x1\n  sorted_by cmp (x1 # insert_sort_insert_by cmp e l')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> cmp e x1\n  sorted_by cmp (x1 # insert_sort_insert_by cmp e l')\n\ngoal (1 subgoal):\n 1. sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))", "by simp"], ["proof (state)\nthis:\n  sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_by cmp (insert_sort_insert_by cmp e (x1 # l'))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun insert_sort_by :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \"  where\n    \"insert_sort_by cmp [] = []\"\n  | \"insert_sort_by cmp (x # xs) = insert_sort_insert_by cmp x (insert_sort_by cmp xs)\""], ["", "lemma insert_sort_by_perm :\n  \"(insert_sort_by cmp l) <~~> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_sort_by cmp l <~~> l", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. insert_sort_by cmp [] <~~> []\n 2. \\<And>a l.\n       insert_sort_by cmp l <~~> l \\<Longrightarrow>\n       insert_sort_by cmp (a # l) <~~> a # l", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. insert_sort_by cmp [] <~~> []\n 2. \\<And>a l.\n       insert_sort_by cmp l <~~> l \\<Longrightarrow>\n       insert_sort_by cmp (a # l) <~~> a # l", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_sort_by cmp [] <~~> []", "by simp"], ["proof (state)\nthis:\n  insert_sort_by cmp [] <~~> []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_by cmp l <~~> l \\<Longrightarrow>\n       insert_sort_by cmp (a # l) <~~> a # l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_by cmp l <~~> l \\<Longrightarrow>\n       insert_sort_by cmp (a # l) <~~> a # l", "case (Cons x l)"], ["proof (state)\nthis:\n  insert_sort_by cmp l <~~> l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       insert_sort_by cmp l <~~> l \\<Longrightarrow>\n       insert_sort_by cmp (a # l) <~~> a # l", "thus ?case"], ["proof (prove)\nusing this:\n  insert_sort_by cmp l <~~> l\n\ngoal (1 subgoal):\n 1. insert_sort_by cmp (x # l) <~~> x # l", "by simp (metis cons_perm_eq insert_sort_insert_by_perm perm.trans)"], ["proof (state)\nthis:\n  insert_sort_by cmp (x # l) <~~> x # l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_sort_by_length [simp]:\n  \"length (insert_sort_by cmp l) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insert_sort_by cmp l) = length l", "by (induct l) auto"], ["", "lemma insert_sort_by_set [simp]:\n  \"set (insert_sort_by cmp l) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_sort_by cmp l) = set l", "by (induct l) auto"], ["", "definition sort_by where\n  \"sort_by = insert_sort_by\""], ["", "lemma sort_by_simps [simp]:\n  \"length (sort_by cmp l) = length l\"\n  \"set (sort_by cmp l) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sort_by cmp l) = length l &&& set (sort_by cmp l) = set l", "unfolding sort_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insert_sort_by cmp l) = length l &&&\n    set (insert_sort_by cmp l) = set l", "by simp_all"], ["", "lemma sort_by_perm :\n  \"sort_by cmp l <~~> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_by cmp l <~~> l", "unfolding sort_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_sort_by cmp l <~~> l", "by (simp add: insert_sort_by_perm)"], ["", "subsection \\<open>Maps\\<close>"], ["", "definition map_image :: \"('v \\<Rightarrow> 'w) \\<Rightarrow> ('k, 'v) map \\<Rightarrow> ('k, 'w) map\" where\n  \"map_image f m = (\\<lambda>k. map_option f (m k))\""], ["", "definition map_domain_image :: \"('k \\<Rightarrow> 'v \\<Rightarrow> 'w) \\<Rightarrow> ('k, 'v) map \\<Rightarrow> ('k, 'w) map\" where\n  \"map_domain_image f m = (\\<lambda>k. map_option (f k) (m k))\""], ["", "lemma map_image_simps [simp]:\n  \"(map_image f m) k = None \\<longleftrightarrow> m k = None\"\n  \"(map_image f m) k = Some x \\<longleftrightarrow> (\\<exists>x'. (m k = Some x') \\<and> (x = f x'))\"\n  \"(map_image f Map.empty) = Map.empty\"\n  \"(map_image f (m (k \\<mapsto> v)) = (map_image f m) (k \\<mapsto> f v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map_image f m k = None) = (m k = None) &&&\n     (map_image f m k = Some x) =\n     (\\<exists>x'. m k = Some x' \\<and> x = f x')) &&&\n    map_image f Map.empty = Map.empty &&&\n    map_image f (m(k \\<mapsto> v)) = map_image f m(k \\<mapsto> f v)", "unfolding map_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map_option f (m k) = None) = (m k = None) &&&\n     (map_option f (m k) = Some x) =\n     (\\<exists>x'. m k = Some x' \\<and> x = f x')) &&&\n    (\\<lambda>k. map_option f None) = Map.empty &&&\n    (\\<lambda>ka. map_option f ((m(k \\<mapsto> v)) ka)) =\n    (\\<lambda>k. map_option f (m k))(k \\<mapsto> f v)", "by auto"], ["", "lemma map_image_dom_ran [simp]:\n  \"dom (map_image f m) = dom m\"\n  \"ran (map_image f m) = f ` (ran m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_image f m) = dom m &&& ran (map_image f m) = f ` ran m", "unfolding dom_def ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. map_image f m a \\<noteq> None} = {a. m a \\<noteq> None} &&&\n    {b. \\<exists>a. map_image f m a = Some b} =\n    f ` {b. \\<exists>a. m a = Some b}", "by auto"], ["", "definition map_to_set :: \"('k, 'v) map \\<Rightarrow> ('k * 'v) set\" where\n  \"map_to_set m = { (k, v) . m k = Some v }\""], ["", "lemma map_to_set_simps [simp] :\n  \"map_to_set Map.empty = {}\"  (is ?g1)\n  \"map_to_set (m ((k::'k) \\<mapsto> (v::'v))) = (insert (k, v) (map_to_set (m |` (- {k}))))\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set Map.empty = {} &&&\n    map_to_set (m(k \\<mapsto> v)) =\n    insert (k, v) (map_to_set (m |` (- {k})))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. map_to_set Map.empty = {}\n 2. map_to_set (m(k \\<mapsto> v)) =\n    insert (k, v) (map_to_set (m |` (- {k})))", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set Map.empty = {}", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(k, v). None = Some v} = {}", "by simp"], ["proof (state)\nthis:\n  map_to_set Map.empty = {}\n\ngoal (1 subgoal):\n 1. map_to_set (m(k \\<mapsto> v)) =\n    insert (k, v) (map_to_set (m |` (- {k})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_to_set (m(k \\<mapsto> v)) =\n    insert (k, v) (map_to_set (m |` (- {k})))", "show ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (m(k \\<mapsto> v)) =\n    insert (k, v) (map_to_set (m |` (- {k})))", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> map_to_set (m(k \\<mapsto> v))) =\n       (x \\<in> insert (k, v) (map_to_set (m |` (- {k}))))", "fix kv :: \"('k * 'v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> map_to_set (m(k \\<mapsto> v))) =\n       (x \\<in> insert (k, v) (map_to_set (m |` (- {k}))))", "obtain k' v' where kv_eq[simp]: \"kv = (k', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v'. kv = (k', v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  kv = (k', v')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> map_to_set (m(k \\<mapsto> v))) =\n       (x \\<in> insert (k, v) (map_to_set (m |` (- {k}))))", "show \"(kv \\<in> map_to_set (m(k \\<mapsto> v))) = (kv \\<in> insert (k, v) (map_to_set (m |` (- {k}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (kv \\<in> map_to_set (m(k \\<mapsto> v))) =\n    (kv \\<in> insert (k, v) (map_to_set (m |` (- {k}))))", "by (auto simp add: map_to_set_def)"], ["proof (state)\nthis:\n  (kv \\<in> map_to_set (m(k \\<mapsto> v))) =\n  (kv \\<in> insert (k, v) (map_to_set (m |` (- {k}))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_to_set (m(k \\<mapsto> v)) = insert (k, v) (map_to_set (m |` (- {k})))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sets\\<close>"], ["", "definition \"set_choose s \\<equiv> (SOME x. (x \\<in> s))\""], ["", "definition without_trans_edges :: \"('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a) set\" where\n  \"without_trans_edges S \\<equiv>\n     let ts = trancl S in\n       { (x, y) \\<in> S. \\<forall>z \\<in> snd ` S. x \\<noteq> z \\<and> y \\<noteq> z \\<longrightarrow> \\<not> ((x, z) \\<in> ts \\<and> (z, y) \\<in> ts)}\""], ["", "definition unbounded_lfp :: \"'a set \\<Rightarrow> ('a set \\<Rightarrow> 'a set) \\<Rightarrow> 'a set\" where\n  \"unbounded_lfp S f \\<equiv>\n     while (\\<lambda>x. x \\<subset> S) f S\""], ["", "definition unbounded_gfp :: \"'a set \\<Rightarrow> ('a set \\<Rightarrow> 'a set) \\<Rightarrow> 'a set\" where\n  \"unbounded_gfp S f \\<equiv>\n     while (\\<lambda>x. S \\<subset> x) f S\""], ["", "lemma set_choose_thm[simp]:\n  \"s \\<noteq> {} \\<Longrightarrow> (set_choose s) \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> {} \\<Longrightarrow> set_choose s \\<in> s", "unfolding set_choose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> {} \\<Longrightarrow> (SOME x. x \\<in> s) \\<in> s", "by (rule someI_ex) auto"], ["", "lemma set_choose_sing [simp]:\n  \"set_choose {x} = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_choose {x} = x", "unfolding set_choose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME xa. xa \\<in> {x}) = x", "by auto"], ["", "lemma set_choose_code [code]:\n  \"set_choose (set [x]) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_choose (set [x]) = x", "by auto"], ["", "lemma set_choose_in [intro] :\n  assumes \"s \\<noteq> {}\"\n  shows \"set_choose s \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_choose s \\<in> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_choose s \\<in> s", "from \\<open>s \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> {}", "obtain x where \"x \\<in> s\""], ["proof (prove)\nusing this:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> s\n\ngoal (1 subgoal):\n 1. set_choose s \\<in> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> s\n\ngoal (1 subgoal):\n 1. set_choose s \\<in> s", "unfolding set_choose_def"], ["proof (prove)\nusing this:\n  x \\<in> s\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> s) \\<in> s", "by (rule someI)"], ["proof (state)\nthis:\n  set_choose s \\<in> s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition set_case where\n  \"set_case s c_empty c_sing c_else =\n    (if (s = {}) then c_empty else\n    (if (card s = 1) then c_sing (set_choose s) else\n       c_else))\""], ["", "lemma set_case_simps [simp] :\n  \"set_case {} c_empty c_sing c_else = c_empty\"\n  \"set_case {x} c_empty c_sing c_else = c_sing x\"\n  \"card s > 1 \\<Longrightarrow> set_case s c_empty c_sing c_else = c_else\"\n  \"\\<not>(finite s) \\<Longrightarrow> set_case s c_empty c_sing c_else = c_else\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_case {} c_empty c_sing c_else = c_empty &&&\n     set_case {x} c_empty c_sing c_else = c_sing x) &&&\n    (1 < card s \\<Longrightarrow>\n     set_case s c_empty c_sing c_else = c_else) &&&\n    (infinite s \\<Longrightarrow> set_case s c_empty c_sing c_else = c_else)", "unfolding set_case_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if {} = {} then c_empty\n      else if card {} = 1 then c_sing (set_choose {}) else c_else) =\n     c_empty &&&\n     (if {x} = {} then c_empty\n      else if card {x} = 1 then c_sing (set_choose {x}) else c_else) =\n     c_sing x) &&&\n    (1 < card s \\<Longrightarrow>\n     (if s = {} then c_empty\n      else if card s = 1 then c_sing (set_choose s) else c_else) =\n     c_else) &&&\n    (infinite s \\<Longrightarrow>\n     (if s = {} then c_empty\n      else if card s = 1 then c_sing (set_choose s) else c_else) =\n     c_else)", "by auto"], ["", "lemma set_case_simp_insert2 [simp] :\nassumes x12_neq: \"x1 \\<noteq> x2\"\nshows \"set_case (insert x1 (insert x2 xs))  c_empty c_sing c_else = c_else\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "proof (cases \"finite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else\n 2. infinite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "case False"], ["proof (state)\nthis:\n  infinite xs\n\ngoal (2 subgoals):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else\n 2. infinite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite xs\n\ngoal (1 subgoal):\n 1. set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "by (simp)"], ["proof (state)\nthis:\n  set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else\n\ngoal (1 subgoal):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "case True"], ["proof (state)\nthis:\n  finite xs\n\ngoal (1 subgoal):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "note fin_xs = this"], ["proof (state)\nthis:\n  finite xs\n\ngoal (1 subgoal):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "have \"card {x1,x2} \\<le> card (insert x1 (insert x2 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x1, x2} \\<le> card (insert x1 (insert x2 xs))", "by (rule card_mono) (auto simp add: fin_xs)"], ["proof (state)\nthis:\n  card {x1, x2} \\<le> card (insert x1 (insert x2 xs))\n\ngoal (1 subgoal):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "with x12_neq"], ["proof (chain)\npicking this:\n  x1 \\<noteq> x2\n  card {x1, x2} \\<le> card (insert x1 (insert x2 xs))", "have \"1 < card (insert x1 (insert x2 xs))\""], ["proof (prove)\nusing this:\n  x1 \\<noteq> x2\n  card {x1, x2} \\<le> card (insert x1 (insert x2 xs))\n\ngoal (1 subgoal):\n 1. 1 < card (insert x1 (insert x2 xs))", "by simp"], ["proof (state)\nthis:\n  1 < card (insert x1 (insert x2 xs))\n\ngoal (1 subgoal):\n 1. finite xs \\<Longrightarrow>\n    set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 < card (insert x1 (insert x2 xs))\n\ngoal (1 subgoal):\n 1. set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else", "by auto"], ["proof (state)\nthis:\n  set_case (insert x1 (insert x2 xs)) c_empty c_sing c_else = c_else\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_case_code [code] :\n  \"set_case (set []) c_empty c_sing c_else = c_empty\"\n  \"set_case (set [x]) c_empty c_sing c_else = c_sing x\"\n  \"set_case (set (x1 # x2 # xs)) c_empty c_sing c_else =\n   (if (x1 = x2) then\n     set_case (set (x2 # xs)) c_empty c_sing c_else\n   else\n     c_else)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_case (set []) c_empty c_sing c_else = c_empty &&&\n    set_case (set [x]) c_empty c_sing c_else = c_sing x &&&\n    set_case (set (x1 # x2 # xs)) c_empty c_sing c_else =\n    (if x1 = x2 then set_case (set (x2 # xs)) c_empty c_sing c_else\n     else c_else)", "by auto"], ["", "definition set_lfp:: \"'a set \\<Rightarrow> ('a set \\<Rightarrow> 'a set) \\<Rightarrow> 'a set\" where\n  \"set_lfp s f = lfp (\\<lambda>s'. f s' \\<union> s)\""], ["", "lemma set_lfp_tail_rec_def :\nassumes mono_f: \"mono f\"\nshows \"set_lfp s f = (if (f s) \\<subseteq> s then s else (set_lfp (s \\<union> f s) f))\" (is \"?ls = ?rs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "proof (cases \"f s \\<subseteq> s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n 2. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "case True"], ["proof (state)\nthis:\n  f s \\<subseteq> s\n\ngoal (2 subgoals):\n 1. f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n 2. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "note fs_sub_s = this"], ["proof (state)\nthis:\n  f s \\<subseteq> s\n\ngoal (2 subgoals):\n 1. f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n 2. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "from fs_sub_s"], ["proof (chain)\npicking this:\n  f s \\<subseteq> s", "have \"\\<Inter>{u. f u \\<union> s \\<subseteq> u} = s\""], ["proof (prove)\nusing this:\n  f s \\<subseteq> s\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u} = s", "by auto"], ["proof (state)\nthis:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u} = s\n\ngoal (2 subgoals):\n 1. f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n 2. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "hence \"?ls = s\""], ["proof (prove)\nusing this:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u} = s\n\ngoal (1 subgoal):\n 1. set_lfp s f = s", "unfolding set_lfp_def lfp_def"], ["proof (prove)\nusing this:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u} = s\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u} = s", "."], ["proof (state)\nthis:\n  set_lfp s f = s\n\ngoal (2 subgoals):\n 1. f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n 2. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "with fs_sub_s"], ["proof (chain)\npicking this:\n  f s \\<subseteq> s\n  set_lfp s f = s", "show \"?ls = ?rs\""], ["proof (prove)\nusing this:\n  f s \\<subseteq> s\n  set_lfp s f = s\n\ngoal (1 subgoal):\n 1. set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "by simp"], ["proof (state)\nthis:\n  set_lfp s f =\n  (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "case False"], ["proof (state)\nthis:\n  \\<not> f s \\<subseteq> s\n\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "note not_fs_sub_s = this"], ["proof (state)\nthis:\n  \\<not> f s \\<subseteq> s\n\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "from mono_f"], ["proof (chain)\npicking this:\n  mono f", "have mono_f': \"mono (\\<lambda>s'. f s' \\<union> s)\""], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. mono (\\<lambda>s'. f s' \\<union> s)", "unfolding mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. x \\<subseteq> y \\<longrightarrow> f x \\<subseteq> f y\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       f x \\<union> s \\<subseteq> f y \\<union> s", "by auto"], ["proof (state)\nthis:\n  mono (\\<lambda>s'. f s' \\<union> s)\n\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "have \"\\<Inter>{u. f u \\<union> s \\<subseteq> u} = \\<Inter>{u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\" (is \"\\<Inter>?S1 = \\<Inter>?S2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u} =\n    \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n 2. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "have \"?S2 \\<subseteq> ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> {u. f u \\<union> s \\<subseteq> u}", "by auto"], ["proof (state)\nthis:\n  {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n  \\<subseteq> {u. f u \\<union> s \\<subseteq> u}\n\ngoal (2 subgoals):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n 2. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "thus \"\\<Inter>?S1 \\<subseteq> \\<Inter>?S2\""], ["proof (prove)\nusing this:\n  {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n  \\<subseteq> {u. f u \\<union> s \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}", "by (rule Inf_superset_mono)"], ["proof (state)\nthis:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n  \\<subseteq> \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "assume \"e \\<in> \\<Inter>?S2\""], ["proof (state)\nthis:\n  e \\<in> \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "hence S2_prop: \"\\<And>s'. f s' \\<subseteq> s' \\<Longrightarrow> s \\<subseteq> s' \\<Longrightarrow> f s \\<subseteq> s' \\<Longrightarrow> e \\<in> s'\""], ["proof (prove)\nusing this:\n  e \\<in> \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>f s' \\<subseteq> s'; s \\<subseteq> s';\n        f s \\<subseteq> s'\\<rbrakk>\n       \\<Longrightarrow> e \\<in> s'", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>f ?s' \\<subseteq> ?s'; s \\<subseteq> ?s';\n   f s \\<subseteq> ?s'\\<rbrakk>\n  \\<Longrightarrow> e \\<in> ?s'\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>f ?s' \\<subseteq> ?s'; s \\<subseteq> ?s';\n   f s \\<subseteq> ?s'\\<rbrakk>\n  \\<Longrightarrow> e \\<in> ?s'\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "fix s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "assume \"f s' \\<subseteq> s'\" \"s \\<subseteq> s'\""], ["proof (state)\nthis:\n  f s' \\<subseteq> s'\n  s \\<subseteq> s'\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "from mono_f \\<open>s \\<subseteq> s'\\<close>"], ["proof (chain)\npicking this:\n  mono f\n  s \\<subseteq> s'", "have \"f s \\<subseteq> f s'\""], ["proof (prove)\nusing this:\n  mono f\n  s \\<subseteq> s'\n\ngoal (1 subgoal):\n 1. f s \\<subseteq> f s'", "unfolding mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. x \\<subseteq> y \\<longrightarrow> f x \\<subseteq> f y\n  s \\<subseteq> s'\n\ngoal (1 subgoal):\n 1. f s \\<subseteq> f s'", "by simp"], ["proof (state)\nthis:\n  f s \\<subseteq> f s'\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "with \\<open>f s' \\<subseteq> s'\\<close>"], ["proof (chain)\npicking this:\n  f s' \\<subseteq> s'\n  f s \\<subseteq> f s'", "have \"f s \\<subseteq> s'\""], ["proof (prove)\nusing this:\n  f s' \\<subseteq> s'\n  f s \\<subseteq> f s'\n\ngoal (1 subgoal):\n 1. f s \\<subseteq> s'", "by simp"], ["proof (state)\nthis:\n  f s \\<subseteq> s'\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "with \\<open>f s' \\<subseteq> s'\\<close> \\<open>s \\<subseteq> s'\\<close> S2_prop"], ["proof (chain)\npicking this:\n  f s' \\<subseteq> s'\n  s \\<subseteq> s'\n  \\<lbrakk>f ?s' \\<subseteq> ?s'; s \\<subseteq> ?s';\n   f s \\<subseteq> ?s'\\<rbrakk>\n  \\<Longrightarrow> e \\<in> ?s'\n  f s \\<subseteq> s'", "have \"e \\<in> s'\""], ["proof (prove)\nusing this:\n  f s' \\<subseteq> s'\n  s \\<subseteq> s'\n  \\<lbrakk>f ?s' \\<subseteq> ?s'; s \\<subseteq> ?s';\n   f s \\<subseteq> ?s'\\<rbrakk>\n  \\<Longrightarrow> e \\<in> ?s'\n  f s \\<subseteq> s'\n\ngoal (1 subgoal):\n 1. e \\<in> s'", "by simp"], ["proof (state)\nthis:\n  e \\<in> s'\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f ?s'2 \\<subseteq> ?s'2; s \\<subseteq> ?s'2\\<rbrakk>\n  \\<Longrightarrow> e \\<in> ?s'2\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "hence \"e \\<in> \\<Inter>?S1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>f ?s'2 \\<subseteq> ?s'2; s \\<subseteq> ?s'2\\<rbrakk>\n  \\<Longrightarrow> e \\<in> ?s'2\n\ngoal (1 subgoal):\n 1. e \\<in> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "by simp"], ["proof (state)\nthis:\n  e \\<in> \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "}"], ["proof (state)\nthis:\n  ?e2\n  \\<in> \\<Inter>\n         {u. f u \\<union> (s \\<union> f s) \\<subseteq> u} \\<Longrightarrow>\n  ?e2 \\<in> \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "thus \"\\<Inter>?S2 \\<subseteq> \\<Inter>?S1\""], ["proof (prove)\nusing this:\n  ?e2\n  \\<in> \\<Inter>\n         {u. f u \\<union> (s \\<union> f s) \\<subseteq> u} \\<Longrightarrow>\n  ?e2 \\<in> \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n    \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}", "by auto"], ["proof (state)\nthis:\n  \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n  \\<subseteq> \\<Inter> {u. f u \\<union> s \\<subseteq> u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u} =\n  \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "hence \"?ls = (set_lfp (s \\<union> f s) f)\""], ["proof (prove)\nusing this:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u} =\n  \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. set_lfp s f = set_lfp (s \\<union> f s) f", "unfolding set_lfp_def lfp_def"], ["proof (prove)\nusing this:\n  \\<Inter> {u. f u \\<union> s \\<subseteq> u} =\n  \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}\n\ngoal (1 subgoal):\n 1. \\<Inter> {u. f u \\<union> s \\<subseteq> u} =\n    \\<Inter> {u. f u \\<union> (s \\<union> f s) \\<subseteq> u}", "."], ["proof (state)\nthis:\n  set_lfp s f = set_lfp (s \\<union> f s) f\n\ngoal (1 subgoal):\n 1. \\<not> f s \\<subseteq> s \\<Longrightarrow>\n    set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "with not_fs_sub_s"], ["proof (chain)\npicking this:\n  \\<not> f s \\<subseteq> s\n  set_lfp s f = set_lfp (s \\<union> f s) f", "show \"?ls = ?rs\""], ["proof (prove)\nusing this:\n  \\<not> f s \\<subseteq> s\n  set_lfp s f = set_lfp (s \\<union> f s) f\n\ngoal (1 subgoal):\n 1. set_lfp s f =\n    (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)", "by simp"], ["proof (state)\nthis:\n  set_lfp s f =\n  (if f s \\<subseteq> s then s else set_lfp (s \\<union> f s) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_lfp_simps [simp] :\n\"mono f \\<Longrightarrow> f s \\<subseteq> s \\<Longrightarrow> set_lfp s f = s\"\n\"mono f \\<Longrightarrow> \\<not>(f s \\<subseteq> s) \\<Longrightarrow> set_lfp s f = (set_lfp (s \\<union> f s) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>mono f; f s \\<subseteq> s\\<rbrakk>\n     \\<Longrightarrow> set_lfp s f = s) &&&\n    (\\<lbrakk>mono f; \\<not> f s \\<subseteq> s\\<rbrakk>\n     \\<Longrightarrow> set_lfp s f = set_lfp (s \\<union> f s) f)", "by (metis set_lfp_tail_rec_def)+"], ["", "fun insert_in_list_at_arbitrary_pos where\n   \"insert_in_list_at_arbitrary_pos x [] = {[x]}\"\n | \"insert_in_list_at_arbitrary_pos x (y # ys) =\n    insert (x # y # ys) ((\\<lambda>l. y # l) ` (insert_in_list_at_arbitrary_pos x ys))\""], ["", "lemma insert_in_list_at_arbitrary_pos_thm :\n  \"xl \\<in> insert_in_list_at_arbitrary_pos x l \\<longleftrightarrow>\n   (\\<exists>l1 l2. l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n    (\\<exists>l1 l2. l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "proof (induct l arbitrary: xl)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xl.\n       (xl \\<in> insert_in_list_at_arbitrary_pos x []) =\n       (\\<exists>l1 l2. [] = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)\n 2. \\<And>a l xl.\n       (\\<And>xl.\n           (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n           (\\<exists>l1 l2.\n               l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)) \\<Longrightarrow>\n       (xl \\<in> insert_in_list_at_arbitrary_pos x (a # l)) =\n       (\\<exists>l1 l2. a # l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xl.\n       (xl \\<in> insert_in_list_at_arbitrary_pos x []) =\n       (\\<exists>l1 l2. [] = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)\n 2. \\<And>a l xl.\n       (\\<And>xl.\n           (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n           (\\<exists>l1 l2.\n               l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)) \\<Longrightarrow>\n       (xl \\<in> insert_in_list_at_arbitrary_pos x (a # l)) =\n       (\\<exists>l1 l2. a # l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xl \\<in> insert_in_list_at_arbitrary_pos x []) =\n    (\\<exists>l1 l2. [] = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "by simp"], ["proof (state)\nthis:\n  (xl \\<in> insert_in_list_at_arbitrary_pos x []) =\n  (\\<exists>l1 l2. [] = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l xl.\n       (\\<And>xl.\n           (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n           (\\<exists>l1 l2.\n               l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)) \\<Longrightarrow>\n       (xl \\<in> insert_in_list_at_arbitrary_pos x (a # l)) =\n       (\\<exists>l1 l2. a # l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l xl.\n       (\\<And>xl.\n           (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n           (\\<exists>l1 l2.\n               l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)) \\<Longrightarrow>\n       (xl \\<in> insert_in_list_at_arbitrary_pos x (a # l)) =\n       (\\<exists>l1 l2. a # l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "case (Cons y l xyl)"], ["proof (state)\nthis:\n  (?xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n  (\\<exists>l1 l2. l = l1 @ l2 \\<and> ?xl = l1 @ [x] @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l xl.\n       (\\<And>xl.\n           (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n           (\\<exists>l1 l2.\n               l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)) \\<Longrightarrow>\n       (xl \\<in> insert_in_list_at_arbitrary_pos x (a # l)) =\n       (\\<exists>l1 l2. a # l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "note ind_hyp = this"], ["proof (state)\nthis:\n  (?xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n  (\\<exists>l1 l2. l = l1 @ l2 \\<and> ?xl = l1 @ [x] @ l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l xl.\n       (\\<And>xl.\n           (xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n           (\\<exists>l1 l2.\n               l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)) \\<Longrightarrow>\n       (xl \\<in> insert_in_list_at_arbitrary_pos x (a # l)) =\n       (\\<exists>l1 l2. a # l = l1 @ l2 \\<and> xl = l1 @ [x] @ l2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)) =\n    (\\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l) \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n 2. \\<exists>l1 l2.\n       y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2 \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "assume xyl_in: \"xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\""], ["proof (state)\nthis:\n  xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n\ngoal (2 subgoals):\n 1. xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l) \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n 2. \\<exists>l1 l2.\n       y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2 \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "show \"\\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "proof (cases \"xyl = x # y # l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xyl = x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n 2. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "case True"], ["proof (state)\nthis:\n  xyl = x # y # l\n\ngoal (2 subgoals):\n 1. xyl = x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n 2. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "hence \"y # l = [] @ (y # l) \\<and> xyl = [] @ [x] @ (y # l)\""], ["proof (prove)\nusing this:\n  xyl = x # y # l\n\ngoal (1 subgoal):\n 1. y # l = [] @ y # l \\<and> xyl = [] @ [x] @ y # l", "by simp"], ["proof (state)\nthis:\n  y # l = [] @ y # l \\<and> xyl = [] @ [x] @ y # l\n\ngoal (2 subgoals):\n 1. xyl = x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n 2. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  y # l = [] @ y # l \\<and> xyl = [] @ [x] @ y # l\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "by blast"], ["proof (state)\nthis:\n  \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n\ngoal (1 subgoal):\n 1. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "case False"], ["proof (state)\nthis:\n  xyl \\<noteq> x # y # l\n\ngoal (1 subgoal):\n 1. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "with xyl_in"], ["proof (chain)\npicking this:\n  xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n  xyl \\<noteq> x # y # l", "have \"xyl \\<in> (#) y ` insert_in_list_at_arbitrary_pos x l\""], ["proof (prove)\nusing this:\n  xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n  xyl \\<noteq> x # y # l\n\ngoal (1 subgoal):\n 1. xyl \\<in> (#) y ` insert_in_list_at_arbitrary_pos x l", "by simp"], ["proof (state)\nthis:\n  xyl \\<in> (#) y ` insert_in_list_at_arbitrary_pos x l\n\ngoal (1 subgoal):\n 1. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "with ind_hyp"], ["proof (chain)\npicking this:\n  (?xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n  (\\<exists>l1 l2. l = l1 @ l2 \\<and> ?xl = l1 @ [x] @ l2)\n  xyl \\<in> (#) y ` insert_in_list_at_arbitrary_pos x l", "obtain l1 l2 where \"l = l1 @ l2 \\<and> xyl = y # l1 @ x # l2\""], ["proof (prove)\nusing this:\n  (?xl \\<in> insert_in_list_at_arbitrary_pos x l) =\n  (\\<exists>l1 l2. l = l1 @ l2 \\<and> ?xl = l1 @ [x] @ l2)\n  xyl \\<in> (#) y ` insert_in_list_at_arbitrary_pos x l\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        l = l1 @ l2 \\<and> xyl = y # l1 @ x # l2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: image_def Bex_def)"], ["proof (state)\nthis:\n  l = l1 @ l2 \\<and> xyl = y # l1 @ x # l2\n\ngoal (1 subgoal):\n 1. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "hence \"y # l = (y # l1) @ l2 \\<and> xyl = (y # l1) @ [x] @ l2\""], ["proof (prove)\nusing this:\n  l = l1 @ l2 \\<and> xyl = y # l1 @ x # l2\n\ngoal (1 subgoal):\n 1. y # l = (y # l1) @ l2 \\<and> xyl = (y # l1) @ [x] @ l2", "by simp"], ["proof (state)\nthis:\n  y # l = (y # l1) @ l2 \\<and> xyl = (y # l1) @ [x] @ l2\n\ngoal (1 subgoal):\n 1. xyl \\<noteq> x # y # l \\<Longrightarrow>\n    \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  y # l = (y # l1) @ l2 \\<and> xyl = (y # l1) @ [x] @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "by blast"], ["proof (state)\nthis:\n  \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2 \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2 \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "assume \"\\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\""], ["proof (state)\nthis:\n  \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2 \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "then"], ["proof (chain)\npicking this:\n  \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2", "obtain l1 l2 where yl_eq: \"y # l = l1 @ l2\" and xyl_eq: \"xyl = l1 @ [x] @ l2\""], ["proof (prove)\nusing this:\n  \\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>y # l = l1 @ l2; xyl = l1 @ [x] @ l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y # l = l1 @ l2\n  xyl = l1 @ [x] @ l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2 \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "show \"xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "proof (cases l1)"], ["proof (state)\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n 2. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "case Nil"], ["proof (state)\nthis:\n  l1 = []\n\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n 2. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "with yl_eq xyl_eq"], ["proof (chain)\npicking this:\n  y # l = l1 @ l2\n  xyl = l1 @ [x] @ l2\n  l1 = []", "have \"xyl = x # y # l\""], ["proof (prove)\nusing this:\n  y # l = l1 @ l2\n  xyl = l1 @ [x] @ l2\n  l1 = []\n\ngoal (1 subgoal):\n 1. xyl = x # y # l", "by simp"], ["proof (state)\nthis:\n  xyl = x # y # l\n\ngoal (2 subgoals):\n 1. l1 = [] \\<Longrightarrow>\n    xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n 2. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xyl = x # y # l\n\ngoal (1 subgoal):\n 1. xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "by simp"], ["proof (state)\nthis:\n  xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "case (Cons y' l1')"], ["proof (state)\nthis:\n  l1 = y' # l1'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "with yl_eq"], ["proof (chain)\npicking this:\n  y # l = l1 @ l2\n  l1 = y' # l1'", "have l1_eq: \"l1 = y # l1'\" and l_eq: \"l = l1' @ l2\""], ["proof (prove)\nusing this:\n  y # l = l1 @ l2\n  l1 = y' # l1'\n\ngoal (1 subgoal):\n 1. l1 = y # l1' &&& l = l1' @ l2", "by simp_all"], ["proof (state)\nthis:\n  l1 = y # l1'\n  l = l1' @ l2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "have \"\\<exists>l1'' l2''. l = l1'' @ l2'' \\<and> l1' @ [x] @ l2 = l1'' @ [x] @ l2''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l1'' l2''.\n       l = l1'' @ l2'' \\<and> l1' @ [x] @ l2 = l1'' @ [x] @ l2''", "apply (rule_tac exI[where x = l1'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l2''. l = l1' @ l2'' \\<and> l1' @ [x] @ l2 = l1' @ [x] @ l2''", "apply (rule_tac exI [where x = l2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = l1' @ l2 \\<and> l1' @ [x] @ l2 = l1' @ [x] @ l2", "apply (simp add: l_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>l1'' l2''.\n     l = l1'' @ l2'' \\<and> l1' @ [x] @ l2 = l1'' @ [x] @ l2''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "hence \"(l1' @ [x] @ l2) \\<in> insert_in_list_at_arbitrary_pos x l\""], ["proof (prove)\nusing this:\n  \\<exists>l1'' l2''.\n     l = l1'' @ l2'' \\<and> l1' @ [x] @ l2 = l1'' @ [x] @ l2''\n\ngoal (1 subgoal):\n 1. l1' @ [x] @ l2 \\<in> insert_in_list_at_arbitrary_pos x l", "unfolding ind_hyp"], ["proof (prove)\nusing this:\n  \\<exists>l1'' l2''.\n     l = l1'' @ l2'' \\<and> l1' @ [x] @ l2 = l1'' @ [x] @ l2''\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2a. l = l1 @ l2a \\<and> l1' @ [x] @ l2 = l1 @ [x] @ l2a", "by blast"], ["proof (state)\nthis:\n  l1' @ [x] @ l2 \\<in> insert_in_list_at_arbitrary_pos x l\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "hence \"\\<exists>l'. l' \\<in> insert_in_list_at_arbitrary_pos x l \\<and> l1 @ x # l2 = y # l'\""], ["proof (prove)\nusing this:\n  l1' @ [x] @ l2 \\<in> insert_in_list_at_arbitrary_pos x l\n\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       l' \\<in> insert_in_list_at_arbitrary_pos x l \\<and>\n       l1 @ x # l2 = y # l'", "by (rule_tac exI [where x = \"l1' @ [x] @ l2\"]) (simp add: l1_eq)"], ["proof (state)\nthis:\n  \\<exists>l'.\n     l' \\<in> insert_in_list_at_arbitrary_pos x l \\<and>\n     l1 @ x # l2 = y # l'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l1 = a # list \\<Longrightarrow>\n       xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>l'.\n     l' \\<in> insert_in_list_at_arbitrary_pos x l \\<and>\n     l1 @ x # l2 = y # l'\n\ngoal (1 subgoal):\n 1. xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)", "by (simp add: image_def Bex_def xyl_eq)"], ["proof (state)\nthis:\n  xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xyl \\<in> insert_in_list_at_arbitrary_pos x (y # l)) =\n  (\\<exists>l1 l2. y # l = l1 @ l2 \\<and> xyl = l1 @ [x] @ l2)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition list_of_set_set :: \"'a set \\<Rightarrow> ('a list) set\" where\n\"list_of_set_set s = { l . (set l = s) \\<and> distinct l }\""], ["", "lemma list_of_set_set_empty [simp]:\n  \"list_of_set_set {} = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_set_set {} = {[]}", "unfolding list_of_set_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. set l = {} \\<and> distinct l} = {[]}", "by auto"], ["", "lemma list_of_set_set_insert [simp] :\n  \"list_of_set_set (insert x s) =\n     \\<Union> ((insert_in_list_at_arbitrary_pos x) ` (list_of_set_set (s - {x})))\"\n   (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_set_set (insert x s) =\n    \\<Union> (insert_in_list_at_arbitrary_pos x ` list_of_set_set (s - {x}))", "proof (intro set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> list_of_set_set (insert x s)) =\n       (xa \\<in> \\<Union>\n                  (insert_in_list_at_arbitrary_pos x `\n                   list_of_set_set (s - {x})))", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> list_of_set_set (insert x s)) =\n       (xa \\<in> \\<Union>\n                  (insert_in_list_at_arbitrary_pos x `\n                   list_of_set_set (s - {x})))", "have \"(set l = insert x s \\<and> distinct l) \\<longleftrightarrow> (\\<exists>l1 l2. set (l1 @ l2) = s - {x} \\<and> distinct (l1 @ l2) \\<and> l = l1 @ x # l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set l = insert x s \\<and> distinct l) =\n    (\\<exists>l1 l2.\n        set (l1 @ l2) = s - {x} \\<and>\n        distinct (l1 @ l2) \\<and> l = l1 @ x # l2)", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "assume \"set l = insert x s \\<and> distinct l\""], ["proof (state)\nthis:\n  set l = insert x s \\<and> distinct l\n\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "hence set_l_eq: \"set l = insert x s\" and \"distinct l\""], ["proof (prove)\nusing this:\n  set l = insert x s \\<and> distinct l\n\ngoal (1 subgoal):\n 1. set l = insert x s &&& distinct l", "by simp_all"], ["proof (state)\nthis:\n  set l = insert x s\n  distinct l\n\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "from \\<open>set l = insert x s\\<close>"], ["proof (chain)\npicking this:\n  set l = insert x s", "have \"x \\<in> set l\""], ["proof (prove)\nusing this:\n  set l = insert x s\n\ngoal (1 subgoal):\n 1. x \\<in> set l", "by simp"], ["proof (state)\nthis:\n  x \\<in> set l\n\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "then"], ["proof (chain)\npicking this:\n  x \\<in> set l", "obtain l1 l2 where l_eq: \"l = l1 @ x # l2\""], ["proof (prove)\nusing this:\n  x \\<in> set l\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        l = l1 @ x # l2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_decomp"], ["proof (prove)\nusing this:\n  \\<exists>ys zs. l = ys @ x # zs\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        l = l1 @ x # l2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l = l1 @ x # l2\n\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "from \\<open>distinct l\\<close>  l_eq"], ["proof (chain)\npicking this:\n  distinct l\n  l = l1 @ x # l2", "have \"distinct (l1 @ l2)\" and x_nin: \"x \\<notin> set (l1 @ l2)\""], ["proof (prove)\nusing this:\n  distinct l\n  l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. distinct (l1 @ l2) &&& x \\<notin> set (l1 @ l2)", "by auto"], ["proof (state)\nthis:\n  distinct (l1 @ l2)\n  x \\<notin> set (l1 @ l2)\n\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "from x_nin set_l_eq[unfolded l_eq]"], ["proof (chain)\npicking this:\n  x \\<notin> set (l1 @ l2)\n  set (l1 @ x # l2) = insert x s", "have set_l12_eq: \"set (l1 @ l2) = s - {x}\""], ["proof (prove)\nusing this:\n  x \\<notin> set (l1 @ l2)\n  set (l1 @ x # l2) = insert x s\n\ngoal (1 subgoal):\n 1. set (l1 @ l2) = s - {x}", "by auto"], ["proof (state)\nthis:\n  set (l1 @ l2) = s - {x}\n\ngoal (2 subgoals):\n 1. set l = insert x s \\<and> distinct l \\<Longrightarrow>\n    \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n 2. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "from \\<open>distinct (l1 @ l2)\\<close> l_eq set_l12_eq"], ["proof (chain)\npicking this:\n  distinct (l1 @ l2)\n  l = l1 @ x # l2\n  set (l1 @ l2) = s - {x}", "show \"\\<exists>l1 l2. set (l1 @ l2) = s - {x} \\<and> distinct (l1 @ l2) \\<and> l = l1 @ x # l2\""], ["proof (prove)\nusing this:\n  distinct (l1 @ l2)\n  l = l1 @ x # l2\n  set (l1 @ l2) = s - {x}\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2", "by blast"], ["proof (state)\nthis:\n  \\<exists>l1 l2.\n     set (l1 @ l2) = s - {x} \\<and>\n     distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "assume \"\\<exists>l1 l2. set (l1 @ l2) = s - {x} \\<and> distinct (l1 @ l2) \\<and> l = l1 @ x # l2\""], ["proof (state)\nthis:\n  \\<exists>l1 l2.\n     set (l1 @ l2) = s - {x} \\<and>\n     distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "then"], ["proof (chain)\npicking this:\n  \\<exists>l1 l2.\n     set (l1 @ l2) = s - {x} \\<and>\n     distinct (l1 @ l2) \\<and> l = l1 @ x # l2", "obtain l1 l2 where \"set (l1 @ l2) = s - {x}\"  \"distinct (l1 @ l2)\" \"l = l1 @ x # l2\""], ["proof (prove)\nusing this:\n  \\<exists>l1 l2.\n     set (l1 @ l2) = s - {x} \\<and>\n     distinct (l1 @ l2) \\<and> l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>set (l1 @ l2) = s - {x}; distinct (l1 @ l2);\n         l = l1 @ x # l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set (l1 @ l2) = s - {x}\n  distinct (l1 @ l2)\n  l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. \\<exists>l1 l2.\n       set (l1 @ l2) = s - {x} \\<and>\n       distinct (l1 @ l2) \\<and> l = l1 @ x # l2 \\<Longrightarrow>\n    set l = insert x s \\<and> distinct l", "thus \"set l = insert x s \\<and> distinct l\""], ["proof (prove)\nusing this:\n  set (l1 @ l2) = s - {x}\n  distinct (l1 @ l2)\n  l = l1 @ x # l2\n\ngoal (1 subgoal):\n 1. set l = insert x s \\<and> distinct l", "by auto"], ["proof (state)\nthis:\n  set l = insert x s \\<and> distinct l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (set l = insert x s \\<and> distinct l) =\n  (\\<exists>l1 l2.\n      set (l1 @ l2) = s - {x} \\<and>\n      distinct (l1 @ l2) \\<and> l = l1 @ x # l2)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> list_of_set_set (insert x s)) =\n       (xa \\<in> \\<Union>\n                  (insert_in_list_at_arbitrary_pos x `\n                   list_of_set_set (s - {x})))", "thus \"l \\<in> list_of_set_set (insert x s) \\<longleftrightarrow> l \\<in> (\\<Union> ((insert_in_list_at_arbitrary_pos x) ` (list_of_set_set (s - {x}))))\""], ["proof (prove)\nusing this:\n  (set l = insert x s \\<and> distinct l) =\n  (\\<exists>l1 l2.\n      set (l1 @ l2) = s - {x} \\<and>\n      distinct (l1 @ l2) \\<and> l = l1 @ x # l2)\n\ngoal (1 subgoal):\n 1. (l \\<in> list_of_set_set (insert x s)) =\n    (l \\<in> \\<Union>\n              (insert_in_list_at_arbitrary_pos x `\n               list_of_set_set (s - {x})))", "unfolding list_of_set_set_def"], ["proof (prove)\nusing this:\n  (set l = insert x s \\<and> distinct l) =\n  (\\<exists>l1 l2.\n      set (l1 @ l2) = s - {x} \\<and>\n      distinct (l1 @ l2) \\<and> l = l1 @ x # l2)\n\ngoal (1 subgoal):\n 1. (l \\<in> {l. set l = insert x s \\<and> distinct l}) =\n    (l \\<in> \\<Union>\n              (insert_in_list_at_arbitrary_pos x `\n               {l. set l = s - {x} \\<and> distinct l}))", "by (simp add: insert_in_list_at_arbitrary_pos_thm ex_simps[symmetric] del: ex_simps)"], ["proof (state)\nthis:\n  (l \\<in> list_of_set_set (insert x s)) =\n  (l \\<in> \\<Union>\n            (insert_in_list_at_arbitrary_pos x ` list_of_set_set (s - {x})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_set_set_code [code]:\n  \"list_of_set_set (set []) = {[]}\"\n  \"list_of_set_set (set (x # xs)) =\n     \\<Union> ((insert_in_list_at_arbitrary_pos x) ` (list_of_set_set ((set xs) - {x})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_set_set (set []) = {[]} &&&\n    list_of_set_set (set (x # xs)) =\n    \\<Union>\n     (insert_in_list_at_arbitrary_pos x ` list_of_set_set (set xs - {x}))", "by simp_all"], ["", "lemma list_of_set_set_is_empty :\n  \"list_of_set_set s = {} \\<longleftrightarrow> \\<not> (finite s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of_set_set s = {}) = infinite s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (list_of_set_set s = {}) = infinite s", "have \"finite s \\<longleftrightarrow> (\\<exists>l. set l = s \\<and> distinct l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s = (\\<exists>l. set l = s \\<and> distinct l)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite s \\<Longrightarrow> \\<exists>l. set l = s \\<and> distinct l\n 2. \\<exists>l. set l = s \\<and> distinct l \\<Longrightarrow> finite s", "assume \"\\<exists>l. set l = s \\<and> distinct l\""], ["proof (state)\nthis:\n  \\<exists>l. set l = s \\<and> distinct l\n\ngoal (2 subgoals):\n 1. finite s \\<Longrightarrow> \\<exists>l. set l = s \\<and> distinct l\n 2. \\<exists>l. set l = s \\<and> distinct l \\<Longrightarrow> finite s", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. set l = s \\<and> distinct l", "obtain l where \"s = set l\""], ["proof (prove)\nusing this:\n  \\<exists>l. set l = s \\<and> distinct l\n\ngoal (1 subgoal):\n 1. (\\<And>l. s = set l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  s = set l\n\ngoal (2 subgoals):\n 1. finite s \\<Longrightarrow> \\<exists>l. set l = s \\<and> distinct l\n 2. \\<exists>l. set l = s \\<and> distinct l \\<Longrightarrow> finite s", "thus \"finite s\""], ["proof (prove)\nusing this:\n  s = set l\n\ngoal (1 subgoal):\n 1. finite s", "by simp"], ["proof (state)\nthis:\n  finite s\n\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> \\<exists>l. set l = s \\<and> distinct l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> \\<exists>l. set l = s \\<and> distinct l", "assume \"finite s\""], ["proof (state)\nthis:\n  finite s\n\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> \\<exists>l. set l = s \\<and> distinct l", "thus \"\\<exists>l. set l = s \\<and> distinct l\""], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. \\<exists>l. set l = s \\<and> distinct l", "proof (induct s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>l. set l = {} \\<and> distinct l\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>l. set l = {} \\<and> distinct l\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. set l = {} \\<and> distinct l", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. set l = {} \\<and> distinct l\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "case (insert e s)"], ["proof (state)\nthis:\n  finite s\n  e \\<notin> s\n  \\<exists>l. set l = s \\<and> distinct l\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "note e_nin_s = insert(2)"], ["proof (state)\nthis:\n  e \\<notin> s\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "from insert(3)"], ["proof (chain)\npicking this:\n  \\<exists>l. set l = s \\<and> distinct l", "obtain l where set_l: \"set l = s\" and dist_l: \"distinct l\""], ["proof (prove)\nusing this:\n  \\<exists>l. set l = s \\<and> distinct l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = s; distinct l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set l = s\n  distinct l\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "from set_l"], ["proof (chain)\npicking this:\n  set l = s", "have set_el: \"set (e # l) = insert e s\""], ["proof (prove)\nusing this:\n  set l = s\n\ngoal (1 subgoal):\n 1. set (e # l) = insert e s", "by auto"], ["proof (state)\nthis:\n  set (e # l) = insert e s\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "from dist_l set_l e_nin_s"], ["proof (chain)\npicking this:\n  distinct l\n  set l = s\n  e \\<notin> s", "have dist_el: \"distinct (e # l)\""], ["proof (prove)\nusing this:\n  distinct l\n  set l = s\n  e \\<notin> s\n\ngoal (1 subgoal):\n 1. distinct (e # l)", "by simp"], ["proof (state)\nthis:\n  distinct (e # l)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>l. set l = F \\<and> distinct l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert x F \\<and> distinct l", "from set_el dist_el"], ["proof (chain)\npicking this:\n  set (e # l) = insert e s\n  distinct (e # l)", "show ?case"], ["proof (prove)\nusing this:\n  set (e # l) = insert e s\n  distinct (e # l)\n\ngoal (1 subgoal):\n 1. \\<exists>l. set l = insert e s \\<and> distinct l", "by blast"], ["proof (state)\nthis:\n  \\<exists>l. set l = insert e s \\<and> distinct l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l. set l = s \\<and> distinct l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite s = (\\<exists>l. set l = s \\<and> distinct l)\n\ngoal (1 subgoal):\n 1. (list_of_set_set s = {}) = infinite s", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite s = (\\<exists>l. set l = s \\<and> distinct l)\n\ngoal (1 subgoal):\n 1. (list_of_set_set s = {}) = infinite s", "unfolding list_of_set_set_def"], ["proof (prove)\nusing this:\n  finite s = (\\<exists>l. set l = s \\<and> distinct l)\n\ngoal (1 subgoal):\n 1. ({l. set l = s \\<and> distinct l} = {}) = infinite s", "by simp"], ["proof (state)\nthis:\n  (list_of_set_set s = {}) = infinite s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition list_of_set :: \"'a set \\<Rightarrow> 'a list\" where\n   \"list_of_set s = set_choose (list_of_set_set s)\""], ["", "lemma list_of_set [simp] :\n  assumes fin_s: \"finite s\"\n  shows \"set (list_of_set s) = s\"\n        \"distinct (list_of_set s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_of_set s) = s &&& distinct (list_of_set s)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set (list_of_set s) = s\n 2. distinct (list_of_set s)", "from fin_s list_of_set_set_is_empty[of s]"], ["proof (chain)\npicking this:\n  finite s\n  (list_of_set_set s = {}) = infinite s", "have \"\\<not> (list_of_set_set s = {})\""], ["proof (prove)\nusing this:\n  finite s\n  (list_of_set_set s = {}) = infinite s\n\ngoal (1 subgoal):\n 1. list_of_set_set s \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  list_of_set_set s \\<noteq> {}\n\ngoal (2 subgoals):\n 1. set (list_of_set s) = s\n 2. distinct (list_of_set s)", "hence \"list_of_set s \\<in> list_of_set_set s\""], ["proof (prove)\nusing this:\n  list_of_set_set s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. list_of_set s \\<in> list_of_set_set s", "unfolding list_of_set_def"], ["proof (prove)\nusing this:\n  list_of_set_set s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_choose (list_of_set_set s) \\<in> list_of_set_set s", "by (rule set_choose_thm)"], ["proof (state)\nthis:\n  list_of_set s \\<in> list_of_set_set s\n\ngoal (2 subgoals):\n 1. set (list_of_set s) = s\n 2. distinct (list_of_set s)", "thus \"set (list_of_set s) = s\"\n       \"distinct (list_of_set s)\""], ["proof (prove)\nusing this:\n  list_of_set s \\<in> list_of_set_set s\n\ngoal (1 subgoal):\n 1. set (list_of_set s) = s &&& distinct (list_of_set s)", "unfolding list_of_set_set_def"], ["proof (prove)\nusing this:\n  list_of_set s \\<in> {l. set l = s \\<and> distinct l}\n\ngoal (1 subgoal):\n 1. set (list_of_set s) = s &&& distinct (list_of_set s)", "by simp_all"], ["proof (state)\nthis:\n  set (list_of_set s) = s\n  distinct (list_of_set s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_set_in:\n  \"finite s \\<Longrightarrow> list_of_set s \\<in> list_of_set_set s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> list_of_set s \\<in> list_of_set_set s", "unfolding list_of_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow>\n    set_choose (list_of_set_set s) \\<in> list_of_set_set s", "by (metis list_of_set_set_is_empty set_choose_thm)"], ["", "definition ordered_list_of_set where\n  \"ordered_list_of_set cmp s = set_choose (sort_by cmp ` list_of_set_set s)\""], ["", "subsection \\<open>sum\\<close>"], ["", "find_consts \"'a list => ('a list * _)\""], ["", "fun sum_partition :: \"('a + 'b) list \\<Rightarrow> 'a list * 'b list\"  where\n  \"sum_partition [] = ([], [])\"\n| \"sum_partition ((Inl l) # lrs) =\n     (let (ll, rl) = sum_partition lrs in\n     (l # ll, rl))\"\n| \"sum_partition ((Inr r) # lrs) =\n     (let (ll, rl) = sum_partition lrs in\n     (ll, r # rl))\""], ["", "lemma sum_partition_length :\n  \"List.length lrs = List.length (fst (sum_partition lrs)) + List.length (snd (sum_partition lrs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length lrs =\n    length (fst (sum_partition lrs)) + length (snd (sum_partition lrs))", "proof (induct lrs)"], ["proof (state)\ngoal (2 subgoals):\n 1. length [] =\n    length (fst (sum_partition [])) + length (snd (sum_partition []))\n 2. \\<And>a lrs.\n       length lrs =\n       length (fst (sum_partition lrs)) +\n       length (snd (sum_partition lrs)) \\<Longrightarrow>\n       length (a # lrs) =\n       length (fst (sum_partition (a # lrs))) +\n       length (snd (sum_partition (a # lrs)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length [] =\n    length (fst (sum_partition [])) + length (snd (sum_partition []))\n 2. \\<And>a lrs.\n       length lrs =\n       length (fst (sum_partition lrs)) +\n       length (snd (sum_partition lrs)) \\<Longrightarrow>\n       length (a # lrs) =\n       length (fst (sum_partition (a # lrs))) +\n       length (snd (sum_partition (a # lrs)))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] =\n    length (fst (sum_partition [])) + length (snd (sum_partition []))", "by simp"], ["proof (state)\nthis:\n  length [] =\n  length (fst (sum_partition [])) + length (snd (sum_partition []))\n\ngoal (1 subgoal):\n 1. \\<And>a lrs.\n       length lrs =\n       length (fst (sum_partition lrs)) +\n       length (snd (sum_partition lrs)) \\<Longrightarrow>\n       length (a # lrs) =\n       length (fst (sum_partition (a # lrs))) +\n       length (snd (sum_partition (a # lrs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lrs.\n       length lrs =\n       length (fst (sum_partition lrs)) +\n       length (snd (sum_partition lrs)) \\<Longrightarrow>\n       length (a # lrs) =\n       length (fst (sum_partition (a # lrs))) +\n       length (snd (sum_partition (a # lrs)))", "case (Cons lr lrs)"], ["proof (state)\nthis:\n  length lrs =\n  length (fst (sum_partition lrs)) + length (snd (sum_partition lrs))\n\ngoal (1 subgoal):\n 1. \\<And>a lrs.\n       length lrs =\n       length (fst (sum_partition lrs)) +\n       length (snd (sum_partition lrs)) \\<Longrightarrow>\n       length (a # lrs) =\n       length (fst (sum_partition (a # lrs))) +\n       length (snd (sum_partition (a # lrs)))", "thus ?case"], ["proof (prove)\nusing this:\n  length lrs =\n  length (fst (sum_partition lrs)) + length (snd (sum_partition lrs))\n\ngoal (1 subgoal):\n 1. length (lr # lrs) =\n    length (fst (sum_partition (lr # lrs))) +\n    length (snd (sum_partition (lr # lrs)))", "by (cases lr) (auto split: prod.split)"], ["proof (state)\nthis:\n  length (lr # lrs) =\n  length (fst (sum_partition (lr # lrs))) +\n  length (snd (sum_partition (lr # lrs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>sorting\\<close>"], ["", "subsection \\<open>Strings\\<close>"], ["", "declare String.literal.explode_inverse [simp]"], ["", "subsection \\<open>num to string conversions\\<close>"], ["", "definition nat_list_to_string :: \"nat list \\<Rightarrow> string\" where\n  \"nat_list_to_string nl = map char_of nl\""], ["", "definition is_digit where\n  \"is_digit (n::nat) = (n < 10)\""], ["", "lemma is_digit_simps[simp] :\n  \"n < 10 \\<Longrightarrow> is_digit n\"\n  \"\\<not>(n < 10) \\<Longrightarrow> \\<not>(is_digit n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < 10 \\<Longrightarrow> is_digit n) &&&\n    (\\<not> n < 10 \\<Longrightarrow> \\<not> is_digit n)", "unfolding is_digit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < 10 \\<Longrightarrow> n < 10) &&&\n    (\\<not> n < 10 \\<Longrightarrow> \\<not> n < 10)", "by simp_all"], ["", "lemma is_digit_expand :\n  \"is_digit n \\<longleftrightarrow>\n     (n = 0) \\<or> (n = 1) \\<or> (n = 2) \\<or> (n = 3) \\<or>  (n = 4) \\<or>\n     (n = 5) \\<or> (n = 6) \\<or> (n = 7) \\<or> (n = 8) \\<or>  (n = 9)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_digit n =\n    (n = 0 \\<or>\n     n = 1 \\<or>\n     n = 2 \\<or>\n     n = 3 \\<or>\n     n = 4 \\<or> n = 5 \\<or> n = 6 \\<or> n = 7 \\<or> n = 8 \\<or> n = 9)", "unfolding is_digit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < 10) =\n    (n = 0 \\<or>\n     n = 1 \\<or>\n     n = 2 \\<or>\n     n = 3 \\<or>\n     n = 4 \\<or> n = 5 \\<or> n = 6 \\<or> n = 7 \\<or> n = 8 \\<or> n = 9)", "by auto"], ["", "lemmas is_digitE = is_digit_expand[THEN iffD1,elim_format]"], ["", "lemmas is_digitI = is_digit_expand[THEN iffD2,rule_format]"], ["", "definition is_digit_char where\n  \"is_digit_char c \\<longleftrightarrow>\n     (c = CHR ''0'') \\<or> (c = CHR ''5'') \\<or>\n     (c = CHR ''1'') \\<or> (c = CHR ''6'') \\<or>\n     (c = CHR ''2'') \\<or> (c = CHR ''7'') \\<or>\n     (c = CHR ''3'') \\<or> (c = CHR ''8'') \\<or>\n     (c = CHR ''4'') \\<or> (c = CHR ''9'')\""], ["", "lemma is_digit_char_simps[simp] :\n  \"is_digit_char (CHR ''0'')\"\n  \"is_digit_char (CHR ''1'')\"\n  \"is_digit_char (CHR ''2'')\"\n  \"is_digit_char (CHR ''3'')\"\n  \"is_digit_char (CHR ''4'')\"\n  \"is_digit_char (CHR ''5'')\"\n  \"is_digit_char (CHR ''6'')\"\n  \"is_digit_char (CHR ''7'')\"\n  \"is_digit_char (CHR ''8'')\"\n  \"is_digit_char (CHR ''9'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((is_digit_char CHR ''0'' &&& is_digit_char CHR ''1'') &&&\n     is_digit_char CHR ''2'' &&&\n     is_digit_char CHR ''3'' &&& is_digit_char CHR ''4'') &&&\n    (is_digit_char CHR ''5'' &&& is_digit_char CHR ''6'') &&&\n    is_digit_char CHR ''7'' &&&\n    is_digit_char CHR ''8'' &&& is_digit_char CHR ''9''", "unfolding is_digit_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((CHR ''0'' = CHR ''0'' \\<or>\n      CHR ''0'' = CHR ''5'' \\<or>\n      CHR ''0'' = CHR ''1'' \\<or>\n      CHR ''0'' = CHR ''6'' \\<or>\n      CHR ''0'' = CHR ''2'' \\<or>\n      CHR ''0'' = CHR ''7'' \\<or>\n      CHR ''0'' = CHR ''3'' \\<or>\n      CHR ''0'' = CHR ''8'' \\<or>\n      CHR ''0'' = CHR ''4'' \\<or> CHR ''0'' = CHR ''9'' &&&\n      CHR ''1'' = CHR ''0'' \\<or>\n      CHR ''1'' = CHR ''5'' \\<or>\n      CHR ''1'' = CHR ''1'' \\<or>\n      CHR ''1'' = CHR ''6'' \\<or>\n      CHR ''1'' = CHR ''2'' \\<or>\n      CHR ''1'' = CHR ''7'' \\<or>\n      CHR ''1'' = CHR ''3'' \\<or>\n      CHR ''1'' = CHR ''8'' \\<or>\n      CHR ''1'' = CHR ''4'' \\<or> CHR ''1'' = CHR ''9'') &&&\n     CHR ''2'' = CHR ''0'' \\<or>\n     CHR ''2'' = CHR ''5'' \\<or>\n     CHR ''2'' = CHR ''1'' \\<or>\n     CHR ''2'' = CHR ''6'' \\<or>\n     CHR ''2'' = CHR ''2'' \\<or>\n     CHR ''2'' = CHR ''7'' \\<or>\n     CHR ''2'' = CHR ''3'' \\<or>\n     CHR ''2'' = CHR ''8'' \\<or>\n     CHR ''2'' = CHR ''4'' \\<or> CHR ''2'' = CHR ''9'' &&&\n     CHR ''3'' = CHR ''0'' \\<or>\n     CHR ''3'' = CHR ''5'' \\<or>\n     CHR ''3'' = CHR ''1'' \\<or>\n     CHR ''3'' = CHR ''6'' \\<or>\n     CHR ''3'' = CHR ''2'' \\<or>\n     CHR ''3'' = CHR ''7'' \\<or>\n     CHR ''3'' = CHR ''3'' \\<or>\n     CHR ''3'' = CHR ''8'' \\<or>\n     CHR ''3'' = CHR ''4'' \\<or> CHR ''3'' = CHR ''9'' &&&\n     CHR ''4'' = CHR ''0'' \\<or>\n     CHR ''4'' = CHR ''5'' \\<or>\n     CHR ''4'' = CHR ''1'' \\<or>\n     CHR ''4'' = CHR ''6'' \\<or>\n     CHR ''4'' = CHR ''2'' \\<or>\n     CHR ''4'' = CHR ''7'' \\<or>\n     CHR ''4'' = CHR ''3'' \\<or>\n     CHR ''4'' = CHR ''8'' \\<or>\n     CHR ''4'' = CHR ''4'' \\<or> CHR ''4'' = CHR ''9'') &&&\n    (CHR ''5'' = CHR ''0'' \\<or>\n     CHR ''5'' = CHR ''5'' \\<or>\n     CHR ''5'' = CHR ''1'' \\<or>\n     CHR ''5'' = CHR ''6'' \\<or>\n     CHR ''5'' = CHR ''2'' \\<or>\n     CHR ''5'' = CHR ''7'' \\<or>\n     CHR ''5'' = CHR ''3'' \\<or>\n     CHR ''5'' = CHR ''8'' \\<or>\n     CHR ''5'' = CHR ''4'' \\<or> CHR ''5'' = CHR ''9'' &&&\n     CHR ''6'' = CHR ''0'' \\<or>\n     CHR ''6'' = CHR ''5'' \\<or>\n     CHR ''6'' = CHR ''1'' \\<or>\n     CHR ''6'' = CHR ''6'' \\<or>\n     CHR ''6'' = CHR ''2'' \\<or>\n     CHR ''6'' = CHR ''7'' \\<or>\n     CHR ''6'' = CHR ''3'' \\<or>\n     CHR ''6'' = CHR ''8'' \\<or>\n     CHR ''6'' = CHR ''4'' \\<or> CHR ''6'' = CHR ''9'') &&&\n    CHR ''7'' = CHR ''0'' \\<or>\n    CHR ''7'' = CHR ''5'' \\<or>\n    CHR ''7'' = CHR ''1'' \\<or>\n    CHR ''7'' = CHR ''6'' \\<or>\n    CHR ''7'' = CHR ''2'' \\<or>\n    CHR ''7'' = CHR ''7'' \\<or>\n    CHR ''7'' = CHR ''3'' \\<or>\n    CHR ''7'' = CHR ''8'' \\<or>\n    CHR ''7'' = CHR ''4'' \\<or> CHR ''7'' = CHR ''9'' &&&\n    CHR ''8'' = CHR ''0'' \\<or>\n    CHR ''8'' = CHR ''5'' \\<or>\n    CHR ''8'' = CHR ''1'' \\<or>\n    CHR ''8'' = CHR ''6'' \\<or>\n    CHR ''8'' = CHR ''2'' \\<or>\n    CHR ''8'' = CHR ''7'' \\<or>\n    CHR ''8'' = CHR ''3'' \\<or>\n    CHR ''8'' = CHR ''8'' \\<or>\n    CHR ''8'' = CHR ''4'' \\<or> CHR ''8'' = CHR ''9'' &&&\n    CHR ''9'' = CHR ''0'' \\<or>\n    CHR ''9'' = CHR ''5'' \\<or>\n    CHR ''9'' = CHR ''1'' \\<or>\n    CHR ''9'' = CHR ''6'' \\<or>\n    CHR ''9'' = CHR ''2'' \\<or>\n    CHR ''9'' = CHR ''7'' \\<or>\n    CHR ''9'' = CHR ''3'' \\<or>\n    CHR ''9'' = CHR ''8'' \\<or>\n    CHR ''9'' = CHR ''4'' \\<or> CHR ''9'' = CHR ''9''", "by simp_all"], ["", "lemmas is_digit_charE = is_digit_char_def[THEN iffD1,elim_format]"], ["", "lemmas is_digit_charI = is_digit_char_def[THEN iffD2,rule_format]"], ["", "definition digit_to_char :: \"nat \\<Rightarrow> char\" where\n  \"digit_to_char n = (\n     if n = 0 then CHR ''0''\n     else if n = 1 then CHR ''1''\n     else if n = 2 then CHR ''2''\n     else if n = 3 then CHR ''3''\n     else if n = 4 then CHR ''4''\n     else if n = 5 then CHR ''5''\n     else if n = 6 then CHR ''6''\n     else if n = 7 then CHR ''7''\n     else if n = 8 then CHR ''8''\n     else if n = 9 then CHR ''9''\n     else CHR ''X'')\""], ["", "lemma digit_to_char_simps [simp]:\n  \"digit_to_char 0 = CHR ''0''\"\n  \"digit_to_char (Suc 0) = CHR ''1''\"\n  \"digit_to_char 2 = CHR ''2''\"\n  \"digit_to_char 3 = CHR ''3''\"\n  \"digit_to_char 4 = CHR ''4''\"\n  \"digit_to_char 5 = CHR ''5''\"\n  \"digit_to_char 6 = CHR ''6''\"\n  \"digit_to_char 7 = CHR ''7''\"\n  \"digit_to_char 8 = CHR ''8''\"\n  \"digit_to_char 9 = CHR ''9''\"\n  \"n > 9 \\<Longrightarrow> digit_to_char n = CHR ''X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((digit_to_char 0 = CHR ''0'' &&& digit_to_char (Suc 0) = CHR ''1'') &&&\n     digit_to_char 2 = CHR ''2'' &&&\n     digit_to_char 3 = CHR ''3'' &&& digit_to_char 4 = CHR ''4'') &&&\n    (digit_to_char 5 = CHR ''5'' &&&\n     digit_to_char 6 = CHR ''6'' &&& digit_to_char 7 = CHR ''7'') &&&\n    digit_to_char 8 = CHR ''8'' &&&\n    digit_to_char 9 = CHR ''9'' &&&\n    (9 < n \\<Longrightarrow> digit_to_char n = CHR ''X'')", "unfolding digit_to_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((if 0 = 0 then CHR ''0''\n       else if 0 = 1 then CHR ''1''\n            else if 0 = 2 then CHR ''2''\n                 else if 0 = 3 then CHR ''3''\n                      else if 0 = 4 then CHR ''4''\n                           else if 0 = 5 then CHR ''5''\n                                else if 0 = 6 then CHR ''6''\n                                     else if 0 = 7 then CHR ''7''\n    else if 0 = 8 then CHR ''8''\n         else if 0 = 9 then CHR ''9'' else CHR ''X'') =\n      CHR ''0'' &&&\n      (if Suc 0 = 0 then CHR ''0''\n       else if Suc 0 = 1 then CHR ''1''\n            else if Suc 0 = 2 then CHR ''2''\n                 else if Suc 0 = 3 then CHR ''3''\n                      else if Suc 0 = 4 then CHR ''4''\n                           else if Suc 0 = 5 then CHR ''5''\n                                else if Suc 0 = 6 then CHR ''6''\n                                     else if Suc 0 = 7 then CHR ''7''\n    else if Suc 0 = 8 then CHR ''8''\n         else if Suc 0 = 9 then CHR ''9'' else CHR ''X'') =\n      CHR ''1'') &&&\n     (if 2 = 0 then CHR ''0''\n      else if 2 = 1 then CHR ''1''\n           else if 2 = 2 then CHR ''2''\n                else if 2 = 3 then CHR ''3''\n                     else if 2 = 4 then CHR ''4''\n                          else if 2 = 5 then CHR ''5''\n                               else if 2 = 6 then CHR ''6''\n                                    else if 2 = 7 then CHR ''7''\n   else if 2 = 8 then CHR ''8''\n        else if 2 = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''2'' &&&\n     (if 3 = 0 then CHR ''0''\n      else if 3 = 1 then CHR ''1''\n           else if 3 = 2 then CHR ''2''\n                else if 3 = 3 then CHR ''3''\n                     else if 3 = 4 then CHR ''4''\n                          else if 3 = 5 then CHR ''5''\n                               else if 3 = 6 then CHR ''6''\n                                    else if 3 = 7 then CHR ''7''\n   else if 3 = 8 then CHR ''8''\n        else if 3 = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''3'' &&&\n     (if 4 = 0 then CHR ''0''\n      else if 4 = 1 then CHR ''1''\n           else if 4 = 2 then CHR ''2''\n                else if 4 = 3 then CHR ''3''\n                     else if 4 = 4 then CHR ''4''\n                          else if 4 = 5 then CHR ''5''\n                               else if 4 = 6 then CHR ''6''\n                                    else if 4 = 7 then CHR ''7''\n   else if 4 = 8 then CHR ''8''\n        else if 4 = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''4'') &&&\n    ((if 5 = 0 then CHR ''0''\n      else if 5 = 1 then CHR ''1''\n           else if 5 = 2 then CHR ''2''\n                else if 5 = 3 then CHR ''3''\n                     else if 5 = 4 then CHR ''4''\n                          else if 5 = 5 then CHR ''5''\n                               else if 5 = 6 then CHR ''6''\n                                    else if 5 = 7 then CHR ''7''\n   else if 5 = 8 then CHR ''8''\n        else if 5 = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''5'' &&&\n     (if 6 = 0 then CHR ''0''\n      else if 6 = 1 then CHR ''1''\n           else if 6 = 2 then CHR ''2''\n                else if 6 = 3 then CHR ''3''\n                     else if 6 = 4 then CHR ''4''\n                          else if 6 = 5 then CHR ''5''\n                               else if 6 = 6 then CHR ''6''\n                                    else if 6 = 7 then CHR ''7''\n   else if 6 = 8 then CHR ''8''\n        else if 6 = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''6'' &&&\n     (if 7 = 0 then CHR ''0''\n      else if 7 = 1 then CHR ''1''\n           else if 7 = 2 then CHR ''2''\n                else if 7 = 3 then CHR ''3''\n                     else if 7 = 4 then CHR ''4''\n                          else if 7 = 5 then CHR ''5''\n                               else if 7 = 6 then CHR ''6''\n                                    else if 7 = 7 then CHR ''7''\n   else if 7 = 8 then CHR ''8''\n        else if 7 = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''7'') &&&\n    (if 8 = 0 then CHR ''0''\n     else if 8 = 1 then CHR ''1''\n          else if 8 = 2 then CHR ''2''\n               else if 8 = 3 then CHR ''3''\n                    else if 8 = 4 then CHR ''4''\n                         else if 8 = 5 then CHR ''5''\n                              else if 8 = 6 then CHR ''6''\n                                   else if 8 = 7 then CHR ''7''\n  else if 8 = 8 then CHR ''8''\n       else if 8 = 9 then CHR ''9'' else CHR ''X'') =\n    CHR ''8'' &&&\n    (if 9 = 0 then CHR ''0''\n     else if 9 = 1 then CHR ''1''\n          else if 9 = 2 then CHR ''2''\n               else if 9 = 3 then CHR ''3''\n                    else if 9 = 4 then CHR ''4''\n                         else if 9 = 5 then CHR ''5''\n                              else if 9 = 6 then CHR ''6''\n                                   else if 9 = 7 then CHR ''7''\n  else if 9 = 8 then CHR ''8''\n       else if 9 = 9 then CHR ''9'' else CHR ''X'') =\n    CHR ''9'' &&&\n    (9 < n \\<Longrightarrow>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''X'')", "by simp_all"], ["", "definition char_to_digit :: \"char \\<Rightarrow> nat\" where\n  \"char_to_digit c = (\n     if c = CHR ''0'' then 0\n     else if c = CHR ''1'' then 1\n     else if c = CHR ''2'' then 2\n     else if c = CHR ''3'' then 3\n     else if c = CHR ''4'' then 4\n     else if c = CHR ''5'' then 5\n     else if c = CHR ''6'' then 6\n     else if c = CHR ''7'' then 7\n     else if c = CHR ''8'' then 8\n     else if c = CHR ''9'' then 9\n     else 10)\""], ["", "lemma char_to_digit_simps [simp]:\n  \"char_to_digit (CHR ''0'') = 0\"\n  \"char_to_digit (CHR ''1'') = 1\"\n  \"char_to_digit (CHR ''2'') = 2\"\n  \"char_to_digit (CHR ''3'') = 3\"\n  \"char_to_digit (CHR ''4'') = 4\"\n  \"char_to_digit (CHR ''5'') = 5\"\n  \"char_to_digit (CHR ''6'') = 6\"\n  \"char_to_digit (CHR ''7'') = 7\"\n  \"char_to_digit (CHR ''8'') = 8\"\n  \"char_to_digit (CHR ''9'') = 9\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((char_to_digit CHR ''0'' = 0 &&& char_to_digit CHR ''1'' = 1) &&&\n     char_to_digit CHR ''2'' = 2 &&&\n     char_to_digit CHR ''3'' = 3 &&& char_to_digit CHR ''4'' = 4) &&&\n    (char_to_digit CHR ''5'' = 5 &&& char_to_digit CHR ''6'' = 6) &&&\n    char_to_digit CHR ''7'' = 7 &&&\n    char_to_digit CHR ''8'' = 8 &&& char_to_digit CHR ''9'' = 9", "unfolding char_to_digit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((if CHR ''0'' = CHR ''0'' then 0\n       else if CHR ''0'' = CHR ''1'' then 1\n            else if CHR ''0'' = CHR ''2'' then 2\n                 else if CHR ''0'' = CHR ''3'' then 3\n                      else if CHR ''0'' = CHR ''4'' then 4\n                           else if CHR ''0'' = CHR ''5'' then 5\n                                else if CHR ''0'' = CHR ''6'' then 6\n                                     else if CHR ''0'' = CHR ''7'' then 7\n    else if CHR ''0'' = CHR ''8'' then 8\n         else if CHR ''0'' = CHR ''9'' then 9 else 10) =\n      0 &&&\n      (if CHR ''1'' = CHR ''0'' then 0\n       else if CHR ''1'' = CHR ''1'' then 1\n            else if CHR ''1'' = CHR ''2'' then 2\n                 else if CHR ''1'' = CHR ''3'' then 3\n                      else if CHR ''1'' = CHR ''4'' then 4\n                           else if CHR ''1'' = CHR ''5'' then 5\n                                else if CHR ''1'' = CHR ''6'' then 6\n                                     else if CHR ''1'' = CHR ''7'' then 7\n    else if CHR ''1'' = CHR ''8'' then 8\n         else if CHR ''1'' = CHR ''9'' then 9 else 10) =\n      1) &&&\n     (if CHR ''2'' = CHR ''0'' then 0\n      else if CHR ''2'' = CHR ''1'' then 1\n           else if CHR ''2'' = CHR ''2'' then 2\n                else if CHR ''2'' = CHR ''3'' then 3\n                     else if CHR ''2'' = CHR ''4'' then 4\n                          else if CHR ''2'' = CHR ''5'' then 5\n                               else if CHR ''2'' = CHR ''6'' then 6\n                                    else if CHR ''2'' = CHR ''7'' then 7\n   else if CHR ''2'' = CHR ''8'' then 8\n        else if CHR ''2'' = CHR ''9'' then 9 else 10) =\n     2 &&&\n     (if CHR ''3'' = CHR ''0'' then 0\n      else if CHR ''3'' = CHR ''1'' then 1\n           else if CHR ''3'' = CHR ''2'' then 2\n                else if CHR ''3'' = CHR ''3'' then 3\n                     else if CHR ''3'' = CHR ''4'' then 4\n                          else if CHR ''3'' = CHR ''5'' then 5\n                               else if CHR ''3'' = CHR ''6'' then 6\n                                    else if CHR ''3'' = CHR ''7'' then 7\n   else if CHR ''3'' = CHR ''8'' then 8\n        else if CHR ''3'' = CHR ''9'' then 9 else 10) =\n     3 &&&\n     (if CHR ''4'' = CHR ''0'' then 0\n      else if CHR ''4'' = CHR ''1'' then 1\n           else if CHR ''4'' = CHR ''2'' then 2\n                else if CHR ''4'' = CHR ''3'' then 3\n                     else if CHR ''4'' = CHR ''4'' then 4\n                          else if CHR ''4'' = CHR ''5'' then 5\n                               else if CHR ''4'' = CHR ''6'' then 6\n                                    else if CHR ''4'' = CHR ''7'' then 7\n   else if CHR ''4'' = CHR ''8'' then 8\n        else if CHR ''4'' = CHR ''9'' then 9 else 10) =\n     4) &&&\n    ((if CHR ''5'' = CHR ''0'' then 0\n      else if CHR ''5'' = CHR ''1'' then 1\n           else if CHR ''5'' = CHR ''2'' then 2\n                else if CHR ''5'' = CHR ''3'' then 3\n                     else if CHR ''5'' = CHR ''4'' then 4\n                          else if CHR ''5'' = CHR ''5'' then 5\n                               else if CHR ''5'' = CHR ''6'' then 6\n                                    else if CHR ''5'' = CHR ''7'' then 7\n   else if CHR ''5'' = CHR ''8'' then 8\n        else if CHR ''5'' = CHR ''9'' then 9 else 10) =\n     5 &&&\n     (if CHR ''6'' = CHR ''0'' then 0\n      else if CHR ''6'' = CHR ''1'' then 1\n           else if CHR ''6'' = CHR ''2'' then 2\n                else if CHR ''6'' = CHR ''3'' then 3\n                     else if CHR ''6'' = CHR ''4'' then 4\n                          else if CHR ''6'' = CHR ''5'' then 5\n                               else if CHR ''6'' = CHR ''6'' then 6\n                                    else if CHR ''6'' = CHR ''7'' then 7\n   else if CHR ''6'' = CHR ''8'' then 8\n        else if CHR ''6'' = CHR ''9'' then 9 else 10) =\n     6) &&&\n    (if CHR ''7'' = CHR ''0'' then 0\n     else if CHR ''7'' = CHR ''1'' then 1\n          else if CHR ''7'' = CHR ''2'' then 2\n               else if CHR ''7'' = CHR ''3'' then 3\n                    else if CHR ''7'' = CHR ''4'' then 4\n                         else if CHR ''7'' = CHR ''5'' then 5\n                              else if CHR ''7'' = CHR ''6'' then 6\n                                   else if CHR ''7'' = CHR ''7'' then 7\n  else if CHR ''7'' = CHR ''8'' then 8\n       else if CHR ''7'' = CHR ''9'' then 9 else 10) =\n    7 &&&\n    (if CHR ''8'' = CHR ''0'' then 0\n     else if CHR ''8'' = CHR ''1'' then 1\n          else if CHR ''8'' = CHR ''2'' then 2\n               else if CHR ''8'' = CHR ''3'' then 3\n                    else if CHR ''8'' = CHR ''4'' then 4\n                         else if CHR ''8'' = CHR ''5'' then 5\n                              else if CHR ''8'' = CHR ''6'' then 6\n                                   else if CHR ''8'' = CHR ''7'' then 7\n  else if CHR ''8'' = CHR ''8'' then 8\n       else if CHR ''8'' = CHR ''9'' then 9 else 10) =\n    8 &&&\n    (if CHR ''9'' = CHR ''0'' then 0\n     else if CHR ''9'' = CHR ''1'' then 1\n          else if CHR ''9'' = CHR ''2'' then 2\n               else if CHR ''9'' = CHR ''3'' then 3\n                    else if CHR ''9'' = CHR ''4'' then 4\n                         else if CHR ''9'' = CHR ''5'' then 5\n                              else if CHR ''9'' = CHR ''6'' then 6\n                                   else if CHR ''9'' = CHR ''7'' then 7\n  else if CHR ''9'' = CHR ''8'' then 8\n       else if CHR ''9'' = CHR ''9'' then 9 else 10) =\n    9", "by simp_all"], ["", "lemma diget_to_char_inv[simp]:\nassumes is_digit: \"is_digit n\"\nshows \"char_to_digit (digit_to_char n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_to_digit (digit_to_char n) = n", "using is_digit"], ["proof (prove)\nusing this:\n  is_digit n\n\ngoal (1 subgoal):\n 1. char_to_digit (digit_to_char n) = n", "unfolding is_digit_expand"], ["proof (prove)\nusing this:\n  n = 0 \\<or>\n  n = 1 \\<or>\n  n = 2 \\<or>\n  n = 3 \\<or>\n  n = 4 \\<or> n = 5 \\<or> n = 6 \\<or> n = 7 \\<or> n = 8 \\<or> n = 9\n\ngoal (1 subgoal):\n 1. char_to_digit (digit_to_char n) = n", "by auto"], ["", "lemma char_to_diget_inv[simp]:\nassumes is_digit: \"is_digit_char c\"\nshows \"digit_to_char (char_to_digit c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_to_char (char_to_digit c) = c", "using is_digit"], ["proof (prove)\nusing this:\n  is_digit_char c\n\ngoal (1 subgoal):\n 1. digit_to_char (char_to_digit c) = c", "unfolding char_to_digit_def is_digit_char_def"], ["proof (prove)\nusing this:\n  c = CHR ''0'' \\<or>\n  c = CHR ''5'' \\<or>\n  c = CHR ''1'' \\<or>\n  c = CHR ''6'' \\<or>\n  c = CHR ''2'' \\<or>\n  c = CHR ''7'' \\<or>\n  c = CHR ''3'' \\<or> c = CHR ''8'' \\<or> c = CHR ''4'' \\<or> c = CHR ''9''\n\ngoal (1 subgoal):\n 1. digit_to_char\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n    c", "by auto"], ["", "lemma char_to_digit_div_mod [simp]:\nassumes is_digit: \"is_digit_char c\"\nshows \"char_to_digit c < 10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_to_digit c < 10", "using is_digit"], ["proof (prove)\nusing this:\n  is_digit_char c\n\ngoal (1 subgoal):\n 1. char_to_digit c < 10", "unfolding char_to_digit_def is_digit_char_def"], ["proof (prove)\nusing this:\n  c = CHR ''0'' \\<or>\n  c = CHR ''5'' \\<or>\n  c = CHR ''1'' \\<or>\n  c = CHR ''6'' \\<or>\n  c = CHR ''2'' \\<or>\n  c = CHR ''7'' \\<or>\n  c = CHR ''3'' \\<or> c = CHR ''8'' \\<or> c = CHR ''4'' \\<or> c = CHR ''9''\n\ngoal (1 subgoal):\n 1. (if c = CHR ''0'' then 0\n     else if c = CHR ''1'' then 1\n          else if c = CHR ''2'' then 2\n               else if c = CHR ''3'' then 3\n                    else if c = CHR ''4'' then 4\n                         else if c = CHR ''5'' then 5\n                              else if c = CHR ''6'' then 6\n                                   else if c = CHR ''7'' then 7\n  else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10)\n    < 10", "by auto"], ["", "lemma is_digit_char_intro[simp]:\n  \"is_digit (char_to_digit c) = is_digit_char c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_digit (char_to_digit c) = is_digit_char c", "unfolding char_to_digit_def is_digit_char_def is_digit_expand"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     0 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     1 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     2 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     3 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     4 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     5 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     6 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     7 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     8 \\<or>\n     (if c = CHR ''0'' then 0\n      else if c = CHR ''1'' then 1\n           else if c = CHR ''2'' then 2\n                else if c = CHR ''3'' then 3\n                     else if c = CHR ''4'' then 4\n                          else if c = CHR ''5'' then 5\n                               else if c = CHR ''6'' then 6\n                                    else if c = CHR ''7'' then 7\n   else if c = CHR ''8'' then 8 else if c = CHR ''9'' then 9 else 10) =\n     9) =\n    (c = CHR ''0'' \\<or>\n     c = CHR ''5'' \\<or>\n     c = CHR ''1'' \\<or>\n     c = CHR ''6'' \\<or>\n     c = CHR ''2'' \\<or>\n     c = CHR ''7'' \\<or>\n     c = CHR ''3'' \\<or>\n     c = CHR ''8'' \\<or> c = CHR ''4'' \\<or> c = CHR ''9'')", "by auto"], ["", "lemma is_digit_intro[simp]:\n  \"is_digit_char (digit_to_char n) = is_digit n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_digit_char (digit_to_char n) = is_digit n", "unfolding digit_to_char_def is_digit_char_def is_digit_expand"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''0'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''5'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''1'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''6'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''2'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''7'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''3'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''8'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''4'' \\<or>\n     (if n = 0 then CHR ''0''\n      else if n = 1 then CHR ''1''\n           else if n = 2 then CHR ''2''\n                else if n = 3 then CHR ''3''\n                     else if n = 4 then CHR ''4''\n                          else if n = 5 then CHR ''5''\n                               else if n = 6 then CHR ''6''\n                                    else if n = 7 then CHR ''7''\n   else if n = 8 then CHR ''8''\n        else if n = 9 then CHR ''9'' else CHR ''X'') =\n     CHR ''9'') =\n    (n = 0 \\<or>\n     n = 1 \\<or>\n     n = 2 \\<or>\n     n = 3 \\<or>\n     n = 4 \\<or> n = 5 \\<or> n = 6 \\<or> n = 7 \\<or> n = 8 \\<or> n = 9)", "by auto"], ["", "lemma digit_to_char_11:\n\"digit_to_char n1 = digit_to_char n2 \\<Longrightarrow>\n (is_digit n1 = is_digit n2) \\<and> (is_digit n1 \\<longrightarrow> (n1 = n2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_to_char n1 = digit_to_char n2 \\<Longrightarrow>\n    is_digit n1 = is_digit n2 \\<and> (is_digit n1 \\<longrightarrow> n1 = n2)", "by (metis diget_to_char_inv is_digit_intro)"], ["", "lemma char_to_digit_11:\n\"char_to_digit c1 = char_to_digit c2 \\<Longrightarrow>\n (is_digit_char c1 = is_digit_char c2) \\<and> (is_digit_char c1 \\<longrightarrow> (c1 = c2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_to_digit c1 = char_to_digit c2 \\<Longrightarrow>\n    is_digit_char c1 = is_digit_char c2 \\<and>\n    (is_digit_char c1 \\<longrightarrow> c1 = c2)", "by (metis char_to_diget_inv is_digit_char_intro)"], ["", "function nat_to_string :: \"nat \\<Rightarrow> string\" where\n  \"nat_to_string n =\n     (if (is_digit n) then [digit_to_char n] else\n      nat_to_string (n div 10) @ [digit_to_char (n mod 10)])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>n. x = n \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>n na.\n       n = na \\<Longrightarrow>\n       (if is_digit n then [digit_to_char n]\n        else nat_to_string_sumC (n div 10) @ [digit_to_char (n mod 10)]) =\n       (if is_digit na then [digit_to_char na]\n        else nat_to_string_sumC (na div 10) @ [digit_to_char (na mod 10)])", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All nat_to_string_dom", "by (relation \"measure id\") (auto simp add: is_digit_def)"], ["", "definition int_to_string :: \"int \\<Rightarrow> string\" where\n  \"int_to_string i \\<equiv>\n     if i < 0 then\n       ''-'' @ nat_to_string (nat (abs i))\n     else\n       nat_to_string (nat i)\""], ["", "lemma nat_to_string_simps[simp]:\n   \"is_digit n \\<Longrightarrow> nat_to_string n = [digit_to_char n]\"\n  \"\\<not>(is_digit n) \\<Longrightarrow> nat_to_string n = nat_to_string (n div 10) @ [digit_to_char (n mod 10)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_digit n \\<Longrightarrow> nat_to_string n = [digit_to_char n]) &&&\n    (\\<not> is_digit n \\<Longrightarrow>\n     nat_to_string n =\n     nat_to_string (n div 10) @ [digit_to_char (n mod 10)])", "by simp_all"], ["", "declare nat_to_string.simps[simp del]"], ["", "lemma nat_to_string_neq_nil[simp]:\n  \"nat_to_string n \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_string n \\<noteq> []", "by (cases \"is_digit n\") simp_all"], ["", "lemmas nat_to_string_neq_nil2[simp] = nat_to_string_neq_nil[symmetric]"], ["", "lemma nat_to_string_char_to_digit [simp]:\n  \"is_digit_char c \\<Longrightarrow> nat_to_string (char_to_digit c) = [c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_digit_char c \\<Longrightarrow> nat_to_string (char_to_digit c) = [c]", "by auto"], ["", "lemma nat_to_string_11[simp] :\n  \"(nat_to_string n1 = nat_to_string n2) \\<longleftrightarrow> n1 = n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_to_string n1 = nat_to_string n2) = (n1 = n2)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. nat_to_string n1 = nat_to_string n2 \\<Longrightarrow> n1 = n2\n 2. n1 = n2 \\<Longrightarrow> nat_to_string n1 = nat_to_string n2", "assume \"n1 = n2\""], ["proof (state)\nthis:\n  n1 = n2\n\ngoal (2 subgoals):\n 1. nat_to_string n1 = nat_to_string n2 \\<Longrightarrow> n1 = n2\n 2. n1 = n2 \\<Longrightarrow> nat_to_string n1 = nat_to_string n2", "thus \"nat_to_string n1 = nat_to_string n2\""], ["proof (prove)\nusing this:\n  n1 = n2\n\ngoal (1 subgoal):\n 1. nat_to_string n1 = nat_to_string n2", "by simp"], ["proof (state)\nthis:\n  nat_to_string n1 = nat_to_string n2\n\ngoal (1 subgoal):\n 1. nat_to_string n1 = nat_to_string n2 \\<Longrightarrow> n1 = n2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_to_string n1 = nat_to_string n2 \\<Longrightarrow> n1 = n2", "assume \"nat_to_string n1 = nat_to_string n2\""], ["proof (state)\nthis:\n  nat_to_string n1 = nat_to_string n2\n\ngoal (1 subgoal):\n 1. nat_to_string n1 = nat_to_string n2 \\<Longrightarrow> n1 = n2", "thus \"n1 = n2\""], ["proof (prove)\nusing this:\n  nat_to_string n1 = nat_to_string n2\n\ngoal (1 subgoal):\n 1. n1 = n2", "proof (induct n2 arbitrary: n1 rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n1.\n       \\<lbrakk>\\<And>y n1.\n                   \\<lbrakk>y < x;\n                    nat_to_string n1 = nat_to_string y\\<rbrakk>\n                   \\<Longrightarrow> n1 = y;\n        nat_to_string n1 = nat_to_string x\\<rbrakk>\n       \\<Longrightarrow> n1 = x", "case (less n2')"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n2'; nat_to_string ?n1.0 = nat_to_string ?y\\<rbrakk>\n  \\<Longrightarrow> ?n1.0 = ?y\n  nat_to_string n1 = nat_to_string n2'\n\ngoal (1 subgoal):\n 1. \\<And>x n1.\n       \\<lbrakk>\\<And>y n1.\n                   \\<lbrakk>y < x;\n                    nat_to_string n1 = nat_to_string y\\<rbrakk>\n                   \\<Longrightarrow> n1 = y;\n        nat_to_string n1 = nat_to_string x\\<rbrakk>\n       \\<Longrightarrow> n1 = x", "note ind_hyp = this(1)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n2'; nat_to_string ?n1.0 = nat_to_string ?y\\<rbrakk>\n  \\<Longrightarrow> ?n1.0 = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x n1.\n       \\<lbrakk>\\<And>y n1.\n                   \\<lbrakk>y < x;\n                    nat_to_string n1 = nat_to_string y\\<rbrakk>\n                   \\<Longrightarrow> n1 = y;\n        nat_to_string n1 = nat_to_string x\\<rbrakk>\n       \\<Longrightarrow> n1 = x", "note n2s_eq = less(2)"], ["proof (state)\nthis:\n  nat_to_string n1 = nat_to_string n2'\n\ngoal (1 subgoal):\n 1. \\<And>x n1.\n       \\<lbrakk>\\<And>y n1.\n                   \\<lbrakk>y < x;\n                    nat_to_string n1 = nat_to_string y\\<rbrakk>\n                   \\<Longrightarrow> n1 = y;\n        nat_to_string n1 = nat_to_string x\\<rbrakk>\n       \\<Longrightarrow> n1 = x", "have is_dig_eq: \"is_digit n2' = is_digit n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_digit n2' = is_digit n1", "using n2s_eq"], ["proof (prove)\nusing this:\n  nat_to_string n1 = nat_to_string n2'\n\ngoal (1 subgoal):\n 1. is_digit n2' = is_digit n1", "apply (cases \"is_digit n2'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nat_to_string n1 = nat_to_string n2'; is_digit n2'\\<rbrakk>\n    \\<Longrightarrow> is_digit n2' = is_digit n1\n 2. \\<lbrakk>nat_to_string n1 = nat_to_string n2';\n     \\<not> is_digit n2'\\<rbrakk>\n    \\<Longrightarrow> is_digit n2' = is_digit n1", "apply (case_tac [!] \"is_digit n1\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>nat_to_string n1 = nat_to_string n2'; is_digit n2';\n     is_digit n1\\<rbrakk>\n    \\<Longrightarrow> is_digit n2' = is_digit n1\n 2. \\<lbrakk>nat_to_string n1 = nat_to_string n2'; is_digit n2';\n     \\<not> is_digit n1\\<rbrakk>\n    \\<Longrightarrow> is_digit n2' = is_digit n1\n 3. \\<lbrakk>nat_to_string n1 = nat_to_string n2'; \\<not> is_digit n2';\n     is_digit n1\\<rbrakk>\n    \\<Longrightarrow> is_digit n2' = is_digit n1\n 4. \\<lbrakk>nat_to_string n1 = nat_to_string n2'; \\<not> is_digit n2';\n     \\<not> is_digit n1\\<rbrakk>\n    \\<Longrightarrow> is_digit n2' = is_digit n1", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_digit n2' = is_digit n1\n\ngoal (1 subgoal):\n 1. \\<And>x n1.\n       \\<lbrakk>\\<And>y n1.\n                   \\<lbrakk>y < x;\n                    nat_to_string n1 = nat_to_string y\\<rbrakk>\n                   \\<Longrightarrow> n1 = y;\n        nat_to_string n1 = nat_to_string x\\<rbrakk>\n       \\<Longrightarrow> n1 = x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 = n2'", "proof (cases \"is_digit n2'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_digit n2' \\<Longrightarrow> n1 = n2'\n 2. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "case True"], ["proof (state)\nthis:\n  is_digit n2'\n\ngoal (2 subgoals):\n 1. is_digit n2' \\<Longrightarrow> n1 = n2'\n 2. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "with n2s_eq is_dig_eq"], ["proof (chain)\npicking this:\n  nat_to_string n1 = nat_to_string n2'\n  is_digit n2' = is_digit n1\n  is_digit n2'", "show ?thesis"], ["proof (prove)\nusing this:\n  nat_to_string n1 = nat_to_string n2'\n  is_digit n2' = is_digit n1\n  is_digit n2'\n\ngoal (1 subgoal):\n 1. n1 = n2'", "by simp (metis digit_to_char_11)"], ["proof (state)\nthis:\n  n1 = n2'\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "case False"], ["proof (state)\nthis:\n  \\<not> is_digit n2'\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "with is_dig_eq"], ["proof (chain)\npicking this:\n  is_digit n2' = is_digit n1\n  \\<not> is_digit n2'", "have not_digs : \"\\<not> (is_digit n1)\"  \"\\<not> (is_digit n2')\""], ["proof (prove)\nusing this:\n  is_digit n2' = is_digit n1\n  \\<not> is_digit n2'\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n1 &&& \\<not> is_digit n2'", "by simp_all"], ["proof (state)\nthis:\n  \\<not> is_digit n1\n  \\<not> is_digit n2'\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "from not_digs(2)"], ["proof (chain)\npicking this:\n  \\<not> is_digit n2'", "have \"n2' div 10 < n2'\""], ["proof (prove)\nusing this:\n  \\<not> is_digit n2'\n\ngoal (1 subgoal):\n 1. n2' div 10 < n2'", "unfolding is_digit_def"], ["proof (prove)\nusing this:\n  \\<not> n2' < 10\n\ngoal (1 subgoal):\n 1. n2' div 10 < n2'", "by auto"], ["proof (state)\nthis:\n  n2' div 10 < n2'\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "note ind_hyp' = ind_hyp [OF this, of \"n1 div 10\"]"], ["proof (state)\nthis:\n  nat_to_string (n1 div 10) = nat_to_string (n2' div 10) \\<Longrightarrow>\n  n1 div 10 = n2' div 10\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "from not_digs n2s_eq ind_hyp' digit_to_char_11[of \"n1 mod 10\" \"n2' mod 10\"]"], ["proof (chain)\npicking this:\n  \\<not> is_digit n1\n  \\<not> is_digit n2'\n  nat_to_string n1 = nat_to_string n2'\n  nat_to_string (n1 div 10) = nat_to_string (n2' div 10) \\<Longrightarrow>\n  n1 div 10 = n2' div 10\n  digit_to_char (n1 mod 10) = digit_to_char (n2' mod 10) \\<Longrightarrow>\n  is_digit (n1 mod 10) = is_digit (n2' mod 10) \\<and>\n  (is_digit (n1 mod 10) \\<longrightarrow> n1 mod 10 = n2' mod 10)", "have \"(n1 mod 10) = (n2' mod 10)\" \"n1 div 10 = n2' div 10\""], ["proof (prove)\nusing this:\n  \\<not> is_digit n1\n  \\<not> is_digit n2'\n  nat_to_string n1 = nat_to_string n2'\n  nat_to_string (n1 div 10) = nat_to_string (n2' div 10) \\<Longrightarrow>\n  n1 div 10 = n2' div 10\n  digit_to_char (n1 mod 10) = digit_to_char (n2' mod 10) \\<Longrightarrow>\n  is_digit (n1 mod 10) = is_digit (n2' mod 10) \\<and>\n  (is_digit (n1 mod 10) \\<longrightarrow> n1 mod 10 = n2' mod 10)\n\ngoal (1 subgoal):\n 1. n1 mod 10 = n2' mod 10 &&& n1 div 10 = n2' div 10", "by simp_all"], ["proof (state)\nthis:\n  n1 mod 10 = n2' mod 10\n  n1 div 10 = n2' div 10\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n2' \\<Longrightarrow> n1 = n2'", "thus \"n1 = n2'\""], ["proof (prove)\nusing this:\n  n1 mod 10 = n2' mod 10\n  n1 div 10 = n2' div 10\n\ngoal (1 subgoal):\n 1. n1 = n2'", "by (metis div_mult_mod_eq)"], ["proof (state)\nthis:\n  n1 = n2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n1 = n2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n1 = n2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"is_nat_string s \\<equiv> (\\<forall>c\\<in>set s. is_digit_char c)\""], ["", "definition \"is_strong_nat_string s \\<equiv> is_nat_string s \\<and> (s \\<noteq> []) \\<and> (hd s = CHR ''0'' \\<longrightarrow> length s = 1)\""], ["", "lemma is_nat_string_simps[simp]:\n  \"is_nat_string []\"\n  \"is_nat_string (c # s) \\<longleftrightarrow> is_digit_char c \\<and> is_nat_string s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nat_string [] &&&\n    is_nat_string (c # s) = (is_digit_char c \\<and> is_nat_string s)", "unfolding is_nat_string_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set []. is_digit_char c &&&\n    (\\<forall>c\\<in>set (c # s). is_digit_char c) =\n    (is_digit_char c \\<and> (\\<forall>c\\<in>set s. is_digit_char c))", "by simp_all"], ["", "lemma is_strong_nat_string_simps[simp]:\n  \"\\<not>(is_strong_nat_string [])\"\n  \"is_strong_nat_string (c # s) \\<longleftrightarrow> is_digit_char c \\<and> is_nat_string s \\<and>\n                                    (c = CHR ''0'' \\<longrightarrow> s = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_strong_nat_string [] &&&\n    is_strong_nat_string (c # s) =\n    (is_digit_char c \\<and>\n     is_nat_string s \\<and> (c = CHR ''0'' \\<longrightarrow> s = []))", "unfolding is_strong_nat_string_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (is_nat_string [] \\<and>\n            [] \\<noteq> [] \\<and>\n            (hd [] = CHR ''0'' \\<longrightarrow> length [] = 1)) &&&\n    (is_nat_string (c # s) \\<and>\n     c # s \\<noteq> [] \\<and>\n     (hd (c # s) = CHR ''0'' \\<longrightarrow> length (c # s) = 1)) =\n    (is_digit_char c \\<and>\n     is_nat_string s \\<and> (c = CHR ''0'' \\<longrightarrow> s = []))", "by simp_all"], ["", "fun string_to_nat_aux :: \"nat \\<Rightarrow> string \\<Rightarrow> nat\" where\n   \"string_to_nat_aux n [] = n\"\n | \"string_to_nat_aux n (d#ds) =\n    string_to_nat_aux (n*10 + char_to_digit d) ds\""], ["", "definition string_to_nat :: \"string \\<Rightarrow> nat option\" where\n   \"string_to_nat s \\<equiv>\n    (if is_nat_string s then Some (string_to_nat_aux 0 s) else None)\""], ["", "definition string_to_nat' :: \"string \\<Rightarrow> nat\" where\n  \"string_to_nat' s \\<equiv> the (string_to_nat s)\""], ["", "lemma string_to_nat_aux_inv :\nassumes \"is_nat_string s\"\nassumes \"n > 0 \\<or> is_strong_nat_string s\"\nshows \"nat_to_string (string_to_nat_aux n s) =\n(if n = 0 then '''' else nat_to_string n) @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n s) =\n    (if n = 0 then [] else nat_to_string n) @ s", "using assms"], ["proof (prove)\nusing this:\n  is_nat_string s\n  0 < n \\<or> is_strong_nat_string s\n\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n s) =\n    (if n = 0 then [] else nat_to_string n) @ s", "proof (induct s arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>is_nat_string [];\n        0 < n \\<or> is_strong_nat_string []\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n []) =\n                         (if n = 0 then [] else nat_to_string n) @ []\n 2. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "case Nil"], ["proof (state)\nthis:\n  is_nat_string []\n  0 < n \\<or> is_strong_nat_string []\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>is_nat_string [];\n        0 < n \\<or> is_strong_nat_string []\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n []) =\n                         (if n = 0 then [] else nat_to_string n) @ []\n 2. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "thus ?case"], ["proof (prove)\nusing this:\n  is_nat_string []\n  0 < n \\<or> is_strong_nat_string []\n\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n []) =\n    (if n = 0 then [] else nat_to_string n) @ []", "by (simp add: is_strong_nat_string_def)"], ["proof (state)\nthis:\n  nat_to_string (string_to_nat_aux n []) =\n  (if n = 0 then [] else nat_to_string n) @ []\n\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "case (Cons c s n)"], ["proof (state)\nthis:\n  \\<lbrakk>is_nat_string s; 0 < ?n \\<or> is_strong_nat_string s\\<rbrakk>\n  \\<Longrightarrow> nat_to_string (string_to_nat_aux ?n s) =\n                    (if ?n = 0 then [] else nat_to_string ?n) @ s\n  is_nat_string (c # s)\n  0 < n \\<or> is_strong_nat_string (c # s)\n\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "from Cons(2)"], ["proof (chain)\npicking this:\n  is_nat_string (c # s)", "have \"is_digit_char c\" \"is_nat_string s\""], ["proof (prove)\nusing this:\n  is_nat_string (c # s)\n\ngoal (1 subgoal):\n 1. is_digit_char c &&& is_nat_string s", "by simp_all"], ["proof (state)\nthis:\n  is_digit_char c\n  is_nat_string s\n\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "note cs_ok = Cons(3)"], ["proof (state)\nthis:\n  0 < n \\<or> is_strong_nat_string (c # s)\n\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "let ?m = \"n*10 + char_to_digit c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "note ind_hyp = Cons(1)[OF \\<open>is_nat_string s\\<close>, of ?m]"], ["proof (state)\nthis:\n  0 < n * 10 + char_to_digit c \\<or>\n  is_strong_nat_string s \\<Longrightarrow>\n  nat_to_string (string_to_nat_aux (n * 10 + char_to_digit c) s) =\n  (if n * 10 + char_to_digit c = 0 then []\n   else nat_to_string (n * 10 + char_to_digit c)) @\n  s\n\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "from \\<open>is_digit_char c\\<close>"], ["proof (chain)\npicking this:\n  is_digit_char c", "have m_div: \"?m div 10 = n\" and\n                              m_mod: \"?m mod 10 = char_to_digit c\""], ["proof (prove)\nusing this:\n  is_digit_char c\n\ngoal (1 subgoal):\n 1. (n * 10 + char_to_digit c) div 10 = n &&&\n    (n * 10 + char_to_digit c) mod 10 = char_to_digit c", "unfolding is_digit_char_def"], ["proof (prove)\nusing this:\n  c = CHR ''0'' \\<or>\n  c = CHR ''5'' \\<or>\n  c = CHR ''1'' \\<or>\n  c = CHR ''6'' \\<or>\n  c = CHR ''2'' \\<or>\n  c = CHR ''7'' \\<or>\n  c = CHR ''3'' \\<or> c = CHR ''8'' \\<or> c = CHR ''4'' \\<or> c = CHR ''9''\n\ngoal (1 subgoal):\n 1. (n * 10 + char_to_digit c) div 10 = n &&&\n    (n * 10 + char_to_digit c) mod 10 = char_to_digit c", "by auto"], ["proof (state)\nthis:\n  (n * 10 + char_to_digit c) div 10 = n\n  (n * 10 + char_to_digit c) mod 10 = char_to_digit c\n\ngoal (1 subgoal):\n 1. \\<And>a s n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>is_nat_string s;\n                    0 < n \\<or> is_strong_nat_string s\\<rbrakk>\n                   \\<Longrightarrow> nat_to_string (string_to_nat_aux n s) =\n                                     (if n = 0 then []\nelse nat_to_string n) @\n                                     s;\n        is_nat_string (a # s);\n        0 < n \\<or> is_strong_nat_string (a # s)\\<rbrakk>\n       \\<Longrightarrow> nat_to_string (string_to_nat_aux n (a # s)) =\n                         (if n = 0 then [] else nat_to_string n) @ a # s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "proof (cases \"?m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n * 10 + char_to_digit c = 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s\n 2. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "case True"], ["proof (state)\nthis:\n  n * 10 + char_to_digit c = 0\n\ngoal (2 subgoals):\n 1. n * 10 + char_to_digit c = 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s\n 2. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "with \\<open>is_digit_char c\\<close>"], ["proof (chain)\npicking this:\n  is_digit_char c\n  n * 10 + char_to_digit c = 0", "have \"n = 0\" \"c = CHR ''0''\""], ["proof (prove)\nusing this:\n  is_digit_char c\n  n * 10 + char_to_digit c = 0\n\ngoal (1 subgoal):\n 1. n = 0 &&& c = CHR ''0''", "unfolding is_digit_char_def"], ["proof (prove)\nusing this:\n  c = CHR ''0'' \\<or>\n  c = CHR ''5'' \\<or>\n  c = CHR ''1'' \\<or>\n  c = CHR ''6'' \\<or>\n  c = CHR ''2'' \\<or>\n  c = CHR ''7'' \\<or>\n  c = CHR ''3'' \\<or> c = CHR ''8'' \\<or> c = CHR ''4'' \\<or> c = CHR ''9''\n  n * 10 + char_to_digit c = 0\n\ngoal (1 subgoal):\n 1. n = 0 &&& c = CHR ''0''", "by auto"], ["proof (state)\nthis:\n  n = 0\n  c = CHR ''0''\n\ngoal (2 subgoals):\n 1. n * 10 + char_to_digit c = 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s\n 2. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "moreover"], ["proof (state)\nthis:\n  n = 0\n  c = CHR ''0''\n\ngoal (2 subgoals):\n 1. n * 10 + char_to_digit c = 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s\n 2. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "with cs_ok"], ["proof (chain)\npicking this:\n  0 < n \\<or> is_strong_nat_string (c # s)\n  n = 0\n  c = CHR ''0''", "have \"s = []\""], ["proof (prove)\nusing this:\n  0 < n \\<or> is_strong_nat_string (c # s)\n  n = 0\n  c = CHR ''0''\n\ngoal (1 subgoal):\n 1. s = []", "by simp"], ["proof (state)\nthis:\n  s = []\n\ngoal (2 subgoals):\n 1. n * 10 + char_to_digit c = 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s\n 2. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "ultimately"], ["proof (chain)\npicking this:\n  n = 0\n  c = CHR ''0''\n  s = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n  c = CHR ''0''\n  s = []\n\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "by simp"], ["proof (state)\nthis:\n  nat_to_string (string_to_nat_aux n (c # s)) =\n  (if n = 0 then [] else nat_to_string n) @ c # s\n\ngoal (1 subgoal):\n 1. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "case False"], ["proof (state)\nthis:\n  n * 10 + char_to_digit c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "note m_neq_0 = this"], ["proof (state)\nthis:\n  n * 10 + char_to_digit c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "with ind_hyp"], ["proof (chain)\npicking this:\n  0 < n * 10 + char_to_digit c \\<or>\n  is_strong_nat_string s \\<Longrightarrow>\n  nat_to_string (string_to_nat_aux (n * 10 + char_to_digit c) s) =\n  (if n * 10 + char_to_digit c = 0 then []\n   else nat_to_string (n * 10 + char_to_digit c)) @\n  s\n  n * 10 + char_to_digit c \\<noteq> 0", "have ind_hyp':\n      \"nat_to_string (string_to_nat_aux ?m s) = (nat_to_string ?m) @ s\""], ["proof (prove)\nusing this:\n  0 < n * 10 + char_to_digit c \\<or>\n  is_strong_nat_string s \\<Longrightarrow>\n  nat_to_string (string_to_nat_aux (n * 10 + char_to_digit c) s) =\n  (if n * 10 + char_to_digit c = 0 then []\n   else nat_to_string (n * 10 + char_to_digit c)) @\n  s\n  n * 10 + char_to_digit c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux (n * 10 + char_to_digit c) s) =\n    nat_to_string (n * 10 + char_to_digit c) @ s", "by auto"], ["proof (state)\nthis:\n  nat_to_string (string_to_nat_aux (n * 10 + char_to_digit c) s) =\n  nat_to_string (n * 10 + char_to_digit c) @ s\n\ngoal (1 subgoal):\n 1. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "hence \"nat_to_string (string_to_nat_aux n (c # s)) = (nat_to_string ?m) @ s\""], ["proof (prove)\nusing this:\n  nat_to_string (string_to_nat_aux (n * 10 + char_to_digit c) s) =\n  nat_to_string (n * 10 + char_to_digit c) @ s\n\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n (c # s)) =\n    nat_to_string (n * 10 + char_to_digit c) @ s", "by simp"], ["proof (state)\nthis:\n  nat_to_string (string_to_nat_aux n (c # s)) =\n  nat_to_string (n * 10 + char_to_digit c) @ s\n\ngoal (1 subgoal):\n 1. n * 10 + char_to_digit c \\<noteq> 0 \\<Longrightarrow>\n    nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "with \\<open>is_digit_char c\\<close> m_div"], ["proof (chain)\npicking this:\n  is_digit_char c\n  (n * 10 + char_to_digit c) div 10 = n\n  nat_to_string (string_to_nat_aux n (c # s)) =\n  nat_to_string (n * 10 + char_to_digit c) @ s", "show ?thesis"], ["proof (prove)\nusing this:\n  is_digit_char c\n  (n * 10 + char_to_digit c) div 10 = n\n  nat_to_string (string_to_nat_aux n (c # s)) =\n  nat_to_string (n * 10 + char_to_digit c) @ s\n\ngoal (1 subgoal):\n 1. nat_to_string (string_to_nat_aux n (c # s)) =\n    (if n = 0 then [] else nat_to_string n) @ c # s", "by simp"], ["proof (state)\nthis:\n  nat_to_string (string_to_nat_aux n (c # s)) =\n  (if n = 0 then [] else nat_to_string n) @ c # s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_string (string_to_nat_aux n (c # s)) =\n  (if n = 0 then [] else nat_to_string n) @ c # s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma string_to_nat_inv :\nassumes strong_nat_s: \"is_strong_nat_string s\"\nassumes s2n_s: \"string_to_nat s = Some n\"\nshows \"nat_to_string n = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_string n = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_to_string n = s", "from strong_nat_s"], ["proof (chain)\npicking this:\n  is_strong_nat_string s", "have nat_s: \"is_nat_string s\""], ["proof (prove)\nusing this:\n  is_strong_nat_string s\n\ngoal (1 subgoal):\n 1. is_nat_string s", "unfolding is_strong_nat_string_def"], ["proof (prove)\nusing this:\n  is_nat_string s \\<and>\n  s \\<noteq> [] \\<and> (hd s = CHR ''0'' \\<longrightarrow> length s = 1)\n\ngoal (1 subgoal):\n 1. is_nat_string s", "by simp"], ["proof (state)\nthis:\n  is_nat_string s\n\ngoal (1 subgoal):\n 1. nat_to_string n = s", "with s2n_s"], ["proof (chain)\npicking this:\n  string_to_nat s = Some n\n  is_nat_string s", "have n_eq: \"n = string_to_nat_aux 0 s\""], ["proof (prove)\nusing this:\n  string_to_nat s = Some n\n  is_nat_string s\n\ngoal (1 subgoal):\n 1. n = string_to_nat_aux 0 s", "unfolding string_to_nat_def"], ["proof (prove)\nusing this:\n  (if is_nat_string s then Some (string_to_nat_aux 0 s) else None) = Some n\n  is_nat_string s\n\ngoal (1 subgoal):\n 1. n = string_to_nat_aux 0 s", "by simp"], ["proof (state)\nthis:\n  n = string_to_nat_aux 0 s\n\ngoal (1 subgoal):\n 1. nat_to_string n = s", "from string_to_nat_aux_inv[of s 0, folded n_eq] nat_s strong_nat_s"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_nat_string s; 0 < 0 \\<or> is_strong_nat_string s\\<rbrakk>\n  \\<Longrightarrow> nat_to_string n =\n                    (if 0 = 0 then [] else nat_to_string 0) @ s\n  is_nat_string s\n  is_strong_nat_string s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_nat_string s; 0 < 0 \\<or> is_strong_nat_string s\\<rbrakk>\n  \\<Longrightarrow> nat_to_string n =\n                    (if 0 = 0 then [] else nat_to_string 0) @ s\n  is_nat_string s\n  is_strong_nat_string s\n\ngoal (1 subgoal):\n 1. nat_to_string n = s", "by simp"], ["proof (state)\nthis:\n  nat_to_string n = s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_to_string_induct [case_names \"digit\" \"non_digit\"]:\nassumes digit: \"\\<And>d. is_digit d \\<Longrightarrow> P d\"\nassumes not_digit: \"\\<And>n. \\<not>(is_digit n) \\<Longrightarrow> P (n div 10) \\<Longrightarrow> P (n mod 10) \\<Longrightarrow> P n\"\nshows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof (induct n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow> P x", "case (less n)"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow> P x", "note ind_hyp = this"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow> P x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof (cases \"is_digit n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_digit n \\<Longrightarrow> P n\n 2. \\<not> is_digit n \\<Longrightarrow> P n", "case True"], ["proof (state)\nthis:\n  is_digit n\n\ngoal (2 subgoals):\n 1. is_digit n \\<Longrightarrow> P n\n 2. \\<not> is_digit n \\<Longrightarrow> P n", "with digit"], ["proof (chain)\npicking this:\n  is_digit ?d \\<Longrightarrow> P ?d\n  is_digit n", "show ?thesis"], ["proof (prove)\nusing this:\n  is_digit ?d \\<Longrightarrow> P ?d\n  is_digit n\n\ngoal (1 subgoal):\n 1. P n", "by simp"], ["proof (state)\nthis:\n  P n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow> P n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow> P n", "case False"], ["proof (state)\nthis:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow> P n", "note not_dig = this"], ["proof (state)\nthis:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow> P n", "hence \"n div 10 < n\" \"n mod 10 < n\""], ["proof (prove)\nusing this:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. n div 10 < n &&& n mod 10 < n", "unfolding is_digit_def"], ["proof (prove)\nusing this:\n  \\<not> n < 10\n\ngoal (1 subgoal):\n 1. n div 10 < n &&& n mod 10 < n", "by auto"], ["proof (state)\nthis:\n  n div 10 < n\n  n mod 10 < n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow> P n", "with not_dig ind_hyp not_digit"], ["proof (chain)\npicking this:\n  \\<not> is_digit n\n  ?y < n \\<Longrightarrow> P ?y\n  \\<lbrakk>\\<not> is_digit ?n; P (?n div 10); P (?n mod 10)\\<rbrakk>\n  \\<Longrightarrow> P ?n\n  n div 10 < n\n  n mod 10 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_digit n\n  ?y < n \\<Longrightarrow> P ?y\n  \\<lbrakk>\\<not> is_digit ?n; P (?n div 10); P (?n mod 10)\\<rbrakk>\n  \\<Longrightarrow> P ?n\n  n div 10 < n\n  n mod 10 < n\n\ngoal (1 subgoal):\n 1. P n", "by simp"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_to_string___is_nat_string [simp]:\n  \"is_nat_string (nat_to_string n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nat_string (nat_to_string n)", "unfolding is_nat_string_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (nat_to_string n). is_digit_char c", "proof (induct n rule: nat_to_string_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d.\n       is_digit d \\<Longrightarrow>\n       \\<forall>c\\<in>set (nat_to_string d). is_digit_char c\n 2. \\<And>n.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c;\n        \\<forall>c\\<in>set (nat_to_string (n mod 10)).\n           is_digit_char c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (nat_to_string n).\n                            is_digit_char c", "case (digit d)"], ["proof (state)\nthis:\n  is_digit d\n\ngoal (2 subgoals):\n 1. \\<And>d.\n       is_digit d \\<Longrightarrow>\n       \\<forall>c\\<in>set (nat_to_string d). is_digit_char c\n 2. \\<And>n.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c;\n        \\<forall>c\\<in>set (nat_to_string (n mod 10)).\n           is_digit_char c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (nat_to_string n).\n                            is_digit_char c", "thus ?case"], ["proof (prove)\nusing this:\n  is_digit d\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (nat_to_string d). is_digit_char c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set (nat_to_string d). is_digit_char c\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c;\n        \\<forall>c\\<in>set (nat_to_string (n mod 10)).\n           is_digit_char c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (nat_to_string n).\n                            is_digit_char c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c;\n        \\<forall>c\\<in>set (nat_to_string (n mod 10)).\n           is_digit_char c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (nat_to_string n).\n                            is_digit_char c", "case (non_digit n)"], ["proof (state)\nthis:\n  \\<not> is_digit n\n  \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c\n  \\<forall>c\\<in>set (nat_to_string (n mod 10)). is_digit_char c\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c;\n        \\<forall>c\\<in>set (nat_to_string (n mod 10)).\n           is_digit_char c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (nat_to_string n).\n                            is_digit_char c", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> is_digit n\n  \\<forall>c\\<in>set (nat_to_string (n div 10)). is_digit_char c\n  \\<forall>c\\<in>set (nat_to_string (n mod 10)). is_digit_char c\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (nat_to_string n). is_digit_char c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set (nat_to_string n). is_digit_char c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_to_string___eq_0 [simp]:\n  \"(nat_to_string n = (CHR ''0'')#s) \\<longleftrightarrow> (n = 0 \\<and> s = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_to_string n = CHR ''0'' # s) = (n = 0 \\<and> s = [])", "unfolding is_nat_string_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_to_string n = CHR ''0'' # s) = (n = 0 \\<and> s = [])", "proof (induct n arbitrary: s rule: nat_to_string_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d s.\n       is_digit d \\<Longrightarrow>\n       (nat_to_string d = CHR ''0'' # s) = (d = 0 \\<and> s = [])\n 2. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "case (digit d)"], ["proof (state)\nthis:\n  is_digit d\n\ngoal (2 subgoals):\n 1. \\<And>d s.\n       is_digit d \\<Longrightarrow>\n       (nat_to_string d = CHR ''0'' # s) = (d = 0 \\<and> s = [])\n 2. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "thus ?case"], ["proof (prove)\nusing this:\n  is_digit d\n\ngoal (1 subgoal):\n 1. (nat_to_string d = CHR ''0'' # s) = (d = 0 \\<and> s = [])", "unfolding is_digit_expand"], ["proof (prove)\nusing this:\n  d = 0 \\<or>\n  d = 1 \\<or>\n  d = 2 \\<or>\n  d = 3 \\<or>\n  d = 4 \\<or> d = 5 \\<or> d = 6 \\<or> d = 7 \\<or> d = 8 \\<or> d = 9\n\ngoal (1 subgoal):\n 1. (nat_to_string d = CHR ''0'' # s) = (d = 0 \\<and> s = [])", "by auto"], ["proof (state)\nthis:\n  (nat_to_string d = CHR ''0'' # s) = (d = 0 \\<and> s = [])\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "case (non_digit n)"], ["proof (state)\nthis:\n  \\<not> is_digit n\n  (nat_to_string (n div 10) = CHR ''0'' # ?s) =\n  (n div 10 = 0 \\<and> ?s = [])\n  (nat_to_string (n mod 10) = CHR ''0'' # ?s) =\n  (n mod 10 = 0 \\<and> ?s = [])\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "obtain c s' where ns_eq: \"nat_to_string (n div 10) = c # s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c s'.\n        nat_to_string (n div 10) = c # s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"nat_to_string (n div 10)\") auto"], ["proof (state)\nthis:\n  nat_to_string (n div 10) = c # s'\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "from non_digit(1)"], ["proof (chain)\npicking this:\n  \\<not> is_digit n", "have \"n div 10 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. n div 10 \\<noteq> 0", "unfolding is_digit_def"], ["proof (prove)\nusing this:\n  \\<not> n < 10\n\ngoal (1 subgoal):\n 1. n div 10 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n div 10 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "with non_digit(2) ns_eq"], ["proof (chain)\npicking this:\n  (nat_to_string (n div 10) = CHR ''0'' # ?s) =\n  (n div 10 = 0 \\<and> ?s = [])\n  nat_to_string (n div 10) = c # s'\n  n div 10 \\<noteq> 0", "have c_neq: \"c \\<noteq> CHR ''0''\""], ["proof (prove)\nusing this:\n  (nat_to_string (n div 10) = CHR ''0'' # ?s) =\n  (n div 10 = 0 \\<and> ?s = [])\n  nat_to_string (n div 10) = c # s'\n  n div 10 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> CHR ''0''", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<not> is_digit n;\n        \\<And>s.\n           (nat_to_string (n div 10) = CHR ''0'' # s) =\n           (n div 10 = 0 \\<and> s = []);\n        \\<And>s.\n           (nat_to_string (n mod 10) = CHR ''0'' # s) =\n           (n mod 10 = 0 \\<and> s = [])\\<rbrakk>\n       \\<Longrightarrow> (nat_to_string n = CHR ''0'' # s) =\n                         (n = 0 \\<and> s = [])", "from \\<open>\\<not> (is_digit n)\\<close> c_neq ns_eq"], ["proof (chain)\npicking this:\n  \\<not> is_digit n\n  c \\<noteq> CHR ''0''\n  nat_to_string (n div 10) = c # s'", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> is_digit n\n  c \\<noteq> CHR ''0''\n  nat_to_string (n div 10) = c # s'\n\ngoal (1 subgoal):\n 1. (nat_to_string n = CHR ''0'' # s) = (n = 0 \\<and> s = [])", "by auto"], ["proof (state)\nthis:\n  (nat_to_string n = CHR ''0'' # s) = (n = 0 \\<and> s = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_to_string___is_strong_nat_string:\n  \"is_strong_nat_string (nat_to_string n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_strong_nat_string (nat_to_string n)", "proof (cases \"is_digit n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_digit n \\<Longrightarrow> is_strong_nat_string (nat_to_string n)\n 2. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "case True"], ["proof (state)\nthis:\n  is_digit n\n\ngoal (2 subgoals):\n 1. is_digit n \\<Longrightarrow> is_strong_nat_string (nat_to_string n)\n 2. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_digit n\n\ngoal (1 subgoal):\n 1. is_strong_nat_string (nat_to_string n)", "by simp"], ["proof (state)\nthis:\n  is_strong_nat_string (nat_to_string n)\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "case False"], ["proof (state)\nthis:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "note not_digit = this"], ["proof (state)\nthis:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "obtain c s' where ns_eq: \"nat_to_string n = c # s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c s'.\n        nat_to_string n = c # s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"nat_to_string n\") auto"], ["proof (state)\nthis:\n  nat_to_string n = c # s'\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "from not_digit"], ["proof (chain)\npicking this:\n  \\<not> is_digit n", "have \"0 < n\""], ["proof (prove)\nusing this:\n  \\<not> is_digit n\n\ngoal (1 subgoal):\n 1. 0 < n", "unfolding is_digit_def"], ["proof (prove)\nusing this:\n  \\<not> n < 10\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "with ns_eq"], ["proof (chain)\npicking this:\n  nat_to_string n = c # s'\n  0 < n", "have c_neq: \"c \\<noteq> CHR ''0''\""], ["proof (prove)\nusing this:\n  nat_to_string n = c # s'\n  0 < n\n\ngoal (1 subgoal):\n 1. c \\<noteq> CHR ''0''", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "hence \"hd (nat_to_string n) \\<noteq> CHR ''0''\""], ["proof (prove)\nusing this:\n  c \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. hd (nat_to_string n) \\<noteq> CHR ''0''", "unfolding ns_eq"], ["proof (prove)\nusing this:\n  c \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. hd (c # s') \\<noteq> CHR ''0''", "by simp"], ["proof (state)\nthis:\n  hd (nat_to_string n) \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. \\<not> is_digit n \\<Longrightarrow>\n    is_strong_nat_string (nat_to_string n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hd (nat_to_string n) \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. is_strong_nat_string (nat_to_string n)", "unfolding is_strong_nat_string_def"], ["proof (prove)\nusing this:\n  hd (nat_to_string n) \\<noteq> CHR ''0''\n\ngoal (1 subgoal):\n 1. is_nat_string (nat_to_string n) \\<and>\n    nat_to_string n \\<noteq> [] \\<and>\n    (hd (nat_to_string n) = CHR ''0'' \\<longrightarrow>\n     length (nat_to_string n) = 1)", "by simp"], ["proof (state)\nthis:\n  is_strong_nat_string (nat_to_string n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_to_string_inv :\n  \"string_to_nat (nat_to_string n) = Some n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. string_to_nat (nat_to_string n) = Some n", "by (metis nat_to_string_11\n          nat_to_string___is_nat_string\n          nat_to_string___is_strong_nat_string\n          string_to_nat_def\n          string_to_nat_inv)"], ["", "definition The_opt where\n  \"The_opt p = (if (\\<exists>!x. p x) then Some (The p) else None)\""], ["", "lemma The_opt_eq_some [simp] :\n\"((The_opt p) = (Some x)) \\<longleftrightarrow> ((p x) \\<and> ((\\<forall> y.  p y \\<longrightarrow> (x = y))))\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "proof (cases \"\\<exists>!x. p x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n 2. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "case True"], ["proof (state)\nthis:\n  \\<exists>!x. p x\n\ngoal (2 subgoals):\n 1. \\<exists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n 2. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "note exists_unique = this"], ["proof (state)\nthis:\n  \\<exists>!x. p x\n\ngoal (2 subgoals):\n 1. \\<exists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n 2. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "then"], ["proof (chain)\npicking this:\n  \\<exists>!x. p x", "obtain x where p_x: \"p x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. p x\n\ngoal (1 subgoal):\n 1. (\\<And>x. p x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p x\n\ngoal (2 subgoals):\n 1. \\<exists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n 2. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "from the1_equality[of p x] exists_unique p_x"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<exists>!x. p x; p x\\<rbrakk> \\<Longrightarrow> (THE x. p x) = x\n  \\<exists>!x. p x\n  p x", "have the_opt_eq: \"The_opt p = Some x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>!x. p x; p x\\<rbrakk> \\<Longrightarrow> (THE x. p x) = x\n  \\<exists>!x. p x\n  p x\n\ngoal (1 subgoal):\n 1. The_opt p = Some x", "unfolding The_opt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>!x. p x; p x\\<rbrakk> \\<Longrightarrow> (THE x. p x) = x\n  \\<exists>!x. p x\n  p x\n\ngoal (1 subgoal):\n 1. (if Ex1 p then Some (The p) else None) = Some x", "by simp"], ["proof (state)\nthis:\n  The_opt p = Some x\n\ngoal (2 subgoals):\n 1. \\<exists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n 2. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "from exists_unique the_opt_eq p_x"], ["proof (chain)\npicking this:\n  \\<exists>!x. p x\n  The_opt p = Some x\n  p x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!x. p x\n  The_opt p = Some x\n  p x\n\ngoal (1 subgoal):\n 1. (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "by auto"], ["proof (state)\nthis:\n  (The_opt p = Some x) =\n  (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n\ngoal (1 subgoal):\n 1. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "case False"], ["proof (state)\nthis:\n  \\<nexists>!x. p x\n\ngoal (1 subgoal):\n 1. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "note not_unique = this"], ["proof (state)\nthis:\n  \\<nexists>!x. p x\n\ngoal (1 subgoal):\n 1. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "hence \"The_opt p = None\""], ["proof (prove)\nusing this:\n  \\<nexists>!x. p x\n\ngoal (1 subgoal):\n 1. The_opt p = None", "unfolding The_opt_def"], ["proof (prove)\nusing this:\n  \\<nexists>!x. p x\n\ngoal (1 subgoal):\n 1. (if Ex1 p then Some (The p) else None) = None", "by simp"], ["proof (state)\nthis:\n  The_opt p = None\n\ngoal (1 subgoal):\n 1. \\<nexists>!x. p x \\<Longrightarrow>\n    (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "with not_unique"], ["proof (chain)\npicking this:\n  \\<nexists>!x. p x\n  The_opt p = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>!x. p x\n  The_opt p = None\n\ngoal (1 subgoal):\n 1. (The_opt p = Some x) =\n    (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))", "by auto"], ["proof (state)\nthis:\n  (The_opt p = Some x) =\n  (p x \\<and> (\\<forall>y. p y \\<longrightarrow> x = y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma The_opt_eq_none [simp] :\n\"((The_opt p) = None) \\<longleftrightarrow> \\<not>(\\<exists>!x. p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (The_opt p = None) = (\\<nexists>!x. p x)", "unfolding The_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if Ex1 p then Some (The p) else None) = None) = (\\<nexists>!x. p x)", "by auto"], ["", "end"]]}