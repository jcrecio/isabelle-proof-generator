{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Semantic_Extras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma all_distinct_alt_def: \"allDistinct = distinct\"", "lemma find_recfun_someD:\n  assumes \"find_recfun n funs = Some (x, e)\"\n  shows \"(n, x, e) \\<in> set funs\"", "lemma find_recfun_alt_def[simp]: \"find_recfun n funs = map_of funs n\"", "lemma size_list_rev[simp]: \"size_list f (rev xs) = size_list f xs\"", "lemma do_if_cases:\n  obtains\n    (none) \"do_if v e1 e2 = None\"\n  | (true) \"do_if v e1 e2 = Some e1\"\n  | (false) \"do_if v e1 e2 = Some e2\"", "lemma do_log_exp: \"do_log op v e = Some (Exp e') \\<Longrightarrow> e = e'\"", "lemma c_of_merge[simp]: \"c (extend_dec_env env2 env1) = nsAppend (c env2) (c env1)\"", "lemma v_of_merge[simp]: \"sem_env.v (extend_dec_env env2 env1) = nsAppend (sem_env.v env2) (sem_env.v env1)\"", "lemma nsEmpty_nsAppend[simp]: \"nsAppend e nsEmpty = e\" \"nsAppend nsEmpty e = e\"", "lemma do_log_cases:\n  obtains\n    (none) \"do_log op v e = None\"\n  | (val) v' where \"do_log op v e = Some (Val v')\"\n  | (exp) \"do_log op v e = Some (Exp e)\"", "lemma do_opapp_cases:\n  assumes \"do_opapp vs = Some (env', exp')\"\n  obtains (closure) env n v0\n            where \"vs = [Closure env n exp', v0]\"\n                  \"env' = (env \\<lparr> sem_env.v := nsBind n v0 (sem_env.v env) \\<rparr> )\"\n        | (recclosure) env funs name n v0\n            where \"vs = [Recclosure env funs name, v0]\"\n              and \"allDistinct (map (\\<lambda>(f, _, _). f) funs)\"\n              and \"find_recfun name funs = Some (n, exp')\"\n              and \"env' = (env \\<lparr> sem_env.v := nsBind n v0 (build_rec_env funs env (sem_env.v env)) \\<rparr> )\"", "lemmas evaluate_induct =\n  evaluate_match_evaluate_list_evaluate.inducts[split_format(complete)]", "lemma evaluate_clock_mono:\n  \"evaluate_match ck env s v pes v' (s', r1) \\<Longrightarrow> clock s' \\<le> clock s\"\n  \"evaluate_list ck env s es (s', r2) \\<Longrightarrow> clock s' \\<le> clock s\"\n  \"evaluate ck env s e (s', r3) \\<Longrightarrow> clock s' \\<le> clock s\"", "lemma evaluate_list_singleton_valE:\n  assumes \"evaluate_list ck env s [e] (s', Rval vs)\"\n  obtains v where \"vs = [v]\" \"evaluate ck env s e (s', Rval v)\"", "lemma evaluate_list_singleton_errD:\n  assumes \"evaluate_list ck env s [e] (s', Rerr err)\"\n  shows \"evaluate ck env s e (s', Rerr err)\"", "lemma evaluate_list_singleton_cases:\n  assumes \"evaluate_list ck env s [e] res\"\n  obtains (val) s' v where \"res = (s', Rval [v])\" \"evaluate ck env s e (s', Rval v)\"\n        | (err) s' err where \"res = (s', Rerr err)\" \"evaluate ck env s e (s', Rerr err)\"", "lemma evaluate_list_singletonI:\n  assumes \"evaluate ck env s e (s', r)\"\n  shows \"evaluate_list ck env s [e] (s', list_result r)\"", "lemma prod_result_cases:\n  obtains (val) s v where \"r = (s, Rval v)\"\n        | (err) s err where \"r = (s, Rerr err)\"", "lemma do_con_check_build_conv: \"do_con_check (c env) cn (length es) \\<Longrightarrow> build_conv (c env) cn vs \\<noteq> None\"", "lemma match_result_sound:\n  \"case match_result env s v0 pes err_v of\n    Rerr err \\<Rightarrow> evaluate_match ck env s v0 pes err_v (s, Rerr err)\n  | Rval (e, env') \\<Rightarrow>\n      \\<forall>bv.\n        evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env')(sem_env.v env) \\<rparr>) s e bv \\<longrightarrow>\n             evaluate_match ck env s v0 pes err_v bv\"", "lemma match_result_sound_val:\n  assumes \"match_result env s v0 pes err_v = Rval (e, env')\"\n  assumes \"evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env')(sem_env.v env) \\<rparr>) s e bv\"\n  shows \"evaluate_match ck env s v0 pes err_v bv\"", "lemma match_result_sound_err:\n  assumes \"match_result env s v0 pes err_v = Rerr err\"\n  shows \"evaluate_match ck env s v0 pes err_v (s, Rerr err)\"", "lemma match_result_correct:\n  assumes \"evaluate_match ck env s v0 pes err_v (s', bv)\"\n  shows \"case bv of\n          Rval v \\<Rightarrow>\n            \\<exists>e env'. match_result env s v0 pes err_v = Rval (e, env') \\<and> evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rval v)\n        | Rerr err \\<Rightarrow>\n            (match_result env s v0 pes err_v = Rerr err) \\<or>\n            (\\<exists>e env'. match_result env s v0 pes err_v = Rval (e, env') \\<and> evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rerr err))\""], "translations": [["", "lemma all_distinct_alt_def: \"allDistinct = distinct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct = distinct", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. allDistinct x = distinct x", "fix xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. allDistinct x = distinct x", "show \"allDistinct xs = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct xs = distinct xs", "by (induct xs) auto"], ["proof (state)\nthis:\n  allDistinct xs = distinct xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_recfun_someD:\n  assumes \"find_recfun n funs = Some (x, e)\"\n  shows \"(n, x, e) \\<in> set funs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, x, e) \\<in> set funs", "using assms"], ["proof (prove)\nusing this:\n  find_recfun n funs = Some (x, e)\n\ngoal (1 subgoal):\n 1. (n, x, e) \\<in> set funs", "by (induct funs) (auto split: if_splits)"], ["", "lemma find_recfun_alt_def[simp]: \"find_recfun n funs = map_of funs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_recfun n funs = map_of funs n", "by (induction funs) auto"], ["", "lemma size_list_rev[simp]: \"size_list f (rev xs) = size_list f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_list f (rev xs) = size_list f xs", "by (auto simp: size_list_conv_sum_list rev_map[symmetric])"], ["", "lemma do_if_cases:\n  obtains\n    (none) \"do_if v e1 e2 = None\"\n  | (true) \"do_if v e1 e2 = Some e1\"\n  | (false) \"do_if v e1 e2 = Some e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_if v e1 e2 = None \\<Longrightarrow> thesis;\n     do_if v e1 e2 = Some e1 \\<Longrightarrow> thesis;\n     do_if v e1 e2 = Some e2 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding do_if_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if v = Boolv True then Some e1\n              else if v = Boolv False then Some e2 else None) =\n             None \\<Longrightarrow>\n             thesis;\n     (if v = Boolv True then Some e1\n      else if v = Boolv False then Some e2 else None) =\n     Some e1 \\<Longrightarrow>\n     thesis;\n     (if v = Boolv True then Some e1\n      else if v = Boolv False then Some e2 else None) =\n     Some e2 \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by meson"], ["", "case_of_simps do_log_alt_def: do_log.simps"], ["", "case_of_simps do_con_check_alt_def: do_con_check.simps"], ["", "case_of_simps list_result_alt_def: list_result.simps"], ["", "context begin"], ["", "private"], ["", "fun_cases do_logE: \"do_log op v e = res\""], ["", "lemma do_log_exp: \"do_log op v e = Some (Exp e') \\<Longrightarrow> e = e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do_log op v e = Some (Exp e') \\<Longrightarrow> e = e'", "by (erule do_logE)\n   (auto split: v.splits option.splits if_splits tid_or_exn.splits id0.splits list.splits)"], ["", "end"], ["", "lemma c_of_merge[simp]: \"c (extend_dec_env env2 env1) = nsAppend (c env2) (c env1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c (extend_dec_env env2 env1) = nsAppend (c env2) (c env1)", "by (cases env1; cases env2; simp add: extend_dec_env_def)"], ["", "lemma v_of_merge[simp]: \"sem_env.v (extend_dec_env env2 env1) = nsAppend (sem_env.v env2) (sem_env.v env1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem_env.v (extend_dec_env env2 env1) =\n    nsAppend (sem_env.v env2) (sem_env.v env1)", "by (cases env1; cases env2; simp add: extend_dec_env_def)"], ["", "lemma nsEmpty_nsAppend[simp]: \"nsAppend e nsEmpty = e\" \"nsAppend nsEmpty e = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nsAppend e nsEmpty = e &&& nsAppend nsEmpty e = e", "by (cases e; auto simp: nsEmpty_def)+"], ["", "lemma do_log_cases:\n  obtains\n    (none) \"do_log op v e = None\"\n  | (val) v' where \"do_log op v e = Some (Val v')\"\n  | (exp) \"do_log op v e = Some (Exp e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n     \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n     do_log op v e = Some (Exp e) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"do_log op v e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n     \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n     do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n     do_log op v e = None\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n        \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n        do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n        do_log op v e = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "case None"], ["proof (state)\nthis:\n  do_log op v e = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n     \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n     do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n     do_log op v e = None\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n        \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n        do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n        do_log op v e = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  do_log op v e = None", "show ?thesis"], ["proof (prove)\nusing this:\n  do_log op v e = None\n\ngoal (1 subgoal):\n 1. thesis", "using none"], ["proof (prove)\nusing this:\n  do_log op v e = None\n  do_log op v e = None \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n        \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n        do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n        do_log op v e = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n        \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n        do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n        do_log op v e = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Some res)"], ["proof (state)\nthis:\n  do_log op v e = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>do_log op v e = None \\<Longrightarrow> thesis;\n        \\<And>v'. do_log op v e = Some (Val v') \\<Longrightarrow> thesis;\n        do_log op v e = Some (Exp e) \\<Longrightarrow> thesis;\n        do_log op v e = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "with val exp"], ["proof (chain)\npicking this:\n  do_log op v e = Some (Val ?v') \\<Longrightarrow> thesis\n  do_log op v e = Some (Exp e) \\<Longrightarrow> thesis\n  do_log op v e = Some res", "show ?thesis"], ["proof (prove)\nusing this:\n  do_log op v e = Some (Val ?v') \\<Longrightarrow> thesis\n  do_log op v e = Some (Exp e) \\<Longrightarrow> thesis\n  do_log op v e = Some res\n\ngoal (1 subgoal):\n 1. thesis", "by (cases res) (metis do_log_exp)+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "private"], ["", "fun_cases do_opappE: \"do_opapp vs = Some res\""], ["", "lemma do_opapp_cases:\n  assumes \"do_opapp vs = Some (env', exp')\"\n  obtains (closure) env n v0\n            where \"vs = [Closure env n exp', v0]\"\n                  \"env' = (env \\<lparr> sem_env.v := nsBind n v0 (sem_env.v env) \\<rparr> )\"\n        | (recclosure) env funs name n v0\n            where \"vs = [Recclosure env funs name, v0]\"\n              and \"allDistinct (map (\\<lambda>(f, _, _). f) funs)\"\n              and \"find_recfun name funs = Some (n, exp')\"\n              and \"env' = (env \\<lparr> sem_env.v := nsBind n v0 (build_rec_env funs env (sem_env.v env)) \\<rparr> )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>env n v0.\n                \\<lbrakk>vs = [Closure env n exp', v0];\n                 env' =\n                 update_v (\\<lambda>_. nsBind n v0 (sem_env.v env))\n                  env\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>env funs name v0 n.\n        \\<lbrakk>vs = [Recclosure env funs name, v0];\n         allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n         find_recfun name funs = Some (n, exp');\n         env' =\n         update_v\n          (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n          env\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>env n v0.\n                \\<lbrakk>vs = [Closure env n exp', v0];\n                 env' =\n                 update_v (\\<lambda>_. nsBind n v0 (sem_env.v env))\n                  env\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>env funs name v0 n.\n        \\<lbrakk>vs = [Recclosure env funs name, v0];\n         allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n         find_recfun name funs = Some (n, exp');\n         env' =\n         update_v\n          (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n          env\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  do_opapp vs = Some (env', exp')\n\ngoal (1 subgoal):\n 1. thesis", "apply (rule do_opappE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>env n e v2.\n       \\<lbrakk>vs = [Closure env n e, v2];\n        (env', exp') =\n        (update_v (\\<lambda>_. nsBind n v2 (sem_env.v env)) env, e)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>env funs n v2.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        Some (env', exp') =\n        (if allDistinct (map (\\<lambda>(f, x, e). f) funs)\n         then case find_recfun n funs of None \\<Rightarrow> None\n              | Some (n, e) \\<Rightarrow>\n                  Some\n                   (update_v\n                     (\\<lambda>_.\n                         nsBind n v2\n                          (build_rec_env funs env (sem_env.v env)))\n                     env,\n                    e)\n         else None)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule closure; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>env funs n v2.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        Some (env', exp') =\n        (if allDistinct (map (\\<lambda>(f, x, e). f) funs)\n         then case find_recfun n funs of None \\<Rightarrow> None\n              | Some (n, e) \\<Rightarrow>\n                  Some\n                   (update_v\n                     (\\<lambda>_.\n                         nsBind n v2\n                          (build_rec_env funs env (sem_env.v env)))\n                     env,\n                    e)\n         else None)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto split: if_splits option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>env funs n v2 a.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        allDistinct (map (\\<lambda>(f, x, e). f) funs);\n        map_of funs n = Some (a, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind a v2 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule recclosure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>env funs n v2 a.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        allDistinct (map (\\<lambda>(f, x, e). f) funs);\n        map_of funs n = Some (a, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind a v2 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> vs =\n                         [Recclosure (?env40 env funs n v2 a)\n                           (?funs40 env funs n v2 a)\n                           (?name40 env funs n v2 a),\n                          ?v0.40 env funs n v2 a]\n 2. \\<And>env funs n v2 a.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        allDistinct (map (\\<lambda>(f, x, e). f) funs);\n        map_of funs n = Some (a, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind a v2 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> allDistinct\n                          (map (\\<lambda>(f, uu_, uu_). f)\n                            (?funs40 env funs n v2 a))\n 3. \\<And>env funs n v2 a.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        allDistinct (map (\\<lambda>(f, x, e). f) funs);\n        map_of funs n = Some (a, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind a v2 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> find_recfun (?name40 env funs n v2 a)\n                          (?funs40 env funs n v2 a) =\n                         Some (?n40 env funs n v2 a, exp')\n 4. \\<And>env funs n v2 a.\n       \\<lbrakk>vs = [Recclosure env funs n, v2];\n        allDistinct (map (\\<lambda>(f, x, e). f) funs);\n        map_of funs n = Some (a, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind a v2 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> env' =\n                         update_v\n                          (\\<lambda>_.\n                              nsBind (?n40 env funs n v2 a)\n                               (?v0.40 env funs n v2 a)\n                               (build_rec_env (?funs40 env funs n v2 a)\n                                 (?env40 env funs n v2 a)\n                                 (sem_env.v (?env40 env funs n v2 a))))\n                          (?env40 env funs n v2 a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas evaluate_induct =\n  evaluate_match_evaluate_list_evaluate.inducts[split_format(complete)]"], ["", "lemma evaluate_clock_mono:\n  \"evaluate_match ck env s v pes v' (s', r1) \\<Longrightarrow> clock s' \\<le> clock s\"\n  \"evaluate_list ck env s es (s', r2) \\<Longrightarrow> clock s' \\<le> clock s\"\n  \"evaluate ck env s e (s', r3) \\<Longrightarrow> clock s' \\<le> clock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes v' (s', r1) \\<Longrightarrow>\n     clock s' \\<le> clock s) &&&\n    (evaluate_list ck env s es (s', r2) \\<Longrightarrow>\n     clock s' \\<le> clock s) &&&\n    (evaluate ck env s e (s', r3) \\<Longrightarrow> clock s' \\<le> clock s)", "by (induction rule: evaluate_induct)\n    (auto simp del: do_app.simps simp: datatype_record_update split: state.splits if_splits)"], ["", "lemma evaluate_list_singleton_valE:\n  assumes \"evaluate_list ck env s [e] (s', Rval vs)\"\n  obtains v where \"vs = [v]\" \"evaluate ck env s e (s', Rval v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>vs = [v]; evaluate ck env s e (s', Rval v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  evaluate_list ck env s [e] (s', Rval vs)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>vs = [v]; evaluate ck env s e (s', Rval v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: evaluate_list.cases)"], ["", "lemma evaluate_list_singleton_errD:\n  assumes \"evaluate_list ck env s [e] (s', Rerr err)\"\n  shows \"evaluate ck env s e (s', Rerr err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate ck env s e (s', Rerr err)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_list ck env s [e] (s', Rerr err)\n\ngoal (1 subgoal):\n 1. evaluate ck env s e (s', Rerr err)", "by (auto elim: evaluate_list.cases)"], ["", "lemma evaluate_list_singleton_cases:\n  assumes \"evaluate_list ck env s [e] res\"\n  obtains (val) s' v where \"res = (s', Rval [v])\" \"evaluate ck env s e (s', Rval v)\"\n        | (err) s' err where \"res = (s', Rerr err)\" \"evaluate ck env s e (s', Rerr err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' v.\n                \\<lbrakk>res = (s', Rval [v]);\n                 evaluate ck env s e (s', Rval v)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s' err.\n        \\<lbrakk>res = (s', Rerr err);\n         evaluate ck env s e (s', Rerr err)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  evaluate_list ck env s [e] res\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' v.\n                \\<lbrakk>res = (s', Rval [v]);\n                 evaluate ck env s e (s', Rval v)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s' err.\n        \\<lbrakk>res = (s', Rerr err);\n         evaluate ck env s e (s', Rerr err)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s' v.\n                \\<lbrakk>res = (s', Rval [v]);\n                 evaluate ck env s e (s', Rval v)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s' err.\n        \\<lbrakk>res = (s', Rerr err);\n         evaluate ck env s e (s', Rerr err)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     evaluate_list ck env s [e] res\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (ind_cases \"evaluate_list ck env s [e] res\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v1 vs s2 s3.\n       \\<lbrakk>\\<And>s' v.\n                   \\<lbrakk>res = (s', Rval [v]);\n                    evaluate ck env s e (s', Rval v)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s' err.\n           \\<lbrakk>res = (s', Rerr err);\n            evaluate ck env s e (s', Rerr err)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        res = (s3, Rval (v1 # vs)); evaluate ck env s e (s2, Rval v1);\n        evaluate_list ck env s2 [] (s3, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>err s'.\n       \\<lbrakk>\\<And>s' v.\n                   \\<lbrakk>res = (s', Rval [v]);\n                    evaluate ck env s e (s', Rval v)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s' err.\n           \\<lbrakk>res = (s', Rerr err);\n            evaluate ck env s e (s', Rerr err)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        res = (s', Rerr err); evaluate ck env s e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>v1 err s2 s3.\n       \\<lbrakk>\\<And>s' v.\n                   \\<lbrakk>res = (s', Rval [v]);\n                    evaluate ck env s e (s', Rval v)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s' err.\n           \\<lbrakk>res = (s', Rerr err);\n            evaluate ck env s e (s', Rerr err)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        res = (s3, Rerr err); evaluate ck env s e (s2, Rval v1);\n        evaluate_list ck env s2 [] (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v1 vs s2 s3.\n       \\<lbrakk>\\<lbrakk>vs = []; evaluate ck env s e (s3, Rval v1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        res = (s3, Rval (v1 # vs)); evaluate ck env s e (s2, Rval v1);\n        evaluate_list ck env s2 [] (s3, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v1 err s2 s3.\n       \\<lbrakk>evaluate ck env s e (s3, Rerr err) \\<Longrightarrow> thesis;\n        res = (s3, Rerr err); evaluate ck env s e (s2, Rval v1);\n        evaluate_list ck env s2 [] (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (ind_cases \"evaluate_list ck env s2 [] (s3, Rval vs)\" for s2 s3 vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v1 vs s2 s3.\n       \\<lbrakk>\\<lbrakk>vs = []; evaluate ck env s e (s3, Rval v1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        res = (s3, Rval (v1 # vs)); evaluate ck env s e (s2, Rval v1);\n        s2 = s3; vs = []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v1 err s2 s3.\n       \\<lbrakk>evaluate ck env s e (s3, Rerr err) \\<Longrightarrow> thesis;\n        res = (s3, Rerr err); evaluate ck env s e (s2, Rval v1);\n        evaluate_list ck env s2 [] (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v1 err s2 s3.\n       \\<lbrakk>evaluate ck env s e (s3, Rerr err) \\<Longrightarrow> thesis;\n        res = (s3, Rerr err); evaluate ck env s e (s2, Rval v1);\n        evaluate_list ck env s2 [] (s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (ind_cases \" evaluate_list ck env s2 [] (s3, Rerr err) \" for s2 s3 err)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evaluate_list_singletonI:\n  assumes \"evaluate ck env s e (s', r)\"\n  shows \"evaluate_list ck env s [e] (s', list_result r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list ck env s [e] (s', list_result r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate ck env s e (s', r)\n\ngoal (1 subgoal):\n 1. evaluate_list ck env s [e] (s', list_result r)", "by (cases r) (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["", "lemma prod_result_cases:\n  obtains (val) s v where \"r = (s, Rval v)\"\n        | (err) s err where \"r = (s, Rerr err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s v. r = (s, Rval v) \\<Longrightarrow> thesis;\n     \\<And>s err. r = (s, Rerr err) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s v. r = (s, Rval v) \\<Longrightarrow> thesis;\n        \\<And>s err. r = (s, Rerr err) \\<Longrightarrow> thesis;\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for _ b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s v. r = (s, Rval v) \\<Longrightarrow> thesis;\n     \\<And>s err. r = (s, Rerr err) \\<Longrightarrow> thesis;\n     r = (a_, b)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s v. r = (s, Rval v) \\<Longrightarrow> thesis;\n        \\<And>s err. r = (s, Rerr err) \\<Longrightarrow> thesis;\n        r = (a_, b); b = Rval x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>s v. r = (s, Rval v) \\<Longrightarrow> thesis;\n        \\<And>s err. r = (s, Rerr err) \\<Longrightarrow> thesis;\n        r = (a_, b); b = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma do_con_check_build_conv: \"do_con_check (c env) cn (length es) \\<Longrightarrow> build_conv (c env) cn vs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do_con_check (c env) cn (length es) \\<Longrightarrow>\n    build_conv (c env) cn vs \\<noteq> None", "by (cases cn) (auto split: option.splits)"], ["", "fun match_result :: \"(v)sem_env \\<Rightarrow> 'ffi state \\<Rightarrow> v \\<Rightarrow>(pat*exp)list \\<Rightarrow> v \\<Rightarrow> (exp \\<times> (char list \\<times> v) list, v)result\" where\n\"match_result _ _ _ [] err_v = Rerr (Rraise err_v)\" |\n\"match_result env s v0 ((p, e) # pes) err_v =\n  (if Lem_list.allDistinct (pat_bindings p []) then\n    (case pmatch (sem_env.c env) (refs s) p v0 [] of\n      Match env' \\<Rightarrow> Rval (e, env') |\n      No_match \\<Rightarrow> match_result env s v0 pes err_v |\n      Match_type_error \\<Rightarrow> Rerr (Rabort Rtype_error))\n   else\n      Rerr (Rabort Rtype_error))\""], ["", "case_of_simps match_result_alt_def: match_result.simps"], ["", "lemma match_result_sound:\n  \"case match_result env s v0 pes err_v of\n    Rerr err \\<Rightarrow> evaluate_match ck env s v0 pes err_v (s, Rerr err)\n  | Rval (e, env') \\<Rightarrow>\n      \\<forall>bv.\n        evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env')(sem_env.v env) \\<rparr>) s e bv \\<longrightarrow>\n             evaluate_match ck env s v0 pes err_v bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case match_result env s v0 pes err_v of\n    Rval (e, env') \\<Rightarrow>\n      \\<forall>bv.\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e bv \\<longrightarrow>\n         evaluate_match ck env s v0 pes err_v bv\n    | Rerr err \\<Rightarrow>\n        evaluate_match ck env s v0 pes err_v (s, Rerr err)", "by (induction rule: match_result.induct)\n   (auto intro: evaluate_match_evaluate_list_evaluate.intros split: match_result.splits result.splits)"], ["", "lemma match_result_sound_val:\n  assumes \"match_result env s v0 pes err_v = Rval (e, env')\"\n  assumes \"evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env')(sem_env.v env) \\<rparr>) s e bv\"\n  shows \"evaluate_match ck env s v0 pes err_v bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v bv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v bv", "note match_result_sound[where env = env and s = s and ?v0.0 = v0 and pes = pes and err_v = err_v, unfolded assms result.case prod.case]"], ["proof (state)\nthis:\n  \\<forall>bv.\n     evaluate ?ck\n      (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n        env)\n      s e bv \\<longrightarrow>\n     evaluate_match ?ck env s v0 pes err_v bv\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v bv", "with assms"], ["proof (chain)\npicking this:\n  match_result env s v0 pes err_v = Rval (e, env')\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e bv\n  \\<forall>bv.\n     evaluate ?ck\n      (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n        env)\n      s e bv \\<longrightarrow>\n     evaluate_match ?ck env s v0 pes err_v bv", "show ?thesis"], ["proof (prove)\nusing this:\n  match_result env s v0 pes err_v = Rval (e, env')\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e bv\n  \\<forall>bv.\n     evaluate ?ck\n      (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n        env)\n      s e bv \\<longrightarrow>\n     evaluate_match ?ck env s v0 pes err_v bv\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v bv", "by blast"], ["proof (state)\nthis:\n  evaluate_match ck env s v0 pes err_v bv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_result_sound_err:\n  assumes \"match_result env s v0 pes err_v = Rerr err\"\n  shows \"evaluate_match ck env s v0 pes err_v (s, Rerr err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v (s, Rerr err)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v (s, Rerr err)", "note match_result_sound[where env = env and s = s and ?v0.0 = v0 and pes = pes and err_v = err_v, unfolded assms result.case prod.case]"], ["proof (state)\nthis:\n  evaluate_match ?ck env s v0 pes err_v (s, Rerr err)\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v (s, Rerr err)", "then"], ["proof (chain)\npicking this:\n  evaluate_match ?ck env s v0 pes err_v (s, Rerr err)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_match ?ck env s v0 pes err_v (s, Rerr err)\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 pes err_v (s, Rerr err)", "by blast"], ["proof (state)\nthis:\n  evaluate_match ck env s v0 pes err_v (s, Rerr err)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_result_correct:\n  assumes \"evaluate_match ck env s v0 pes err_v (s', bv)\"\n  shows \"case bv of\n          Rval v \\<Rightarrow>\n            \\<exists>e env'. match_result env s v0 pes err_v = Rval (e, env') \\<and> evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rval v)\n        | Rerr err \\<Rightarrow>\n            (match_result env s v0 pes err_v = Rerr err) \\<or>\n            (\\<exists>e env'. match_result env s v0 pes err_v = Rval (e, env') \\<and> evaluate ck (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s e (s', Rerr err))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 pes err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 pes err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 pes err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "using assms"], ["proof (prove)\nusing this:\n  evaluate_match ck env s v0 pes err_v (s', bv)\n\ngoal (1 subgoal):\n 1. case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 pes err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 pes err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 pes err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "proof (induction pes)"], ["proof (state)\ngoal (2 subgoals):\n 1. evaluate_match ck env s v0 [] err_v (s', bv) \\<Longrightarrow>\n    case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 [] err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 [] err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 [] err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))\n 2. \\<And>a pes.\n       \\<lbrakk>evaluate_match ck env s v0 pes err_v\n                 (s', bv) \\<Longrightarrow>\n                case bv of\n                Rval va \\<Rightarrow>\n                  \\<exists>e env'.\n                     match_result env s v0 pes err_v = Rval (e, env') \\<and>\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env)\n                      s e (s', Rval va)\n                | Rerr err \\<Rightarrow>\n                    match_result env s v0 pes err_v = Rerr err \\<or>\n                    (\\<exists>e env'.\n                        match_result env s v0 pes err_v =\n                        Rval (e, env') \\<and>\n                        evaluate ck\n                         (update_v\n                           (\\<lambda>_.\n                               nsAppend (alist_to_ns env') (sem_env.v env))\n                           env)\n                         s e (s', Rerr err));\n        evaluate_match ck env s v0 (a # pes) err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (a # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (a # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (a # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "case (Cons pe pes)"], ["proof (state)\nthis:\n  evaluate_match ck env s v0 pes err_v (s', bv) \\<Longrightarrow>\n  case bv of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v0 pes err_v = Rval (e, env') \\<and>\n       evaluate ck\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (s', Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v0 pes err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v0 pes err_v = Rval (e, env') \\<and>\n          evaluate ck\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (s', Rerr err))\n  evaluate_match ck env s v0 (pe # pes) err_v (s', bv)\n\ngoal (2 subgoals):\n 1. evaluate_match ck env s v0 [] err_v (s', bv) \\<Longrightarrow>\n    case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 [] err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 [] err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 [] err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))\n 2. \\<And>a pes.\n       \\<lbrakk>evaluate_match ck env s v0 pes err_v\n                 (s', bv) \\<Longrightarrow>\n                case bv of\n                Rval va \\<Rightarrow>\n                  \\<exists>e env'.\n                     match_result env s v0 pes err_v = Rval (e, env') \\<and>\n                     evaluate ck\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env)\n                      s e (s', Rval va)\n                | Rerr err \\<Rightarrow>\n                    match_result env s v0 pes err_v = Rerr err \\<or>\n                    (\\<exists>e env'.\n                        match_result env s v0 pes err_v =\n                        Rval (e, env') \\<and>\n                        evaluate ck\n                         (update_v\n                           (\\<lambda>_.\n                               nsAppend (alist_to_ns env') (sem_env.v env))\n                           env)\n                         s e (s', Rerr err));\n        evaluate_match ck env s v0 (a # pes) err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (a # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (a # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (a # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "from Cons.prems"], ["proof (chain)\npicking this:\n  evaluate_match ck env s v0 (pe # pes) err_v (s', bv)", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_match ck env s v0 (pe # pes) err_v (s', bv)\n\ngoal (1 subgoal):\n 1. case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>env' p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = Match env' \\<and>\n        evaluate ck\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s e (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 2. \\<And>p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n        evaluate_match ck env s v0 pes err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 3. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 4. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "case (mat_cons1 env' p e)"], ["proof (state)\nthis:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = Match env' \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e (s', bv)\n\ngoal (4 subgoals):\n 1. \\<And>env' p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = Match env' \\<and>\n        evaluate ck\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s e (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 2. \\<And>p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n        evaluate_match ck env s v0 pes err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 3. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 4. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "then"], ["proof (chain)\npicking this:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = Match env' \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e (s', bv)", "show ?thesis"], ["proof (prove)\nusing this:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = Match env' \\<and>\n  evaluate ck\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s e (s', bv)\n\ngoal (1 subgoal):\n 1. case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "by (cases bv) auto"], ["proof (state)\nthis:\n  case bv of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n       evaluate ck\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (s', Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n          evaluate ck\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (s', Rerr err))\n\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n        evaluate_match ck env s v0 pes err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 2. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 3. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n        evaluate_match ck env s v0 pes err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 2. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 3. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "case (mat_cons2 p e)"], ["proof (state)\nthis:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n  evaluate_match ck env s v0 pes err_v (s', bv)\n\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>pe = (p, e);\n        allDistinct (pat_bindings p []) \\<and>\n        pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n        evaluate_match ck env s v0 pes err_v (s', bv)\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 2. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 3. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "then"], ["proof (chain)\npicking this:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n  evaluate_match ck env s v0 pes err_v (s', bv)", "show ?thesis"], ["proof (prove)\nusing this:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n  evaluate_match ck env s v0 pes err_v (s', bv)\n\ngoal (1 subgoal):\n 1. case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "using Cons.IH"], ["proof (prove)\nusing this:\n  pe = (p, e)\n  allDistinct (pat_bindings p []) \\<and>\n  pmatch (c env) (refs s) p v0 [] = No_match \\<and>\n  evaluate_match ck env s v0 pes err_v (s', bv)\n  evaluate_match ck env s v0 pes err_v (s', bv) \\<Longrightarrow>\n  case bv of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v0 pes err_v = Rval (e, env') \\<and>\n       evaluate ck\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (s', Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v0 pes err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v0 pes err_v = Rval (e, env') \\<and>\n          evaluate ck\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (s', Rerr err))\n\ngoal (1 subgoal):\n 1. case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "by (cases bv) auto"], ["proof (state)\nthis:\n  case bv of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n       evaluate ck\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (s', Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n          evaluate ck\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (s', Rerr err))\n\ngoal (2 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))\n 2. \\<And>p e.\n       \\<lbrakk>pe = (p, e); s' = s; bv = Rerr (Rabort Rtype_error);\n        \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> case bv of\n                         Rval va \\<Rightarrow>\n                           \\<exists>e env'.\n                              match_result env s v0 (pe # pes) err_v =\n                              Rval (e, env') \\<and>\n                              evaluate ck\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsAppend (alist_to_ns env')\n(sem_env.v env))\n                                 env)\n                               s e (s', Rval va)\n                         | Rerr err \\<Rightarrow>\n                             match_result env s v0 (pe # pes) err_v =\n                             Rerr err \\<or>\n                             (\\<exists>e env'.\n                                 match_result env s v0 (pe # pes) err_v =\n                                 Rval (e, env') \\<and>\n                                 evaluate ck\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e (s', Rerr err))", "qed auto"], ["proof (state)\nthis:\n  case bv of\n  Rval va \\<Rightarrow>\n    \\<exists>e env'.\n       match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n       evaluate ck\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)\n        s e (s', Rval va)\n  | Rerr err \\<Rightarrow>\n      match_result env s v0 (pe # pes) err_v = Rerr err \\<or>\n      (\\<exists>e env'.\n          match_result env s v0 (pe # pes) err_v = Rval (e, env') \\<and>\n          evaluate ck\n           (update_v\n             (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n           s e (s', Rerr err))\n\ngoal (1 subgoal):\n 1. evaluate_match ck env s v0 [] err_v (s', bv) \\<Longrightarrow>\n    case bv of\n    Rval va \\<Rightarrow>\n      \\<exists>e env'.\n         match_result env s v0 [] err_v = Rval (e, env') \\<and>\n         evaluate ck\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          s e (s', Rval va)\n    | Rerr err \\<Rightarrow>\n        match_result env s v0 [] err_v = Rerr err \\<or>\n        (\\<exists>e env'.\n            match_result env s v0 [] err_v = Rval (e, env') \\<and>\n            evaluate ck\n             (update_v\n               (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n               env)\n             s e (s', Rerr err))", "qed (auto elim: evaluate_match.cases)"], ["", "end"]]}