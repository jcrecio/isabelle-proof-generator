{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Big_Step_Clocked.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma do_app_no_runtime_error:\n  assumes \"do_app (refs s, ffi s) op0 (rev vs) = Some ((refs', ffi'), res)\"\n  shows \"res \\<noteq> Rerr (Rabort Rtimeout_error)\"", "lemma big_unclocked0:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> ck = False \\<Longrightarrow> snd r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock (fst r1))\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow> ck = False \\<Longrightarrow> snd r2 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock (fst r2))\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> ck = False \\<Longrightarrow> snd r3 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock (fst r3))\"", "lemma big_unclocked1:\n \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>st' r. r1 = (st', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n  \\<longrightarrow> evaluate_match False env (s \\<lparr> clock := cnt \\<rparr>) v pes err_v ((st' \\<lparr> clock := cnt \\<rparr>), r)\"\n \"evaluate_list ck env s es r2 \\<Longrightarrow> \\<forall>st' r. r2 = (st', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n  \\<longrightarrow> evaluate_list False env (s \\<lparr> clock := cnt \\<rparr>) es ((st' \\<lparr> clock := cnt \\<rparr>), r)\"\n \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>st' r. r3 = (st', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n \\<longrightarrow> evaluate False env (s \\<lparr> clock := cnt \\<rparr>) e ((st' \\<lparr> clock := cnt \\<rparr>), r)\"", "lemma big_unclocked_ignore:\n \"evaluate_match ck env s v pes err_v (st', r1) \\<Longrightarrow> r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n    evaluate_match False env (s \\<lparr> clock := cnt \\<rparr>) v pes err_v (st' \\<lparr> clock := cnt \\<rparr>, r1)\"\n \"evaluate_list ck env s es (st', r2) \\<Longrightarrow> r2 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n    evaluate_list False env (s \\<lparr> clock := cnt \\<rparr>) es (st' \\<lparr> clock := cnt \\<rparr>, r2)\"\n \"evaluate ck env s e (st', r3) \\<Longrightarrow> r3 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n    evaluate False env (s \\<lparr> clock := cnt \\<rparr>) e (st' \\<lparr> clock := cnt \\<rparr>, r3)\"", "lemma big_unclocked:\n  assumes \"evaluate False env s e (s',r) \\<Longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  assumes \"evaluate False env s e (s',r) \\<Longrightarrow> clock s = clock s'\"\n  assumes \"evaluate False env (s \\<lparr> clock := count1 \\<rparr>) e ((s' \\<lparr> clock := count1 \\<rparr>),r)\"\n  shows \"evaluate False env (s \\<lparr> clock := count2 \\<rparr>) e ((s' \\<lparr> clock := count2 \\<rparr>),r)\"", "lemma add_to_counter0:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>s' r' extra. (r1 = (s',r')) \\<and> (r' \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (ck = True)\n   \\<longrightarrow> evaluate_match True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) v pes err_v ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r')\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow>  \\<forall>s' r' extra. (r2 = (s',r')) \\<and> (r' \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (ck = True)\n   \\<longrightarrow> evaluate_list True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) es ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r')\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>s' r' extra. (r3 = (s',r')) \\<and> (r' \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (ck = True)\n   \\<longrightarrow> evaluate True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) e ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r')\"", "lemma add_clock:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>s' r'. (r1 = (s', r') \\<and> ck = False\n   \\<longrightarrow> (\\<exists>c. evaluate_match True env (s (| clock := c |)) v pes err_v ((s' (| clock := 0 |)),r')))\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow> \\<forall>s' r'. (r2 = (s', r') \\<and> ck = False\n   \\<longrightarrow> (\\<exists>c. evaluate_list True env (s (| clock := c |)) es ((s' (| clock := 0 |)),r')))\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>s' r'. (r3 = (s', r') \\<and> ck = False\n   \\<longrightarrow> (\\<exists>c. evaluate True env (s (| clock := c |)) e ((s' (| clock := 0 |)),r')))\"", "lemma clock_monotone:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>s' r'. r1 = (s',r') \\<and> (ck=True) \\<longrightarrow> (clock   s') \\<le> (clock   s)\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow> \\<forall>s' r'. r2 = (s',r') \\<and> (ck = True) \\<longrightarrow> (clock   s') \\<le> (clock   s)\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>s' r'. r3 = (s',r') \\<and> (ck = True) \\<longrightarrow> (clock   s') \\<le> (clock   s)\"", "lemma big_clocked_unclocked_equiv:\n  \"evaluate False env s e (s',r1) =\n   (\\<exists>c. evaluate True env (s (| clock := c |)) e ((s' (| clock := 0 |)),r1) \\<and>\n        r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s'))\" (is \"?lhs = ?rhs\")", "lemma big_clocked_timeout_0:\n  \"evaluate_match ck env s v pes err_v r1  \\<Longrightarrow> \\<forall>s'. r1 = (s',Rerr (Rabort Rtimeout_error)) \\<and> ck = True \\<longrightarrow> (clock s') = 0\"\n  \"evaluate_list ck env s es r2  \\<Longrightarrow> \\<forall>s'. r2 = (s',Rerr (Rabort Rtimeout_error)) \\<and> ck = True \\<longrightarrow> (clock s') = 0\"\n  \"evaluate ck env s e r3  \\<Longrightarrow> \\<forall>s'. r3 = (s',Rerr (Rabort Rtimeout_error)) \\<and> ck = True \\<longrightarrow> (clock s') = 0\"", "lemma big_clocked_unclocked_equiv_timeout:\n  \"(\\<forall>r. \\<not>evaluate False env s e r) =\n   (\\<forall>c. \\<exists>s'. evaluate True env (s \\<lparr> clock := c \\<rparr>) e (s',Rerr (Rabort Rtimeout_error)) \\<and> (clock s') = 0)\" (is \"?lhs = ?rhs\")", "lemma sub_from_counter:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n   \\<forall>count count' s' r'.\n    (clock   s) = count + extra1 \\<and>\n    r1 = (s',r') \\<and>\n    (clock   s') = count' + extra1 \\<and>\n    ck = True \\<longrightarrow>\n    evaluate_match True env (s (| clock := count |)) v pes err_v ((s' (| clock := count' |) ),r')\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow>\n   \\<forall>count count' s' r'.\n    (clock   s) = count + extra2 \\<and>\n    r2 = (s',r') \\<and>\n    (clock   s') = count' + extra2 \\<and>\n    ck = True \\<longrightarrow>\n    evaluate_list True env (s (| clock := count |)) es ((s' (| clock := count' |) ),r')\"\n  \"evaluate ck env s e r3 \\<Longrightarrow>\n   \\<forall>count count' s' r'.\n    (clock   s) = count + extra3 \\<and>\n    r3 = (s',r') \\<and>\n    (clock   s') = count' + extra3 \\<and>\n    ck = True \\<longrightarrow>\n    evaluate True env (s (| clock := count |)) e ((s' (| clock := count' |) ),r')\"", "lemma clocked_min_counter:\n  assumes \"evaluate True env s e (s',r')\"\n  shows \"evaluate True env (s (| clock := (clock   s) - (clock   s') |)) e ((s' (| clock := 0 |)),r')\"", "lemma dec_evaluate_not_timeout:\n  \"evaluate_dec False mn env s d (s',r) \\<Longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error)\"", "lemma dec_unclocked_ignore:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   \\<forall>s' r count. res = (s',r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_dec False mn env (s (| clock := count |)) d (s' (| clock := count |),r)\"", "lemma dec_unclocked_1:\n  assumes \"evaluate_dec False mn env s d (s',r)\"\n  shows \"(r \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (clock   s) = (clock   s')\"", "lemma dec_unclocked_2:\n  assumes \"evaluate_dec False mn env (s \\<lparr> clock := count1 \\<rparr>) d ((s' \\<lparr> clock := count1 \\<rparr>),r)\"\n  shows \"evaluate_dec False mn env (s \\<lparr> clock := count2 \\<rparr>) d ((s' \\<lparr> clock := count2 \\<rparr>),r)\"", "lemma dec_unclocked:\n  \"(evaluate_dec False mn env s d (s',r) \\<longrightarrow> (r \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (clock   s) = (clock   s')) \\<and>\n   (evaluate_dec False mn env (s (| clock := count1 |)) d ((s' (| clock := count1 |)),r) \\<longrightarrow>\n   evaluate_dec False mn env (s (| clock := count2 |)) d ((s' (| clock := count2 |)),r))\"", "lemma not_evaluate_dec_timeout:\n  assumes \"\\<forall>r. \\<not>evaluate_dec False mn env s d r\"\n  shows \"\\<exists>r. evaluate_dec True mn env s d r \\<and> snd r = Rerr (Rabort Rtimeout_error)\"", "lemma dec_clocked_total: \"\\<exists>res. evaluate_dec True mn env s d res\"", "lemma dec_clocked_min_counter:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow> ck = True \\<Longrightarrow>\n   evaluate_dec ck mn env (s (| clock := (clock   s) - (clock   (fst res))|)) d (((fst res) (| clock := 0|)), snd res)\"", "lemma dec_sub_from_counter:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   (\\<forall>count count' s' r. (clock   s) = count + extra \\<and> (clock   s') = count' + extra \\<and> res = (s',r) \\<and> ck = True \\<longrightarrow>\n     evaluate_dec ck mn env (s (| clock := count |)) d ((s' (| clock := count' |)),r))\"", "lemma dec_clock_monotone:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow> ck = True \\<Longrightarrow> (clock   (fst res)) \\<le> (clock   s)\"", "lemma dec_add_clock:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   \\<forall>s' r. res = (s',r) \\<and> ck = False \\<longrightarrow> (\\<exists>c. evaluate_dec True mn env (s (| clock := c |)) d ((s' (| clock := 0 |)),r))\"", "lemma dec_add_to_counter:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   \\<forall>s' r extra. res = (s',r) \\<and> ck = True \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec True mn env (s (| clock := (clock   s) + extra |)) d ((s' (| clock := (clock   s') + extra |)),r)\"", "lemma dec_unclocked_unchanged:\n  \"evaluate_dec ck mn env s d r \\<Longrightarrow> ck = False \\<Longrightarrow> (snd r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   (fst r))\"", "lemma dec_clocked_unclocked_equiv:\n  \"evaluate_dec False mn env s1 d (s2,r) =\n  (\\<exists>c. evaluate_dec True mn env (s1 (| clock := c |)) d ((s2 (| clock := 0 |)),r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s1) = (clock   s2))\" (is \"?lhs = ?rhs\")", "lemma decs_add_clock:\n  \"evaluate_decs ck mn env s ds res \\<Longrightarrow>\n   \\<forall>s' r. res = (s',r) \\<and> ck = False \\<longrightarrow> (\\<exists>c. evaluate_decs True mn env (s (| clock := c |)) ds (s' (| clock := 0 |),r))\"", "lemma decs_evaluate_not_timeout:\n  \"evaluate_decs ck mn env s ds r \\<Longrightarrow>\n   \\<forall>s' r'. ck = False \\<and> r = (s',r') \\<longrightarrow> r' \\<noteq> Rerr (Rabort Rtimeout_error)\"", "lemma decs_unclocked_unchanged:\n  \"evaluate_decs ck mn env s ds r \\<Longrightarrow>\n   \\<forall>s' r'. ck = False \\<and> r = (s',r') \\<longrightarrow> r' \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s')\"", "lemma decs_unclocked_ignore:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow> \\<forall>s' r count. res = (s',r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_decs False mn env (s (| clock := count |)) d ((s' (| clock := count |)),r)\"", "lemma decs_unclocked_2:\n  assumes \"evaluate_decs False mn env (s (| clock := count1 |)) ds ((s' (| clock := count1 |)),r)\"\n  shows \"evaluate_decs False mn env (s (| clock := count2 |)) ds ((s' (| clock := count2 |)),r)\"", "lemma decs_unclocked:\n  \"(evaluate_decs False mn env s ds (s',r) \\<longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s')) \\<and>\n   (evaluate_decs False mn env (s (| clock := count1 |)) ds ((s' (| clock := count1 |)),r) =\n   evaluate_decs False mn env (s (| clock := count2 |)) ds ((s' (| clock := count2 |)),r))\"", "lemma not_evaluate_decs_timeout:\n  assumes \"\\<forall>r. \\<not>evaluate_decs False mn env s ds r\"\n  shows \"\\<exists>r. evaluate_decs True mn env s ds r \\<and> (snd r) = Rerr (Rabort Rtimeout_error)\"", "lemma decs_clocked_total: \"\\<exists>res. evaluate_decs True mn env s ds res\"", "lemma decs_clock_monotone:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow> ck = True \\<Longrightarrow> (clock (fst res)) \\<le> (clock s)\"", "lemma decs_sub_from_counter:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow>\n  \\<forall>extra count count' s' r'.\n    (clock s) = count + extra \\<and> (clock s') = count' + extra \\<and>\n    res = (s',r') \\<and> ck = True \\<longrightarrow> evaluate_decs ck mn env (s \\<lparr> clock := count \\<rparr>) d ((s' \\<lparr> clock := count' \\<rparr>),r')\"", "lemma decs_clocked_min_counter:\n  assumes \"evaluate_decs ck mn env s ds res\" \"ck = True\"\n  shows \"evaluate_decs ck mn env (s \\<lparr> clock := clock s - (clock (fst res))\\<rparr>) ds (((fst res) \\<lparr> clock := 0 \\<rparr>),(snd res))\"", "lemma decs_add_to_counter:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow> \\<forall>s' r extra. res = (s',r) \\<and> ck = True \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_decs True mn env (s \\<lparr> clock := clock s + extra \\<rparr>) d ((s' \\<lparr> clock := clock s' + extra \\<rparr>),r)\"", "lemma top_evaluate_not_timeout:\n  \"evaluate_top False env s tp (s',r) \\<Longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error)\"", "lemma top_unclocked_ignore:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"r \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  shows \"evaluate_top False env (s \\<lparr> clock := cnt \\<rparr>) tp ((s' \\<lparr> clock := cnt \\<rparr>),r)\"", "lemma top_unclocked:\n  \"(evaluate_top False env s tp (s',r) \\<longrightarrow> (r \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (clock   s) = (clock   s')) \\<and>\n   (evaluate_top False env (s (| clock := count1 |)) tp ((s' (| clock := count1 |)),r) =\n    evaluate_top False env (s (| clock := count2 |)) tp ((s' (| clock := count2 |)),r))\" (is \"?P \\<and> ?Q\")", "lemma not_evaluate_top_timeout:\n  assumes \"\\<forall>r. \\<not>evaluate_top False env s tp r\"\n  shows \" \\<exists>r. evaluate_top True env s tp r \\<and> (snd r) = Rerr (Rabort Rtimeout_error)\"", "lemma top_clocked_total:\n  \"\\<exists>r. evaluate_top True env s tp r\"", "lemma top_clocked_min_counter:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"ck\"\n  shows \"evaluate_top ck env (s \\<lparr> clock := clock s - clock s' \\<rparr>) tp (s' \\<lparr> clock := 0 \\<rparr>,r)\"", "lemma top_add_clock:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"\\<not>ck\"\n  shows \"\\<exists>c. evaluate_top True env (s (| clock := c |)) tp ((s' (| clock := 0 |)),r)\"", "lemma top_clocked_unclocked_equiv:\n  \"evaluate_top False env s tp (s',r) =\n  (\\<exists>c. evaluate_top True env (s \\<lparr> clock := c \\<rparr>) tp ((s' \\<lparr> clock := 0 \\<rparr>),r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       (clock s) = (clock s'))\" (is \"?P = ?Q\")", "lemma top_clock_monotone:\n  \"evaluate_top ck env s tp (s',r) \\<Longrightarrow> ck = True \\<Longrightarrow> (clock   s') \\<le> (clock   s)\"", "lemma top_sub_from_counter:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"ck = True\" \"(clock   s) = cnt + extra\" \"(clock   s') = cnt' + extra\"\n  shows \"evaluate_top ck env (s (| clock := cnt |)) tp ((s' (| clock := cnt' |)),r)\"", "lemma top_add_to_counter:\n  assumes \"evaluate_top True env s d (s',r)\" \"r \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  shows \"evaluate_top True env (s (| clock := (clock   s) + extra |)) d ((s' (| clock := (clock   s') + extra |)),r)\"", "lemma prog_clock_monotone:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> ck \\<Longrightarrow> (clock (fst res)) \\<le> (clock s)\"", "lemma prog_unclocked_ignore:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> \\<forall>cnt s' r. res = (s',r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n    \\<longrightarrow> evaluate_prog False env (s (| clock := cnt |)) prog ((s' (| clock := cnt |)),r)\"", "lemma prog_unclocked_unchanged:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> \\<not>ck \\<Longrightarrow>(snd res) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   (fst res)) = (clock s)\"", "lemma prog_unclocked_1:\n  assumes \"evaluate_prog False env s prog (s',r)\"\n  shows \"r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s = clock s')\"", "lemma prog_unclocked_2:\n  assumes \"evaluate_prog False env (s \\<lparr> clock := cnt1 \\<rparr>) prog (s' \\<lparr> clock := cnt1 \\<rparr>,r)\"\n  shows \"evaluate_prog False env (s \\<lparr> clock := cnt2 \\<rparr>) prog (s' \\<lparr> clock := cnt2 \\<rparr>,r)\"", "lemma prog_unclocked:\n  \"(evaluate_prog False env s prog (s',r) \\<longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s = clock s')) \\<and>\n   (evaluate_prog False env (s \\<lparr> clock := cnt1 \\<rparr>) prog (s' \\<lparr> clock := cnt1 \\<rparr>,r) =\n   evaluate_prog False env (s \\<lparr> clock := cnt2 \\<rparr>) prog (s' \\<lparr> clock := cnt2 \\<rparr>,r))\"", "lemma not_evaluate_prog_timeout:\n  assumes \"\\<forall>res. \\<not>evaluate_prog False env s prog res\"\n  shows \"\\<exists>r. evaluate_prog True env s prog r \\<and> snd r = Rerr (Rabort Rtimeout_error)\"", "lemma not_evaluate_whole_prog_timeout:\n  assumes \"\\<forall>res. \\<not>evaluate_whole_prog False env s prog res\"\n  shows \"\\<exists>r. evaluate_whole_prog True env s prog r \\<and> snd r = Rerr (Rabort Rtimeout_error)\" (is ?P)", "lemma prog_add_to_counter:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> \\<forall>s' r extra. res = (s',r) \\<and> ck = True \\<and>  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_prog True env (s (| clock := (clock   s) + extra |)) prog ((s' (| clock := (clock   s') + extra |)),r)\"", "lemma prog_sub_from_counter:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow>\n   \\<forall>extra cnt cnt' s' r.\n     (clock   s) = extra + cnt \\<and> (clock   s') = extra + cnt' \\<and> res = (s',r) \\<and> ck = True \\<longrightarrow>\n     evaluate_prog ck env (s (| clock :=  cnt |)) prog ((s' (| clock := cnt' |)),r)\"", "lemma prog_clocked_min_counter:\n  assumes \"evaluate_prog True env s prog (s', r)\"\n  shows \"evaluate_prog True env (s (| clock := (clock   s) - (clock  s') |)) prog (((s') (| clock := 0 |)), r)\"", "lemma prog_add_clock:\n  \"evaluate_prog False env s prog (s', res) \\<Longrightarrow> \\<exists>c. evaluate_prog True env (s (| clock := c |)) prog ((s' (| clock := 0 |)),res)\"", "lemma prog_clocked_unclocked_equiv:\n  \"evaluate_prog False env s prog (s',r) =\n   (\\<exists>c. evaluate_prog True env (s (| clock := c |)) prog ((s' (| clock := 0 |)),r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s'))\" (is \"?lhs = ?rhs\")", "lemma clocked_evaluate:\n  \"(\\<exists>k. BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e (s', r) \\<and> r \\<noteq>  Rerr (Rabort Rtimeout_error)) =\n   (\\<exists>k. BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e ((update_clock (\\<lambda>_. 0) s'), r) \\<and> r \\<noteq>  Rerr (Rabort Rtimeout_error))\""], "translations": [["", "lemma do_app_no_runtime_error:\n  assumes \"do_app (refs s, ffi s) op0 (rev vs) = Some ((refs', ffi'), res)\"\n  shows \"res \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res \\<noteq> Rerr (Rabort Rtimeout_error)", "using assms"], ["proof (prove)\nusing this:\n  do_app (refs s, ffi s) op0 (rev vs) = Some ((refs', ffi'), res)\n\ngoal (1 subgoal):\n 1. res \\<noteq> Rerr (Rabort Rtimeout_error)", "apply (auto\n        split: op0.splits list.splits v.splits lit.splits if_splits word_size.splits\n               eq_result.splits option.splits store_v.splits\n        simp: store_alloc_def store_assign_def call_FFI_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x39 x3 x5 x2a.\n       \\<lbrakk>op0 = FFI x39; vs = [Loc x5, Litv (StrLit x3)];\n        store_lookup x5 (refs s) = Some (W8array x2a);\n        final_event (ffi s) = None; x39 \\<noteq> [];\n        (case case oracle0 (ffi s) x39 (ffi_state (ffi s))\n                    (map (\\<lambda>c2. word_of_nat (of_char c2)) x3) x2a of\n              Oracle_return ffi' bytes' \\<Rightarrow>\n                if length bytes' = length x2a\n                then (update_io_events\n                       (\\<lambda>_.\n                           io_events (ffi s) @\n                           [IO_event x39\n                             (map (\\<lambda>c2. word_of_nat (of_char c2))\n                               x3)\n                             (zipSameLength x2a bytes')])\n                       (update_ffi_state (\\<lambda>_. ffi') (ffi s)),\n                      bytes')\n                else (update_final_event\n                       (\\<lambda>_.\n                           Some\n                            (Final_event x39\n                              (map (\\<lambda>c2. word_of_nat (of_char c2))\n                                x3)\n                              x2a FFI_failed))\n                       (ffi s),\n                      x2a)\n              | Oracle_diverge \\<Rightarrow>\n                  (update_final_event\n                    (\\<lambda>_.\n                        Some\n                         (Final_event x39\n                           (map (\\<lambda>c2. word_of_nat (of_char c2)) x3)\n                           x2a FFI_diverged))\n                    (ffi s),\n                   x2a)\n              | Oracle_fail \\<Rightarrow>\n                  (update_final_event\n                    (\\<lambda>_.\n                        Some\n                         (Final_event x39\n                           (map (\\<lambda>c2. word_of_nat (of_char c2)) x3)\n                           x2a FFI_failed))\n                    (ffi s),\n                   x2a) of\n         (t', ws') \\<Rightarrow>\n           case if x5 < length (refs s) \\<and>\n                   store_v_same_type (refs s ! x5) (W8array ws')\n                then Some ((refs s)[x5 := W8array ws']) else None of\n           None \\<Rightarrow> None\n           | Some s' \\<Rightarrow> Some ((s', t'), Rval (Conv None []))) =\n        Some ((refs', ffi'), Rerr (Rabort Rtimeout_error));\n        res = Rerr (Rabort Rtimeout_error)\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto split: oracle_result.splits if_splits)"], ["", "context\n  notes do_app.simps[simp del]\nbegin"], ["", "private"], ["", "lemma big_unclocked0:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> ck = False \\<Longrightarrow> snd r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock (fst r1))\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow> ck = False \\<Longrightarrow> snd r2 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock (fst r2))\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> ck = False \\<Longrightarrow> snd r3 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s) = (clock (fst r3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>evaluate_match ck env s v pes err_v r1; ck = False\\<rbrakk>\n     \\<Longrightarrow> snd r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                       clock s = clock (fst r1)) &&&\n    (\\<lbrakk>evaluate_list ck env s es r2; ck = False\\<rbrakk>\n     \\<Longrightarrow> snd r2 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                       clock s = clock (fst r2)) &&&\n    (\\<lbrakk>evaluate ck env s e r3; ck = False\\<rbrakk>\n     \\<Longrightarrow> snd r3 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                       clock s = clock (fst r3))", "by (induction rule: evaluate_match_evaluate_list_evaluate.inducts)\n     (auto intro!: do_app_no_runtime_error)"], ["", "corollary big_unclocked_notimeout:\n  \"evaluate_match False env s v pes err_v (s', r1) \\<Longrightarrow> r1 \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  \"evaluate_list False env s es (s', r2) \\<Longrightarrow> r2 \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  \"evaluate False env s e (s', r3) \\<Longrightarrow> r3 \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match False env s v pes err_v (s', r1) \\<Longrightarrow>\n     r1 \\<noteq> Rerr (Rabort Rtimeout_error)) &&&\n    (evaluate_list False env s es (s', r2) \\<Longrightarrow>\n     r2 \\<noteq> Rerr (Rabort Rtimeout_error)) &&&\n    (evaluate False env s e (s', r3) \\<Longrightarrow>\n     r3 \\<noteq> Rerr (Rabort Rtimeout_error))", "using big_unclocked0"], ["proof (prove)\nusing this:\n  \\<lbrakk>evaluate_match ?ck ?env ?s ?v ?pes ?err_v ?r1.0;\n   ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r1.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r1.0)\n  \\<lbrakk>evaluate_list ?ck ?env ?s ?es ?r2.0; ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r2.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r2.0)\n  \\<lbrakk>evaluate ?ck ?env ?s ?e ?r3.0; ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r3.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r3.0)\n\ngoal (1 subgoal):\n 1. (evaluate_match False env s v pes err_v (s', r1) \\<Longrightarrow>\n     r1 \\<noteq> Rerr (Rabort Rtimeout_error)) &&&\n    (evaluate_list False env s es (s', r2) \\<Longrightarrow>\n     r2 \\<noteq> Rerr (Rabort Rtimeout_error)) &&&\n    (evaluate False env s e (s', r3) \\<Longrightarrow>\n     r3 \\<noteq> Rerr (Rabort Rtimeout_error))", "by fastforce+"], ["", "corollary big_unclocked_unchanged:\n  \"evaluate_match False env s v pes err_v (s', r1) \\<Longrightarrow> clock s = clock s'\"\n  \"evaluate_list False env s es (s', r2) \\<Longrightarrow> clock s = clock s'\"\n  \"evaluate False env s e (s', r3) \\<Longrightarrow> clock s = clock s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match False env s v pes err_v (s', r1) \\<Longrightarrow>\n     clock s = clock s') &&&\n    (evaluate_list False env s es (s', r2) \\<Longrightarrow>\n     clock s = clock s') &&&\n    (evaluate False env s e (s', r3) \\<Longrightarrow> clock s = clock s')", "using big_unclocked0"], ["proof (prove)\nusing this:\n  \\<lbrakk>evaluate_match ?ck ?env ?s ?v ?pes ?err_v ?r1.0;\n   ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r1.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r1.0)\n  \\<lbrakk>evaluate_list ?ck ?env ?s ?es ?r2.0; ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r2.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r2.0)\n  \\<lbrakk>evaluate ?ck ?env ?s ?e ?r3.0; ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r3.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r3.0)\n\ngoal (1 subgoal):\n 1. (evaluate_match False env s v pes err_v (s', r1) \\<Longrightarrow>\n     clock s = clock s') &&&\n    (evaluate_list False env s es (s', r2) \\<Longrightarrow>\n     clock s = clock s') &&&\n    (evaluate False env s e (s', r3) \\<Longrightarrow> clock s = clock s')", "by fastforce+"], ["", "private"], ["", "lemma big_unclocked1:\n \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>st' r. r1 = (st', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n  \\<longrightarrow> evaluate_match False env (s \\<lparr> clock := cnt \\<rparr>) v pes err_v ((st' \\<lparr> clock := cnt \\<rparr>), r)\"\n \"evaluate_list ck env s es r2 \\<Longrightarrow> \\<forall>st' r. r2 = (st', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n  \\<longrightarrow> evaluate_list False env (s \\<lparr> clock := cnt \\<rparr>) es ((st' \\<lparr> clock := cnt \\<rparr>), r)\"\n \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>st' r. r3 = (st', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n \\<longrightarrow> evaluate False env (s \\<lparr> clock := cnt \\<rparr>) e ((st' \\<lparr> clock := cnt \\<rparr>), r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n     \\<forall>st' r.\n        r1 = (st', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n        evaluate_match False env (update_clock (\\<lambda>_. cnt) s) v pes\n         err_v (update_clock (\\<lambda>_. cnt) st', r)) &&&\n    (evaluate_list ck env s es r2 \\<Longrightarrow>\n     \\<forall>st' r.\n        r2 = (st', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n        evaluate_list False env (update_clock (\\<lambda>_. cnt) s) es\n         (update_clock (\\<lambda>_. cnt) st', r)) &&&\n    (evaluate ck env s e r3 \\<Longrightarrow>\n     \\<forall>st' r.\n        r3 = (st', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n        evaluate False env (update_clock (\\<lambda>_. cnt) s) e\n         (update_clock (\\<lambda>_. cnt) st', r))", "by (induction arbitrary: cnt and cnt and cnt rule: evaluate_match_evaluate_list_evaluate.inducts)\n   (auto intro: evaluate_match_evaluate_list_evaluate.intros split:if_splits)"], ["", "lemma big_unclocked_ignore:\n \"evaluate_match ck env s v pes err_v (st', r1) \\<Longrightarrow> r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n    evaluate_match False env (s \\<lparr> clock := cnt \\<rparr>) v pes err_v (st' \\<lparr> clock := cnt \\<rparr>, r1)\"\n \"evaluate_list ck env s es (st', r2) \\<Longrightarrow> r2 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n    evaluate_list False env (s \\<lparr> clock := cnt \\<rparr>) es (st' \\<lparr> clock := cnt \\<rparr>, r2)\"\n \"evaluate ck env s e (st', r3) \\<Longrightarrow> r3 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n    evaluate False env (s \\<lparr> clock := cnt \\<rparr>) e (st' \\<lparr> clock := cnt \\<rparr>, r3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>evaluate_match ck env s v pes err_v (st', r1);\n      r1 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n     \\<Longrightarrow> evaluate_match False env\n                        (update_clock (\\<lambda>_. cnt) s) v pes err_v\n                        (update_clock (\\<lambda>_. cnt) st', r1)) &&&\n    (\\<lbrakk>evaluate_list ck env s es (st', r2);\n      r2 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n     \\<Longrightarrow> evaluate_list False env\n                        (update_clock (\\<lambda>_. cnt) s) es\n                        (update_clock (\\<lambda>_. cnt) st', r2)) &&&\n    (\\<lbrakk>evaluate ck env s e (st', r3);\n      r3 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n     \\<Longrightarrow> evaluate False env (update_clock (\\<lambda>_. cnt) s)\n                        e (update_clock (\\<lambda>_. cnt) st', r3))", "by (rule big_unclocked1[rule_format]; (assumption | simp))+"], ["", "lemma big_unclocked:\n  assumes \"evaluate False env s e (s',r) \\<Longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  assumes \"evaluate False env s e (s',r) \\<Longrightarrow> clock s = clock s'\"\n  assumes \"evaluate False env (s \\<lparr> clock := count1 \\<rparr>) e ((s' \\<lparr> clock := count1 \\<rparr>),r)\"\n  shows \"evaluate False env (s \\<lparr> clock := count2 \\<rparr>) e ((s' \\<lparr> clock := count2 \\<rparr>),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate False env (update_clock (\\<lambda>_. count2) s) e\n     (update_clock (\\<lambda>_. count2) s', r)", "using assms big_unclocked0(3) big_unclocked_ignore(3)"], ["proof (prove)\nusing this:\n  evaluate False env s e (s', r) \\<Longrightarrow>\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate False env s e (s', r) \\<Longrightarrow> clock s = clock s'\n  evaluate False env (update_clock (\\<lambda>_. count1) s) e\n   (update_clock (\\<lambda>_. count1) s', r)\n  \\<lbrakk>evaluate ?ck ?env ?s ?e ?r3.0; ?ck = False\\<rbrakk>\n  \\<Longrightarrow> snd ?r3.0 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock ?s = clock (fst ?r3.0)\n  \\<lbrakk>evaluate ?ck ?env ?s ?e (?st', ?r3.0);\n   ?r3.0 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate False ?env (update_clock (\\<lambda>_. ?cnt) ?s)\n                     ?e (update_clock (\\<lambda>_. ?cnt) ?st', ?r3.0)\n\ngoal (1 subgoal):\n 1. evaluate False env (update_clock (\\<lambda>_. count2) s) e\n     (update_clock (\\<lambda>_. count2) s', r)", "by fastforce"], ["", "private"], ["", "lemma add_to_counter0:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>s' r' extra. (r1 = (s',r')) \\<and> (r' \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (ck = True)\n   \\<longrightarrow> evaluate_match True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) v pes err_v ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r')\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow>  \\<forall>s' r' extra. (r2 = (s',r')) \\<and> (r' \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (ck = True)\n   \\<longrightarrow> evaluate_list True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) es ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r')\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>s' r' extra. (r3 = (s',r')) \\<and> (r' \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (ck = True)\n   \\<longrightarrow> evaluate True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) e ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n     \\<forall>s' r' extra.\n        r1 = (s', r') \\<and>\n        r' \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        ck = True \\<longrightarrow>\n        evaluate_match True env\n         (update_clock (\\<lambda>_. clock s + extra) s) v pes err_v\n         (update_clock (\\<lambda>_. clock s' + extra) s', r')) &&&\n    (evaluate_list ck env s es r2 \\<Longrightarrow>\n     \\<forall>s' r' extra.\n        r2 = (s', r') \\<and>\n        r' \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        ck = True \\<longrightarrow>\n        evaluate_list True env\n         (update_clock (\\<lambda>_. clock s + extra) s) es\n         (update_clock (\\<lambda>_. clock s' + extra) s', r')) &&&\n    (evaluate ck env s e r3 \\<Longrightarrow>\n     \\<forall>s' r' extra.\n        r3 = (s', r') \\<and>\n        r' \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        ck = True \\<longrightarrow>\n        evaluate True env (update_clock (\\<lambda>_. clock s + extra) s) e\n         (update_clock (\\<lambda>_. clock s' + extra) s', r'))", "by (induction rule: evaluate_match_evaluate_list_evaluate.inducts)\n   (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["", "corollary add_to_counter:\n  \"evaluate_match True env s v pes err_v (s', r1) \\<Longrightarrow> r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n     evaluate_match True env (s \\<lparr> clock := clock s + extra \\<rparr>) v pes err_v ((s' \\<lparr> clock := clock s' + extra \\<rparr>), r1)\"\n  \"evaluate_list True env s es (s', r2) \\<Longrightarrow> r2 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n     evaluate_list True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) es ((s' \\<lparr> clock := (clock   s')+ extra\\<rparr>),r2)\"\n  \"evaluate True env s e (s', r3) \\<Longrightarrow> r3 \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n     evaluate True env (s \\<lparr> clock := (clock   s)+extra \\<rparr>) e ((s' \\<lparr> clock := (clock s')+ extra\\<rparr>),r3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>evaluate_match True env s v pes err_v (s', r1);\n      r1 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n     \\<Longrightarrow> evaluate_match True env\n                        (update_clock (\\<lambda>_. clock s + extra) s) v pes\n                        err_v\n                        (update_clock (\\<lambda>_. clock s' + extra) s',\n                         r1)) &&&\n    (\\<lbrakk>evaluate_list True env s es (s', r2);\n      r2 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n     \\<Longrightarrow> evaluate_list True env\n                        (update_clock (\\<lambda>_. clock s + extra) s) es\n                        (update_clock (\\<lambda>_. clock s' + extra) s',\n                         r2)) &&&\n    (\\<lbrakk>evaluate True env s e (s', r3);\n      r3 \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n     \\<Longrightarrow> evaluate True env\n                        (update_clock (\\<lambda>_. clock s + extra) s) e\n                        (update_clock (\\<lambda>_. clock s' + extra) s',\n                         r3))", "by (rule add_to_counter0[rule_format]; (assumption | simp))+"], ["", "lemma add_clock:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>s' r'. (r1 = (s', r') \\<and> ck = False\n   \\<longrightarrow> (\\<exists>c. evaluate_match True env (s (| clock := c |)) v pes err_v ((s' (| clock := 0 |)),r')))\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow> \\<forall>s' r'. (r2 = (s', r') \\<and> ck = False\n   \\<longrightarrow> (\\<exists>c. evaluate_list True env (s (| clock := c |)) es ((s' (| clock := 0 |)),r')))\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>s' r'. (r3 = (s', r') \\<and> ck = False\n   \\<longrightarrow> (\\<exists>c. evaluate True env (s (| clock := c |)) e ((s' (| clock := 0 |)),r')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n     \\<forall>s' r'.\n        r1 = (s', r') \\<and> ck = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate_match True env (update_clock (\\<lambda>_. c) s) v pes\n             err_v (update_clock (\\<lambda>_. 0) s', r'))) &&&\n    (evaluate_list ck env s es r2 \\<Longrightarrow>\n     \\<forall>s' r'.\n        r2 = (s', r') \\<and> ck = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate_list True env (update_clock (\\<lambda>_. c) s) es\n             (update_clock (\\<lambda>_. 0) s', r'))) &&&\n    (evaluate ck env s e r3 \\<Longrightarrow>\n     \\<forall>s' r'.\n        r3 = (s', r') \\<and> ck = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate True env (update_clock (\\<lambda>_. c) s) e\n             (update_clock (\\<lambda>_. 0) s', r')))", "proof (induction rule:evaluate_match_evaluate_list_evaluate.inducts)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>ck env l s.\n       \\<forall>s' r'.\n          (s, Rval (Litv l)) = (s', r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Lit l)\n               (update_clock (\\<lambda>_. 0) s', r'))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s' r'.\n           (s2, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Raise e)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<forall>s' r'.\n           (s2, Rerr err) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr err) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Raise e)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s' r'.\n           (s2, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rval v1) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Handle e pes)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 5. \\<And>ck s1 s2 env e pes v1 bv.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>s' r'.\n            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n            ck = False \\<longrightarrow>\n            (\\<exists>c.\n                evaluate True env (update_clock (\\<lambda>_. c) s1) e\n                 (update_clock (\\<lambda>_. 0) s', r')))) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>s' r'.\n           bv = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_match True env (update_clock (\\<lambda>_. c) s2) v1\n                pes v1\n                (update_clock (\\<lambda>_. 0) s', r'))) \\<Longrightarrow>\n       \\<forall>s' r'.\n          bv = (s', r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s1)\n               (Handle e pes) (update_clock (\\<lambda>_. 0) s', r'))\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<forall>s' r'.\n           (s2, Rerr (Rabort a)) = (s', r') \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True env (update_clock (\\<lambda>_. c) s1) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True env\n                                 (update_clock (\\<lambda>_. c) s1)\n                                 (Handle e pes)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 7. \\<And>ck env cn es vs s s' v1.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>s'a r'.\n           (s', Rval vs) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_list True env (update_clock (\\<lambda>_. c) s)\n                (rev es)\n                (update_clock (\\<lambda>_. 0) s'a, r'))) \\<Longrightarrow>\n       \\<forall>s'a r'.\n          (s', Rval v1) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s'a, r'))\n 8. \\<And>ck env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>s' r'.\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s', r'))\n 9. \\<And>ck env cn es err s s'.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>s'a r'.\n           (s', Rerr err) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_list True env (update_clock (\\<lambda>_. c) s)\n                (rev es)\n                (update_clock (\\<lambda>_. 0) s'a, r'))) \\<Longrightarrow>\n       \\<forall>s'a r'.\n          (s', Rerr err) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s'a, r'))\n 10. \\<And>ck env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>s' r'.\n           (s, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True env (update_clock (\\<lambda>_. c) s) (Var n)\n                (update_clock (\\<lambda>_. 0) s', r'))\nA total of 42 subgoals...", "case app1"], ["proof (state)\nthis:\n  (evaluate_list ck_ env_ s1_ (rev es_) (s2_, Rval vs_) \\<and>\n   (\\<forall>s' r'.\n       (s2_, Rval vs_) = (s', r') \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_list True env_ (update_clock (\\<lambda>_. c) s1_)\n            (rev es_) (update_clock (\\<lambda>_. 0) s', r')))) \\<and>\n  do_opapp (rev vs_) = Some (env'_, e_) \\<and>\n  (ck_ \\<longrightarrow> clock s2_ \\<noteq> 0) \\<and>\n  evaluate ck_ env'_\n   (if ck_ then update_clock (\\<lambda>_. clock s2_ - 1) s2_ else s2_) e_\n   bv_ \\<and>\n  (\\<forall>s' r'.\n      bv_ = (s', r') \\<and> ck_ = False \\<longrightarrow>\n      (\\<exists>c.\n          evaluate True env'_\n           (update_clock (\\<lambda>_. c)\n             (if ck_ then update_clock (\\<lambda>_. clock s2_ - 1) s2_\n              else s2_))\n           e_ (update_clock (\\<lambda>_. 0) s', r')))\n\ngoal (42 subgoals):\n 1. \\<And>ck env l s.\n       \\<forall>s' r'.\n          (s, Rval (Litv l)) = (s', r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Lit l)\n               (update_clock (\\<lambda>_. 0) s', r'))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s' r'.\n           (s2, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Raise e)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<forall>s' r'.\n           (s2, Rerr err) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr err) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Raise e)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s' r'.\n           (s2, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rval v1) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Handle e pes)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 5. \\<And>ck s1 s2 env e pes v1 bv.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>s' r'.\n            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n            ck = False \\<longrightarrow>\n            (\\<exists>c.\n                evaluate True env (update_clock (\\<lambda>_. c) s1) e\n                 (update_clock (\\<lambda>_. 0) s', r')))) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>s' r'.\n           bv = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_match True env (update_clock (\\<lambda>_. c) s2) v1\n                pes v1\n                (update_clock (\\<lambda>_. 0) s', r'))) \\<Longrightarrow>\n       \\<forall>s' r'.\n          bv = (s', r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s1)\n               (Handle e pes) (update_clock (\\<lambda>_. 0) s', r'))\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<forall>s' r'.\n           (s2, Rerr (Rabort a)) = (s', r') \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True env (update_clock (\\<lambda>_. c) s1) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True env\n                                 (update_clock (\\<lambda>_. c) s1)\n                                 (Handle e pes)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 7. \\<And>ck env cn es vs s s' v1.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>s'a r'.\n           (s', Rval vs) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_list True env (update_clock (\\<lambda>_. c) s)\n                (rev es)\n                (update_clock (\\<lambda>_. 0) s'a, r'))) \\<Longrightarrow>\n       \\<forall>s'a r'.\n          (s', Rval v1) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s'a, r'))\n 8. \\<And>ck env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>s' r'.\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s', r'))\n 9. \\<And>ck env cn es err s s'.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>s'a r'.\n           (s', Rerr err) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_list True env (update_clock (\\<lambda>_. c) s)\n                (rev es)\n                (update_clock (\\<lambda>_. 0) s'a, r'))) \\<Longrightarrow>\n       \\<forall>s'a r'.\n          (s', Rerr err) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s'a, r'))\n 10. \\<And>ck env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>s' r'.\n           (s, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True env (update_clock (\\<lambda>_. c) s) (Var n)\n                (update_clock (\\<lambda>_. 0) s', r'))\nA total of 42 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck_ env_ s1_ (rev es_) (s2_, Rval vs_) \\<and>\n   (\\<forall>s' r'.\n       (s2_, Rval vs_) = (s', r') \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_list True env_ (update_clock (\\<lambda>_. c) s1_)\n            (rev es_) (update_clock (\\<lambda>_. 0) s', r')))) \\<and>\n  do_opapp (rev vs_) = Some (env'_, e_) \\<and>\n  (ck_ \\<longrightarrow> clock s2_ \\<noteq> 0) \\<and>\n  evaluate ck_ env'_\n   (if ck_ then update_clock (\\<lambda>_. clock s2_ - 1) s2_ else s2_) e_\n   bv_ \\<and>\n  (\\<forall>s' r'.\n      bv_ = (s', r') \\<and> ck_ = False \\<longrightarrow>\n      (\\<exists>c.\n          evaluate True env'_\n           (update_clock (\\<lambda>_. c)\n             (if ck_ then update_clock (\\<lambda>_. clock s2_ - 1) s2_\n              else s2_))\n           e_ (update_clock (\\<lambda>_. 0) s', r')))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck_ env_ s1_ (rev es_) (s2_, Rval vs_) \\<and>\n   (\\<forall>s' r'.\n       (s2_, Rval vs_) = (s', r') \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_list True env_ (update_clock (\\<lambda>_. c) s1_)\n            (rev es_) (update_clock (\\<lambda>_. 0) s', r')))) \\<and>\n  do_opapp (rev vs_) = Some (env'_, e_) \\<and>\n  (ck_ \\<longrightarrow> clock s2_ \\<noteq> 0) \\<and>\n  evaluate ck_ env'_\n   (if ck_ then update_clock (\\<lambda>_. clock s2_ - 1) s2_ else s2_) e_\n   bv_ \\<and>\n  (\\<forall>s' r'.\n      bv_ = (s', r') \\<and> ck_ = False \\<longrightarrow>\n      (\\<exists>c.\n          evaluate True env'_\n           (update_clock (\\<lambda>_. c)\n             (if ck_ then update_clock (\\<lambda>_. clock s2_ - 1) s2_\n              else s2_))\n           e_ (update_clock (\\<lambda>_. 0) s', r')))\n\ngoal (1 subgoal):\n 1. \\<forall>s' r'.\n       bv_ = (s', r') \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate True env_ (update_clock (\\<lambda>_. c) s1_)\n            (App Opapp es_) (update_clock (\\<lambda>_. 0) s', r'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' r' c ca.\n       \\<lbrakk>evaluate_list False env_ s1_ (rev es_) (s2_, Rval vs_);\n        do_opapp (rev vs_) = Some (env'_, e_);\n        evaluate False env'_ s2_ e_ (s', r'); \\<not> ck_; bv_ = (s', r');\n        evaluate_list True env_ (update_clock (\\<lambda>_. c) s1_) (rev es_)\n         (update_clock (\\<lambda>_. 0) s2_, Rval vs_);\n        evaluate True env'_ (update_clock (\\<lambda>_. ca) s2_) e_\n         (update_clock (\\<lambda>_. 0) s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate True env_\n                             (update_clock (\\<lambda>_. c) s1_)\n                             (App Opapp es_)\n                             (update_clock (\\<lambda>_. 0) s', r')", "subgoal for s' r' c c'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_list False env_ s1_ (rev es_) (s2_, Rval vs_);\n     do_opapp (rev vs_) = Some (env'_, e_);\n     evaluate False env'_ s2_ e_ (s', r'); \\<not> ck_; bv_ = (s', r');\n     evaluate_list True env_ (update_clock (\\<lambda>_. c) s1_) (rev es_)\n      (update_clock (\\<lambda>_. 0) s2_, Rval vs_);\n     evaluate True env'_ (update_clock (\\<lambda>_. c') s2_) e_\n      (update_clock (\\<lambda>_. 0) s', r')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate True env_\n                          (update_clock (\\<lambda>_. c) s1_) (App Opapp es_)\n                          (update_clock (\\<lambda>_. 0) s', r')", "apply (drule add_to_counter(2)[where extra = \"c'+1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate_list False env_ s1_ (rev es_) (s2_, Rval vs_);\n     do_opapp (rev vs_) = Some (env'_, e_);\n     evaluate False env'_ s2_ e_ (s', r'); \\<not> ck_; bv_ = (s', r');\n     evaluate True env'_ (update_clock (\\<lambda>_. c') s2_) e_\n      (update_clock (\\<lambda>_. 0) s', r')\\<rbrakk>\n    \\<Longrightarrow> Rval vs_ \\<noteq> Rerr (Rabort Rtimeout_error)\n 2. \\<lbrakk>evaluate_list False env_ s1_ (rev es_) (s2_, Rval vs_);\n     do_opapp (rev vs_) = Some (env'_, e_);\n     evaluate False env'_ s2_ e_ (s', r'); \\<not> ck_; bv_ = (s', r');\n     evaluate True env'_ (update_clock (\\<lambda>_. c') s2_) e_\n      (update_clock (\\<lambda>_. 0) s', r');\n     evaluate_list True env_\n      (update_clock\n        (\\<lambda>_. clock (update_clock (\\<lambda>_. c) s1_) + (c' + 1))\n        (update_clock (\\<lambda>_. c) s1_))\n      (rev es_)\n      (update_clock\n        (\\<lambda>_. clock (update_clock (\\<lambda>_. 0) s2_) + (c' + 1))\n        (update_clock (\\<lambda>_. 0) s2_),\n       Rval vs_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate True env_\n                          (update_clock (\\<lambda>_. c) s1_) (App Opapp es_)\n                          (update_clock (\\<lambda>_. 0) s', r')", "by (auto intro!: evaluate_match_evaluate_list_evaluate.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>s' r'.\n     bv_ = (s', r') \\<and> ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate True env_ (update_clock (\\<lambda>_. c) s1_)\n          (App Opapp es_) (update_clock (\\<lambda>_. 0) s', r'))\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s.\n       \\<forall>s' r'.\n          (s, Rval (Litv l)) = (s', r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Lit l)\n               (update_clock (\\<lambda>_. 0) s', r'))\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s' r'.\n           (s2, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Raise e)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<forall>s' r'.\n           (s2, Rerr err) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr err) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Raise e)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s' r'.\n           (s2, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True s1 (update_clock (\\<lambda>_. c) env) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rval v1) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True s1\n                                 (update_clock (\\<lambda>_. c) env)\n                                 (Handle e pes)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 5. \\<And>ck s1 s2 env e pes v1 bv.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>s' r'.\n            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n            ck = False \\<longrightarrow>\n            (\\<exists>c.\n                evaluate True env (update_clock (\\<lambda>_. c) s1) e\n                 (update_clock (\\<lambda>_. 0) s', r')))) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>s' r'.\n           bv = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_match True env (update_clock (\\<lambda>_. c) s2) v1\n                pes v1\n                (update_clock (\\<lambda>_. 0) s', r'))) \\<Longrightarrow>\n       \\<forall>s' r'.\n          bv = (s', r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s1)\n               (Handle e pes) (update_clock (\\<lambda>_. 0) s', r'))\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<forall>s' r'.\n           (s2, Rerr (Rabort a)) = (s', r') \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True env (update_clock (\\<lambda>_. c) s1) e\n                (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s' r'.\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            ck = False \\<longrightarrow>\n                            (\\<exists>c.\n                                evaluate True env\n                                 (update_clock (\\<lambda>_. c) s1)\n                                 (Handle e pes)\n                                 (update_clock (\\<lambda>_. 0) s', r'))\n 7. \\<And>ck env cn es vs s s' v1.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>s'a r'.\n           (s', Rval vs) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_list True env (update_clock (\\<lambda>_. c) s)\n                (rev es)\n                (update_clock (\\<lambda>_. 0) s'a, r'))) \\<Longrightarrow>\n       \\<forall>s'a r'.\n          (s', Rval v1) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s'a, r'))\n 8. \\<And>ck env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>s' r'.\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s', r'))\n 9. \\<And>ck env cn es err s s'.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>s'a r'.\n           (s', Rerr err) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_list True env (update_clock (\\<lambda>_. c) s)\n                (rev es)\n                (update_clock (\\<lambda>_. 0) s'a, r'))) \\<Longrightarrow>\n       \\<forall>s'a r'.\n          (s', Rerr err) = (s'a, r') \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate True env (update_clock (\\<lambda>_. c) s) (Con cn es)\n               (update_clock (\\<lambda>_. 0) s'a, r'))\n 10. \\<And>ck env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>s' r'.\n           (s, Rval v1) = (s', r') \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate True env (update_clock (\\<lambda>_. c) s) (Var n)\n                (update_clock (\\<lambda>_. 0) s', r'))\nA total of 41 subgoals...", "qed (force intro: evaluate_match_evaluate_list_evaluate.intros dest:add_to_counter(3))+"], ["", "lemma clock_monotone:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow> \\<forall>s' r'. r1 = (s',r') \\<and> (ck=True) \\<longrightarrow> (clock   s') \\<le> (clock   s)\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow> \\<forall>s' r'. r2 = (s',r') \\<and> (ck = True) \\<longrightarrow> (clock   s') \\<le> (clock   s)\"\n  \"evaluate ck env s e r3 \\<Longrightarrow> \\<forall>s' r'. r3 = (s',r') \\<and> (ck = True) \\<longrightarrow> (clock   s') \\<le> (clock   s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n     \\<forall>s' r'.\n        r1 = (s', r') \\<and> ck = True \\<longrightarrow>\n        clock s' \\<le> clock s) &&&\n    (evaluate_list ck env s es r2 \\<Longrightarrow>\n     \\<forall>s' r'.\n        r2 = (s', r') \\<and> ck = True \\<longrightarrow>\n        clock s' \\<le> clock s) &&&\n    (evaluate ck env s e r3 \\<Longrightarrow>\n     \\<forall>s' r'.\n        r3 = (s', r') \\<and> ck = True \\<longrightarrow>\n        clock s' \\<le> clock s)", "by (induction rule:evaluate_match_evaluate_list_evaluate.inducts) auto"], ["", "lemma big_clocked_unclocked_equiv:\n  \"evaluate False env s e (s',r1) =\n   (\\<exists>c. evaluate True env (s (| clock := c |)) e ((s' (| clock := 0 |)),r1) \\<and>\n        r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s'))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate False env s e (s', r1) =\n    (\\<exists>c.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n        r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. evaluate False env s e (s', r1) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate False env s e (s', r1)", "assume ?lhs"], ["proof (state)\nthis:\n  evaluate False env s e (s', r1)\n\ngoal (2 subgoals):\n 1. evaluate False env s e (s', r1) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate False env s e (s', r1)", "then"], ["proof (chain)\npicking this:\n  evaluate False env s e (s', r1)", "show ?rhs"], ["proof (prove)\nusing this:\n  evaluate False env s e (s', r1)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "using big_unclocked_unchanged(3)"], ["proof (prove)\nusing this:\n  evaluate False env s e (s', r1)\n  evaluate False ?env ?s ?e (?s', ?r3.0) \\<Longrightarrow>\n  clock ?s = clock ?s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "by (fastforce simp add: big_unclocked_unchanged big_unclocked_notimeout add_clock)"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate True env (update_clock (\\<lambda>_. c) s) e\n      (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n     r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate False env s e (s', r1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate False env s e (s', r1)", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate True env (update_clock (\\<lambda>_. c) s) e\n      (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n     r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate False env s e (s', r1)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     evaluate True env (update_clock (\\<lambda>_. c) s) e\n      (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n     r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate True env (update_clock (\\<lambda>_. c) s) e\n      (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n     r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. evaluate False env s e (s', r1)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (update_clock (\\<lambda>_. 0) s', r1) \\<and>\n       r1 \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate False env s e (s', r1)", "apply (elim conjE exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate True env (update_clock (\\<lambda>_. c) s) e\n                 (update_clock (\\<lambda>_. 0) s', r1);\n        r1 \\<noteq> Rerr (Rabort Rtimeout_error);\n        clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate False env s e (s', r1)", "apply (drule big_unclocked_ignore(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>r1 \\<noteq> Rerr (Rabort Rtimeout_error);\n        clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> r1 \\<noteq> Rerr (Rabort Rtimeout_error)\n 2. \\<And>c.\n       \\<lbrakk>r1 \\<noteq> Rerr (Rabort Rtimeout_error);\n        clock s = clock s';\n        evaluate False env\n         (update_clock (\\<lambda>_. ?cnt4 c)\n           (update_clock (\\<lambda>_. c) s))\n         e (update_clock (\\<lambda>_. ?cnt4 c)\n             (update_clock (\\<lambda>_. 0) s'),\n            r1)\\<rbrakk>\n       \\<Longrightarrow> evaluate False env s e (s', r1)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>r1 \\<noteq> Rerr (Rabort Rtimeout_error);\n        clock s = clock s';\n        evaluate False env (update_clock (\\<lambda>a. ?cnt4 c) s) e\n         (update_clock (\\<lambda>a. ?cnt4 c) s', r1)\\<rbrakk>\n       \\<Longrightarrow> evaluate False env s e (s', r1)", "by (metis big_unclocked state.record_simps(7))"], ["proof (state)\nthis:\n  evaluate False env s e (s', r1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma big_clocked_timeout_0:\n  \"evaluate_match ck env s v pes err_v r1  \\<Longrightarrow> \\<forall>s'. r1 = (s',Rerr (Rabort Rtimeout_error)) \\<and> ck = True \\<longrightarrow> (clock s') = 0\"\n  \"evaluate_list ck env s es r2  \\<Longrightarrow> \\<forall>s'. r2 = (s',Rerr (Rabort Rtimeout_error)) \\<and> ck = True \\<longrightarrow> (clock s') = 0\"\n  \"evaluate ck env s e r3  \\<Longrightarrow> \\<forall>s'. r3 = (s',Rerr (Rabort Rtimeout_error)) \\<and> ck = True \\<longrightarrow> (clock s') = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n     \\<forall>s'.\n        r1 = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        ck = True \\<longrightarrow>\n        clock s' = 0) &&&\n    (evaluate_list ck env s es r2 \\<Longrightarrow>\n     \\<forall>s'.\n        r2 = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        ck = True \\<longrightarrow>\n        clock s' = 0) &&&\n    (evaluate ck env s e r3 \\<Longrightarrow>\n     \\<forall>s'.\n        r3 = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        ck = True \\<longrightarrow>\n        clock s' = 0)", "proof(induction rule:evaluate_match_evaluate_list_evaluate.inducts)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>ck env l s.\n       \\<forall>s'.\n          (s, Rval (Litv l)) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s'.\n           (s2, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr (Rraise v1)) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<forall>s'.\n           (s2, Rerr err) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr err) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s'.\n           (s2, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rval v1) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 5. \\<And>ck s1 s2 env e pes v1 bv.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>s'.\n            (s2, Rerr (Rraise v1)) =\n            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n            ck = True \\<longrightarrow>\n            clock s' = 0)) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>s'.\n           bv = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0) \\<Longrightarrow>\n       \\<forall>s'.\n          bv = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<forall>s'.\n           (s2, Rerr (Rabort a)) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr (Rabort a)) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 7. \\<And>ck env cn es vs s s' v1.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>s'a.\n           (s', Rval vs) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s'a = 0) \\<Longrightarrow>\n       \\<forall>s'a.\n          (s', Rval v1) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s'a = 0\n 8. \\<And>ck env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>s'.\n          (s, Rerr (Rabort Rtype_error)) =\n          (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 9. \\<And>ck env cn es err s s'.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>s'a.\n           (s', Rerr err) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s'a = 0) \\<Longrightarrow>\n       \\<forall>s'a.\n          (s', Rerr err) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s'a = 0\n 10. \\<And>ck env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>s'.\n           (s, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\nA total of 42 subgoals...", "case app4"], ["proof (state)\nthis:\n  (evaluate_list ck_ env_ s1_ (rev es_) (s2_, Rval vs_) \\<and>\n   (\\<forall>s'.\n       (s2_, Rval vs_) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n       ck_ = True \\<longrightarrow>\n       clock s' = 0)) \\<and>\n  do_app (refs s2_, ffi s2_) op0_ (rev vs_) =\n  Some ((refs'_, ffi'_), res_) \\<and>\n  op0_ \\<noteq> Opapp\n\ngoal (42 subgoals):\n 1. \\<And>ck env l s.\n       \\<forall>s'.\n          (s, Rval (Litv l)) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s'.\n           (s2, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr (Rraise v1)) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<forall>s'.\n           (s2, Rerr err) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr err) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s'.\n           (s2, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rval v1) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 5. \\<And>ck s1 s2 env e pes v1 bv.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>s'.\n            (s2, Rerr (Rraise v1)) =\n            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n            ck = True \\<longrightarrow>\n            clock s' = 0)) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>s'.\n           bv = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0) \\<Longrightarrow>\n       \\<forall>s'.\n          bv = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<forall>s'.\n           (s2, Rerr (Rabort a)) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr (Rabort a)) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 7. \\<And>ck env cn es vs s s' v1.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>s'a.\n           (s', Rval vs) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s'a = 0) \\<Longrightarrow>\n       \\<forall>s'a.\n          (s', Rval v1) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s'a = 0\n 8. \\<And>ck env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>s'.\n          (s, Rerr (Rabort Rtype_error)) =\n          (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 9. \\<And>ck env cn es err s s'.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>s'a.\n           (s', Rerr err) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s'a = 0) \\<Longrightarrow>\n       \\<forall>s'a.\n          (s', Rerr err) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s'a = 0\n 10. \\<And>ck env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>s'.\n           (s, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\nA total of 42 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck_ env_ s1_ (rev es_) (s2_, Rval vs_) \\<and>\n   (\\<forall>s'.\n       (s2_, Rval vs_) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n       ck_ = True \\<longrightarrow>\n       clock s' = 0)) \\<and>\n  do_app (refs s2_, ffi s2_) op0_ (rev vs_) =\n  Some ((refs'_, ffi'_), res_) \\<and>\n  op0_ \\<noteq> Opapp", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck_ env_ s1_ (rev es_) (s2_, Rval vs_) \\<and>\n   (\\<forall>s'.\n       (s2_, Rval vs_) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n       ck_ = True \\<longrightarrow>\n       clock s' = 0)) \\<and>\n  do_app (refs s2_, ffi s2_) op0_ (rev vs_) =\n  Some ((refs'_, ffi'_), res_) \\<and>\n  op0_ \\<noteq> Opapp\n\ngoal (1 subgoal):\n 1. \\<forall>s'.\n       (update_ffi (\\<lambda>_. ffi'_)\n         (update_refs (\\<lambda>_. refs'_) s2_),\n        res_) =\n       (s', Rerr (Rabort Rtimeout_error)) \\<and>\n       ck_ = True \\<longrightarrow>\n       clock s' = 0", "by (auto dest!:do_app_no_runtime_error)"], ["proof (state)\nthis:\n  \\<forall>s'.\n     (update_ffi (\\<lambda>_. ffi'_) (update_refs (\\<lambda>_. refs'_) s2_),\n      res_) =\n     (s', Rerr (Rabort Rtimeout_error)) \\<and>\n     ck_ = True \\<longrightarrow>\n     clock s' = 0\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s.\n       \\<forall>s'.\n          (s, Rval (Litv l)) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 2. \\<And>ck env e s1 s2 v1.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s'.\n           (s2, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr (Rraise v1)) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 3. \\<And>ck env e s1 s2 err.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<forall>s'.\n           (s2, Rerr err) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr err) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 4. \\<And>ck s1 s2 env e v1 pes.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<forall>s'.\n           (s2, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rval v1) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 5. \\<And>ck s1 s2 env e pes v1 bv.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>s'.\n            (s2, Rerr (Rraise v1)) =\n            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n            ck = True \\<longrightarrow>\n            clock s' = 0)) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>s'.\n           bv = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0) \\<Longrightarrow>\n       \\<forall>s'.\n          bv = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 6. \\<And>ck s1 s2 env e pes a.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<forall>s'.\n           (s2, Rerr (Rabort a)) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s'.\n                            (s2, Rerr (Rabort a)) =\n                            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n                            ck = True \\<longrightarrow>\n                            clock s' = 0\n 7. \\<And>ck env cn es vs s s' v1.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>s'a.\n           (s', Rval vs) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s'a = 0) \\<Longrightarrow>\n       \\<forall>s'a.\n          (s', Rval v1) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s'a = 0\n 8. \\<And>ck env cn es s.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>s'.\n          (s, Rerr (Rabort Rtype_error)) =\n          (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s' = 0\n 9. \\<And>ck env cn es err s s'.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>s'a.\n           (s', Rerr err) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s'a = 0) \\<Longrightarrow>\n       \\<forall>s'a.\n          (s', Rerr err) = (s'a, Rerr (Rabort Rtimeout_error)) \\<and>\n          ck = True \\<longrightarrow>\n          clock s'a = 0\n 10. \\<And>ck env n v1 s.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>s'.\n           (s, Rval v1) = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           ck = True \\<longrightarrow>\n           clock s' = 0\nA total of 41 subgoals...", "qed(auto)"], ["", "lemma big_clocked_unclocked_equiv_timeout:\n  \"(\\<forall>r. \\<not>evaluate False env s e r) =\n   (\\<forall>c. \\<exists>s'. evaluate True env (s \\<lparr> clock := c \\<rparr>) e (s',Rerr (Rabort Rtimeout_error)) \\<and> (clock s') = 0)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r. \\<not> evaluate False env s e r) =\n    (\\<forall>c.\n        \\<exists>s'.\n           evaluate True env (update_clock (\\<lambda>_. c) s) e\n            (s', Rerr (Rabort Rtimeout_error)) \\<and>\n           clock s' = 0)", "proof rule"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>r. \\<not> evaluate False env s e r \\<Longrightarrow>\n    \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0\n 2. \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0 \\<Longrightarrow>\n    \\<forall>r. \\<not> evaluate False env s e r", "assume l:?lhs"], ["proof (state)\nthis:\n  \\<forall>r. \\<not> evaluate False env s e r\n\ngoal (2 subgoals):\n 1. \\<forall>r. \\<not> evaluate False env s e r \\<Longrightarrow>\n    \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0\n 2. \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0 \\<Longrightarrow>\n    \\<forall>r. \\<not> evaluate False env s e r", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "obtain s' r where e:\"evaluate True env (update_clock (\\<lambda>_. c) s) e (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using evaluate_total"], ["proof (prove)\nusing this:\n  \\<exists>s' r. evaluate True ?env ?s ?e (s', r)\n\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  evaluate True env (update_clock (\\<lambda>_. c) s) e (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "have r:\"r = Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr (Rabort Rtimeout_error)", "using l big_unclocked_ignore(3)[OF e, simplified]"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate False env s e r\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<Longrightarrow>\n  evaluate False env (update_clock (\\<lambda>a. ?cnt) s) e\n   (update_clock (\\<lambda>_. ?cnt) s', r)\n\ngoal (1 subgoal):\n 1. r = Rerr (Rabort Rtimeout_error)", "by (metis state.record_simps(7))"], ["proof (state)\nthis:\n  r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "moreover"], ["proof (state)\nthis:\n  r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "have \"(clock s') = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock s' = 0", "using r e big_clocked_timeout_0(3)"], ["proof (prove)\nusing this:\n  r = Rerr (Rabort Rtimeout_error)\n  evaluate True env (update_clock (\\<lambda>_. c) s) e (s', r)\n  evaluate ?ck ?env ?s ?e ?r3.0 \\<Longrightarrow>\n  \\<forall>s'.\n     ?r3.0 = (s', Rerr (Rabort Rtimeout_error)) \\<and>\n     ?ck = True \\<longrightarrow>\n     clock s' = 0\n\ngoal (1 subgoal):\n 1. clock s' = 0", "by blast"], ["proof (state)\nthis:\n  clock s' = 0\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "ultimately"], ["proof (chain)\npicking this:\n  r = Rerr (Rabort Rtimeout_error)\n  clock s' = 0", "show \"\\<exists>s'. evaluate True env (update_clock (\\<lambda>_. c) s) e (s', Rerr (Rabort Rtimeout_error)) \\<and> clock s' = 0\""], ["proof (prove)\nusing this:\n  r = Rerr (Rabort Rtimeout_error)\n  clock s' = 0\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (s', Rerr (Rabort Rtimeout_error)) \\<and>\n       clock s' = 0", "using e"], ["proof (prove)\nusing this:\n  r = Rerr (Rabort Rtimeout_error)\n  clock s' = 0\n  evaluate True env (update_clock (\\<lambda>_. c) s) e (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       evaluate True env (update_clock (\\<lambda>_. c) s) e\n        (s', Rerr (Rabort Rtimeout_error)) \\<and>\n       clock s' = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     evaluate True env (update_clock (\\<lambda>_. c) s) e\n      (s', Rerr (Rabort Rtimeout_error)) \\<and>\n     clock s' = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c.\n     \\<exists>s'.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        clock s' = 0\n\ngoal (1 subgoal):\n 1. \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0 \\<Longrightarrow>\n    \\<forall>r. \\<not> evaluate False env s e r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0 \\<Longrightarrow>\n    \\<forall>r. \\<not> evaluate False env s e r", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>c.\n     \\<exists>s'.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        clock s' = 0\n\ngoal (1 subgoal):\n 1. \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0 \\<Longrightarrow>\n    \\<forall>r. \\<not> evaluate False env s e r", "then"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     \\<exists>s'.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        clock s' = 0", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     \\<exists>s'.\n        evaluate True env (update_clock (\\<lambda>_. c) s) e\n         (s', Rerr (Rabort Rtimeout_error)) \\<and>\n        clock s' = 0\n\ngoal (1 subgoal):\n 1. \\<forall>r. \\<not> evaluate False env s e r", "by (metis big_clocked_unclocked_equiv eq_snd_iff evaluate_determ(3))"], ["proof (state)\nthis:\n  \\<forall>r. \\<not> evaluate False env s e r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_from_counter:\n  \"evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n   \\<forall>count count' s' r'.\n    (clock   s) = count + extra1 \\<and>\n    r1 = (s',r') \\<and>\n    (clock   s') = count' + extra1 \\<and>\n    ck = True \\<longrightarrow>\n    evaluate_match True env (s (| clock := count |)) v pes err_v ((s' (| clock := count' |) ),r')\"\n  \"evaluate_list ck env s es r2 \\<Longrightarrow>\n   \\<forall>count count' s' r'.\n    (clock   s) = count + extra2 \\<and>\n    r2 = (s',r') \\<and>\n    (clock   s') = count' + extra2 \\<and>\n    ck = True \\<longrightarrow>\n    evaluate_list True env (s (| clock := count |)) es ((s' (| clock := count' |) ),r')\"\n  \"evaluate ck env s e r3 \\<Longrightarrow>\n   \\<forall>count count' s' r'.\n    (clock   s) = count + extra3 \\<and>\n    r3 = (s',r') \\<and>\n    (clock   s') = count' + extra3 \\<and>\n    ck = True \\<longrightarrow>\n    evaluate True env (s (| clock := count |)) e ((s' (| clock := count' |) ),r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_match ck env s v pes err_v r1 \\<Longrightarrow>\n     \\<forall>count count' s' r'.\n        clock s = count + extra1 \\<and>\n        r1 = (s', r') \\<and>\n        clock s' = count' + extra1 \\<and> ck = True \\<longrightarrow>\n        evaluate_match True env (update_clock (\\<lambda>_. count) s) v pes\n         err_v (update_clock (\\<lambda>_. count') s', r')) &&&\n    (evaluate_list ck env s es r2 \\<Longrightarrow>\n     \\<forall>count count' s' r'.\n        clock s = count + extra2 \\<and>\n        r2 = (s', r') \\<and>\n        clock s' = count' + extra2 \\<and> ck = True \\<longrightarrow>\n        evaluate_list True env (update_clock (\\<lambda>_. count) s) es\n         (update_clock (\\<lambda>_. count') s', r')) &&&\n    (evaluate ck env s e r3 \\<Longrightarrow>\n     \\<forall>count count' s' r'.\n        clock s = count + extra3 \\<and>\n        r3 = (s', r') \\<and>\n        clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n        evaluate True env (update_clock (\\<lambda>_. count) s) e\n         (update_clock (\\<lambda>_. count') s', r'))", "proof (induction arbitrary:extra1 and extra2 and extra3 rule:evaluate_match_evaluate_list_evaluate.inducts)"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes v1 bv extra3.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>x count count' s' r'.\n            clock s1 = count + x \\<and>\n            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n            clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n            evaluate True env (update_clock (\\<lambda>_. count) s1) e\n             (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>x count count' s' r'.\n           clock s2 = count + x \\<and>\n           bv = (s', r') \\<and>\n           clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1\n            (update_clock (\\<lambda>_. count') s', r')) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s1 = count + extra3 \\<and>\n          bv = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s1)\n           (Handle e pes) (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 7. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 8. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 9. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 10. \\<And>ck env n v1 s extra3.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rval v1) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 42 subgoals...", "case (handle2 ck s1 s2 env e pes v1 bv)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1 pes\n       v1 (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (42 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes v1 bv extra3.\n       (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n        (\\<forall>x count count' s' r'.\n            clock s1 = count + x \\<and>\n            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n            clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n            evaluate True env (update_clock (\\<lambda>_. count) s1) e\n             (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n       evaluate_match ck env s2 v1 pes v1 bv \\<and>\n       (\\<forall>x count count' s' r'.\n           clock s2 = count + x \\<and>\n           bv = (s', r') \\<and>\n           clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1\n            (update_clock (\\<lambda>_. count') s', r')) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s1 = count + extra3 \\<and>\n          bv = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s1)\n           (Handle e pes) (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 7. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 8. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 9. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 10. \\<And>ck env n v1 s extra3.\n        nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rval v1) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 42 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1 pes\n       v1 (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rerr (Rraise v1)) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_match ck env s2 v1 pes v1 bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1 pes\n       v1 (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra3 \\<and>\n       bv = (s', r') \\<and>\n       clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1)\n        (Handle e pes) (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Handle e pes)\n                          (update_clock (\\<lambda>_. count') s', r')", "apply (subgoal_tac \"(clock   s2) \\<ge> extra3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Handle e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2,\n             Rerr (Rraise v1))\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Handle e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rerr (Rraise v1));\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. counta) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Handle e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. counta) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e\n            (update_clock (\\<lambda>_. count'a) s2,\n             Rerr (Rraise v1))\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Handle e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra3\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rerr (Rraise v1));\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) v1 pes v1\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Handle e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rerr (Rraise v1));\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) v1 pes v1\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e\n                          (?s2.25 count count' s' r',\n                           Rerr (Rraise (?v1.25 count count' s' r'))) \\<and>\n                         evaluate_match True env (?s2.25 count count' s' r')\n                          (?v1.25 count count' s' r') pes\n                          (?v1.25 count count' s' r')\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rerr (Rraise v1));\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rerr (Rraise v1));\n        evaluate_match True env s2 v1 pes v1 (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes v1 (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "by (auto dest:clock_monotone(1))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra3 \\<and>\n     bv = (s', r') \\<and>\n     clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n     evaluate True env (update_clock (\\<lambda>_. count) s1) (Handle e pes)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 41 subgoals...", "case (app1 ck env es vs env' e bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval vs) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate_list True env (update_clock (\\<lambda>_. count) s1) (rev es)\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and>\n  (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n  evaluate ck env'\n   (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n   bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock\n       (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) =\n      count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env'\n       (update_clock (\\<lambda>_. count)\n         (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2))\n       e (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (41 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 41 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval vs) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate_list True env (update_clock (\\<lambda>_. count) s1) (rev es)\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and>\n  (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n  evaluate ck env'\n   (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n   bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock\n       (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) =\n      count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env'\n       (update_clock (\\<lambda>_. count)\n         (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2))\n       e (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate_list ck env s1 (rev es) (s2, Rval vs) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval vs) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate_list True env (update_clock (\\<lambda>_. count) s1) (rev es)\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_opapp (rev vs) = Some (env', e) \\<and>\n  (ck \\<longrightarrow> clock s2 \\<noteq> 0) \\<and>\n  evaluate ck env'\n   (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) e\n   bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock\n       (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2) =\n      count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env'\n       (update_clock (\\<lambda>_. count)\n         (if ck then update_clock (\\<lambda>_. clock s2 - 1) s2 else s2))\n       e (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra3 \\<and>\n       bv = (s', r') \\<and>\n       clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1)\n        (App Opapp es) (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (App Opapp es)\n                          (update_clock (\\<lambda>_. count') s', r')", "apply (subgoal_tac \"(clock   s2)-1\\<ge>extra3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2;\n        extra3 \\<le> clock s2 - 1\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (App Opapp es)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2;\n        extra3 \\<le> clock s2 - 1;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x24 count count' s' r' \\<and>\n           clock s2 = count'a + ?x24 count count' s' r' \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es)\n            (update_clock (\\<lambda>_. count'a) s2, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (App Opapp es)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2;\n        extra3 \\<le> clock s2 - 1;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x24 count count' s' r' \\<and>\n           clock s2 = count'a + ?x24 count count' s' r' \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count'a) s2, Rval vs);\n        \\<forall>counta count'a.\n           clock s2 - Suc 0 = counta + ?x26 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x26 count count' s' r' \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. counta) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (App Opapp es)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2;\n        extra3 \\<le> clock s2 - 1;\n        \\<forall>counta count'a.\n           clock s2 - Suc 0 = counta + ?x26 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x26 count count' s' r' \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. counta) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        \\<forall>count'a.\n           count + extra3 =\n           ?count28 count count' s' r' + ?x24 count count' s' r' \\<and>\n           clock s2 = count'a + ?x24 count count' s' r' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. ?count28 count count' s' r') s1)\n            (rev es)\n            (update_clock (\\<lambda>_. count'a) s2, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (App Opapp es)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "apply (drule_tac x=\"(clock   s2)-extra3-1\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2;\n        extra3 \\<le> clock s2 - 1;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count28 count count' s' r' + ?x24 count count' s' r' \\<and>\n           clock s2 = count'a + ?x24 count count' s' r' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. ?count28 count count' s' r') s1)\n            (rev es) (update_clock (\\<lambda>_. count'a) s2, Rval vs);\n        \\<forall>count'a.\n           clock s2 - Suc 0 =\n           clock s2 - extra3 - 1 + ?x26 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x26 count count' s' r' \\<longrightarrow>\n           evaluate True env'\n            (update_clock (\\<lambda>a. clock s2 - extra3 - 1) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (App Opapp es)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2;\n        extra3 \\<le> clock s2 - 1;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count28 count count' s' r' + ?x24 count count' s' r' \\<and>\n           clock s2 = count'a + ?x24 count count' s' r' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. ?count28 count count' s' r') s1)\n            (rev es) (update_clock (\\<lambda>_. count'a) s2, Rval vs);\n        \\<forall>count'a.\n           clock s2 - Suc 0 =\n           clock s2 - extra3 - 1 + ?x26 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x26 count count' s' r' \\<longrightarrow>\n           evaluate True env'\n            (update_clock (\\<lambda>a. clock s2 - extra3 - 1) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (rev es)\n                          (?s2.32 count count' s' r',\n                           Rval (?vs32 count count' s' r')) \\<and>\n                         do_opapp (rev (?vs32 count count' s' r')) =\n                         Some\n                          (?env'32 count count' s' r',\n                           ?e32 count count' s' r') \\<and>\n                         (True \\<longrightarrow>\n                          clock (?s2.32 count count' s' r') \\<noteq>\n                          0) \\<and>\n                         evaluate True (?env'32 count count' s' r')\n                          (if True\n                           then update_clock\n                                 (\\<lambda>_.\n                                     clock (?s2.32 count count' s' r') - 1)\n                                 (?s2.32 count count' s' r')\n                           else ?s2.32 count count' s' r')\n                          (?e32 count count' s' r')\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate_list True env s1 (rev es) (s2, Rval vs);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s1)\n            (rev es) (update_clock (\\<lambda>_. count') s2, Rval vs);\n        do_opapp (rev vs) = Some (env', e);\n        evaluate True env' (update_clock (\\<lambda>_. clock s2 - Suc 0) s2)\n         e (s', r');\n        \\<forall>x count count'a.\n           clock s2 - Suc 0 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env' (update_clock (\\<lambda>a. count) s2) e\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; 0 < clock s2\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2 - 1", "by (auto dest:clock_monotone(3))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra3 \\<and>\n     bv = (s', r') \\<and>\n     clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n     evaluate True env (update_clock (\\<lambda>_. count) s1) (App Opapp es)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (40 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 40 subgoals...", "case (log1 ck env op0 e1 e2 v1 e' bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_log op0 v1 e2 = Some (Exp e') \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (40 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 40 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_log op0 v1 e2 = Some (Exp e') \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_log op0 v1 e2 = Some (Exp e') \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra3 \\<and>\n       bv = (s', r') \\<and>\n       clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1)\n        (Log op0 e1 e2) (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Log op0 e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')", "apply (subgoal_tac \"(clock   s2)\\<ge>extra3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Log op0 e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Log op0 e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Log op0 e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        \\<forall>count'a.\n           count + extra3 =\n           ?count22 count count' s' r' + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count22 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Log op0 e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra3\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count22 count count' s' r' + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count22 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (Log op0 e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count22 count count' s' r' + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count22 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e1\n                          (?s2.26 count count' s' r',\n                           Rval (?v1.26 count count' s' r')) \\<and>\n                         do_log op0 (?v1.26 count count' s' r') e2 =\n                         Some (Exp (?e'26 count count' s' r')) \\<and>\n                         evaluate True env (?s2.26 count count' s' r')\n                          (?e'26 count count' s' r')\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_log op0 v1 e2 = Some (Exp e'); evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "by (auto dest:clock_monotone(3))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra3 \\<and>\n     bv = (s', r') \\<and>\n     clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n     evaluate True env (update_clock (\\<lambda>_. count) s1) (Log op0 e1 e2)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (39 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 39 subgoals...", "case (if1 ck env e1 e2 e3 v1 e' bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_if v1 e2 e3 = Some e' \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (39 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 39 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_if v1 e2 e3 = Some e' \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  do_if v1 e2 e3 = Some e' \\<and>\n  evaluate ck env s2 e' bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra3 \\<and>\n       bv = (s', r') \\<and>\n       clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1)\n        (exp0.If e1 e2 e3) (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.If e1 e2 e3)\n                          (update_clock (\\<lambda>_. count') s', r')", "apply (subgoal_tac \"(clock   s2)\\<ge>extra3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.If e1 e2 e3)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.If e1 e2 e3)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.If e1 e2 e3)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        \\<forall>count'a.\n           count + extra3 =\n           ?count22 count count' s' r' + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count22 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.If e1 e2 e3)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra3\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count22 count count' s' r' + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count22 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.If e1 e2 e3)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count22 count count' s' r' + ?x18 count count' s' r' \\<and>\n           clock s2 = count'a + ?x18 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count22 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x20 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x20 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e1\n                          (?s2.26 count count' s' r',\n                           Rval (?v1.26 count count' s' r')) \\<and>\n                         do_if (?v1.26 count count' s' r') e2 e3 =\n                         Some (?e'26 count count' s' r') \\<and>\n                         evaluate True env (?s2.26 count count' s' r')\n                          (?e'26 count count' s' r')\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        do_if v1 e2 e3 = Some e'; evaluate True env s2 e' (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s2) e'\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros dest:clock_monotone(3))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra3 \\<and>\n     bv = (s', r') \\<and>\n     clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n     evaluate True env (update_clock (\\<lambda>_. count) s1)\n      (exp0.If e1 e2 e3) (update_clock (\\<lambda>_. count') s', r')\n\ngoal (38 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 38 subgoals...", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 38 subgoals...", "case (mat1 ck env e pes v1 bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1 pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (38 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 38 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1 pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_match ck env s2 v1 pes\n   (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1 pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra3 \\<and>\n       bv = (s', r') \\<and>\n       clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n        (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n                          (update_clock (\\<lambda>_. count') s', r')", "apply (subgoal_tac \"(clock   s2)\\<ge>extra3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. counta) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. counta) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra3\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) v1 pes\n            (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate_match True env\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) v1 pes\n            (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e\n                          (?s2.25 count count' s' r',\n                           Rval (?v1.25 count count' s' r')) \\<and>\n                         evaluate_match True env (?s2.25 count count' s' r')\n                          (?v1.25 count count' s' r') pes\n                          (Conv (Some (''Bind'', TypeExn (Short ''Bind'')))\n                            [])\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_match True env s2 v1 pes\n         (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate_match True env (update_clock (\\<lambda>_. count) s2) v1\n            pes (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "by (auto dest:clock_monotone(1))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra3 \\<and>\n     bv = (s', r') \\<and>\n     clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n     evaluate True env (update_clock (\\<lambda>_. count) s1) (Mat e pes)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (37 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 37 subgoals...", "case (let1 ck env n e1 e2 v1 bv s1 s2)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate ck (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2\n   e2 bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True\n       (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n       (update_clock (\\<lambda>_. count) s2) e2\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (37 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 37 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate ck (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2\n   e2 bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True\n       (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n       (update_clock (\\<lambda>_. count) s2) e2\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e1 (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e1\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate ck (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2\n   e2 bv \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      bv = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate True\n       (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n       (update_clock (\\<lambda>_. count) s2) e2\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra3 \\<and>\n       bv = (s', r') \\<and>\n       clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1)\n        (exp0.Let n e1 e2) (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.Let n e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')", "apply (subgoal_tac \"(clock   s2)\\<ge>extra3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.Let n e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.Let n e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra3 = counta + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. counta) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.Let n e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. counta) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.Let n e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra3\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1)\n                          (exp0.Let n e1 e2)\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck; extra3 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra3 =\n           ?count21 count count' s' r' + ?x17 count count' s' r' \\<and>\n           clock s2 = count'a + ?x17 count count' s' r' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count21 count count' s' r') s1) e1\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra3 + ?x19 count count' s' r' \\<and>\n           count' + extra3 =\n           count'a + ?x19 count count' s' r' \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. clock s2 - extra3) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r')\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e1\n                          (?s2.25 count count' s' r',\n                           Rval (?v1.25 count count' s' r')) \\<and>\n                         evaluate True\n                          (update_v\n                            (\\<lambda>_.\n                                nsOptBind n (?v1.25 count count' s' r')\n                                 (sem_env.v env))\n                            env)\n                          (?s2.25 count count' s' r') e2\n                          (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count' s' r'.\n       \\<lbrakk>evaluate True env s1 e1 (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra3 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e1\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate True\n         (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env) s2 e2\n         (s', r');\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra3 = count'a + x \\<longrightarrow>\n           evaluate True\n            (update_v (\\<lambda>_. nsOptBind n v1 (sem_env.v env)) env)\n            (update_clock (\\<lambda>_. count) s2) e2\n            (update_clock (\\<lambda>_. count'a) s', r');\n        clock s1 = count + extra3; bv = (s', r');\n        clock s' = count' + extra3; ck\\<rbrakk>\n       \\<Longrightarrow> extra3 \\<le> clock s2", "by (auto dest:clock_monotone(3))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra3 \\<and>\n     bv = (s', r') \\<and>\n     clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n     evaluate True env (update_clock (\\<lambda>_. count) s1)\n      (exp0.Let n e1 e2) (update_clock (\\<lambda>_. count') s', r')\n\ngoal (36 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 36 subgoals...", "case (cons1 ck env e es v1 vs s1 s2 s3)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      (s3, Rval vs) = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (36 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 36 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      (s3, Rval vs) = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_list ck env s2 es (s3, Rval vs) \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      (s3, Rval vs) = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra2 \\<and>\n       (s3, Rval (v1 # vs)) = (s', r') \\<and>\n       clock s' = count' + extra2 \\<and> ck = True \\<longrightarrow>\n       evaluate_list True env (update_clock (\\<lambda>_. count) s1) (e # es)\n        (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3,\n                           Rval (v1 # vs))", "apply (subgoal_tac \"(clock   s2)\\<ge>extra2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3,\n                           Rval (v1 # vs))\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra2 = counta + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3,\n                           Rval (v1 # vs))\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra2 = counta + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3,\n                           Rval (v1 # vs))\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        \\<forall>count'a.\n           count + extra2 = ?count16 count count' + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count16 count count') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3,\n                           Rval (v1 # vs))\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra2\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra2 = ?count16 count count' + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count16 count count') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra2 + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. clock s2 - extra2) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3,\n                           Rval (v1 # vs))\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra2 = ?count16 count count' + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count16 count count') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra2 + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. clock s2 - extra2) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e\n                          (?s2.20 count count', Rval v1) \\<and>\n                         evaluate_list True env (?s2.20 count count') es\n                          (update_clock (\\<lambda>_. count') s3, Rval vs)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rval vs);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rval vs);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "by (auto dest:clock_monotone(2))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra2 \\<and>\n     (s3, Rval (v1 # vs)) = (s', r') \\<and>\n     clock s' = count' + extra2 \\<and> ck = True \\<longrightarrow>\n     evaluate_list True env (update_clock (\\<lambda>_. count) s1) (e # es)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (35 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 35 subgoals...", "case (cons3 ck env e es v1 err s1 s2 s3)"], ["proof (state)\nthis:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      (s3, Rerr err) = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (35 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 35 subgoals...", "then"], ["proof (chain)\npicking this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      (s3, Rerr err) = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  (evaluate ck env s1 e (s2, Rval v1) \\<and>\n   (\\<forall>x count count' s' r'.\n       clock s1 = count + x \\<and>\n       (s2, Rval v1) = (s', r') \\<and>\n       clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n       evaluate True env (update_clock (\\<lambda>_. count) s1) e\n        (update_clock (\\<lambda>_. count') s', r'))) \\<and>\n  evaluate_list ck env s2 es (s3, Rerr err) \\<and>\n  (\\<forall>x count count' s' r'.\n      clock s2 = count + x \\<and>\n      (s3, Rerr err) = (s', r') \\<and>\n      clock s' = count' + x \\<and> ck = True \\<longrightarrow>\n      evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r'.\n       clock s1 = count + extra2 \\<and>\n       (s3, Rerr err) = (s', r') \\<and>\n       clock s' = count' + extra2 \\<and> ck = True \\<longrightarrow>\n       evaluate_list True env (update_clock (\\<lambda>_. count) s1) (e # es)\n        (update_clock (\\<lambda>_. count') s', r')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)", "apply (subgoal_tac \"(clock   s2)\\<ge>extra2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra2 = counta + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>counta count'a.\n           count + extra2 = counta + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>counta count'a.\n           clock s2 = counta + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. counta) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        \\<forall>count'a.\n           count + extra2 = ?count16 count count' + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count16 count count') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply (drule_tac x=\"(clock   s2)-extra2\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra2 = ?count16 count count' + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count16 count count') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra2 + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. clock s2 - extra2) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env\n                          (update_clock (\\<lambda>_. count) s1) (e # es)\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck;\n        extra2 \\<le> clock s2;\n        \\<forall>count'a.\n           count + extra2 = ?count16 count count' + ?x12 count count' \\<and>\n           clock s2 = count'a + ?x12 count count' \\<longrightarrow>\n           evaluate True env\n            (update_clock (\\<lambda>_. ?count16 count count') s1) e\n            (update_clock (\\<lambda>_. count'a) s2, Rval v1);\n        \\<forall>count'a.\n           clock s2 = clock s2 - extra2 + ?x14 count count' \\<and>\n           count' + extra2 = count'a + ?x14 count count' \\<longrightarrow>\n           evaluate_list True env\n            (update_clock (\\<lambda>_. clock s2 - extra2) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate True env\n                          (update_clock (\\<lambda>_. count) s1) e\n                          (?s2.20 count count',\n                           Rval (?v1.20 count count')) \\<and>\n                         evaluate_list True env (?s2.20 count count') es\n                          (update_clock (\\<lambda>_. count') s3, Rerr err)\n 2. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count count'.\n       \\<lbrakk>evaluate True env s1 e (s2, Rval v1);\n        \\<forall>x counta count'.\n           count + extra2 = counta + x \\<and>\n           clock s2 = count' + x \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. counta) s1) e\n            (update_clock (\\<lambda>_. count') s2, Rval v1);\n        evaluate_list True env s2 es (s3, Rerr err);\n        \\<forall>x count count'a.\n           clock s2 = count + x \\<and>\n           count' + extra2 = count'a + x \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s2) es\n            (update_clock (\\<lambda>_. count'a) s3, Rerr err);\n        clock s1 = count + extra2; clock s3 = count' + extra2; ck\\<rbrakk>\n       \\<Longrightarrow> extra2 \\<le> clock s2", "by (auto dest:clock_monotone(2))"], ["proof (state)\nthis:\n  \\<forall>count count' s' r'.\n     clock s1 = count + extra2 \\<and>\n     (s3, Rerr err) = (s', r') \\<and>\n     clock s' = count' + extra2 \\<and> ck = True \\<longrightarrow>\n     evaluate_list True env (update_clock (\\<lambda>_. count) s1) (e # es)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (34 subgoals):\n 1. \\<And>ck env l s extra3.\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval (Litv l)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Lit l)\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck env e s1 s2 v1 extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr (Rraise v1)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck env e s1 s2 err extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rerr err);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rerr err) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rerr err) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Raise e)\n                             (update_clock (\\<lambda>_. count') s', r')\n 4. \\<And>ck s1 s2 env e v1 pes extra3.\n       \\<lbrakk>evaluate ck s1 env e (s2, Rval v1);\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock env = count + extra3 \\<and>\n              (s2, Rval v1) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True s1 (update_clock (\\<lambda>_. count) env) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock env = count + extra3 \\<and>\n                            (s2, Rval v1) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True s1\n                             (update_clock (\\<lambda>_. count) env)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 5. \\<And>ck s1 s2 env e pes a extra3.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rerr (Rabort a));\n        \\<And>extra3.\n           \\<forall>count count' s' r'.\n              clock s1 = count + extra3 \\<and>\n              (s2, Rerr (Rabort a)) = (s', r') \\<and>\n              clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n              evaluate True env (update_clock (\\<lambda>_. count) s1) e\n               (update_clock (\\<lambda>_. count') s', r')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>count count' s' r'.\n                            clock s1 = count + extra3 \\<and>\n                            (s2, Rerr (Rabort a)) = (s', r') \\<and>\n                            clock s' = count' + extra3 \\<and>\n                            ck = True \\<longrightarrow>\n                            evaluate True env\n                             (update_clock (\\<lambda>_. count) s1)\n                             (Handle e pes)\n                             (update_clock (\\<lambda>_. count') s', r')\n 6. \\<And>ck env cn es vs s s' v1 extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       build_conv (c env) cn (rev vs) = Some v1 \\<and>\n       evaluate_list ck env s (rev es) (s', Rval vs) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rval vs) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rval v1) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 7. \\<And>ck env cn es s extra3.\n       \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s', r')\n 8. \\<And>ck env cn es err s s' extra3.\n       do_con_check (c env) cn (length es) \\<and>\n       evaluate_list ck env s (rev es) (s', Rerr err) \\<and>\n       (\\<forall>x count count' s'a r'.\n           clock s = count + x \\<and>\n           (s', Rerr err) = (s'a, r') \\<and>\n           clock s'a = count' + x \\<and> ck = True \\<longrightarrow>\n           evaluate_list True env (update_clock (\\<lambda>_. count) s)\n            (rev es)\n            (update_clock (\\<lambda>_. count') s'a, r')) \\<Longrightarrow>\n       \\<forall>count count' s'a r'.\n          clock s = count + extra3 \\<and>\n          (s', Rerr err) = (s'a, r') \\<and>\n          clock s'a = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Con cn es)\n           (update_clock (\\<lambda>_. count') s'a, r')\n 9. \\<And>ck env n v1 s extra3.\n       nsLookup (sem_env.v env) n = Some v1 \\<Longrightarrow>\n       \\<forall>count count' s' r'.\n          clock s = count + extra3 \\<and>\n          (s, Rval v1) = (s', r') \\<and>\n          clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n          evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n           (update_clock (\\<lambda>_. count') s', r')\n 10. \\<And>ck env n s extra3.\n        nsLookup (sem_env.v env) n = None \\<Longrightarrow>\n        \\<forall>count count' s' r'.\n           clock s = count + extra3 \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r') \\<and>\n           clock s' = count' + extra3 \\<and> ck = True \\<longrightarrow>\n           evaluate True env (update_clock (\\<lambda>_. count) s) (Var n)\n            (update_clock (\\<lambda>_. count') s', r')\nA total of 34 subgoals...", "qed(fastforce intro:evaluate_match_evaluate_list_evaluate.intros)+"], ["", "lemma clocked_min_counter:\n  assumes \"evaluate True env s e (s',r')\"\n  shows \"evaluate True env (s (| clock := (clock   s) - (clock   s') |)) e ((s' (| clock := 0 |)),r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n     (update_clock (\\<lambda>_. 0) s', r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n     (update_clock (\\<lambda>_. 0) s', r')", "from assms"], ["proof (chain)\npicking this:\n  evaluate True env s e (s', r')", "have \"(clock   s) \\<ge> (clock   s')\""], ["proof (prove)\nusing this:\n  evaluate True env s e (s', r')\n\ngoal (1 subgoal):\n 1. clock s' \\<le> clock s", "by (fastforce intro:clock_monotone(3)[rule_format])"], ["proof (state)\nthis:\n  clock s' \\<le> clock s\n\ngoal (1 subgoal):\n 1. evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n     (update_clock (\\<lambda>_. 0) s', r')", "then"], ["proof (chain)\npicking this:\n  clock s' \\<le> clock s", "show ?thesis"], ["proof (prove)\nusing this:\n  clock s' \\<le> clock s\n\ngoal (1 subgoal):\n 1. evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n     (update_clock (\\<lambda>_. 0) s', r')", "thm sub_from_counter(3)[rule_format]"], ["proof (prove)\nusing this:\n  clock s' \\<le> clock s\n\ngoal (1 subgoal):\n 1. evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n     (update_clock (\\<lambda>_. 0) s', r')", "using assms"], ["proof (prove)\nusing this:\n  clock s' \\<le> clock s\n  evaluate True env s e (s', r')\n\ngoal (1 subgoal):\n 1. evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n     (update_clock (\\<lambda>_. 0) s', r')", "by (auto intro!:sub_from_counter(3)[rule_format])"], ["proof (state)\nthis:\n  evaluate True env (update_clock (\\<lambda>_. clock s - clock s') s) e\n   (update_clock (\\<lambda>_. 0) s', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dec_evaluate_not_timeout:\n  \"evaluate_dec False mn env s d (s',r) \\<Longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s d (s', r) \\<Longrightarrow>\n    r \\<noteq> Rerr (Rabort Rtimeout_error)", "by (ind_cases \"evaluate_dec False mn env s d (s', r)\", auto dest: big_unclocked_notimeout)"], ["", "lemma dec_unclocked_ignore:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   \\<forall>s' r count. res = (s',r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_dec False mn env (s (| clock := count |)) d (s' (| clock := count |),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ck mn env s d res \\<Longrightarrow>\n    \\<forall>s' r count.\n       res = (s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_dec False mn env (update_clock (\\<lambda>_. count) s) d\n        (update_clock (\\<lambda>_. count) s', r)", "proof (induction rule:evaluate_dec.inducts)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r count.\n          (s', Rerr err) = (s'a, r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r count.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. count) s', r)\nA total of 12 subgoals...", "case dtype1"], ["proof (state)\nthis:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r count.\n          (s', Rerr err) = (s'a, r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r count.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. count) s', r)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)", "show ?case"], ["proof (prove)\nusing this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r count.\n       (update_defined_types\n         (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n        Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n       (s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_dec False mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dtype locs_ tds_) (update_clock (\\<lambda>_. count) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count.\n       \\<lbrakk>check_dup_ctors tds_;\n        new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n        disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n        allDistinct\n         (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n           tds_)\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec False mn_ env_\n                          (update_clock (\\<lambda>_. count) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. count) s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<And>count.\n       \\<lbrakk>check_dup_ctors tds_;\n        new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n        disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n        allDistinct\n         (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n           tds_)\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec False mn_ env_\n                          (update_clock (\\<lambda>_. count) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. count) s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "by metis"], ["proof (state)\nthis:\n  \\<forall>s' r count.\n     (update_defined_types\n       (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n      Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n     (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec False mn_ env_ (update_clock (\\<lambda>_. count) s_)\n      (Dtype locs_ tds_) (update_clock (\\<lambda>_. count) s', r)\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r count.\n          (s', Rerr err) = (s'a, r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r count.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r count.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count) s', r)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r count.\n          (s', Rerr err) = (s'a, r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r count.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r count.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count) s', r)\nA total of 11 subgoals...", "case dexn1"], ["proof (state)\nthis:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r count.\n          (s', Rerr err) = (s'a, r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r count.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r count.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count) s', r)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_", "show ?case"], ["proof (prove)\nusing this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (1 subgoal):\n 1. \\<forall>s' r count.\n       (update_defined_types\n         (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n         s_,\n        Rval\n         (make_sem_env nsEmpty\n           (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n       (s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_dec False mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. count) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count.\n       TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_ \\<Longrightarrow>\n       evaluate_dec False mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dexn locs_ cn_ ts_)\n        (update_defined_types\n          (\\<lambda>_. insert (TypeExn (mk_id mn_ cn_)) (defined_types s_))\n          (update_clock (\\<lambda>_. count) s_),\n         Rval\n          (make_sem_env nsEmpty\n            (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_)))))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<And>count.\n       TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_ \\<Longrightarrow>\n       evaluate_dec False mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dexn locs_ cn_ ts_)\n        (update_defined_types\n          (\\<lambda>_. insert (TypeExn (mk_id mn_ cn_)) (defined_types s_))\n          (update_clock (\\<lambda>_. count) s_),\n         Rval\n          (make_sem_env nsEmpty\n            (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_)))))", "by (metis Un_insert_left sup_bot.left_neutral)"], ["proof (state)\nthis:\n  \\<forall>s' r count.\n     (update_defined_types\n       (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_) s_,\n      Rval\n       (make_sem_env nsEmpty\n         (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n     (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec False mn_ env_ (update_clock (\\<lambda>_. count) s_)\n      (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. count) s', r)\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r count.\n          (s', Rerr err) = (s'a, r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r count.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r count.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>s' r count.\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count) s', r)", "qed (force intro:evaluate_dec.intros simp add:big_unclocked_ignore(3))+"], ["", "private"], ["", "lemma dec_unclocked_1:\n  assumes \"evaluate_dec False mn env s d (s',r)\"\n  shows \"(r \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (clock   s) = (clock   s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "using assms"], ["proof (prove)\nusing this:\n  evaluate_dec False mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "by cases (auto dest: big_unclocked_notimeout big_unclocked_unchanged)"], ["", "private"], ["", "lemma dec_unclocked_2:\n  assumes \"evaluate_dec False mn env (s \\<lparr> clock := count1 \\<rparr>) d ((s' \\<lparr> clock := count1 \\<rparr>),r)\"\n  shows \"evaluate_dec False mn env (s \\<lparr> clock := count2 \\<rparr>) d ((s' \\<lparr> clock := count2 \\<rparr>),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n     (update_clock (\\<lambda>_. count2) s', r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n     (update_clock (\\<lambda>_. count2) s', r)", "from assms"], ["proof (chain)\npicking this:\n  evaluate_dec False mn env (update_clock (\\<lambda>_. count1) s) d\n   (update_clock (\\<lambda>_. count1) s', r)", "have \"r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\nusing this:\n  evaluate_dec False mn env (update_clock (\\<lambda>_. count1) s) d\n   (update_clock (\\<lambda>_. count1) s', r)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "using dec_evaluate_not_timeout"], ["proof (prove)\nusing this:\n  evaluate_dec False mn env (update_clock (\\<lambda>_. count1) s) d\n   (update_clock (\\<lambda>_. count1) s', r)\n  evaluate_dec False ?mn ?env ?s ?d (?s', ?r) \\<Longrightarrow>\n  ?r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n     (update_clock (\\<lambda>_. count2) s', r)", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n     (update_clock (\\<lambda>_. count2) s', r)", "using assms dec_unclocked_ignore[rule_format]"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate_dec False mn env (update_clock (\\<lambda>_. count1) s) d\n   (update_clock (\\<lambda>_. count1) s', r)\n  \\<lbrakk>evaluate_dec ?ck ?mn ?env ?s ?d ?res;\n   ?res = (?s', ?r) \\<and> ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_dec False ?mn ?env\n                     (update_clock (\\<lambda>_. ?count) ?s) ?d\n                     (update_clock (\\<lambda>_. ?count) ?s', ?r)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n     (update_clock (\\<lambda>_. count2) s', r)", "by fastforce"], ["proof (state)\nthis:\n  evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n   (update_clock (\\<lambda>_. count2) s', r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dec_unclocked:\n  \"(evaluate_dec False mn env s d (s',r) \\<longrightarrow> (r \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (clock   s) = (clock   s')) \\<and>\n   (evaluate_dec False mn env (s (| clock := count1 |)) d ((s' (| clock := count1 |)),r) \\<longrightarrow>\n   evaluate_dec False mn env (s (| clock := count2 |)) d ((s' (| clock := count2 |)),r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_dec False mn env s d (s', r) \\<longrightarrow>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n     clock s = clock s') \\<and>\n    (evaluate_dec False mn env (update_clock (\\<lambda>_. count1) s) d\n      (update_clock (\\<lambda>_. count1) s', r) \\<longrightarrow>\n     evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n      (update_clock (\\<lambda>_. count2) s', r))", "using dec_unclocked_1 dec_unclocked_2"], ["proof (prove)\nusing this:\n  evaluate_dec False ?mn ?env ?s ?d (?s', ?r) \\<Longrightarrow>\n  ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock ?s = clock ?s'\n  evaluate_dec False ?mn ?env (update_clock (\\<lambda>_. ?count1.0) ?s) ?d\n   (update_clock (\\<lambda>_. ?count1.0) ?s', ?r) \\<Longrightarrow>\n  evaluate_dec False ?mn ?env (update_clock (\\<lambda>_. ?count2.0) ?s) ?d\n   (update_clock (\\<lambda>_. ?count2.0) ?s', ?r)\n\ngoal (1 subgoal):\n 1. (evaluate_dec False mn env s d (s', r) \\<longrightarrow>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n     clock s = clock s') \\<and>\n    (evaluate_dec False mn env (update_clock (\\<lambda>_. count1) s) d\n      (update_clock (\\<lambda>_. count1) s', r) \\<longrightarrow>\n     evaluate_dec False mn env (update_clock (\\<lambda>_. count2) s) d\n      (update_clock (\\<lambda>_. count2) s', r))", "by blast"], ["", "corollary big_clocked_unclocked_equiv_timeout_1:\n  \"(\\<forall>r. \\<not> evaluate False env s e r) \\<Longrightarrow>\n  (\\<forall>c. \\<exists>s'. evaluate True env (update_clock (\\<lambda>_. c) s) e (s', Rerr (Rabort Rtimeout_error)) \\<and> clock s' = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r. \\<not> evaluate False env s e r \\<Longrightarrow>\n    \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "using big_clocked_unclocked_equiv_timeout"], ["proof (prove)\nusing this:\n  (\\<forall>r. \\<not> evaluate False ?env ?s ?e r) =\n  (\\<forall>c.\n      \\<exists>s'.\n         evaluate True ?env (update_clock (\\<lambda>_. c) ?s) ?e\n          (s', Rerr (Rabort Rtimeout_error)) \\<and>\n         clock s' = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>r. \\<not> evaluate False env s e r \\<Longrightarrow>\n    \\<forall>c.\n       \\<exists>s'.\n          evaluate True env (update_clock (\\<lambda>_. c) s) e\n           (s', Rerr (Rabort Rtimeout_error)) \\<and>\n          clock s' = 0", "by blast"], ["", "lemma not_evaluate_dec_timeout:\n  assumes \"\\<forall>r. \\<not>evaluate_dec False mn env s d r\"\n  shows \"\\<exists>r. evaluate_dec True mn env s d r \\<and> snd r = Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_dec True mn env s d r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof (cases d)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "case (Dlet locs p e)"], ["proof (state)\nthis:\n  d = Dlet locs p e\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "have \"\\<not> evaluate False env s e r\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> evaluate False env s e r", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate False env s e r \\<Longrightarrow> False", "apply (cases \"Lem_list.allDistinct (pat_bindings p [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate False env s e r;\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>evaluate False env s e r;\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e r;\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>evaluate False env s e r; allDistinct (pat_bindings p []);\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>evaluate False env s e (a, b);\n        allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for s' r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e (s', r);\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases r; hypsubst_thin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate False env s e (s', Rval x1);\n        allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2.\n       \\<lbrakk>evaluate False env s e (s', Rerr x2);\n        allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \"pmatch(c   env)(refs   s') p v []\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s') p v [] = No_match\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s') p v [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>x3.\n       \\<lbrakk>evaluate False env s e (s', Rval v);\n        allDistinct (pat_bindings p []);\n        pmatch (c env) (refs s') p v [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s d r\n\ngoal (3 subgoals):\n 1. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s') p v [] = No_match\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s') p v [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>x3.\n       \\<lbrakk>evaluate False env s e (s', Rval v);\n        allDistinct (pat_bindings p []);\n        pmatch (c env) (refs s') p v [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> False", "unfolding Dlet"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s (Dlet locs p e) r\n\ngoal (3 subgoals):\n 1. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s') p v [] = No_match\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>evaluate False env s e (s', Rval v);\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s') p v [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>x3.\n       \\<lbrakk>evaluate False env s e (s', Rval v);\n        allDistinct (pat_bindings p []);\n        pmatch (c env) (refs s') p v [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis evaluate_dec.intros)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate False env s e (s', Rerr x2);\n        allDistinct (pat_bindings p [])\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e (s', Rerr x2_);\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s d r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e (s', Rerr x2_);\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "unfolding Dlet"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s (Dlet locs p e) r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e (s', Rerr x2_);\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis dlet5)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e r;\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e r;\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s d r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e r;\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "unfolding Dlet"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s (Dlet locs p e) r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate False env s e r;\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis dlet4)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> evaluate False env s e ?r\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "note big_clocked_unclocked_equiv_timeout_1[rule_format, OF this]"], ["proof (state)\nthis:\n  \\<exists>s'.\n     evaluate True env (update_clock (\\<lambda>_. ?c) s) e\n      (s', Rerr (Rabort Rtimeout_error)) \\<and>\n     clock s' = 0\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<exists>s'.\n     evaluate True env (update_clock (\\<lambda>_. ?c) s) e\n      (s', Rerr (Rabort Rtimeout_error)) \\<and>\n     clock s' = 0", "obtain s' where \"evaluate True env (update_clock (\\<lambda>_. clock s) s) e (s', Rerr (Rabort Rtimeout_error))\""], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     evaluate True env (update_clock (\\<lambda>_. ?c) s) e\n      (s', Rerr (Rabort Rtimeout_error)) \\<and>\n     clock s' = 0\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        evaluate True env (update_clock (\\<lambda>_. clock s) s) e\n         (s', Rerr (Rabort Rtimeout_error)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  evaluate True env (update_clock (\\<lambda>_. clock s) s) e\n   (s', Rerr (Rabort Rtimeout_error))\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  evaluate True env (update_clock (\\<lambda>_. clock s) s) e\n   (s', Rerr (Rabort Rtimeout_error))", "have \"evaluate True env s e (s', Rerr (Rabort Rtimeout_error))\""], ["proof (prove)\nusing this:\n  evaluate True env (update_clock (\\<lambda>_. clock s) s) e\n   (s', Rerr (Rabort Rtimeout_error))\n\ngoal (1 subgoal):\n 1. evaluate True env s e (s', Rerr (Rabort Rtimeout_error))", "by simp"], ["proof (state)\nthis:\n  evaluate True env s e (s', Rerr (Rabort Rtimeout_error))\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "have \"Lem_list.allDistinct (pat_bindings p [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct (pat_bindings p [])", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow> False", "apply (drule dlet4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ?ck2 ?mn2 ?env2 ?s2 (Dlet ?locs2 p ?e2)\n     (?s2, Rerr (Rabort Rtype_error)) \\<Longrightarrow>\n    False", "using assms Dlet"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_dec False mn env s d r\n  d = Dlet locs p e\n\ngoal (1 subgoal):\n 1. evaluate_dec ?ck2 ?mn2 ?env2 ?s2 (Dlet ?locs2 p ?e2)\n     (?s2, Rerr (Rabort Rtype_error)) \\<Longrightarrow>\n    False", "by blast"], ["proof (state)\nthis:\n  allDistinct (pat_bindings p [])\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_dec True mn env s d r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "unfolding Dlet"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_dec True mn env s (Dlet locs p e) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_dec True mn env s (Dlet locs p e) ?r\n 2. snd ?r = Rerr (Rabort Rtimeout_error)", "apply (rule dlet5)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate True env s e (?s'2, Rerr ?err2) \\<and>\n    allDistinct (pat_bindings p [])\n 2. snd (?s'2, Rerr ?err2) = Rerr (Rabort Rtimeout_error)", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. evaluate True env s e (?s'2, Rerr ?err2)\n 2. allDistinct (pat_bindings p [])\n 3. snd (?s'2, Rerr ?err2) = Rerr (Rabort Rtimeout_error)", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (s', Rerr (Rabort Rtimeout_error)) = Rerr (Rabort Rtimeout_error)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_dec True mn env s d r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 4. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_dec True mn env s d r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "qed (metis evaluate_dec.intros assms)+"], ["", "lemma dec_clocked_total: \"\\<exists>res. evaluate_dec True mn env s d res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>res. evaluate_dec True mn env s d res", "proof (cases d)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res", "case (Dlet locs p e)"], ["proof (state)\nthis:\n  d = Dlet locs p e\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res", "obtain s' r where e:\"evaluate True env s e (s', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate True env s e (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis evaluate_total)"], ["proof (state)\nthis:\n  evaluate True env s e (s', r)\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       d = Dlet x11 x12 x13 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 2. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 3. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 4. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 5. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>res. evaluate_dec True mn env s d res", "unfolding Dlet"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res", "apply (cases \"Lem_list.allDistinct (pat_bindings p [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. allDistinct (pat_bindings p []) \\<Longrightarrow>\n    \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res\n 2. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct (pat_bindings p []) \\<Longrightarrow>\n    \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res", "using e"], ["proof (prove)\nusing this:\n  evaluate True env s e (s', r)\n\ngoal (1 subgoal):\n 1. allDistinct (pat_bindings p []) \\<Longrightarrow>\n    \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res", "apply (cases r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        evaluate True env s e (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res.\n                            evaluate_dec True mn env s (Dlet locs p e) res\n 2. \\<And>x2.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        evaluate True env s e (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res.\n                            evaluate_dec True mn env s (Dlet locs p e) res", "subgoal for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []); evaluate True env s e (s', r);\n     r = Rval v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>res.\n                         evaluate_dec True mn env s (Dlet locs p e) res", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     evaluate True env s e (s', Rval v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>res.\n                         evaluate_dec True mn env s (Dlet locs p e) res", "apply (cases \"pmatch(c   env)(refs   s') p v []\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     evaluate True env s e (s', Rval v);\n     pmatch (c env) (refs s') p v [] = No_match\\<rbrakk>\n    \\<Longrightarrow> \\<exists>res.\n                         evaluate_dec True mn env s (Dlet locs p e) res\n 2. \\<lbrakk>allDistinct (pat_bindings p []);\n     evaluate True env s e (s', Rval v);\n     pmatch (c env) (refs s') p v [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> \\<exists>res.\n                         evaluate_dec True mn env s (Dlet locs p e) res\n 3. \\<And>x3.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        evaluate True env s e (s', Rval v);\n        pmatch (c env) (refs s') p v [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res.\n                            evaluate_dec True mn env s (Dlet locs p e) res", "using evaluate_dec.intros"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     evaluate True env s e (s', Rval v);\n     pmatch (c env) (refs s') p v [] = No_match\\<rbrakk>\n    \\<Longrightarrow> \\<exists>res.\n                         evaluate_dec True mn env s (Dlet locs p e) res\n 2. \\<lbrakk>allDistinct (pat_bindings p []);\n     evaluate True env s e (s', Rval v);\n     pmatch (c env) (refs s') p v [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> \\<exists>res.\n                         evaluate_dec True mn env s (Dlet locs p e) res\n 3. \\<And>x3.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        evaluate True env s e (s', Rval v);\n        pmatch (c env) (refs s') p v [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res.\n                            evaluate_dec True mn env s (Dlet locs p e) res", "by metis+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        evaluate True env s e (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res.\n                            evaluate_dec True mn env s (Dlet locs p e) res", "using evaluate_dec.intros"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        evaluate True env s e (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res.\n                            evaluate_dec True mn env s (Dlet locs p e) res", "by metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res", "using evaluate_dec.intros"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n\ngoal (1 subgoal):\n 1. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    \\<exists>res. evaluate_dec True mn env s (Dlet locs p e) res", "by metis"], ["proof (state)\nthis:\n  \\<exists>res. evaluate_dec True mn env s d res\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       d = Dletrec x21 x22 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 2. \\<And>x31 x32.\n       d = Dtype x31 x32 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 3. \\<And>x41 x42 x43 x44.\n       d = Dtabbrev x41 x42 x43 x44 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res\n 4. \\<And>x51 x52 x53.\n       d = Dexn x51 x52 x53 \\<Longrightarrow>\n       \\<exists>res. evaluate_dec True mn env s d res", "qed (blast intro: evaluate_dec.intros)+"], ["", "lemma dec_clocked_min_counter:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow> ck = True \\<Longrightarrow>\n   evaluate_dec ck mn env (s (| clock := (clock   s) - (clock   (fst res))|)) d (((fst res) (| clock := 0|)), snd res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_dec ck mn env s d res; ck = True\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec ck mn env\n                       (update_clock (\\<lambda>_. clock s - clock (fst res))\n                         s)\n                       d (update_clock (\\<lambda>_. 0) (fst res), snd res)", "proof (induction rule:evaluate_dec.inducts)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       \\<lbrakk>check_dup_ctors tds \\<and>\n                new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n                disjnt new_tdecs (defined_types s) \\<and>\n                allDistinct\n                 (map (\\<lambda>x.\n                          case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                   tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (update_defined_types\n  (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n Rval (make_sem_env nsEmpty (build_tdefs mn tds)))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (update_defined_types\n                                   (\\<lambda>_.\n new_tdecs \\<union> defined_types s)\n                                   s,\n                                  Rval\n                                   (make_sem_env nsEmpty\n                                     (build_tdefs mn tds)))),\n                           snd (update_defined_types\n                                 (\\<lambda>_.\n                                     new_tdecs \\<union> defined_types s)\n                                 s,\n                                Rval\n                                 (make_sem_env nsEmpty\n                                   (build_tdefs mn tds))))\n 9. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        ck = True \\<Longrightarrow>\n        evaluate_dec ck mn env\n         (update_clock\n           (\\<lambda>_.\n               clock s -\n               clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n           s)\n         (Dtabbrev locs tvs tn t0)\n         (update_clock (\\<lambda>_. 0)\n           (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n          snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       \\<lbrakk>check_dup_ctors tds \\<and>\n                new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n                disjnt new_tdecs (defined_types s) \\<and>\n                allDistinct\n                 (map (\\<lambda>x.\n                          case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                   tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (update_defined_types\n  (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n Rval (make_sem_env nsEmpty (build_tdefs mn tds)))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (update_defined_types\n                                   (\\<lambda>_.\n new_tdecs \\<union> defined_types s)\n                                   s,\n                                  Rval\n                                   (make_sem_env nsEmpty\n                                     (build_tdefs mn tds)))),\n                           snd (update_defined_types\n                                 (\\<lambda>_.\n                                     new_tdecs \\<union> defined_types s)\n                                 s,\n                                Rval\n                                 (make_sem_env nsEmpty\n                                   (build_tdefs mn tds))))\n 9. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        ck = True \\<Longrightarrow>\n        evaluate_dec ck mn env\n         (update_clock\n           (\\<lambda>_.\n               clock s -\n               clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n           s)\n         (Dtabbrev locs tvs tn t0)\n         (update_clock (\\<lambda>_. 0)\n           (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n          snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\nA total of 12 subgoals...", "case dtype1"], ["proof (state)\nthis:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n  ck_ = True\n\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       \\<lbrakk>check_dup_ctors tds \\<and>\n                new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n                disjnt new_tdecs (defined_types s) \\<and>\n                allDistinct\n                 (map (\\<lambda>x.\n                          case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                   tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (update_defined_types\n  (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n Rval (make_sem_env nsEmpty (build_tdefs mn tds)))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (update_defined_types\n                                   (\\<lambda>_.\n new_tdecs \\<union> defined_types s)\n                                   s,\n                                  Rval\n                                   (make_sem_env nsEmpty\n                                     (build_tdefs mn tds)))),\n                           snd (update_defined_types\n                                 (\\<lambda>_.\n                                     new_tdecs \\<union> defined_types s)\n                                 s,\n                                Rval\n                                 (make_sem_env nsEmpty\n                                   (build_tdefs mn tds))))\n 9. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        ck = True \\<Longrightarrow>\n        evaluate_dec ck mn env\n         (update_clock\n           (\\<lambda>_.\n               clock s -\n               clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n           s)\n         (Dtabbrev locs tvs tn t0)\n         (update_clock (\\<lambda>_. 0)\n           (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n          snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n  ck_ = True", "show ?case"], ["proof (prove)\nusing this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n  ck_ = True\n\ngoal (1 subgoal):\n 1. evaluate_dec ck_ mn_ env_\n     (update_clock\n       (\\<lambda>_.\n           clock s_ -\n           clock\n            (fst (update_defined_types\n                   (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n                  Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_)))))\n       s_)\n     (Dtype locs_ tds_)\n     (update_clock (\\<lambda>_. 0)\n       (fst (update_defined_types\n              (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n             Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_)))),\n      snd (update_defined_types\n            (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n           Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ck_; check_dup_ctors tds_;\n     new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n     disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n     allDistinct\n      (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n        tds_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. 0) s_) (Dtype locs_ tds_)\n                       (update_defined_types\n                         (\\<lambda>_.\n                             type_defs_to_new_tdecs mn_ tds_ \\<union>\n                             defined_types s_)\n                         (update_clock (\\<lambda>_. 0) s_),\n                        Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "using state.record_simps(4) evaluate_dec.intros"], ["proof (prove)\nusing this:\n  defined_types (update_clock ?f ?x) = defined_types ?x\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ck_; check_dup_ctors tds_;\n     new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n     disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n     allDistinct\n      (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n        tds_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. 0) s_) (Dtype locs_ tds_)\n                       (update_defined_types\n                         (\\<lambda>_.\n                             type_defs_to_new_tdecs mn_ tds_ \\<union>\n                             defined_types s_)\n                         (update_clock (\\<lambda>_. 0) s_),\n                        Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "by metis"], ["proof (state)\nthis:\n  evaluate_dec ck_ mn_ env_\n   (update_clock\n     (\\<lambda>_.\n         clock s_ -\n         clock\n          (fst (update_defined_types\n                 (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n                Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_)))))\n     s_)\n   (Dtype locs_ tds_)\n   (update_clock (\\<lambda>_. 0)\n     (fst (update_defined_types\n            (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n           Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_)))),\n    snd (update_defined_types\n          (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n         Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))))\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       ck = True \\<Longrightarrow>\n       evaluate_dec ck mn env\n        (update_clock\n          (\\<lambda>_.\n              clock s -\n              clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n          s)\n        (Dtabbrev locs tvs tn t0)\n        (update_clock (\\<lambda>_. 0)\n          (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n         snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\n 10. \\<And>ck mn env cn ts s locs.\n        \\<lbrakk>TypeExn (mk_id mn cn) \\<notin> defined_types s;\n         ck = True\\<rbrakk>\n        \\<Longrightarrow> evaluate_dec ck mn env\n                           (update_clock\n                             (\\<lambda>_.\n                                 clock s -\n                                 clock\n                                  (fst (update_defined_types\n   (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s) s,\n  Rval\n   (make_sem_env nsEmpty (nsSing cn (length ts, TypeExn (mk_id mn cn)))))))\n                             s)\n                           (Dexn locs cn ts)\n                           (update_clock (\\<lambda>_. 0)\n                             (fst (update_defined_types\n                                    (\\<lambda>_.\n  {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n                                    s,\n                                   Rval\n                                    (make_sem_env nsEmpty\n(nsSing cn (length ts, TypeExn (mk_id mn cn)))))),\n                            snd (update_defined_types\n                                  (\\<lambda>_.\n{TypeExn (mk_id mn cn)} \\<union> defined_types s)\n                                  s,\n                                 Rval\n                                  (make_sem_env nsEmpty\n                                    (nsSing cn\n(length ts, TypeExn (mk_id mn cn))))))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       ck = True \\<Longrightarrow>\n       evaluate_dec ck mn env\n        (update_clock\n          (\\<lambda>_.\n              clock s -\n              clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n          s)\n        (Dtabbrev locs tvs tn t0)\n        (update_clock (\\<lambda>_. 0)\n          (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n         snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\n 10. \\<And>ck mn env cn ts s locs.\n        \\<lbrakk>TypeExn (mk_id mn cn) \\<notin> defined_types s;\n         ck = True\\<rbrakk>\n        \\<Longrightarrow> evaluate_dec ck mn env\n                           (update_clock\n                             (\\<lambda>_.\n                                 clock s -\n                                 clock\n                                  (fst (update_defined_types\n   (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s) s,\n  Rval\n   (make_sem_env nsEmpty (nsSing cn (length ts, TypeExn (mk_id mn cn)))))))\n                             s)\n                           (Dexn locs cn ts)\n                           (update_clock (\\<lambda>_. 0)\n                             (fst (update_defined_types\n                                    (\\<lambda>_.\n  {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n                                    s,\n                                   Rval\n                                    (make_sem_env nsEmpty\n(nsSing cn (length ts, TypeExn (mk_id mn cn)))))),\n                            snd (update_defined_types\n                                  (\\<lambda>_.\n{TypeExn (mk_id mn cn)} \\<union> defined_types s)\n                                  s,\n                                 Rval\n                                  (make_sem_env nsEmpty\n                                    (nsSing cn\n(length ts, TypeExn (mk_id mn cn))))))\nA total of 11 subgoals...", "case dexn1"], ["proof (state)\nthis:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n  ck_ = True\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       ck = True \\<Longrightarrow>\n       evaluate_dec ck mn env\n        (update_clock\n          (\\<lambda>_.\n              clock s -\n              clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n          s)\n        (Dtabbrev locs tvs tn t0)\n        (update_clock (\\<lambda>_. 0)\n          (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n         snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\n 10. \\<And>ck mn env cn ts s locs.\n        \\<lbrakk>TypeExn (mk_id mn cn) \\<notin> defined_types s;\n         ck = True\\<rbrakk>\n        \\<Longrightarrow> evaluate_dec ck mn env\n                           (update_clock\n                             (\\<lambda>_.\n                                 clock s -\n                                 clock\n                                  (fst (update_defined_types\n   (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s) s,\n  Rval\n   (make_sem_env nsEmpty (nsSing cn (length ts, TypeExn (mk_id mn cn)))))))\n                             s)\n                           (Dexn locs cn ts)\n                           (update_clock (\\<lambda>_. 0)\n                             (fst (update_defined_types\n                                    (\\<lambda>_.\n  {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n                                    s,\n                                   Rval\n                                    (make_sem_env nsEmpty\n(nsSing cn (length ts, TypeExn (mk_id mn cn)))))),\n                            snd (update_defined_types\n                                  (\\<lambda>_.\n{TypeExn (mk_id mn cn)} \\<union> defined_types s)\n                                  s,\n                                 Rval\n                                  (make_sem_env nsEmpty\n                                    (nsSing cn\n(length ts, TypeExn (mk_id mn cn))))))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n  ck_ = True", "show ?case"], ["proof (prove)\nusing this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n  ck_ = True\n\ngoal (1 subgoal):\n 1. evaluate_dec ck_ mn_ env_\n     (update_clock\n       (\\<lambda>_.\n           clock s_ -\n           clock\n            (fst (update_defined_types\n                   (\\<lambda>_.\n                       {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n                   s_,\n                  Rval\n                   (make_sem_env nsEmpty\n                     (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_)))))))\n       s_)\n     (Dexn locs_ cn_ ts_)\n     (update_clock (\\<lambda>_. 0)\n       (fst (update_defined_types\n              (\\<lambda>_.\n                  {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n              s_,\n             Rval\n              (make_sem_env nsEmpty\n                (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_)))))),\n      snd (update_defined_types\n            (\\<lambda>_.\n                {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n            s_,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_; ck_\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. 0) s_)\n                       (Dexn locs_ cn_ ts_)\n                       (update_defined_types\n                         (\\<lambda>_.\n                             insert (TypeExn (mk_id mn_ cn_))\n                              (defined_types s_))\n                         (update_clock (\\<lambda>_. 0) s_),\n                        Rval\n                         (make_sem_env nsEmpty\n                           (nsSing cn_\n                             (length ts_, TypeExn (mk_id mn_ cn_)))))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_; ck_\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. 0) s_)\n                       (Dexn locs_ cn_ ts_)\n                       (update_defined_types\n                         (\\<lambda>_.\n                             insert (TypeExn (mk_id mn_ cn_))\n                              (defined_types s_))\n                         (update_clock (\\<lambda>_. 0) s_),\n                        Rval\n                         (make_sem_env nsEmpty\n                           (nsSing cn_\n                             (length ts_, TypeExn (mk_id mn_ cn_)))))", "by (metis Un_insert_left sup_bot.left_neutral)"], ["proof (state)\nthis:\n  evaluate_dec ck_ mn_ env_\n   (update_clock\n     (\\<lambda>_.\n         clock s_ -\n         clock\n          (fst (update_defined_types\n                 (\\<lambda>_.\n                     {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n                 s_,\n                Rval\n                 (make_sem_env nsEmpty\n                   (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_)))))))\n     s_)\n   (Dexn locs_ cn_ ts_)\n   (update_clock (\\<lambda>_. 0)\n     (fst (update_defined_types\n            (\\<lambda>_.\n                {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n            s_,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_)))))),\n    snd (update_defined_types\n          (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n          s_,\n         Rval\n          (make_sem_env nsEmpty\n            (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))))\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match env';\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock\n                                 (fst (s2,\n Rval (make_sem_env (alist_to_ns env') nsEmpty))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2,\n                                  Rval\n                                   (make_sem_env (alist_to_ns env')\n                                     nsEmpty))),\n                           snd (s2,\n                                Rval\n                                 (make_sem_env (alist_to_ns env') nsEmpty)))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = No_match;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rraise Bindv))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rraise Bindv))),\n                           snd (s2, Rerr (Rraise Bindv)))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       \\<lbrakk>evaluate ck env s1 e (s2, Rval v1) \\<and>\n                allDistinct (pat_bindings p []) \\<and>\n                pmatch (c env) (refs s2) p v1 [] = Match_type_error;\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s1 -\n                                clock (fst (s2, Rerr (Rabort Rtype_error))))\n                            s1)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s2, Rerr (Rabort Rtype_error))),\n                           snd (s2, Rerr (Rabort Rtype_error)))\n 4. \\<And>ck mn env p e s locs.\n       \\<lbrakk>\\<not> allDistinct (pat_bindings p []); ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 5. \\<And>ck mn env p e err s s' locs.\n       \\<lbrakk>evaluate ck env s e (s', Rerr err) \\<and>\n                allDistinct (pat_bindings p []);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s - clock (fst (s', Rerr err)))\n                            s)\n                          (Dlet locs p e)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s', Rerr err)),\n                           snd (s', Rerr err))\n 6. \\<And>ck mn env funs s locs.\n       \\<lbrakk>allDistinct\n                 (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                   funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock\n                                 (fst (s,\n Rval (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rval\n(make_sem_env (build_rec_env funs env nsEmpty) nsEmpty))),\n                           snd (s, Rval\n                                    (make_sem_env\n(build_rec_env funs env nsEmpty) nsEmpty)))\n 7. \\<And>ck mn env funs s locs.\n       \\<lbrakk>\\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of (x, y, z) \\<Rightarrow> x)\n                          funs);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dletrec locs funs)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 8. \\<And>ck mn env tds s locs.\n       \\<lbrakk>\\<not> check_dup_ctors tds \\<or>\n                \\<not> disjnt (type_defs_to_new_tdecs mn tds)\n                        (defined_types s) \\<or>\n                \\<not> allDistinct\n                        (map (\\<lambda>x.\n                                 case x of\n                                 (tvs, tn, ctors) \\<Rightarrow> tn)\n                          tds);\n        ck = True\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec ck mn env\n                          (update_clock\n                            (\\<lambda>_.\n                                clock s -\n                                clock (fst (s, Rerr (Rabort Rtype_error))))\n                            s)\n                          (Dtype locs tds)\n                          (update_clock (\\<lambda>_. 0)\n                            (fst (s, Rerr (Rabort Rtype_error))),\n                           snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       ck = True \\<Longrightarrow>\n       evaluate_dec ck mn env\n        (update_clock\n          (\\<lambda>_.\n              clock s -\n              clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))))\n          s)\n        (Dtabbrev locs tvs tn t0)\n        (update_clock (\\<lambda>_. 0)\n          (fst (s, Rval (make_sem_env nsEmpty nsEmpty))),\n         snd (s, Rval (make_sem_env nsEmpty nsEmpty)))\n 10. \\<And>ck mn env cn ts s locs.\n        \\<lbrakk>TypeExn (mk_id mn cn) \\<in> defined_types s;\n         ck = True\\<rbrakk>\n        \\<Longrightarrow> evaluate_dec ck mn env\n                           (update_clock\n                             (\\<lambda>_.\n                                 clock s -\n                                 clock (fst (s, Rerr (Rabort Rtype_error))))\n                             s)\n                           (Dexn locs cn ts)\n                           (update_clock (\\<lambda>_. 0)\n                             (fst (s, Rerr (Rabort Rtype_error))),\n                            snd (s, Rerr (Rabort Rtype_error)))", "qed (force intro:evaluate_dec.intros simp add:clocked_min_counter)+"], ["", "lemma dec_sub_from_counter:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   (\\<forall>count count' s' r. (clock   s) = count + extra \\<and> (clock   s') = count' + extra \\<and> res = (s',r) \\<and> ck = True \\<longrightarrow>\n     evaluate_dec ck mn env (s (| clock := count |)) d ((s' (| clock := count' |)),r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ck mn env s d res \\<Longrightarrow>\n    \\<forall>count count' s' r.\n       clock s = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       res = (s', r) \\<and> ck = True \\<longrightarrow>\n       evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s) d\n        (update_clock (\\<lambda>_. count') s', r)", "proof (induction rule:evaluate_dec.inducts)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. count') s', r)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. count') s', r)\nA total of 12 subgoals...", "case dtype1"], ["proof (state)\nthis:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. count') s', r)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)", "show ?case"], ["proof (prove)\nusing this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r.\n       clock s_ = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       (update_defined_types\n         (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n        Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n       (s', r) \\<and>\n       ck_ = True \\<longrightarrow>\n       evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dtype locs_ tds_) (update_clock (\\<lambda>_. count') s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count.\n       \\<lbrakk>check_dup_ctors tds_;\n        new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n        disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n        allDistinct (map (\\<lambda>(tvs, tn, ctors). tn) tds_);\n        clock s_ = count + extra; ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. count) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. count) s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<And>count.\n       \\<lbrakk>check_dup_ctors tds_;\n        new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n        disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n        allDistinct (map (\\<lambda>(tvs, tn, ctors). tn) tds_);\n        clock s_ = count + extra; ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. count) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. count) s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "by (metis)"], ["proof (state)\nthis:\n  \\<forall>count count' s' r.\n     clock s_ = count + extra \\<and>\n     clock s' = count' + extra \\<and>\n     (update_defined_types\n       (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n      Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n     (s', r) \\<and>\n     ck_ = True \\<longrightarrow>\n     evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n      (Dtype locs_ tds_) (update_clock (\\<lambda>_. count') s', r)\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)\nA total of 11 subgoals...", "case dtype2"], ["proof (state)\nthis:\n  \\<not> check_dup_ctors tds_ \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            tds_)\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtype locs tds) (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<not> check_dup_ctors tds_ \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            tds_)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> check_dup_ctors tds_ \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            tds_)\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r.\n       clock s_ = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = True \\<longrightarrow>\n       evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dtype locs_ tds_) (update_clock (\\<lambda>_. count') s', r)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> check_dup_ctors tds_ \\<Longrightarrow>\n    \\<forall>count count' s' r.\n       clock s_ = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = True \\<longrightarrow>\n       evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dtype locs_ tds_) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n    \\<not> allDistinct\n            (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n              tds_) \\<Longrightarrow>\n    \\<forall>count count' s' r.\n       clock s_ = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = True \\<longrightarrow>\n       evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dtype locs_ tds_) (update_clock (\\<lambda>_. count') s', r)", "by (auto intro!: evaluate_dec.intros)"], ["proof (state)\nthis:\n  \\<forall>count count' s' r.\n     clock s_ = count + extra \\<and>\n     clock s' = count' + extra \\<and>\n     (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n     ck_ = True \\<longrightarrow>\n     evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n      (Dtype locs_ tds_) (update_clock (\\<lambda>_. count') s', r)\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)", "case dexn1"], ["proof (state)\nthis:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>count count' s' r.\n           clock s = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = True \\<longrightarrow>\n           evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n            (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)", "then"], ["proof (chain)\npicking this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_", "show ?case"], ["proof (prove)\nusing this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (1 subgoal):\n 1. \\<forall>count count' s' r.\n       clock s_ = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       (update_defined_types\n         (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n         s_,\n        Rval\n         (make_sem_env nsEmpty\n           (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n       (s', r) \\<and>\n       ck_ = True \\<longrightarrow>\n       evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n        (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. count') s', r)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>count.\n       \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n        clock s_ = count + extra; ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. count) s_)\n                          (Dexn locs_ cn_ ts_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                insert (TypeExn (mk_id mn_ cn_))\n                                 (defined_types s_))\n                            (update_clock (\\<lambda>_. count) s_),\n                           Rval\n                            (make_sem_env nsEmpty\n                              (nsSing cn_\n                                (length ts_, TypeExn (mk_id mn_ cn_)))))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<And>count.\n       \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n        clock s_ = count + extra; ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. count) s_)\n                          (Dexn locs_ cn_ ts_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                insert (TypeExn (mk_id mn_ cn_))\n                                 (defined_types s_))\n                            (update_clock (\\<lambda>_. count) s_),\n                           Rval\n                            (make_sem_env nsEmpty\n                              (nsSing cn_\n                                (length ts_, TypeExn (mk_id mn_ cn_)))))", "by (metis Un_insert_left sup_bot.left_neutral)"], ["proof (state)\nthis:\n  \\<forall>count count' s' r.\n     clock s_ = count + extra \\<and>\n     clock s' = count' + extra \\<and>\n     (update_defined_types\n       (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_) s_,\n      Rval\n       (make_sem_env nsEmpty\n         (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n     (s', r) \\<and>\n     ck_ = True \\<longrightarrow>\n     evaluate_dec ck_ mn_ env_ (update_clock (\\<lambda>_. count) s_)\n      (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. count') s', r)\n\ngoal (9 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s1)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>count count' s'a r.\n          clock s = count + extra \\<and>\n          clock s'a = count' + extra \\<and>\n          (s', Rerr err) = (s'a, r) \\<and> ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dlet locs p e) (update_clock (\\<lambda>_. count') s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dletrec locs funs) (update_clock (\\<lambda>_. count') s', r)\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. count') s', r)\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>count count' s' r.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_dec ck mn env (update_clock (\\<lambda>_. count) s)\n           (Dexn locs cn ts) (update_clock (\\<lambda>_. count') s', r)", "qed (force intro:evaluate_dec.intros simp add:sub_from_counter)+"], ["", "lemma dec_clock_monotone:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow> ck = True \\<Longrightarrow> (clock   (fst res)) \\<le> (clock   s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_dec ck mn env s d res; ck = True\\<rbrakk>\n    \\<Longrightarrow> clock (fst res) \\<le> clock s", "by (induction rule:evaluate_dec.inducts)\n     (auto simp add:clock_monotone)"], ["", "lemma dec_add_clock:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   \\<forall>s' r. res = (s',r) \\<and> ck = False \\<longrightarrow> (\\<exists>c. evaluate_dec True mn env (s (| clock := c |)) d ((s' (| clock := 0 |)),r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ck mn env s d res \\<Longrightarrow>\n    \\<forall>s' r.\n       res = (s', r) \\<and> ck = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn env (update_clock (\\<lambda>_. c) s) d\n            (update_clock (\\<lambda>_. 0) s', r))", "proof (induction rule: evaluate_dec.inducts)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dtabbrev locs tvs tn t0)\n                (update_clock (\\<lambda>_. 0) s', r))\nA total of 12 subgoals...", "case dlet1"], ["proof (state)\nthis:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = Match env'_\n\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dtabbrev locs tvs tn t0)\n                (update_clock (\\<lambda>_. 0) s', r))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = Match env'_", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = Match env'_\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s2_, Rval (make_sem_env (alist_to_ns env'_) nsEmpty)) =\n       (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n            (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate ck_ env_ s1_ e_ (s2_, Rval v1_);\n     allDistinct (pat_bindings p_ []) \\<and>\n     pmatch (c env_) (refs s2_) p_ v1_ [] = Match env'_\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s' r.\n                         (s2_,\n                          Rval (make_sem_env (alist_to_ns env'_) nsEmpty)) =\n                         (s', r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s1_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s', r))", "apply (drule add_clock(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p_ []) \\<and>\n             pmatch (c env_) (refs s2_) p_ v1_ [] = Match env'_;\n     \\<forall>s' r'.\n        (s2_, Rval v1_) = (s', r') \\<and> ck_ = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate True env_ (update_clock (\\<lambda>_. c) s1_) e_\n             (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s' r.\n                         (s2_,\n                          Rval (make_sem_env (alist_to_ns env'_) nsEmpty)) =\n                         (s', r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s1_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s', r))", "by (auto|rule)+"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s2_, Rval (make_sem_env (alist_to_ns env'_) nsEmpty)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n          (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 5. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 5. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\nA total of 11 subgoals...", "case dlet2"], ["proof (state)\nthis:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = No_match\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 5. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = No_match", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = No_match\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s2_, Rerr (Rraise Bindv)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n            (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate ck_ env_ s1_ e_ (s2_, Rval v1_);\n     allDistinct (pat_bindings p_ []) \\<and>\n     pmatch (c env_) (refs s2_) p_ v1_ [] = No_match\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s' r.\n                         (s2_, Rerr (Rraise Bindv)) = (s', r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s1_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s', r))", "apply (drule add_clock(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p_ []) \\<and>\n             pmatch (c env_) (refs s2_) p_ v1_ [] = No_match;\n     \\<forall>s' r'.\n        (s2_, Rval v1_) = (s', r') \\<and> ck_ = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate True env_ (update_clock (\\<lambda>_. c) s1_) e_\n             (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s' r.\n                         (s2_, Rerr (Rraise Bindv)) = (s', r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s1_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       \\<lbrakk>allDistinct (pat_bindings p_ []);\n        pmatch (c env_) (refs s2_) p_ v1_ [] = No_match; \\<not> ck_;\n        evaluate True env_ (update_clock (\\<lambda>_. ca) s1_) e_\n         (update_clock (\\<lambda>_. 0) s2_, Rval v1_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_dec True mn_ env_\n                             (update_clock (\\<lambda>_. c) s1_)\n                             (Dlet locs_ p_ e_)\n                             (update_clock (\\<lambda>_. 0) s2_,\n                              Rerr (Rraise Bindv))", "by rule+ auto"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s2_, Rerr (Rraise Bindv)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n          (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 4. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>s' r.\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 4. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>s' r.\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dlet3"], ["proof (state)\nthis:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = Match_type_error\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 4. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>s' r.\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n                (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = Match_type_error", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck_ env_ s1_ e_ (s2_, Rval v1_) \\<and>\n  allDistinct (pat_bindings p_ []) \\<and>\n  pmatch (c env_) (refs s2_) p_ v1_ [] = Match_type_error\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s2_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n            (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate ck_ env_ s1_ e_ (s2_, Rval v1_);\n     allDistinct (pat_bindings p_ []) \\<and>\n     pmatch (c env_) (refs s2_) p_ v1_ [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s' r.\n                         (s2_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s1_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s', r))", "apply (drule add_clock(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p_ []) \\<and>\n             pmatch (c env_) (refs s2_) p_ v1_ [] = Match_type_error;\n     \\<forall>s' r'.\n        (s2_, Rval v1_) = (s', r') \\<and> ck_ = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate True env_ (update_clock (\\<lambda>_. c) s1_) e_\n             (update_clock (\\<lambda>_. 0) s', r'))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s' r.\n                         (s2_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s1_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       \\<lbrakk>allDistinct (pat_bindings p_ []);\n        pmatch (c env_) (refs s2_) p_ v1_ [] = Match_type_error; \\<not> ck_;\n        evaluate True env_ (update_clock (\\<lambda>_. ca) s1_) e_\n         (update_clock (\\<lambda>_. 0) s2_, Rval v1_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_dec True mn_ env_\n                             (update_clock (\\<lambda>_. c) s1_)\n                             (Dlet locs_ p_ e_)\n                             (update_clock (\\<lambda>_. 0) s2_,\n                              Rerr (Rabort Rtype_error))", "by rule+ auto"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s2_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n          (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (9 subgoals):\n 1. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 3. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 3. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dlet4"], ["proof (state)\nthis:\n  \\<not> allDistinct (pat_bindings p_ [])\n\ngoal (9 subgoals):\n 1. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 3. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 9. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  \\<not> allDistinct (pat_bindings p_ [])", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> allDistinct (pat_bindings p_ [])\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))", "by (auto intro:evaluate_dec.intros)"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (8 subgoals):\n 1. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 2. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 2. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dlet5"], ["proof (state)\nthis:\n  evaluate ck_ env_ s_ e_ (s'_, Rerr err_) \\<and>\n  allDistinct (pat_bindings p_ [])\n\ngoal (8 subgoals):\n 1. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r.\n          (s', Rerr err) = (s'a, r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dlet locs p e) (update_clock (\\<lambda>_. 0) s'a, r))\n 2. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 8. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  evaluate ck_ env_ s_ e_ (s'_, Rerr err_) \\<and>\n  allDistinct (pat_bindings p_ [])", "show ?case"], ["proof (prove)\nusing this:\n  evaluate ck_ env_ s_ e_ (s'_, Rerr err_) \\<and>\n  allDistinct (pat_bindings p_ [])\n\ngoal (1 subgoal):\n 1. \\<forall>s'a r.\n       (s'_, Rerr err_) = (s'a, r) \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s'a, r))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate ck_ env_ s_ e_ (s'_, Rerr err_);\n     allDistinct (pat_bindings p_ [])\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s'a r.\n                         (s'_, Rerr err_) = (s'a, r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s'a, r))", "apply (drule add_clock(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p_ []);\n     \\<forall>s'a r'.\n        (s'_, Rerr err_) = (s'a, r') \\<and> ck_ = False \\<longrightarrow>\n        (\\<exists>c.\n            evaluate True env_ (update_clock (\\<lambda>_. c) s_) e_\n             (update_clock (\\<lambda>_. 0) s'a, r'))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s'a r.\n                         (s'_, Rerr err_) = (s'a, r) \\<and>\n                         ck_ = False \\<longrightarrow>\n                         (\\<exists>c.\n                             evaluate_dec True mn_ env_\n                              (update_clock (\\<lambda>_. c) s_)\n                              (Dlet locs_ p_ e_)\n                              (update_clock (\\<lambda>_. 0) s'a, r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>allDistinct (pat_bindings p_ []); \\<not> ck_;\n        evaluate True env_ (update_clock (\\<lambda>_. c) s_) e_\n         (update_clock (\\<lambda>_. 0) s'_, Rerr err_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_dec True mn_ env_\n                             (update_clock (\\<lambda>_. c) s_)\n                             (Dlet locs_ p_ e_)\n                             (update_clock (\\<lambda>_. 0) s'_, Rerr err_)", "by rule+ auto"], ["proof (state)\nthis:\n  \\<forall>s'a r.\n     (s'_, Rerr err_) = (s'a, r) \\<and> ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dlet locs_ p_ e_) (update_clock (\\<lambda>_. 0) s'a, r))\n\ngoal (7 subgoals):\n 1. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dletrec1"], ["proof (state)\nthis:\n  allDistinct (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs_)\n\ngoal (7 subgoals):\n 1. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 7. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  allDistinct (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs_)", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s_,\n        Rval (make_sem_env (build_rec_env funs_ env_ nsEmpty) nsEmpty)) =\n       (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dletrec locs_ funs_) (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct\n              (map (\\<lambda>x. case x of (x, a) \\<Rightarrow> x) funs_);\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. c) s_)\n                          (Dletrec locs_ funs_)\n                          (update_clock (\\<lambda>_. 0) s_,\n                           Rval\n                            (make_sem_env (build_rec_env funs_ env_ nsEmpty)\n                              nsEmpty))", "by rule+ auto"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s_, Rval (make_sem_env (build_rec_env funs_ env_ nsEmpty) nsEmpty)) =\n     (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dletrec locs_ funs_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (6 subgoals):\n 1. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dletrec2"], ["proof (state)\nthis:\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs_)\n\ngoal (6 subgoals):\n 1. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dletrec locs funs) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 6. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs_)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x) funs_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dletrec locs_ funs_) (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> allDistinct\n                     (map (\\<lambda>x. case x of (x, a) \\<Rightarrow> x)\n                       funs_);\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. c) s_)\n                          (Dletrec locs_ funs_)\n                          (update_clock (\\<lambda>_. 0) s_,\n                           Rerr (Rabort Rtype_error))", "by rule+ auto"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dletrec locs_ funs_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (5 subgoals):\n 1. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dtype1"], ["proof (state)\nthis:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (5 subgoals):\n 1. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 5. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)", "show ?case"], ["proof (prove)\nusing this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (update_defined_types\n         (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n        Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n       (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dtype locs_ tds_) (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_dup_ctors tds_;\n     new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n     disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n     allDistinct\n      (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_);\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. c) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. 0) s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "by (metis (full_types) evaluate_dec.dtype1 state.record_simps(4))"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (update_defined_types\n       (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n      Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n     (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dtype locs_ tds_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (4 subgoals):\n 1. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dtype2"], ["proof (state)\nthis:\n  \\<not> check_dup_ctors tds_ \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            tds_)\n\ngoal (4 subgoals):\n 1. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtype locs tds) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 4. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  \\<not> check_dup_ctors tds_ \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            tds_)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> check_dup_ctors tds_ \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            tds_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dtype locs_ tds_) (update_clock (\\<lambda>_. 0) s', r))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjnt (type_defs_to_new_tdecs mn_ tds_)\n              (defined_types s_) \\<longrightarrow>\n             check_dup_ctors tds_ \\<longrightarrow>\n             \\<not> allDistinct (map (\\<lambda>(tvs, tn, ctors). tn) tds_);\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. c) s_)\n                          (Dtype locs_ tds_)\n                          (update_clock (\\<lambda>_. 0) s_,\n                           Rerr (Rabort Rtype_error))", "by rule+ auto"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dtype locs_ tds_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (3 subgoals):\n 1. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dtabbrev"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dtabbrev locs tvs tn t0)\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s_, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dtabbrev locs_ tvs_ tn_ t0_)\n            (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ck_ \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n        (Dtabbrev locs_ tvs_ tn_ t0_)\n        (update_clock (\\<lambda>_. 0) s_,\n         Rval (make_sem_env nsEmpty nsEmpty))", "by rule+"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s_, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dtabbrev locs_ tvs_ tn_ t0_)\n          (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (2 subgoals):\n 1. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dexn1"], ["proof (state)\nthis:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (2 subgoals):\n 1. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (update_defined_types\n            (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n            s,\n           Rval\n            (make_sem_env nsEmpty\n              (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n          (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_", "show ?case"], ["proof (prove)\nusing this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (update_defined_types\n         (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n         s_,\n        Rval\n         (make_sem_env nsEmpty\n           (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n       (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. c) s_)\n                          (Dexn locs_ cn_ ts_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                insert (TypeExn (mk_id mn_ cn_))\n                                 (defined_types s_))\n                            (update_clock (\\<lambda>_. 0) s_),\n                           Rval\n                            (make_sem_env nsEmpty\n                              (nsSing cn_\n                                (length ts_, TypeExn (mk_id mn_ cn_)))))", "apply (rule exI[where x=0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. 0) s_)\n                       (Dexn locs_ cn_ ts_)\n                       (update_defined_types\n                         (\\<lambda>_.\n                             insert (TypeExn (mk_id mn_ cn_))\n                              (defined_types s_))\n                         (update_clock (\\<lambda>_. 0) s_),\n                        Rval\n                         (make_sem_env nsEmpty\n                           (nsSing cn_\n                             (length ts_, TypeExn (mk_id mn_ cn_)))))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. 0) s_)\n                       (Dexn locs_ cn_ ts_)\n                       (update_defined_types\n                         (\\<lambda>_.\n                             insert (TypeExn (mk_id mn_ cn_))\n                              (defined_types s_))\n                         (update_clock (\\<lambda>_. 0) s_),\n                        Rval\n                         (make_sem_env nsEmpty\n                           (nsSing cn_\n                             (length ts_, TypeExn (mk_id mn_ cn_)))))", "by (metis Un_insert_left sup_bot.left_neutral)"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (update_defined_types\n       (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_) s_,\n      Rval\n       (make_sem_env nsEmpty\n         (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n     (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (1 subgoal):\n 1. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "case dexn2"], ["proof (state)\nthis:\n  TypeExn (mk_id mn_ cn_) \\<in> defined_types s_\n\ngoal (1 subgoal):\n 1. \\<And>ck mn env cn ts s locs.\n       TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n       \\<forall>s' r.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_dec True mn env (update_clock (\\<lambda>_. c) s)\n               (Dexn locs cn ts) (update_clock (\\<lambda>_. 0) s', r))", "then"], ["proof (chain)\npicking this:\n  TypeExn (mk_id mn_ cn_) \\<in> defined_types s_", "show ?case"], ["proof (prove)\nusing this:\n  TypeExn (mk_id mn_ cn_) \\<in> defined_types s_\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n            (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. 0) s', r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<in> defined_types s_;\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. c) s_)\n                          (Dexn locs_ cn_ ts_)\n                          (update_clock (\\<lambda>_. 0) s_,\n                           Rerr (Rabort Rtype_error))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<in> defined_types s_;\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec True mn_ env_\n                       (update_clock (\\<lambda>_. ?c4) s_)\n                       (Dexn locs_ cn_ ts_)\n                       (update_clock (\\<lambda>_. 0) s_,\n                        Rerr (Rabort Rtype_error))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<in> defined_types s_;\n     \\<not> ck_\\<rbrakk>\n    \\<Longrightarrow> TypeExn (mk_id mn_ cn_)\n                      \\<in> defined_types (update_clock (\\<lambda>_. 0) s_)", "by auto"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s_, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s_)\n          (Dexn locs_ cn_ ts_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dec_add_to_counter:\n  \"evaluate_dec ck mn env s d res \\<Longrightarrow>\n   \\<forall>s' r extra. res = (s',r) \\<and> ck = True \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec True mn env (s (| clock := (clock   s) + extra |)) d ((s' (| clock := (clock   s') + extra |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ck mn env s d res \\<Longrightarrow>\n    \\<forall>s' r extra.\n       res = (s', r) \\<and>\n       ck = True \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_dec True mn env\n        (update_clock (\\<lambda>_. clock s + extra) s) d\n        (update_clock (\\<lambda>_. clock s' + extra) s', r)", "proof (induction rule:evaluate_dec.inducts)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r extra.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r extra.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)\nA total of 12 subgoals...", "case dtype1"], ["proof (state)\nthis:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (12 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s new_tdecs locs.\n       check_dup_ctors tds \\<and>\n       new_tdecs = type_defs_to_new_tdecs mn tds \\<and>\n       disjnt new_tdecs (defined_types s) \\<and>\n       allDistinct\n        (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n          tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (update_defined_types\n            (\\<lambda>_. new_tdecs \\<union> defined_types s) s,\n           Rval (make_sem_env nsEmpty (build_tdefs mn tds))) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env tvs tn t0 s locs.\n        \\<forall>s' r extra.\n           (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s)\n            (Dtabbrev locs tvs tn t0)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)", "show ?case"], ["proof (prove)\nusing this:\n  check_dup_ctors tds_ \\<and>\n  new_tdecs_ = type_defs_to_new_tdecs mn_ tds_ \\<and>\n  disjnt new_tdecs_ (defined_types s_) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) tds_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r extra.\n       (update_defined_types\n         (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n        Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n       (s', r) \\<and>\n       ck_ = True \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_dec True mn_ env_\n        (update_clock (\\<lambda>_. clock s_ + extra) s_) (Dtype locs_ tds_)\n        (update_clock (\\<lambda>_. clock s' + extra) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>extra.\n       \\<lbrakk>check_dup_ctors tds_;\n        new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n        disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n        allDistinct\n         (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n           tds_);\n        ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. clock s_ + extra) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. clock s_ + extra)\n                              s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<And>extra.\n       \\<lbrakk>check_dup_ctors tds_;\n        new_tdecs_ = type_defs_to_new_tdecs mn_ tds_;\n        disjnt (type_defs_to_new_tdecs mn_ tds_) (defined_types s_);\n        allDistinct\n         (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n           tds_);\n        ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. clock s_ + extra) s_)\n                          (Dtype locs_ tds_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                type_defs_to_new_tdecs mn_ tds_ \\<union>\n                                defined_types s_)\n                            (update_clock (\\<lambda>_. clock s_ + extra)\n                              s_),\n                           Rval\n                            (make_sem_env nsEmpty (build_tdefs mn_ tds_)))", "by (metis)"], ["proof (state)\nthis:\n  \\<forall>s' r extra.\n     (update_defined_types\n       (\\<lambda>_. new_tdecs_ \\<union> defined_types s_) s_,\n      Rval (make_sem_env nsEmpty (build_tdefs mn_ tds_))) =\n     (s', r) \\<and>\n     ck_ = True \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec True mn_ env_\n      (update_clock (\\<lambda>_. clock s_ + extra) s_) (Dtype locs_ tds_)\n      (update_clock (\\<lambda>_. clock s' + extra) s', r)\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r extra.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s) (Dexn locs cn ts)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r extra.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s) (Dexn locs cn ts)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)\nA total of 11 subgoals...", "case dexn1"], ["proof (state)\nthis:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (11 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<notin> defined_types s \\<Longrightarrow>\n        \\<forall>s' r extra.\n           (update_defined_types\n             (\\<lambda>_. {TypeExn (mk_id mn cn)} \\<union> defined_types s)\n             s,\n            Rval\n             (make_sem_env nsEmpty\n               (nsSing cn (length ts, TypeExn (mk_id mn cn))))) =\n           (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s) (Dexn locs cn ts)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_", "show ?case"], ["proof (prove)\nusing this:\n  TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_\n\ngoal (1 subgoal):\n 1. \\<forall>s' r extra.\n       (update_defined_types\n         (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_)\n         s_,\n        Rval\n         (make_sem_env nsEmpty\n           (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n       (s', r) \\<and>\n       ck_ = True \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_dec True mn_ env_\n        (update_clock (\\<lambda>_. clock s_ + extra) s_)\n        (Dexn locs_ cn_ ts_)\n        (update_clock (\\<lambda>_. clock s' + extra) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>extra.\n       \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n        ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. clock s_ + extra) s_)\n                          (Dexn locs_ cn_ ts_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                insert (TypeExn (mk_id mn_ cn_))\n                                 (defined_types s_))\n                            (update_clock (\\<lambda>_. clock s_ + extra)\n                              s_),\n                           Rval\n                            (make_sem_env nsEmpty\n                              (nsSing cn_\n                                (length ts_, TypeExn (mk_id mn_ cn_)))))", "using evaluate_dec.intros state.record_simps(4)"], ["proof (prove)\nusing this:\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = Match ?env' \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rval (make_sem_env (alist_to_ns ?env') nsEmpty))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] = No_match \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rraise Bindv))\n  evaluate ?ck ?env ?s1.0 ?e (?s2.0, Rval ?v1.0) \\<and>\n  allDistinct (pat_bindings ?p []) \\<and>\n  pmatch (c ?env) (refs ?s2.0) ?p ?v1.0 [] =\n  Match_type_error \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s1.0 (Dlet ?locs ?p ?e)\n   (?s2.0, Rerr (Rabort Rtype_error))\n  \\<not> allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate ?ck ?env ?s ?e (?s', Rerr ?err) \\<and>\n  allDistinct (pat_bindings ?p []) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dlet ?locs ?p ?e) (?s', Rerr ?err)\n  allDistinct\n   (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n     ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rval (make_sem_env (build_rec_env ?funs ?env nsEmpty) nsEmpty))\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n            ?funs) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dletrec ?locs ?funs)\n   (?s, Rerr (Rabort Rtype_error))\n  check_dup_ctors ?tds \\<and>\n  ?new_tdecs = type_defs_to_new_tdecs ?mn ?tds \\<and>\n  disjnt ?new_tdecs (defined_types ?s) \\<and>\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (update_defined_types (\\<lambda>_. ?new_tdecs \\<union> defined_types ?s)\n     ?s,\n    Rval (make_sem_env nsEmpty (build_tdefs ?mn ?tds)))\n  \\<not> check_dup_ctors ?tds \\<or>\n  \\<not> disjnt (type_defs_to_new_tdecs ?mn ?tds) (defined_types ?s) \\<or>\n  \\<not> allDistinct\n          (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n            ?tds) \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dtype ?locs ?tds)\n   (?s, Rerr (Rabort Rtype_error))\n  evaluate_dec ?ck ?mn ?env ?s (Dtabbrev ?locs ?tvs ?tn ?t0.0)\n   (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  TypeExn (mk_id ?mn ?cn) \\<notin> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (update_defined_types\n     (\\<lambda>_. {TypeExn (mk_id ?mn ?cn)} \\<union> defined_types ?s) ?s,\n    Rval\n     (make_sem_env nsEmpty\n       (nsSing ?cn (length ?ts, TypeExn (mk_id ?mn ?cn)))))\n  TypeExn (mk_id ?mn ?cn) \\<in> defined_types ?s \\<Longrightarrow>\n  evaluate_dec ?ck ?mn ?env ?s (Dexn ?locs ?cn ?ts)\n   (?s, Rerr (Rabort Rtype_error))\n  defined_types (update_clock ?f ?x) = defined_types ?x\n\ngoal (1 subgoal):\n 1. \\<And>extra.\n       \\<lbrakk>TypeExn (mk_id mn_ cn_) \\<notin> defined_types s_;\n        ck_\\<rbrakk>\n       \\<Longrightarrow> evaluate_dec True mn_ env_\n                          (update_clock (\\<lambda>_. clock s_ + extra) s_)\n                          (Dexn locs_ cn_ ts_)\n                          (update_defined_types\n                            (\\<lambda>_.\n                                insert (TypeExn (mk_id mn_ cn_))\n                                 (defined_types s_))\n                            (update_clock (\\<lambda>_. clock s_ + extra)\n                              s_),\n                           Rval\n                            (make_sem_env nsEmpty\n                              (nsSing cn_\n                                (length ts_, TypeExn (mk_id mn_ cn_)))))", "by (metis Un_insert_left sup_bot.left_neutral)"], ["proof (state)\nthis:\n  \\<forall>s' r extra.\n     (update_defined_types\n       (\\<lambda>_. {TypeExn (mk_id mn_ cn_)} \\<union> defined_types s_) s_,\n      Rval\n       (make_sem_env nsEmpty\n         (nsSing cn_ (length ts_, TypeExn (mk_id mn_ cn_))))) =\n     (s', r) \\<and>\n     ck_ = True \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec True mn_ env_\n      (update_clock (\\<lambda>_. clock s_ + extra) s_) (Dexn locs_ cn_ ts_)\n      (update_clock (\\<lambda>_. clock s' + extra) s', r)\n\ngoal (10 subgoals):\n 1. \\<And>ck mn env p e v1 env' s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match env' \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rval (make_sem_env (alist_to_ns env') nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = No_match \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rraise Bindv)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn env p e v1 s1 s2 locs.\n       evaluate ck env s1 e (s2, Rval v1) \\<and>\n       allDistinct (pat_bindings p []) \\<and>\n       pmatch (c env) (refs s2) p v1 [] = Match_type_error \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 4. \\<And>ck mn env p e s locs.\n       \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 5. \\<And>ck mn env p e err s s' locs.\n       evaluate ck env s e (s', Rerr err) \\<and>\n       allDistinct (pat_bindings p []) \\<Longrightarrow>\n       \\<forall>s'a r extra.\n          (s', Rerr err) = (s'a, r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dlet locs p e)\n           (update_clock (\\<lambda>_. clock s'a + extra) s'a, r)\n 6. \\<And>ck mn env funs s locs.\n       allDistinct\n        (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n          funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rval\n               (make_sem_env (build_rec_env funs env nsEmpty) nsEmpty)) =\n          (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 7. \\<And>ck mn env funs s locs.\n       \\<not> allDistinct\n               (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n                 funs) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dletrec locs funs)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 8. \\<And>ck mn env tds s locs.\n       \\<not> check_dup_ctors tds \\<or>\n       \\<not> disjnt (type_defs_to_new_tdecs mn tds) (defined_types s) \\<or>\n       \\<not> allDistinct\n               (map (\\<lambda>x.\n                        case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n                 tds) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) (Dtype locs tds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 9. \\<And>ck mn env tvs tn t0 s locs.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_dec True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s)\n           (Dtabbrev locs tvs tn t0)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 10. \\<And>ck mn env cn ts s locs.\n        TypeExn (mk_id mn cn) \\<in> defined_types s \\<Longrightarrow>\n        \\<forall>s' r extra.\n           (s, Rerr (Rabort Rtype_error)) = (s', r) \\<and>\n           ck = True \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec True mn env\n            (update_clock (\\<lambda>_. clock s + extra) s) (Dexn locs cn ts)\n            (update_clock (\\<lambda>_. clock s' + extra) s', r)", "qed (force intro:evaluate_dec.intros simp add:add_to_counter(3))+"], ["", "lemma dec_unclocked_unchanged:\n  \"evaluate_dec ck mn env s d r \\<Longrightarrow> ck = False \\<Longrightarrow> (snd r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   (fst r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_dec ck mn env s d r; ck = False\\<rbrakk>\n    \\<Longrightarrow> snd r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                      clock s = clock (fst r)", "by (induction rule: evaluate_dec.inducts)\n     (auto simp: big_unclocked_notimeout big_clocked_unclocked_equiv)"], ["", "lemma dec_clocked_unclocked_equiv:\n  \"evaluate_dec False mn env s1 d (s2,r) =\n  (\\<exists>c. evaluate_dec True mn env (s1 (| clock := c |)) d ((s2 (| clock := 0 |)),r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s1) = (clock   s2))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s1 d (s2, r) =\n    (\\<exists>c.\n        evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n         (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. evaluate_dec False mn env s1 d (s2, r) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n 2. \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s1 = clock s2 \\<Longrightarrow>\n    evaluate_dec False mn env s1 d (s2, r)", "assume ?lhs"], ["proof (state)\nthis:\n  evaluate_dec False mn env s1 d (s2, r)\n\ngoal (2 subgoals):\n 1. evaluate_dec False mn env s1 d (s2, r) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n 2. \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s1 = clock s2 \\<Longrightarrow>\n    evaluate_dec False mn env s1 d (s2, r)", "then"], ["proof (chain)\npicking this:\n  evaluate_dec False mn env s1 d (s2, r)", "show ?rhs"], ["proof (prove)\nusing this:\n  evaluate_dec False mn env s1 d (s2, r)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2", "by (auto dest:dec_unclocked_unchanged dec_add_clock)"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n      (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s1 = clock s2 \\<Longrightarrow>\n    evaluate_dec False mn env s1 d (s2, r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s1 = clock s2 \\<Longrightarrow>\n    evaluate_dec False mn env s1 d (s2, r)", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n      (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n        (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s1 = clock s2 \\<Longrightarrow>\n    evaluate_dec False mn env s1 d (s2, r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n      (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n      (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s1 d (s2, r)", "using dec_unclocked_ignore"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n      (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r count.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec False ?mn ?env (update_clock (\\<lambda>_. count) ?s) ?d\n      (update_clock (\\<lambda>_. count) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s1 d (s2, r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n                 (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s1 = clock s2;\n     \\<And>ck mn env s d res.\n        evaluate_dec ck mn env s d res \\<Longrightarrow>\n        \\<forall>s' r count.\n           res = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s) d\n            (update_clock (\\<lambda>_. count) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec False mn env s1 d (s2, r)", "(* sledgehammer proof *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n                 (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s1 = clock s2;\n     \\<And>ck mn env s d res.\n        evaluate_dec ck mn env s d res \\<Longrightarrow>\n        \\<forall>s' r count.\n           res = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s) d\n            (update_clock (\\<lambda>_. count) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec False mn env s1 d (s2, r)", "obtain nn :: nat where\n      f1: \"evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d (update_clock (\\<lambda>n. 0) s2, r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n         (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        clock s1 = clock s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<exists>c. evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d (update_clock (\\<lambda>_. 0) s2, r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n      (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n         (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        clock s1 = clock s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n   (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n                 (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s1 = clock s2;\n     \\<And>ck mn env s d res.\n        evaluate_dec ck mn env s d res \\<Longrightarrow>\n        \\<forall>s' r count.\n           res = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s) d\n            (update_clock (\\<lambda>_. count) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec False mn env s1 d (s2, r)", "then"], ["proof (chain)\npicking this:\n  evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n   (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2", "have \"\\<forall>n. evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d (update_clock (\\<lambda>na. n) s2, r)\""], ["proof (prove)\nusing this:\n  evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n   (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d\n        (update_clock (\\<lambda>na. n) s2, r)", "using dec_unclocked_ignore"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n   (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r count.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec False ?mn ?env (update_clock (\\<lambda>_. count) ?s) ?d\n      (update_clock (\\<lambda>_. count) s', r)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d\n        (update_clock (\\<lambda>na. n) s2, r)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>n.\n     evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d\n      (update_clock (\\<lambda>na. n) s2, r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_dec True mn env (update_clock (\\<lambda>_. c) s1) d\n                 (update_clock (\\<lambda>_. 0) s2, r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s1 = clock s2;\n     \\<And>ck mn env s d res.\n        evaluate_dec ck mn env s d res \\<Longrightarrow>\n        \\<forall>s' r count.\n           res = (s', r) \\<and>\n           r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_dec False mn env (update_clock (\\<lambda>_. count) s) d\n            (update_clock (\\<lambda>_. count) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_dec False mn env s1 d (s2, r)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d\n      (update_clock (\\<lambda>na. n) s2, r)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d\n      (update_clock (\\<lambda>na. n) s2, r)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s1 d (s2, r)", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     evaluate_dec False mn env (update_clock (\\<lambda>na. n) s1) d\n      (update_clock (\\<lambda>na. n) s2, r)\n  evaluate_dec True mn env (update_clock (\\<lambda>n. nn) s1) d\n   (update_clock (\\<lambda>n. 0) s2, r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s1 d (s2, r)", "by (metis (full_types) state.record_simps(7))"], ["proof (state)\nthis:\n  evaluate_dec False mn env s1 d (s2, r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_dec False mn env s1 d (s2, r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decs_add_clock:\n  \"evaluate_decs ck mn env s ds res \\<Longrightarrow>\n   \\<forall>s' r. res = (s',r) \\<and> ck = False \\<longrightarrow> (\\<exists>c. evaluate_decs True mn env (s (| clock := c |)) ds (s' (| clock := 0 |),r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env s ds res \\<Longrightarrow>\n    \\<forall>s' r.\n       res = (s', r) \\<and> ck = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) ds\n            (update_clock (\\<lambda>_. 0) s', r))", "proof (induction rule:evaluate_decs.inducts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) []\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr e) = (s', r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra.\n           (s3, r) = (s', ra) \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_decs True mn (extend_dec_env new_env env)\n                (update_clock (\\<lambda>_. c) s2) ds\n                (update_clock (\\<lambda>_. 0) s', ra))) \\<Longrightarrow>\n       \\<forall>s' ra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', ra))", "case cons1"], ["proof (state)\nthis:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rerr e_)\n\ngoal (3 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) []\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>s' r.\n          (s2, Rerr e) = (s', r) \\<and> ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', r))\n 3. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra.\n           (s3, r) = (s', ra) \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_decs True mn (extend_dec_env new_env env)\n                (update_clock (\\<lambda>_. c) s2) ds\n                (update_clock (\\<lambda>_. 0) s', ra))) \\<Longrightarrow>\n       \\<forall>s' ra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', ra))", "then"], ["proof (chain)\npicking this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rerr e_)", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rerr e_)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s2_, Rerr e_) = (s', r) \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_decs True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n            (d_ # ds_) (update_clock (\\<lambda>_. 0) s', r))", "using dec_add_clock evaluate_decs.cons1"], ["proof (prove)\nusing this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rerr e_)\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r.\n     ?res = (s', r) \\<and> ?ck = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True ?mn ?env (update_clock (\\<lambda>_. c) ?s) ?d\n          (update_clock (\\<lambda>_. 0) s', r))\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rerr ?e) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds) (?s2.0, Rerr ?e)\n\ngoal (1 subgoal):\n 1. \\<forall>s' r.\n       (s2_, Rerr e_) = (s', r) \\<and> ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_decs True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n            (d_ # ds_) (update_clock (\\<lambda>_. 0) s', r))", "by blast"], ["proof (state)\nthis:\n  \\<forall>s' r.\n     (s2_, Rerr e_) = (s', r) \\<and> ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_decs True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n          (d_ # ds_) (update_clock (\\<lambda>_. 0) s', r))\n\ngoal (2 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) []\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra.\n           (s3, r) = (s', ra) \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_decs True mn (extend_dec_env new_env env)\n                (update_clock (\\<lambda>_. c) s2) ds\n                (update_clock (\\<lambda>_. 0) s', ra))) \\<Longrightarrow>\n       \\<forall>s' ra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', ra))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) []\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra.\n           (s3, r) = (s', ra) \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_decs True mn (extend_dec_env new_env env)\n                (update_clock (\\<lambda>_. c) s2) ds\n                (update_clock (\\<lambda>_. 0) s', ra))) \\<Longrightarrow>\n       \\<forall>s' ra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', ra))", "case cons2"], ["proof (state)\nthis:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra.\n      (s3_, r_) = (s', ra) \\<and> ck_ = False \\<longrightarrow>\n      (\\<exists>c.\n          evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n           (update_clock (\\<lambda>_. c) s2_) ds_\n           (update_clock (\\<lambda>_. 0) s', ra)))\n\ngoal (2 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) []\n               (update_clock (\\<lambda>_. 0) s', r))\n 2. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra.\n           (s3, r) = (s', ra) \\<and> ck = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_decs True mn (extend_dec_env new_env env)\n                (update_clock (\\<lambda>_. c) s2) ds\n                (update_clock (\\<lambda>_. 0) s', ra))) \\<Longrightarrow>\n       \\<forall>s' ra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s1)\n               (d # ds) (update_clock (\\<lambda>_. 0) s', ra))", "then"], ["proof (chain)\npicking this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra.\n      (s3_, r_) = (s', ra) \\<and> ck_ = False \\<longrightarrow>\n      (\\<exists>c.\n          evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n           (update_clock (\\<lambda>_. c) s2_) ds_\n           (update_clock (\\<lambda>_. 0) s', ra)))", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra.\n      (s3_, r_) = (s', ra) \\<and> ck_ = False \\<longrightarrow>\n      (\\<exists>c.\n          evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n           (update_clock (\\<lambda>_. c) s2_) ds_\n           (update_clock (\\<lambda>_. 0) s', ra)))\n\ngoal (1 subgoal):\n 1. \\<forall>s' ra.\n       (s3_, combine_dec_result new_env_ r_) = (s', ra) \\<and>\n       ck_ = False \\<longrightarrow>\n       (\\<exists>c.\n           evaluate_decs True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n            (d_ # ds_) (update_clock (\\<lambda>_. 0) s', ra))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_dec False mn_ env_ s1_ d_ (s2_, Rval new_env_);\n        evaluate_decs False mn_ (extend_dec_env new_env_ env_) s2_ ds_\n         (s3_, r_);\n        \\<not> ck_;\n        evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) ds_\n         (update_clock (\\<lambda>_. 0) s3_, r_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_decs True mn_ env_\n                             (update_clock (\\<lambda>_. c) s1_) (d_ # ds_)\n                             (update_clock (\\<lambda>_. 0) s3_,\n                              combine_dec_result new_env_ r_)", "apply (drule dec_add_clock)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_decs False mn_ (extend_dec_env new_env_ env_) s2_\n                 ds_ (s3_, r_);\n        \\<not> ck_;\n        evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) ds_\n         (update_clock (\\<lambda>_. 0) s3_, r_);\n        \\<forall>s' r.\n           (s2_, Rval new_env_) = (s', r) \\<and>\n           False = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n                d_ (update_clock (\\<lambda>_. 0) s', r))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_decs True mn_ env_\n                             (update_clock (\\<lambda>_. c) s1_) (d_ # ds_)\n                             (update_clock (\\<lambda>_. 0) s3_,\n                              combine_dec_result new_env_ r_)", "using dec_add_to_counter[rule_format] evaluate_decs.cons2"], ["proof (prove)\nusing this:\n  \\<lbrakk>evaluate_dec ?ck ?mn ?env ?s ?d ?res;\n   ?res = (?s', ?r) \\<and>\n   ?ck = True \\<and> ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_dec True ?mn ?env\n                     (update_clock (\\<lambda>_. clock ?s + ?extra) ?s) ?d\n                     (update_clock (\\<lambda>_. clock ?s' + ?extra) ?s', ?r)\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_decs False mn_ (extend_dec_env new_env_ env_) s2_\n                 ds_ (s3_, r_);\n        \\<not> ck_;\n        evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) ds_\n         (update_clock (\\<lambda>_. 0) s3_, r_);\n        \\<forall>s' r.\n           (s2_, Rval new_env_) = (s', r) \\<and>\n           False = False \\<longrightarrow>\n           (\\<exists>c.\n               evaluate_dec True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n                d_ (update_clock (\\<lambda>_. 0) s', r))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_decs True mn_ env_\n                             (update_clock (\\<lambda>_. c) s1_) (d_ # ds_)\n                             (update_clock (\\<lambda>_. 0) s3_,\n                              combine_dec_result new_env_ r_)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>s' ra.\n     (s3_, combine_dec_result new_env_ r_) = (s', ra) \\<and>\n     ck_ = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_decs True mn_ env_ (update_clock (\\<lambda>_. c) s1_)\n          (d_ # ds_) (update_clock (\\<lambda>_. 0) s', ra))\n\ngoal (1 subgoal):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = False \\<longrightarrow>\n          (\\<exists>c.\n              evaluate_decs True mn env (update_clock (\\<lambda>_. c) s) []\n               (update_clock (\\<lambda>_. 0) s', r))", "qed (auto intro:evaluate_decs.intros)"], ["", "lemma decs_evaluate_not_timeout:\n  \"evaluate_decs ck mn env s ds r \\<Longrightarrow>\n   \\<forall>s' r'. ck = False \\<and> r = (s',r') \\<longrightarrow> r' \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env s ds r \\<Longrightarrow>\n    \\<forall>s' r'.\n       ck = False \\<and> r = (s', r') \\<longrightarrow>\n       r' \\<noteq> Rerr (Rabort Rtimeout_error)", "by (induction rule:evaluate_decs.inducts)\n     (case_tac r;fastforce dest:dec_evaluate_not_timeout)+"], ["", "lemma decs_unclocked_unchanged:\n  \"evaluate_decs ck mn env s ds r \\<Longrightarrow>\n   \\<forall>s' r'. ck = False \\<and> r = (s',r') \\<longrightarrow> r' \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env s ds r \\<Longrightarrow>\n    \\<forall>s' r'.\n       ck = False \\<and> r = (s', r') \\<longrightarrow>\n       r' \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "by (induction rule:evaluate_decs.inducts)\n     (case_tac r;fastforce simp add:dec_unclocked_unchanged dest:dec_evaluate_not_timeout)+"], ["", "lemma decs_unclocked_ignore:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow> \\<forall>s' r count. res = (s',r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_decs False mn env (s (| clock := count |)) d ((s' (| clock := count |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env s d res \\<Longrightarrow>\n    \\<forall>s' r count.\n       res = (s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_decs False mn env (update_clock (\\<lambda>_. count) s) d\n        (update_clock (\\<lambda>_. count) s', r)", "by (induction rule:evaluate_decs.inducts)\n     (auto intro!:evaluate_decs.intros simp add:dec_unclocked_ignore)"], ["", "private"], ["", "lemma decs_unclocked_2:\n  assumes \"evaluate_decs False mn env (s (| clock := count1 |)) ds ((s' (| clock := count1 |)),r)\"\n  shows \"evaluate_decs False mn env (s (| clock := count2 |)) ds ((s' (| clock := count2 |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs False mn env (update_clock (\\<lambda>_. count2) s) ds\n     (update_clock (\\<lambda>_. count2) s', r)", "using decs_unclocked_ignore[rule_format] assms decs_evaluate_not_timeout"], ["proof (prove)\nusing this:\n  \\<lbrakk>evaluate_decs ?ck ?mn ?env ?s ?d ?res;\n   ?res = (?s', ?r) \\<and> ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_decs False ?mn ?env\n                     (update_clock (\\<lambda>_. ?count) ?s) ?d\n                     (update_clock (\\<lambda>_. ?count) ?s', ?r)\n  evaluate_decs False mn env (update_clock (\\<lambda>_. count1) s) ds\n   (update_clock (\\<lambda>_. count1) s', r)\n  evaluate_decs ?ck ?mn ?env ?s ?ds ?r \\<Longrightarrow>\n  \\<forall>s' r'.\n     ?ck = False \\<and> ?r = (s', r') \\<longrightarrow>\n     r' \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn env (update_clock (\\<lambda>_. count2) s) ds\n     (update_clock (\\<lambda>_. count2) s', r)", "by fastforce"], ["", "lemma decs_unclocked:\n  \"(evaluate_decs False mn env s ds (s',r) \\<longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s')) \\<and>\n   (evaluate_decs False mn env (s (| clock := count1 |)) ds ((s' (| clock := count1 |)),r) =\n   evaluate_decs False mn env (s (| clock := count2 |)) ds ((s' (| clock := count2 |)),r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_decs False mn env s ds (s', r) \\<longrightarrow>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n     clock s = clock s') \\<and>\n    evaluate_decs False mn env (update_clock (\\<lambda>_. count1) s) ds\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_decs False mn env (update_clock (\\<lambda>_. count2) s) ds\n     (update_clock (\\<lambda>_. count2) s', r)", "by (auto simp add:decs_unclocked_unchanged decs_unclocked_2)"], ["", "lemma not_evaluate_decs_timeout:\n  assumes \"\\<forall>r. \\<not>evaluate_decs False mn env s ds r\"\n  shows \"\\<exists>r. evaluate_decs True mn env s ds r \\<and> (snd r) = Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s ds r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_decs False mn env s ds r\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s ds r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof (induction ds arbitrary:mn env s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>mn env s.\n       \\<forall>r.\n          \\<not> evaluate_decs False mn env s [] r \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_decs True mn env s [] r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>a ds mn env s.\n       \\<lbrakk>\\<And>mn env s.\n                   \\<forall>r.\n                      \\<not> evaluate_decs False mn env s ds\n                              r \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_decs True mn env s ds r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>r. \\<not> evaluate_decs False mn env s (a # ds) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (a # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>r. \\<not> evaluate_decs False mn env s [] r\n\ngoal (2 subgoals):\n 1. \\<And>mn env s.\n       \\<forall>r.\n          \\<not> evaluate_decs False mn env s [] r \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_decs True mn env s [] r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>a ds mn env s.\n       \\<lbrakk>\\<And>mn env s.\n                   \\<forall>r.\n                      \\<not> evaluate_decs False mn env s ds\n                              r \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_decs True mn env s ds r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>r. \\<not> evaluate_decs False mn env s (a # ds) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (a # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<forall>r. \\<not> evaluate_decs False mn env s [] r", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_decs False mn env s [] r\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s [] r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using assms evaluate_decs.intros"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> evaluate_decs False mn env s [] r\n  \\<forall>r. \\<not> evaluate_decs False mn env s ds r\n  evaluate_decs ?ck ?mn ?env ?s [] (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rerr ?e) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds) (?s2.0, Rerr ?e)\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s [] r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_decs True mn env s [] r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       \\<lbrakk>\\<And>mn env s.\n                   \\<forall>r.\n                      \\<not> evaluate_decs False mn env s ds\n                              r \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_decs True mn env s ds r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>r. \\<not> evaluate_decs False mn env s (a # ds) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (a # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       \\<lbrakk>\\<And>mn env s.\n                   \\<forall>r.\n                      \\<not> evaluate_decs False mn env s ds\n                              r \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_decs True mn env s ds r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>r. \\<not> evaluate_decs False mn env s (a # ds) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (a # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case (Cons d ds)"], ["proof (state)\nthis:\n  \\<forall>r. \\<not> evaluate_decs False ?mn ?env ?s ds r \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_decs True ?mn ?env ?s ds r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>r. \\<not> evaluate_decs False mn env s (d # ds) r\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       \\<lbrakk>\\<And>mn env s.\n                   \\<forall>r.\n                      \\<not> evaluate_decs False mn env s ds\n                              r \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_decs True mn env s ds r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>r. \\<not> evaluate_decs False mn env s (a # ds) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (a # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "obtain s' r where d:\"evaluate_dec True mn env s d (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_dec True mn env s d (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dec_clocked_total"], ["proof (prove)\nusing this:\n  \\<exists>res. evaluate_dec True ?mn ?env ?s ?d res\n\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_dec True mn env s d (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  evaluate_dec True mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       \\<lbrakk>\\<And>mn env s.\n                   \\<forall>r.\n                      \\<not> evaluate_decs False mn env s ds\n                              r \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_decs True mn env s ds r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>r. \\<not> evaluate_decs False mn env s (a # ds) r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (a # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  evaluate_dec True mn env s d (s', r)", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s (d # ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case (Rval new_env)"], ["proof (state)\nthis:\n  r = Rval new_env\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "have \"\\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)\" for s3 r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env) s' ds\n     (s3, r) \\<Longrightarrow>\n    False", "assume \"evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)\""], ["proof (state)\nthis:\n  evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env) s' ds\n     (s3, r) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)", "have \"evaluate_decs False mn (extend_dec_env new_env env) (s' \\<lparr>clock := (clock s)\\<rparr>) ds ((s3 \\<lparr>clock := (clock s)\\<rparr>), r)\""], ["proof (prove)\nusing this:\n  evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env)\n     (update_clock (\\<lambda>_. clock s) s') ds\n     (update_clock (\\<lambda>_. clock s) s3, r)", "using decs_unclocked decs_unclocked_ignore"], ["proof (prove)\nusing this:\n  evaluate_decs False mn (extend_dec_env new_env env) s' ds (s3, r)\n  (evaluate_decs False ?mn ?env ?s ?ds (?s', ?r) \\<longrightarrow>\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock ?s = clock ?s') \\<and>\n  evaluate_decs False ?mn ?env (update_clock (\\<lambda>_. ?count1.0) ?s) ?ds\n   (update_clock (\\<lambda>_. ?count1.0) ?s', ?r) =\n  evaluate_decs False ?mn ?env (update_clock (\\<lambda>_. ?count2.0) ?s) ?ds\n   (update_clock (\\<lambda>_. ?count2.0) ?s', ?r)\n  evaluate_decs ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r count.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_decs False ?mn ?env (update_clock (\\<lambda>_. count) ?s) ?d\n      (update_clock (\\<lambda>_. count) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env)\n     (update_clock (\\<lambda>_. clock s) s') ds\n     (update_clock (\\<lambda>_. clock s) s3, r)", "by fastforce"], ["proof (state)\nthis:\n  evaluate_decs False mn (extend_dec_env new_env env)\n   (update_clock (\\<lambda>_. clock s) s') ds\n   (update_clock (\\<lambda>_. clock s) s3, r)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env) s' ds\n     (s3, r) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  evaluate_decs False mn (extend_dec_env new_env env)\n   (update_clock (\\<lambda>_. clock s) s') ds\n   (update_clock (\\<lambda>_. clock s) s3, r)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env) s' ds\n     (s3, r) \\<Longrightarrow>\n    False", "from d"], ["proof (chain)\npicking this:\n  evaluate_dec True mn env s d (s', r__)", "have \"evaluate_dec False mn env s d ((s' \\<lparr>clock := (clock s)\\<rparr>), Rval new_env)\""], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r__)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s d\n     (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "using dec_unclocked_ignore"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r__)\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r count.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec False ?mn ?env (update_clock (\\<lambda>_. count) ?s) ?d\n      (update_clock (\\<lambda>_. count) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s d\n     (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "unfolding Rval"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', Rval new_env)\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r count.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec False ?mn ?env (update_clock (\\<lambda>_. count) ?s) ?d\n      (update_clock (\\<lambda>_. count) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_dec False mn env s d\n     (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "by (metis (full_types) result.distinct(1) state.record_simps(7))"], ["proof (state)\nthis:\n  evaluate_dec False mn env s d\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_decs False mn (extend_dec_env new_env env) s' ds\n     (s3, r) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  evaluate_decs False mn (extend_dec_env new_env env)\n   (update_clock (\\<lambda>_. clock s) s') ds\n   (update_clock (\\<lambda>_. clock s) s3, r)\n  evaluate_dec False mn env s d\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "show False"], ["proof (prove)\nusing this:\n  evaluate_decs False mn (extend_dec_env new_env env)\n   (update_clock (\\<lambda>_. clock s) s') ds\n   (update_clock (\\<lambda>_. clock s) s3, r)\n  evaluate_dec False mn env s d\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)\n\ngoal (1 subgoal):\n 1. False", "using evaluate_decs.cons2 Cons"], ["proof (prove)\nusing this:\n  evaluate_decs False mn (extend_dec_env new_env env)\n   (update_clock (\\<lambda>_. clock s) s') ds\n   (update_clock (\\<lambda>_. clock s) s3, r)\n  evaluate_dec False mn env s d\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  \\<forall>r. \\<not> evaluate_decs False ?mn ?env ?s ds r \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_decs True ?mn ?env ?s ds r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>r. \\<not> evaluate_decs False mn env s (d # ds) r\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds\n          (?s3.0, ?r)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds\n          (?s3.0, ?r)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds\n          (?s3.0, ?r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s (d # ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using Cons.IH[simplified] evaluate_decs.cons2 d"], ["proof (prove)\nusing this:\n  \\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds\n          (?s3.0, ?r)\n  \\<forall>a b.\n     \\<not> evaluate_decs False ?mn ?env ?s ds (a, b) \\<Longrightarrow>\n  \\<exists>a.\n     evaluate_decs True ?mn ?env ?s ds (a, Rerr (Rabort Rtimeout_error))\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  evaluate_dec True mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s (d # ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "unfolding Rval"], ["proof (prove)\nusing this:\n  \\<not> evaluate_decs False mn (extend_dec_env new_env env) s' ds\n          (?s3.0, ?r)\n  \\<forall>a b.\n     \\<not> evaluate_decs False ?mn ?env ?s ds (a, b) \\<Longrightarrow>\n  \\<exists>a.\n     evaluate_decs True ?mn ?env ?s ds (a, Rerr (Rabort Rtimeout_error))\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  evaluate_dec True mn env s d (s', Rval new_env)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s (d # ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by (metis combine_dec_result.simps(1) snd_conv)"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_decs True mn env s (d # ds) r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case (Rerr e)"], ["proof (state)\nthis:\n  r = Rerr e\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "have \"e = Rabort Rtimeout_error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = Rabort Rtimeout_error", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> Rabort Rtimeout_error \\<Longrightarrow> False", "assume \"e \\<noteq> Rabort Rtimeout_error\""], ["proof (state)\nthis:\n  e \\<noteq> Rabort Rtimeout_error\n\ngoal (1 subgoal):\n 1. e \\<noteq> Rabort Rtimeout_error \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e \\<noteq> Rabort Rtimeout_error", "obtain s' where \"evaluate_dec False mn env s d (s',r)\""], ["proof (prove)\nusing this:\n  e \\<noteq> Rabort Rtimeout_error\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        evaluate_dec False mn env s d (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dec_unclocked_ignore[rule_format, where count=\"clock s\"] d Rerr state.simps"], ["proof (prove)\nusing this:\n  e \\<noteq> Rabort Rtimeout_error\n  \\<lbrakk>evaluate_dec ?ck ?mn ?env ?s ?d ?res;\n   ?res = (?s', ?r) \\<and> ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_dec False ?mn ?env\n                     (update_clock (\\<lambda>_. clock s) ?s) ?d\n                     (update_clock (\\<lambda>_. clock s) ?s', ?r)\n  evaluate_dec True mn env s d (s', r)\n  r = Rerr e\n  (make_state ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0 =\n   make_state ?y1.0 ?y2.0 ?y3.0 ?y4.0 ?y5.0) =\n  (?x1.0 = ?y1.0 \\<and>\n   ?x2.0 = ?y2.0 \\<and>\n   ?x3.0 = ?y3.0 \\<and> ?x4.0 = ?y4.0 \\<and> ?x5.0 = ?y5.0)\n  (case make_state ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0 of\n   make_state x xa xb xc xd \\<Rightarrow> ?f x xa xb xc xd) =\n  ?f ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0\n  rec_state ?f (make_state ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) =\n  ?f ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        evaluate_dec False mn env s d (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  evaluate_dec False mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. e \\<noteq> Rabort Rtimeout_error \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  evaluate_dec False mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. False", "unfolding Rerr"], ["proof (prove)\nusing this:\n  evaluate_dec False mn env s d (s', Rerr e)\n\ngoal (1 subgoal):\n 1. False", "using Cons evaluate_decs.cons1"], ["proof (prove)\nusing this:\n  evaluate_dec False mn env s d (s', Rerr e)\n  \\<forall>r. \\<not> evaluate_decs False ?mn ?env ?s ds r \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_decs True ?mn ?env ?s ds r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>r. \\<not> evaluate_decs False mn env s (d # ds) r\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rerr ?e) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds) (?s2.0, Rerr ?e)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e = Rabort Rtimeout_error\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_dec True mn env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_decs True mn env s (d # ds) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  e = Rabort Rtimeout_error", "show ?thesis"], ["proof (prove)\nusing this:\n  e = Rabort Rtimeout_error\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s (d # ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using d evaluate_decs.cons1 Rerr"], ["proof (prove)\nusing this:\n  e = Rabort Rtimeout_error\n  evaluate_dec True mn env s d (s', r)\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rerr ?e) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds) (?s2.0, Rerr ?e)\n  r = Rerr e\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_decs True mn env s (d # ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_decs True mn env s (d # ds) r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_decs True mn env s (d # ds) r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decs_clocked_total: \"\\<exists>res. evaluate_decs True mn env s ds res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>res. evaluate_decs True mn env s ds res", "proof (induction ds arbitrary:mn env s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>mn env s. Ex (evaluate_decs True mn env s [])\n 2. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>mn env s. Ex (evaluate_decs True mn env s [])\n 2. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. evaluate_decs True mn env s [] a", "by (auto intro:evaluate_decs.intros)"], ["proof (state)\nthis:\n  \\<exists>a. evaluate_decs True mn env s [] a\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "case (Cons d ds)"], ["proof (state)\nthis:\n  \\<exists>a. evaluate_decs True ?mn ?env ?s ds a\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "obtain s' r where d:\"evaluate_dec True mn env s d (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_dec True mn env s d (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dec_clocked_total"], ["proof (prove)\nusing this:\n  \\<exists>res. evaluate_dec True ?mn ?env ?s ?d res\n\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_dec True mn env s d (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  evaluate_dec True mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "then"], ["proof (chain)\npicking this:\n  evaluate_dec True mn env s d (s', r)", "obtain s'' r' where ds:\"evaluate_decs True mn env s' ds (s'',r')\""], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r)\n\ngoal (1 subgoal):\n 1. (\\<And>s'' r'.\n        evaluate_decs True mn env s' ds (s'', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r)\n  \\<exists>a. evaluate_decs True ?mn ?env ?s ds a\n\ngoal (1 subgoal):\n 1. (\\<And>s'' r'.\n        evaluate_decs True mn env s' ds (s'', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  evaluate_decs True mn env s' ds (s'', r')\n\ngoal (1 subgoal):\n 1. \\<And>a ds mn env s.\n       (\\<And>mn env s.\n           Ex (evaluate_decs True mn env s ds)) \\<Longrightarrow>\n       Ex (evaluate_decs True mn env s (a # ds))", "from d ds"], ["proof (chain)\npicking this:\n  evaluate_dec True mn env s d (s', r)\n  evaluate_decs True mn env s' ds (s'', r')", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r)\n  evaluate_decs True mn env s' ds (s'', r')\n\ngoal (1 subgoal):\n 1. \\<exists>a. evaluate_decs True mn env s (d # ds) a", "using evaluate_decs.intros Cons"], ["proof (prove)\nusing this:\n  evaluate_dec True mn env s d (s', r)\n  evaluate_decs True mn env s' ds (s'', r')\n  evaluate_decs ?ck ?mn ?env ?s [] (?s, Rval (make_sem_env nsEmpty nsEmpty))\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rerr ?e) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds) (?s2.0, Rerr ?e)\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  \\<exists>a. evaluate_decs True ?mn ?env ?s ds a\n\ngoal (1 subgoal):\n 1. \\<exists>a. evaluate_decs True mn env s (d # ds) a", "by (cases r;fastforce)+"], ["proof (state)\nthis:\n  \\<exists>a. evaluate_decs True mn env s (d # ds) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decs_clock_monotone:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow> ck = True \\<Longrightarrow> (clock (fst res)) \\<le> (clock s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_decs ck mn env s d res; ck = True\\<rbrakk>\n    \\<Longrightarrow> clock (fst res) \\<le> clock s", "by (induction rule:evaluate_decs.inducts) (fastforce dest:dec_clock_monotone)+"], ["", "lemma decs_sub_from_counter:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow>\n  \\<forall>extra count count' s' r'.\n    (clock s) = count + extra \\<and> (clock s') = count' + extra \\<and>\n    res = (s',r') \\<and> ck = True \\<longrightarrow> evaluate_decs ck mn env (s \\<lparr> clock := count \\<rparr>) d ((s' \\<lparr> clock := count' \\<rparr>),r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env s d res \\<Longrightarrow>\n    \\<forall>extra count count' s' r'.\n       clock s = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       res = (s', r') \\<and> ck = True \\<longrightarrow>\n       evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s) d\n        (update_clock (\\<lambda>_. count') s', r')", "proof (induction rule:evaluate_decs.inducts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>extra count count' s' r'.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r') \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s) []\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>extra count count' s' r'.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr e) = (s', r') \\<and> ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1)\n           (d # ds) (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>extra count count' s' r'.\n           clock s2 = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s3, r) = (s', r') \\<and> ck = True \\<longrightarrow>\n           evaluate_decs ck mn (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. count) s2) ds\n            (update_clock (\\<lambda>_. count') s', r')) \\<Longrightarrow>\n       \\<forall>extra count count' s' r'.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s3, combine_dec_result new_env r) = (s', r') \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1)\n           (d # ds) (update_clock (\\<lambda>_. count') s', r')", "case (cons2 ck mn s1 s2 s3 env d ds new_env r)"], ["proof (state)\nthis:\n  evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n  evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n  (\\<forall>extra count count' s' r'.\n      clock s2 = count + extra \\<and>\n      clock s' = count' + extra \\<and>\n      (s3, r) = (s', r') \\<and> ck = True \\<longrightarrow>\n      evaluate_decs ck mn (extend_dec_env new_env env)\n       (update_clock (\\<lambda>_. count) s2) ds\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (3 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>extra count count' s' r'.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r') \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s) []\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>extra count count' s' r'.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr e) = (s', r') \\<and> ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1)\n           (d # ds) (update_clock (\\<lambda>_. count') s', r')\n 3. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>extra count count' s' r'.\n           clock s2 = count + extra \\<and>\n           clock s' = count' + extra \\<and>\n           (s3, r) = (s', r') \\<and> ck = True \\<longrightarrow>\n           evaluate_decs ck mn (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. count) s2) ds\n            (update_clock (\\<lambda>_. count') s', r')) \\<Longrightarrow>\n       \\<forall>extra count count' s' r'.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s3, combine_dec_result new_env r) = (s', r') \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1)\n           (d # ds) (update_clock (\\<lambda>_. count') s', r')", "then"], ["proof (chain)\npicking this:\n  evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n  evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n  (\\<forall>extra count count' s' r'.\n      clock s2 = count + extra \\<and>\n      clock s' = count' + extra \\<and>\n      (s3, r) = (s', r') \\<and> ck = True \\<longrightarrow>\n      evaluate_decs ck mn (extend_dec_env new_env env)\n       (update_clock (\\<lambda>_. count) s2) ds\n       (update_clock (\\<lambda>_. count') s', r'))", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n  evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n  (\\<forall>extra count count' s' r'.\n      clock s2 = count + extra \\<and>\n      clock s' = count' + extra \\<and>\n      (s3, r) = (s', r') \\<and> ck = True \\<longrightarrow>\n      evaluate_decs ck mn (extend_dec_env new_env env)\n       (update_clock (\\<lambda>_. count) s2) ds\n       (update_clock (\\<lambda>_. count') s', r'))\n\ngoal (1 subgoal):\n 1. \\<forall>extra count count' s' r'.\n       clock s1 = count + extra \\<and>\n       clock s' = count' + extra \\<and>\n       (s3, combine_dec_result new_env r) = (s', r') \\<and>\n       ck = True \\<longrightarrow>\n       evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1)\n        (d # ds) (update_clock (\\<lambda>_. count') s', r')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>extra count count'.\n       \\<lbrakk>evaluate_dec True mn env s1 d (s2, Rval new_env);\n        evaluate_decs True mn (extend_dec_env new_env env) s2 ds (s3, r);\n        \\<forall>extraa count count'a.\n           clock s2 = count + extraa \\<and>\n           count' + extra = count'a + extraa \\<longrightarrow>\n           evaluate_decs True mn (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. count) s2) ds\n            (update_clock (\\<lambda>_. count'a) s3, r);\n        clock s1 = count + extra; clock s3 = count' + extra; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate_decs True mn env\n                          (update_clock (\\<lambda>_. count) s1) (d # ds)\n                          (update_clock (\\<lambda>_. count') s3,\n                           combine_dec_result new_env r)", "subgoal for extra"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_dec True mn env s1 d (s2, Rval new_env);\n     evaluate_decs True mn (extend_dec_env new_env env) s2 ds (s3, r);\n     \\<forall>extraa count count'a.\n        clock s2 = count + extraa \\<and>\n        count'_ + extra = count'a + extraa \\<longrightarrow>\n        evaluate_decs True mn (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. count) s2) ds\n         (update_clock (\\<lambda>_. count'a) s3, r);\n     clock s1 = count_ + extra; clock s3 = count'_ + extra; ck\\<rbrakk>\n    \\<Longrightarrow> evaluate_decs True mn env\n                       (update_clock (\\<lambda>_. count_) s1) (d # ds)\n                       (update_clock (\\<lambda>_. count'_) s3,\n                        combine_dec_result new_env r)", "apply (subgoal_tac \"clock s2\\<ge>extra\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate_dec True mn env s1 d (s2, Rval new_env);\n     evaluate_decs True mn (extend_dec_env new_env env) s2 ds (s3, r);\n     \\<forall>extraa count count'a.\n        clock s2 = count + extraa \\<and>\n        count'_ + extra = count'a + extraa \\<longrightarrow>\n        evaluate_decs True mn (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. count) s2) ds\n         (update_clock (\\<lambda>_. count'a) s3, r);\n     clock s1 = count_ + extra; clock s3 = count'_ + extra; ck;\n     extra \\<le> clock s2\\<rbrakk>\n    \\<Longrightarrow> evaluate_decs True mn env\n                       (update_clock (\\<lambda>_. count_) s1) (d # ds)\n                       (update_clock (\\<lambda>_. count'_) s3,\n                        combine_dec_result new_env r)\n 2. \\<lbrakk>evaluate_dec True mn env s1 d (s2, Rval new_env);\n     evaluate_decs True mn (extend_dec_env new_env env) s2 ds (s3, r);\n     \\<forall>extraa count count'a.\n        clock s2 = count + extraa \\<and>\n        count'_ + extra = count'a + extraa \\<longrightarrow>\n        evaluate_decs True mn (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. count) s2) ds\n         (update_clock (\\<lambda>_. count'a) s3, r);\n     clock s1 = count_ + extra; clock s3 = count'_ + extra; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "apply (metis dec_sub_from_counter diff_add_inverse2 eq_diff_iff evaluate_decs.cons2 le_add2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_dec True mn env s1 d (s2, Rval new_env);\n     evaluate_decs True mn (extend_dec_env new_env env) s2 ds (s3, r);\n     \\<forall>extraa count count'a.\n        clock s2 = count + extraa \\<and>\n        count'_ + extra = count'a + extraa \\<longrightarrow>\n        evaluate_decs True mn (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. count) s2) ds\n         (update_clock (\\<lambda>_. count'a) s3, r);\n     clock s1 = count_ + extra; clock s3 = count'_ + extra; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "using decs_clock_monotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>evaluate_decs ?ck ?mn ?env ?s ?d ?res; ?ck = True\\<rbrakk>\n  \\<Longrightarrow> clock (fst ?res) \\<le> clock ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_dec True mn env s1 d (s2, Rval new_env);\n     evaluate_decs True mn (extend_dec_env new_env env) s2 ds (s3, r);\n     \\<forall>extraa count count'a.\n        clock s2 = count + extraa \\<and>\n        count'_ + extra = count'a + extraa \\<longrightarrow>\n        evaluate_decs True mn (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. count) s2) ds\n         (update_clock (\\<lambda>_. count'a) s3, r);\n     clock s1 = count_ + extra; clock s3 = count'_ + extra; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>extra count count' s' r'.\n     clock s1 = count + extra \\<and>\n     clock s' = count' + extra \\<and>\n     (s3, combine_dec_result new_env r) = (s', r') \\<and>\n     ck = True \\<longrightarrow>\n     evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1) (d # ds)\n      (update_clock (\\<lambda>_. count') s', r')\n\ngoal (2 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>extra count count' s' r'.\n          clock s = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r') \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s) []\n           (update_clock (\\<lambda>_. count') s', r')\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>extra count count' s' r'.\n          clock s1 = count + extra \\<and>\n          clock s' = count' + extra \\<and>\n          (s2, Rerr e) = (s', r') \\<and> ck = True \\<longrightarrow>\n          evaluate_decs ck mn env (update_clock (\\<lambda>_. count) s1)\n           (d # ds) (update_clock (\\<lambda>_. count') s', r')", "qed (auto intro!:evaluate_decs.intros simp add:dec_sub_from_counter)"], ["", "lemma decs_clocked_min_counter:\n  assumes \"evaluate_decs ck mn env s ds res\" \"ck = True\"\n  shows \"evaluate_decs ck mn env (s \\<lparr> clock := clock s - (clock (fst res))\\<rparr>) ds (((fst res) \\<lparr> clock := 0 \\<rparr>),(snd res))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env\n     (update_clock (\\<lambda>_. clock s - clock (fst res)) s) ds\n     (update_clock (\\<lambda>_. 0) (fst res), snd res)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env\n     (update_clock (\\<lambda>_. clock s - clock (fst res)) s) ds\n     (update_clock (\\<lambda>_. 0) (fst res), snd res)", "from assms"], ["proof (chain)\npicking this:\n  evaluate_decs ck mn env s ds res\n  ck = True", "have \"clock (fst res) \\<le> clock s\""], ["proof (prove)\nusing this:\n  evaluate_decs ck mn env s ds res\n  ck = True\n\ngoal (1 subgoal):\n 1. clock (fst res) \\<le> clock s", "using decs_clock_monotone"], ["proof (prove)\nusing this:\n  evaluate_decs ck mn env s ds res\n  ck = True\n  \\<lbrakk>evaluate_decs ?ck ?mn ?env ?s ?d ?res; ?ck = True\\<rbrakk>\n  \\<Longrightarrow> clock (fst ?res) \\<le> clock ?s\n\ngoal (1 subgoal):\n 1. clock (fst res) \\<le> clock s", "by fastforce"], ["proof (state)\nthis:\n  clock (fst res) \\<le> clock s\n\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env\n     (update_clock (\\<lambda>_. clock s - clock (fst res)) s) ds\n     (update_clock (\\<lambda>_. 0) (fst res), snd res)", "with assms"], ["proof (chain)\npicking this:\n  evaluate_decs ck mn env s ds res\n  ck = True\n  clock (fst res) \\<le> clock s", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_decs ck mn env s ds res\n  ck = True\n  clock (fst res) \\<le> clock s\n\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env\n     (update_clock (\\<lambda>_. clock s - clock (fst res)) s) ds\n     (update_clock (\\<lambda>_. 0) (fst res), snd res)", "by (auto elim!: decs_sub_from_counter[rule_format])"], ["proof (state)\nthis:\n  evaluate_decs ck mn env\n   (update_clock (\\<lambda>_. clock s - clock (fst res)) s) ds\n   (update_clock (\\<lambda>_. 0) (fst res), snd res)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decs_add_to_counter:\n  \"evaluate_decs ck mn env s d res \\<Longrightarrow> \\<forall>s' r extra. res = (s',r) \\<and> ck = True \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_decs True mn env (s \\<lparr> clock := clock s + extra \\<rparr>) d ((s' \\<lparr> clock := clock s' + extra \\<rparr>),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs ck mn env s d res \\<Longrightarrow>\n    \\<forall>s' r extra.\n       res = (s', r) \\<and>\n       ck = True \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_decs True mn env\n        (update_clock (\\<lambda>_. clock s + extra) s) d\n        (update_clock (\\<lambda>_. clock s' + extra) s', r)", "proof (induction rule:evaluate_decs.inducts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) []\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr e) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (d # ds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra extra.\n           (s3, r) = (s', ra) \\<and>\n           ck = True \\<and>\n           ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_decs True mn (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. clock s2 + extra) s2) ds\n            (update_clock (\\<lambda>_. clock s' + extra) s',\n             ra)) \\<Longrightarrow>\n       \\<forall>s' ra extra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = True \\<and>\n          ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (d # ds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', ra)", "case cons2"], ["proof (state)\nthis:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra extra.\n      (s3_, r_) = (s', ra) \\<and>\n      ck_ = True \\<and>\n      ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n      evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. clock s2_ + extra) s2_) ds_\n       (update_clock (\\<lambda>_. clock s' + extra) s', ra))\n\ngoal (3 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) []\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr e) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (d # ds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 3. \\<And>ck mn s1 s2 s3 env d ds new_env r.\n       evaluate_dec ck mn env s1 d (s2, Rval new_env) \\<and>\n       evaluate_decs ck mn (extend_dec_env new_env env) s2 ds (s3, r) \\<and>\n       (\\<forall>s' ra extra.\n           (s3, r) = (s', ra) \\<and>\n           ck = True \\<and>\n           ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n           evaluate_decs True mn (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. clock s2 + extra) s2) ds\n            (update_clock (\\<lambda>_. clock s' + extra) s',\n             ra)) \\<Longrightarrow>\n       \\<forall>s' ra extra.\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = True \\<and>\n          ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (d # ds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', ra)", "then"], ["proof (chain)\npicking this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra extra.\n      (s3_, r_) = (s', ra) \\<and>\n      ck_ = True \\<and>\n      ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n      evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. clock s2_ + extra) s2_) ds_\n       (update_clock (\\<lambda>_. clock s' + extra) s', ra))", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra extra.\n      (s3_, r_) = (s', ra) \\<and>\n      ck_ = True \\<and>\n      ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n      evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. clock s2_ + extra) s2_) ds_\n       (update_clock (\\<lambda>_. clock s' + extra) s', ra))\n\ngoal (1 subgoal):\n 1. \\<forall>s' ra extra.\n       (s3_, combine_dec_result new_env_ r_) = (s', ra) \\<and>\n       ck_ = True \\<and>\n       ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_decs True mn_ env_\n        (update_clock (\\<lambda>_. clock s1_ + extra) s1_) (d_ # ds_)\n        (update_clock (\\<lambda>_. clock s' + extra) s', ra)", "using dec_add_to_counter evaluate_decs.cons2"], ["proof (prove)\nusing this:\n  evaluate_dec ck_ mn_ env_ s1_ d_ (s2_, Rval new_env_) \\<and>\n  evaluate_decs ck_ mn_ (extend_dec_env new_env_ env_) s2_ ds_\n   (s3_, r_) \\<and>\n  (\\<forall>s' ra extra.\n      (s3_, r_) = (s', ra) \\<and>\n      ck_ = True \\<and>\n      ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n      evaluate_decs True mn_ (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. clock s2_ + extra) s2_) ds_\n       (update_clock (\\<lambda>_. clock s' + extra) s', ra))\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r extra.\n     ?res = (s', r) \\<and>\n     ?ck = True \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_dec True ?mn ?env\n      (update_clock (\\<lambda>_. clock ?s + extra) ?s) ?d\n      (update_clock (\\<lambda>_. clock s' + extra) s', r)\n  evaluate_dec ?ck ?mn ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<and>\n  evaluate_decs ?ck ?mn (extend_dec_env ?new_env ?env) ?s2.0 ?ds\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_decs ?ck ?mn ?env ?s1.0 (?d # ?ds)\n   (?s3.0, combine_dec_result ?new_env ?r)\n\ngoal (1 subgoal):\n 1. \\<forall>s' ra extra.\n       (s3_, combine_dec_result new_env_ r_) = (s', ra) \\<and>\n       ck_ = True \\<and>\n       ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_decs True mn_ env_\n        (update_clock (\\<lambda>_. clock s1_ + extra) s1_) (d_ # ds_)\n        (update_clock (\\<lambda>_. clock s' + extra) s', ra)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>s' ra extra.\n     (s3_, combine_dec_result new_env_ r_) = (s', ra) \\<and>\n     ck_ = True \\<and>\n     ra \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_decs True mn_ env_\n      (update_clock (\\<lambda>_. clock s1_ + extra) s1_) (d_ # ds_)\n      (update_clock (\\<lambda>_. clock s' + extra) s', ra)\n\ngoal (2 subgoals):\n 1. \\<And>ck mn env s.\n       \\<forall>s' r extra.\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s + extra) s) []\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)\n 2. \\<And>ck mn s1 s2 env d ds e.\n       evaluate_dec ck mn env s1 d (s2, Rerr e) \\<Longrightarrow>\n       \\<forall>s' r extra.\n          (s2, Rerr e) = (s', r) \\<and>\n          ck = True \\<and>\n          r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n          evaluate_decs True mn env\n           (update_clock (\\<lambda>_. clock s1 + extra) s1) (d # ds)\n           (update_clock (\\<lambda>_. clock s' + extra) s', r)", "qed (auto intro!:evaluate_decs.intros simp add:dec_add_to_counter)"], ["", "lemma top_evaluate_not_timeout:\n  \"evaluate_top False env s tp (s',r) \\<Longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r) \\<Longrightarrow>\n    r \\<noteq> Rerr (Rabort Rtimeout_error)", "by (ind_cases \"evaluate_top False env s tp (s',r)\") (fastforce dest:dec_evaluate_not_timeout decs_evaluate_not_timeout)+"], ["", "lemma top_unclocked_ignore:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"r \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  shows \"evaluate_top False env (s \\<lparr> clock := cnt \\<rparr>) tp ((s' \\<lparr> clock := cnt \\<rparr>),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top ck env s tp (s', r)\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "proof (cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "case (tmod1 s2 ds mn specs new_env)"], ["proof (state)\nthis:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds;\n     s' =\n     update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2;\n     r =\n     Rval\n      (make_sem_env (nsLift mn (sem_env.v new_env))\n        (nsLift mn (c new_env)));\n     [mn] \\<notin> defined_mods s \\<and>\n     no_dup_types ds \\<and>\n     evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) tp\n                       (update_clock (\\<lambda>_. cnt) s', r)", "from tmod1"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)", "have \"[mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)\""], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)", "by fastforce"], ["proof (state)\nthis:\n  [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds;\n     s' =\n     update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2;\n     r =\n     Rval\n      (make_sem_env (nsLift mn (sem_env.v new_env))\n        (nsLift mn (c new_env)));\n     [mn] \\<notin> defined_mods s \\<and>\n     no_dup_types ds \\<and>\n     evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) tp\n                       (update_clock (\\<lambda>_. cnt) s', r)", "moreover"], ["proof (state)\nthis:\n  [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds;\n     s' =\n     update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2;\n     r =\n     Rval\n      (make_sem_env (nsLift mn (sem_env.v new_env))\n        (nsLift mn (c new_env)));\n     [mn] \\<notin> defined_mods s \\<and>\n     no_dup_types ds \\<and>\n     evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) tp\n                       (update_clock (\\<lambda>_. cnt) s', r)", "from tmod1"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)", "have \"evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds (update_clock (\\<lambda>_. cnt) s2, Rval new_env)\""], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n     (update_clock (\\<lambda>_. cnt) s2, Rval new_env)", "using decs_unclocked_ignore"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n  evaluate_decs ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r count.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_decs False ?mn ?env (update_clock (\\<lambda>_. count) ?s) ?d\n      (update_clock (\\<lambda>_. count) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n     (update_clock (\\<lambda>_. cnt) s2, Rval new_env)", "by fastforce"], ["proof (state)\nthis:\n  evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n   (update_clock (\\<lambda>_. cnt) s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds;\n     s' =\n     update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2;\n     r =\n     Rval\n      (make_sem_env (nsLift mn (sem_env.v new_env))\n        (nsLift mn (c new_env)));\n     [mn] \\<notin> defined_mods s \\<and>\n     no_dup_types ds \\<and>\n     evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) tp\n                       (update_clock (\\<lambda>_. cnt) s', r)", "ultimately"], ["proof (chain)\npicking this:\n  [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)\n  evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n   (update_clock (\\<lambda>_. cnt) s2, Rval new_env)", "show ?thesis"], ["proof (prove)\nusing this:\n  [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)\n  evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n   (update_clock (\\<lambda>_. cnt) s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "unfolding tmod1"], ["proof (prove)\nusing this:\n  [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s)\n  evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n   (update_clock (\\<lambda>_. cnt) s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s)\n     (Tmod mn specs ds)\n     (update_clock (\\<lambda>_. cnt)\n       (update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2),\n      Rval\n       (make_sem_env (nsLift mn (sem_env.v new_env))\n         (nsLift mn (c new_env))))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[mn] \\<notin> defined_mods (update_clock (\\<lambda>_. cnt) s);\n     evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n      (update_clock (\\<lambda>_. cnt) s2, Rval new_env)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) (Tmod mn specs ds)\n                       (update_clock (\\<lambda>_. cnt)\n                         (update_defined_mods\n                           (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n                           s2),\n                        Rval\n                         (make_sem_env (nsLift mn (sem_env.v new_env))\n                           (nsLift mn (c new_env))))", "apply (drule evaluate_top.tmod1[OF conjI])"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n     (update_clock (\\<lambda>_. cnt) s2, Rval new_env) \\<Longrightarrow>\n    no_dup_types ?ds2 \\<and>\n    evaluate_decs ?ck2 [mn] ?env2 (update_clock (\\<lambda>_. cnt) s) ?ds2\n     (?s2.2, Rval ?new_env2)\n 2. \\<lbrakk>evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s)\n              ds (update_clock (\\<lambda>_. cnt) s2, Rval new_env);\n     evaluate_top ?ck2 ?env2 (update_clock (\\<lambda>_. cnt) s)\n      (Tmod mn ?specs2 ?ds2)\n      (update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods ?s2.2)\n        ?s2.2,\n       Rval\n        (make_sem_env (nsLift mn (sem_env.v ?new_env2))\n          (nsLift mn (c ?new_env2))))\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) (Tmod mn specs ds)\n                       (update_clock (\\<lambda>_. cnt)\n                         (update_defined_mods\n                           (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n                           s2),\n                        Rval\n                         (make_sem_env (nsLift mn (sem_env.v new_env))\n                           (nsLift mn (c new_env))))", "using tmod1"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (2 subgoals):\n 1. evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s) ds\n     (update_clock (\\<lambda>_. cnt) s2, Rval new_env) \\<Longrightarrow>\n    no_dup_types ?ds2 \\<and>\n    evaluate_decs ?ck2 [mn] ?env2 (update_clock (\\<lambda>_. cnt) s) ?ds2\n     (?s2.2, Rval ?new_env2)\n 2. \\<lbrakk>evaluate_decs False [mn] env (update_clock (\\<lambda>_. cnt) s)\n              ds (update_clock (\\<lambda>_. cnt) s2, Rval new_env);\n     evaluate_top ?ck2 ?env2 (update_clock (\\<lambda>_. cnt) s)\n      (Tmod mn ?specs2 ?ds2)\n      (update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods ?s2.2)\n        ?s2.2,\n       Rval\n        (make_sem_env (nsLift mn (sem_env.v ?new_env2))\n          (nsLift mn (c ?new_env2))))\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s) (Tmod mn specs ds)\n                       (update_clock (\\<lambda>_. cnt)\n                         (update_defined_mods\n                           (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n                           s2),\n                        Rval\n                         (make_sem_env (nsLift mn (sem_env.v new_env))\n                           (nsLift mn (c new_env))))", "by auto"], ["proof (state)\nthis:\n  evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n   (update_clock (\\<lambda>_. cnt) s', r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n   (update_clock (\\<lambda>_. cnt) s', r)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "case tmod2"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "(* this is the same as tmod1 *)"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "using assms"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n  evaluate_top ck env s tp (s', r)\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top ck env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     err_ \\<noteq> Rabort Rtimeout_error; [mn_] \\<notin> defined_mods s;\n     no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. cnt) s2_),\n                        Rerr err_)", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top ck env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     err_ \\<noteq> Rabort Rtimeout_error; [mn_] \\<notin> defined_mods s;\n     no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env\n                       (update_clock (\\<lambda>_. cnt) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f8 s2_)))\n                         (update_clock (\\<lambda>_. cnt) s2_),\n                        Rerr err_)", "by (fastforce simp add:decs_unclocked_ignore intro:evaluate_top.tmod2[simplified])"], ["proof (state)\nthis:\n  evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n   (update_clock (\\<lambda>_. cnt) s', r)\n\ngoal (4 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "case (tmod3 ds mn specs)"], ["proof (state)\nthis:\n  tp = Tmod mn specs ds\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  \\<not> no_dup_types ds\n\ngoal (4 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  \\<not> no_dup_types ds", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  \\<not> no_dup_types ds\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt) s', r)", "by (auto intro:evaluate_top.intros)"], ["proof (state)\nthis:\n  evaluate_top False env (update_clock (\\<lambda>_. cnt) s) tp\n   (update_clock (\\<lambda>_. cnt) s', r)\n\ngoal (3 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); tp = Tdec d;\n        r = Rerr err; evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)\n 3. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top False env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt) s', r)", "qed(auto intro!:evaluate_top.intros simp add:dec_unclocked_ignore)"], ["", "lemma top_unclocked:\n  \"(evaluate_top False env s tp (s',r) \\<longrightarrow> (r \\<noteq> Rerr (Rabort Rtimeout_error)) \\<and> (clock   s) = (clock   s')) \\<and>\n   (evaluate_top False env (s (| clock := count1 |)) tp ((s' (| clock := count1 |)),r) =\n    evaluate_top False env (s (| clock := count2 |)) tp ((s' (| clock := count2 |)),r))\" (is \"?P \\<and> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_top False env s tp (s', r) \\<longrightarrow>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n     clock s = clock s') \\<and>\n    evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n     (update_clock (\\<lambda>_. count2) s', r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. evaluate_top False env s tp (s', r) \\<longrightarrow>\n    r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n     (update_clock (\\<lambda>_. count2) s', r)", "show ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r) \\<longrightarrow>\n    r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "apply (auto simp add:top_evaluate_not_timeout)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r) \\<Longrightarrow> clock s = clock s'", "by (ind_cases \"evaluate_top False env s tp (s',r)\")\n    (auto simp add:dec_unclocked decs_unclocked top_evaluate_not_timeout)"], ["proof (state)\nthis:\n  evaluate_top False env s tp (s', r) \\<longrightarrow>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n     (update_clock (\\<lambda>_. count2) s', r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n     (update_clock (\\<lambda>_. count2) s', r)", "show ?Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n     (update_clock (\\<lambda>_. count2) s', r)", "using top_unclocked_ignore[rule_format] top_evaluate_not_timeout"], ["proof (prove)\nusing this:\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n  evaluate_top False ?env ?s ?tp (?s', ?r) \\<Longrightarrow>\n  ?r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n     (update_clock (\\<lambda>_. count1) s', r) =\n    evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n     (update_clock (\\<lambda>_. count2) s', r)", "by fastforce+"], ["proof (state)\nthis:\n  evaluate_top False env (update_clock (\\<lambda>_. count1) s) tp\n   (update_clock (\\<lambda>_. count1) s', r) =\n  evaluate_top False env (update_clock (\\<lambda>_. count2) s) tp\n   (update_clock (\\<lambda>_. count2) s', r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_evaluate_top_timeout:\n  assumes \"\\<forall>r. \\<not>evaluate_top False env s tp r\"\n  shows \" \\<exists>r. evaluate_top True env s tp r \\<and> (snd r) = Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_top True env s tp r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof (cases tp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "case (Tmod mn specs ds)"], ["proof (state)\nthis:\n  tp = Tmod mn specs ds\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "have ds:\"no_dup_types ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_dup_types ds", "using Tmod assms tmod3"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  \\<forall>r. \\<not> evaluate_top False env s tp r\n  \\<not> no_dup_types ?ds \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tmod ?mn ?specs ?ds)\n   (?s1.0, Rerr (Rabort Rtype_error))\n\ngoal (1 subgoal):\n 1. no_dup_types ds", "by blast"], ["proof (state)\nthis:\n  no_dup_types ds\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "have mn:\"[mn] \\<notin> defined_mods s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [mn] \\<notin> defined_mods s", "using Tmod assms tmod4"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  \\<forall>r. \\<not> evaluate_top False env s tp r\n  [?mn] \\<in> defined_mods ?s \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s (Tmod ?mn ?specs ?ds)\n   (?s, Rerr (Rabort Rtype_error))\n\ngoal (1 subgoal):\n 1. [mn] \\<notin> defined_mods s", "by blast"], ["proof (state)\nthis:\n  [mn] \\<notin> defined_mods s\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "have \"\\<not> evaluate_decs False [mn] env s ds (s', r)\" for s' r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> evaluate_decs False [mn] env s ds (s', r)", "apply (cases r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       r = Rval x1 \\<Longrightarrow>\n       \\<not> evaluate_decs False [mn] env s ds (s', r)\n 2. \\<And>x2.\n       r = Rerr x2 \\<Longrightarrow>\n       \\<not> evaluate_decs False [mn] env s ds (s', r)", "using ds mn Tmod assms tmod1 tmod2"], ["proof (prove)\nusing this:\n  no_dup_types ds\n  [mn] \\<notin> defined_mods s\n  tp = Tmod mn specs ds\n  \\<forall>r. \\<not> evaluate_top False env s tp r\n  [?mn] \\<notin> defined_mods ?s1.0 \\<and>\n  no_dup_types ?ds \\<and>\n  evaluate_decs ?ck [?mn] ?env ?s1.0 ?ds\n   (?s2.0, Rval ?new_env) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tmod ?mn ?specs ?ds)\n   (update_defined_mods (\\<lambda>_. {[?mn]} \\<union> defined_mods ?s2.0)\n     ?s2.0,\n    Rval\n     (make_sem_env (nsLift ?mn (sem_env.v ?new_env))\n       (nsLift ?mn (c ?new_env))))\n  [?mn] \\<notin> defined_mods ?s1.0 \\<and>\n  no_dup_types ?ds \\<and>\n  evaluate_decs ?ck [?mn] ?env ?s1.0 ?ds\n   (?s2.0, Rerr ?err) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tmod ?mn ?specs ?ds)\n   (update_defined_mods (\\<lambda>_. {[?mn]} \\<union> defined_mods ?s2.0)\n     ?s2.0,\n    Rerr ?err)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       r = Rval x1 \\<Longrightarrow>\n       \\<not> evaluate_decs False [mn] env s ds (s', r)\n 2. \\<And>x2.\n       r = Rerr x2 \\<Longrightarrow>\n       \\<not> evaluate_decs False [mn] env s ds (s', r)", "by blast+"], ["proof (state)\nthis:\n  \\<not> evaluate_decs False [mn] env s ds (?s', ?r)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<not> evaluate_decs False [mn] env s ds (?s', ?r)", "obtain s' where \" evaluate_decs True [mn] env s ds (s', Rerr (Rabort Rtimeout_error))\""], ["proof (prove)\nusing this:\n  \\<not> evaluate_decs False [mn] env s ds (?s', ?r)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        evaluate_decs True [mn] env s ds\n         (s', Rerr (Rabort Rtimeout_error)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) not_evaluate_decs_timeout[simplified])"], ["proof (state)\nthis:\n  evaluate_decs True [mn] env s ds (s', Rerr (Rabort Rtimeout_error))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_top True env s tp r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "unfolding Tmod"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_top True env s (Tmod mn specs ds) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_top True env s (Tmod mn specs ds) ?r\n 2. snd ?r = Rerr (Rabort Rtimeout_error)", "apply (rule tmod2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [mn] \\<notin> defined_mods s \\<and>\n    no_dup_types ds \\<and>\n    evaluate_decs True [mn] env s ds (?s2.2, Rerr ?err2)\n 2. snd (update_defined_mods\n          (\\<lambda>_. {[mn]} \\<union> defined_mods ?s2.2) ?s2.2,\n         Rerr ?err2) =\n    Rerr (Rabort Rtimeout_error)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. [mn] \\<notin> defined_mods s\n 2. no_dup_types ds\n 3. evaluate_decs True [mn] env s ds (?s2.2, Rerr ?err2)\n 4. snd (update_defined_mods\n          (\\<lambda>_. {[mn]} \\<union> defined_mods ?s2.2) ?s2.2,\n         Rerr ?err2) =\n    Rerr (Rabort Rtimeout_error)", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s')\n          s',\n         Rerr (Rabort Rtimeout_error)) =\n    Rerr (Rabort Rtimeout_error)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_top True env s tp r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "case (Tdec d)"], ["proof (state)\nthis:\n  tp = Tdec d\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "have \"\\<not> evaluate_dec False [] env s d (s', r)\" for s' r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> evaluate_dec False [] env s d (s', r)", "apply (cases r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       r = Rval x1 \\<Longrightarrow>\n       \\<not> evaluate_dec False [] env s d (s', r)\n 2. \\<And>x2.\n       r = Rerr x2 \\<Longrightarrow>\n       \\<not> evaluate_dec False [] env s d (s', r)", "using tdec1 tdec2 assms Tdec"], ["proof (prove)\nusing this:\n  evaluate_dec ?ck [] ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tdec ?d) (?s2.0, Rval ?new_env)\n  evaluate_dec ?ck [] ?env ?s1.0 ?d (?s2.0, Rerr ?err) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tdec ?d) (?s2.0, Rerr ?err)\n  \\<forall>r. \\<not> evaluate_top False env s tp r\n  tp = Tdec d\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       r = Rval x1 \\<Longrightarrow>\n       \\<not> evaluate_dec False [] env s d (s', r)\n 2. \\<And>x2.\n       r = Rerr x2 \\<Longrightarrow>\n       \\<not> evaluate_dec False [] env s d (s', r)", "by blast+"], ["proof (state)\nthis:\n  \\<not> evaluate_dec False [] env s d (?s', ?r)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<not> evaluate_dec False [] env s d (?s', ?r)", "obtain s' where  \" evaluate_dec True [] env s d (s', Rerr (Rabort Rtimeout_error))\""], ["proof (prove)\nusing this:\n  \\<not> evaluate_dec False [] env s d (?s', ?r)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        evaluate_dec True [] env s d\n         (s', Rerr (Rabort Rtimeout_error)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not_evaluate_dec_timeout[simplified]"], ["proof (prove)\nusing this:\n  \\<not> evaluate_dec False [] env s d (?s', ?r)\n  \\<forall>a b.\n     \\<not> evaluate_dec False ?mn ?env ?s ?d (a, b) \\<Longrightarrow>\n  \\<exists>a b.\n     evaluate_dec True ?mn ?env ?s ?d (a, b) \\<and>\n     b = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        evaluate_dec True [] env s d\n         (s', Rerr (Rabort Rtimeout_error)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  evaluate_dec True [] env s d (s', Rerr (Rabort Rtimeout_error))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_top True env s tp r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_top True env s tp r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "unfolding Tdec"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_top True env s (Tdec d) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_top True env s (Tdec d) ?r\n 2. snd ?r = Rerr (Rabort Rtimeout_error)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_dec True [] env s d (?s2.2, Rerr ?err2)\n 2. snd (?s2.2, Rerr ?err2) = Rerr (Rabort Rtimeout_error)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (s', Rerr (Rabort Rtimeout_error)) = Rerr (Rabort Rtimeout_error)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_top True env s tp r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_clocked_total:\n  \"\\<exists>r. evaluate_top True env s tp r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_top True env s tp r", "proof (cases tp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "case (Tmod mn specs ds)"], ["proof (state)\nthis:\n  tp = Tmod mn specs ds\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "have ds:\"\\<exists>s' r. evaluate_decs True [mn] env s ds (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s' r. evaluate_decs True [mn] env s ds (s', r)", "using decs_clocked_total[simplified]"], ["proof (prove)\nusing this:\n  \\<exists>a b. evaluate_decs True ?mn ?env ?s ?ds (a, b)\n\ngoal (1 subgoal):\n 1. \\<exists>s' r. evaluate_decs True [mn] env s ds (s', r)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s' r. evaluate_decs True [mn] env s ds (s', r)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13.\n       tp = Tmod x11 x12 x13 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r\n 2. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "from Tmod"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_top True env s tp r", "apply (cases \"no_dup_types ds\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r\n 2. \\<lbrakk>tp = Tmod mn specs ds; \\<not> no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tp = Tmod mn specs ds; \\<not> no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r\n 2. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "using tmod3"], ["proof (prove)\nusing this:\n  \\<not> no_dup_types ?ds \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tmod ?mn ?specs ?ds)\n   (?s1.0, Rerr (Rabort Rtype_error))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tp = Tmod mn specs ds; \\<not> no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r\n 2. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "apply (cases \"[mn] \\<in>(defined_mods s)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<in> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r\n 2. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<notin> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "using tmod4"], ["proof (prove)\nusing this:\n  [?mn] \\<in> defined_mods ?s \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s (Tmod ?mn ?specs ?ds)\n   (?s, Rerr (Rabort Rtype_error))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<in> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r\n 2. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<notin> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<notin> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "using ds"], ["proof (prove)\nusing this:\n  \\<exists>s' r. evaluate_decs True [mn] env s ds (s', r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<notin> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. evaluate_top True env s tp r", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' r.\n       \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n        [mn] \\<notin> defined_mods s;\n        evaluate_decs True [mn] env s ds (s', r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tmod mn specs ds)\n                             (a, b)", "subgoal for s' r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n     [mn] \\<notin> defined_mods s;\n     evaluate_decs True [mn] env s ds (s', r)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         evaluate_top True env s (Tmod mn specs ds) (a, b)", "apply (cases r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n        [mn] \\<notin> defined_mods s;\n        evaluate_decs True [mn] env s ds (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tmod mn specs ds)\n                             (a, b)\n 2. \\<And>x2.\n       \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n        [mn] \\<notin> defined_mods s;\n        evaluate_decs True [mn] env s ds (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tmod mn specs ds)\n                             (a, b)", "using evaluate_top.tmod1 evaluate_top.tmod2"], ["proof (prove)\nusing this:\n  [?mn] \\<notin> defined_mods ?s1.0 \\<and>\n  no_dup_types ?ds \\<and>\n  evaluate_decs ?ck [?mn] ?env ?s1.0 ?ds\n   (?s2.0, Rval ?new_env) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tmod ?mn ?specs ?ds)\n   (update_defined_mods (\\<lambda>_. {[?mn]} \\<union> defined_mods ?s2.0)\n     ?s2.0,\n    Rval\n     (make_sem_env (nsLift ?mn (sem_env.v ?new_env))\n       (nsLift ?mn (c ?new_env))))\n  [?mn] \\<notin> defined_mods ?s1.0 \\<and>\n  no_dup_types ?ds \\<and>\n  evaluate_decs ?ck [?mn] ?env ?s1.0 ?ds\n   (?s2.0, Rerr ?err) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tmod ?mn ?specs ?ds)\n   (update_defined_mods (\\<lambda>_. {[?mn]} \\<union> defined_mods ?s2.0)\n     ?s2.0,\n    Rerr ?err)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n        [mn] \\<notin> defined_mods s;\n        evaluate_decs True [mn] env s ds (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tmod mn specs ds)\n                             (a, b)\n 2. \\<And>x2.\n       \\<lbrakk>tp = Tmod mn specs ds; no_dup_types ds;\n        [mn] \\<notin> defined_mods s;\n        evaluate_decs True [mn] env s ds (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tmod mn specs ds)\n                             (a, b)", "by blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r. evaluate_top True env s tp r\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "case (Tdec d)"], ["proof (state)\nthis:\n  tp = Tdec d\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "have d:\"\\<exists>s' r. evaluate_dec True [] env s d (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s' r. evaluate_dec True [] env s d (s', r)", "using dec_clocked_total[simplified]"], ["proof (prove)\nusing this:\n  \\<exists>a b. evaluate_dec True ?mn ?env ?s ?d (a, b)\n\ngoal (1 subgoal):\n 1. \\<exists>s' r. evaluate_dec True [] env s d (s', r)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s' r. evaluate_dec True [] env s d (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       tp = Tdec x2 \\<Longrightarrow>\n       \\<exists>r. evaluate_top True env s tp r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_top True env s tp r", "unfolding Tdec"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_top True env s (Tdec d) r", "using d"], ["proof (prove)\nusing this:\n  \\<exists>s' r. evaluate_dec True [] env s d (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_top True env s (Tdec d) r", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' r.\n       evaluate_dec True [] env s d (s', r) \\<Longrightarrow>\n       \\<exists>a b. evaluate_top True env s (Tdec d) (a, b)", "subgoal for s' r"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec True [] env s d (s', r) \\<Longrightarrow>\n    \\<exists>a b. evaluate_top True env s (Tdec d) (a, b)", "apply (cases r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_dec True [] env s d (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tdec d) (a, b)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_dec True [] env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tdec d) (a, b)", "using evaluate_top.tdec1 evaluate_top.tdec2"], ["proof (prove)\nusing this:\n  evaluate_dec ?ck [] ?env ?s1.0 ?d (?s2.0, Rval ?new_env) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tdec ?d) (?s2.0, Rval ?new_env)\n  evaluate_dec ?ck [] ?env ?s1.0 ?d (?s2.0, Rerr ?err) \\<Longrightarrow>\n  evaluate_top ?ck ?env ?s1.0 (Tdec ?d) (?s2.0, Rerr ?err)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_dec True [] env s d (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tdec d) (a, b)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_dec True [] env s d (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            evaluate_top True env s (Tdec d) (a, b)", "by blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r. evaluate_top True env s tp r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_clocked_min_counter:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"ck\"\n  shows \"evaluate_top ck env (s \\<lparr> clock := clock s - clock s' \\<rparr>) tp (s' \\<lparr> clock := 0 \\<rparr>,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. clock s - clock s') s) tp\n     (update_clock (\\<lambda>_. 0) s', r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top ck env s tp (s', r)\n  ck\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. clock s - clock s') s) tp\n     (update_clock (\\<lambda>_. 0) s', r)", "proof (cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)", "case tmod1"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\n\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. clock s - clock s') s) tp\n     (update_clock (\\<lambda>_. 0) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top ck env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. 0) s2_),\n                        Rval\n                         (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n                           (nsLift mn_ (c new_env_))))", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top ck env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f6 s2_)))\n                         (update_clock (\\<lambda>_. 0) s2_),\n                        Rval\n                         (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n                           (nsLift mn_ (c new_env_))))", "apply (rule evaluate_top.tmod1[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock\n                                  (\\<lambda>_. clock s - clock s2_)\n                                  s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs ck [mn_] env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       ds_ (update_clock (\\<lambda>_. 0) s2_, Rval new_env_)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top ck env s tp (s', r)\n  ck\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock\n                                  (\\<lambda>_. clock s - clock s2_)\n                                  s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs ck [mn_] env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       ds_ (update_clock (\\<lambda>_. 0) s2_, Rval new_env_)", "by (auto dest:decs_clocked_min_counter)"], ["proof (state)\nthis:\n  evaluate_top ck env (update_clock (\\<lambda>_. clock s - clock s') s) tp\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)", "case tmod2"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. clock s - clock s') s) tp\n     (update_clock (\\<lambda>_. 0) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_; [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top ck env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. 0) s2_),\n                        Rerr err_)", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_; [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top ck env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f6 s2_)))\n                         (update_clock (\\<lambda>_. 0) s2_),\n                        Rerr err_)", "apply (rule evaluate_top.tmod2[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_; [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock\n                                  (\\<lambda>_. clock s - clock s2_)\n                                  s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs ck [mn_] env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       ds_ (update_clock (\\<lambda>_. 0) s2_, Rerr err_)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top ck env s tp (s', r)\n  ck\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_; [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock\n                                  (\\<lambda>_. clock s - clock s2_)\n                                  s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs ck [mn_] env\n                       (update_clock (\\<lambda>_. clock s - clock s2_) s)\n                       ds_ (update_clock (\\<lambda>_. 0) s2_, Rerr err_)", "by (auto dest:decs_clocked_min_counter)"], ["proof (state)\nthis:\n  evaluate_top ck env (update_clock (\\<lambda>_. clock s - clock s') s) tp\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (4 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. clock s - clock s') s)\n                          tp (update_clock (\\<lambda>_. 0) s', r)", "qed (fastforce intro:evaluate_top.intros dest:dec_clocked_min_counter)+"], ["", "lemma top_add_clock:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"\\<not>ck\"\n  shows \"\\<exists>c. evaluate_top True env (s (| clock := c |)) tp ((s' (| clock := 0 |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top ck env s tp (s', r)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "proof (cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "case (tdec1 d)"], ["proof (state)\nthis:\n  tp = Tdec d\n  r = Rval new_env_\n  evaluate_dec ck [] env s d (s', Rval new_env_)\n\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tdec d\n  r = Rval new_env_\n  evaluate_dec ck [] env s d (s', Rval new_env_)", "obtain c where \"evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d (update_clock (\\<lambda>_. 0) s', r)\""], ["proof (prove)\nusing this:\n  tp = Tdec d\n  r = Rval new_env_\n  evaluate_dec ck [] env s d (s', Rval new_env_)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n         (update_clock (\\<lambda>_. 0) s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dec_add_clock assms"], ["proof (prove)\nusing this:\n  tp = Tdec d\n  r = Rval new_env_\n  evaluate_dec ck [] env s d (s', Rval new_env_)\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r.\n     ?res = (s', r) \\<and> ?ck = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True ?mn ?env (update_clock (\\<lambda>_. c) ?s) ?d\n          (update_clock (\\<lambda>_. 0) s', r))\n  evaluate_top ck env s tp (s', r)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n         (update_clock (\\<lambda>_. 0) s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', r)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "unfolding tdec1"], ["proof (prove)\nusing this:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', Rval new_env_)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) (Tdec d)\n        (update_clock (\\<lambda>_. 0) s', Rval new_env_)", "by - rule+"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (5 subgoals):\n 1. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "case (tdec2 d)"], ["proof (state)\nthis:\n  tp = Tdec d\n  r = Rerr err_\n  evaluate_dec ck [] env s d (s', Rerr err_)\n\ngoal (5 subgoals):\n 1. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tdec d\n  r = Rerr err_\n  evaluate_dec ck [] env s d (s', Rerr err_)", "obtain c where \"evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d (update_clock (\\<lambda>_. 0) s', r)\""], ["proof (prove)\nusing this:\n  tp = Tdec d\n  r = Rerr err_\n  evaluate_dec ck [] env s d (s', Rerr err_)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n         (update_clock (\\<lambda>_. 0) s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dec_add_clock assms"], ["proof (prove)\nusing this:\n  tp = Tdec d\n  r = Rerr err_\n  evaluate_dec ck [] env s d (s', Rerr err_)\n  evaluate_dec ?ck ?mn ?env ?s ?d ?res \\<Longrightarrow>\n  \\<forall>s' r.\n     ?res = (s', r) \\<and> ?ck = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_dec True ?mn ?env (update_clock (\\<lambda>_. c) ?s) ?d\n          (update_clock (\\<lambda>_. 0) s', r))\n  evaluate_top ck env s tp (s', r)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n         (update_clock (\\<lambda>_. 0) s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (5 subgoals):\n 1. \\<And>d err.\n       \\<lbrakk>\\<not> ck; tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', r)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "unfolding tdec2"], ["proof (prove)\nusing this:\n  evaluate_dec True [] env (update_clock (\\<lambda>_. c) s) d\n   (update_clock (\\<lambda>_. 0) s', Rerr err_)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) (Tdec d)\n        (update_clock (\\<lambda>_. 0) s', Rerr err_)", "by - rule+"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (4 subgoals):\n 1. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "case (tmod1 s2 ds mn specs new_env)"], ["proof (state)\nthis:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (4 subgoals):\n 1. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)", "obtain c where \"evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds (update_clock (\\<lambda>_. 0) s2, Rval new_env)\""], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n         (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using decs_add_clock assms"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n  evaluate_decs ?ck ?mn ?env ?s ?ds ?res \\<Longrightarrow>\n  \\<forall>s' r.\n     ?res = (s', r) \\<and> ?ck = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_decs True ?mn ?env (update_clock (\\<lambda>_. c) ?s) ?ds\n          (update_clock (\\<lambda>_. 0) s', r))\n  evaluate_top ck env s tp (s', r)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n         (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rval new_env)\n\ngoal (4 subgoals):\n 1. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rval new_env)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "unfolding tmod1"], ["proof (prove)\nusing this:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. \\<exists>ca.\n       evaluate_top True env (update_clock (\\<lambda>_. ca) s)\n        (Tmod mn specs ds)\n        (update_clock (\\<lambda>_. 0)\n          (update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n            s2),\n         Rval\n          (make_sem_env (nsLift mn (sem_env.v new_env))\n            (nsLift mn (c new_env))))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n    \\<exists>ca.\n       evaluate_top True env (update_clock (\\<lambda>_. ca) s)\n        (Tmod mn specs ds)\n        (update_defined_mods (\\<lambda>_. insert [mn] (defined_mods s2))\n          (update_clock (\\<lambda>_. 0) s2),\n         Rval\n          (make_sem_env (nsLift mn (sem_env.v new_env))\n            (nsLift mn (c new_env))))", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n    \\<exists>ca.\n       evaluate_top True env (update_clock (\\<lambda>_. ca) s)\n        (Tmod mn specs ds)\n        (update_defined_mods\n          (\\<lambda>_. insert [mn] (defined_mods (update_clock ?f1 s2)))\n          (update_clock (\\<lambda>_. 0) s2),\n         Rval\n          (make_sem_env (nsLift mn (sem_env.v new_env))\n            (nsLift mn (c new_env))))", "apply rule+"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n    evaluate_top True env (update_clock (\\<lambda>_. ?c2) s)\n     (Tmod mn specs ds)\n     (update_defined_mods\n       (\\<lambda>_. insert [mn] (defined_mods (update_clock ?f1 s2)))\n       (update_clock (\\<lambda>_. 0) s2),\n      Rval\n       (make_sem_env (nsLift mn (sem_env.v new_env))\n         (nsLift mn (c new_env))))", "apply (rule evaluate_top.tmod1[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n    [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. ?c2) s) \\<and>\n    no_dup_types ds \\<and>\n    evaluate_decs True [mn] env (update_clock (\\<lambda>_. ?c2) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env)", "using tmod1"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r =\n  Rval\n   (make_sem_env (nsLift mn (sem_env.v new_env)) (nsLift mn (c new_env)))\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env) \\<Longrightarrow>\n    [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. ?c2) s) \\<and>\n    no_dup_types ds \\<and>\n    evaluate_decs True [mn] env (update_clock (\\<lambda>_. ?c2) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rval new_env)", "by auto"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (3 subgoals):\n 1. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "case (tmod2 s2 ds mn specs err)"], ["proof (state)\nthis:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r = Rerr err\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rerr err)\n\ngoal (3 subgoals):\n 1. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r = Rerr err\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rerr err)", "obtain c where \"evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds (update_clock (\\<lambda>_. 0) s2, Rerr err)\""], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r = Rerr err\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rerr err)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n         (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using decs_add_clock assms"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r = Rerr err\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rerr err)\n  evaluate_decs ?ck ?mn ?env ?s ?ds ?res \\<Longrightarrow>\n  \\<forall>s' r.\n     ?res = (s', r) \\<and> ?ck = False \\<longrightarrow>\n     (\\<exists>c.\n         evaluate_decs True ?mn ?env (update_clock (\\<lambda>_. c) ?s) ?ds\n          (update_clock (\\<lambda>_. 0) s', r))\n  evaluate_top ck env s tp (s', r)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n         (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rerr err)\n\ngoal (3 subgoals):\n 1. \\<And>s2 ds mn specs err.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 3. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rerr err)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rerr err)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "unfolding tmod2"], ["proof (prove)\nusing this:\n  evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n   (update_clock (\\<lambda>_. 0) s2, Rerr err)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s)\n        (Tmod mn specs ds)\n        (update_clock (\\<lambda>_. 0)\n          (update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n            s2),\n         Rerr err)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s)\n        (Tmod mn specs ds)\n        (update_defined_mods (\\<lambda>_. insert [mn] (defined_mods s2))\n          (update_clock (\\<lambda>_. 0) s2),\n         Rerr err)", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s)\n        (Tmod mn specs ds)\n        (update_defined_mods\n          (\\<lambda>_. insert [mn] (defined_mods (update_clock ?f1 s2)))\n          (update_clock (\\<lambda>_. 0) s2),\n         Rerr err)", "apply rule+"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n    evaluate_top True env (update_clock (\\<lambda>_. ?c2) s)\n     (Tmod mn specs ds)\n     (update_defined_mods\n       (\\<lambda>_. insert [mn] (defined_mods (update_clock ?f1 s2)))\n       (update_clock (\\<lambda>_. 0) s2),\n      Rerr err)", "apply (rule evaluate_top.tmod2[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n    [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. ?c2) s) \\<and>\n    no_dup_types ds \\<and>\n    evaluate_decs True [mn] env (update_clock (\\<lambda>_. ?c2) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err)", "using tmod2"], ["proof (prove)\nusing this:\n  tp = Tmod mn specs ds\n  s' = update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2) s2\n  r = Rerr err\n  [mn] \\<notin> defined_mods s \\<and>\n  no_dup_types ds \\<and> evaluate_decs ck [mn] env s ds (s2, Rerr err)\n\ngoal (1 subgoal):\n 1. evaluate_decs True [mn] env (update_clock (\\<lambda>_. c) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err) \\<Longrightarrow>\n    [mn] \\<notin> defined_mods (update_clock (\\<lambda>_. ?c2) s) \\<and>\n    no_dup_types ds \\<and>\n    evaluate_decs True [mn] env (update_clock (\\<lambda>_. ?c2) s) ds\n     (update_clock (\\<lambda>_. 0) s2, Rerr err)", "by auto"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (2 subgoals):\n 1. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "case tmod3"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  \\<not> no_dup_types ds_\n\ngoal (2 subgoals):\n 1. \\<And>ds mn specs.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  \\<not> no_dup_types ds_", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  \\<not> no_dup_types ds_\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "by (auto intro:evaluate_top.intros)"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (1 subgoal):\n 1. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "case tmod4"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  [mn_] \\<in> defined_mods s\n\ngoal (1 subgoal):\n 1. \\<And>mn specs ds.\n       \\<lbrakk>\\<not> ck; tp = Tmod mn specs ds; s' = s;\n        r = Rerr (Rabort Rtype_error); [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_top True env\n                             (update_clock (\\<lambda>_. c) s) tp\n                             (update_clock (\\<lambda>_. 0) s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  [mn_] \\<in> defined_mods s", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' = s\n  r = Rerr (Rabort Rtype_error)\n  [mn_] \\<in> defined_mods s\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r)", "unfolding tmod4"], ["proof (prove)\nusing this:\n  Tmod mn_ specs_ ds_ = Tmod mn_ specs_ ds_\n  s = s\n  Rerr (Rabort Rtype_error) = Rerr (Rabort Rtype_error)\n  [mn_] \\<in> defined_mods s\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s)\n        (Tmod mn_ specs_ ds_)\n        (update_clock (\\<lambda>_. 0) s, Rerr (Rabort Rtype_error))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tmod mn_ specs_ ds_ = Tmod mn_ specs_ ds_; s = s;\n     Rerr (Rabort Rtype_error) = Rerr (Rabort Rtype_error);\n     [mn_] \\<in> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_top True env\n                          (update_clock (\\<lambda>_. c) s)\n                          (Tmod mn_ specs_ ds_)\n                          (update_clock (\\<lambda>_. 0) s,\n                           Rerr (Rabort Rtype_error))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tmod mn_ specs_ ds_ = Tmod mn_ specs_ ds_; s = s;\n     Rerr (Rabort Rtype_error) = Rerr (Rabort Rtype_error);\n     [mn_] \\<in> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. ?c4) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_clock (\\<lambda>_. 0) s,\n                        Rerr (Rabort Rtype_error))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Tmod mn_ specs_ ds_ = Tmod mn_ specs_ ds_; s = s;\n     Rerr (Rabort Rtype_error) = Rerr (Rabort Rtype_error);\n     [mn_] \\<in> defined_mods s\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<in> defined_mods (update_clock (\\<lambda>_. 0) s)", "by simp"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_clocked_unclocked_equiv:\n  \"evaluate_top False env s tp (s',r) =\n  (\\<exists>c. evaluate_top True env (s \\<lparr> clock := c \\<rparr>) tp ((s' \\<lparr> clock := 0 \\<rparr>),r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       (clock s) = (clock s'))\" (is \"?P = ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r) =\n    (\\<exists>c.\n        evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n         (update_clock (\\<lambda>_. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. evaluate_top False env s tp (s', r) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_top False env s tp (s', r)", "assume ?P"], ["proof (state)\nthis:\n  evaluate_top False env s tp (s', r)\n\ngoal (2 subgoals):\n 1. evaluate_top False env s tp (s', r) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_top False env s tp (s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_top False env s tp (s', r)", "show ?Q"], ["proof (prove)\nusing this:\n  evaluate_top False env s tp (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "by (auto simp add:top_add_clock top_unclocked dest:top_evaluate_not_timeout)"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_top False env s tp (s', r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_top False env s tp (s', r)", "assume ?Q"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_top False env s tp (s', r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "show ?P"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r)", "using top_unclocked_ignore"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r)", "(* sledgehammer proof *)"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n                 (update_clock (\\<lambda>_. 0) s', r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s = clock s';\n     \\<And>ck env s tp s' r cnt.\n        \\<lbrakk>evaluate_top ck env s tp (s', r);\n         r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n        \\<Longrightarrow> evaluate_top False env\n                           (update_clock (\\<lambda>_. cnt) s) tp\n                           (update_clock (\\<lambda>_. cnt) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env s tp (s', r)", "obtain nn :: nat where\n      f1: \"evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp (update_clock (\\<lambda>n. 0) s', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n         (update_clock (\\<lambda>n. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        clock s = clock s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<exists>c. evaluate_top True env (update_clock (\\<lambda>_. c) s) tp (update_clock (\\<lambda>_. 0) s', r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n         (update_clock (\\<lambda>n. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n        clock s = clock s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n   (update_clock (\\<lambda>n. 0) s', r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n                 (update_clock (\\<lambda>_. 0) s', r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s = clock s';\n     \\<And>ck env s tp s' r cnt.\n        \\<lbrakk>evaluate_top ck env s tp (s', r);\n         r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n        \\<Longrightarrow> evaluate_top False env\n                           (update_clock (\\<lambda>_. cnt) s) tp\n                           (update_clock (\\<lambda>_. cnt) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env s tp (s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n   (update_clock (\\<lambda>n. 0) s', r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "have \"\\<forall>n. evaluate_top False env (update_clock (\\<lambda>na. n) s) tp (update_clock (\\<lambda>na. n) s', r)\""], ["proof (prove)\nusing this:\n  evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n   (update_clock (\\<lambda>n. 0) s', r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       evaluate_top False env (update_clock (\\<lambda>na. n) s) tp\n        (update_clock (\\<lambda>na. n) s', r)", "using top_unclocked_ignore"], ["proof (prove)\nusing this:\n  evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n   (update_clock (\\<lambda>n. 0) s', r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       evaluate_top False env (update_clock (\\<lambda>na. n) s) tp\n        (update_clock (\\<lambda>na. n) s', r)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>n.\n     evaluate_top False env (update_clock (\\<lambda>na. n) s) tp\n      (update_clock (\\<lambda>na. n) s', r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c.\n                evaluate_top True env (update_clock (\\<lambda>_. c) s) tp\n                 (update_clock (\\<lambda>_. 0) s', r) \\<and>\n                r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                clock s = clock s';\n     \\<And>ck env s tp s' r cnt.\n        \\<lbrakk>evaluate_top ck env s tp (s', r);\n         r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n        \\<Longrightarrow> evaluate_top False env\n                           (update_clock (\\<lambda>_. cnt) s) tp\n                           (update_clock (\\<lambda>_. cnt) s', r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top False env s tp (s', r)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     evaluate_top False env (update_clock (\\<lambda>na. n) s) tp\n      (update_clock (\\<lambda>na. n) s', r)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     evaluate_top False env (update_clock (\\<lambda>na. n) s) tp\n      (update_clock (\\<lambda>na. n) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r)", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     evaluate_top False env (update_clock (\\<lambda>na. n) s) tp\n      (update_clock (\\<lambda>na. n) s', r)\n  evaluate_top True env (update_clock (\\<lambda>n. nn) s) tp\n   (update_clock (\\<lambda>n. 0) s', r) \\<and>\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. evaluate_top False env s tp (s', r)", "by (metis state.record_simps(7))"], ["proof (state)\nthis:\n  evaluate_top False env s tp (s', r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_top False env s tp (s', r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_clock_monotone:\n  \"evaluate_top ck env s tp (s',r) \\<Longrightarrow> ck = True \\<Longrightarrow> (clock   s') \\<le> (clock   s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_top ck env s tp (s', r); ck = True\\<rbrakk>\n    \\<Longrightarrow> clock s' \\<le> clock s", "by (ind_cases \"evaluate_top ck env s tp (s',r)\") (fastforce dest:dec_clock_monotone decs_clock_monotone)+"], ["", "lemma top_sub_from_counter:\n  assumes \"evaluate_top ck env s tp (s',r)\" \"ck = True\" \"(clock   s) = cnt + extra\" \"(clock   s') = cnt' + extra\"\n  shows \"evaluate_top ck env (s (| clock := cnt |)) tp ((s' (| clock := cnt' |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt') s', r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top ck env s tp (s', r)\n  ck = True\n  clock s = cnt + extra\n  clock s' = cnt' + extra\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt') s', r)", "proof (cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)", "case tmod1"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\n\ngoal (6 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt') s', r)", "using assms"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs ck [mn_] env s ds_ (s2_, Rval new_env_)\n  evaluate_top ck env s tp (s', r)\n  ck = True\n  clock s = cnt + extra\n  clock s' = cnt' + extra\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt') s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rval\n        (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n          (nsLift mn_ (c new_env_))));\n     ck; clock s = cnt + extra; clock s2_ = cnt' + extra;\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. cnt) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. cnt') s2_),\n                        Rval\n                         (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n                           (nsLift mn_ (c new_env_))))", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rval\n        (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n          (nsLift mn_ (c new_env_))));\n     ck; clock s = cnt + extra; clock s2_ = cnt' + extra;\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. cnt) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f10 s2_)))\n                         (update_clock (\\<lambda>_. cnt') s2_),\n                        Rval\n                         (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n                           (nsLift mn_ (c new_env_))))", "apply (rule evaluate_top.tmod1[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rval\n        (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n          (nsLift mn_ (c new_env_))));\n     ck; clock s = cnt + extra; clock s2_ = cnt' + extra;\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock (\\<lambda>_. cnt) s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs True [mn_] env\n                       (update_clock (\\<lambda>_. cnt) s) ds_\n                       (update_clock (\\<lambda>_. cnt') s2_, Rval new_env_)", "by (auto dest:decs_sub_from_counter)"], ["proof (state)\nthis:\n  evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n   (update_clock (\\<lambda>_. cnt') s', r)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)", "case tmod2"], ["proof (state)\nthis:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (5 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs ck [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)", "then"], ["proof (chain)\npicking this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)", "show ?thesis"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt') s', r)", "using assms"], ["proof (prove)\nusing this:\n  tp = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and> evaluate_decs ck [mn_] env s ds_ (s2_, Rerr err_)\n  evaluate_top ck env s tp (s', r)\n  ck = True\n  clock s = cnt + extra\n  clock s' = cnt' + extra\n\ngoal (1 subgoal):\n 1. evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n     (update_clock (\\<lambda>_. cnt') s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     ck; clock s = cnt + extra; clock s2_ = cnt' + extra;\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. cnt) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. cnt') s2_),\n                        Rerr err_)", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     ck; clock s = cnt + extra; clock s2_ = cnt' + extra;\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. cnt) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f10 s2_)))\n                         (update_clock (\\<lambda>_. cnt') s2_),\n                        Rerr err_)", "apply (rule evaluate_top.tmod2[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     ck; clock s = cnt + extra; clock s2_ = cnt' + extra;\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock (\\<lambda>_. cnt) s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs True [mn_] env\n                       (update_clock (\\<lambda>_. cnt) s) ds_\n                       (update_clock (\\<lambda>_. cnt') s2_, Rerr err_)", "by (auto dest:decs_sub_from_counter)"], ["proof (state)\nthis:\n  evaluate_top ck env (update_clock (\\<lambda>_. cnt) s) tp\n   (update_clock (\\<lambda>_. cnt') s', r)\n\ngoal (4 subgoals):\n 1. \\<And>d new_env.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rval new_env;\n        evaluate_dec ck [] env s d (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>d err.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tdec d; r = Rerr err;\n        evaluate_dec ck [] env s d (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>ck = True; clock s = cnt + extra; clock s' = cnt' + extra;\n        tp = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top ck env\n                          (update_clock (\\<lambda>_. cnt) s) tp\n                          (update_clock (\\<lambda>_. cnt') s', r)", "qed (fastforce intro:evaluate_top.intros simp add:dec_sub_from_counter)+"], ["", "lemma top_add_to_counter:\n  assumes \"evaluate_top True env s d (s',r)\" \"r \\<noteq> Rerr (Rabort Rtimeout_error)\"\n  shows \"evaluate_top True env (s (| clock := (clock   s) + extra |)) d ((s' (| clock := (clock   s') + extra |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n     (update_clock (\\<lambda>_. clock s' + extra) s', r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_top True env s d (s', r)\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n     (update_clock (\\<lambda>_. clock s' + extra) s', r)", "proof cases"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>da new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rval new_env;\n        evaluate_dec True [] env s da (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 2. \\<And>da err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rerr err; evaluate_dec True [] env s da (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)", "case tmod1"], ["proof (state)\nthis:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\n\ngoal (6 subgoals):\n 1. \\<And>da new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rval new_env;\n        evaluate_dec True [] env s da (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 2. \\<And>da err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rerr err; evaluate_dec True [] env s da (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 3. \\<And>s2 ds mn specs new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r =\n        Rval\n         (make_sem_env (nsLift mn (sem_env.v new_env))\n           (nsLift mn (c new_env)));\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 4. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 5. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 6. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)", "then"], ["proof (chain)\npicking this:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)", "show ?thesis"], ["proof (prove)\nusing this:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r =\n  Rval\n   (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n     (nsLift mn_ (c new_env_)))\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\n\ngoal (1 subgoal):\n 1. evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n     (update_clock (\\<lambda>_. clock s' + extra) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. clock s + extra) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. clock s2_ + extra) s2_),\n                        Rval\n                         (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n                           (nsLift mn_ (c new_env_))))", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. clock s + extra) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f6 s2_)))\n                         (update_clock (\\<lambda>_. clock s2_ + extra) s2_),\n                        Rval\n                         (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n                           (nsLift mn_ (c new_env_))))", "apply (rule evaluate_top.tmod1[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r =\n     Rval\n      (make_sem_env (nsLift mn_ (sem_env.v new_env_))\n        (nsLift mn_ (c new_env_)));\n     [mn_] \\<notin> defined_mods s; no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock (\\<lambda>_. clock s + extra)\n                                  s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs True [mn_] env\n                       (update_clock (\\<lambda>_. clock s + extra) s) ds_\n                       (update_clock (\\<lambda>_. clock s2_ + extra) s2_,\n                        Rval new_env_)", "by (auto dest:decs_add_to_counter)"], ["proof (state)\nthis:\n  evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n   (update_clock (\\<lambda>_. clock s' + extra) s', r)\n\ngoal (5 subgoals):\n 1. \\<And>da new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rval new_env;\n        evaluate_dec True [] env s da (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 2. \\<And>da err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rerr err; evaluate_dec True [] env s da (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>da new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rval new_env;\n        evaluate_dec True [] env s da (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 2. \\<And>da err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rerr err; evaluate_dec True [] env s da (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)", "case tmod2"], ["proof (state)\nthis:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (5 subgoals):\n 1. \\<And>da new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rval new_env;\n        evaluate_dec True [] env s da (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 2. \\<And>da err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rerr err; evaluate_dec True [] env s da (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 3. \\<And>s2 ds mn specs err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds;\n        s' =\n        update_defined_mods (\\<lambda>_. {[mn]} \\<union> defined_mods s2)\n         s2;\n        r = Rerr err;\n        [mn] \\<notin> defined_mods s \\<and>\n        no_dup_types ds \\<and>\n        evaluate_decs True [mn] env s ds (s2, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 4. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 5. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)", "then"], ["proof (chain)\npicking this:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)", "show ?thesis"], ["proof (prove)\nusing this:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\n\ngoal (1 subgoal):\n 1. evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n     (update_clock (\\<lambda>_. clock s' + extra) s', r)", "using assms"], ["proof (prove)\nusing this:\n  d = Tmod mn_ specs_ ds_\n  s' =\n  update_defined_mods (\\<lambda>_. {[mn_]} \\<union> defined_mods s2_) s2_\n  r = Rerr err_\n  [mn_] \\<notin> defined_mods s \\<and>\n  no_dup_types ds_ \\<and>\n  evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\n  evaluate_top True env s d (s', r)\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n     (update_clock (\\<lambda>_. clock s' + extra) s', r)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     err_ \\<noteq> Rabort Rtimeout_error; [mn_] \\<notin> defined_mods s;\n     no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. clock s + extra) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_. insert [mn_] (defined_mods s2_))\n                         (update_clock (\\<lambda>_. clock s2_ + extra) s2_),\n                        Rerr err_)", "apply (subst state.record_simps(5)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     err_ \\<noteq> Rabort Rtimeout_error; [mn_] \\<notin> defined_mods s;\n     no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. clock s + extra) s)\n                       (Tmod mn_ specs_ ds_)\n                       (update_defined_mods\n                         (\\<lambda>_.\n                             insert [mn_]\n                              (defined_mods (update_clock ?f8 s2_)))\n                         (update_clock (\\<lambda>_. clock s2_ + extra) s2_),\n                        Rerr err_)", "apply (rule evaluate_top.tmod2[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = Tmod mn_ specs_ ds_;\n     s' =\n     update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_)) s2_;\n     r = Rerr err_;\n     evaluate_top True env s (Tmod mn_ specs_ ds_)\n      (update_defined_mods (\\<lambda>_. insert [mn_] (defined_mods s2_))\n        s2_,\n       Rerr err_);\n     err_ \\<noteq> Rabort Rtimeout_error; [mn_] \\<notin> defined_mods s;\n     no_dup_types ds_;\n     evaluate_decs True [mn_] env s ds_ (s2_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> [mn_]\n                      \\<notin> defined_mods\n                                (update_clock (\\<lambda>_. clock s + extra)\n                                  s) \\<and>\n                      no_dup_types ds_ \\<and>\n                      evaluate_decs True [mn_] env\n                       (update_clock (\\<lambda>_. clock s + extra) s) ds_\n                       (update_clock (\\<lambda>_. clock s2_ + extra) s2_,\n                        Rerr err_)", "by (auto dest:decs_add_to_counter)"], ["proof (state)\nthis:\n  evaluate_top True env (update_clock (\\<lambda>_. clock s + extra) s) d\n   (update_clock (\\<lambda>_. clock s' + extra) s', r)\n\ngoal (4 subgoals):\n 1. \\<And>da new_env.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rval new_env;\n        evaluate_dec True [] env s da (s', Rval new_env)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 2. \\<And>da err.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error); d = Tdec da;\n        r = Rerr err; evaluate_dec True [] env s da (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 3. \\<And>ds mn specs.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        \\<not> no_dup_types ds\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)\n 4. \\<And>mn specs ds.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        d = Tmod mn specs ds; s' = s; r = Rerr (Rabort Rtype_error);\n        [mn] \\<in> defined_mods s\\<rbrakk>\n       \\<Longrightarrow> evaluate_top True env\n                          (update_clock (\\<lambda>_. clock s + extra) s) d\n                          (update_clock (\\<lambda>_. clock s' + extra) s',\n                           r)", "qed (fastforce intro:evaluate_top.intros dest:dec_add_to_counter)+"], ["", "lemma prog_clock_monotone:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> ck \\<Longrightarrow> (clock (fst res)) \\<le> (clock s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_prog ck env s prog res; ck\\<rbrakk>\n    \\<Longrightarrow> clock (fst res) \\<le> clock s", "by (induction rule:evaluate_prog.inducts) (auto dest:top_clock_monotone)"], ["", "lemma prog_unclocked_ignore:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> \\<forall>cnt s' r. res = (s',r) \\<and> r \\<noteq> Rerr (Rabort Rtimeout_error)\n    \\<longrightarrow> evaluate_prog False env (s (| clock := cnt |)) prog ((s' (| clock := cnt |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog ck env s prog res \\<Longrightarrow>\n    \\<forall>cnt s' r.\n       res = (s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_prog False env (update_clock (\\<lambda>_. cnt) s) prog\n        (update_clock (\\<lambda>_. cnt) s', r)", "by (induction rule:evaluate_prog.inducts) (auto intro!:evaluate_prog.intros dest:top_unclocked_ignore)"], ["", "lemma prog_unclocked_unchanged:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> \\<not>ck \\<Longrightarrow>(snd res) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   (fst res)) = (clock s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_prog ck env s prog res; \\<not> ck\\<rbrakk>\n    \\<Longrightarrow> snd res \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                      clock (fst res) = clock s", "proof (induction rule:evaluate_prog.inducts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<not> ck \\<Longrightarrow>\n       snd (s, Rval (make_sem_env nsEmpty nsEmpty)) \\<noteq>\n       Rerr (Rabort Rtimeout_error) \\<and>\n       clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))) = clock s\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n                evaluate_prog ck (extend_dec_env new_env env) s2 tops\n                 (s3, r) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                 clock (fst (s3, r)) = clock s2);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s3, combine_dec_result new_env r) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s3, combine_dec_result new_env r)) =\n                         clock s1\n 3. \\<And>ck s1 s2 env top0 tops err.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s2, Rerr err) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s2, Rerr err)) = clock s1", "case (cons1 ck s1 s2 s3 env top0 tops new_env r)"], ["proof (state)\nthis:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck\n\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<not> ck \\<Longrightarrow>\n       snd (s, Rval (make_sem_env nsEmpty nsEmpty)) \\<noteq>\n       Rerr (Rabort Rtimeout_error) \\<and>\n       clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))) = clock s\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n                evaluate_prog ck (extend_dec_env new_env env) s2 tops\n                 (s3, r) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                 clock (fst (s3, r)) = clock s2);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s3, combine_dec_result new_env r) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s3, combine_dec_result new_env r)) =\n                         clock s1\n 3. \\<And>ck s1 s2 env top0 tops err.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s2, Rerr err) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s2, Rerr err)) = clock s1", "then"], ["proof (chain)\npicking this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck", "have \"r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\nusing this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "by simp"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<not> ck \\<Longrightarrow>\n       snd (s, Rval (make_sem_env nsEmpty nsEmpty)) \\<noteq>\n       Rerr (Rabort Rtimeout_error) \\<and>\n       clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))) = clock s\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n                evaluate_prog ck (extend_dec_env new_env env) s2 tops\n                 (s3, r) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                 clock (fst (s3, r)) = clock s2);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s3, combine_dec_result new_env r) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s3, combine_dec_result new_env r)) =\n                         clock s1\n 3. \\<And>ck s1 s2 env top0 tops err.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s2, Rerr err) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s2, Rerr err)) = clock s1", "moreover"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<not> ck \\<Longrightarrow>\n       snd (s, Rval (make_sem_env nsEmpty nsEmpty)) \\<noteq>\n       Rerr (Rabort Rtimeout_error) \\<and>\n       clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))) = clock s\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n                evaluate_prog ck (extend_dec_env new_env env) s2 tops\n                 (s3, r) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                 clock (fst (s3, r)) = clock s2);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s3, combine_dec_result new_env r) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s3, combine_dec_result new_env r)) =\n                         clock s1\n 3. \\<And>ck s1 s2 env top0 tops err.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s2, Rerr err) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s2, Rerr err)) = clock s1", "from cons1"], ["proof (chain)\npicking this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck", "have \"clock s1 = clock s2\""], ["proof (prove)\nusing this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. clock s1 = clock s2", "using top_unclocked"], ["proof (prove)\nusing this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck\n  (evaluate_top False ?env ?s ?tp (?s', ?r) \\<longrightarrow>\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock ?s = clock ?s') \\<and>\n  evaluate_top False ?env (update_clock (\\<lambda>_. ?count1.0) ?s) ?tp\n   (update_clock (\\<lambda>_. ?count1.0) ?s', ?r) =\n  evaluate_top False ?env (update_clock (\\<lambda>_. ?count2.0) ?s) ?tp\n   (update_clock (\\<lambda>_. ?count2.0) ?s', ?r)\n\ngoal (1 subgoal):\n 1. clock s1 = clock s2", "by force"], ["proof (state)\nthis:\n  clock s1 = clock s2\n\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<not> ck \\<Longrightarrow>\n       snd (s, Rval (make_sem_env nsEmpty nsEmpty)) \\<noteq>\n       Rerr (Rabort Rtimeout_error) \\<and>\n       clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))) = clock s\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n                evaluate_prog ck (extend_dec_env new_env env) s2 tops\n                 (s3, r) \\<and>\n                (\\<not> ck \\<longrightarrow>\n                 snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                 clock (fst (s3, r)) = clock s2);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s3, combine_dec_result new_env r) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s3, combine_dec_result new_env r)) =\n                         clock s1\n 3. \\<And>ck s1 s2 env top0 tops err.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s2, Rerr err) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s2, Rerr err)) = clock s1", "ultimately"], ["proof (chain)\npicking this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  clock s1 = clock s2", "show ?case"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  clock s1 = clock s2\n\ngoal (1 subgoal):\n 1. snd (s3, combine_dec_result new_env r) \\<noteq>\n    Rerr (Rabort Rtimeout_error) \\<and>\n    clock (fst (s3, combine_dec_result new_env r)) = clock s1", "using combine_dec_result.simps cons1"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  clock s1 = clock s2\n  combine_dec_result ?env (Rerr ?e) = Rerr ?e\n  combine_dec_result ?env (Rval ?env') =\n  Rval\n   (make_sem_env (nsAppend (sem_env.v ?env') (sem_env.v ?env))\n     (nsAppend (c ?env') (c ?env)))\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<not> ck \\<longrightarrow>\n   snd (s3, r) \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock (fst (s3, r)) = clock s2)\n  \\<not> ck\n\ngoal (1 subgoal):\n 1. snd (s3, combine_dec_result new_env r) \\<noteq>\n    Rerr (Rabort Rtimeout_error) \\<and>\n    clock (fst (s3, combine_dec_result new_env r)) = clock s1", "by (cases r;auto)"], ["proof (state)\nthis:\n  snd (s3, combine_dec_result new_env r) \\<noteq>\n  Rerr (Rabort Rtimeout_error) \\<and>\n  clock (fst (s3, combine_dec_result new_env r)) = clock s1\n\ngoal (2 subgoals):\n 1. \\<And>ck env s.\n       \\<not> ck \\<Longrightarrow>\n       snd (s, Rval (make_sem_env nsEmpty nsEmpty)) \\<noteq>\n       Rerr (Rabort Rtimeout_error) \\<and>\n       clock (fst (s, Rval (make_sem_env nsEmpty nsEmpty))) = clock s\n 2. \\<And>ck s1 s2 env top0 tops err.\n       \\<lbrakk>evaluate_top ck env s1 top0 (s2, Rerr err);\n        \\<not> ck\\<rbrakk>\n       \\<Longrightarrow> snd (s2, Rerr err) \\<noteq>\n                         Rerr (Rabort Rtimeout_error) \\<and>\n                         clock (fst (s2, Rerr err)) = clock s1", "qed (auto simp add: top_clocked_unclocked_equiv)"], ["", "private"], ["", "lemma prog_unclocked_1:\n  assumes \"evaluate_prog False env s prog (s',r)\"\n  shows \"r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s = clock s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "from assms"], ["proof (chain)\npicking this:\n  evaluate_prog False env s prog (s', r)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_prog False env s prog (s', r)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "using prog_unclocked_unchanged"], ["proof (prove)\nusing this:\n  evaluate_prog False env s prog (s', r)\n  \\<lbrakk>evaluate_prog ?ck ?env ?s ?prog ?res; \\<not> ?ck\\<rbrakk>\n  \\<Longrightarrow> snd ?res \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n                    clock (fst ?res) = clock ?s\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "by fastforce"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma prog_unclocked_2:\n  assumes \"evaluate_prog False env (s \\<lparr> clock := cnt1 \\<rparr>) prog (s' \\<lparr> clock := cnt1 \\<rparr>,r)\"\n  shows \"evaluate_prog False env (s \\<lparr> clock := cnt2 \\<rparr>) prog (s' \\<lparr> clock := cnt2 \\<rparr>,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "from assms"], ["proof (chain)\npicking this:\n  evaluate_prog False env (update_clock (\\<lambda>_. cnt1) s) prog\n   (update_clock (\\<lambda>_. cnt1) s', r)", "have \"r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\nusing this:\n  evaluate_prog False env (update_clock (\\<lambda>_. cnt1) s) prog\n   (update_clock (\\<lambda>_. cnt1) s', r)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "using prog_unclocked_1"], ["proof (prove)\nusing this:\n  evaluate_prog False env (update_clock (\\<lambda>_. cnt1) s) prog\n   (update_clock (\\<lambda>_. cnt1) s', r)\n  evaluate_prog False ?env ?s ?prog (?s', ?r) \\<Longrightarrow>\n  ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock ?s = clock ?s'\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "using prog_unclocked_ignore assms"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate_prog ?ck ?env ?s ?prog ?res \\<Longrightarrow>\n  \\<forall>cnt s' r.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_prog False ?env (update_clock (\\<lambda>_. cnt) ?s) ?prog\n      (update_clock (\\<lambda>_. cnt) s', r)\n  evaluate_prog False env (update_clock (\\<lambda>_. cnt1) s) prog\n   (update_clock (\\<lambda>_. cnt1) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "by fastforce"], ["proof (state)\nthis:\n  evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n   (update_clock (\\<lambda>_. cnt2) s', r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prog_unclocked:\n  \"(evaluate_prog False env s prog (s',r) \\<longrightarrow> r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock s = clock s')) \\<and>\n   (evaluate_prog False env (s \\<lparr> clock := cnt1 \\<rparr>) prog (s' \\<lparr> clock := cnt1 \\<rparr>,r) =\n   evaluate_prog False env (s \\<lparr> clock := cnt2 \\<rparr>) prog (s' \\<lparr> clock := cnt2 \\<rparr>,r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evaluate_prog False env s prog (s', r) \\<longrightarrow>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n     clock s = clock s') \\<and>\n    evaluate_prog False env (update_clock (\\<lambda>_. cnt1) s) prog\n     (update_clock (\\<lambda>_. cnt1) s', r) =\n    evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "using prog_unclocked_1 prog_unclocked_2"], ["proof (prove)\nusing this:\n  evaluate_prog False ?env ?s ?prog (?s', ?r) \\<Longrightarrow>\n  ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock ?s = clock ?s'\n  evaluate_prog False ?env (update_clock (\\<lambda>_. ?cnt1.0) ?s) ?prog\n   (update_clock (\\<lambda>_. ?cnt1.0) ?s', ?r) \\<Longrightarrow>\n  evaluate_prog False ?env (update_clock (\\<lambda>_. ?cnt2.0) ?s) ?prog\n   (update_clock (\\<lambda>_. ?cnt2.0) ?s', ?r)\n\ngoal (1 subgoal):\n 1. (evaluate_prog False env s prog (s', r) \\<longrightarrow>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n     clock s = clock s') \\<and>\n    evaluate_prog False env (update_clock (\\<lambda>_. cnt1) s) prog\n     (update_clock (\\<lambda>_. cnt1) s', r) =\n    evaluate_prog False env (update_clock (\\<lambda>_. cnt2) s) prog\n     (update_clock (\\<lambda>_. cnt2) s', r)", "by blast"], ["", "lemma not_evaluate_prog_timeout:\n  assumes \"\\<forall>res. \\<not>evaluate_prog False env s prog res\"\n  shows \"\\<exists>r. evaluate_prog True env s prog r \\<and> snd r = Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>res. \\<not> evaluate_prog False env s prog res\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof (induction prog arbitrary:env s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>env s.\n       \\<forall>res.\n          \\<not> evaluate_prog False env s [] res \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_prog True env s [] r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>a prog env s.\n       \\<lbrakk>\\<And>env s.\n                   \\<forall>res.\n                      \\<not> evaluate_prog False env s prog\n                              res \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_prog True env s prog r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>res.\n           \\<not> evaluate_prog False env s (a # prog) res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (a # prog) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>res. \\<not> evaluate_prog False env s [] res\n\ngoal (2 subgoals):\n 1. \\<And>env s.\n       \\<forall>res.\n          \\<not> evaluate_prog False env s [] res \\<Longrightarrow>\n       \\<exists>r.\n          evaluate_prog True env s [] r \\<and>\n          snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>a prog env s.\n       \\<lbrakk>\\<And>env s.\n                   \\<forall>res.\n                      \\<not> evaluate_prog False env s prog\n                              res \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_prog True env s prog r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>res.\n           \\<not> evaluate_prog False env s (a # prog) res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (a # prog) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<forall>res. \\<not> evaluate_prog False env s [] res", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>res. \\<not> evaluate_prog False env s [] res\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s [] r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using evaluate_prog.intros(1)"], ["proof (prove)\nusing this:\n  \\<forall>res. \\<not> evaluate_prog False env s [] res\n  evaluate_prog ?ck ?env ?s [] (?s, Rval (make_sem_env nsEmpty nsEmpty))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s [] r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_prog True env s [] r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>a prog env s.\n       \\<lbrakk>\\<And>env s.\n                   \\<forall>res.\n                      \\<not> evaluate_prog False env s prog\n                              res \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_prog True env s prog r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>res.\n           \\<not> evaluate_prog False env s (a # prog) res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (a # prog) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a prog env s.\n       \\<lbrakk>\\<And>env s.\n                   \\<forall>res.\n                      \\<not> evaluate_prog False env s prog\n                              res \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_prog True env s prog r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>res.\n           \\<not> evaluate_prog False env s (a # prog) res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (a # prog) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case (Cons top0 tops)"], ["proof (state)\nthis:\n  \\<forall>res.\n     \\<not> evaluate_prog False ?env ?s tops res \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_prog True ?env ?s tops r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>res. \\<not> evaluate_prog False env s (top0 # tops) res\n\ngoal (1 subgoal):\n 1. \\<And>a prog env s.\n       \\<lbrakk>\\<And>env s.\n                   \\<forall>res.\n                      \\<not> evaluate_prog False env s prog\n                              res \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_prog True env s prog r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>res.\n           \\<not> evaluate_prog False env s (a # prog) res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (a # prog) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "obtain s' r where top0:\"evaluate_top True env s top0 (s',r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_top True env s top0 (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using top_clocked_total[simplified]"], ["proof (prove)\nusing this:\n  \\<exists>a b. evaluate_top True ?env ?s ?tp (a, b)\n\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_top True env s top0 (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  evaluate_top True env s top0 (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>a prog env s.\n       \\<lbrakk>\\<And>env s.\n                   \\<forall>res.\n                      \\<not> evaluate_prog False env s prog\n                              res \\<Longrightarrow>\n                   \\<exists>r.\n                      evaluate_prog True env s prog r \\<and>\n                      snd r = Rerr (Rabort Rtimeout_error);\n        \\<forall>res.\n           \\<not> evaluate_prog False env s (a # prog) res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (a # prog) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  evaluate_top True env s top0 (s', r)", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_top True env s top0 (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case (Rval new_env)"], ["proof (state)\nthis:\n  r = Rval new_env\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "have \"\\<not> evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)\" for s3 r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_prog False (extend_dec_env new_env env) s' tops\n     (s3, r) \\<Longrightarrow>\n    False", "assume tops:\"evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)\""], ["proof (state)\nthis:\n  evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)\n\ngoal (1 subgoal):\n 1. evaluate_prog False (extend_dec_env new_env env) s' tops\n     (s3, r) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)", "have \"r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (prove)\nusing this:\n  evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "using prog_unclocked"], ["proof (prove)\nusing this:\n  evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)\n  (evaluate_prog False ?env ?s ?prog (?s', ?r) \\<longrightarrow>\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n   clock ?s = clock ?s') \\<and>\n  evaluate_prog False ?env (update_clock (\\<lambda>_. ?cnt1.0) ?s) ?prog\n   (update_clock (\\<lambda>_. ?cnt1.0) ?s', ?r) =\n  evaluate_prog False ?env (update_clock (\\<lambda>_. ?cnt2.0) ?s) ?prog\n   (update_clock (\\<lambda>_. ?cnt2.0) ?s', ?r)\n\ngoal (1 subgoal):\n 1. r \\<noteq> Rerr (Rabort Rtimeout_error)", "by fastforce"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_prog False (extend_dec_env new_env env) s' tops\n     (s3, r) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. evaluate_prog False (extend_dec_env new_env env) s' tops\n     (s3, r) \\<Longrightarrow>\n    False", "from top0"], ["proof (chain)\npicking this:\n  evaluate_top True env s top0 (s', r__)", "have \"evaluate_top False env s top0 (update_clock (\\<lambda>_. clock s) s', Rval new_env)\""], ["proof (prove)\nusing this:\n  evaluate_top True env s top0 (s', r__)\n\ngoal (1 subgoal):\n 1. evaluate_top False env s top0\n     (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "unfolding Rval"], ["proof (prove)\nusing this:\n  evaluate_top True env s top0 (s', Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_top False env s top0\n     (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "using top_unclocked_ignore"], ["proof (prove)\nusing this:\n  evaluate_top True env s top0 (s', Rval new_env)\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n\ngoal (1 subgoal):\n 1. evaluate_top False env s top0\n     (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "by (metis (full_types) result.distinct(1) state.record_simps(7))"], ["proof (state)\nthis:\n  evaluate_top False env s top0\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)\n\ngoal (1 subgoal):\n 1. evaluate_prog False (extend_dec_env new_env env) s' tops\n     (s3, r) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate_top False env s top0\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)", "show False"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate_top False env s top0\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)\n\ngoal (1 subgoal):\n 1. False", "using prog_unclocked_ignore[rule_format] Cons.prems evaluate_prog.cons1 tops"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate_top False env s top0\n   (update_clock (\\<lambda>_. clock s) s', Rval new_env)\n  \\<lbrakk>evaluate_prog ?ck ?env ?s ?prog ?res;\n   ?res = (?s', ?r) \\<and> ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_prog False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?prog\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n  \\<forall>res. \\<not> evaluate_prog False env s (top0 # tops) res\n  evaluate_top ?ck ?env ?s1.0 ?top0.0 (?s2.0, Rval ?new_env) \\<and>\n  evaluate_prog ?ck (extend_dec_env ?new_env ?env) ?s2.0 ?tops\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_prog ?ck ?env ?s1.0 (?top0.0 # ?tops)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  evaluate_prog False (extend_dec_env new_env env) s' tops (s3, r)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> evaluate_prog False (extend_dec_env new_env env) s' tops\n          (?s3.0, ?r)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  \\<not> evaluate_prog False (extend_dec_env new_env env) s' tops\n          (?s3.0, ?r)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> evaluate_prog False (extend_dec_env new_env env) s' tops\n          (?s3.0, ?r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using Cons.IH[simplified] evaluate_prog.cons1 top0"], ["proof (prove)\nusing this:\n  \\<not> evaluate_prog False (extend_dec_env new_env env) s' tops\n          (?s3.0, ?r)\n  \\<forall>a b.\n     \\<not> evaluate_prog False ?env ?s tops (a, b) \\<Longrightarrow>\n  \\<exists>a.\n     evaluate_prog True ?env ?s tops (a, Rerr (Rabort Rtimeout_error))\n  evaluate_top ?ck ?env ?s1.0 ?top0.0 (?s2.0, Rval ?new_env) \\<and>\n  evaluate_prog ?ck (extend_dec_env ?new_env ?env) ?s2.0 ?tops\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_prog ?ck ?env ?s1.0 (?top0.0 # ?tops)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  evaluate_top True env s top0 (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "unfolding Rval"], ["proof (prove)\nusing this:\n  \\<not> evaluate_prog False (extend_dec_env new_env env) s' tops\n          (?s3.0, ?r)\n  \\<forall>a b.\n     \\<not> evaluate_prog False ?env ?s tops (a, b) \\<Longrightarrow>\n  \\<exists>a.\n     evaluate_prog True ?env ?s tops (a, Rerr (Rabort Rtimeout_error))\n  evaluate_top ?ck ?env ?s1.0 ?top0.0 (?s2.0, Rval ?new_env) \\<and>\n  evaluate_prog ?ck (extend_dec_env ?new_env ?env) ?s2.0 ?tops\n   (?s3.0, ?r) \\<Longrightarrow>\n  evaluate_prog ?ck ?env ?s1.0 (?top0.0 # ?tops)\n   (?s3.0, combine_dec_result ?new_env ?r)\n  evaluate_top True env s top0 (s', Rval new_env)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by (metis combine_dec_result.simps(1) snd_conv)"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_prog True env s (top0 # tops) r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "case (Rerr err)"], ["proof (state)\nthis:\n  r = Rerr err\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "have \"err = Rabort Rtimeout_error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. err = Rabort Rtimeout_error", "using Cons top0 top_unclocked_ignore"], ["proof (prove)\nusing this:\n  \\<forall>res.\n     \\<not> evaluate_prog False ?env ?s tops res \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_prog True ?env ?s tops r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>res. \\<not> evaluate_prog False env s (top0 # tops) res\n  evaluate_top True env s top0 (s', r)\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n\ngoal (1 subgoal):\n 1. err = Rabort Rtimeout_error", "unfolding Rerr"], ["proof (prove)\nusing this:\n  \\<forall>res.\n     \\<not> evaluate_prog False ?env ?s tops res \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_prog True ?env ?s tops r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>res. \\<not> evaluate_prog False env s (top0 # tops) res\n  evaluate_top True env s top0 (s', Rerr err)\n  \\<lbrakk>evaluate_top ?ck ?env ?s ?tp (?s', ?r);\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error)\\<rbrakk>\n  \\<Longrightarrow> evaluate_top False ?env\n                     (update_clock (\\<lambda>_. ?cnt) ?s) ?tp\n                     (update_clock (\\<lambda>_. ?cnt) ?s', ?r)\n\ngoal (1 subgoal):\n 1. err = Rabort Rtimeout_error", "by (metis evaluate_prog.cons2 result.inject(2) state.record_simps(7))"], ["proof (state)\nthis:\n  err = Rabort Rtimeout_error\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>evaluate_top True env s top0 (s', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            evaluate_prog True env s (top0 # tops) r \\<and>\n                            snd r = Rerr (Rabort Rtimeout_error)", "then"], ["proof (chain)\npicking this:\n  err = Rabort Rtimeout_error", "show ?thesis"], ["proof (prove)\nusing this:\n  err = Rabort Rtimeout_error\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using top0"], ["proof (prove)\nusing this:\n  err = Rabort Rtimeout_error\n  evaluate_top True env s top0 (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "unfolding Rerr"], ["proof (prove)\nusing this:\n  err = Rabort Rtimeout_error\n  evaluate_top True env s top0 (s', Rerr err)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_prog True env s (top0 # tops) r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by (meson evaluate_prog.cons2 snd_conv)"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_prog True env s (top0 # tops) r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_prog True env s (top0 # tops) r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_evaluate_whole_prog_timeout:\n  assumes \"\\<forall>res. \\<not>evaluate_whole_prog False env s prog res\"\n  shows \"\\<exists>r. evaluate_whole_prog True env s prog r \\<and> snd r = Rerr (Rabort Rtimeout_error)\" (is ?P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "show ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "apply (cases \"no_dup_mods prog (defined_mods s)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_dup_mods prog (defined_mods s) \\<Longrightarrow>\n    \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<not> no_dup_mods prog (defined_mods s) \\<Longrightarrow>\n    \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "apply (cases \"no_dup_top_types prog (defined_types s)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>no_dup_mods prog (defined_mods s);\n     no_dup_top_types prog (defined_types s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         evaluate_whole_prog True env s prog r \\<and>\n                         snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<lbrakk>no_dup_mods prog (defined_mods s);\n     \\<not> no_dup_top_types prog (defined_types s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         evaluate_whole_prog True env s prog r \\<and>\n                         snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<not> no_dup_mods prog (defined_mods s) \\<Longrightarrow>\n    \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "using not_evaluate_prog_timeout assms"], ["proof (prove)\nusing this:\n  \\<forall>res.\n     \\<not> evaluate_prog False ?env ?s ?prog res \\<Longrightarrow>\n  \\<exists>r.\n     evaluate_prog True ?env ?s ?prog r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n  \\<forall>res. \\<not> evaluate_whole_prog False env s prog res\n\ngoal (3 subgoals):\n 1. \\<lbrakk>no_dup_mods prog (defined_mods s);\n     no_dup_top_types prog (defined_types s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         evaluate_whole_prog True env s prog r \\<and>\n                         snd r = Rerr (Rabort Rtimeout_error)\n 2. \\<lbrakk>no_dup_mods prog (defined_mods s);\n     \\<not> no_dup_top_types prog (defined_types s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         evaluate_whole_prog True env s prog r \\<and>\n                         snd r = Rerr (Rabort Rtimeout_error)\n 3. \\<not> no_dup_mods prog (defined_mods s) \\<Longrightarrow>\n    \\<exists>r.\n       evaluate_whole_prog True env s prog r \\<and>\n       snd r = Rerr (Rabort Rtimeout_error)", "by fastforce+"], ["proof (state)\nthis:\n  \\<exists>r.\n     evaluate_whole_prog True env s prog r \\<and>\n     snd r = Rerr (Rabort Rtimeout_error)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prog_add_to_counter:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow> \\<forall>s' r extra. res = (s',r) \\<and> ck = True \\<and>  r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n    evaluate_prog True env (s (| clock := (clock   s) + extra |)) prog ((s' (| clock := (clock   s') + extra |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog ck env s prog res \\<Longrightarrow>\n    \\<forall>s' r extra.\n       res = (s', r) \\<and>\n       ck = True \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n       evaluate_prog True env (update_clock (\\<lambda>_. clock s + extra) s)\n        prog (update_clock (\\<lambda>_. clock s' + extra) s', r)", "by (induction rule:evaluate_prog.inducts) (auto intro!:evaluate_prog.intros dest:top_add_to_counter)"], ["", "lemma prog_sub_from_counter:\n  \"evaluate_prog ck env s prog res \\<Longrightarrow>\n   \\<forall>extra cnt cnt' s' r.\n     (clock   s) = extra + cnt \\<and> (clock   s') = extra + cnt' \\<and> res = (s',r) \\<and> ck = True \\<longrightarrow>\n     evaluate_prog ck env (s (| clock :=  cnt |)) prog ((s' (| clock := cnt' |)),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog ck env s prog res \\<Longrightarrow>\n    \\<forall>extra cnt cnt' s' r.\n       clock s = extra + cnt \\<and>\n       clock s' = extra + cnt' \\<and>\n       res = (s', r) \\<and> ck = True \\<longrightarrow>\n       evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s) prog\n        (update_clock (\\<lambda>_. cnt') s', r)", "proof (induction rule:evaluate_prog.inducts)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<forall>extra cnt cnt' s' r.\n          clock s = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s) []\n           (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n       evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n       (\\<forall>extra cnt cnt' s' ra.\n           clock s2 = extra + cnt \\<and>\n           clock s' = extra + cnt' \\<and>\n           (s3, r) = (s', ra) \\<and> ck = True \\<longrightarrow>\n           evaluate_prog ck (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. cnt) s2) tops\n            (update_clock (\\<lambda>_. cnt') s', ra)) \\<Longrightarrow>\n       \\<forall>extra cnt cnt' s' ra.\n          clock s1 = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. cnt') s', ra)\n 3. \\<And>ck s1 s2 env top0 tops err.\n       evaluate_top ck env s1 top0 (s2, Rerr err) \\<Longrightarrow>\n       \\<forall>extra cnt cnt' s' r.\n          clock s1 = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s2, Rerr err) = (s', r) \\<and> ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. cnt') s', r)", "case (cons1 ck s1 s2 s3 env top0 tops new_env r)"], ["proof (state)\nthis:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<forall>extra cnt cnt' s' ra.\n      clock s2 = extra + cnt \\<and>\n      clock s' = extra + cnt' \\<and>\n      (s3, r) = (s', ra) \\<and> ck = True \\<longrightarrow>\n      evaluate_prog ck (extend_dec_env new_env env)\n       (update_clock (\\<lambda>_. cnt) s2) tops\n       (update_clock (\\<lambda>_. cnt') s', ra))\n\ngoal (3 subgoals):\n 1. \\<And>ck env s.\n       \\<forall>extra cnt cnt' s' r.\n          clock s = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s) []\n           (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>ck s1 s2 s3 env top0 tops new_env r.\n       evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n       evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n       (\\<forall>extra cnt cnt' s' ra.\n           clock s2 = extra + cnt \\<and>\n           clock s' = extra + cnt' \\<and>\n           (s3, r) = (s', ra) \\<and> ck = True \\<longrightarrow>\n           evaluate_prog ck (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. cnt) s2) tops\n            (update_clock (\\<lambda>_. cnt') s', ra)) \\<Longrightarrow>\n       \\<forall>extra cnt cnt' s' ra.\n          clock s1 = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. cnt') s', ra)\n 3. \\<And>ck s1 s2 env top0 tops err.\n       evaluate_top ck env s1 top0 (s2, Rerr err) \\<Longrightarrow>\n       \\<forall>extra cnt cnt' s' r.\n          clock s1 = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s2, Rerr err) = (s', r) \\<and> ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. cnt') s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<forall>extra cnt cnt' s' ra.\n      clock s2 = extra + cnt \\<and>\n      clock s' = extra + cnt' \\<and>\n      (s3, r) = (s', ra) \\<and> ck = True \\<longrightarrow>\n      evaluate_prog ck (extend_dec_env new_env env)\n       (update_clock (\\<lambda>_. cnt) s2) tops\n       (update_clock (\\<lambda>_. cnt') s', ra))", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_top ck env s1 top0 (s2, Rval new_env) \\<and>\n  evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3, r) \\<and>\n  (\\<forall>extra cnt cnt' s' ra.\n      clock s2 = extra + cnt \\<and>\n      clock s' = extra + cnt' \\<and>\n      (s3, r) = (s', ra) \\<and> ck = True \\<longrightarrow>\n      evaluate_prog ck (extend_dec_env new_env env)\n       (update_clock (\\<lambda>_. cnt) s2) tops\n       (update_clock (\\<lambda>_. cnt') s', ra))\n\ngoal (1 subgoal):\n 1. \\<forall>extra cnt cnt' s' ra.\n       clock s1 = extra + cnt \\<and>\n       clock s' = extra + cnt' \\<and>\n       (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n       ck = True \\<longrightarrow>\n       evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1)\n        (top0 # tops) (update_clock (\\<lambda>_. cnt') s', ra)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>extra cnt cnt'.\n       \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n        evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n        \\<forall>extraa cnt cnt'a.\n           clock s2 = extraa + cnt \\<and>\n           extra + cnt' = extraa + cnt'a \\<longrightarrow>\n           evaluate_prog True (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. cnt) s2) tops\n            (update_clock (\\<lambda>_. cnt'a) s3, r);\n        clock s1 = extra + cnt; clock s3 = extra + cnt'; ck\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog True env\n                          (update_clock (\\<lambda>_. cnt) s1) (top0 # tops)\n                          (update_clock (\\<lambda>_. cnt') s3,\n                           combine_dec_result new_env r)", "subgoal for extra"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     \\<forall>extraa cnt cnt'a.\n        clock s2 = extraa + cnt \\<and>\n        extra + cnt'_ = extraa + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True env\n                       (update_clock (\\<lambda>_. cnt_) s1) (top0 # tops)\n                       (update_clock (\\<lambda>_. cnt'_) s3,\n                        combine_dec_result new_env r)", "apply (subgoal_tac \"clock   s2 \\<ge> extra\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     \\<forall>extraa cnt cnt'a.\n        clock s2 = extraa + cnt \\<and>\n        extra + cnt'_ = extraa + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck;\n     extra \\<le> clock s2\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True env\n                       (update_clock (\\<lambda>_. cnt_) s1) (top0 # tops)\n                       (update_clock (\\<lambda>_. cnt'_) s3,\n                        combine_dec_result new_env r)\n 2. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     \\<forall>extraa cnt cnt'a.\n        clock s2 = extraa + cnt \\<and>\n        extra + cnt'_ = extraa + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "apply (drule_tac x=\"extra\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck;\n     extra \\<le> clock s2;\n     \\<forall>cnt cnt'a.\n        clock s2 = extra + cnt \\<and>\n        extra + cnt'_ = extra + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True env\n                       (update_clock (\\<lambda>_. cnt_) s1) (top0 # tops)\n                       (update_clock (\\<lambda>_. cnt'_) s3,\n                        combine_dec_result new_env r)\n 2. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     \\<forall>extraa cnt cnt'a.\n        clock s2 = extraa + cnt \\<and>\n        extra + cnt'_ = extraa + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "apply (drule_tac x=\"(clock s2) - extra\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck;\n     extra \\<le> clock s2;\n     \\<forall>cnt'a.\n        clock s2 = extra + (clock s2 - extra) \\<and>\n        extra + cnt'_ = extra + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. clock s2 - extra) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True env\n                       (update_clock (\\<lambda>_. cnt_) s1) (top0 # tops)\n                       (update_clock (\\<lambda>_. cnt'_) s3,\n                        combine_dec_result new_env r)\n 2. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     \\<forall>extraa cnt cnt'a.\n        clock s2 = extraa + cnt \\<and>\n        extra + cnt'_ = extraa + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "apply rule+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck;\n     extra \\<le> clock s2;\n     \\<forall>cnt'a.\n        clock s2 = extra + (clock s2 - extra) \\<and>\n        extra + cnt'_ = extra + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. clock s2 - extra) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_top True env\n                       (update_clock (\\<lambda>_. cnt_) s1) top0\n                       (?s2.5, Rval new_env)\n 2. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck;\n     extra \\<le> clock s2;\n     \\<forall>cnt'a.\n        clock s2 = extra + (clock s2 - extra) \\<and>\n        extra + cnt'_ = extra + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. clock s2 - extra) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r)\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True (extend_dec_env new_env env) ?s2.5\n                       tops (update_clock (\\<lambda>_. cnt'_) s3, r)\n 3. \\<lbrakk>evaluate_top True env s1 top0 (s2, Rval new_env);\n     evaluate_prog True (extend_dec_env new_env env) s2 tops (s3, r);\n     \\<forall>extraa cnt cnt'a.\n        clock s2 = extraa + cnt \\<and>\n        extra + cnt'_ = extraa + cnt'a \\<longrightarrow>\n        evaluate_prog True (extend_dec_env new_env env)\n         (update_clock (\\<lambda>_. cnt) s2) tops\n         (update_clock (\\<lambda>_. cnt'a) s3, r);\n     clock s1 = extra + cnt_; clock s3 = extra + cnt'_; ck\\<rbrakk>\n    \\<Longrightarrow> extra \\<le> clock s2", "by (auto simp add:top_sub_from_counter dest:prog_clock_monotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>extra cnt cnt' s' ra.\n     clock s1 = extra + cnt \\<and>\n     clock s' = extra + cnt' \\<and>\n     (s3, combine_dec_result new_env r) = (s', ra) \\<and>\n     ck = True \\<longrightarrow>\n     evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1) (top0 # tops)\n      (update_clock (\\<lambda>_. cnt') s', ra)\n\ngoal (2 subgoals):\n 1. \\<And>ck env s.\n       \\<forall>extra cnt cnt' s' r.\n          clock s = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s, Rval (make_sem_env nsEmpty nsEmpty)) = (s', r) \\<and>\n          ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s) []\n           (update_clock (\\<lambda>_. cnt') s', r)\n 2. \\<And>ck s1 s2 env top0 tops err.\n       evaluate_top ck env s1 top0 (s2, Rerr err) \\<Longrightarrow>\n       \\<forall>extra cnt cnt' s' r.\n          clock s1 = extra + cnt \\<and>\n          clock s' = extra + cnt' \\<and>\n          (s2, Rerr err) = (s', r) \\<and> ck = True \\<longrightarrow>\n          evaluate_prog ck env (update_clock (\\<lambda>_. cnt) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. cnt') s', r)", "qed (auto intro!:evaluate_prog.intros simp add:top_sub_from_counter)"], ["", "lemma prog_clocked_min_counter:\n  assumes \"evaluate_prog True env s prog (s', r)\"\n  shows \"evaluate_prog True env (s (| clock := (clock   s) - (clock  s') |)) prog (((s') (| clock := 0 |)), r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog True env (update_clock (\\<lambda>_. clock s - clock s') s)\n     prog (update_clock (\\<lambda>_. 0) s', r)", "using assms"], ["proof (prove)\nusing this:\n  evaluate_prog True env s prog (s', r)\n\ngoal (1 subgoal):\n 1. evaluate_prog True env (update_clock (\\<lambda>_. clock s - clock s') s)\n     prog (update_clock (\\<lambda>_. 0) s', r)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog True env s prog (s', r) \\<Longrightarrow>\n    evaluate_prog True env (update_clock (\\<lambda>_. clock s - clock s') s)\n     prog (update_clock (\\<lambda>_. 0) s', r)", "apply (frule prog_clock_monotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_prog True env s prog (s', r) \\<Longrightarrow> True\n 2. \\<lbrakk>evaluate_prog True env s prog (s', r);\n     clock (fst (s', r)) \\<le> clock s\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True env\n                       (update_clock (\\<lambda>_. clock s - clock s') s)\n                       prog (update_clock (\\<lambda>_. 0) s', r)", "using prog_sub_from_counter"], ["proof (prove)\nusing this:\n  evaluate_prog ?ck ?env ?s ?prog ?res \\<Longrightarrow>\n  \\<forall>extra cnt cnt' s' r.\n     clock ?s = extra + cnt \\<and>\n     clock s' = extra + cnt' \\<and>\n     ?res = (s', r) \\<and> ?ck = True \\<longrightarrow>\n     evaluate_prog ?ck ?env (update_clock (\\<lambda>_. cnt) ?s) ?prog\n      (update_clock (\\<lambda>_. cnt') s', r)\n\ngoal (2 subgoals):\n 1. evaluate_prog True env s prog (s', r) \\<Longrightarrow> True\n 2. \\<lbrakk>evaluate_prog True env s prog (s', r);\n     clock (fst (s', r)) \\<le> clock s\\<rbrakk>\n    \\<Longrightarrow> evaluate_prog True env\n                       (update_clock (\\<lambda>_. clock s - clock s') s)\n                       prog (update_clock (\\<lambda>_. 0) s', r)", "by force+"], ["", "lemma prog_add_clock:\n  \"evaluate_prog False env s prog (s', res) \\<Longrightarrow> \\<exists>c. evaluate_prog True env (s (| clock := c |)) prog ((s' (| clock := 0 |)),res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog False env s prog (s', res) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', res)", "proof (induction False env s prog s' res rule: evaluate_prog.induct[split_format(complete)])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>env s.\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s) []\n           (update_clock (\\<lambda>_. 0) s,\n            Rval (make_sem_env nsEmpty nsEmpty))\n 2. \\<And>s1 s2 s3 env top0 tops new_env r.\n       evaluate_top False env s1 top0 (s2, Rval new_env) \\<and>\n       evaluate_prog False (extend_dec_env new_env env) s2 tops\n        (s3, r) \\<and>\n       (\\<exists>c.\n           evaluate_prog True (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. c) s2) tops\n            (update_clock (\\<lambda>_. 0) s3, r)) \\<Longrightarrow>\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s1)\n           (top0 # tops)\n           (update_clock (\\<lambda>_. 0) s3, combine_dec_result new_env r)\n 3. \\<And>s1 s2 env top0 tops err.\n       evaluate_top False env s1 top0 (s2, Rerr err) \\<Longrightarrow>\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. 0) s2, Rerr err)", "case cons1"], ["proof (state)\nthis:\n  evaluate_top False env_ s1_ top0_ (s2_, Rval new_env_) \\<and>\n  evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n   (s3_, r_) \\<and>\n  (\\<exists>c.\n      evaluate_prog True (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. c) s2_) tops_\n       (update_clock (\\<lambda>_. 0) s3_, r_))\n\ngoal (3 subgoals):\n 1. \\<And>env s.\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s) []\n           (update_clock (\\<lambda>_. 0) s,\n            Rval (make_sem_env nsEmpty nsEmpty))\n 2. \\<And>s1 s2 s3 env top0 tops new_env r.\n       evaluate_top False env s1 top0 (s2, Rval new_env) \\<and>\n       evaluate_prog False (extend_dec_env new_env env) s2 tops\n        (s3, r) \\<and>\n       (\\<exists>c.\n           evaluate_prog True (extend_dec_env new_env env)\n            (update_clock (\\<lambda>_. c) s2) tops\n            (update_clock (\\<lambda>_. 0) s3, r)) \\<Longrightarrow>\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s1)\n           (top0 # tops)\n           (update_clock (\\<lambda>_. 0) s3, combine_dec_result new_env r)\n 3. \\<And>s1 s2 env top0 tops err.\n       evaluate_top False env s1 top0 (s2, Rerr err) \\<Longrightarrow>\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. 0) s2, Rerr err)", "then"], ["proof (chain)\npicking this:\n  evaluate_top False env_ s1_ top0_ (s2_, Rval new_env_) \\<and>\n  evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n   (s3_, r_) \\<and>\n  (\\<exists>c.\n      evaluate_prog True (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. c) s2_) tops_\n       (update_clock (\\<lambda>_. 0) s3_, r_))", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_top False env_ s1_ top0_ (s2_, Rval new_env_) \\<and>\n  evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n   (s3_, r_) \\<and>\n  (\\<exists>c.\n      evaluate_prog True (extend_dec_env new_env_ env_)\n       (update_clock (\\<lambda>_. c) s2_) tops_\n       (update_clock (\\<lambda>_. 0) s3_, r_))\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_prog True env_ (update_clock (\\<lambda>_. c) s1_)\n        (top0_ # tops_)\n        (update_clock (\\<lambda>_. 0) s3_, combine_dec_result new_env_ r_)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_top False env_ s1_ top0_ (s2_, Rval new_env_);\n        evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n         (s3_, r_);\n        evaluate_prog True (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) tops_\n         (update_clock (\\<lambda>_. 0) s3_, r_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_prog True env_\n                             (update_clock (\\<lambda>_. c) s1_)\n                             (top0_ # tops_)\n                             (update_clock (\\<lambda>_. 0) s3_,\n                              combine_dec_result new_env_ r_)", "apply (drule top_add_clock)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n                 (s3_, r_);\n        evaluate_prog True (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) tops_\n         (update_clock (\\<lambda>_. 0) s3_, r_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> False\n 2. \\<And>c.\n       \\<lbrakk>evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n                 (s3_, r_);\n        evaluate_prog True (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) tops_\n         (update_clock (\\<lambda>_. 0) s3_, r_);\n        \\<exists>c.\n           evaluate_top True env_ (update_clock (\\<lambda>_. c) s1_) top0_\n            (update_clock (\\<lambda>_. 0) s2_, Rval new_env_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_prog True env_\n                             (update_clock (\\<lambda>_. c) s1_)\n                             (top0_ # tops_)\n                             (update_clock (\\<lambda>_. 0) s3_,\n                              combine_dec_result new_env_ r_)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c ca.\n       \\<lbrakk>evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n                 (s3_, r_);\n        evaluate_prog True (extend_dec_env new_env_ env_)\n         (update_clock (\\<lambda>_. c) s2_) tops_\n         (update_clock (\\<lambda>_. 0) s3_, r_);\n        evaluate_top True env_ (update_clock (\\<lambda>_. ca) s1_) top0_\n         (update_clock (\\<lambda>_. 0) s2_, Rval new_env_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            evaluate_prog True env_\n                             (update_clock (\\<lambda>_. c) s1_)\n                             (top0_ # tops_)\n                             (update_clock (\\<lambda>_. 0) s3_,\n                              combine_dec_result new_env_ r_)", "subgoal for c c'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n              (s3_, r_);\n     evaluate_prog True (extend_dec_env new_env_ env_)\n      (update_clock (\\<lambda>_. c) s2_) tops_\n      (update_clock (\\<lambda>_. 0) s3_, r_);\n     evaluate_top True env_ (update_clock (\\<lambda>_. c') s1_) top0_\n      (update_clock (\\<lambda>_. 0) s2_, Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_prog True env_\n                          (update_clock (\\<lambda>_. c) s1_) (top0_ # tops_)\n                          (update_clock (\\<lambda>_. 0) s3_,\n                           combine_dec_result new_env_ r_)", "apply (drule top_add_to_counter[where extra = c])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n              (s3_, r_);\n     evaluate_prog True (extend_dec_env new_env_ env_)\n      (update_clock (\\<lambda>_. c) s2_) tops_\n      (update_clock (\\<lambda>_. 0) s3_, r_)\\<rbrakk>\n    \\<Longrightarrow> Rval new_env_ \\<noteq> Rerr (Rabort Rtimeout_error)\n 2. \\<lbrakk>evaluate_prog False (extend_dec_env new_env_ env_) s2_ tops_\n              (s3_, r_);\n     evaluate_prog True (extend_dec_env new_env_ env_)\n      (update_clock (\\<lambda>_. c) s2_) tops_\n      (update_clock (\\<lambda>_. 0) s3_, r_);\n     evaluate_top True env_\n      (update_clock\n        (\\<lambda>_. clock (update_clock (\\<lambda>_. c') s1_) + c)\n        (update_clock (\\<lambda>_. c') s1_))\n      top0_\n      (update_clock\n        (\\<lambda>_. clock (update_clock (\\<lambda>_. 0) s2_) + c)\n        (update_clock (\\<lambda>_. 0) s2_),\n       Rval new_env_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         evaluate_prog True env_\n                          (update_clock (\\<lambda>_. c) s1_) (top0_ # tops_)\n                          (update_clock (\\<lambda>_. 0) s3_,\n                           combine_dec_result new_env_ r_)", "by (auto simp add:add.commute intro: evaluate_prog.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_prog True env_ (update_clock (\\<lambda>_. c) s1_)\n      (top0_ # tops_)\n      (update_clock (\\<lambda>_. 0) s3_, combine_dec_result new_env_ r_)\n\ngoal (2 subgoals):\n 1. \\<And>env s.\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s) []\n           (update_clock (\\<lambda>_. 0) s,\n            Rval (make_sem_env nsEmpty nsEmpty))\n 2. \\<And>s1 s2 env top0 tops err.\n       evaluate_top False env s1 top0 (s2, Rerr err) \\<Longrightarrow>\n       \\<exists>c.\n          evaluate_prog True env (update_clock (\\<lambda>_. c) s1)\n           (top0 # tops) (update_clock (\\<lambda>_. 0) s2, Rerr err)", "qed (auto intro: evaluate_prog.intros dest: top_add_clock)"], ["", "lemma prog_clocked_unclocked_equiv:\n  \"evaluate_prog False env s prog (s',r) =\n   (\\<exists>c. evaluate_prog True env (s (| clock := c |)) prog ((s' (| clock := 0 |)),r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> (clock   s) = (clock   s'))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog False env s prog (s', r) =\n    (\\<exists>c.\n        evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n         (update_clock (\\<lambda>_. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s')", "proof rule"], ["proof (state)\ngoal (2 subgoals):\n 1. evaluate_prog False env s prog (s', r) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_prog False env s prog (s', r)", "assume \"?lhs\""], ["proof (state)\nthis:\n  evaluate_prog False env s prog (s', r)\n\ngoal (2 subgoals):\n 1. evaluate_prog False env s prog (s', r) \\<Longrightarrow>\n    \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n 2. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_prog False env s prog (s', r)", "then"], ["proof (chain)\npicking this:\n  evaluate_prog False env s prog (s', r)", "show \"?rhs\""], ["proof (prove)\nusing this:\n  evaluate_prog False env s prog (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "using prog_add_clock"], ["proof (prove)\nusing this:\n  evaluate_prog False env s prog (s', r)\n  evaluate_prog False ?env ?s ?prog (?s', ?res) \\<Longrightarrow>\n  \\<exists>c.\n     evaluate_prog True ?env (update_clock (\\<lambda>_. c) ?s) ?prog\n      (update_clock (\\<lambda>_. 0) ?s', ?res)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "by (fastforce simp: prog_unclocked)"], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_prog False env s prog (s', r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_prog False env s prog (s', r)", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>c.\n     evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n        (update_clock (\\<lambda>_. 0) s', r) \\<and>\n       r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and>\n       clock s = clock s' \\<Longrightarrow>\n    evaluate_prog False env s prog (s', r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'", "show \"?lhs\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n      (update_clock (\\<lambda>_. 0) s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock s = clock s'\n\ngoal (1 subgoal):\n 1. evaluate_prog False env s prog (s', r)", "apply (auto simp: prog_unclocked)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "(* sledgehammer proof *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "fix c :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "assume a1: \"evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog (update_clock (\\<lambda>_. 0) s', r)\""], ["proof (state)\nthis:\n  evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n   (update_clock (\\<lambda>_. 0) s', r)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "assume a2: \"r \\<noteq> Rerr (Rabort Rtimeout_error)\""], ["proof (state)\nthis:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "assume a3: \"clock s = clock s'\""], ["proof (state)\nthis:\n  clock s = clock s'\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "have \"\\<forall>n. evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog (update_clock (\\<lambda>na. n) s', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog\n        (update_clock (\\<lambda>na. n) s', r)", "using a2 a1 prog_unclocked_ignore"], ["proof (prove)\nusing this:\n  r \\<noteq> Rerr (Rabort Rtimeout_error)\n  evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n   (update_clock (\\<lambda>_. 0) s', r)\n  evaluate_prog ?ck ?env ?s ?prog ?res \\<Longrightarrow>\n  \\<forall>cnt s' r.\n     ?res = (s', r) \\<and>\n     r \\<noteq> Rerr (Rabort Rtimeout_error) \\<longrightarrow>\n     evaluate_prog False ?env (update_clock (\\<lambda>_. cnt) ?s) ?prog\n      (update_clock (\\<lambda>_. cnt) s', r)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog\n        (update_clock (\\<lambda>na. n) s', r)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>n.\n     evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog\n      (update_clock (\\<lambda>na. n) s', r)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>evaluate_prog True env (update_clock (\\<lambda>_. c) s) prog\n                 (update_clock (\\<lambda>_. 0) s', r);\n        r \\<noteq> Rerr (Rabort Rtimeout_error); clock s = clock s'\\<rbrakk>\n       \\<Longrightarrow> evaluate_prog False env s prog (s', r)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog\n      (update_clock (\\<lambda>na. n) s', r)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog\n      (update_clock (\\<lambda>na. n) s', r)\n\ngoal (1 subgoal):\n 1. evaluate_prog False env s prog (s', r)", "using a3"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     evaluate_prog False env (update_clock (\\<lambda>na. n) s) prog\n      (update_clock (\\<lambda>na. n) s', r)\n  clock s = clock s'\n\ngoal (1 subgoal):\n 1. evaluate_prog False env s prog (s', r)", "by (metis (no_types) state.record_simps(7))"], ["proof (state)\nthis:\n  evaluate_prog False env s prog (s', r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_prog False env s prog (s', r)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma clocked_evaluate:\n  \"(\\<exists>k. BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e (s', r) \\<and> r \\<noteq>  Rerr (Rabort Rtimeout_error)) =\n   (\\<exists>k. BigStep.evaluate True env (update_clock (\\<lambda>_. k) s) e ((update_clock (\\<lambda>_. 0) s'), r) \\<and> r \\<noteq>  Rerr (Rabort Rtimeout_error))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k.\n        evaluate True env (update_clock (\\<lambda>_. k) s) e (s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error)) =\n    (\\<exists>k.\n        evaluate True env (update_clock (\\<lambda>_. k) s) e\n         (update_clock (\\<lambda>_. 0) s', r) \\<and>\n        r \\<noteq> Rerr (Rabort Rtimeout_error))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        evaluate True env (update_clock (\\<lambda>_. k) s) e\n         (s', r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            evaluate True env\n                             (update_clock (\\<lambda>_. k) s) e\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>k.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        evaluate True env (update_clock (\\<lambda>_. k) s) e\n         (update_clock (\\<lambda>_. 0) s', r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            evaluate True env\n                             (update_clock (\\<lambda>_. k) s) e (s', r)", "apply (frule clock_monotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        evaluate True env (update_clock (\\<lambda>_. k) s) e (s', r);\n        \\<forall>s'a r'.\n           (s', r) = (s'a, r') \\<and> True = True \\<longrightarrow>\n           clock s'a \\<le> clock (update_clock (\\<lambda>_. k) s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            evaluate True env\n                             (update_clock (\\<lambda>_. k) s) e\n                             (update_clock (\\<lambda>_. 0) s', r)\n 2. \\<And>k.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        evaluate True env (update_clock (\\<lambda>_. k) s) e\n         (update_clock (\\<lambda>_. 0) s', r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            evaluate True env\n                             (update_clock (\\<lambda>_. k) s) e (s', r)", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n     evaluate True env (update_clock (\\<lambda>_. k) s) e (s', r);\n     \\<forall>s'a r'.\n        (s', r) = (s'a, r') \\<and> True = True \\<longrightarrow>\n        clock s'a \\<le> clock (update_clock (\\<lambda>_. k) s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         evaluate True env (update_clock (\\<lambda>_. k) s)\n                          e (update_clock (\\<lambda>_. 0) s', r)", "by (force dest: sub_from_counter(3)[rule_format, where count' = 0 and count = \"k - (clock s')\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>r \\<noteq> Rerr (Rabort Rtimeout_error);\n        evaluate True env (update_clock (\\<lambda>_. k) s) e\n         (update_clock (\\<lambda>_. 0) s', r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            evaluate True env\n                             (update_clock (\\<lambda>_. k) s) e (s', r)", "by (force dest: add_to_counter[where extra = \"clock s'\"])"], ["", "end"]]}