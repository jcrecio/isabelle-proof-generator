{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Evaluate_Clock.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma fix_clock:\n  \"fix_clock s1 (s2, x) = (s, x) \\<Longrightarrow> clock s \\<le> clock s1\"\n  \"fix_clock s1 (s2, x) = (s, x) \\<Longrightarrow> clock s \\<le> clock s2\"", "lemma dec_clock[simp]: \"clock (dec_clock st) = clock st - 1\"", "lemma fun_evaluate_clock0:\n  \"clock (fst (fun_evaluate_match s1 env v p v')) \\<le> clock s1\"\n  \"clock (fst (fun_evaluate s1 env e)) \\<le> clock s1\"", "lemma fun_evaluate_clock:\n  \"fun_evaluate_match s1 env v p v' = (s2, r) \\<Longrightarrow> clock s2 \\<le> clock s1\"\n  \"fun_evaluate s1 env e = (s2, r) \\<Longrightarrow> clock s2 \\<le> clock s1\"", "lemma fix_clock_evaluate[simp]:\n  \"fix_clock s1 (fun_evaluate s1 env e) = fun_evaluate s1 env e\"", "lemmas fun_evaluate_simps[simp] =\n  fun_evaluate.simps[unfolded fix_clock_evaluate]\n  fun_evaluate_match.simps[unfolded fix_clock_evaluate]", "lemmas fun_evaluate_induct =\n  fun_evaluate_match_fun_evaluate.induct[unfolded fix_clock_evaluate]", "lemma fun_evaluate_length:\n  \"fun_evaluate_match s env v pes err_v = (s', res) \\<Longrightarrow> (case res of Rval vs \\<Rightarrow> length vs = 1 | _ \\<Rightarrow> True)\"\n  \"fun_evaluate s env es = (s', res) \\<Longrightarrow> (case res of Rval vs \\<Rightarrow> length vs = length es | _ \\<Rightarrow> True)\"", "lemma fun_evaluate_matchE:\n  assumes \"fun_evaluate_match s env v pes err_v = (s', Rval vs)\"\n  obtains v where \"vs = [v]\""], "translations": [["", "lemma fix_clock:\n  \"fix_clock s1 (s2, x) = (s, x) \\<Longrightarrow> clock s \\<le> clock s1\"\n  \"fix_clock s1 (s2, x) = (s, x) \\<Longrightarrow> clock s \\<le> clock s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fix_clock s1 (s2, x) = (s, x) \\<Longrightarrow>\n     clock s \\<le> clock s1) &&&\n    (fix_clock s1 (s2, x) = (s, x) \\<Longrightarrow> clock s \\<le> clock s2)", "unfolding fix_clock_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case (s2, x) of\n      (x3a, x) \\<Rightarrow>\n        (update_clock\n          (\\<lambda>_.\n              if clock x3a \\<le> clock s1 then clock x3a else clock s1)\n          x3a,\n         x)) =\n     (s, x) \\<Longrightarrow>\n     clock s \\<le> clock s1) &&&\n    ((case (s2, x) of\n      (x3a, x) \\<Rightarrow>\n        (update_clock\n          (\\<lambda>_.\n              if clock x3a \\<le> clock s1 then clock x3a else clock s1)\n          x3a,\n         x)) =\n     (s, x) \\<Longrightarrow>\n     clock s \\<le> clock s2)", "by auto"], ["", "lemma dec_clock[simp]: \"clock (dec_clock st) = clock st - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (dec_clock st) = clock st - 1", "unfolding dec_clock_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (update_clock (\\<lambda>_. clock st - 1) st) = clock st - 1", "by auto"], ["", "context begin"], ["", "private"], ["", "lemma fun_evaluate_clock0:\n  \"clock (fst (fun_evaluate_match s1 env v p v')) \\<le> clock s1\"\n  \"clock (fst (fun_evaluate s1 env e)) \\<le> clock s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate_match s1 env v p v')) \\<le> clock s1 &&&\n    clock (fst (fun_evaluate s1 env e)) \\<le> clock s1", "proof (induction rule: fun_evaluate_match_fun_evaluate.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env (e2 # es)))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env (e1 # e2 # es)))\n                         \\<le> clock st\n 3. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 4. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 5. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 6. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 7. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 8. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 9. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 10. \\<And>st env lop e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2 x1a.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n             x2 = Exp x1a\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                          \\<le> clock st\nA total of 18 subgoals...", "case (2 st env e1 e2 es)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [e1])) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env [e1]);\n   ?y = Rval ?x1.0\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate ?x env (e2 # es)))\n                    \\<le> clock ?x\n\ngoal (18 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env (e2 # es)))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env (e1 # e2 # es)))\n                         \\<le> clock st\n 3. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 4. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 5. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 6. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 7. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 8. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 9. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 10. \\<And>st env lop e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2 x1a.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n             x2 = Exp x1a\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                          \\<le> clock st\nA total of 18 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env [e1]) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env [e1]) = (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env [e1]) = (st', r)\n\ngoal (18 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env (e2 # es)))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env (e1 # e2 # es)))\n                         \\<le> clock st\n 3. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 4. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 5. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 6. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 7. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 8. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 9. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 10. \\<And>st env lop e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2 x1a.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n             x2 = Exp x1a\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                          \\<le> clock st\nA total of 18 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env (e1 # e2 # es))) \\<le> clock st", "apply (auto split: prod.splits result.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x1a x1b.\n       \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a, Rval x1b);\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock x1a \\<le> clock st\n 2. \\<And>x1 x1a x2a.\n       \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a, Rerr x2a);\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock x1a \\<le> clock st\n 3. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a_, Rval x1b_);\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock x1a_ \\<le> clock st", "using 2(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  r = Rval ?x1.0 \\<Longrightarrow>\n  clock (fst (fun_evaluate st' env (e2 # es))) \\<le> clock st'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a_, Rval x1b_);\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock x1a_ \\<le> clock st", "by (smt \"*\" fix_clock(1) fix_clock.simps fst_conv le_trans prod.collapse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x1a x2a.\n       \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a, Rerr x2a);\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock x1a \\<le> clock st\n 2. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a_, Rerr x2a_);\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock x1a_ \\<le> clock st", "using 2(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  r = Rval ?x1.0 \\<Longrightarrow>\n  clock (fst (fun_evaluate st' env (e2 # es))) \\<le> clock st'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st' env (e2 # es) = (x1a_, Rerr x2a_);\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock x1a_ \\<le> clock st", "by (smt \"*\" fix_clock(1) fix_clock.simps fst_conv le_trans prod.collapse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps prod.collapse prod.sel(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env (e1 # e2 # es))) \\<le> clock st\n\ngoal (17 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 6. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 7. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 8. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                          \\<le> clock st\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 6. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 7. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 8. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                          \\<le> clock st\nA total of 17 subgoals...", "case (5 st env e pes)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [e])) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env [e]);\n   ?y = Rerr ?x2.0; ?x2.0 = Rraise ?x1.0\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate_match ?x env ?x1.0 pes ?x1.0))\n                    \\<le> clock ?x\n\ngoal (17 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 6. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 7. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 8. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                          \\<le> clock st\nA total of 17 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env [e]) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env [e]) = (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env [e]) = (st', r)\n\ngoal (17 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env x1 pes x1))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Handle e pes]))\n                         \\<le> clock st\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 6. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 7. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 8. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                          \\<le> clock st\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env [Handle e pes])) \\<le> clock st", "apply (auto split: prod.splits result.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1. r = Rval x1 \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x2.\n       r = Rerr x2 \\<Longrightarrow>\n       clock\n        (fst (case x2 of\n              Rraise v2 \\<Rightarrow> fun_evaluate_match st' env v2 pes v2\n              | Rabort abort \\<Rightarrow> (st', Rerr (Rabort abort))))\n       \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rval x1_ \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps prod.collapse prod.sel(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       r = Rerr x2 \\<Longrightarrow>\n       clock\n        (fst (case x2 of\n              Rraise v2 \\<Rightarrow> fun_evaluate_match st' env v2 pes v2\n              | Rabort abort \\<Rightarrow> (st', Rerr (Rabort abort))))\n       \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow>\n    clock\n     (fst (case x2_ of\n           Rraise v2 \\<Rightarrow> fun_evaluate_match st' env v2 pes v2\n           | Rabort abort \\<Rightarrow> (st', Rerr (Rabort abort))))\n    \\<le> clock st", "using 5(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>r = Rerr ?x2.0; ?x2.0 = Rraise ?x1.0\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate_match st' env ?x1.0 pes ?x1.0))\n                    \\<le> clock st'\n\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow>\n    clock\n     (fst (case x2_ of\n           Rraise v2 \\<Rightarrow> fun_evaluate_match st' env v2 pes v2\n           | Rabort abort \\<Rightarrow> (st', Rerr (Rabort abort))))\n    \\<le> clock st", "by (smt \"*\" \"5.IH\"(1) dual_order.trans eq_fst_iff error_result.exhaust error_result.simps(5) error_result.simps(6) fix_clock(2) fix_clock.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [Handle e pes])) \\<le> clock st\n\ngoal (16 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 10. \\<And>st env e pes.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate_match x env (hd x1) pes\nBindv))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                          \\<le> clock st\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 10. \\<And>st env e pes.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate_match x env (hd x1) pes\nBindv))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                          \\<le> clock st\nA total of 16 subgoals...", "case (9 st env op1 es)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env (rev es))) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env (rev es));\n   ?y = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock ?x) ?xa [?ya]))\n                    \\<le> clock (dec_clock ?x)\n\ngoal (16 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 10. \\<And>st env e pes.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate_match x env (hd x1) pes\nBindv))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                          \\<le> clock st\nA total of 16 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env (rev es)) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env (rev es)) =\n        (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env (rev es)) = (st', r)\n\ngoal (16 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 10. \\<And>st env e pes.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate_match x env (hd x1) pes\nBindv))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                          \\<le> clock st\nA total of 16 subgoals...", "note do_app.simps[simp del]"], ["proof (state)\nthis:\n  do_app (?s, ?t1.0) ?op1.0 ?vs =\n  (case (?op1.0, ?vs) of (Opn op1, []) \\<Rightarrow> None\n   | (Opn op1, [Litv (IntLit n1)]) \\<Rightarrow> None\n   | (Opn op1, [Litv (IntLit n1), Litv (IntLit n2)]) \\<Rightarrow>\n       if (op1 = Divide \\<or> op1 = Modulo) \\<and> n2 = 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Div'')))\n       else Some ((?s, ?t1.0), Rval (Litv (IntLit (opn_lookup op1 n1 n2))))\n   | (Opn op1, Litv (IntLit n1) # Litv (IntLit n2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1, Litv (IntLit n1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1,\n      Litv (IntLit n1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1,\n      Litv (IntLit n1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1, Litv (IntLit n1) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Opn op1, Litv (IntLit n1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, []) \\<Rightarrow> None\n   | (Opb op1, [Litv (IntLit n1)]) \\<Rightarrow> None\n   | (Opb op1, [Litv (IntLit n1), Litv (IntLit n2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Boolv (opb_lookup op1 n1 n2)))\n   | (Opb op1, Litv (IntLit n1) # Litv (IntLit n2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1, Litv (IntLit n1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1,\n      Litv (IntLit n1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1,\n      Litv (IntLit n1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1, Litv (IntLit n1) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Opb op1, Litv (IntLit n1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, []) \\<Rightarrow> None\n   | (Opw W8 op1, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, [Litv (Word8 w1)]) \\<Rightarrow> None\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1,\n      Litv (Word8 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1, [Litv (Word8 w1), Litv (Word8 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word8 (opw8_lookup op1 w1 w2))))\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (Word8 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1, Litv (Word8 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1,\n      Litv (Word8 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1,\n      Litv (Word8 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Litv (Word8 w1) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Litv (Word8 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, []) \\<Rightarrow> None\n   | (Opw W64 op1, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, [Litv (Word64 w1)]) \\<Rightarrow> None\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1, Litv (Word64 w1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1, [Litv (Word64 w1), Litv (Word64 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (opw64_lookup op1 w1 w2))))\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (Word64 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Litv (Word64 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Litv (Word64 w1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Litv (Word64 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, []) \\<Rightarrow> None\n   | (Shift W8 op1 n, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, [Litv (Word8 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word8 (shift8_lookup op1 w n))))\n   | (Shift W8 op1 n, Litv (Word8 w) # a # x) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W8 op1 n, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W8 op1 n, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, []) \\<Rightarrow> None\n   | (Shift W64 op1 n, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, [Litv (Word64 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (shift64_lookup op1 w n))))\n   | (Shift W64 op1 n, Litv (Word64 w) # a # x) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W64 op1 n, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W64 op1 n, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Equality, []) \\<Rightarrow> None | (Equality, [v1]) \\<Rightarrow> None\n   | (Equality, [v1, v2]) \\<Rightarrow>\n       case do_eq v1 v2 of\n       Eq_val b \\<Rightarrow> Some ((?s, ?t1.0), Rval (Boolv b))\n       | Eq_type_error \\<Rightarrow> None\n   | (Equality, v1 # v2 # ab # x) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, []) \\<Rightarrow> None\n   | (FP_cmp cmp, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, [Litv (Word64 w1)]) \\<Rightarrow> None\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp,\n      Litv (Word64 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp, [Litv (Word64 w1), Litv (Word64 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Boolv (fp_cmp cmp w1 w2)))\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (Word64 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Litv (Word64 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp,\n      Litv (Word64 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp,\n      Litv (Word64 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Litv (Word64 w1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Litv (Word64 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Loc x # list) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, []) \\<Rightarrow> None\n   | (FP_uop uop, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, [Litv (Word64 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (fp_uop uop w))))\n   | (FP_uop uop, Litv (Word64 w) # a # x) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (FP_uop uop, Loc x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, []) \\<Rightarrow> None\n   | (FP_bop bop, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, [Litv (Word64 w1)]) \\<Rightarrow> None\n   | (FP_bop bop, Litv (Word64 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop,\n      Litv (Word64 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop, Litv (Word64 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop, Litv (Word64 w1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop, [Litv (Word64 w1), Litv (Word64 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (fp_bop bop w1 w2))))\n   | (FP_bop bop, Litv (Word64 w1) # Litv (Word64 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Litv (Word64 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop,\n      Litv (Word64 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop,\n      Litv (Word64 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Litv (Word64 w1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Litv (Word64 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Loc x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opapp, b) \\<Rightarrow> None | (Opassign, []) \\<Rightarrow> None\n   | (Opassign, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, [Loc lnum]) \\<Rightarrow> None\n   | (Opassign, [Loc lnum, v2]) \\<Rightarrow>\n       case store_assign lnum (Refv v2) ?s of None \\<Rightarrow> None\n       | Some s' \\<Rightarrow> Some ((s', ?t1.0), Rval (Conv None []))\n   | (Opassign, Loc lnum # v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Opassign, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opref, []) \\<Rightarrow> None\n   | (Opref, [v2]) \\<Rightarrow>\n       let (s', n) = store_alloc (Refv v2) ?s\n       in Some ((s', ?t1.0), Rval (Loc n))\n   | (Opref, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Opderef, []) \\<Rightarrow> None\n   | (Opderef, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, [Loc n]) \\<Rightarrow>\n       case store_lookup n ?s of None \\<Rightarrow> None\n       | Some (Refv v2) \\<Rightarrow> Some ((?s, ?t1.0), Rval v2)\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Opderef, Loc n # a # x) \\<Rightarrow> Map.empty x\n   | (Opderef, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, []) \\<Rightarrow> None\n   | (Aw8alloc, [Litv (IntLit n)]) \\<Rightarrow> None\n   | (Aw8alloc, Litv (IntLit n) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, Litv (IntLit n) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, Litv (IntLit n) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, [Litv (IntLit n), Litv (Word8 w)]) \\<Rightarrow>\n       if n < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let (s', lnum) =\n                  store_alloc (W8array (replicate (nat \\<bar>n\\<bar>) w)) ?s\n            in Some ((s', ?t1.0), Rval (Loc lnum))\n   | (Aw8alloc, Litv (IntLit n) # Litv (Word8 w) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc, Litv (IntLit n) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, Litv (IntLit n) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc,\n      Litv (IntLit n) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc,\n      Litv (IntLit n) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc, Litv (IntLit n) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Litv (IntLit n) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, []) \\<Rightarrow> None\n   | (Aw8sub, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, [Loc lnum]) \\<Rightarrow> None\n   | (Aw8sub, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length ws \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else Some ((?s, ?t1.0), Rval (Litv (Word8 (ws ! n))))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8sub, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8sub, Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8sub, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, []) \\<Rightarrow> None\n   | (Aw8length, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8length, [Loc n]) \\<Rightarrow>\n       case store_lookup n ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length ws)))))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Aw8length, Loc n # a # x) \\<Rightarrow> Map.empty x\n   | (Aw8length, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, []) \\<Rightarrow> None\n   | (Aw8update, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, [Loc lnum]) \\<Rightarrow> None\n   | (Aw8update, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow> None\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (IntLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, [Loc lnum, Litv (IntLit i), Litv (Word8 w)]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length ws \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else case store_assign lnum (W8array (ws[n := w])) ?s of\n                        None \\<Rightarrow> None\n                        | Some s' \\<Rightarrow>\n                            Some ((s', ?t1.0), Rval (Conv None []))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (Word8 w) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum #\n      Litv (IntLit i) # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum #\n      Litv (IntLit i) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, Loc lnum # Litv (IntLit i) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8update, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8update, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8update, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, []) \\<Rightarrow> None\n   | (WordFromInt W8, [Litv (IntLit i)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word8 (word_of_int i))))\n   | (WordFromInt W8, Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W8, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, []) \\<Rightarrow> None\n   | (WordFromInt W64, [Litv (IntLit i)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (word_of_int i))))\n   | (WordFromInt W64, Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W64, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W64, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, []) \\<Rightarrow> None\n   | (WordToInt W8, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, [Litv (Word8 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (unat w)))))\n   | (WordToInt W8, Litv (Word8 w) # a # x) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W8, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, []) \\<Rightarrow> None\n   | (WordToInt W64, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, [Litv (Word64 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (unat w)))))\n   | (WordToInt W64, Litv (Word64 w) # a # x) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W64, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W64, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, []) \\<Rightarrow> None\n   | (CopyStrStr, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, [Litv (StrLit str)]) \\<Rightarrow> None\n   | (CopyStrStr, [Litv (StrLit str), Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyStrStr,\n      [Litv (StrLit str), Litv (IntLit off),\n       Litv (IntLit len)]) \\<Rightarrow>\n       Some\n        ((?s, ?t1.0),\n         case copy_array (str, off) len None of\n         None \\<Rightarrow> Rerr (Rraise (prim_exn ''Subscript''))\n         | Some cs \\<Rightarrow> Rval (Litv (StrLit cs)))\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (IntLit len) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Closure sem_env listc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr, Litv (StrLit str) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr, Litv (StrLit str) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Litv (StrLit str) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Litv (StrLit str) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Loc x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, []) \\<Rightarrow> None\n   | (CopyStrAw8, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, [Litv (StrLit str)]) \\<Rightarrow> None\n   | (CopyStrAw8, [Litv (StrLit str), Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyStrAw8,\n      [Litv (StrLit str), Litv (IntLit off),\n       Litv (IntLit len)]) \\<Rightarrow>\n       None\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (IntLit len) # Litv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      [Litv (StrLit str), Litv (IntLit off), Litv (IntLit len),\n       Loc dst]) \\<Rightarrow>\n       None\n   | (CopyStrAw8,\n      [Litv (StrLit str), Litv (IntLit off), Litv (IntLit len), Loc dst,\n       Litv (IntLit dstoff)]) \\<Rightarrow>\n       case store_lookup dst ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           case copy_array (str, off) len (Some (ws_to_chars ws, dstoff)) of\n           None \\<Rightarrow>\n             Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           | Some cs \\<Rightarrow>\n               case store_assign dst (W8array (chars_to_ws cs)) ?s of\n               None \\<Rightarrow> None\n               | Some s' \\<Rightarrow>\n                   Some ((s', ?t1.0), Rval (Conv None []))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Litv (IntLit dstoff) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Closure sem_env listc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Closure sem_env listc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8, Litv (StrLit str) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8, Litv (StrLit str) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Litv (StrLit str) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Litv (StrLit str) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Loc x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, []) \\<Rightarrow> None\n   | (CopyAw8Str, Litv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, [Loc src]) \\<Rightarrow> None\n   | (CopyAw8Str, [Loc src, Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyAw8Str,\n      [Loc src, Litv (IntLit off), Litv (IntLit len)]) \\<Rightarrow>\n       case store_lookup src ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           Some\n            ((?s, ?t1.0),\n             case copy_array (ws, off) len None of\n             None \\<Rightarrow> Rerr (Rraise (prim_exn ''Subscript''))\n             | Some ws \\<Rightarrow> Rval (Litv (StrLit (ws_to_chars ws))))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (IntLit len) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src #\n      Litv (IntLit off) # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, Loc src # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, Loc src # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Loc src # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, Loc src # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Loc src # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, []) \\<Rightarrow> None\n   | (CopyAw8Aw8, Litv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, [Loc src]) \\<Rightarrow> None\n   | (CopyAw8Aw8, [Loc src, Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyAw8Aw8,\n      [Loc src, Litv (IntLit off), Litv (IntLit len)]) \\<Rightarrow>\n       None\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) # Litv (IntLit len) # Litv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      [Loc src, Litv (IntLit off), Litv (IntLit len),\n       Loc dst]) \\<Rightarrow>\n       None\n   | (CopyAw8Aw8,\n      [Loc src, Litv (IntLit off), Litv (IntLit len), Loc dst,\n       Litv (IntLit dstoff)]) \\<Rightarrow>\n       case (store_lookup src ?s, store_lookup dst ?s) of\n       (None, b) \\<Rightarrow> None\n       | (Some (Refv xa), b) \\<Rightarrow> Map.empty xa\n       | (Some (W8array ws), None) \\<Rightarrow> None\n       | (Some (W8array ws), Some (Refv xa)) \\<Rightarrow> Map.empty xa\n       | (Some (W8array ws), Some (W8array ds)) \\<Rightarrow>\n           case copy_array (ws, off) len (Some (ds, dstoff)) of\n           None \\<Rightarrow>\n             Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           | Some ws \\<Rightarrow>\n               case store_assign dst (W8array ws) ?s of\n               None \\<Rightarrow> None\n               | Some s' \\<Rightarrow>\n                   Some ((s', ?t1.0), Rval (Conv None []))\n       | (Some (W8array ws), Some (Varray xa)) \\<Rightarrow> Map.empty xa\n       | (Some (Varray xa), b) \\<Rightarrow> Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Litv (IntLit dstoff) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, Loc src # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, Loc src # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Loc src # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, Loc src # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Loc src # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Ord, []) \\<Rightarrow> None\n   | (Ord, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, [Litv (lit.Char c2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (of_char c2)))))\n   | (Ord, Litv (lit.Char c2) # a # x) \\<Rightarrow> Map.empty x\n   | (Ord, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Chr, []) \\<Rightarrow> None\n   | (Chr, [Litv (IntLit i)]) \\<Rightarrow>\n       Some\n        ((?s, ?t1.0),\n         if i < 0 \\<or> 255 < i then Rerr (Rraise (prim_exn ''Chr''))\n         else Rval (Litv (lit.Char (char_of (nat \\<bar>i\\<bar>)))))\n   | (Chr, Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Chr, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, []) \\<Rightarrow> None\n   | (Chopb op1, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, [Litv (lit.Char c1)]) \\<Rightarrow> None\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1, [Litv (lit.Char c1), Litv (lit.Char c2)]) \\<Rightarrow>\n       Some\n        ((?s, ?t1.0),\n         Rval\n          (Boolv (opb_lookup op1 (int (of_char c1)) (int (of_char c2)))))\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (lit.Char c2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1, Litv (lit.Char c1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1, Litv (lit.Char c1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1,\n      Litv (lit.Char c1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1,\n      Litv (lit.Char c1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Litv (lit.Char c1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Litv (lit.Char c1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Implode, []) \\<Rightarrow> None\n   | (Implode, [v2]) \\<Rightarrow>\n       case v_to_char_list v2 of None \\<Rightarrow> None\n       | Some ls \\<Rightarrow> Some ((?s, ?t1.0), Rval (Litv (StrLit ls)))\n   | (Implode, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Strsub, []) \\<Rightarrow> None\n   | (Strsub, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, [Litv (StrLit str)]) \\<Rightarrow> None\n   | (Strsub, [Litv (StrLit str), Litv (IntLit i)]) \\<Rightarrow>\n       if i < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let n = nat \\<bar>i\\<bar>\n            in if length str \\<le> n\n               then Some\n                     ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n               else Some ((?s, ?t1.0), Rval (Litv (lit.Char (str ! n))))\n   | (Strsub, Litv (StrLit str) # Litv (IntLit i) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Strsub, Litv (StrLit str) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub,\n      Litv (StrLit str) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub,\n      Litv (StrLit str) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub, Litv (StrLit str) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Strsub, Litv (StrLit str) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, []) \\<Rightarrow> None\n   | (Strlen, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, [Litv (StrLit str)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length str)))))\n   | (Strlen, Litv (StrLit str) # a # x) \\<Rightarrow> Map.empty x\n   | (Strlen, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Strcat, []) \\<Rightarrow> None\n   | (Strcat, [v2]) \\<Rightarrow>\n       case v_to_list v2 of None \\<Rightarrow> None\n       | Some vs \\<Rightarrow>\n           case vs_to_string vs of None \\<Rightarrow> None\n           | Some str \\<Rightarrow>\n               Some ((?s, ?t1.0), Rval (Litv (StrLit str)))\n   | (Strcat, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (VfromList, []) \\<Rightarrow> None\n   | (VfromList, [v2]) \\<Rightarrow>\n       case v_to_list v2 of None \\<Rightarrow> None\n       | Some vs \\<Rightarrow> Some ((?s, ?t1.0), Rval (Vectorv vs))\n   | (VfromList, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Vsub, []) \\<Rightarrow> None\n   | (Vsub, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, [Vectorv vs]) \\<Rightarrow> None\n   | (Vsub, [Vectorv vs, Litv (IntLit i)]) \\<Rightarrow>\n       if i < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let n = nat \\<bar>i\\<bar>\n            in if length vs \\<le> n\n               then Some\n                     ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n               else Some ((?s, ?t1.0), Rval (vs ! n))\n   | (Vsub, Vectorv vs # Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Vsub, Vectorv vs # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Vsub, Vectorv vs # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Vsub, Vectorv vs # Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Vsub, Vectorv vs # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Vsub, Vectorv vs # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Vsub, Vectorv vs # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Vsub, Vectorv vs # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Vsub, Vectorv vs # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Vsub, Vectorv vs # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Vlength, []) \\<Rightarrow> None\n   | (Vlength, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, [Vectorv vs]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length vs)))))\n   | (Vlength, Vectorv vs # a # x) \\<Rightarrow> Map.empty x\n   | (Aalloc, []) \\<Rightarrow> None\n   | (Aalloc, [Litv (IntLit n)]) \\<Rightarrow> None\n   | (Aalloc, [Litv (IntLit n), v2]) \\<Rightarrow>\n       if n < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let (s', lnum) =\n                  store_alloc (Varray (replicate (nat \\<bar>n\\<bar>) v2)) ?s\n            in Some ((s', ?t1.0), Rval (Loc lnum))\n   | (Aalloc, Litv (IntLit n) # v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, []) \\<Rightarrow> None\n   | (AallocEmpty, Litv x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, [Conv None []]) \\<Rightarrow>\n       let (s', lnum) = store_alloc (Varray []) ?s\n       in Some ((s', ?t1.0), Rval (Loc lnum))\n   | (AallocEmpty, Conv None [] # a # x) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Conv None (a # x) # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Conv (Some x) listb # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (AallocEmpty, Loc x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Asub, []) \\<Rightarrow> None\n   | (Asub, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Asub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Asub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Asub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Asub, [Loc lnum]) \\<Rightarrow> None\n   | (Asub, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray vs) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length vs \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else Some ((?s, ?t1.0), Rval (vs ! n))\n   | (Asub, Loc lnum # Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Asub, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Asub, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Asub, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Asub, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Asub, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Asub, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Asub, Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Asub, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Asub, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Asub, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Alength, []) \\<Rightarrow> None\n   | (Alength, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Alength, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Alength, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Alength, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Alength, [Loc n]) \\<Rightarrow>\n       case store_lookup n ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray ws) \\<Rightarrow>\n           Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length ws)))))\n   | (Alength, Loc n # a # x) \\<Rightarrow> Map.empty x\n   | (Alength, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, []) \\<Rightarrow> None\n   | (Aupdate, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, [Loc lnum]) \\<Rightarrow> None\n   | (Aupdate, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow> None\n   | (Aupdate, [Loc lnum, Litv (IntLit i), v2]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray vs) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length vs \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else case store_assign lnum (Varray (vs[n := v2])) ?s of\n                        None \\<Rightarrow> None\n                        | Some s' \\<Rightarrow>\n                            Some ((s', ?t1.0), Rval (Conv None []))\n   | (Aupdate, Loc lnum # Litv (IntLit i) # v2 # aa # xa) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Aupdate, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aupdate, Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aupdate, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aupdate, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Aupdate, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, []) \\<Rightarrow> None\n   | (ConfigGC, [Litv (IntLit i)]) \\<Rightarrow> None\n   | (ConfigGC, [Litv (IntLit i), Litv (IntLit j)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Conv None []))\n   | (ConfigGC, Litv (IntLit i) # Litv (IntLit j) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC, Litv (IntLit i) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC,\n      Litv (IntLit i) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC,\n      Litv (IntLit i) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC, Litv (IntLit i) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Litv (IntLit i) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Loc x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (FFI n, []) \\<Rightarrow> None\n   | (FFI n, Litv (IntLit xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, Litv (lit.Char xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, [Litv (StrLit conf)]) \\<Rightarrow> None\n   | (FFI n, Litv (StrLit conf) # Litv x # listb) \\<Rightarrow> Map.empty x\n   | (FFI n, Litv (StrLit conf) # Conv option x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n,\n      Litv (StrLit conf) # Closure sem_env lista x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n,\n      Litv (StrLit conf) # Recclosure sem_env list1 x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n, [Litv (StrLit conf), Loc lnum]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           case call_FFI ?t1.0 n\n                 (map (\\<lambda>c2. word_of_nat (of_char c2)) conf) ws of\n           (t', ws') \\<Rightarrow>\n             case store_assign lnum (W8array ws') ?s of\n             None \\<Rightarrow> None\n             | Some s' \\<Rightarrow> Some ((s', t'), Rval (Conv None []))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (FFI n, Litv (StrLit conf) # Loc lnum # a # x) \\<Rightarrow>\n       Map.empty x\n   | (FFI n, Litv (StrLit conf) # Vectorv x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n, Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, Litv (Word64 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Closure sem_env listc x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Recclosure sem_env list1 x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Loc x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Vectorv x # lista) \\<Rightarrow> Map.empty x)\n\ngoal (16 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env op1 es.\n       \\<lbrakk>clock (fst (fun_evaluate st env (rev es))) \\<le> clock st;\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate (dec_clock x) xa [ya]))\n                             \\<le> clock (dec_clock x)\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [App op1 es]))\n                         \\<le> clock st\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 10. \\<And>st env e pes.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate_match x env (hd x1) pes\nBindv))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                          \\<le> clock st\nA total of 16 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env [App op1 es])) \\<le> clock st", "apply (auto split: prod.splits result.splits option.splits if_splits)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>do_opapp (rev x1) = None;\n        do_app (refs st', ffi st') op1 (rev x1) = None; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x1 a b ba.\n       \\<lbrakk>do_opapp (rev x1) = None;\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((a, b), ba);\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 3. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = None; op1 = Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 4. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = None; op1 \\<noteq> Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 5. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = Some ((aa, ba), bb);\n        op1 = Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 6. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((aa, ba), bb);\n        op1 \\<noteq> Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 7. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_opapp (rev x1_) = None;\n     do_app (refs st', ffi st') op1 (rev x1_) = None; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps prod.collapse prod.sel(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 a b ba.\n       \\<lbrakk>do_opapp (rev x1) = None;\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((a, b), ba);\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = None; op1 = Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 3. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = None; op1 \\<noteq> Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 4. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = Some ((aa, ba), bb);\n        op1 = Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 5. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((aa, ba), bb);\n        op1 \\<noteq> Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 6. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_opapp (rev x1_) = None;\n     do_app (refs st', ffi st') op1 (rev x1_) = Some ((a_, b_), ba_);\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps prod.collapse prod.sel(2))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = None; op1 = Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 2. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = None; op1 \\<noteq> Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 3. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = Some ((aa, ba), bb);\n        op1 = Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 4. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((aa, ba), bb);\n        op1 \\<noteq> Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 5. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock st'; do_opapp (rev x1_) = Some (a_, b_);\n     do_app (refs st', ffi st') Opapp (rev x1_) = None; op1 = Opapp;\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a_ [b_]))\n                      \\<le> clock st", "by (smt \"*\" \"9.IH\"(2) One_nat_def Suc_pred dec_clock dual_order.trans fix_clock(1) fix_clock.simps fst_conv le_imp_less_Suc nat_less_le prod.collapse)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a b.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = None; op1 \\<noteq> Opapp;\n        r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = Some ((aa, ba), bb);\n        op1 = Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 3. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((aa, ba), bb);\n        op1 \\<noteq> Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 4. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock st'; do_opapp (rev x1_) = Some (a_, b_);\n     do_app (refs st', ffi st') op1 (rev x1_) = None; op1 \\<noteq> Opapp;\n     r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.collapse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') Opapp (rev x1) = Some ((aa, ba), bb);\n        op1 = Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a [b]))\n                         \\<le> clock st\n 2. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((aa, ba), bb);\n        op1 \\<noteq> Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 3. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock st'; do_opapp (rev x1_) = Some (a_, b_);\n     do_app (refs st', ffi st') Opapp (rev x1_) = Some ((aa_, ba_), bb_);\n     op1 = Opapp; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a_ [b_]))\n                      \\<le> clock st", "using 9(2)[OF *[symmetric], simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>r = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; 0 < clock st'\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') ?xa [?ya]))\n                    \\<le> clock st' - Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock st'; do_opapp (rev x1_) = Some (a_, b_);\n     do_app (refs st', ffi st') Opapp (rev x1_) = Some ((aa_, ba_), bb_);\n     op1 = Opapp; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') a_ [b_]))\n                      \\<le> clock st", "by (smt \"*\" Suc_pred dual_order.trans fix_clock(1) fix_clock.simps le_imp_less_Suc less_irrefl_nat nat_le_linear prod.collapse prod.sel(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 a b aa ba bb.\n       \\<lbrakk>0 < clock st'; do_opapp (rev x1) = Some (a, b);\n        do_app (refs st', ffi st') op1 (rev x1) = Some ((aa, ba), bb);\n        op1 \\<noteq> Opapp; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock st'; do_opapp (rev x1_) = Some (a_, b_);\n     do_app (refs st', ffi st') op1 (rev x1_) = Some ((aa_, ba_), bb_);\n     op1 \\<noteq> Opapp; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps prod.collapse prod.sel(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "using 9(2)[OF *[symmetric], simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>r = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; 0 < clock st'\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate (dec_clock st') ?xa [?ya]))\n                    \\<le> clock st' - Suc 0\n\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "by (smt \"*\" Suc_pred dual_order.trans fix_clock(1) fix_clock.simps le_imp_less_Suc less_irrefl_nat nat_le_linear prod.collapse prod.sel(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [App op1 es])) \\<le> clock st\n\ngoal (15 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 9. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate x\n(update_v (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env) [e2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                          \\<le> clock st\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 9. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate x\n(update_v (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env) [e2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                          \\<le> clock st\nA total of 15 subgoals...", "case (10 st env lop e1 e2)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [e1])) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env [e1]);\n   ?y = Rval ?x1.0; do_log lop (hd ?x1.0) e2 = Some ?x2.0;\n   ?x2.0 = Exp ?x1a\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate ?x env [?x1a])) \\<le> clock ?x\n\ngoal (15 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 9. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate x\n(update_v (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env) [e2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                          \\<le> clock st\nA total of 15 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env [e1]) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env [e1]) = (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env [e1]) = (st', r)\n\ngoal (15 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2;\n            x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x1a]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Log lop e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 9. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> clock\n                               (fst (fun_evaluate x\n(update_v (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env) [e2]))\n                              \\<le> clock x\\<rbrakk>\n        \\<Longrightarrow> clock\n                           (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                          \\<le> clock st\nA total of 15 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env [Log lop e1 e2])) \\<le> clock st", "apply (auto split: prod.splits result.splits option.splits exp_or_val.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>do_log lop (hd x1) e2 = None; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x1 x1a.\n       \\<lbrakk>do_log lop (hd x1) e2 = Some (Exp x1a); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st' env [x1a]))\n                         \\<le> clock st\n 3. \\<And>x1 x2a.\n       \\<lbrakk>do_log lop (hd x1) e2 = Some (Val x2a); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 4. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_log lop (hd x1_) e2 = None; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.collapse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>do_log lop (hd x1) e2 = Some (Exp x1a); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st' env [x1a]))\n                         \\<le> clock st\n 2. \\<And>x1 x2a.\n       \\<lbrakk>do_log lop (hd x1) e2 = Some (Val x2a); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 3. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_log lop (hd x1_) e2 = Some (Exp x1a_); r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate st' env [x1a_]))\n                      \\<le> clock st", "using 10(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>r = Rval ?x1.0; do_log lop (hd ?x1.0) e2 = Some ?x2.0;\n   ?x2.0 = Exp ?x1a\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate st' env [?x1a]))\n                    \\<le> clock st'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>do_log lop (hd x1_) e2 = Some (Exp x1a_); r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate st' env [x1a_]))\n                      \\<le> clock st", "by (metis (no_types, lifting) \"*\" dual_order.trans fix_clock(1) fix_clock.simps fstI prod.collapse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a.\n       \\<lbrakk>do_log lop (hd x1) e2 = Some (Val x2a); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_log lop (hd x1_) e2 = Some (Val x2a_); r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps prod.collapse snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.exhaust_sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [Log lop e1 e2])) \\<le> clock st\n\ngoal (14 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 8. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         clock\n          (fst (fun_evaluate st\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 [e]))\n         \\<le> clock st) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 8. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         clock\n          (fst (fun_evaluate st\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 [e]))\n         \\<le> clock st) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\nA total of 14 subgoals...", "case (11 st env e1 e2 e3)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [e1])) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env [e1]);\n   ?y = Rval ?x1.0; do_if (hd ?x1.0) e2 e3 = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate ?x env [?x2.0])) \\<le> clock ?x\n\ngoal (14 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 8. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         clock\n          (fst (fun_evaluate st\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 [e]))\n         \\<le> clock st) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\nA total of 14 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env [e1]) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env [e1]) = (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env [e1]) = (st', r)\n\ngoal (14 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e1 e2 e3.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> clock (fst (fun_evaluate x env [x2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.If e1 e2 e3]))\n                         \\<le> clock st\n 8. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         clock\n          (fst (fun_evaluate st\n                 (update_v\n                   (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                 [e]))\n         \\<le> clock st) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env [exp0.If e1 e2 e3])) \\<le> clock st", "apply (auto split: prod.splits result.splits option.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>do_if (hd x1) e2 e3 = None; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock st' \\<le> clock st\n 2. \\<And>x1 x2.\n       \\<lbrakk>do_if (hd x1) e2 e3 = Some x2; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st' env [x2]))\n                         \\<le> clock st\n 3. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_if (hd x1_) e2 e3 = None; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.collapse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>do_if (hd x1) e2 e3 = Some x2; r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st' env [x2]))\n                         \\<le> clock st\n 2. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_if (hd x1_) e2 e3 = Some x2_; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate st' env [x2_]))\n                      \\<le> clock st", "using 11(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>r = Rval ?x1.0; do_if (hd ?x1.0) e2 e3 = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> clock (fst (fun_evaluate st' env [?x2.0]))\n                    \\<le> clock st'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>do_if (hd x1_) e2 e3 = Some x2_; r = Rval x1_\\<rbrakk>\n    \\<Longrightarrow> clock (fst (fun_evaluate st' env [x2_]))\n                      \\<le> clock st", "by (metis (no_types, lifting) \"*\" dual_order.trans eq_fst_iff fix_clock(1) fix_clock.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.exhaust_sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [exp0.If e1 e2 e3])) \\<le> clock st\n\ngoal (13 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 8. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 10. \\<And>st env e t1.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 8. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 10. \\<And>st env e t1.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\nA total of 13 subgoals...", "case (12 st env e pes)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [e])) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env [e]);\n   ?y = Rval ?x1.0\\<rbrakk>\n  \\<Longrightarrow> clock\n                     (fst (fun_evaluate_match ?x env (hd ?x1.0) pes Bindv))\n                    \\<le> clock ?x\n\ngoal (13 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 8. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 10. \\<And>st env e t1.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\nA total of 13 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env [e]) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env [e]) = (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env [e]) = (st', r)\n\ngoal (13 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env e pes.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate_match x env (hd x1) pes\n                                     Bindv))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock (fst (fun_evaluate st env [Mat e pes]))\n                         \\<le> clock st\n 8. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 9. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 10. \\<And>st env e t1.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\nA total of 13 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env [Mat e pes])) \\<le> clock st", "apply (auto split: prod.splits result.splits option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       r = Rval x1 \\<Longrightarrow>\n       clock (fst (fun_evaluate_match st' env (hd x1) pes Bindv))\n       \\<le> clock st\n 2. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rval x1_ \\<Longrightarrow>\n    clock (fst (fun_evaluate_match st' env (hd x1_) pes Bindv))\n    \\<le> clock st", "using 12(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  r = Rval ?x1.0 \\<Longrightarrow>\n  clock (fst (fun_evaluate_match st' env (hd ?x1.0) pes Bindv))\n  \\<le> clock st'\n\ngoal (1 subgoal):\n 1. r = Rval x1_ \\<Longrightarrow>\n    clock (fst (fun_evaluate_match st' env (hd x1_) pes Bindv))\n    \\<le> clock st", "by (metis (no_types, lifting) \"*\" dual_order.trans eq_fst_iff fix_clock(1) fix_clock.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.exhaust_sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [Mat e pes])) \\<le> clock st\n\ngoal (12 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 9. \\<And>st env e t1.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\n 10. \\<And>st env e l.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Lannot e l])) \\<le> clock st\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 9. \\<And>st env e t1.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\n 10. \\<And>st env e l.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Lannot e l])) \\<le> clock st\nA total of 12 subgoals...", "case (13 st env xo e1 e2)"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [e1])) \\<le> clock st\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env [e1]);\n   ?y = Rval ?x1.0\\<rbrakk>\n  \\<Longrightarrow> clock\n                     (fst (fun_evaluate ?x\n                            (update_v\n                              (\\<lambda>_.\n                                  nsOptBind xo (hd ?x1.0) (sem_env.v env))\n                              env)\n                            [e2]))\n                    \\<le> clock ?x\n\ngoal (12 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 9. \\<And>st env e t1.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\n 10. \\<And>st env e l.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Lannot e l])) \\<le> clock st\nA total of 12 subgoals...", "obtain st' r where *[simp]: \"fix_clock st (fun_evaluate st env [e1]) = (st', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st' r.\n        fix_clock st (fun_evaluate st env [e1]) = (st', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fix_clock st (fun_evaluate st env [e1]) = (st', r)\n\ngoal (12 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env xo e1 e2.\n       \\<lbrakk>clock (fst (fun_evaluate st env [e1])) \\<le> clock st;\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> clock\n                              (fst (fun_evaluate x\n                                     (update_v\n (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env)) env)\n                                     [e2]))\n                             \\<le> clock x\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (fun_evaluate st env [exp0.Let xo e1 e2]))\n                         \\<le> clock st\n 8. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 9. \\<And>st env e t1.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\n 10. \\<And>st env e l.\n        clock (fst (fun_evaluate st env [e]))\n        \\<le> clock st \\<Longrightarrow>\n        clock (fst (fun_evaluate st env [Lannot e l])) \\<le> clock st\nA total of 12 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (fun_evaluate st env [exp0.Let xo e1 e2])) \\<le> clock st", "apply (auto split: prod.splits result.splits option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       r = Rval x1 \\<Longrightarrow>\n       clock\n        (fst (fun_evaluate st'\n               (update_v (\\<lambda>_. nsOptBind xo (hd x1) (sem_env.v env))\n                 env)\n               [e2]))\n       \\<le> clock st\n 2. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rval x1_ \\<Longrightarrow>\n    clock\n     (fst (fun_evaluate st'\n            (update_v (\\<lambda>_. nsOptBind xo (hd x1_) (sem_env.v env))\n              env)\n            [e2]))\n    \\<le> clock st", "using 13(2)[OF *[symmetric]]"], ["proof (prove)\nusing this:\n  r = Rval ?x1.0 \\<Longrightarrow>\n  clock\n   (fst (fun_evaluate st'\n          (update_v (\\<lambda>_. nsOptBind xo (hd ?x1.0) (sem_env.v env))\n            env)\n          [e2]))\n  \\<le> clock st'\n\ngoal (1 subgoal):\n 1. r = Rval x1_ \\<Longrightarrow>\n    clock\n     (fst (fun_evaluate st'\n            (update_v (\\<lambda>_. nsOptBind xo (hd x1_) (sem_env.v env))\n              env)\n            [e2]))\n    \\<le> clock st", "by (metis (no_types, lifting) \"*\" dual_order.trans eq_fst_iff fix_clock(1) fix_clock.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2. r = Rerr x2 \\<Longrightarrow> clock st' \\<le> clock st", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = Rerr x2_ \\<Longrightarrow> clock st' \\<le> clock st", "by (metis \"*\" fix_clock(1) fix_clock.simps fst_conv prod.exhaust_sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock (fst (fun_evaluate st env [exp0.Let xo e1 e2])) \\<le> clock st\n\ngoal (11 subgoals):\n 1. \\<And>st env. clock (fst (fun_evaluate st env [])) \\<le> clock st\n 2. \\<And>st env l. clock (fst (fun_evaluate st env [Lit l])) \\<le> clock st\n 3. \\<And>st env e.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Raise e])) \\<le> clock st\n 4. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        clock (fst (fun_evaluate st env (rev es)))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Con cn es])) \\<le> clock st\n 5. \\<And>st env n. clock (fst (fun_evaluate st env [Var n])) \\<le> clock st\n 6. \\<And>st env x e.\n       clock (fst (fun_evaluate st env [Fun x e])) \\<le> clock st\n 7. \\<And>st env funs e.\n       (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n        clock\n         (fst (fun_evaluate st\n                (update_v\n                  (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n                [e]))\n        \\<le> clock st) \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Letrec funs e])) \\<le> clock st\n 8. \\<And>st env e t1.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Tannot e t1])) \\<le> clock st\n 9. \\<And>st env e l.\n       clock (fst (fun_evaluate st env [e]))\n       \\<le> clock st \\<Longrightarrow>\n       clock (fst (fun_evaluate st env [Lannot e l])) \\<le> clock st\n 10. \\<And>st env v2 err_v.\n        clock (fst (fun_evaluate_match st env v2 [] err_v)) \\<le> clock st\nA total of 11 subgoals...", "qed (auto split: prod.splits result.splits option.splits match_result.splits)"], ["", "lemma fun_evaluate_clock:\n  \"fun_evaluate_match s1 env v p v' = (s2, r) \\<Longrightarrow> clock s2 \\<le> clock s1\"\n  \"fun_evaluate s1 env e = (s2, r) \\<Longrightarrow> clock s2 \\<le> clock s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fun_evaluate_match s1 env v p v' = (s2, r) \\<Longrightarrow>\n     clock s2 \\<le> clock s1) &&&\n    (fun_evaluate s1 env e = (s2, r) \\<Longrightarrow>\n     clock s2 \\<le> clock s1)", "using fun_evaluate_clock0"], ["proof (prove)\nusing this:\n  clock (fst (fun_evaluate_match ?s1.0 ?env ?v ?p ?v')) \\<le> clock ?s1.0\n  clock (fst (fun_evaluate ?s1.0 ?env ?e)) \\<le> clock ?s1.0\n\ngoal (1 subgoal):\n 1. (fun_evaluate_match s1 env v p v' = (s2, r) \\<Longrightarrow>\n     clock s2 \\<le> clock s1) &&&\n    (fun_evaluate s1 env e = (s2, r) \\<Longrightarrow>\n     clock s2 \\<le> clock s1)", "by (metis fst_conv)+"], ["", "end"], ["", "lemma fix_clock_evaluate[simp]:\n  \"fix_clock s1 (fun_evaluate s1 env e) = fun_evaluate s1 env e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix_clock s1 (fun_evaluate s1 env e) = fun_evaluate s1 env e", "unfolding fix_clock_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fun_evaluate s1 env e of\n     (x3a, x) \\<Rightarrow>\n       (update_clock\n         (\\<lambda>_.\n             if clock x3a \\<le> clock s1 then clock x3a else clock s1)\n         x3a,\n        x)) =\n    fun_evaluate s1 env e", "using fun_evaluate_clock"], ["proof (prove)\nusing this:\n  fun_evaluate_match ?s1.0 ?env ?v ?p ?v' = (?s2.0, ?r) \\<Longrightarrow>\n  clock ?s2.0 \\<le> clock ?s1.0\n  fun_evaluate ?s1.0 ?env ?e = (?s2.0, ?r) \\<Longrightarrow>\n  clock ?s2.0 \\<le> clock ?s1.0\n\ngoal (1 subgoal):\n 1. (case fun_evaluate s1 env e of\n     (x3a, x) \\<Rightarrow>\n       (update_clock\n         (\\<lambda>_.\n             if clock x3a \\<le> clock s1 then clock x3a else clock s1)\n         x3a,\n        x)) =\n    fun_evaluate s1 env e", "by (fastforce split: prod.splits)"], ["", "declare fun_evaluate.simps[simp del]"], ["", "declare fun_evaluate_match.simps[simp del]"], ["", "lemmas fun_evaluate_simps[simp] =\n  fun_evaluate.simps[unfolded fix_clock_evaluate]\n  fun_evaluate_match.simps[unfolded fix_clock_evaluate]"], ["", "lemmas fun_evaluate_induct =\n  fun_evaluate_match_fun_evaluate.induct[unfolded fix_clock_evaluate]"], ["", "lemma fun_evaluate_length:\n  \"fun_evaluate_match s env v pes err_v = (s', res) \\<Longrightarrow> (case res of Rval vs \\<Rightarrow> length vs = 1 | _ \\<Rightarrow> True)\"\n  \"fun_evaluate s env es = (s', res) \\<Longrightarrow> (case res of Rval vs \\<Rightarrow> length vs = length es | _ \\<Rightarrow> True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fun_evaluate_match s env v pes err_v = (s', res) \\<Longrightarrow>\n     case res of Rval vs \\<Rightarrow> length vs = 1\n     | Rerr error_result \\<Rightarrow> True) &&&\n    (fun_evaluate s env es = (s', res) \\<Longrightarrow>\n     case res of Rval vs \\<Rightarrow> length vs = length es\n     | Rerr error_result \\<Rightarrow> True)", "proof (induction arbitrary: s' res and s' res rule: fun_evaluate_match_fun_evaluate.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>st env s' res.\n       fun_evaluate st env [] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length []\n       | Rerr error_result \\<Rightarrow> True\n 2. \\<And>st env e1 e2 es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e1]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x1 s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; fun_evaluate x env (e2 # es) = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of\n                             Rval vs \\<Rightarrow>\n                               length vs = length (e2 # es)\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env (e1 # e2 # es) = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length (e1 # e2 # es)\n                         | Rerr error_result \\<Rightarrow> True\n 3. \\<And>st env l s' res.\n       fun_evaluate st env [Lit l] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Lit l]\n       | Rerr error_result \\<Rightarrow> True\n 4. \\<And>st env e s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e]\n                   | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Raise e] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow> length vs = length [Raise e]\n                         | Rerr error_result \\<Rightarrow> True\n 5. \\<And>st env e pes s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x2 x1 s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1;\n            fun_evaluate_match x env x1 pes x1 = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of Rval vs \\<Rightarrow> length vs = 1\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Handle e pes] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Handle e pes]\n                         | Rerr error_result \\<Rightarrow> True\n 6. \\<And>st env cn es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   \\<lbrakk>do_con_check (c env) cn (length es);\n                    fun_evaluate st env (rev es) = (s', res)\\<rbrakk>\n                   \\<Longrightarrow> case res of\n                                     Rval vs \\<Rightarrow>\n length vs = length (rev es)\n                                     | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Con cn es] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Con cn es]\n                         | Rerr error_result \\<Rightarrow> True\n 7. \\<And>st env n s' res.\n       fun_evaluate st env [Var n] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Var n]\n       | Rerr error_result \\<Rightarrow> True\n 8. \\<And>st env x e s' res.\n       fun_evaluate st env [Fun x e] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Fun x e]\n       | Rerr error_result \\<Rightarrow> True\n 9. \\<And>st env op1 es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env (rev es) =\n                   (s', res) \\<Longrightarrow>\n                   case res of\n                   Rval vs \\<Rightarrow> length vs = length (rev es)\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x1 x2 xa ya s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0;\n            fun_evaluate (dec_clock x) xa [ya] = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of\n                             Rval vs \\<Rightarrow> length vs = length [ya]\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [App op1 es] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [App op1 es]\n                         | Rerr error_result \\<Rightarrow> True\n 10. \\<And>st env lop e1 e2 s' res.\n        \\<lbrakk>\\<And>s' res.\n                    fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                    case res of\n                    Rval vs \\<Rightarrow> length vs = length [e1]\n                    | Rerr error_result \\<Rightarrow> True;\n         \\<And>x y x1 x2 x1a s' res.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a;\n             fun_evaluate x env [x1a] = (s', res)\\<rbrakk>\n            \\<Longrightarrow> case res of\n                              Rval vs \\<Rightarrow> length vs = length [x1a]\n                              | Rerr error_result \\<Rightarrow> True;\n         fun_evaluate st env [Log lop e1 e2] = (s', res)\\<rbrakk>\n        \\<Longrightarrow> case res of\n                          Rval vs \\<Rightarrow>\n                            length vs = length [Log lop e1 e2]\n                          | Rerr error_result \\<Rightarrow> True\nA total of 18 subgoals...", "case (9 st env op1 es)"], ["proof (state)\nthis:\n  fun_evaluate st env (rev es) = (?s', ?res) \\<Longrightarrow>\n  case ?res of Rval vs \\<Rightarrow> length vs = length (rev es)\n  | Rerr error_result \\<Rightarrow> True\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env (rev es));\n   ?y = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; clock ?x \\<noteq> 0;\n   fun_evaluate (dec_clock ?x) ?xa [?ya] = (?s', ?res)\\<rbrakk>\n  \\<Longrightarrow> case ?res of\n                    Rval vs \\<Rightarrow> length vs = length [?ya]\n                    | Rerr error_result \\<Rightarrow> True\n  fun_evaluate st env [App op1 es] = (s', res)\n\ngoal (18 subgoals):\n 1. \\<And>st env s' res.\n       fun_evaluate st env [] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length []\n       | Rerr error_result \\<Rightarrow> True\n 2. \\<And>st env e1 e2 es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e1]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x1 s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; fun_evaluate x env (e2 # es) = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of\n                             Rval vs \\<Rightarrow>\n                               length vs = length (e2 # es)\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env (e1 # e2 # es) = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length (e1 # e2 # es)\n                         | Rerr error_result \\<Rightarrow> True\n 3. \\<And>st env l s' res.\n       fun_evaluate st env [Lit l] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Lit l]\n       | Rerr error_result \\<Rightarrow> True\n 4. \\<And>st env e s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e]\n                   | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Raise e] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow> length vs = length [Raise e]\n                         | Rerr error_result \\<Rightarrow> True\n 5. \\<And>st env e pes s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x2 x1 s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1;\n            fun_evaluate_match x env x1 pes x1 = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of Rval vs \\<Rightarrow> length vs = 1\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Handle e pes] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Handle e pes]\n                         | Rerr error_result \\<Rightarrow> True\n 6. \\<And>st env cn es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   \\<lbrakk>do_con_check (c env) cn (length es);\n                    fun_evaluate st env (rev es) = (s', res)\\<rbrakk>\n                   \\<Longrightarrow> case res of\n                                     Rval vs \\<Rightarrow>\n length vs = length (rev es)\n                                     | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Con cn es] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Con cn es]\n                         | Rerr error_result \\<Rightarrow> True\n 7. \\<And>st env n s' res.\n       fun_evaluate st env [Var n] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Var n]\n       | Rerr error_result \\<Rightarrow> True\n 8. \\<And>st env x e s' res.\n       fun_evaluate st env [Fun x e] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Fun x e]\n       | Rerr error_result \\<Rightarrow> True\n 9. \\<And>st env op1 es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env (rev es) =\n                   (s', res) \\<Longrightarrow>\n                   case res of\n                   Rval vs \\<Rightarrow> length vs = length (rev es)\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x1 x2 xa ya s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env (rev es));\n            y = Rval x1; op1 = Opapp; do_opapp (rev x1) = Some x2;\n            (xa, ya) = x2; clock x \\<noteq> 0;\n            fun_evaluate (dec_clock x) xa [ya] = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of\n                             Rval vs \\<Rightarrow> length vs = length [ya]\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [App op1 es] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [App op1 es]\n                         | Rerr error_result \\<Rightarrow> True\n 10. \\<And>st env lop e1 e2 s' res.\n        \\<lbrakk>\\<And>s' res.\n                    fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                    case res of\n                    Rval vs \\<Rightarrow> length vs = length [e1]\n                    | Rerr error_result \\<Rightarrow> True;\n         \\<And>x y x1 x2 x1a s' res.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a;\n             fun_evaluate x env [x1a] = (s', res)\\<rbrakk>\n            \\<Longrightarrow> case res of\n                              Rval vs \\<Rightarrow> length vs = length [x1a]\n                              | Rerr error_result \\<Rightarrow> True;\n         fun_evaluate st env [Log lop e1 e2] = (s', res)\\<rbrakk>\n        \\<Longrightarrow> case res of\n                          Rval vs \\<Rightarrow>\n                            length vs = length [Log lop e1 e2]\n                          | Rerr error_result \\<Rightarrow> True\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  fun_evaluate st env (rev es) = (?s', ?res) \\<Longrightarrow>\n  case ?res of Rval vs \\<Rightarrow> length vs = length (rev es)\n  | Rerr error_result \\<Rightarrow> True\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env (rev es));\n   ?y = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; clock ?x \\<noteq> 0;\n   fun_evaluate (dec_clock ?x) ?xa [?ya] = (?s', ?res)\\<rbrakk>\n  \\<Longrightarrow> case ?res of\n                    Rval vs \\<Rightarrow> length vs = length [?ya]\n                    | Rerr error_result \\<Rightarrow> True\n  fun_evaluate st env [App op1 es] = (s', res)", "show ?case"], ["proof (prove)\nusing this:\n  fun_evaluate st env (rev es) = (?s', ?res) \\<Longrightarrow>\n  case ?res of Rval vs \\<Rightarrow> length vs = length (rev es)\n  | Rerr error_result \\<Rightarrow> True\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env (rev es));\n   ?y = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; clock ?x \\<noteq> 0;\n   fun_evaluate (dec_clock ?x) ?xa [?ya] = (?s', ?res)\\<rbrakk>\n  \\<Longrightarrow> case ?res of\n                    Rval vs \\<Rightarrow> length vs = length [?ya]\n                    | Rerr error_result \\<Rightarrow> True\n  fun_evaluate st env [App op1 es] = (s', res)\n\ngoal (1 subgoal):\n 1. case res of Rval vs \\<Rightarrow> length vs = length [App op1 es]\n    | Rerr error_result \\<Rightarrow> True", "supply do_app.simps[simp del]"], ["proof (prove)\nusing this:\n  fun_evaluate st env (rev es) = (?s', ?res) \\<Longrightarrow>\n  case ?res of Rval vs \\<Rightarrow> length vs = length (rev es)\n  | Rerr error_result \\<Rightarrow> True\n  \\<lbrakk>(?x, ?y) = fix_clock st (fun_evaluate st env (rev es));\n   ?y = Rval ?x1.0; op1 = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0;\n   (?xa, ?ya) = ?x2.0; clock ?x \\<noteq> 0;\n   fun_evaluate (dec_clock ?x) ?xa [?ya] = (?s', ?res)\\<rbrakk>\n  \\<Longrightarrow> case ?res of\n                    Rval vs \\<Rightarrow> length vs = length [?ya]\n                    | Rerr error_result \\<Rightarrow> True\n  fun_evaluate st env [App op1 es] = (s', res)\n\ngoal (1 subgoal):\n 1. case res of Rval vs \\<Rightarrow> length vs = length [App op1 es]\n    | Rerr error_result \\<Rightarrow> True", "apply (fastforce\n        split: if_splits prod.splits result.splits option.splits exp_or_val.splits match_result.splits error_result.splits\n        simp: list_result_alt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case res of Rval vs \\<Rightarrow> length vs = length [App op1 es]\n  | Rerr error_result \\<Rightarrow> True\n\ngoal (17 subgoals):\n 1. \\<And>st env s' res.\n       fun_evaluate st env [] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length []\n       | Rerr error_result \\<Rightarrow> True\n 2. \\<And>st env e1 e2 es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e1]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x1 s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; fun_evaluate x env (e2 # es) = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of\n                             Rval vs \\<Rightarrow>\n                               length vs = length (e2 # es)\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env (e1 # e2 # es) = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length (e1 # e2 # es)\n                         | Rerr error_result \\<Rightarrow> True\n 3. \\<And>st env l s' res.\n       fun_evaluate st env [Lit l] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Lit l]\n       | Rerr error_result \\<Rightarrow> True\n 4. \\<And>st env e s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e]\n                   | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Raise e] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow> length vs = length [Raise e]\n                         | Rerr error_result \\<Rightarrow> True\n 5. \\<And>st env e pes s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x2 x1 s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e]);\n            y = Rerr x2; x2 = Rraise x1;\n            fun_evaluate_match x env x1 pes x1 = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of Rval vs \\<Rightarrow> length vs = 1\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Handle e pes] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Handle e pes]\n                         | Rerr error_result \\<Rightarrow> True\n 6. \\<And>st env cn es s' res.\n       \\<lbrakk>\\<And>s' res.\n                   \\<lbrakk>do_con_check (c env) cn (length es);\n                    fun_evaluate st env (rev es) = (s', res)\\<rbrakk>\n                   \\<Longrightarrow> case res of\n                                     Rval vs \\<Rightarrow>\n length vs = length (rev es)\n                                     | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Con cn es] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Con cn es]\n                         | Rerr error_result \\<Rightarrow> True\n 7. \\<And>st env n s' res.\n       fun_evaluate st env [Var n] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Var n]\n       | Rerr error_result \\<Rightarrow> True\n 8. \\<And>st env x e s' res.\n       fun_evaluate st env [Fun x e] = (s', res) \\<Longrightarrow>\n       case res of Rval vs \\<Rightarrow> length vs = length [Fun x e]\n       | Rerr error_result \\<Rightarrow> True\n 9. \\<And>st env lop e1 e2 s' res.\n       \\<lbrakk>\\<And>s' res.\n                   fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                   case res of Rval vs \\<Rightarrow> length vs = length [e1]\n                   | Rerr error_result \\<Rightarrow> True;\n        \\<And>x y x1 x2 x1a s' res.\n           \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n            y = Rval x1; do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a;\n            fun_evaluate x env [x1a] = (s', res)\\<rbrakk>\n           \\<Longrightarrow> case res of\n                             Rval vs \\<Rightarrow> length vs = length [x1a]\n                             | Rerr error_result \\<Rightarrow> True;\n        fun_evaluate st env [Log lop e1 e2] = (s', res)\\<rbrakk>\n       \\<Longrightarrow> case res of\n                         Rval vs \\<Rightarrow>\n                           length vs = length [Log lop e1 e2]\n                         | Rerr error_result \\<Rightarrow> True\n 10. \\<And>st env e1 e2 e3 s' res.\n        \\<lbrakk>\\<And>s' res.\n                    fun_evaluate st env [e1] = (s', res) \\<Longrightarrow>\n                    case res of\n                    Rval vs \\<Rightarrow> length vs = length [e1]\n                    | Rerr error_result \\<Rightarrow> True;\n         \\<And>x y x1 x2 s' res.\n            \\<lbrakk>(x, y) = fix_clock st (fun_evaluate st env [e1]);\n             y = Rval x1; do_if (hd x1) e2 e3 = Some x2;\n             fun_evaluate x env [x2] = (s', res)\\<rbrakk>\n            \\<Longrightarrow> case res of\n                              Rval vs \\<Rightarrow> length vs = length [x2]\n                              | Rerr error_result \\<Rightarrow> True;\n         fun_evaluate st env [exp0.If e1 e2 e3] = (s', res)\\<rbrakk>\n        \\<Longrightarrow> case res of\n                          Rval vs \\<Rightarrow>\n                            length vs = length [exp0.If e1 e2 e3]\n                          | Rerr error_result \\<Rightarrow> True\nA total of 17 subgoals...", "qed (fastforce\n      split: if_splits prod.splits result.splits option.splits exp_or_val.splits\n             match_result.splits error_result.splits)+"], ["", "lemma fun_evaluate_matchE:\n  assumes \"fun_evaluate_match s env v pes err_v = (s', Rval vs)\"\n  obtains v where \"vs = [v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. vs = [v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using fun_evaluate_length(1)[OF assms]"], ["proof (prove)\nusing this:\n  case Rval vs of Rval vs \\<Rightarrow> length vs = 1\n  | Rerr error_result \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. (\\<And>v. vs = [v] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases vs) auto"], ["", "end"]]}