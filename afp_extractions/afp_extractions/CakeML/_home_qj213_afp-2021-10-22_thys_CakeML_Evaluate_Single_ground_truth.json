{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Evaluate_Single.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma evaluate_list_cong[fundef_cong]:\n  assumes \"\\<And>e s. e \\<in> set es1 \\<Longrightarrow> clock s \\<le> clock s1 \\<Longrightarrow> eval1 s e = eval2 s e\" \"s1 = s2\" \"es1 = es2\"\n  shows \"evaluate_list eval1 s1 es1 = evaluate_list eval2 s2 es2\"", "lemma match_result_elem:\n  assumes \"match_result env s v0 pes err_v = Rval (e, env')\"\n  shows \"\\<exists>pat. (pat, e) \\<in> set pes\"", "lemma evaluate_list_clock_monotone: \"clock (fst (evaluate_list eval s es)) \\<le> clock s\"", "lemma i_hate_words_helper:\n  \"i \\<le> (j - k :: nat) \\<Longrightarrow> i \\<le> j\"", "lemma evaluate_clock_monotone:\n  \\<open>clock (fst (evaluate env s e)) \\<le> clock s\\<close>\n  if \\<open>evaluate_dom (env, s, e)\\<close>", "lemma pat_elem_less_size:\n  \"(pat, e) \\<in> set pes \\<Longrightarrow> size_exp' e < (size_list (size_prod size size_exp') pes)\"", "lemma elem_less_size: \"e \\<in> set es \\<Longrightarrow> size_exp' e \\<le> size_list size_exp' es\"", "lemma evaluate_total: \"All evaluate_dom\"", "lemma evaluate_clock_monotone': \"evaluate eval s e = (s', r) \\<Longrightarrow>  clock s' \\<le> clock s\"", "lemma fix_clock_evaluate[simp]: \"fix_clock s (evaluate eval s e) = evaluate eval s e\"", "lemma evaluate_list_eq[simp]: \"evaluate_list (evaluate env) = evaluate_list' env\"", "lemma fun_evaluate_equiv:\n  \"fun_evaluate_match s env v pes err_v = (case match_result env s v pes err_v of\n      Rerr err \\<Rightarrow> (s, Rerr err)\n    | Rval (e, env') \\<Rightarrow> evaluate_list (evaluate (env \\<lparr> sem_env.v := (nsAppend (alist_to_ns env') (sem_env.v env)) \\<rparr>)) s [e])\"\n  \"fun_evaluate s env es = evaluate_list (evaluate env) s es\""], "translations": [["", "lemma evaluate_list_cong[fundef_cong]:\n  assumes \"\\<And>e s. e \\<in> set es1 \\<Longrightarrow> clock s \\<le> clock s1 \\<Longrightarrow> eval1 s e = eval2 s e\" \"s1 = s2\" \"es1 = es2\"\n  shows \"evaluate_list eval1 s1 es1 = evaluate_list eval2 s2 es2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate_list eval1 s1 es1 =\n    Evaluate_Single.evaluate_list eval2 s2 es2", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?e \\<in> set es1; clock ?s \\<le> clock s1\\<rbrakk>\n  \\<Longrightarrow> eval1 ?s ?e = eval2 ?s ?e\n  s1 = s2\n  es1 = es2\n\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate_list eval1 s1 es1 =\n    Evaluate_Single.evaluate_list eval2 s2 es2", "by (induction es1 arbitrary: es2 s1 s2) (fastforce simp: fix_clock_alt_def split: prod.splits result.splits)+"], ["", "function (sequential)\nevaluate :: \" v sem_env \\<Rightarrow>'ffi state \\<Rightarrow> exp \\<Rightarrow> 'ffi state*(v,v) result\" where\n\nLit:\n\"evaluate env s (Lit l) = (s, Rval (Litv l))\" |\n\nRaise:\n\"evaluate env s (Raise e) =\n  (case evaluate env s e of\n    (s', Rval v) \\<Rightarrow> (s', Rerr (Rraise (v)))\n  | res \\<Rightarrow> res)\" |\n\nHandle:\n\"evaluate env s (Handle e pes) =\n  (case evaluate env s e of\n    (s', Rerr (Rraise v)) \\<Rightarrow>\n      (case match_result env s' v pes v of\n        (Rval (e', env')) \\<Rightarrow>\n          evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s' e'\n      | (Rerr err) \\<Rightarrow> (s', Rerr err))\n  | res \\<Rightarrow> res)\" |\n\nCon:\n\"evaluate env s (Con cn es) =\n  (if do_con_check (c env) cn (length es) then\n    (case evaluate_list (evaluate env) s (rev es) of\n      (s', Rval vs) \\<Rightarrow>\n        (case build_conv (c env) cn (rev vs) of\n          Some v \\<Rightarrow> (s', Rval v)\n        | None \\<Rightarrow> (s', Rerr (Rabort Rtype_error)))\n    | (s', Rerr err) \\<Rightarrow> (s', Rerr err))\n  else (s, Rerr (Rabort Rtype_error)))\" |\n\nVar:\n\"evaluate env s (Var n) =\n  (case nsLookup (sem_env.v env) n of\n    Some v \\<Rightarrow> (s, Rval v)\n  | None \\<Rightarrow> (s, Rerr (Rabort Rtype_error)))\" |\n\nFun:\n\"evaluate env s (Fun n e) = (s, Rval (Closure env n e))\" |\n\nApp:\n\"evaluate env s (App op0 es) =\n  (case evaluate_list (evaluate env) s (rev es) of\n    (s', Rval vs) \\<Rightarrow>\n      (if op0 = Opapp then\n        (case do_opapp (rev vs) of\n          Some (env', e) \\<Rightarrow>\n            (if (clock s' = 0) then\n              (s', Rerr (Rabort Rtimeout_error))\n            else\n              evaluate env' (dec_clock s') e)\n        | None \\<Rightarrow> (s', Rerr (Rabort Rtype_error)))\n      else\n        (case do_app (refs s', ffi s') op0 (rev vs) of\n          Some ((refs',ffi'), res) \\<Rightarrow> (s' \\<lparr>refs:=refs',ffi:=ffi'\\<rparr>, res)\n        | None \\<Rightarrow> (s', Rerr (Rabort Rtype_error))))\n  | (s', Rerr err) \\<Rightarrow> (s', Rerr err))\" |\n\nLog:\n\"evaluate env s (Log op0 e1 e2) =\n  (case evaluate env s e1 of\n    (s', Rval v) \\<Rightarrow>\n      (case do_log op0 v e2 of\n        Some (Exp e') \\<Rightarrow> evaluate env s' e'\n      | Some (Val bv) \\<Rightarrow> (s', Rval bv)\n      | None \\<Rightarrow> (s', Rerr (Rabort Rtype_error)))\n  | res \\<Rightarrow> res)\" |\n\nIf:\n\"evaluate env s (If e1 e2 e3) =\n  (case evaluate env s e1 of\n    (s', Rval v) \\<Rightarrow>\n      (case do_if v e2 e3 of\n        Some e' \\<Rightarrow> evaluate env s' e'\n      | None \\<Rightarrow> (s', Rerr (Rabort Rtype_error)))\n  | res \\<Rightarrow> res)\" |\n\nMat:\n\"evaluate env s (Mat e pes) =\n  (case evaluate env s e of\n    (s', Rval v) \\<Rightarrow>\n      (case match_result env s' v pes Bindv of\n        Rval (e', env') \\<Rightarrow>\n          evaluate (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>) s' e'\n      | Rerr err \\<Rightarrow> (s', Rerr err))\n  | res \\<Rightarrow> res)\" |\n\nLet:\n\"evaluate env s (Let n e1 e2) =\n  (case evaluate env s e1 of\n    (s', Rval v) \\<Rightarrow>\n      evaluate ( env \\<lparr> sem_env.v := (nsOptBind n v(sem_env.v env)) \\<rparr>) s' e2\n  | res \\<Rightarrow> res)\" |\n\nLetrec:\n\"evaluate env s (Letrec funs e) =\n  (if distinct (List.map (\\<lambda>x. (case  x of (x,y,z) => x )) funs) then\n    evaluate ( env \\<lparr> sem_env.v := (build_rec_env funs env(sem_env.v env)) \\<rparr>) s e\n  else\n    (s, Rerr (Rabort Rtype_error)))\" |\n\nTannot:\n\"evaluate env s (Tannot e t0) = evaluate env s e\" |\n\nLannot:\n\"evaluate env s (Lannot e l) = evaluate env s e\""], ["proof (prove)\ngoal (106 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>env s l. x = (env, s, Lit l) \\<Longrightarrow> P;\n        \\<And>env s e. x = (env, s, Raise e) \\<Longrightarrow> P;\n        \\<And>env s e pes. x = (env, s, Handle e pes) \\<Longrightarrow> P;\n        \\<And>env s cn es. x = (env, s, Con cn es) \\<Longrightarrow> P;\n        \\<And>env s n. x = (env, s, Var n) \\<Longrightarrow> P;\n        \\<And>env s n e. x = (env, s, Fun n e) \\<Longrightarrow> P;\n        \\<And>env s op0 es. x = (env, s, App op0 es) \\<Longrightarrow> P;\n        \\<And>env s op0 e1 e2.\n           x = (env, s, Log op0 e1 e2) \\<Longrightarrow> P;\n        \\<And>env s e1 e2 e3.\n           x = (env, s, exp0.If e1 e2 e3) \\<Longrightarrow> P;\n        \\<And>env s e pes. x = (env, s, Mat e pes) \\<Longrightarrow> P;\n        \\<And>env s n e1 e2.\n           x = (env, s, exp0.Let n e1 e2) \\<Longrightarrow> P;\n        \\<And>env s funs e. x = (env, s, Letrec funs e) \\<Longrightarrow> P;\n        \\<And>env s e t0. x = (env, s, Tannot e t0) \\<Longrightarrow> P;\n        \\<And>env s e l.\n           x = (env, s, Lannot e l) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>env s l enva sa la.\n       (env, s, Lit l) = (enva, sa, Lit la) \\<Longrightarrow>\n       (s, Rval (Litv l)) = (sa, Rval (Litv la))\n 3. \\<And>env s l enva sa e.\n       (env, s, Lit l) = (enva, sa, Raise e) \\<Longrightarrow>\n       (s, Rval (Litv l)) =\n       (case evaluate_sumC (enva, sa, e) of\n        (s', Rval v) \\<Rightarrow> (s', Rerr (Rraise v))\n        | (s', Rerr error_result) \\<Rightarrow> (s', Rerr error_result))\n 4. \\<And>env s l enva sa e pes.\n       (env, s, Lit l) = (enva, sa, Handle e pes) \\<Longrightarrow>\n       (s, Rval (Litv l)) =\n       (case evaluate_sumC (enva, sa, e) of\n        (s', Rval ab) \\<Rightarrow> (s', Rval ab)\n        | (s', Rerr (Rraise va)) \\<Rightarrow>\n            case match_result enva s' va pes va of\n            Rval (e', env') \\<Rightarrow>\n              evaluate_sumC\n               (update_v\n                 (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v enva))\n                 enva,\n                s', e')\n            | Rerr err \\<Rightarrow> (s', Rerr err)\n        | (s', Rerr (Rabort abort)) \\<Rightarrow> (s', Rerr (Rabort abort)))\n 5. \\<And>env s l enva sa cn es.\n       (env, s, Lit l) = (enva, sa, Con cn es) \\<Longrightarrow>\n       (s, Rval (Litv l)) =\n       (if do_con_check (c enva) cn (length es)\n        then case Evaluate_Single.evaluate_list\n                   (\\<lambda>x1 x2. evaluate_sumC (enva, x1, x2)) sa\n                   (rev es) of\n             (s', Rval vs) \\<Rightarrow>\n               case build_conv (c enva) cn (rev vs) of\n               None \\<Rightarrow> (s', Rerr (Rabort Rtype_error))\n               | Some v \\<Rightarrow> (s', Rval v)\n             | (s', Rerr err) \\<Rightarrow> (s', Rerr err)\n        else (sa, Rerr (Rabort Rtype_error)))\n 6. \\<And>env s l enva sa n.\n       (env, s, Lit l) = (enva, sa, Var n) \\<Longrightarrow>\n       (s, Rval (Litv l)) =\n       (case nsLookup (sem_env.v enva) n of\n        None \\<Rightarrow> (sa, Rerr (Rabort Rtype_error))\n        | Some v \\<Rightarrow> (sa, Rval v))\n 7. \\<And>env s l enva sa n e.\n       (env, s, Lit l) = (enva, sa, Fun n e) \\<Longrightarrow>\n       (s, Rval (Litv l)) = (sa, Rval (Closure enva n e))\n 8. \\<And>env s l enva sa op0 es.\n       (env, s, Lit l) = (enva, sa, App op0 es) \\<Longrightarrow>\n       (s, Rval (Litv l)) =\n       (case Evaluate_Single.evaluate_list\n              (\\<lambda>x1 x2. evaluate_sumC (enva, x1, x2)) sa (rev es) of\n        (s', Rval vs) \\<Rightarrow>\n          if op0 = Opapp\n          then case do_opapp (rev vs) of\n               None \\<Rightarrow> (s', Rerr (Rabort Rtype_error))\n               | Some (env', e) \\<Rightarrow>\n                   if clock s' = 0 then (s', Rerr (Rabort Rtimeout_error))\n                   else evaluate_sumC (env', dec_clock s', e)\n          else case do_app (refs s', ffi s') op0 (rev vs) of\n               None \\<Rightarrow> (s', Rerr (Rabort Rtype_error))\n               | Some ((refs', ffi'), res) \\<Rightarrow>\n                   (update_ffi (\\<lambda>_. ffi')\n                     (update_refs (\\<lambda>_. refs') s'),\n                    res)\n        | (s', Rerr err) \\<Rightarrow> (s', Rerr err))\n 9. \\<And>env s l enva sa op0 e1 e2.\n       (env, s, Lit l) = (enva, sa, Log op0 e1 e2) \\<Longrightarrow>\n       (s, Rval (Litv l)) =\n       (case evaluate_sumC (enva, sa, e1) of\n        (s', Rval v) \\<Rightarrow>\n          case do_log op0 v e2 of\n          None \\<Rightarrow> (s', Rerr (Rabort Rtype_error))\n          | Some (Exp x2) \\<Rightarrow> evaluate_sumC (enva, s', x2)\n          | Some (Val bv) \\<Rightarrow> (s', Rval bv)\n        | (s', Rerr error_result) \\<Rightarrow> (s', Rerr error_result))\n 10. \\<And>env s l enva sa e1 e2 e3.\n        (env, s, Lit l) = (enva, sa, exp0.If e1 e2 e3) \\<Longrightarrow>\n        (s, Rval (Litv l)) =\n        (case evaluate_sumC (enva, sa, e1) of\n         (s', Rval v) \\<Rightarrow>\n           case do_if v e2 e3 of\n           None \\<Rightarrow> (s', Rerr (Rabort Rtype_error))\n           | Some x2 \\<Rightarrow> evaluate_sumC (enva, s', x2)\n         | (s', Rerr error_result) \\<Rightarrow> (s', Rerr error_result))\nA total of 106 subgoals...", "by pat_completeness auto"], ["", "context\n  notes do_app.simps[simp del]\nbegin"], ["", "lemma match_result_elem:\n  assumes \"match_result env s v0 pes err_v = Rval (e, env')\"\n  shows \"\\<exists>pat. (pat, e) \\<in> set pes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pat. (pat, e) \\<in> set pes", "using assms"], ["proof (prove)\nusing this:\n  match_result env s v0 pes err_v = Rval (e, env')\n\ngoal (1 subgoal):\n 1. \\<exists>pat. (pat, e) \\<in> set pes", "proof (induction pes)"], ["proof (state)\ngoal (2 subgoals):\n 1. match_result env s v0 [] err_v = Rval (e, env') \\<Longrightarrow>\n    \\<exists>pat. (pat, e) \\<in> set []\n 2. \\<And>a pes.\n       \\<lbrakk>match_result env s v0 pes err_v =\n                Rval (e, env') \\<Longrightarrow>\n                \\<exists>pat. (pat, e) \\<in> set pes;\n        match_result env s v0 (a # pes) err_v = Rval (e, env')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat. (pat, e) \\<in> set (a # pes)", "case Nil"], ["proof (state)\nthis:\n  match_result env s v0 [] err_v = Rval (e, env')\n\ngoal (2 subgoals):\n 1. match_result env s v0 [] err_v = Rval (e, env') \\<Longrightarrow>\n    \\<exists>pat. (pat, e) \\<in> set []\n 2. \\<And>a pes.\n       \\<lbrakk>match_result env s v0 pes err_v =\n                Rval (e, env') \\<Longrightarrow>\n                \\<exists>pat. (pat, e) \\<in> set pes;\n        match_result env s v0 (a # pes) err_v = Rval (e, env')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat. (pat, e) \\<in> set (a # pes)", "then"], ["proof (chain)\npicking this:\n  match_result env s v0 [] err_v = Rval (e, env')", "show ?case"], ["proof (prove)\nusing this:\n  match_result env s v0 [] err_v = Rval (e, env')\n\ngoal (1 subgoal):\n 1. \\<exists>pat. (pat, e) \\<in> set []", "by auto"], ["proof (state)\nthis:\n  \\<exists>pat. (pat, e) \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>a pes.\n       \\<lbrakk>match_result env s v0 pes err_v =\n                Rval (e, env') \\<Longrightarrow>\n                \\<exists>pat. (pat, e) \\<in> set pes;\n        match_result env s v0 (a # pes) err_v = Rval (e, env')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat. (pat, e) \\<in> set (a # pes)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a pes.\n       \\<lbrakk>match_result env s v0 pes err_v =\n                Rval (e, env') \\<Longrightarrow>\n                \\<exists>pat. (pat, e) \\<in> set pes;\n        match_result env s v0 (a # pes) err_v = Rval (e, env')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat. (pat, e) \\<in> set (a # pes)", "case (Cons pe pes)"], ["proof (state)\nthis:\n  match_result env s v0 pes err_v = Rval (e, env') \\<Longrightarrow>\n  \\<exists>pat. (pat, e) \\<in> set pes\n  match_result env s v0 (pe # pes) err_v = Rval (e, env')\n\ngoal (1 subgoal):\n 1. \\<And>a pes.\n       \\<lbrakk>match_result env s v0 pes err_v =\n                Rval (e, env') \\<Longrightarrow>\n                \\<exists>pat. (pat, e) \\<in> set pes;\n        match_result env s v0 (a # pes) err_v = Rval (e, env')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat. (pat, e) \\<in> set (a # pes)", "then"], ["proof (chain)\npicking this:\n  match_result env s v0 pes err_v = Rval (e, env') \\<Longrightarrow>\n  \\<exists>pat. (pat, e) \\<in> set pes\n  match_result env s v0 (pe # pes) err_v = Rval (e, env')", "obtain p e where \"pe = (p, e)\""], ["proof (prove)\nusing this:\n  match_result env s v0 pes err_v = Rval (e, env') \\<Longrightarrow>\n  \\<exists>pat. (pat, e) \\<in> set pes\n  match_result env s v0 (pe # pes) err_v = Rval (e, env')\n\ngoal (1 subgoal):\n 1. (\\<And>p e. pe = (p, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pe = (p, e)\n\ngoal (1 subgoal):\n 1. \\<And>a pes.\n       \\<lbrakk>match_result env s v0 pes err_v =\n                Rval (e, env') \\<Longrightarrow>\n                \\<exists>pat. (pat, e) \\<in> set pes;\n        match_result env s v0 (a # pes) err_v = Rval (e, env')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat. (pat, e) \\<in> set (a # pes)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pat. (pat, e) \\<in> set (pe # pes)", "using Cons(2)"], ["proof (prove)\nusing this:\n  match_result env s v0 (pe # pes) err_v = Rval (e, env')\n\ngoal (1 subgoal):\n 1. \\<exists>pat. (pat, e) \\<in> set (pe # pes)", "apply (simp add:match_result_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case pe of\n     (x6a, x5ba) \\<Rightarrow>\n       if allDistinct (pat_bindings x6a [])\n       then case pmatch (c env) (refs s) x6a v0 [] of\n            No_match \\<Rightarrow> match_result env s v0 pes err_v\n            | Match_type_error \\<Rightarrow> Rerr (Rabort Rtype_error)\n            | Match env' \\<Rightarrow> Rval (x5ba, env')\n       else Rerr (Rabort Rtype_error)) =\n    Rval (e, env') \\<Longrightarrow>\n    \\<exists>pat. (pat, e) = pe \\<or> (pat, e) \\<in> set pes", "unfolding \\<open>pe = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (p, e) of\n     (x6a, x5ba) \\<Rightarrow>\n       if allDistinct (pat_bindings x6a [])\n       then case pmatch (c env) (refs s) x6a v0 [] of\n            No_match \\<Rightarrow> match_result env s v0 pes err_v\n            | Match_type_error \\<Rightarrow> Rerr (Rabort Rtype_error)\n            | Match env' \\<Rightarrow> Rval (x5ba, env')\n       else Rerr (Rabort Rtype_error)) =\n    Rval (e, env') \\<Longrightarrow>\n    \\<exists>pat. (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes", "apply (cases \"allDistinct (pat_bindings p [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 2. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes", "apply (cases \"pmatch (c env) (refs s) p v0 []\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s) p v0 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 2. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 3. \\<And>x3.\n       \\<lbrakk>(case (p, e) of\n                 (x6a, x5ba) \\<Rightarrow>\n                   if allDistinct (pat_bindings x6a [])\n                   then case pmatch (c env) (refs s) x6a v0 [] of\n                        No_match \\<Rightarrow>\n                          match_result env s v0 pes err_v\n                        | Match_type_error \\<Rightarrow>\n                            Rerr (Rabort Rtype_error)\n                        | Match env' \\<Rightarrow> Rval (x5ba, env')\n                   else Rerr (Rabort Rtype_error)) =\n                Rval (e, env');\n        allDistinct (pat_bindings p []);\n        pmatch (c env) (refs s) p v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat.\n                            (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 4. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes", "using Cons(1)"], ["proof (prove)\nusing this:\n  match_result env s v0 pes err_v = Rval (e, env') \\<Longrightarrow>\n  \\<exists>pat. (pat, e) \\<in> set pes\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s) p v0 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 2. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     allDistinct (pat_bindings p []);\n     pmatch (c env) (refs s) p v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 3. \\<And>x3.\n       \\<lbrakk>(case (p, e) of\n                 (x6a, x5ba) \\<Rightarrow>\n                   if allDistinct (pat_bindings x6a [])\n                   then case pmatch (c env) (refs s) x6a v0 [] of\n                        No_match \\<Rightarrow>\n                          match_result env s v0 pes err_v\n                        | Match_type_error \\<Rightarrow>\n                            Rerr (Rabort Rtype_error)\n                        | Match env' \\<Rightarrow> Rval (x5ba, env')\n                   else Rerr (Rabort Rtype_error)) =\n                Rval (e, env');\n        allDistinct (pat_bindings p []);\n        pmatch (c env) (refs s) p v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pat.\n                            (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes\n 4. \\<lbrakk>(case (p, e) of\n              (x6a, x5ba) \\<Rightarrow>\n                if allDistinct (pat_bindings x6a [])\n                then case pmatch (c env) (refs s) x6a v0 [] of\n                     No_match \\<Rightarrow> match_result env s v0 pes err_v\n                     | Match_type_error \\<Rightarrow>\n                         Rerr (Rabort Rtype_error)\n                     | Match env' \\<Rightarrow> Rval (x5ba, env')\n                else Rerr (Rabort Rtype_error)) =\n             Rval (e, env');\n     \\<not> allDistinct (pat_bindings p [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pat.\n                         (pat, e) = (p, e) \\<or> (pat, e) \\<in> set pes", "by auto+"], ["proof (state)\nthis:\n  \\<exists>pat. (pat, e) \\<in> set (pe # pes)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma evaluate_list_clock_monotone: \"clock (fst (evaluate_list eval s es)) \\<le> clock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (Evaluate_Single.evaluate_list eval s es)) \\<le> clock s", "apply (induction es arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       clock (fst (Evaluate_Single.evaluate_list eval s [])) \\<le> clock s\n 2. \\<And>a es s.\n       (\\<And>s.\n           clock (fst (Evaluate_Single.evaluate_list eval s es))\n           \\<le> clock s) \\<Longrightarrow>\n       clock (fst (Evaluate_Single.evaluate_list eval s (a # es)))\n       \\<le> clock s", "apply (auto split:prod.splits result.splits simp add:fix_clock_alt_def dest!:fstI intro:le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a es s.\n       \\<lbrakk>\\<And>s.\n                   clock (fst (Evaluate_Single.evaluate_list eval s es))\n                   \\<le> clock s;\n        \\<not> clock (fst (eval s a)) \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (Evaluate_Single.evaluate_list eval\n                                 (update_clock (\\<lambda>_. clock s)\n                                   (fst (eval s a)))\n                                 es))\n                         \\<le> clock s\n 2. \\<And>a es s.\n       \\<lbrakk>\\<And>s.\n                   clock (fst (Evaluate_Single.evaluate_list eval s es))\n                   \\<le> clock s;\n        \\<not> clock (fst (eval s a)) \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> clock\n                          (fst (Evaluate_Single.evaluate_list eval\n                                 (update_clock (\\<lambda>_. clock s)\n                                   (fst (eval s a)))\n                                 es))\n                         \\<le> clock s", "apply (metis state.record_simps(1))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_hate_words_helper:\n  \"i \\<le> (j - k :: nat) \\<Longrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j - k \\<Longrightarrow> i \\<le> j", "by simp"], ["", "thm i_hate_words_helper [THEN le_trans, no_vars]"], ["", "private"], ["", "lemma evaluate_clock_monotone:\n  \\<open>clock (fst (evaluate env s e)) \\<le> clock s\\<close>\n  if \\<open>evaluate_dom (env, s, e)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock (fst (Evaluate_Single.evaluate env s e)) \\<le> clock s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clock (fst (Evaluate_Single.evaluate env s e)) \\<le> clock s", "have *: \\<open>i \\<le> j - k \\<Longrightarrow> j \\<le> r \\<Longrightarrow> i \\<le> r\\<close> for i j k r :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j - k; j \\<le> r\\<rbrakk> \\<Longrightarrow> i \\<le> r", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> ?j - ?k; ?j \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> ?r\n\ngoal (1 subgoal):\n 1. clock (fst (Evaluate_Single.evaluate env s e)) \\<le> clock s", "from that"], ["proof (chain)\npicking this:\n  evaluate_dom (env, s, e)", "show ?thesis"], ["proof (prove)\nusing this:\n  evaluate_dom (env, s, e)\n\ngoal (1 subgoal):\n 1. clock (fst (Evaluate_Single.evaluate env s e)) \\<le> clock s", "by induction (fastforce simp add: evaluate.psimps do_con_check_build_conv evaluate_list_clock_monotone\n      split: prod.splits result.splits option.splits exp_or_val.splits error_result.splits\n      dest: fstI intro: *)+"], ["proof (state)\nthis:\n  clock (fst (Evaluate_Single.evaluate env s e)) \\<le> clock s\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition fun_evaluate_single_relation where\n\"fun_evaluate_single_relation = inv_image (less_than <*lex*> less_than) (\\<lambda>x.\n  case x of (_, s, e) \\<Rightarrow> (clock s, size_exp' e))\""], ["", "private"], ["", "lemma pat_elem_less_size:\n  \"(pat, e) \\<in> set pes \\<Longrightarrow> size_exp' e < (size_list (size_prod size size_exp') pes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, e) \\<in> set pes \\<Longrightarrow>\n    size_exp' e < size_list (size_prod size size_exp') pes", "by (induction pes) auto"], ["", "private"], ["", "lemma elem_less_size: \"e \\<in> set es \\<Longrightarrow> size_exp' e \\<le> size_list size_exp' es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set es \\<Longrightarrow>\n    size_exp' e \\<le> size_list size_exp' es", "by (induction es) auto"], ["", "lemma evaluate_total: \"All evaluate_dom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All evaluate_dom", "proof (relation \"fun_evaluate_single_relation\", unfold fun_evaluate_single_relation_def, goal_cases)"], ["proof (state)\ngoal (18 subgoals):\n 1. wf (inv_image (less_than <*lex*> less_than)\n         (\\<lambda>(x, s, e). (clock s, size_exp' e)))\n 2. \\<And>env s e.\n       ((env, s, e), env, s, Raise e)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 3. \\<And>env s e pes.\n       ((env, s, e), env, s, Handle e pes)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 4. \\<And>env s e pes x y x2 x1 x1a xa ya.\n       \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e; y = Rerr x2;\n        x2 = Rraise x1; match_result env x x1 pes x1 = Rval x1a;\n        (xa, ya) = x1a; evaluate_dom (env, s, e)\\<rbrakk>\n       \\<Longrightarrow> ((update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns ya) (sem_env.v env))\n                            env,\n                           x, xa),\n                          env, s, Handle e pes)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 5. \\<And>env s cn es e sa.\n       \\<lbrakk>do_con_check (c env) cn (length es); e \\<in> set (rev es);\n        clock sa \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> ((env, sa, e), env, s, Con cn es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 6. \\<And>env s op0 es e sa.\n       \\<lbrakk>e \\<in> set (rev es); clock sa \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> ((env, sa, e), env, s, App op0 es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 7. \\<And>env s op0 es x y x1 x2 xa ya.\n       \\<lbrakk>(x, y) =\n                Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env)\n                 s (rev es);\n        y = Rval x1; op0 = Opapp; do_opapp (rev x1) = Some x2;\n        (xa, ya) = x2; clock x \\<noteq> 0;\n        \\<And>e sa.\n           \\<lbrakk>e \\<in> set (rev es); clock sa \\<le> clock s\\<rbrakk>\n           \\<Longrightarrow> evaluate_dom (env, sa, e)\\<rbrakk>\n       \\<Longrightarrow> ((xa, dec_clock x, ya), env, s, App op0 es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 8. \\<And>env s op0 e1 e2.\n       ((env, s, e1), env, s, Log op0 e1 e2)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 9. \\<And>env s op0 e1 e2 x y x1 x2 x1a.\n       \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e1; y = Rval x1;\n        do_log op0 x1 e2 = Some x2; x2 = Exp x1a;\n        evaluate_dom (env, s, e1)\\<rbrakk>\n       \\<Longrightarrow> ((env, x, x1a), env, s, Log op0 e1 e2)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 10. \\<And>env s e1 e2 e3.\n        ((env, s, e1), env, s, exp0.If e1 e2 e3)\n        \\<in> inv_image (less_than <*lex*> less_than)\n               (\\<lambda>(x, s, e). (clock s, size_exp' e))\nA total of 18 subgoals...", "case 7"], ["proof (state)\nthis:\n  (x_, y_) =\n  Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env_) s_ (rev es_)\n  y_ = Rval x1_\n  op0_ = Opapp\n  do_opapp (rev x1_) = Some x2_\n  (xa_, ya_) = x2_\n  clock x_ \\<noteq> 0\n  \\<lbrakk>?e \\<in> set (rev es_); clock ?sa \\<le> clock s_\\<rbrakk>\n  \\<Longrightarrow> evaluate_dom (env_, ?sa, ?e)\n\ngoal (18 subgoals):\n 1. wf (inv_image (less_than <*lex*> less_than)\n         (\\<lambda>(x, s, e). (clock s, size_exp' e)))\n 2. \\<And>env s e.\n       ((env, s, e), env, s, Raise e)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 3. \\<And>env s e pes.\n       ((env, s, e), env, s, Handle e pes)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 4. \\<And>env s e pes x y x2 x1 x1a xa ya.\n       \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e; y = Rerr x2;\n        x2 = Rraise x1; match_result env x x1 pes x1 = Rval x1a;\n        (xa, ya) = x1a; evaluate_dom (env, s, e)\\<rbrakk>\n       \\<Longrightarrow> ((update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns ya) (sem_env.v env))\n                            env,\n                           x, xa),\n                          env, s, Handle e pes)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 5. \\<And>env s cn es e sa.\n       \\<lbrakk>do_con_check (c env) cn (length es); e \\<in> set (rev es);\n        clock sa \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> ((env, sa, e), env, s, Con cn es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 6. \\<And>env s op0 es e sa.\n       \\<lbrakk>e \\<in> set (rev es); clock sa \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> ((env, sa, e), env, s, App op0 es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 7. \\<And>env s op0 es x y x1 x2 xa ya.\n       \\<lbrakk>(x, y) =\n                Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env)\n                 s (rev es);\n        y = Rval x1; op0 = Opapp; do_opapp (rev x1) = Some x2;\n        (xa, ya) = x2; clock x \\<noteq> 0;\n        \\<And>e sa.\n           \\<lbrakk>e \\<in> set (rev es); clock sa \\<le> clock s\\<rbrakk>\n           \\<Longrightarrow> evaluate_dom (env, sa, e)\\<rbrakk>\n       \\<Longrightarrow> ((xa, dec_clock x, ya), env, s, App op0 es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 8. \\<And>env s op0 e1 e2.\n       ((env, s, e1), env, s, Log op0 e1 e2)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 9. \\<And>env s op0 e1 e2 x y x1 x2 x1a.\n       \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e1; y = Rval x1;\n        do_log op0 x1 e2 = Some x2; x2 = Exp x1a;\n        evaluate_dom (env, s, e1)\\<rbrakk>\n       \\<Longrightarrow> ((env, x, x1a), env, s, Log op0 e1 e2)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 10. \\<And>env s e1 e2 e3.\n        ((env, s, e1), env, s, exp0.If e1 e2 e3)\n        \\<in> inv_image (less_than <*lex*> less_than)\n               (\\<lambda>(x, s, e). (clock s, size_exp' e))\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  (x_, y_) =\n  Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env_) s_ (rev es_)\n  y_ = Rval x1_\n  op0_ = Opapp\n  do_opapp (rev x1_) = Some x2_\n  (xa_, ya_) = x2_\n  clock x_ \\<noteq> 0\n  \\<lbrakk>?e \\<in> set (rev es_); clock ?sa \\<le> clock s_\\<rbrakk>\n  \\<Longrightarrow> evaluate_dom (env_, ?sa, ?e)", "show ?case"], ["proof (prove)\nusing this:\n  (x_, y_) =\n  Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env_) s_ (rev es_)\n  y_ = Rval x1_\n  op0_ = Opapp\n  do_opapp (rev x1_) = Some x2_\n  (xa_, ya_) = x2_\n  clock x_ \\<noteq> 0\n  \\<lbrakk>?e \\<in> set (rev es_); clock ?sa \\<le> clock s_\\<rbrakk>\n  \\<Longrightarrow> evaluate_dom (env_, ?sa, ?e)\n\ngoal (1 subgoal):\n 1. ((xa_, dec_clock x_, ya_), env_, s_, App op0_ es_)\n    \\<in> inv_image (less_than <*lex*> less_than)\n           (\\<lambda>(x, s, e). (clock s, size_exp' e))", "using evaluate_list_clock_monotone \"7\"(1)[symmetric]"], ["proof (prove)\nusing this:\n  (x_, y_) =\n  Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env_) s_ (rev es_)\n  y_ = Rval x1_\n  op0_ = Opapp\n  do_opapp (rev x1_) = Some x2_\n  (xa_, ya_) = x2_\n  clock x_ \\<noteq> 0\n  \\<lbrakk>?e \\<in> set (rev es_); clock ?sa \\<le> clock s_\\<rbrakk>\n  \\<Longrightarrow> evaluate_dom (env_, ?sa, ?e)\n  clock (fst (Evaluate_Single.evaluate_list ?eval ?s ?es)) \\<le> clock ?s\n  Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env_) s_\n   (rev es_) =\n  (x_, y_)\n\ngoal (1 subgoal):\n 1. ((xa_, dec_clock x_, ya_), env_, s_, App op0_ es_)\n    \\<in> inv_image (less_than <*lex*> less_than)\n           (\\<lambda>(x, s, e). (clock s, size_exp' e))", "by (auto dest!: fstI simp add:evaluate_list_clock_monotone Suc_le_lessD)"], ["proof (state)\nthis:\n  ((xa_, dec_clock x_, ya_), env_, s_, App op0_ es_)\n  \\<in> inv_image (less_than <*lex*> less_than)\n         (\\<lambda>(x, s, e). (clock s, size_exp' e))\n\ngoal (17 subgoals):\n 1. wf (inv_image (less_than <*lex*> less_than)\n         (\\<lambda>(x, s, e). (clock s, size_exp' e)))\n 2. \\<And>env s e.\n       ((env, s, e), env, s, Raise e)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 3. \\<And>env s e pes.\n       ((env, s, e), env, s, Handle e pes)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 4. \\<And>env s e pes x y x2 x1 x1a xa ya.\n       \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e; y = Rerr x2;\n        x2 = Rraise x1; match_result env x x1 pes x1 = Rval x1a;\n        (xa, ya) = x1a; evaluate_dom (env, s, e)\\<rbrakk>\n       \\<Longrightarrow> ((update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns ya) (sem_env.v env))\n                            env,\n                           x, xa),\n                          env, s, Handle e pes)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 5. \\<And>env s cn es e sa.\n       \\<lbrakk>do_con_check (c env) cn (length es); e \\<in> set (rev es);\n        clock sa \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> ((env, sa, e), env, s, Con cn es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 6. \\<And>env s op0 es e sa.\n       \\<lbrakk>e \\<in> set (rev es); clock sa \\<le> clock s\\<rbrakk>\n       \\<Longrightarrow> ((env, sa, e), env, s, App op0 es)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 7. \\<And>env s op0 e1 e2.\n       ((env, s, e1), env, s, Log op0 e1 e2)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 8. \\<And>env s op0 e1 e2 x y x1 x2 x1a.\n       \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e1; y = Rval x1;\n        do_log op0 x1 e2 = Some x2; x2 = Exp x1a;\n        evaluate_dom (env, s, e1)\\<rbrakk>\n       \\<Longrightarrow> ((env, x, x1a), env, s, Log op0 e1 e2)\n                         \\<in> inv_image (less_than <*lex*> less_than)\n                                (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 9. \\<And>env s e1 e2 e3.\n       ((env, s, e1), env, s, exp0.If e1 e2 e3)\n       \\<in> inv_image (less_than <*lex*> less_than)\n              (\\<lambda>(x, s, e). (clock s, size_exp' e))\n 10. \\<And>env s e1 e2 e3 x y x1 x2.\n        \\<lbrakk>(x, y) = Evaluate_Single.evaluate env s e1; y = Rval x1;\n         do_if x1 e2 e3 = Some x2; evaluate_dom (env, s, e1)\\<rbrakk>\n        \\<Longrightarrow> ((env, x, x2), env, s, exp0.If e1 e2 e3)\n                          \\<in> inv_image (less_than <*lex*> less_than)\n                                 (\\<lambda>(x, s, e).\n                                     (clock s, size_exp' e))\nA total of 17 subgoals...", "qed (auto simp add: less_Suc_eq_le Suc_le_lessD do_if_def do_log_alt_def evaluate_list_clock_monotone elem_less_size\n          split:lop.splits v.splits option.splits tid_or_exn.splits if_splits id0.splits list.splits\n          dest!:evaluate_clock_monotone match_result_elem fstI dest:sym pat_elem_less_size intro:le_neq_implies_less)"], ["", "termination evaluate"], ["proof (prove)\ngoal (1 subgoal):\n 1. All evaluate_dom", "by (rule evaluate_total)"], ["", "lemma evaluate_clock_monotone': \"evaluate eval s e = (s', r) \\<Longrightarrow>  clock s' \\<le> clock s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate eval s e = (s', r) \\<Longrightarrow>\n    clock s' \\<le> clock s", "using fst_conv evaluate_clock_monotone evaluate_total"], ["proof (prove)\nusing this:\n  fst (?x1.0, ?x2.0) = ?x1.0\n  evaluate_dom (?env, ?s, ?e) \\<Longrightarrow>\n  clock (fst (Evaluate_Single.evaluate ?env ?s ?e)) \\<le> clock ?s\n  All evaluate_dom\n\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate eval s e = (s', r) \\<Longrightarrow>\n    clock s' \\<le> clock s", "by metis"], ["", "fun evaluate_list' :: \"v sem_env \\<Rightarrow> 'ffi state \\<Rightarrow> exp list \\<Rightarrow> 'ffi state*(v list, v) result\" where\n\"evaluate_list' env s [] = (s, Rval [])\" |\n\"evaluate_list' env s (e#es) =\n  (case evaluate env s e of\n    (s', Rval v) \\<Rightarrow>\n      (case evaluate_list' env s' es of\n        (s'', Rval vs) \\<Rightarrow> (s'', Rval (v#vs))\n      | res \\<Rightarrow> res)\n  |  (s', Rerr err) \\<Rightarrow> (s', Rerr err))\""], ["", "lemma fix_clock_evaluate[simp]: \"fix_clock s (evaluate eval s e) = evaluate eval s e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix_clock s (Evaluate_Single.evaluate eval s e) =\n    Evaluate_Single.evaluate eval s e", "unfolding fix_clock_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Evaluate_Single.evaluate eval s e of\n     (x3a, x) \\<Rightarrow>\n       (update_clock\n         (\\<lambda>_.\n             if clock x3a \\<le> clock s then clock x3a else clock s)\n         x3a,\n        x)) =\n    Evaluate_Single.evaluate eval s e", "apply (auto simp: datatype_record_update split: state.splits prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 x5 x2a.\n       \\<lbrakk>\\<not> x1 \\<le> clock s;\n        Evaluate_Single.evaluate eval s e =\n        (make_state x1 x2 x3 x4 x5, x2a)\\<rbrakk>\n       \\<Longrightarrow> False", "using evaluate_clock_monotone'"], ["proof (prove)\nusing this:\n  Evaluate_Single.evaluate ?eval ?s ?e = (?s', ?r) \\<Longrightarrow>\n  clock ?s' \\<le> clock ?s\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 x5 x2a.\n       \\<lbrakk>\\<not> x1 \\<le> clock s;\n        Evaluate_Single.evaluate eval s e =\n        (make_state x1 x2 x3 x4 x5, x2a)\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["", "lemma evaluate_list_eq[simp]: \"evaluate_list (evaluate env) = evaluate_list' env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env) =\n    evaluate_list' env", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env) x xa =\n       evaluate_list' env x xa", "subgoal for s es"], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env) s es =\n    evaluate_list' env s es", "by (induction rule:evaluate_list'.induct) (auto split:prod.splits result.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare evaluate_list.simps[simp del]"], ["", "lemma fun_evaluate_equiv:\n  \"fun_evaluate_match s env v pes err_v = (case match_result env s v pes err_v of\n      Rerr err \\<Rightarrow> (s, Rerr err)\n    | Rval (e, env') \\<Rightarrow> evaluate_list (evaluate (env \\<lparr> sem_env.v := (nsAppend (alist_to_ns env') (sem_env.v env)) \\<rparr>)) s [e])\"\n  \"fun_evaluate s env es = evaluate_list (evaluate env) s es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate_match s env v pes err_v =\n    (case match_result env s v pes err_v of\n     Rval (e, env') \\<Rightarrow>\n       Evaluate_Single.evaluate_list\n        (Evaluate_Single.evaluate\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env))\n        s [e]\n     | Rerr err \\<Rightarrow> (s, Rerr err)) &&&\n    fun_evaluate s env es =\n    Evaluate_Single.evaluate_list (Evaluate_Single.evaluate env) s es", "by (induction rule: fun_evaluate_induct)\n     (auto split: prod.splits result.splits match_result.splits option.splits exp_or_val.splits\n                  if_splits match_result.splits error_result.splits\n           simp: all_distinct_alt_def)"], ["", "corollary fun_evaluate_equiv':\n  \"evaluate env s e = map_prod id (map_result hd id) (fun_evaluate s env [e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s e =\n    map_prod id (map_result hd id) (fun_evaluate s env [e])", "by (subst fun_evaluate_equiv) (simp split: prod.splits result.splits add: error_result.map_id)"], ["", "end"], ["", "end"]]}