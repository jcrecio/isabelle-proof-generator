{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Big_Step_Fun_Equiv.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemmas eval_all = valid_eval valid_eval_list valid_eval_match", "lemma evaluate_iff:\n  \"evaluate True env st e r \\<longleftrightarrow> (r = eval env e st)\"\n  \"evaluate_list True env st es r' \\<longleftrightarrow> (r' = eval_list env es st)\"\n  \"evaluate_match True env st v pes v' r \\<longleftrightarrow> (r = eval_match env v pes v' st)\"", "lemma evaluate_iff_sym:\n  \"evaluate True env st e r \\<longleftrightarrow> (eval env e st = r)\"\n  \"evaluate_list True env st es r' \\<longleftrightarrow> (eval_list env es st = r')\"\n  \"evaluate_match True env st v pes v' r \\<longleftrightarrow> (eval_match env v pes v' st = r)\"", "lemma other_eval_eq:\n  assumes \"Big_Step_Fun_Equiv.eval eval' eval_list' eval_match'\"\n  shows \"eval' = eval\" \"eval_list' = eval_list\" \"eval_match' = eval_match\"", "lemma eval_list_singleton:\n  \"eval_list env [e] st = map_prod id list_result (eval env e st)\"", "lemma eval_eqI:\n  assumes \"\\<And>r. evaluate True env st1 e1 r \\<longleftrightarrow> evaluate True env st2 e2 r\"\n  shows \"eval env e1 st1 = eval env e2 st2\"", "lemma eval_match_eqI:\n  assumes \"\\<And>r. evaluate_match True env1 st1 v1 pes1 err_v1 r \\<longleftrightarrow> evaluate_match True env2 st2 v2 pes2 err_v2 r\"\n  shows \"eval_match env1 v1 pes1 err_v1 st1 = eval_match env2 v2 pes2 err_v2 st2\"", "lemma eval_tannot[simp]: \"eval env (Tannot e t1) st = eval env e st\"", "lemma eval_lannot[simp]: \"eval env (Lannot e t1) st = eval env e st\"", "lemma eval_match[simp]:\n  \"eval env (Mat e pes) st =\n    (case eval env e st of\n      (st', Rval v) \\<Rightarrow> eval_match env v pes Bindv st'\n    | (st', Rerr err) \\<Rightarrow> (st', Rerr err))\"", "lemma eval_match_empty[simp]: \"eval_match env v2 [] err_v st = (st, Rerr (Rraise err_v))\"", "lemma run_eval: \"\\<exists>run_eval. \\<forall>env e s. evaluate True env s e (run_eval env e s)\"", "lemma run_eval_list: \"\\<exists>run_eval_list. \\<forall>env es s. evaluate_list True env s es (run_eval_list env es s)\"", "lemma run_eval_match: \"\\<exists>run_eval_match. \\<forall>env v pes err_v s. evaluate_match True env s v pes err_v (run_eval_match env v pes err_v s)\"", "lemma fun_evaluate:\n  \"evaluate_match True env s v pes err_v (map_prod id (map_result hd id) (fun_evaluate_match s env v pes err_v))\"\n  \"evaluate_list True env s es (fun_evaluate s env es)\"", "lemmas big_fun_equivalence =\n  fun.other_eval_eq[OF run.eval_axioms]\n\\<comment> \\<open>@{thm [display] big_fun_equivalence}\\<close>"], "translations": [["", "lemmas eval_all = valid_eval valid_eval_list valid_eval_match"], ["", "lemma evaluate_iff:\n  \"evaluate True env st e r \\<longleftrightarrow> (r = eval env e st)\"\n  \"evaluate_list True env st es r' \\<longleftrightarrow> (r' = eval_list env es st)\"\n  \"evaluate_match True env st v pes v' r \\<longleftrightarrow> (r = eval_match env v pes v' st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e r = (r = eval env e st) &&&\n    evaluate_list True env st es r' = (r' = eval_list env es st) &&&\n    evaluate_match True env st v pes v' r = (r = eval_match env v pes v' st)", "by (metis eval_all evaluate_determ)+"], ["", "lemma evaluate_iff_sym:\n  \"evaluate True env st e r \\<longleftrightarrow> (eval env e st = r)\"\n  \"evaluate_list True env st es r' \\<longleftrightarrow> (eval_list env es st = r')\"\n  \"evaluate_match True env st v pes v' r \\<longleftrightarrow> (eval_match env v pes v' st = r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e r = (eval env e st = r) &&&\n    evaluate_list True env st es r' = (eval_list env es st = r') &&&\n    evaluate_match True env st v pes v' r = (eval_match env v pes v' st = r)", "by (auto simp: evaluate_iff)"], ["", "lemma other_eval_eq:\n  assumes \"Big_Step_Fun_Equiv.eval eval' eval_list' eval_match'\"\n  shows \"eval' = eval\" \"eval_list' = eval_list\" \"eval_match' = eval_match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval' = eval &&& eval_list' = eval_list &&& eval_match' = eval_match", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. eval' = eval\n 2. eval_list' = eval_list\n 3. eval_match' = eval_match", "interpret other: Big_Step_Fun_Equiv.eval eval' eval_list' eval_match'"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval eval' eval_list' eval_match'", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. eval' = eval\n 2. eval_list' = eval_list\n 3. eval_match' = eval_match", "show \"eval' = eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval' = eval", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb. eval' x xa xb = eval x xa xb", "using evaluate_iff other.evaluate_iff"], ["proof (prove)\nusing this:\n  evaluate True ?env ?st ?e ?r = (?r = eval ?env ?e ?st)\n  evaluate_list True ?env ?st ?es ?r' = (?r' = eval_list ?env ?es ?st)\n  evaluate_match True ?env ?st ?v ?pes ?v' ?r =\n  (?r = eval_match ?env ?v ?pes ?v' ?st)\n  evaluate True ?env ?st ?e ?r = (?r = eval' ?env ?e ?st)\n  evaluate_list True ?env ?st ?es ?r' = (?r' = eval_list' ?env ?es ?st)\n  evaluate_match True ?env ?st ?v ?pes ?v' ?r =\n  (?r = eval_match' ?env ?v ?pes ?v' ?st)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb. eval' x xa xb = eval x xa xb", "by (metis evaluate_determ)"], ["proof (state)\nthis:\n  eval' = eval\n\ngoal (2 subgoals):\n 1. eval_list' = eval_list\n 2. eval_match' = eval_match", "show \"eval_list' = eval_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_list' = eval_list", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb. eval_list' x xa xb = eval_list x xa xb", "using evaluate_iff other.evaluate_iff"], ["proof (prove)\nusing this:\n  evaluate True ?env ?st ?e ?r = (?r = eval ?env ?e ?st)\n  evaluate_list True ?env ?st ?es ?r' = (?r' = eval_list ?env ?es ?st)\n  evaluate_match True ?env ?st ?v ?pes ?v' ?r =\n  (?r = eval_match ?env ?v ?pes ?v' ?st)\n  evaluate True ?env ?st ?e ?r = (?r = eval' ?env ?e ?st)\n  evaluate_list True ?env ?st ?es ?r' = (?r' = eval_list' ?env ?es ?st)\n  evaluate_match True ?env ?st ?v ?pes ?v' ?r =\n  (?r = eval_match' ?env ?v ?pes ?v' ?st)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb. eval_list' x xa xb = eval_list x xa xb", "by (metis evaluate_determ)"], ["proof (state)\nthis:\n  eval_list' = eval_list\n\ngoal (1 subgoal):\n 1. eval_match' = eval_match", "show \"eval_match' = eval_match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_match' = eval_match", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc xd.\n       eval_match' x xa xb xc xd = eval_match x xa xb xc xd", "using evaluate_iff other.evaluate_iff"], ["proof (prove)\nusing this:\n  evaluate True ?env ?st ?e ?r = (?r = eval ?env ?e ?st)\n  evaluate_list True ?env ?st ?es ?r' = (?r' = eval_list ?env ?es ?st)\n  evaluate_match True ?env ?st ?v ?pes ?v' ?r =\n  (?r = eval_match ?env ?v ?pes ?v' ?st)\n  evaluate True ?env ?st ?e ?r = (?r = eval' ?env ?e ?st)\n  evaluate_list True ?env ?st ?es ?r' = (?r' = eval_list' ?env ?es ?st)\n  evaluate_match True ?env ?st ?v ?pes ?v' ?r =\n  (?r = eval_match' ?env ?v ?pes ?v' ?st)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc xd.\n       eval_match' x xa xb xc xd = eval_match x xa xb xc xd", "by (metis evaluate_determ)"], ["proof (state)\nthis:\n  eval_match' = eval_match\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_list_singleton:\n  \"eval_list env [e] st = map_prod id list_result (eval env e st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "define res where \"res = eval_list env [e] st\""], ["proof (state)\nthis:\n  res = eval_list env [e] st\n\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "then"], ["proof (chain)\npicking this:\n  res = eval_list env [e] st", "have e: \"evaluate_list True env st [e] res\""], ["proof (prove)\nusing this:\n  res = eval_list env [e] st\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [e] res", "by (metis evaluate_iff)"], ["proof (state)\nthis:\n  evaluate_list True env st [e] res\n\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "then"], ["proof (chain)\npicking this:\n  evaluate_list True env st [e] res", "obtain st' r where \"res = (st', r)\""], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] res\n\ngoal (1 subgoal):\n 1. (\\<And>st' r. res = (st', r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  res = (st', r)\n\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "then"], ["proof (chain)\npicking this:\n  res = (st', r)", "have \"map_prod id list_result (eval env e st) = (st', r)\""], ["proof (prove)\nusing this:\n  res = (st', r)\n\ngoal (1 subgoal):\n 1. map_prod id list_result (eval env e st) = (st', r)", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>res = (st', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)\n 2. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "case (Rval vs)"], ["proof (state)\nthis:\n  r = Rval vs\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>res = (st', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)\n 2. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "with e"], ["proof (chain)\npicking this:\n  evaluate_list True env st [e] res\n  r = Rval vs", "obtain v where \"vs = [v]\" \"evaluate True env st e (st', Rval v)\""], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] res\n  r = Rval vs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>vs = [v]; evaluate True env st e (st', Rval v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>res = (st', r)\\<close>"], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] (st', r)\n  r = Rval vs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>vs = [v]; evaluate True env st e (st', Rval v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis evaluate_list_singleton_valE)"], ["proof (state)\nthis:\n  vs = [v]\n  evaluate True env st e (st', Rval v)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>res = (st', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)\n 2. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "then"], ["proof (chain)\npicking this:\n  vs = [v]\n  evaluate True env st e (st', Rval v)", "have \"eval env e st = (st', Rval v)\""], ["proof (prove)\nusing this:\n  vs = [v]\n  evaluate True env st e (st', Rval v)\n\ngoal (1 subgoal):\n 1. eval env e st = (st', Rval v)", "by (metis evaluate_iff_sym)"], ["proof (state)\nthis:\n  eval env e st = (st', Rval v)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>res = (st', r); r = Rval x1\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)\n 2. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "then"], ["proof (chain)\npicking this:\n  eval env e st = (st', Rval v)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval env e st = (st', Rval v)\n\ngoal (1 subgoal):\n 1. map_prod id list_result (eval env e st) = (st', r)", "unfolding \\<open>r = _\\<close> \\<open>vs = _\\<close>"], ["proof (prove)\nusing this:\n  eval env e st = (st', Rval v)\n\ngoal (1 subgoal):\n 1. map_prod id list_result (eval env e st) = (st', Rval [v])", "by auto"], ["proof (state)\nthis:\n  map_prod id list_result (eval env e st) = (st', r)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "case (Rerr err)"], ["proof (state)\nthis:\n  r = Rerr err\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "with e"], ["proof (chain)\npicking this:\n  evaluate_list True env st [e] res\n  r = Rerr err", "have \"evaluate True env st e (st', Rerr err)\""], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] res\n  r = Rerr err\n\ngoal (1 subgoal):\n 1. evaluate True env st e (st', Rerr err)", "unfolding \\<open>res = (st', r)\\<close>"], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] (st', r)\n  r = Rerr err\n\ngoal (1 subgoal):\n 1. evaluate True env st e (st', Rerr err)", "by (metis evaluate_list_singleton_errD)"], ["proof (state)\nthis:\n  evaluate True env st e (st', Rerr err)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "then"], ["proof (chain)\npicking this:\n  evaluate True env st e (st', Rerr err)", "have \"eval env e st = (st', Rerr err)\""], ["proof (prove)\nusing this:\n  evaluate True env st e (st', Rerr err)\n\ngoal (1 subgoal):\n 1. eval env e st = (st', Rerr err)", "by (metis evaluate_iff_sym)"], ["proof (state)\nthis:\n  eval env e st = (st', Rerr err)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>res = (st', r); r = Rerr x2\\<rbrakk>\n       \\<Longrightarrow> map_prod id list_result (eval env e st) = (st', r)", "then"], ["proof (chain)\npicking this:\n  eval env e st = (st', Rerr err)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval env e st = (st', Rerr err)\n\ngoal (1 subgoal):\n 1. map_prod id list_result (eval env e st) = (st', r)", "unfolding \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  eval env e st = (st', Rerr err)\n\ngoal (1 subgoal):\n 1. map_prod id list_result (eval env e st) = (st', Rerr err)", "by (cases err) auto"], ["proof (state)\nthis:\n  map_prod id list_result (eval env e st) = (st', r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_prod id list_result (eval env e st) = (st', r)\n\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "then"], ["proof (chain)\npicking this:\n  map_prod id list_result (eval env e st) = (st', r)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_prod id list_result (eval env e st) = (st', r)\n\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "using res_def \\<open>res = (st', r)\\<close>"], ["proof (prove)\nusing this:\n  map_prod id list_result (eval env e st) = (st', r)\n  res = eval_list env [e] st\n  res = (st', r)\n\ngoal (1 subgoal):\n 1. eval_list env [e] st = map_prod id list_result (eval env e st)", "by metis"], ["proof (state)\nthis:\n  eval_list env [e] st = map_prod id list_result (eval env e st)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_eqI:\n  assumes \"\\<And>r. evaluate True env st1 e1 r \\<longleftrightarrow> evaluate True env st2 e2 r\"\n  shows \"eval env e1 st1 = eval env e2 st2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval env e1 st1 = eval env e2 st2", "using assms"], ["proof (prove)\nusing this:\n  evaluate True env st1 e1 ?r = evaluate True env st2 e2 ?r\n\ngoal (1 subgoal):\n 1. eval env e1 st1 = eval env e2 st2", "by (metis evaluate_iff)"], ["", "lemma eval_match_eqI:\n  assumes \"\\<And>r. evaluate_match True env1 st1 v1 pes1 err_v1 r \\<longleftrightarrow> evaluate_match True env2 st2 v2 pes2 err_v2 r\"\n  shows \"eval_match env1 v1 pes1 err_v1 st1 = eval_match env2 v2 pes2 err_v2 st2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_match env1 v1 pes1 err_v1 st1 = eval_match env2 v2 pes2 err_v2 st2", "using assms"], ["proof (prove)\nusing this:\n  evaluate_match True env1 st1 v1 pes1 err_v1 ?r =\n  evaluate_match True env2 st2 v2 pes2 err_v2 ?r\n\ngoal (1 subgoal):\n 1. eval_match env1 v1 pes1 err_v1 st1 = eval_match env2 v2 pes2 err_v2 st2", "by (metis evaluate_iff)"], ["", "lemma eval_tannot[simp]: \"eval env (Tannot e t1) st = eval env e st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval env (Tannot e t1) st = eval env e st", "by (rule eval_eqI) (auto elim: evaluate.cases intro: evaluate_match_evaluate_list_evaluate.intros)"], ["", "lemma eval_lannot[simp]: \"eval env (Lannot e t1) st = eval env e st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval env (Lannot e t1) st = eval env e st", "by (rule eval_eqI) (auto elim: evaluate.cases intro: evaluate_match_evaluate_list_evaluate.intros)"], ["", "lemma eval_match[simp]:\n  \"eval env (Mat e pes) st =\n    (case eval env e st of\n      (st', Rval v) \\<Rightarrow> eval_match env v pes Bindv st'\n    | (st', Rerr err) \\<Rightarrow> (st', Rerr err))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval env (Mat e pes) st =\n    (case eval env e st of\n     (st', Rval v) \\<Rightarrow> eval_match env v pes Bindv st'\n     | (st', Rerr err) \\<Rightarrow> (st', Rerr err))", "apply (subst evaluate_iff_sym[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st (Mat e pes)\n     (case eval env e st of\n      (st', Rval v) \\<Rightarrow> eval_match env v pes Bindv st'\n      | (st', Rerr err) \\<Rightarrow> (st', Rerr err))", "apply (simp only: split!: prod.splits result.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a.\n       eval env e st = (x1, Rval x1a) \\<Longrightarrow>\n       evaluate True env st (Mat e pes) (eval_match env x1a pes Bindv x1)\n 2. \\<And>x1 x2 x2a.\n       eval env e st = (x1, Rerr x2a) \\<Longrightarrow>\n       evaluate True env st (Mat e pes) (x1, Rerr x2a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval env e st = (x1_, Rval x1a_) \\<Longrightarrow>\n    evaluate True env st (Mat e pes) (eval_match env x1a_ pes Bindv x1_)", "apply (subst (asm) evaluate_iff_sym[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (x1_, Rval x1a_) \\<Longrightarrow>\n    evaluate True env st (Mat e pes) (eval_match env x1a_ pes Bindv x1_)", "apply (rule mat1, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate True env st e (x1_, Rval x1a_) \\<Longrightarrow>\n    evaluate True env st e (?s2.1, Rval ?v1.1)\n 2. evaluate True env st e (x1_, Rval x1a_) \\<Longrightarrow>\n    evaluate_match True env ?s2.1 ?v1.1 pes\n     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n     (eval_match env x1a_ pes Bindv x1_)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (x1_, Rval x1a_) \\<Longrightarrow>\n    evaluate_match True env x1_ x1a_ pes\n     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n     (eval_match env x1a_ pes Bindv x1_)", "apply (subst Bindv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (x1_, Rval x1a_) \\<Longrightarrow>\n    evaluate_match True env x1_ x1a_ pes\n     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n     (eval_match env x1a_ pes\n       (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) x1_)", "apply (metis valid_eval_match)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x2a.\n       eval env e st = (x1, Rerr x2a) \\<Longrightarrow>\n       evaluate True env st (Mat e pes) (x1, Rerr x2a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval env e st = (x1_, Rerr x2a_) \\<Longrightarrow>\n    evaluate True env st (Mat e pes) (x1_, Rerr x2a_)", "apply (subst (asm) evaluate_iff_sym[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (x1_, Rerr x2a_) \\<Longrightarrow>\n    evaluate True env st (Mat e pes) (x1_, Rerr x2a_)", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_match_empty[simp]: \"eval_match env v2 [] err_v st = (st, Rerr (Rraise err_v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_match env v2 [] err_v st = (st, Rerr (Rraise err_v))", "by (subst evaluate_iff_sym[symmetric]) (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["", "end"], ["", "lemma run_eval: \"\\<exists>run_eval. \\<forall>env e s. evaluate True env s e (run_eval env e s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>run_eval.\n       \\<forall>env e s. evaluate True env s e (run_eval env e s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>run_eval.\n       \\<forall>env e s. evaluate True env s e (run_eval env e s)", "define f where \"f env_e_s = (case env_e_s of (env, e, s::'a state) \\<Rightarrow> evaluate True env s e)\" for env_e_s"], ["proof (state)\nthis:\n  f ?env_e_s =\n  (case ?env_e_s of (env, e, s) \\<Rightarrow> evaluate True env s e)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval.\n       \\<forall>env e s. evaluate True env s e (run_eval env e s)", "have \"\\<exists>g. \\<forall>env_e_s. f env_e_s (g env_e_s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. \\<forall>env_e_s. f env_e_s (g env_e_s)", "proof (rule choice, safe, unfold f_def prod.case)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate True a b aa)", "fix env e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate True a b aa)", "fix s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate True a b aa)", "obtain s' r where \"evaluate True env s e (s', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate True env s e (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis evaluate_total)"], ["proof (state)\nthis:\n  evaluate True env s e (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate True a b aa)", "then"], ["proof (chain)\npicking this:\n  evaluate True env s e (s', r)", "show \"\\<exists>r. evaluate True env s e r\""], ["proof (prove)\nusing this:\n  evaluate True env s e (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate True env s e r", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. evaluate True env s e r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g. \\<forall>env_e_s. f env_e_s (g env_e_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval.\n       \\<forall>env e s. evaluate True env s e (run_eval env e s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. \\<forall>env_e_s. f env_e_s (g env_e_s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>g. \\<forall>env_e_s. f env_e_s (g env_e_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval.\n       \\<forall>env e s. evaluate True env s e (run_eval env e s)", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>g.\n     \\<forall>env_e_s.\n        (case env_e_s of (env, e, s) \\<Rightarrow> evaluate True env s e)\n         (g env_e_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval.\n       \\<forall>env e s. evaluate True env s e (run_eval env e s)", "by force"], ["proof (state)\nthis:\n  \\<exists>run_eval.\n     \\<forall>env e s. evaluate True env s e (run_eval env e s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_eval_list: \"\\<exists>run_eval_list. \\<forall>env es s. evaluate_list True env s es (run_eval_list env es s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>run_eval_list.\n       \\<forall>env es s.\n          evaluate_list True env s es (run_eval_list env es s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>run_eval_list.\n       \\<forall>env es s.\n          evaluate_list True env s es (run_eval_list env es s)", "define f where \"f env_es_s = (case env_es_s of (env, es, s::'a state) \\<Rightarrow> evaluate_list True env s es)\" for env_es_s"], ["proof (state)\nthis:\n  f ?env_es_s =\n  (case ?env_es_s of (env, es, s) \\<Rightarrow> evaluate_list True env s es)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_list.\n       \\<forall>env es s.\n          evaluate_list True env s es (run_eval_list env es s)", "have \"\\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)", "proof (rule choice, safe, unfold f_def prod.case)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate_list True a b aa)", "fix env es"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate_list True a b aa)", "fix s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate_list True a b aa)", "obtain s' r where \"evaluate_list True env s es (s', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_list True env s es (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis evaluate_list_total)"], ["proof (state)\nthis:\n  evaluate_list True env s es (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b. Ex (evaluate_list True a b aa)", "then"], ["proof (chain)\npicking this:\n  evaluate_list True env s es (s', r)", "show \"\\<exists>r. evaluate_list True env s es r\""], ["proof (prove)\nusing this:\n  evaluate_list True env s es (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_list True env s es r", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. evaluate_list True env s es r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_list.\n       \\<forall>env es s.\n          evaluate_list True env s es (run_eval_list env es s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_list.\n       \\<forall>env es s.\n          evaluate_list True env s es (run_eval_list env es s)", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>g.\n     \\<forall>env_es_s.\n        (case env_es_s of\n         (env, es, s) \\<Rightarrow> evaluate_list True env s es)\n         (g env_es_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_list.\n       \\<forall>env es s.\n          evaluate_list True env s es (run_eval_list env es s)", "by force"], ["proof (state)\nthis:\n  \\<exists>run_eval_list.\n     \\<forall>env es s. evaluate_list True env s es (run_eval_list env es s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_eval_match: \"\\<exists>run_eval_match. \\<forall>env v pes err_v s. evaluate_match True env s v pes err_v (run_eval_match env v pes err_v s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>run_eval_match.\n       \\<forall>env v pes err_v s.\n          evaluate_match True env s v pes err_v\n           (run_eval_match env v pes err_v s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>run_eval_match.\n       \\<forall>env v pes err_v s.\n          evaluate_match True env s v pes err_v\n           (run_eval_match env v pes err_v s)", "define f where \"f env_v_pes_err_v_s = (case env_v_pes_err_v_s of (env, v, pes, err_v, s::'a state) \\<Rightarrow> evaluate_match True env s v pes err_v)\" for env_v_pes_err_v_s"], ["proof (state)\nthis:\n  f ?env_v_pes_err_v_s =\n  (case ?env_v_pes_err_v_s of\n   (env, v, pes, err_v, s) \\<Rightarrow>\n     evaluate_match True env s v pes err_v)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_match.\n       \\<forall>env v pes err_v s.\n          evaluate_match True env s v pes err_v\n           (run_eval_match env v pes err_v s)", "have \"\\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)", "proof (rule choice, safe, unfold f_def prod.case)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b. Ex (evaluate_match True a b aa ab ac)", "fix env v pes err_v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b. Ex (evaluate_match True a b aa ab ac)", "fix s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b. Ex (evaluate_match True a b aa ab ac)", "obtain s' r where \"evaluate_match True env s v pes err_v (s', r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' r.\n        evaluate_match True env s v pes err_v (s', r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis evaluate_match_total)"], ["proof (state)\nthis:\n  evaluate_match True env s v pes err_v (s', r)\n\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b. Ex (evaluate_match True a b aa ab ac)", "then"], ["proof (chain)\npicking this:\n  evaluate_match True env s v pes err_v (s', r)", "show \"\\<exists>r. evaluate_match True env s v pes err_v r\""], ["proof (prove)\nusing this:\n  evaluate_match True env s v pes err_v (s', r)\n\ngoal (1 subgoal):\n 1. \\<exists>r. evaluate_match True env s v pes err_v r", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. evaluate_match True env s v pes err_v r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_match.\n       \\<forall>env v pes err_v s.\n          evaluate_match True env s v pes err_v\n           (run_eval_match env v pes err_v s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>g. \\<forall>env_es_s. f env_es_s (g env_es_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_match.\n       \\<forall>env v pes err_v s.\n          evaluate_match True env s v pes err_v\n           (run_eval_match env v pes err_v s)", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>g.\n     \\<forall>env_es_s.\n        (case env_es_s of\n         (env, v, pes, err_v, s) \\<Rightarrow>\n           evaluate_match True env s v pes err_v)\n         (g env_es_s)\n\ngoal (1 subgoal):\n 1. \\<exists>run_eval_match.\n       \\<forall>env v pes err_v s.\n          evaluate_match True env s v pes err_v\n           (run_eval_match env v pes err_v s)", "by force"], ["proof (state)\nthis:\n  \\<exists>run_eval_match.\n     \\<forall>env v pes err_v s.\n        evaluate_match True env s v pes err_v\n         (run_eval_match env v pes err_v s)\n\ngoal:\nNo subgoals!", "qed"], ["", "global_interpretation run: eval\n  \"SOME f. \\<forall>env e s. evaluate True env s e (f env e s)\"\n  \"SOME f. \\<forall>env es s. evaluate_list True env s es (f env es s)\"\n  \"SOME f. \\<forall>env v pes err_v s. evaluate_match True env s v pes err_v (f env v pes err_v s)\"\n  defines\n    run_eval = \"SOME f. \\<forall>env e s. evaluate True env s e (f env e s)\" and\n    run_eval_list = \"SOME f. \\<forall>env es s. evaluate_list True env s es (f env es s)\" and\n    run_eval_match = \"SOME f. \\<forall>env v pes err_v s. evaluate_match True env s v pes err_v (f env v pes err_v s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (SOME f. \\<forall>env e s. evaluate True env s e (f env e s))\n     (SOME f. \\<forall>env es s. evaluate_list True env s es (f env es s))\n     (SOME f.\n         \\<forall>env v pes err_v s.\n            evaluate_match True env s v pes err_v (f env v pes err_v s))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>env s e.\n       evaluate True env s e\n        ((SOME f. \\<forall>env e s. evaluate True env s e (f env e s)) env e\n          s)\n 2. \\<And>env s es.\n       evaluate_list True env s es\n        ((SOME f.\n             \\<forall>env es s. evaluate_list True env s es (f env es s))\n          env es s)\n 3. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>env s e.\n       evaluate True env s e\n        ((SOME f. \\<forall>env e s. evaluate True env s e (f env e s)) env e\n          s)\n 2. \\<And>env s es.\n       evaluate_list True env s es\n        ((SOME f.\n             \\<forall>env es s. evaluate_list True env s es (f env es s))\n          env es s)\n 3. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env_ s_ e_\n     ((SOME f. \\<forall>env e s. evaluate True env s e (f env e s)) env_ e_\n       s_)", "using someI_ex[OF run_eval, rule_format]"], ["proof (prove)\nusing this:\n  evaluate True ?env ?s ?e\n   ((SOME x. \\<forall>env e s. evaluate True env s e (x env e s)) ?env ?e\n     ?s)\n\ngoal (1 subgoal):\n 1. evaluate True env_ s_ e_\n     ((SOME f. \\<forall>env e s. evaluate True env s e (f env e s)) env_ e_\n       s_)", "."], ["proof (state)\nthis:\n  evaluate True env_ s_ e_\n   ((SOME f. \\<forall>env e s. evaluate True env s e (f env e s)) env_ e_\n     s_)\n\ngoal (2 subgoals):\n 1. \\<And>env s es.\n       evaluate_list True env s es\n        ((SOME f.\n             \\<forall>env es s. evaluate_list True env s es (f env es s))\n          env es s)\n 2. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>env s es.\n       evaluate_list True env s es\n        ((SOME f.\n             \\<forall>env es s. evaluate_list True env s es (f env es s))\n          env es s)\n 2. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>env s es.\n       evaluate_list True env s es\n        ((SOME f.\n             \\<forall>env es s. evaluate_list True env s es (f env es s))\n          env es s)\n 2. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env_ s_ es_\n     ((SOME f. \\<forall>env es s. evaluate_list True env s es (f env es s))\n       env_ es_ s_)", "using someI_ex[OF run_eval_list, rule_format]"], ["proof (prove)\nusing this:\n  evaluate_list True ?env ?s ?es\n   ((SOME x. \\<forall>env es s. evaluate_list True env s es (x env es s))\n     ?env ?es ?s)\n\ngoal (1 subgoal):\n 1. evaluate_list True env_ s_ es_\n     ((SOME f. \\<forall>env es s. evaluate_list True env s es (f env es s))\n       env_ es_ s_)", "."], ["proof (state)\nthis:\n  evaluate_list True env_ s_ es_\n   ((SOME f. \\<forall>env es s. evaluate_list True env s es (f env es s))\n     env_ es_ s_)\n\ngoal (1 subgoal):\n 1. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        ((SOME f.\n             \\<forall>env v pes err_v s.\n                evaluate_match True env s v pes err_v (f env v pes err_v s))\n          env v pes err_v s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env_ s_ v_ pes_ err_v_\n     ((SOME f.\n          \\<forall>env v pes err_v s.\n             evaluate_match True env s v pes err_v (f env v pes err_v s))\n       env_ v_ pes_ err_v_ s_)", "using someI_ex[OF run_eval_match, rule_format]"], ["proof (prove)\nusing this:\n  evaluate_match True ?env ?s ?v ?pes ?err_v\n   ((SOME x.\n        \\<forall>env v pes err_v s.\n           evaluate_match True env s v pes err_v (x env v pes err_v s))\n     ?env ?v ?pes ?err_v ?s)\n\ngoal (1 subgoal):\n 1. evaluate_match True env_ s_ v_ pes_ err_v_\n     ((SOME f.\n          \\<forall>env v pes err_v s.\n             evaluate_match True env s v pes err_v (f env v pes err_v s))\n       env_ v_ pes_ err_v_ s_)", "."], ["proof (state)\nthis:\n  evaluate_match True env_ s_ v_ pes_ err_v_\n   ((SOME f.\n        \\<forall>env v pes err_v s.\n           evaluate_match True env s v pes err_v (f env v pes err_v s))\n     env_ v_ pes_ err_v_ s_)\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_fact run_eval"], ["", "hide_fact run_eval_list"], ["", "hide_fact run_eval_match"], ["", "lemma fun_evaluate:\n  \"evaluate_match True env s v pes err_v (map_prod id (map_result hd id) (fun_evaluate_match s env v pes err_v))\"\n  \"evaluate_list True env s es (fun_evaluate s env es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env s v pes err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match s env v pes err_v)) &&&\n    evaluate_list True env s es (fun_evaluate s env es)", "proof (induction rule: fun_evaluate_induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env e pes.\n       \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rerr x2;\n            x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_match True env x x1 pes x1\n                              (map_prod id (map_result hd id)\n                                (fun_evaluate_match x env x1 pes\n                                  x1))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (fun_evaluate st env [Handle e pes])\n 6. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        evaluate_list True env st (rev es)\n         (fun_evaluate st env (rev es))) \\<Longrightarrow>\n       evaluate_list True env st [Con cn es]\n        (fun_evaluate st env [Con cn es])\n 7. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 8. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 9. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 10. \\<And>st env lop e1 e2.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1 x2 x1a.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n             do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True env x [x1a]\n                               (fun_evaluate x env [x1a])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                           (fun_evaluate st env [Log lop e1 e2])\nA total of 18 subgoals...", "case (5 st env e pes)"], ["proof (state)\nthis:\n  evaluate_list True env st [e] (fun_evaluate st env [e])\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env [e]; ?y = Rerr ?x2.0;\n   ?x2.0 = Rraise ?x1.0\\<rbrakk>\n  \\<Longrightarrow> evaluate_match True env ?x ?x1.0 pes ?x1.0\n                     (map_prod id (map_result hd id)\n                       (fun_evaluate_match ?x env ?x1.0 pes ?x1.0))\n\ngoal (18 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env e pes.\n       \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n        \\<And>x y x2 x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rerr x2;\n            x2 = Rraise x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_match True env x x1 pes x1\n                              (map_prod id (map_result hd id)\n                                (fun_evaluate_match x env x1 pes\n                                  x1))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (fun_evaluate st env [Handle e pes])\n 6. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        evaluate_list True env st (rev es)\n         (fun_evaluate st env (rev es))) \\<Longrightarrow>\n       evaluate_list True env st [Con cn es]\n        (fun_evaluate st env [Con cn es])\n 7. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 8. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 9. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 10. \\<And>st env lop e1 e2.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1 x2 x1a.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n             do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True env x [x1a]\n                               (fun_evaluate x env [x1a])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                           (fun_evaluate st env [Log lop e1 e2])\nA total of 18 subgoals...", "from 5(1)"], ["proof (chain)\npicking this:\n  evaluate_list True env st [e] (fun_evaluate st env [e])", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] (fun_evaluate st env [e])\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Handle e pes]\n     (fun_evaluate st env [Handle e pes])", "apply (rule evaluate_list_singleton_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s' v.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n        evaluate True env st e (s', Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (fun_evaluate st env [Handle e pes])\n 2. \\<And>s' err.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr err);\n        evaluate True env st e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (fun_evaluate st env [Handle e pes])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                       (fun_evaluate st env [Handle e pes])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                       (s'_, Rval [v_])", "apply (rule evaluate_match_evaluate_list_evaluate.cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (Handle e pes)\n                       (?s2.1, Rval v_) \\<and>\n                      evaluate_list True env ?s2.1 [] (s'_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (Handle e pes) (?s2.1, Rval v_)\n 2. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env ?s2.1 [] (s'_, Rval [])", "apply (rule handle1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st e (?s2.1, Rval v_)\n 2. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env ?s2.1 [] (s'_, Rval [])", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rval [v_]);\n     evaluate True env st e (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env s'_ [] (s'_, Rval [])", "apply (rule evaluate_match_evaluate_list_evaluate.empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' err.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr err);\n        evaluate True env st e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (fun_evaluate st env [Handle e pes])", "subgoal for s' err"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rerr err);\n     evaluate True env st e (s', Rerr err)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                       (fun_evaluate st env [Handle e pes])", "apply (simp split!: error_result.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rraise x1));\n        evaluate True env st e (s', Rerr (Rraise x1));\n        err = Rraise x1\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (fun_evaluate_match s' env x1 pes x1)\n 2. \\<And>x2.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rabort x2));\n        evaluate True env st e (s', Rerr (Rabort x2));\n        err = Rabort x2\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (s', Rerr (Rabort x2))", "subgoal for exn"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rraise exn));\n     evaluate True env st e (s', Rerr (Rraise exn));\n     err = Rraise exn\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                       (fun_evaluate_match s' env exn pes exn)", "apply (cases \"fun_evaluate_match s' env exn pes exn\" rule: prod_result_cases; simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s v.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rraise exn));\n        evaluate True env st e (s', Rerr (Rraise exn)); err = Rraise exn;\n        fun_evaluate_match s' env exn pes exn = (s, Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (s, Rval v)\n 2. \\<And>s erra.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rraise exn));\n        evaluate True env st e (s', Rerr (Rraise exn)); err = Rraise exn;\n        fun_evaluate_match s' env exn pes exn = (s, Rerr erra)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (s, Rerr erra)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env st [Handle e pes] (s_, Rval v_)", "using prems(4)"], ["proof (prove)\nusing this:\n  fun_evaluate_match s' env exn pes exn = (s_, Rval v_)\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Handle e pes] (s_, Rval v_)", "apply (rule fun_evaluate_matchE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env st [Handle e pes] (s_, Rval v_)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env st [Handle e pes] (s_, Rval [v])", "apply (rule evaluate_match_evaluate_list_evaluate.cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st (Handle e pes) (?s2.2 v, Rval v) \\<and>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st (Handle e pes) (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (rule handle2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st e (?s2.5 v, Rerr (Rraise (?v1.5 v))) \\<and>\n       evaluate_match True env (?s2.5 v) (?v1.5 v) pes (?v1.5 v)\n        (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st e (?s2.5 v, Rerr (Rraise (?v1.5 v)))\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env (?s2.5 v) (?v1.5 v) pes (?v1.5 v)\n        (?s2.2 v, Rval v)\n 3. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (rule prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env s' exn pes exn (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "using 5(2)[OF prems(1)[symmetric] refl refl, unfolded prems(4)]"], ["proof (prove)\nusing this:\n  evaluate_match True env s' exn pes exn\n   (map_prod id (map_result hd id) (s_, Rval v_))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env s' exn pes exn (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow> evaluate_list True env s_ [] (s_, Rval [])", "by (rule evaluate_match_evaluate_list_evaluate.empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s erra.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rraise exn));\n        evaluate True env st e (s', Rerr (Rraise exn)); err = Rraise exn;\n        fun_evaluate_match s' env exn pes exn = (s, Rerr erra)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (s, Rerr erra)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env st [Handle e pes] (s_, Rerr erra_)", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st (Handle e pes) (s_, Rerr erra_)", "apply (rule handle2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (?s2.2, Rerr (Rraise ?v1.2)) \\<and>\n    evaluate_match True env ?s2.2 ?v1.2 pes ?v1.2 (s_, Rerr erra_)", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate True env st e (?s2.2, Rerr (Rraise ?v1.2))\n 2. evaluate_match True env ?s2.2 ?v1.2 pes ?v1.2 (s_, Rerr erra_)", "apply (rule prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env s' exn pes exn (s_, Rerr erra_)", "supply error_result.map_ident[simp]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env s' exn pes exn (s_, Rerr erra_)", "using 5(2)[OF prems(1)[symmetric] refl refl, unfolded prems(4), simplified]"], ["proof (prove)\nusing this:\n  evaluate_match True env s' exn pes exn (s_, Rerr erra_)\n\ngoal (1 subgoal):\n 1. evaluate_match True env s' exn pes exn (s_, Rerr erra_)", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rabort x2));\n        evaluate True env st e (s', Rerr (Rabort x2));\n        err = Rabort x2\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                          (s', Rerr (Rabort x2))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rabort x2_));\n     evaluate True env st e (s', Rerr (Rabort x2_));\n     err = Rabort x2_\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Handle e pes]\n                       (s', Rerr (Rabort x2_))", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rabort x2_));\n     evaluate True env st e (s', Rerr (Rabort x2_));\n     err = Rabort x2_\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (Handle e pes)\n                       (s', Rerr (Rabort x2_))", "apply (rule handle3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rerr (Rabort x2_));\n     evaluate True env st e (s', Rerr (Rabort x2_));\n     err = Rabort x2_\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st e (s', Rerr (Rabort x2_))", "by assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_list True env st [Handle e pes]\n   (fun_evaluate st env [Handle e pes])\n\ngoal (17 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        evaluate_list True env st (rev es)\n         (fun_evaluate st env (rev es))) \\<Longrightarrow>\n       evaluate_list True env st [Con cn es]\n        (fun_evaluate st env [Con cn es])\n 6. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 7. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 8. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n             do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True env x [x2]\n                               (fun_evaluate x env [x2])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                           (fun_evaluate st env [exp0.If e1 e2 e3])\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        evaluate_list True env st (rev es)\n         (fun_evaluate st env (rev es))) \\<Longrightarrow>\n       evaluate_list True env st [Con cn es]\n        (fun_evaluate st env [Con cn es])\n 6. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 7. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 8. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n             do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True env x [x2]\n                               (fun_evaluate x env [x2])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                           (fun_evaluate st env [exp0.If e1 e2 e3])\nA total of 17 subgoals...", "case (6 st env cn es)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es) \\<Longrightarrow>\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n\ngoal (17 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env cn es.\n       (do_con_check (c env) cn (length es) \\<Longrightarrow>\n        evaluate_list True env st (rev es)\n         (fun_evaluate st env (rev es))) \\<Longrightarrow>\n       evaluate_list True env st [Con cn es]\n        (fun_evaluate st env [Con cn es])\n 6. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 7. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 8. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 9. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 10. \\<And>st env e1 e2 e3.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1 x2.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n             do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True env x [x2]\n                               (fun_evaluate x env [x2])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                           (fun_evaluate st env [exp0.If e1 e2 e3])\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "proof (cases \"do_con_check (c env) cn (length es)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])\n 2. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "case True"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n\ngoal (2 subgoals):\n 1. do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])\n 2. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "then"], ["proof (chain)\npicking this:\n  do_con_check (c env) cn (length es)", "show ?thesis"], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es]\n     (case fun_evaluate st env (rev es) of\n      (st', Rval vs) \\<Rightarrow>\n        case build_conv (c env) cn (rev vs) of\n        None \\<Rightarrow> (st', Rerr (Rabort Rtype_error))\n        | Some v2 \\<Rightarrow> (st', Rval [v2])\n      | (st', Rerr error_result) \\<Rightarrow> (st', Rerr error_result))", "apply (frule 6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_con_check (c env) cn (length es);\n     evaluate_list True env st (rev es)\n      (fun_evaluate st env (rev es))\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Con cn es]\n                       (case fun_evaluate st env (rev es) of\n                        (st', Rval vs) \\<Rightarrow>\n                          case build_conv (c env) cn (rev vs) of\n                          None \\<Rightarrow>\n                            (st', Rerr (Rabort Rtype_error))\n                          | Some v2 \\<Rightarrow> (st', Rval [v2])\n                        | (st', Rerr error_result) \\<Rightarrow>\n                            (st', Rerr error_result))", "apply (cases \"fun_evaluate st env (rev es)\" rule: prod_result_cases; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s v.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s, Rval v);\n        fun_evaluate st env (rev es) = (s, Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Con cn es]\n                          (case build_conv (c env) cn (rev v) of\n                           None \\<Rightarrow> (s, Rerr (Rabort Rtype_error))\n                           | Some v2 \\<Rightarrow> (s, Rval [v2]))\n 2. \\<And>s err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s, Rerr err);\n        fun_evaluate st env (rev es) = (s, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Con cn es] (s, Rerr err)", "subgoal for _ vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_con_check (c env) cn (length es);\n     evaluate_list True env st (rev es) (s_, Rval vs);\n     fun_evaluate st env (rev es) = (s_, Rval vs)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Con cn es]\n                       (case build_conv (c env) cn (rev vs) of\n                        None \\<Rightarrow> (s_, Rerr (Rabort Rtype_error))\n                        | Some v2 \\<Rightarrow> (s_, Rval [v2]))", "apply (frule do_con_check_build_conv[where vs = \"rev vs\"], auto split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Con cn es]\n                          (s_, Rval [y])", "apply (rule evaluate_match_evaluate_list_evaluate.cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate True env st (Con cn es)\n                          (?s2.14 y, Rval y) \\<and>\n                         evaluate_list True env (?s2.14 y) [] (s_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate True env st (Con cn es) (?s2.14 y, Rval y)\n 2. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env (?s2.14 y) [] (s_, Rval [])", "apply (rule con1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> do_con_check (c env) cn (length es) \\<and>\n                         build_conv (c env) cn (rev (?vs17 y)) =\n                         Some y \\<and>\n                         evaluate_list True env st (rev es)\n                          (?s2.14 y, Rval (?vs17 y))\n 2. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env (?s2.14 y) [] (s_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> do_con_check (c env) cn (length es)\n 2. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> build_conv (c env) cn (rev (?vs17 y)) = Some y\n 3. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (rev es)\n                          (?s2.14 y, Rval (?vs17 y))\n 4. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env (?s2.14 y) [] (s_, Rval [])", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s_, Rval vs);\n        fun_evaluate st env (rev es) = (s_, Rval vs);\n        build_conv (c env) cn (rev vs) = Some y\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env s_ [] (s_, Rval [])", "by (rule evaluate_match_evaluate_list_evaluate.empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        evaluate_list True env st (rev es) (s, Rerr err);\n        fun_evaluate st env (rev es) = (s, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Con cn es] (s, Rerr err)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>do_con_check (c env) cn (length es);\n     evaluate_list True env st (rev es) (s_, Rerr err_);\n     fun_evaluate st env (rev es) = (s_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Con cn es] (s_, Rerr err_)", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])\n\ngoal (1 subgoal):\n 1. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "case False"], ["proof (state)\nthis:\n  \\<not> do_con_check (c env) cn (length es)\n\ngoal (1 subgoal):\n 1. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "then"], ["proof (chain)\npicking this:\n  \\<not> do_con_check (c env) cn (length es)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> do_con_check (c env) cn (length es)\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate_list True env st [Con cn es] (st, Rerr (Rabort Rtype_error))", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    evaluate True env st (Con cn es) (st, Rerr (Rabort Rtype_error))", "apply (rule con2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> do_con_check (c env) cn (length es) \\<Longrightarrow>\n    \\<not> do_con_check (c env) cn (length es)", "by assumption"], ["proof (state)\nthis:\n  evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_list True env st [Con cn es] (fun_evaluate st env [Con cn es])\n\ngoal (16 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 10. \\<And>st env e pes.\n        \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                               (map_prod id (map_result hd id)\n                                 (fun_evaluate_match x env (hd x1) pes\n                                   Bindv))\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                           (fun_evaluate st env [Mat e pes])\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 10. \\<And>st env e pes.\n        \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                               (map_prod id (map_result hd id)\n                                 (fun_evaluate_match x env (hd x1) pes\n                                   Bindv))\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                           (fun_evaluate st env [Mat e pes])\nA total of 16 subgoals...", "case (9 st env op es)"], ["proof (state)\nthis:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n\ngoal (16 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 10. \\<And>st env e pes.\n        \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                               (map_prod id (map_result hd id)\n                                 (fun_evaluate_match x env (hd x1) pes\n                                   Bindv))\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                           (fun_evaluate st env [Mat e pes])\nA total of 16 subgoals...", "note do_app.simps[simp del]"], ["proof (state)\nthis:\n  do_app (?s, ?t1.0) ?op1.0 ?vs =\n  (case (?op1.0, ?vs) of (Opn op1, []) \\<Rightarrow> None\n   | (Opn op1, [Litv (IntLit n1)]) \\<Rightarrow> None\n   | (Opn op1, [Litv (IntLit n1), Litv (IntLit n2)]) \\<Rightarrow>\n       if (op1 = Divide \\<or> op1 = Modulo) \\<and> n2 = 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Div'')))\n       else Some ((?s, ?t1.0), Rval (Litv (IntLit (opn_lookup op1 n1 n2))))\n   | (Opn op1, Litv (IntLit n1) # Litv (IntLit n2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1, Litv (IntLit n1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opn op1, Litv (IntLit n1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1,\n      Litv (IntLit n1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1,\n      Litv (IntLit n1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1, Litv (IntLit n1) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Opn op1, Litv (IntLit n1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opn op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opn op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opn op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, []) \\<Rightarrow> None\n   | (Opb op1, [Litv (IntLit n1)]) \\<Rightarrow> None\n   | (Opb op1, [Litv (IntLit n1), Litv (IntLit n2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Boolv (opb_lookup op1 n1 n2)))\n   | (Opb op1, Litv (IntLit n1) # Litv (IntLit n2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1, Litv (IntLit n1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opb op1, Litv (IntLit n1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1,\n      Litv (IntLit n1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1,\n      Litv (IntLit n1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1, Litv (IntLit n1) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Opb op1, Litv (IntLit n1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opb op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opb op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opb op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, []) \\<Rightarrow> None\n   | (Opw W8 op1, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, [Litv (Word8 w1)]) \\<Rightarrow> None\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1,\n      Litv (Word8 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1, [Litv (Word8 w1), Litv (Word8 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word8 (opw8_lookup op1 w1 w2))))\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (Word8 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Litv (Word8 w1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W8 op1, Litv (Word8 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1,\n      Litv (Word8 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1,\n      Litv (Word8 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Litv (Word8 w1) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Litv (Word8 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W8 op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Opw W8 op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opw W8 op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, []) \\<Rightarrow> None\n   | (Opw W64 op1, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Opw W64 op1, [Litv (Word64 w1)]) \\<Rightarrow> None\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1, Litv (Word64 w1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Opw W64 op1, [Litv (Word64 w1), Litv (Word64 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (opw64_lookup op1 w1 w2))))\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Litv (Word64 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Litv (Word64 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1,\n      Litv (Word64 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Litv (Word64 w1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Litv (Word64 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Opw W64 op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Opw W64 op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, []) \\<Rightarrow> None\n   | (Shift W8 op1 n, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, [Litv (Word8 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word8 (shift8_lookup op1 w n))))\n   | (Shift W8 op1 n, Litv (Word8 w) # a # x) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W8 op1 n, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W8 op1 n, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W8 op1 n, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Shift W8 op1 n, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, []) \\<Rightarrow> None\n   | (Shift W64 op1 n, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Shift W64 op1 n, [Litv (Word64 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (shift64_lookup op1 w n))))\n   | (Shift W64 op1 n, Litv (Word64 w) # a # x) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W64 op1 n, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Shift W64 op1 n, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Shift W64 op1 n, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Equality, []) \\<Rightarrow> None | (Equality, [v1]) \\<Rightarrow> None\n   | (Equality, [v1, v2]) \\<Rightarrow>\n       case do_eq v1 v2 of\n       Eq_val b \\<Rightarrow> Some ((?s, ?t1.0), Rval (Boolv b))\n       | Eq_type_error \\<Rightarrow> None\n   | (Equality, v1 # v2 # ab # x) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, []) \\<Rightarrow> None\n   | (FP_cmp cmp, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_cmp cmp, [Litv (Word64 w1)]) \\<Rightarrow> None\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp,\n      Litv (Word64 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_cmp cmp, [Litv (Word64 w1), Litv (Word64 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Boolv (fp_cmp cmp w1 w2)))\n   | (FP_cmp cmp, Litv (Word64 w1) # Litv (Word64 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Litv (Word64 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp,\n      Litv (Word64 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp,\n      Litv (Word64 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Litv (Word64 w1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Litv (Word64 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (FP_cmp cmp, Loc x # list) \\<Rightarrow> Map.empty x\n   | (FP_cmp cmp, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, []) \\<Rightarrow> None\n   | (FP_uop uop, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_uop uop, [Litv (Word64 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (fp_uop uop w))))\n   | (FP_uop uop, Litv (Word64 w) # a # x) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (FP_uop uop, Loc x # list) \\<Rightarrow> Map.empty x\n   | (FP_uop uop, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, []) \\<Rightarrow> None\n   | (FP_bop bop, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (FP_bop bop, [Litv (Word64 w1)]) \\<Rightarrow> None\n   | (FP_bop bop, Litv (Word64 w1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop,\n      Litv (Word64 w1) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop, Litv (Word64 w1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop, Litv (Word64 w1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (FP_bop bop, [Litv (Word64 w1), Litv (Word64 w2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (fp_bop bop w1 w2))))\n   | (FP_bop bop, Litv (Word64 w1) # Litv (Word64 w2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Litv (Word64 w1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop,\n      Litv (Word64 w1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop,\n      Litv (Word64 w1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Litv (Word64 w1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Litv (Word64 w1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (FP_bop bop, Loc x # list) \\<Rightarrow> Map.empty x\n   | (FP_bop bop, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opapp, b) \\<Rightarrow> None | (Opassign, []) \\<Rightarrow> None\n   | (Opassign, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opassign, [Loc lnum]) \\<Rightarrow> None\n   | (Opassign, [Loc lnum, v2]) \\<Rightarrow>\n       case store_assign lnum (Refv v2) ?s of None \\<Rightarrow> None\n       | Some s' \\<Rightarrow> Some ((s', ?t1.0), Rval (Conv None []))\n   | (Opassign, Loc lnum # v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Opassign, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Opref, []) \\<Rightarrow> None\n   | (Opref, [v2]) \\<Rightarrow>\n       let (s', n) = store_alloc (Refv v2) ?s\n       in Some ((s', ?t1.0), Rval (Loc n))\n   | (Opref, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Opderef, []) \\<Rightarrow> None\n   | (Opderef, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Opderef, [Loc n]) \\<Rightarrow>\n       case store_lookup n ?s of None \\<Rightarrow> None\n       | Some (Refv v2) \\<Rightarrow> Some ((?s, ?t1.0), Rval v2)\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Opderef, Loc n # a # x) \\<Rightarrow> Map.empty x\n   | (Opderef, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, []) \\<Rightarrow> None\n   | (Aw8alloc, [Litv (IntLit n)]) \\<Rightarrow> None\n   | (Aw8alloc, Litv (IntLit n) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, Litv (IntLit n) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, Litv (IntLit n) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, [Litv (IntLit n), Litv (Word8 w)]) \\<Rightarrow>\n       if n < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let (s', lnum) =\n                  store_alloc (W8array (replicate (nat \\<bar>n\\<bar>) w)) ?s\n            in Some ((s', ?t1.0), Rval (Loc lnum))\n   | (Aw8alloc, Litv (IntLit n) # Litv (Word8 w) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc, Litv (IntLit n) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8alloc, Litv (IntLit n) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc,\n      Litv (IntLit n) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc,\n      Litv (IntLit n) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc, Litv (IntLit n) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Litv (IntLit n) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8alloc, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aw8alloc, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Aw8alloc, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, []) \\<Rightarrow> None\n   | (Aw8sub, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aw8sub, [Loc lnum]) \\<Rightarrow> None\n   | (Aw8sub, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length ws \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else Some ((?s, ?t1.0), Rval (Litv (Word8 (ws ! n))))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Aw8sub, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8sub, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8sub, Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8sub, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8sub, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, []) \\<Rightarrow> None\n   | (Aw8length, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8length, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8length, [Loc n]) \\<Rightarrow>\n       case store_lookup n ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length ws)))))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Aw8length, Loc n # a # x) \\<Rightarrow> Map.empty x\n   | (Aw8length, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, []) \\<Rightarrow> None\n   | (Aw8update, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aw8update, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, [Loc lnum]) \\<Rightarrow> None\n   | (Aw8update, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow> None\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (IntLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, [Loc lnum, Litv (IntLit i), Litv (Word8 w)]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length ws \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else case store_assign lnum (W8array (ws[n := w])) ?s of\n                        None \\<Rightarrow> None\n                        | Some s' \\<Rightarrow>\n                            Some ((s', ?t1.0), Rval (Conv None []))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (Word8 w) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum #\n      Litv (IntLit i) # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum #\n      Litv (IntLit i) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, Loc lnum # Litv (IntLit i) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum # Litv (IntLit i) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aw8update, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8update, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update,\n      Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aw8update, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8update, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Aw8update, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, []) \\<Rightarrow> None\n   | (WordFromInt W8, [Litv (IntLit i)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word8 (word_of_int i))))\n   | (WordFromInt W8, Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W8, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, []) \\<Rightarrow> None\n   | (WordFromInt W64, [Litv (IntLit i)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (Word64 (word_of_int i))))\n   | (WordFromInt W64, Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordFromInt W64, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W64, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordFromInt W64, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordFromInt W64, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, []) \\<Rightarrow> None\n   | (WordToInt W8, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, [Litv (Word8 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (unat w)))))\n   | (WordToInt W8, Litv (Word8 w) # a # x) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W8, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, []) \\<Rightarrow> None\n   | (WordToInt W64, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (WordToInt W64, [Litv (Word64 w)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (unat w)))))\n   | (WordToInt W64, Litv (Word64 w) # a # x) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W64, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (WordToInt W64, Loc x # list) \\<Rightarrow> Map.empty x\n   | (WordToInt W64, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, []) \\<Rightarrow> None\n   | (CopyStrStr, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, [Litv (StrLit str)]) \\<Rightarrow> None\n   | (CopyStrStr, [Litv (StrLit str), Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyStrStr,\n      [Litv (StrLit str), Litv (IntLit off),\n       Litv (IntLit len)]) \\<Rightarrow>\n       Some\n        ((?s, ?t1.0),\n         case copy_array (str, off) len None of\n         None \\<Rightarrow> Rerr (Rraise (prim_exn ''Subscript''))\n         | Some cs \\<Rightarrow> Rval (Litv (StrLit cs)))\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (IntLit len) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Closure sem_env listc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr, Litv (StrLit str) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr,\n      Litv (StrLit str) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrStr, Litv (StrLit str) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr,\n      Litv (StrLit str) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Litv (StrLit str) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Litv (StrLit str) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrStr, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrStr, Loc x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrStr, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, []) \\<Rightarrow> None\n   | (CopyStrAw8, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, [Litv (StrLit str)]) \\<Rightarrow> None\n   | (CopyStrAw8, [Litv (StrLit str), Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyStrAw8,\n      [Litv (StrLit str), Litv (IntLit off),\n       Litv (IntLit len)]) \\<Rightarrow>\n       None\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (IntLit len) # Litv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      [Litv (StrLit str), Litv (IntLit off), Litv (IntLit len),\n       Loc dst]) \\<Rightarrow>\n       None\n   | (CopyStrAw8,\n      [Litv (StrLit str), Litv (IntLit off), Litv (IntLit len), Loc dst,\n       Litv (IntLit dstoff)]) \\<Rightarrow>\n       case store_lookup dst ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           case copy_array (str, off) len (Some (ws_to_chars ws, dstoff)) of\n           None \\<Rightarrow>\n             Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           | Some cs \\<Rightarrow>\n               case store_assign dst (W8array (chars_to_ws cs)) ?s of\n               None \\<Rightarrow> None\n               | Some s' \\<Rightarrow>\n                   Some ((s', ?t1.0), Rval (Conv None []))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Litv (IntLit dstoff) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Closure sem_env listc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Closure sem_env listc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) #\n      Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8, Litv (StrLit str) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8,\n      Litv (StrLit str) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyStrAw8, Litv (StrLit str) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8,\n      Litv (StrLit str) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Litv (StrLit str) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Litv (StrLit str) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (CopyStrAw8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyStrAw8, Loc x # list) \\<Rightarrow> Map.empty x\n   | (CopyStrAw8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, []) \\<Rightarrow> None\n   | (CopyAw8Str, Litv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, [Loc src]) \\<Rightarrow> None\n   | (CopyAw8Str, [Loc src, Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyAw8Str,\n      [Loc src, Litv (IntLit off), Litv (IntLit len)]) \\<Rightarrow>\n       case store_lookup src ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           Some\n            ((?s, ?t1.0),\n             case copy_array (ws, off) len None of\n             None \\<Rightarrow> Rerr (Rraise (prim_exn ''Subscript''))\n             | Some ws \\<Rightarrow> Rval (Litv (StrLit (ws_to_chars ws))))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (IntLit len) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src #\n      Litv (IntLit off) # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, Loc src # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src # Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, Loc src # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Str, Loc src # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Loc src # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str,\n      Loc src # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Str, Loc src # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Loc src # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Str, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, []) \\<Rightarrow> None\n   | (CopyAw8Aw8, Litv x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, [Loc src]) \\<Rightarrow> None\n   | (CopyAw8Aw8, [Loc src, Litv (IntLit off)]) \\<Rightarrow> None\n   | (CopyAw8Aw8,\n      [Loc src, Litv (IntLit off), Litv (IntLit len)]) \\<Rightarrow>\n       None\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) # Litv (IntLit len) # Litv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      [Loc src, Litv (IntLit off), Litv (IntLit len),\n       Loc dst]) \\<Rightarrow>\n       None\n   | (CopyAw8Aw8,\n      [Loc src, Litv (IntLit off), Litv (IntLit len), Loc dst,\n       Litv (IntLit dstoff)]) \\<Rightarrow>\n       case (store_lookup src ?s, store_lookup dst ?s) of\n       (None, b) \\<Rightarrow> None\n       | (Some (Refv xa), b) \\<Rightarrow> Map.empty xa\n       | (Some (W8array ws), None) \\<Rightarrow> None\n       | (Some (W8array ws), Some (Refv xa)) \\<Rightarrow> Map.empty xa\n       | (Some (W8array ws), Some (W8array ds)) \\<Rightarrow>\n           case copy_array (ws, off) len (Some (ds, dstoff)) of\n           None \\<Rightarrow>\n             Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           | Some ws \\<Rightarrow>\n               case store_assign dst (W8array ws) ?s of\n               None \\<Rightarrow> None\n               | Some s' \\<Rightarrow>\n                   Some ((s', ?t1.0), Rval (Conv None []))\n       | (Some (W8array ws), Some (Varray xa)) \\<Rightarrow> Map.empty xa\n       | (Some (Varray xa), b) \\<Rightarrow> Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Litv (IntLit dstoff) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) #\n      Loc dst # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Loc dst # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) #\n      Litv (IntLit len) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (lit.Char xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (StrLit xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (Word8 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Litv (Word64 xa) # list) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Conv option x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) # Closure sem_env listb x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src #\n      Litv (IntLit off) # Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, Loc src # Litv (IntLit off) # Loc x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src # Litv (IntLit off) # Vectorv x # list) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, Loc src # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (CopyAw8Aw8, Loc src # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Loc src # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8,\n      Loc src # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (CopyAw8Aw8, Loc src # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Loc src # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (CopyAw8Aw8, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Ord, []) \\<Rightarrow> None\n   | (Ord, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, [Litv (lit.Char c2)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (of_char c2)))))\n   | (Ord, Litv (lit.Char c2) # a # x) \\<Rightarrow> Map.empty x\n   | (Ord, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Ord, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Ord, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Chr, []) \\<Rightarrow> None\n   | (Chr, [Litv (IntLit i)]) \\<Rightarrow>\n       Some\n        ((?s, ?t1.0),\n         if i < 0 \\<or> 255 < i then Rerr (Rraise (prim_exn ''Chr''))\n         else Rval (Litv (lit.Char (char_of (nat \\<bar>i\\<bar>)))))\n   | (Chr, Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Chr, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chr, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Chr, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, []) \\<Rightarrow> None\n   | (Chopb op1, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, [Litv (lit.Char c1)]) \\<Rightarrow> None\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (IntLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1, [Litv (lit.Char c1), Litv (lit.Char c2)]) \\<Rightarrow>\n       Some\n        ((?s, ?t1.0),\n         Rval\n          (Boolv (opb_lookup op1 (int (of_char c1)) (int (of_char c2)))))\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (lit.Char c2) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1, Litv (lit.Char c1) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1,\n      Litv (lit.Char c1) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Chopb op1, Litv (lit.Char c1) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1,\n      Litv (lit.Char c1) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1,\n      Litv (lit.Char c1) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Litv (lit.Char c1) # Loc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Litv (lit.Char c1) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Chopb op1, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (Chopb op1, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Chopb op1, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Implode, []) \\<Rightarrow> None\n   | (Implode, [v2]) \\<Rightarrow>\n       case v_to_char_list v2 of None \\<Rightarrow> None\n       | Some ls \\<Rightarrow> Some ((?s, ?t1.0), Rval (Litv (StrLit ls)))\n   | (Implode, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Strsub, []) \\<Rightarrow> None\n   | (Strsub, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, [Litv (StrLit str)]) \\<Rightarrow> None\n   | (Strsub, [Litv (StrLit str), Litv (IntLit i)]) \\<Rightarrow>\n       if i < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let n = nat \\<bar>i\\<bar>\n            in if length str \\<le> n\n               then Some\n                     ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n               else Some ((?s, ?t1.0), Rval (Litv (lit.Char (str ! n))))\n   | (Strsub, Litv (StrLit str) # Litv (IntLit i) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (Strsub, Litv (StrLit str) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Strsub, Litv (StrLit str) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub,\n      Litv (StrLit str) # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub,\n      Litv (StrLit str) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub, Litv (StrLit str) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Strsub, Litv (StrLit str) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Strsub, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strsub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Strsub, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, []) \\<Rightarrow> None\n   | (Strlen, Litv (IntLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, [Litv (StrLit str)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length str)))))\n   | (Strlen, Litv (StrLit str) # a # x) \\<Rightarrow> Map.empty x\n   | (Strlen, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Strlen, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Strlen, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Strcat, []) \\<Rightarrow> None\n   | (Strcat, [v2]) \\<Rightarrow>\n       case v_to_list v2 of None \\<Rightarrow> None\n       | Some vs \\<Rightarrow>\n           case vs_to_string vs of None \\<Rightarrow> None\n           | Some str \\<Rightarrow>\n               Some ((?s, ?t1.0), Rval (Litv (StrLit str)))\n   | (Strcat, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (VfromList, []) \\<Rightarrow> None\n   | (VfromList, [v2]) \\<Rightarrow>\n       case v_to_list v2 of None \\<Rightarrow> None\n       | Some vs \\<Rightarrow> Some ((?s, ?t1.0), Rval (Vectorv vs))\n   | (VfromList, v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Vsub, []) \\<Rightarrow> None\n   | (Vsub, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Vsub, [Vectorv vs]) \\<Rightarrow> None\n   | (Vsub, [Vectorv vs, Litv (IntLit i)]) \\<Rightarrow>\n       if i < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let n = nat \\<bar>i\\<bar>\n            in if length vs \\<le> n\n               then Some\n                     ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n               else Some ((?s, ?t1.0), Rval (vs ! n))\n   | (Vsub, Vectorv vs # Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Vsub, Vectorv vs # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Vsub, Vectorv vs # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Vsub, Vectorv vs # Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Vsub, Vectorv vs # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Vsub, Vectorv vs # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Vsub, Vectorv vs # Closure sem_env listc x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Vsub, Vectorv vs # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Vsub, Vectorv vs # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Vsub, Vectorv vs # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Vlength, []) \\<Rightarrow> None\n   | (Vlength, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Vlength, [Vectorv vs]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length vs)))))\n   | (Vlength, Vectorv vs # a # x) \\<Rightarrow> Map.empty x\n   | (Aalloc, []) \\<Rightarrow> None\n   | (Aalloc, [Litv (IntLit n)]) \\<Rightarrow> None\n   | (Aalloc, [Litv (IntLit n), v2]) \\<Rightarrow>\n       if n < 0\n       then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n       else let (s', lnum) =\n                  store_alloc (Varray (replicate (nat \\<bar>n\\<bar>) v2)) ?s\n            in Some ((s', ?t1.0), Rval (Loc lnum))\n   | (Aalloc, Litv (IntLit n) # v2 # aa # xa) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (Aalloc, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Loc x # list) \\<Rightarrow> Map.empty x\n   | (Aalloc, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, []) \\<Rightarrow> None\n   | (AallocEmpty, Litv x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, [Conv None []]) \\<Rightarrow>\n       let (s', lnum) = store_alloc (Varray []) ?s\n       in Some ((s', ?t1.0), Rval (Loc lnum))\n   | (AallocEmpty, Conv None [] # a # x) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Conv None (a # x) # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Conv (Some x) listb # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Recclosure sem_env list1 x # list) \\<Rightarrow>\n       Map.empty x\n   | (AallocEmpty, Loc x # list) \\<Rightarrow> Map.empty x\n   | (AallocEmpty, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Asub, []) \\<Rightarrow> None\n   | (Asub, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Asub, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Asub, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Asub, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Asub, [Loc lnum]) \\<Rightarrow> None\n   | (Asub, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray vs) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length vs \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else Some ((?s, ?t1.0), Rval (vs ! n))\n   | (Asub, Loc lnum # Litv (IntLit i) # a # x) \\<Rightarrow> Map.empty x\n   | (Asub, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Asub, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Asub, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Asub, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (Asub, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Asub, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Asub, Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Asub, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Asub, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Asub, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Alength, []) \\<Rightarrow> None\n   | (Alength, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Alength, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Alength, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Alength, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Alength, [Loc n]) \\<Rightarrow>\n       case store_lookup n ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray ws) \\<Rightarrow>\n           Some ((?s, ?t1.0), Rval (Litv (IntLit (int (length ws)))))\n   | (Alength, Loc n # a # x) \\<Rightarrow> Map.empty x\n   | (Alength, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, []) \\<Rightarrow> None\n   | (Aupdate, Litv x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (Aupdate, [Loc lnum]) \\<Rightarrow> None\n   | (Aupdate, [Loc lnum, Litv (IntLit i)]) \\<Rightarrow> None\n   | (Aupdate, [Loc lnum, Litv (IntLit i), v2]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array xa) \\<Rightarrow> Map.empty xa\n       | Some (Varray vs) \\<Rightarrow>\n           if i < 0\n           then Some ((?s, ?t1.0), Rerr (Rraise (prim_exn ''Subscript'')))\n           else let n = nat \\<bar>i\\<bar>\n                in if length vs \\<le> n\n                   then Some\n                         ((?s, ?t1.0),\n                          Rerr (Rraise (prim_exn ''Subscript'')))\n                   else case store_assign lnum (Varray (vs[n := v2])) ?s of\n                        None \\<Rightarrow> None\n                        | Some s' \\<Rightarrow>\n                            Some ((s', ?t1.0), Rval (Conv None []))\n   | (Aupdate, Loc lnum # Litv (IntLit i) # v2 # aa # xa) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (Aupdate, Loc lnum # Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (Aupdate, Loc lnum # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aupdate, Loc lnum # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (Aupdate, Loc lnum # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (Aupdate, Loc lnum # Vectorv x # lista) \\<Rightarrow> Map.empty x\n   | (Aupdate, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, []) \\<Rightarrow> None\n   | (ConfigGC, [Litv (IntLit i)]) \\<Rightarrow> None\n   | (ConfigGC, [Litv (IntLit i), Litv (IntLit j)]) \\<Rightarrow>\n       Some ((?s, ?t1.0), Rval (Conv None []))\n   | (ConfigGC, Litv (IntLit i) # Litv (IntLit j) # a # x) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC, Litv (IntLit i) # Litv (lit.Char xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Litv (StrLit xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Litv (Word8 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Litv (Word64 xa) # lista) \\<Rightarrow>\n       Map.empty xa\n   | (ConfigGC, Litv (IntLit i) # Conv option x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC,\n      Litv (IntLit i) # Closure sem_env listb x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC,\n      Litv (IntLit i) # Recclosure sem_env list1 x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC, Litv (IntLit i) # Loc x # lista) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Litv (IntLit i) # Vectorv x # lista) \\<Rightarrow>\n       Map.empty x\n   | (ConfigGC, Litv (lit.Char xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Litv (StrLit xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Litv (Word8 xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Litv (Word64 xa) # list) \\<Rightarrow> Map.empty xa\n   | (ConfigGC, Conv option x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Closure sem_env listb x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Recclosure sem_env list1 x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Loc x # list) \\<Rightarrow> Map.empty x\n   | (ConfigGC, Vectorv x # list) \\<Rightarrow> Map.empty x\n   | (FFI n, []) \\<Rightarrow> None\n   | (FFI n, Litv (IntLit xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, Litv (lit.Char xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, [Litv (StrLit conf)]) \\<Rightarrow> None\n   | (FFI n, Litv (StrLit conf) # Litv x # listb) \\<Rightarrow> Map.empty x\n   | (FFI n, Litv (StrLit conf) # Conv option x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n,\n      Litv (StrLit conf) # Closure sem_env lista x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n,\n      Litv (StrLit conf) # Recclosure sem_env list1 x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n, [Litv (StrLit conf), Loc lnum]) \\<Rightarrow>\n       case store_lookup lnum ?s of None \\<Rightarrow> None\n       | Some (Refv xa) \\<Rightarrow> Map.empty xa\n       | Some (W8array ws) \\<Rightarrow>\n           case call_FFI ?t1.0 n\n                 (map (\\<lambda>c2. word_of_nat (of_char c2)) conf) ws of\n           (t', ws') \\<Rightarrow>\n             case store_assign lnum (W8array ws') ?s of\n             None \\<Rightarrow> None\n             | Some s' \\<Rightarrow> Some ((s', t'), Rval (Conv None []))\n       | Some (Varray xa) \\<Rightarrow> Map.empty xa\n   | (FFI n, Litv (StrLit conf) # Loc lnum # a # x) \\<Rightarrow>\n       Map.empty x\n   | (FFI n, Litv (StrLit conf) # Vectorv x # listb) \\<Rightarrow>\n       Map.empty x\n   | (FFI n, Litv (Word8 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, Litv (Word64 xa) # lista) \\<Rightarrow> Map.empty xa\n   | (FFI n, Conv option x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Closure sem_env listc x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Recclosure sem_env list1 x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Loc x # lista) \\<Rightarrow> Map.empty x\n   | (FFI n, Vectorv x # lista) \\<Rightarrow> Map.empty x)\n\ngoal (16 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env op1 es.\n       \\<lbrakk>evaluate_list True env st (rev es)\n                 (fun_evaluate st env (rev es));\n        \\<And>x y x1 x2 xa ya.\n           \\<lbrakk>(x, y) = fun_evaluate st env (rev es); y = Rval x1;\n            op1 = Opapp; do_opapp (rev x1) = Some x2; (xa, ya) = x2;\n            clock x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True xa (dec_clock x) [ya]\n                              (fun_evaluate (dec_clock x) xa [ya])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op1 es]\n                          (fun_evaluate st env [App op1 es])\n 8. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 9. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 10. \\<And>st env e pes.\n        \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                               (map_prod id (map_result hd id)\n                                 (fun_evaluate_match x env (hd x1) pes\n                                   Bindv))\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                           (fun_evaluate st env [Mat e pes])\nA total of 16 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env st [App op es] (fun_evaluate st env [App op es])", "apply (cases \"fun_evaluate st env (rev es)\" rule: prod_result_cases; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s v.\n       fun_evaluate st env (rev es) = (s, Rval v) \\<Longrightarrow>\n       (op = Opapp \\<longrightarrow>\n        evaluate_list True env st [App Opapp es]\n         (case do_opapp (rev v) of\n          None \\<Rightarrow> (s, Rerr (Rabort Rtype_error))\n          | Some (env', e) \\<Rightarrow>\n              if clock s = 0 then (s, Rerr (Rabort Rtimeout_error))\n              else fun_evaluate (dec_clock s) env' [e])) \\<and>\n       (op \\<noteq> Opapp \\<longrightarrow>\n        evaluate_list True env st [App op es]\n         (case do_app (refs s, ffi s) op (rev v) of\n          None \\<Rightarrow> (s, Rerr (Rabort Rtype_error))\n          | Some ((refs1, ffi1), r) \\<Rightarrow>\n              (update_ffi (\\<lambda>_. ffi1)\n                (update_refs (\\<lambda>_. refs1) s),\n               list_result r)))\n 2. \\<And>s err.\n       fun_evaluate st env (rev es) = (s, Rerr err) \\<Longrightarrow>\n       evaluate_list True env st [App op es] (s, Rerr err)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate st env (rev es) = (s_, Rval v_) \\<Longrightarrow>\n    (op = Opapp \\<longrightarrow>\n     evaluate_list True env st [App Opapp es]\n      (case do_opapp (rev v_) of\n       None \\<Rightarrow> (s_, Rerr (Rabort Rtype_error))\n       | Some (env', e) \\<Rightarrow>\n           if clock s_ = 0 then (s_, Rerr (Rabort Rtimeout_error))\n           else fun_evaluate (dec_clock s_) env' [e])) \\<and>\n    (op \\<noteq> Opapp \\<longrightarrow>\n     evaluate_list True env st [App op es]\n      (case do_app (refs s_, ffi s_) op (rev v_) of\n       None \\<Rightarrow> (s_, Rerr (Rabort Rtype_error))\n       | Some ((refs1, ffi1), r) \\<Rightarrow>\n           (update_ffi (\\<lambda>_. ffi1)\n             (update_refs (\\<lambda>_. refs1) s_),\n            list_result r)))", "apply (safe; simp split!: option.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_); op = Opapp;\n     do_opapp (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (s_, Rerr (Rabort Rtype_error))\n 2. \\<And>a b.\n       \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_); op = Opapp;\n        do_opapp (rev v_) = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> (clock s_ = 0 \\<longrightarrow>\n                          evaluate_list True env st [App Opapp es]\n                           (s_, Rerr (Rabort Rtimeout_error))) \\<and>\n                         (0 < clock s_ \\<longrightarrow>\n                          evaluate_list True env st [App Opapp es]\n                           (fun_evaluate (dec_clock s_) a [b]))\n 3. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp; do_app (refs s_, ffi s_) op (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App op es]\n                       (s_, Rerr (Rabort Rtype_error))\n 4. \\<And>a b ba.\n       \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n        op \\<noteq> Opapp;\n        do_app (refs s_, ffi s_) op (rev v_) = Some ((a, b), ba)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op es]\n                          (update_ffi (\\<lambda>_. b)\n                            (update_refs (\\<lambda>_. a) s_),\n                           list_result ba)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_); op = Opapp;\n     do_opapp (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (s_, Rerr (Rabort Rtype_error))", "using 9"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_); op = Opapp;\n     do_opapp (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (s_, Rerr (Rabort Rtype_error))", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_); op = Opapp;\n        do_opapp (rev v_) = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> (clock s_ = 0 \\<longrightarrow>\n                          evaluate_list True env st [App Opapp es]\n                           (s_, Rerr (Rabort Rtimeout_error))) \\<and>\n                         (0 < clock s_ \\<longrightarrow>\n                          evaluate_list True env st [App Opapp es]\n                           (fun_evaluate (dec_clock s_) a [b]))\n 2. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp; do_app (refs s_, ffi s_) op (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App op es]\n                       (s_, Rerr (Rabort Rtype_error))\n 3. \\<And>a b ba.\n       \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n        op \\<noteq> Opapp;\n        do_app (refs s_, ffi s_) op (rev v_) = Some ((a, b), ba)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op es]\n                          (update_ffi (\\<lambda>_. b)\n                            (update_refs (\\<lambda>_. a) s_),\n                           list_result ba)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. (clock s_ = 0 \\<longrightarrow>\n     evaluate_list True env st [App Opapp es]\n      (s_, Rerr (Rabort Rtimeout_error))) \\<and>\n    (0 < clock s_ \\<longrightarrow>\n     evaluate_list True env st [App Opapp es]\n      (fun_evaluate (dec_clock s_) a_ [b_]))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. clock s_ = 0 \\<longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (s_, Rerr (Rabort Rtimeout_error))\n 2. 0 < clock s_ \\<longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (fun_evaluate (dec_clock s_) a_ [b_])", "using 9 prems"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n  fun_evaluate st env (rev es) = (s_, Rval v_)\n  op = Opapp\n  do_opapp (rev v_) = Some (a_, b_)\n\ngoal (2 subgoals):\n 1. clock s_ = 0 \\<longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (s_, Rerr (Rabort Rtimeout_error))\n 2. 0 < clock s_ \\<longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (fun_evaluate (dec_clock s_) a_ [b_])", "apply (fastforce intro: evaluate_match_evaluate_list_evaluate.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < clock s_ \\<longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (fun_evaluate (dec_clock s_) a_ [b_])", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < clock s_ \\<Longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (fun_evaluate (dec_clock s_) a_ [b_])", "using 9(2)[OF prems(1)[symmetric] refl prems(2) prems(3) refl]"], ["proof (prove)\nusing this:\n  clock s_ \\<noteq> 0 \\<Longrightarrow>\n  evaluate_list True a_ (dec_clock s_) [b_]\n   (fun_evaluate (dec_clock s_) a_ [b_])\n\ngoal (1 subgoal):\n 1. 0 < clock s_ \\<Longrightarrow>\n    evaluate_list True env st [App Opapp es]\n     (fun_evaluate (dec_clock s_) a_ [b_])", "apply (cases rule: evaluate_list_singleton_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < clock s_ \\<Longrightarrow> clock s_ \\<noteq> 0\n 2. \\<And>s' v.\n       \\<lbrakk>0 < clock s_;\n        fun_evaluate (dec_clock s_) a_ [b_] = (s', Rval [v]);\n        evaluate True a_ (dec_clock s_) b_ (s', Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                          (fun_evaluate (dec_clock s_) a_ [b_])\n 3. \\<And>s' err.\n       \\<lbrakk>0 < clock s_;\n        fun_evaluate (dec_clock s_) a_ [b_] = (s', Rerr err);\n        evaluate True a_ (dec_clock s_) b_ (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                          (fun_evaluate (dec_clock s_) a_ [b_])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < clock s_ \\<Longrightarrow> clock s_ \\<noteq> 0", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s' v.\n       \\<lbrakk>0 < clock s_;\n        fun_evaluate (dec_clock s_) a_ [b_] = (s', Rval [v]);\n        evaluate True a_ (dec_clock s_) b_ (s', Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                          (fun_evaluate (dec_clock s_) a_ [b_])\n 2. \\<And>s' err.\n       \\<lbrakk>0 < clock s_;\n        fun_evaluate (dec_clock s_) a_ [b_] = (s', Rerr err);\n        evaluate True a_ (dec_clock s_) b_ (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                          (fun_evaluate (dec_clock s_) a_ [b_])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rval [v_]);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (fun_evaluate (dec_clock s_) a_ [b_])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rval [v_]);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (s'_, Rval [v_])", "apply (rule evaluate_match_evaluate_list_evaluate.cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rval [v_]);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (App Opapp es)\n                       (?s2.1, Rval v_) \\<and>\n                      evaluate_list True env ?s2.1 [] (s'_, Rval [])", "using 9 prems"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n  fun_evaluate st env (rev es) = (s_, Rval va___)\n  op = Opapp\n  do_opapp (rev va___) = Some (a_, b_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rval [v_]);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rval v_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (App Opapp es)\n                       (?s2.1, Rval v_) \\<and>\n                      evaluate_list True env ?s2.1 [] (s'_, Rval [])", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros simp: dec_clock_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' err.\n       \\<lbrakk>0 < clock s_;\n        fun_evaluate (dec_clock s_) a_ [b_] = (s', Rerr err);\n        evaluate True a_ (dec_clock s_) b_ (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                          (fun_evaluate (dec_clock s_) a_ [b_])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rerr err_);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (fun_evaluate (dec_clock s_) a_ [b_])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rerr err_);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App Opapp es]\n                       (s'_, Rerr err_)", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rerr err_);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (App Opapp es) (s'_, Rerr err_)", "using 9 prems"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n  fun_evaluate st env (rev es) = (s_, Rval v_)\n  op = Opapp\n  do_opapp (rev v_) = Some (a_, b_)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < clock s_;\n     fun_evaluate (dec_clock s_) a_ [b_] = (s'_, Rerr err_);\n     evaluate True a_ (dec_clock s_) b_ (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (App Opapp es) (s'_, Rerr err_)", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros simp: dec_clock_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp; do_app (refs s_, ffi s_) op (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App op es]\n                       (s_, Rerr (Rabort Rtype_error))\n 2. \\<And>a b ba.\n       \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n        op \\<noteq> Opapp;\n        do_app (refs s_, ffi s_) op (rev v_) = Some ((a, b), ba)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op es]\n                          (update_ffi (\\<lambda>_. b)\n                            (update_refs (\\<lambda>_. a) s_),\n                           list_result ba)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp; do_app (refs s_, ffi s_) op (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App op es]\n                       (s_, Rerr (Rabort Rtype_error))", "using 9"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp; do_app (refs s_, ffi s_) op (rev v_) = None\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App op es]\n                       (s_, Rerr (Rabort Rtype_error))", "by (auto intro: evaluate_match_evaluate_list_evaluate.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n        op \\<noteq> Opapp;\n        do_app (refs s_, ffi s_) op (rev v_) = Some ((a, b), ba)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [App op es]\n                          (update_ffi (\\<lambda>_. b)\n                            (update_refs (\\<lambda>_. a) s_),\n                           list_result ba)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [App op es]\n                       (update_ffi (\\<lambda>_. b_)\n                         (update_refs (\\<lambda>_. a_) s_),\n                        list_result ba_)", "apply (rule evaluate_list_singletonI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (App op es)\n                       (update_ffi (\\<lambda>_. b_)\n                         (update_refs (\\<lambda>_. a_) s_),\n                        ba_)", "apply (rule app4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st (rev es)\n                       (s_, Rval ?vs2) \\<and>\n                      do_app (refs s_, ffi s_) op (rev ?vs2) =\n                      Some ((a_, b_), ba_) \\<and>\n                      op \\<noteq> Opapp", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st (rev es) (s_, Rval ?vs2)\n 2. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> do_app (refs s_, ffi s_) op (rev ?vs2) =\n                      Some ((a_, b_), ba_)\n 3. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> op \\<noteq> Opapp", "using 9"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env (rev es); ?y = Rval ?x1.0;\n   op = Opapp; do_opapp (rev ?x1.0) = Some ?x2.0; (?xa, ?ya) = ?x2.0;\n   clock ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True ?xa (dec_clock ?x) [?ya]\n                     (fun_evaluate (dec_clock ?x) ?xa [?ya])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st (rev es) (s_, Rval ?vs2)\n 2. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> do_app (refs s_, ffi s_) op (rev ?vs2) =\n                      Some ((a_, b_), ba_)\n 3. \\<lbrakk>fun_evaluate st env (rev es) = (s_, Rval v_);\n     op \\<noteq> Opapp;\n     do_app (refs s_, ffi s_) op (rev v_) = Some ((a_, b_), ba_)\\<rbrakk>\n    \\<Longrightarrow> op \\<noteq> Opapp", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s err.\n       fun_evaluate st env (rev es) = (s, Rerr err) \\<Longrightarrow>\n       evaluate_list True env st [App op es] (s, Rerr err)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate st env (rev es) = (s_, Rerr err_) \\<Longrightarrow>\n    evaluate_list True env st [App op es] (s_, Rerr err_)", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate st env (rev es) = (s_, Rerr err_) \\<Longrightarrow>\n    evaluate True env st (App op es) (s_, Rerr err_)", "apply (rule app6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate st env (rev es) = (s_, Rerr err_) \\<Longrightarrow>\n    evaluate_list True env st (rev es) (s_, Rerr err_)", "using 9(1)"], ["proof (prove)\nusing this:\n  evaluate_list True env st (rev es) (fun_evaluate st env (rev es))\n\ngoal (1 subgoal):\n 1. fun_evaluate st env (rev es) = (s_, Rerr err_) \\<Longrightarrow>\n    evaluate_list True env st (rev es) (s_, Rerr err_)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_list True env st [App op es] (fun_evaluate st env [App op es])\n\ngoal (15 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env e pes.\n       \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                              (map_prod id (map_result hd id)\n                                (fun_evaluate_match x env (hd x1) pes\n                                  Bindv))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                          (fun_evaluate st env [Mat e pes])\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsOptBind xo (hd x1) (sem_env.v env))\n                                 env)\n                               x [e2]\n                               (fun_evaluate x\n                                 (update_v\n                                   (\\<lambda>_.\n nsOptBind xo (hd x1) (sem_env.v env))\n                                   env)\n                                 [e2])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                           (fun_evaluate st env [exp0.Let xo e1 e2])\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env e pes.\n       \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                              (map_prod id (map_result hd id)\n                                (fun_evaluate_match x env (hd x1) pes\n                                  Bindv))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                          (fun_evaluate st env [Mat e pes])\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsOptBind xo (hd x1) (sem_env.v env))\n                                 env)\n                               x [e2]\n                               (fun_evaluate x\n                                 (update_v\n                                   (\\<lambda>_.\n nsOptBind xo (hd x1) (sem_env.v env))\n                                   env)\n                                 [e2])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                           (fun_evaluate st env [exp0.Let xo e1 e2])\nA total of 15 subgoals...", "case (12 st env e pes)"], ["proof (state)\nthis:\n  evaluate_list True env st [e] (fun_evaluate st env [e])\n  \\<lbrakk>(?x, ?y) = fun_evaluate st env [e]; ?y = Rval ?x1.0\\<rbrakk>\n  \\<Longrightarrow> evaluate_match True env ?x (hd ?x1.0) pes Bindv\n                     (map_prod id (map_result hd id)\n                       (fun_evaluate_match ?x env (hd ?x1.0) pes Bindv))\n\ngoal (15 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env e pes.\n       \\<lbrakk>evaluate_list True env st [e] (fun_evaluate st env [e]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_match True env x (hd x1) pes Bindv\n                              (map_prod id (map_result hd id)\n                                (fun_evaluate_match x env (hd x1) pes\n                                  Bindv))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                          (fun_evaluate st env [Mat e pes])\n 10. \\<And>st env xo e1 e2.\n        \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n         \\<And>x y x1.\n            \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n            \\<Longrightarrow> evaluate_list True\n                               (update_v\n                                 (\\<lambda>_.\n                                     nsOptBind xo (hd x1) (sem_env.v env))\n                                 env)\n                               x [e2]\n                               (fun_evaluate x\n                                 (update_v\n                                   (\\<lambda>_.\n nsOptBind xo (hd x1) (sem_env.v env))\n                                   env)\n                                 [e2])\\<rbrakk>\n        \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                           (fun_evaluate st env [exp0.Let xo e1 e2])\nA total of 15 subgoals...", "from 12(1)"], ["proof (chain)\npicking this:\n  evaluate_list True env st [e] (fun_evaluate st env [e])", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_list True env st [e] (fun_evaluate st env [e])\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Mat e pes] (fun_evaluate st env [Mat e pes])", "apply (rule evaluate_list_singleton_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s' v.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n        evaluate True env st e (s', Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                          (fun_evaluate st env [Mat e pes])\n 2. \\<And>s' err.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr err);\n        evaluate True env st e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                          (fun_evaluate st env [Mat e pes])", "subgoal for s' v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n     evaluate True env st e (s', Rval v)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                       (fun_evaluate st env [Mat e pes])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n     evaluate True env st e (s', Rval v)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                       (fun_evaluate_match s' env v pes Bindv)", "apply (cases \"fun_evaluate_match s' env v pes Bindv\" rule: prod_result_cases; simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s v.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n        evaluate True env st e (s', Rval v);\n        fun_evaluate_match s' env v pes Bindv = (s, Rval v)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes] (s, Rval v)\n 2. \\<And>s err.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n        evaluate True env st e (s', Rval v);\n        fun_evaluate_match s' env v pes Bindv = (s, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes] (s, Rerr err)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env st [Mat e pes] (s_, Rval v_)", "using prems(3)"], ["proof (prove)\nusing this:\n  fun_evaluate_match s' env v pes Bindv = (s_, Rval v_)\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Mat e pes] (s_, Rval v_)", "apply (rule fun_evaluate_matchE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env st [Mat e pes] (s_, Rval v_)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env st [Mat e pes] (s_, Rval [v])", "apply (rule evaluate_match_evaluate_list_evaluate.cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st (Mat e pes) (?s2.2 v, Rval v) \\<and>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st (Mat e pes) (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (rule mat1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st e (?s2.5 v, Rval (?v1.5 v)) \\<and>\n       evaluate_match True env (?s2.5 v) (?v1.5 v) pes\n        (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) [])\n        (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (fold Bindv_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st e (?s2.5 v, Rval (?v1.5 v)) \\<and>\n       evaluate_match True env (?s2.5 v) (?v1.5 v) pes Bindv\n        (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate True env st e (?s2.5 v, Rval (?v1.5 v))\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env (?s2.5 v) (?v1.5 v) pes Bindv\n        (?s2.2 v, Rval v)\n 3. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply (rule prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env s' v pes Bindv (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "supply error_result.map_ident[simp]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env s' v pes Bindv (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "using 12(2)[OF prems(1)[symmetric] refl, simplified, unfolded prems(3), simplified]"], ["proof (prove)\nusing this:\n  evaluate_match True env s' v pes Bindv (s_, Rval (hd v_))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_match True env s' v pes Bindv (?s2.2 v, Rval v)\n 2. \\<And>v.\n       v_ = [v] \\<Longrightarrow>\n       evaluate_list True env (?s2.2 v) [] (s_, Rval [])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v_ = [v] \\<Longrightarrow> evaluate_list True env s_ [] (s_, Rval [])", "by (rule evaluate_match_evaluate_list_evaluate.empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s err.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rval [v]);\n        evaluate True env st e (s', Rval v);\n        fun_evaluate_match s' env v pes Bindv = (s, Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes] (s, Rerr err)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env st [Mat e pes] (s_, Rerr err_)", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st (Mat e pes) (s_, Rerr err_)", "apply (rule mat1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (?s2.2, Rval ?v1.2) \\<and>\n    evaluate_match True env ?s2.2 ?v1.2 pes\n     (Conv (Some (''Bind'', TypeExn (Short ''Bind''))) []) (s_, Rerr err_)", "apply (fold Bindv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate True env st e (?s2.2, Rval ?v1.2) \\<and>\n    evaluate_match True env ?s2.2 ?v1.2 pes Bindv (s_, Rerr err_)", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate True env st e (?s2.2, Rval ?v1.2)\n 2. evaluate_match True env ?s2.2 ?v1.2 pes Bindv (s_, Rerr err_)", "apply (rule prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env s' v pes Bindv (s_, Rerr err_)", "supply error_result.map_ident[simp]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env s' v pes Bindv (s_, Rerr err_)", "using 12(2)[OF prems(1)[symmetric] refl, simplified, unfolded prems(3), simplified]"], ["proof (prove)\nusing this:\n  evaluate_match True env s' v pes Bindv (s_, Rerr err_)\n\ngoal (1 subgoal):\n 1. evaluate_match True env s' v pes Bindv (s_, Rerr err_)", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' err.\n       \\<lbrakk>fun_evaluate st env [e] = (s', Rerr err);\n        evaluate True env st e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                          (fun_evaluate st env [Mat e pes])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rerr err_);\n     evaluate True env st e (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Mat e pes]\n                       (fun_evaluate st env [Mat e pes])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rerr err_);\n     evaluate True env st e (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate_list True env st [Mat e pes] (s'_, Rerr err_)", "apply (rule evaluate_match_evaluate_list_evaluate.cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rerr err_);\n     evaluate True env st e (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st (Mat e pes) (s'_, Rerr err_)", "apply (rule mat2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_evaluate st env [e] = (s'_, Rerr err_);\n     evaluate True env st e (s'_, Rerr err_)\\<rbrakk>\n    \\<Longrightarrow> evaluate True env st e (s'_, Rerr err_)", "by assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_list True env st [Mat e pes] (fun_evaluate st env [Mat e pes])\n\ngoal (14 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         evaluate_list True\n          (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n            env)\n          st [e]\n          (fun_evaluate st\n            (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n              env)\n            [e])) \\<Longrightarrow>\n        evaluate_list True env st [Letrec funs e]\n         (fun_evaluate st env [Letrec funs e])\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         evaluate_list True\n          (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n            env)\n          st [e]\n          (fun_evaluate st\n            (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n              env)\n            [e])) \\<Longrightarrow>\n        evaluate_list True env st [Letrec funs e]\n         (fun_evaluate st env [Letrec funs e])\nA total of 14 subgoals...", "case (14 st env funs e)"], ["proof (state)\nthis:\n  allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n  evaluate_list True\n   (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) st\n   [e]\n   (fun_evaluate st\n     (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n     [e])\n\ngoal (14 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env funs e.\n        (allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n         evaluate_list True\n          (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n            env)\n          st [e]\n          (fun_evaluate st\n            (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env))\n              env)\n            [e])) \\<Longrightarrow>\n        evaluate_list True env st [Letrec funs e]\n         (fun_evaluate st env [Letrec funs e])\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n  evaluate_list True\n   (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) st\n   [e]\n   (fun_evaluate st\n     (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n     [e])", "show ?case"], ["proof (prove)\nusing this:\n  allDistinct (map (\\<lambda>(x, y, z). x) funs) \\<Longrightarrow>\n  evaluate_list True\n   (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env) st\n   [e]\n   (fun_evaluate st\n     (update_v (\\<lambda>_. build_rec_env funs env (sem_env.v env)) env)\n     [e])\n\ngoal (1 subgoal):\n 1. evaluate_list True env st [Letrec funs e]\n     (fun_evaluate st env [Letrec funs e])", "by (cases \"allDistinct (map (\\<lambda>(x, y, z). x) funs)\")\n       (fastforce intro: evaluate_match_evaluate_list_evaluate.intros elim: evaluate_list_singleton_cases)+"], ["proof (state)\nthis:\n  evaluate_list True env st [Letrec funs e]\n   (fun_evaluate st env [Letrec funs e])\n\ngoal (13 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env e t1.\n        evaluate_list True env st [e]\n         (fun_evaluate st env [e]) \\<Longrightarrow>\n        evaluate_list True env st [Tannot e t1]\n         (fun_evaluate st env [Tannot e t1])\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env e t1.\n        evaluate_list True env st [e]\n         (fun_evaluate st env [e]) \\<Longrightarrow>\n        evaluate_list True env st [Tannot e t1]\n         (fun_evaluate st env [Tannot e t1])\nA total of 13 subgoals...", "case (18 st env v2 p e pes err_v)"], ["proof (state)\nthis:\n  \\<lbrakk>allDistinct (pat_bindings p []);\n   pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n  \\<Longrightarrow> evaluate_match True env st v2 pes err_v\n                     (map_prod id (map_result hd id)\n                       (fun_evaluate_match st env v2 pes err_v))\n  \\<lbrakk>allDistinct (pat_bindings p []);\n   pmatch (c env) (refs st) p v2 [] = Match ?x3.0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns ?x3.0) (sem_env.v env))\n                       env)\n                     st [e]\n                     (fun_evaluate st\n                       (update_v\n                         (\\<lambda>_.\n                             nsAppend (alist_to_ns ?x3.0) (sem_env.v env))\n                         env)\n                       [e])\n\ngoal (13 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env e t1.\n        evaluate_list True env st [e]\n         (fun_evaluate st env [e]) \\<Longrightarrow>\n        evaluate_list True env st [Tannot e t1]\n         (fun_evaluate st env [Tannot e t1])\nA total of 13 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "proof (cases \"allDistinct (pat_bindings p [])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "case True"], ["proof (state)\nthis:\n  allDistinct (pat_bindings p [])\n\ngoal (2 subgoals):\n 1. allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "proof (cases \"pmatch (c env) (refs st) p v2 []\")"], ["proof (state)\ngoal (3 subgoals):\n 1. pmatch (c env) (refs st) p v2 [] = No_match \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. pmatch (c env) (refs st) p v2 [] = Match_type_error \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 3. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "case No_match"], ["proof (state)\nthis:\n  pmatch (c env) (refs st) p v2 [] = No_match\n\ngoal (3 subgoals):\n 1. pmatch (c env) (refs st) p v2 [] = No_match \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. pmatch (c env) (refs st) p v2 [] = Match_type_error \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 3. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "with True"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p [])\n  pmatch (c env) (refs st) p v2 [] = No_match", "show ?thesis"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p [])\n  pmatch (c env) (refs st) p v2 [] = No_match\n\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "apply (simp del: id_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> evaluate_match True env st v2 ((p, e) # pes) err_v\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate_match st env v2 pes err_v))", "apply (rule mat_cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> allDistinct (pat_bindings p []) \\<and>\n                      pmatch (c env) (refs st) p v2 [] = No_match \\<and>\n                      evaluate_match True env st v2 pes err_v\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate_match st env v2 pes err_v))", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> allDistinct (pat_bindings p [])\n 2. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> pmatch (c env) (refs st) p v2 [] = No_match\n 3. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> evaluate_match True env st v2 pes err_v\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate_match st env v2 pes err_v))", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> evaluate_match True env st v2 pes err_v\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate_match st env v2 pes err_v))", "apply (rule 18)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> allDistinct (pat_bindings p [])\n 2. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> pmatch (c env) (refs st) p v2 [] = No_match", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_match True env st v2 ((p, e) # pes) err_v\n   (map_prod id (map_result hd id)\n     (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n\ngoal (2 subgoals):\n 1. pmatch (c env) (refs st) p v2 [] = Match_type_error \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. pmatch (c env) (refs st) p v2 [] = Match_type_error \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "case Match_type_error"], ["proof (state)\nthis:\n  pmatch (c env) (refs st) p v2 [] = Match_type_error\n\ngoal (2 subgoals):\n 1. pmatch (c env) (refs st) p v2 [] = Match_type_error \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n 2. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "with True"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p [])\n  pmatch (c env) (refs st) p v2 [] = Match_type_error", "show ?thesis"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p [])\n  pmatch (c env) (refs st) p v2 [] = Match_type_error\n\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> evaluate_match True env st v2 ((p, e) # pes) err_v\n                       (st, Rerr (Rabort Rtype_error))", "apply (rule mat_cons3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> pmatch (c env) (refs st) p v2 [] = Match_type_error", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_match True env st v2 ((p, e) # pes) err_v\n   (map_prod id (map_result hd id)\n     (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "case Match"], ["proof (state)\nthis:\n  pmatch (c env) (refs st) p v2 [] = Match x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       pmatch (c env) (refs st) p v2 [] = Match x3 \\<Longrightarrow>\n       evaluate_match True env st v2 ((p, e) # pes) err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "with True"], ["proof (chain)\npicking this:\n  allDistinct (pat_bindings p [])\n  pmatch (c env) (refs st) p v2 [] = Match x3_", "show ?thesis"], ["proof (prove)\nusing this:\n  allDistinct (pat_bindings p [])\n  pmatch (c env) (refs st) p v2 [] = Match x3_\n\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "apply (simp del: id_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> evaluate_match True env st v2 ((p, e) # pes) err_v\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate st\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns x3_) (sem_env.v env))\n                             env)\n                           [e]))", "apply (rule mat_cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> allDistinct (pat_bindings p []) \\<and>\n                      pmatch (c env) (refs st) p v2 [] = Match ?env'3 \\<and>\n                      evaluate True\n                       (update_v\n                         (\\<lambda>_.\n                             nsAppend (alist_to_ns ?env'3) (sem_env.v env))\n                         env)\n                       st e\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate st\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns x3_) (sem_env.v env))\n                             env)\n                           [e]))", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> allDistinct (pat_bindings p [])\n 2. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> pmatch (c env) (refs st) p v2 [] = Match ?env'3\n 3. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> evaluate True\n                       (update_v\n                         (\\<lambda>_.\n                             nsAppend (alist_to_ns ?env'3) (sem_env.v env))\n                         env)\n                       st e\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate st\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns x3_) (sem_env.v env))\n                             env)\n                           [e]))", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> evaluate True\n                       (update_v\n                         (\\<lambda>_.\n                             nsAppend (alist_to_ns x3_) (sem_env.v env))\n                         env)\n                       st e\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate st\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns x3_) (sem_env.v env))\n                             env)\n                           [e]))", "using 18(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>allDistinct (pat_bindings p []);\n   pmatch (c env) (refs st) p v2 [] = Match ?x3.0\\<rbrakk>\n  \\<Longrightarrow> evaluate_list True\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns ?x3.0) (sem_env.v env))\n                       env)\n                     st [e]\n                     (fun_evaluate st\n                       (update_v\n                         (\\<lambda>_.\n                             nsAppend (alist_to_ns ?x3.0) (sem_env.v env))\n                         env)\n                       [e])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> evaluate True\n                       (update_v\n                         (\\<lambda>_.\n                             nsAppend (alist_to_ns x3_) (sem_env.v env))\n                         env)\n                       st e\n                       (map_prod id (map_result hd id)\n                         (fun_evaluate st\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns x3_) (sem_env.v env))\n                             env)\n                           [e]))", "apply (rule evaluate_list_singleton_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> allDistinct (pat_bindings p [])\n 2. \\<lbrakk>allDistinct (pat_bindings p []);\n     pmatch (c env) (refs st) p v2 [] = Match x3_\\<rbrakk>\n    \\<Longrightarrow> pmatch (c env) (refs st) p v2 [] = Match ?x3.8\n 3. \\<And>s' va.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        pmatch (c env) (refs st) p v2 [] = Match x3_;\n        fun_evaluate st\n         (update_v\n           (\\<lambda>_. nsAppend (alist_to_ns ?x3.8) (sem_env.v env)) env)\n         [e] =\n        (s', Rval [va]);\n        evaluate True\n         (update_v\n           (\\<lambda>_. nsAppend (alist_to_ns ?x3.8) (sem_env.v env)) env)\n         st e (s', Rval va)\\<rbrakk>\n       \\<Longrightarrow> evaluate True\n                          (update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns x3_) (sem_env.v env))\n                            env)\n                          st e\n                          (map_prod id (map_result hd id)\n                            (fun_evaluate st\n                              (update_v\n                                (\\<lambda>_.\n                                    nsAppend (alist_to_ns x3_)\n                                     (sem_env.v env))\n                                env)\n                              [e]))\n 4. \\<And>s' err.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        pmatch (c env) (refs st) p v2 [] = Match x3_;\n        fun_evaluate st\n         (update_v\n           (\\<lambda>_. nsAppend (alist_to_ns ?x3.8) (sem_env.v env)) env)\n         [e] =\n        (s', Rerr err);\n        evaluate True\n         (update_v\n           (\\<lambda>_. nsAppend (alist_to_ns ?x3.8) (sem_env.v env)) env)\n         st e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate True\n                          (update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns x3_) (sem_env.v env))\n                            env)\n                          st e\n                          (map_prod id (map_result hd id)\n                            (fun_evaluate st\n                              (update_v\n                                (\\<lambda>_.\n                                    nsAppend (alist_to_ns x3_)\n                                     (sem_env.v env))\n                                env)\n                              [e]))", "apply assumption+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s' va.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        pmatch (c env) (refs st) p v2 [] = Match x3_;\n        fun_evaluate st\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns x3_) (sem_env.v env))\n           env)\n         [e] =\n        (s', Rval [va]);\n        evaluate True\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns x3_) (sem_env.v env))\n           env)\n         st e (s', Rval va)\\<rbrakk>\n       \\<Longrightarrow> evaluate True\n                          (update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns x3_) (sem_env.v env))\n                            env)\n                          st e\n                          (map_prod id (map_result hd id)\n                            (fun_evaluate st\n                              (update_v\n                                (\\<lambda>_.\n                                    nsAppend (alist_to_ns x3_)\n                                     (sem_env.v env))\n                                env)\n                              [e]))\n 2. \\<And>s' err.\n       \\<lbrakk>allDistinct (pat_bindings p []);\n        pmatch (c env) (refs st) p v2 [] = Match x3_;\n        fun_evaluate st\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns x3_) (sem_env.v env))\n           env)\n         [e] =\n        (s', Rerr err);\n        evaluate True\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns x3_) (sem_env.v env))\n           env)\n         st e (s', Rerr err)\\<rbrakk>\n       \\<Longrightarrow> evaluate True\n                          (update_v\n                            (\\<lambda>_.\n                                nsAppend (alist_to_ns x3_) (sem_env.v env))\n                            env)\n                          st e\n                          (map_prod id (map_result hd id)\n                            (fun_evaluate st\n                              (update_v\n                                (\\<lambda>_.\n                                    nsAppend (alist_to_ns x3_)\n                                     (sem_env.v env))\n                                env)\n                              [e]))", "apply (auto simp: error_result.map_ident)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evaluate_match True env st v2 ((p, e) # pes) err_v\n   (map_prod id (map_result hd id)\n     (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_match True env st v2 ((p, e) # pes) err_v\n   (map_prod id (map_result hd id)\n     (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n\ngoal (1 subgoal):\n 1. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "case False"], ["proof (state)\nthis:\n  \\<not> allDistinct (pat_bindings p [])\n\ngoal (1 subgoal):\n 1. \\<not> allDistinct (pat_bindings p []) \\<Longrightarrow>\n    evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "using False"], ["proof (prove)\nusing this:\n  \\<not> allDistinct (pat_bindings p [])\n\ngoal (1 subgoal):\n 1. evaluate_match True env st v2 ((p, e) # pes) err_v\n     (map_prod id (map_result hd id)\n       (fun_evaluate_match st env v2 ((p, e) # pes) err_v))", "by (auto intro: mat_cons4)"], ["proof (state)\nthis:\n  evaluate_match True env st v2 ((p, e) # pes) err_v\n   (map_prod id (map_result hd id)\n     (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_match True env st v2 ((p, e) # pes) err_v\n   (map_prod id (map_result hd id)\n     (fun_evaluate_match st env v2 ((p, e) # pes) err_v))\n\ngoal (12 subgoals):\n 1. \\<And>st env. evaluate_list True env st [] (fun_evaluate st env [])\n 2. \\<And>st env e1 e2 es.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x (e2 # es)\n                              (fun_evaluate x env (e2 # es))\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st (e1 # e2 # es)\n                          (fun_evaluate st env (e1 # e2 # es))\n 3. \\<And>st env l.\n       evaluate_list True env st [Lit l] (fun_evaluate st env [Lit l])\n 4. \\<And>st env e.\n       evaluate_list True env st [e]\n        (fun_evaluate st env [e]) \\<Longrightarrow>\n       evaluate_list True env st [Raise e] (fun_evaluate st env [Raise e])\n 5. \\<And>st env n.\n       evaluate_list True env st [Var n] (fun_evaluate st env [Var n])\n 6. \\<And>st env x e.\n       evaluate_list True env st [Fun x e] (fun_evaluate st env [Fun x e])\n 7. \\<And>st env lop e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2 x1a.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_log lop (hd x1) e2 = Some x2; x2 = Exp x1a\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x1a]\n                              (fun_evaluate x env [x1a])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [Log lop e1 e2]\n                          (fun_evaluate st env [Log lop e1 e2])\n 8. \\<And>st env e1 e2 e3.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1 x2.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1;\n            do_if (hd x1) e2 e3 = Some x2\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True env x [x2]\n                              (fun_evaluate x env [x2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.If e1 e2 e3]\n                          (fun_evaluate st env [exp0.If e1 e2 e3])\n 9. \\<And>st env xo e1 e2.\n       \\<lbrakk>evaluate_list True env st [e1] (fun_evaluate st env [e1]);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = fun_evaluate st env [e1]; y = Rval x1\\<rbrakk>\n           \\<Longrightarrow> evaluate_list True\n                              (update_v\n                                (\\<lambda>_.\n                                    nsOptBind xo (hd x1) (sem_env.v env))\n                                env)\n                              x [e2]\n                              (fun_evaluate x\n                                (update_v\n                                  (\\<lambda>_.\nnsOptBind xo (hd x1) (sem_env.v env))\n                                  env)\n                                [e2])\\<rbrakk>\n       \\<Longrightarrow> evaluate_list True env st [exp0.Let xo e1 e2]\n                          (fun_evaluate st env [exp0.Let xo e1 e2])\n 10. \\<And>st env e t1.\n        evaluate_list True env st [e]\n         (fun_evaluate st env [e]) \\<Longrightarrow>\n        evaluate_list True env st [Tannot e t1]\n         (fun_evaluate st env [Tannot e t1])\nA total of 12 subgoals...", "qed (fastforce\n      intro: evaluate_match_evaluate_list_evaluate.intros\n      elim: evaluate_list_singleton_cases\n      split: option.splits prod.splits result.splits if_splits exp_or_val.splits)+"], ["", "global_interpretation \"fun\": eval\n  \"\\<lambda>env e s. map_prod id (map_result hd id) (fun_evaluate s env [e])\"\n  \"\\<lambda>env es s. fun_evaluate s env es\"\n  \"\\<lambda>env v pes err_v s. map_prod id (map_result hd id) (fun_evaluate_match s env v pes err_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (\\<lambda>env e s.\n         map_prod id (map_result hd id) (fun_evaluate s env [e]))\n     (\\<lambda>env es s. fun_evaluate s env es)\n     (\\<lambda>env v pes err_v s.\n         map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>env s e.\n       evaluate True env s e\n        (map_prod id (map_result hd id) (fun_evaluate s env [e]))\n 2. \\<And>env s es. evaluate_list True env s es (fun_evaluate s env es)\n 3. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "case (1 env s e)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>env s e.\n       evaluate True env s e\n        (map_prod id (map_result hd id) (fun_evaluate s env [e]))\n 2. \\<And>env s es. evaluate_list True env s es (fun_evaluate s env es)\n 3. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "have \"evaluate_list True env s [e] (fun_evaluate s env [e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env s [e] (fun_evaluate s env [e])", "by (metis fun_evaluate)"], ["proof (state)\nthis:\n  evaluate_list True env s [e] (fun_evaluate s env [e])\n\ngoal (3 subgoals):\n 1. \\<And>env s e.\n       evaluate True env s e\n        (map_prod id (map_result hd id) (fun_evaluate s env [e]))\n 2. \\<And>env s es. evaluate_list True env s es (fun_evaluate s env es)\n 3. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "then"], ["proof (chain)\npicking this:\n  evaluate_list True env s [e] (fun_evaluate s env [e])", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_list True env s [e] (fun_evaluate s env [e])\n\ngoal (1 subgoal):\n 1. evaluate True env s e\n     (map_prod id (map_result hd id) (fun_evaluate s env [e]))", "by (rule evaluate_list_singleton_cases) (auto simp: error_result.map_id)"], ["proof (state)\nthis:\n  evaluate True env s e\n   (map_prod id (map_result hd id) (fun_evaluate s env [e]))\n\ngoal (2 subgoals):\n 1. \\<And>env s es. evaluate_list True env s es (fun_evaluate s env es)\n 2. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>env s es. evaluate_list True env s es (fun_evaluate s env es)\n 2. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "case (2 env s es)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>env s es. evaluate_list True env s es (fun_evaluate s env es)\n 2. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_list True env s es (fun_evaluate s env es)", "by (rule fun_evaluate)"], ["proof (state)\nthis:\n  evaluate_list True env s es (fun_evaluate s env es)\n\ngoal (1 subgoal):\n 1. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "case (3 env s v pes err_v)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>env s v pes err_v.\n       evaluate_match True env s v pes err_v\n        (map_prod id (map_result hd id)\n          (fun_evaluate_match s env v pes err_v))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_match True env s v pes err_v\n     (map_prod id (map_result hd id) (fun_evaluate_match s env v pes err_v))", "by (rule fun_evaluate)"], ["proof (state)\nthis:\n  evaluate_match True env s v pes err_v\n   (map_prod id (map_result hd id) (fun_evaluate_match s env v pes err_v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas big_fun_equivalence =\n  fun.other_eval_eq[OF run.eval_axioms]\n\\<comment> \\<open>@{thm [display] big_fun_equivalence}\\<close>"], ["", "end"]]}