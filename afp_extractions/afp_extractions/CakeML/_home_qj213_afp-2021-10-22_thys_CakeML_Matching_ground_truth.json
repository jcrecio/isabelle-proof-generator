{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML/Matching.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML", "problem_names": ["lemma fold2_cong[fundef_cong]:\n  assumes \"init1 = init2\" \"err1 = err2\" \"xs1 = xs2\" \"ys1 = ys2\"\n  assumes \"\\<And>init x y. x \\<in> set xs1 \\<Longrightarrow> y \\<in> set ys1 \\<Longrightarrow> f x y init = g x y init\"\n  shows \"fold2 f err1 xs1 ys1 init1 = fold2 g err2 xs2 ys2 init2\"", "lemma pmatch_list_length_neq:\n  \"length vs \\<noteq> length ps \\<Longrightarrow> fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs m = Match_type_error\"", "lemma pmatch_list_nomatch:\n  \"length vs = length ps \\<Longrightarrow> fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs No_match = No_match\"", "lemma pmatch_list_typerr:\n  \"length vs = length ps \\<Longrightarrow> fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs Match_type_error = Match_type_error\"", "lemma pmatch_single_eq0:\n  \"length ps = length vs \\<Longrightarrow> pmatch_list cenv s ps vs env = fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs (Match env)\"\n  \"pmatch cenv s p v0 env = pmatch_single cenv s p v0 env\"", "lemma pmatch_single_equiv: \"pmatch = pmatch_single\""], "translations": [["", "lemma fold2_cong[fundef_cong]:\n  assumes \"init1 = init2\" \"err1 = err2\" \"xs1 = xs2\" \"ys1 = ys2\"\n  assumes \"\\<And>init x y. x \\<in> set xs1 \\<Longrightarrow> y \\<in> set ys1 \\<Longrightarrow> f x y init = g x y init\"\n  shows \"fold2 f err1 xs1 ys1 init1 = fold2 g err2 xs2 ys2 init2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold2 f err1 xs1 ys1 init1 = fold2 g err2 xs2 ys2 init2", "using assms"], ["proof (prove)\nusing this:\n  init1 = init2\n  err1 = err2\n  xs1 = xs2\n  ys1 = ys2\n  \\<lbrakk>?x \\<in> set xs1; ?y \\<in> set ys1\\<rbrakk>\n  \\<Longrightarrow> f ?x ?y ?init = g ?x ?y ?init\n\ngoal (1 subgoal):\n 1. fold2 f err1 xs1 ys1 init1 = fold2 g err2 xs2 ys2 init2", "by (induction f err1 xs1 ys1 init1 arbitrary: init2 xs2 ys2 rule: fold2.induct) auto"], ["", "fun pmatch_single :: \"((string),(string),(nat*tid_or_exn))namespace \\<Rightarrow>((v)store_v)list \\<Rightarrow> pat \\<Rightarrow> v \\<Rightarrow>(string*v)list \\<Rightarrow>((string*v)list)match_result \" where\n\"pmatch_single envC s Pany v' env = ( Match env )\" |\n\"pmatch_single envC s (Pvar x) v' env = ( Match ((x,v')# env))\" |\n\"pmatch_single envC s (Plit l) (Litv l') env = (\n  if l = l' then\n    Match env\n  else if lit_same_type l l' then\n    No_match\n  else\n    Match_type_error )\" |\n\"pmatch_single envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env =\n  (case  nsLookup envC n of\n      Some (l, t1) =>\n        if same_tid t1 t' \\<and> (List.length ps = l) then\n          if same_ctor (id_to_n n, t1) (n',t') then\n            fold2 (\\<lambda>p v m. case m of\n               Match env \\<Rightarrow> pmatch_single envC s p v env \n            | m \\<Rightarrow> m) Match_type_error ps vs (Match env)\n          else\n            No_match\n        else\n          Match_type_error\n    | _ => Match_type_error\n  )\" |\n\"pmatch_single envC s (Pcon None ps) (Conv None vs) env = (\n  if List.length ps = List.length vs then\n    fold2 (\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single envC s p v env \n        | m \\<Rightarrow> m)\n         Match_type_error ps vs (Match env)\n  else\n    Match_type_error )\" |\n\"pmatch_single envC s (Pref p) (Loc lnum) env =\n  (case  store_lookup lnum s of\n      Some (Refv v2) => pmatch_single envC s p v2 env\n    | Some _ => Match_type_error\n    | None => Match_type_error\n  )\" |\n\"pmatch_single envC s (Ptannot p t1) v2 env = pmatch_single envC s p v2 env\" |\n\"pmatch_single envC _ _ _ env = Match_type_error\""], ["", "private"], ["", "lemma pmatch_list_length_neq:\n  \"length vs \\<noteq> length ps \\<Longrightarrow> fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs m = Match_type_error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs \\<noteq> length ps \\<Longrightarrow>\n    fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match env \\<Rightarrow> pmatch_single cenv s p v env)\n     Match_type_error ps vs m =\n    Match_type_error", "by (induction ps vs arbitrary:m rule:List.list_induct2') auto"], ["", "private"], ["", "lemma pmatch_list_nomatch:\n  \"length vs = length ps \\<Longrightarrow> fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs No_match = No_match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs = length ps \\<Longrightarrow>\n    fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match env \\<Rightarrow> pmatch_single cenv s p v env)\n     Match_type_error ps vs No_match =\n    No_match", "by (induction ps vs  rule:List.list_induct2') auto"], ["", "private"], ["", "lemma pmatch_list_typerr:\n  \"length vs = length ps \\<Longrightarrow> fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs Match_type_error = Match_type_error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs = length ps \\<Longrightarrow>\n    fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match env \\<Rightarrow> pmatch_single cenv s p v env)\n     Match_type_error ps vs Match_type_error =\n    Match_type_error", "by (induction ps vs  rule:List.list_induct2') auto"], ["", "private"], ["", "lemma pmatch_single_eq0:\n  \"length ps = length vs \\<Longrightarrow> pmatch_list cenv s ps vs env = fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> pmatch_single cenv s p v env \n        | m \\<Rightarrow> m) Match_type_error ps vs (Match env)\"\n  \"pmatch cenv s p v0 env = pmatch_single cenv s p v0 env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length ps = length vs \\<Longrightarrow>\n     pmatch_list cenv s ps vs env =\n     fold2\n      (\\<lambda>p v m.\n          case m of No_match \\<Rightarrow> No_match\n          | Match_type_error \\<Rightarrow> Match_type_error\n          | Match env \\<Rightarrow> pmatch_single cenv s p v env)\n      Match_type_error ps vs (Match env)) &&&\n    pmatch cenv s p v0 env = pmatch_single cenv s p v0 env", "proof (induction rule: pmatch_list_pmatch.induct)"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>envC s v' env.\n       pmatch envC s Pany v' env = pmatch_single envC s Pany v' env\n 2. \\<And>envC s x v' env.\n       pmatch envC s (Pvar x) v' env = pmatch_single envC s (Pvar x) v' env\n 3. \\<And>envC s l l' env.\n       pmatch envC s (Plit l) (Litv l') env =\n       pmatch_single envC s (Plit l) (Litv l') env\n 4. \\<And>envC s n ps n' t' vs env.\n       (\\<And>x2 x y.\n           \\<lbrakk>nsLookup envC n = Some x2; (x, y) = x2;\n            same_tid y t' \\<and> length ps = x;\n            same_ctor (id_to_n n, y) (n', t'); length vs = x;\n            length ps = length vs\\<rbrakk>\n           \\<Longrightarrow> pmatch_list envC s ps vs env =\n                             fold2\n                              (\\<lambda>p v.\n                                  case_match_result No_match\n                                   Match_type_error\n                                   (pmatch_single envC s p v))\n                              Match_type_error ps vs\n                              (Match env)) \\<Longrightarrow>\n       pmatch envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env =\n       pmatch_single envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env\n 5. \\<And>envC s ps vs env.\n       (\\<lbrakk>length ps = length vs; length ps = length vs\\<rbrakk>\n        \\<Longrightarrow> pmatch_list envC s ps vs env =\n                          fold2\n                           (\\<lambda>p v.\n                               case_match_result No_match Match_type_error\n                                (pmatch_single envC s p v))\n                           Match_type_error ps vs\n                           (Match env)) \\<Longrightarrow>\n       pmatch envC s (Pcon None ps) (Conv None vs) env =\n       pmatch_single envC s (Pcon None ps) (Conv None vs) env\n 6. \\<And>envC s p lnum env.\n       (\\<And>x2 x1.\n           \\<lbrakk>store_lookup lnum s = Some x2; x2 = Refv x1\\<rbrakk>\n           \\<Longrightarrow> pmatch envC s p x1 env =\n                             pmatch_single envC s p x1\n                              env) \\<Longrightarrow>\n       pmatch envC s (Pref p) (Loc lnum) env =\n       pmatch_single envC s (Pref p) (Loc lnum) env\n 7. \\<And>envC s p t1 v2 env.\n       pmatch envC s p v2 env =\n       pmatch_single envC s p v2 env \\<Longrightarrow>\n       pmatch envC s (Ptannot p t1) v2 env =\n       pmatch_single envC s (Ptannot p t1) v2 env\n 8. \\<And>envC uu_ v va vb env.\n       pmatch envC uu_ (Plit v) (Conv va vb) env =\n       pmatch_single envC uu_ (Plit v) (Conv va vb) env\n 9. \\<And>envC uu_ v va vb vc env.\n       pmatch envC uu_ (Plit v) (Closure va vb vc) env =\n       pmatch_single envC uu_ (Plit v) (Closure va vb vc) env\n 10. \\<And>envC uu_ v va vb vc env.\n        pmatch envC uu_ (Plit v) (Recclosure va vb vc) env =\n        pmatch_single envC uu_ (Plit v) (Recclosure va vb vc) env\nA total of 33 subgoals...", "case (4 envC s n ps n' t' vs env)"], ["proof (state)\nthis:\n  \\<lbrakk>nsLookup envC n = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t' \\<and> length ps = ?x; same_ctor (id_to_n n, ?y) (n', t');\n   length vs = ?x; length ps = length vs\\<rbrakk>\n  \\<Longrightarrow> pmatch_list envC s ps vs env =\n                    fold2\n                     (\\<lambda>p v a.\n                         case a of No_match \\<Rightarrow> No_match\n                         | Match_type_error \\<Rightarrow> Match_type_error\n                         | Match a \\<Rightarrow> pmatch_single envC s p v a)\n                     Match_type_error ps vs (Match env)\n\ngoal (33 subgoals):\n 1. \\<And>envC s v' env.\n       pmatch envC s Pany v' env = pmatch_single envC s Pany v' env\n 2. \\<And>envC s x v' env.\n       pmatch envC s (Pvar x) v' env = pmatch_single envC s (Pvar x) v' env\n 3. \\<And>envC s l l' env.\n       pmatch envC s (Plit l) (Litv l') env =\n       pmatch_single envC s (Plit l) (Litv l') env\n 4. \\<And>envC s n ps n' t' vs env.\n       (\\<And>x2 x y.\n           \\<lbrakk>nsLookup envC n = Some x2; (x, y) = x2;\n            same_tid y t' \\<and> length ps = x;\n            same_ctor (id_to_n n, y) (n', t'); length vs = x;\n            length ps = length vs\\<rbrakk>\n           \\<Longrightarrow> pmatch_list envC s ps vs env =\n                             fold2\n                              (\\<lambda>p v.\n                                  case_match_result No_match\n                                   Match_type_error\n                                   (pmatch_single envC s p v))\n                              Match_type_error ps vs\n                              (Match env)) \\<Longrightarrow>\n       pmatch envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env =\n       pmatch_single envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env\n 5. \\<And>envC s ps vs env.\n       (\\<lbrakk>length ps = length vs; length ps = length vs\\<rbrakk>\n        \\<Longrightarrow> pmatch_list envC s ps vs env =\n                          fold2\n                           (\\<lambda>p v.\n                               case_match_result No_match Match_type_error\n                                (pmatch_single envC s p v))\n                           Match_type_error ps vs\n                           (Match env)) \\<Longrightarrow>\n       pmatch envC s (Pcon None ps) (Conv None vs) env =\n       pmatch_single envC s (Pcon None ps) (Conv None vs) env\n 6. \\<And>envC s p lnum env.\n       (\\<And>x2 x1.\n           \\<lbrakk>store_lookup lnum s = Some x2; x2 = Refv x1\\<rbrakk>\n           \\<Longrightarrow> pmatch envC s p x1 env =\n                             pmatch_single envC s p x1\n                              env) \\<Longrightarrow>\n       pmatch envC s (Pref p) (Loc lnum) env =\n       pmatch_single envC s (Pref p) (Loc lnum) env\n 7. \\<And>envC s p t1 v2 env.\n       pmatch envC s p v2 env =\n       pmatch_single envC s p v2 env \\<Longrightarrow>\n       pmatch envC s (Ptannot p t1) v2 env =\n       pmatch_single envC s (Ptannot p t1) v2 env\n 8. \\<And>envC uu_ v va vb env.\n       pmatch envC uu_ (Plit v) (Conv va vb) env =\n       pmatch_single envC uu_ (Plit v) (Conv va vb) env\n 9. \\<And>envC uu_ v va vb vc env.\n       pmatch envC uu_ (Plit v) (Closure va vb vc) env =\n       pmatch_single envC uu_ (Plit v) (Closure va vb vc) env\n 10. \\<And>envC uu_ v va vb vc env.\n        pmatch envC uu_ (Plit v) (Recclosure va vb vc) env =\n        pmatch_single envC uu_ (Plit v) (Recclosure va vb vc) env\nA total of 33 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>nsLookup envC n = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t' \\<and> length ps = ?x; same_ctor (id_to_n n, ?y) (n', t');\n   length vs = ?x; length ps = length vs\\<rbrakk>\n  \\<Longrightarrow> pmatch_list envC s ps vs env =\n                    fold2\n                     (\\<lambda>p v a.\n                         case a of No_match \\<Rightarrow> No_match\n                         | Match_type_error \\<Rightarrow> Match_type_error\n                         | Match a \\<Rightarrow> pmatch_single envC s p v a)\n                     Match_type_error ps vs (Match env)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>nsLookup envC n = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t' \\<and> length ps = ?x; same_ctor (id_to_n n, ?y) (n', t');\n   length vs = ?x; length ps = length vs\\<rbrakk>\n  \\<Longrightarrow> pmatch_list envC s ps vs env =\n                    fold2\n                     (\\<lambda>p v a.\n                         case a of No_match \\<Rightarrow> No_match\n                         | Match_type_error \\<Rightarrow> Match_type_error\n                         | Match a \\<Rightarrow> pmatch_single envC s p v a)\n                     Match_type_error ps vs (Match env)\n\ngoal (1 subgoal):\n 1. pmatch envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env =\n    pmatch_single envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env", "by (auto split:option.splits match_result.splits dest!:pmatch_list_length_neq[where m = \"Match env\" and cenv = envC and s = s])"], ["proof (state)\nthis:\n  pmatch envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env =\n  pmatch_single envC s (Pcon (Some n) ps) (Conv (Some (n', t')) vs) env\n\ngoal (32 subgoals):\n 1. \\<And>envC s v' env.\n       pmatch envC s Pany v' env = pmatch_single envC s Pany v' env\n 2. \\<And>envC s x v' env.\n       pmatch envC s (Pvar x) v' env = pmatch_single envC s (Pvar x) v' env\n 3. \\<And>envC s l l' env.\n       pmatch envC s (Plit l) (Litv l') env =\n       pmatch_single envC s (Plit l) (Litv l') env\n 4. \\<And>envC s ps vs env.\n       (\\<lbrakk>length ps = length vs; length ps = length vs\\<rbrakk>\n        \\<Longrightarrow> pmatch_list envC s ps vs env =\n                          fold2\n                           (\\<lambda>p v.\n                               case_match_result No_match Match_type_error\n                                (pmatch_single envC s p v))\n                           Match_type_error ps vs\n                           (Match env)) \\<Longrightarrow>\n       pmatch envC s (Pcon None ps) (Conv None vs) env =\n       pmatch_single envC s (Pcon None ps) (Conv None vs) env\n 5. \\<And>envC s p lnum env.\n       (\\<And>x2 x1.\n           \\<lbrakk>store_lookup lnum s = Some x2; x2 = Refv x1\\<rbrakk>\n           \\<Longrightarrow> pmatch envC s p x1 env =\n                             pmatch_single envC s p x1\n                              env) \\<Longrightarrow>\n       pmatch envC s (Pref p) (Loc lnum) env =\n       pmatch_single envC s (Pref p) (Loc lnum) env\n 6. \\<And>envC s p t1 v2 env.\n       pmatch envC s p v2 env =\n       pmatch_single envC s p v2 env \\<Longrightarrow>\n       pmatch envC s (Ptannot p t1) v2 env =\n       pmatch_single envC s (Ptannot p t1) v2 env\n 7. \\<And>envC uu_ v va vb env.\n       pmatch envC uu_ (Plit v) (Conv va vb) env =\n       pmatch_single envC uu_ (Plit v) (Conv va vb) env\n 8. \\<And>envC uu_ v va vb vc env.\n       pmatch envC uu_ (Plit v) (Closure va vb vc) env =\n       pmatch_single envC uu_ (Plit v) (Closure va vb vc) env\n 9. \\<And>envC uu_ v va vb vc env.\n       pmatch envC uu_ (Plit v) (Recclosure va vb vc) env =\n       pmatch_single envC uu_ (Plit v) (Recclosure va vb vc) env\n 10. \\<And>envC uu_ v va env.\n        pmatch envC uu_ (Plit v) (Loc va) env =\n        pmatch_single envC uu_ (Plit v) (Loc va) env\nA total of 32 subgoals...", "qed (auto split:option.splits match_result.splits store_v.splits simp:pmatch_list_nomatch pmatch_list_typerr)"], ["", "lemma pmatch_single_equiv: \"pmatch = pmatch_single\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmatch = pmatch_single", "by (rule ext)+ (simp add: pmatch_single_eq0)"], ["", "end"], ["", "export_code pmatch_single checking SML"], ["", "end"]]}