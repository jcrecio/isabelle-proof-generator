{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Normalisation/Monad_Normalisation_Test.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Normalisation", "problem_names": ["lemma\n  assumes \"f = id\"\n  shows\n    \"do {x \\<leftarrow> B; z \\<leftarrow> C x; d \\<leftarrow> E z x; a \\<leftarrow> D z x; y \\<leftarrow> A; return_pmf (x,y)} =\n     do {y \\<leftarrow> A; x \\<leftarrow> B; z \\<leftarrow> C x; a \\<leftarrow> D z x; d \\<leftarrow> E z x; return_pmf (f (x,y))}\"", "lemma \"(do {a \\<leftarrow> E; b \\<leftarrow> E; w \\<leftarrow> B b a; z \\<leftarrow> B a b; return_pmf (w,z)}) =\n       (do {a \\<leftarrow> E; b \\<leftarrow> E; z \\<leftarrow> B a b; w \\<leftarrow> B b a; return_pmf (w,z)})\"", "lemma \"(do {a \\<leftarrow> E; b \\<leftarrow> E; w \\<leftarrow> B b a; z \\<leftarrow> B a b; return_pmf (w,z)}) =\n       (do {a \\<leftarrow> E; b \\<leftarrow> E; z \\<leftarrow> B a b; w \\<leftarrow> B b a; return_pmf (w,z)})\"", "lemma \"do {y \\<leftarrow> A; x \\<leftarrow> A; z \\<leftarrow> B x y y; w \\<leftarrow> B x x y; Some (x,y)} =\n       do {x \\<leftarrow> A; y \\<leftarrow> A; z \\<leftarrow> B x x y; w \\<leftarrow> B x y y; Some (x,y)}\"", "lemma \"do {y \\<leftarrow> A; x \\<leftarrow> A; z \\<leftarrow> B x y y; w \\<leftarrow> B x x y; {x,y}} =\n       do {x \\<leftarrow> A; y \\<leftarrow> A; z \\<leftarrow> B x x y; w \\<leftarrow> B x y y; {x,y}}\"", "lemma \"do {y \\<leftarrow> A; x \\<leftarrow> A; z \\<leftarrow> B x y y; w \\<leftarrow> B x x y; return_pmf (x,y)} =\n       do {x \\<leftarrow> A; y \\<leftarrow> A; z \\<leftarrow> B x x y; w \\<leftarrow> B x y y; return_pmf (x,y)}\"", "lemma \"do {x \\<leftarrow> A 0; y \\<leftarrow> A x; w \\<leftarrow> B y y; z \\<leftarrow> B x y; a \\<leftarrow> C; Predicate.single (a,a)} =\n       do {x \\<leftarrow> A 0; y \\<leftarrow> A x; z \\<leftarrow> B x y; w \\<leftarrow> B y y; a \\<leftarrow> C; Predicate.single (a,a)}\"", "lemma \"do {x \\<leftarrow> A 0; y \\<leftarrow> A x; z \\<leftarrow> B x y; w \\<leftarrow> B y y; a \\<leftarrow> C; return_pmf (a,a)} =\n       do {x \\<leftarrow> A 0; y \\<leftarrow> A x; z \\<leftarrow> B y y; w \\<leftarrow> B x y; a \\<leftarrow> C; return_pmf (a,a)}\"", "lemma \"do {x \\<leftarrow> B; z \\<leftarrow> C x; d \\<leftarrow> E z x; a \\<leftarrow> D z x; y \\<leftarrow> A; return_pmf (x,y)} =\n       do {y \\<leftarrow> A; x \\<leftarrow> B; z \\<leftarrow> C x; a \\<leftarrow> D z x; d \\<leftarrow> E z x; return_pmf (x,y)}\"", "lemma \n  \"do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      z \\<leftarrow> sample_uniform (order \\<G>);\n      b \\<leftarrow> coin_spmf;\n      ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 (f x);\n      _ :: unit \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n      guess \\<leftarrow> \\<A>2 (f y, xor (f z) (if b then msg1 else msg2)) \\<sigma>;\n      return_spmf (guess \\<longleftrightarrow> b)\n    } = do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 (f x);\n      _ :: unit \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n      b \\<leftarrow> coin_spmf;\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      guess \\<leftarrow> \\<A>2 (f y, xor (f x) (if b then msg1 else msg2)) \\<sigma>;\n      return_spmf (guess \\<longleftrightarrow> b)\n    }\"", "lemma\n  \"do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      xa \\<leftarrow> sample_uniform (order \\<G>);\n      x \\<leftarrow> \\<A>1 (f x);\n      case x of\n      (x, xb) \\<Rightarrow>\n        (case x of\n         (msg1, msg2) \\<Rightarrow>\n           \\<lambda>\\<sigma>. do {\n                a \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n                x \\<leftarrow> coin_spmf;\n                xaa \\<leftarrow> map_spmf f (sample_uniform (order \\<G>));\n                guess \\<leftarrow> \\<A>2 (f xa, xaa) \\<sigma>;\n                return_spmf (guess \\<longleftrightarrow> x)\n              })\n         xb\n    } = do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      xa \\<leftarrow> sample_uniform (order \\<G>);\n      x \\<leftarrow> \\<A>1 (f x);\n      case x of\n      (x, xb) \\<Rightarrow>\n        (case x of\n         (msg1, msg2) \\<Rightarrow>\n           \\<lambda>\\<sigma>. do {\n                a \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n                z \\<leftarrow> map_spmf f (sample_uniform (order \\<G>));\n                guess \\<leftarrow> \\<A>2 (f xa, z) \\<sigma>;\n                map_spmf ((\\<longleftrightarrow>) guess) coin_spmf\n              })\n         xb\n    }\"", "lemma elgamal_step3:\n  \"do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      b \\<leftarrow> coin_spmf;\n      p \\<leftarrow> \\<A>1 (f x);\n      _ \\<leftarrow> assert_spmf (valid_plain (fst (fst p)) \\<and> valid_plain (snd (fst p)));\n      guess \\<leftarrow>\n        \\<A>2 (f y, xor (f (x * y)) (if b then fst (fst p) else snd (fst p)))\n         (snd p);\n      return_spmf (guess \\<longleftrightarrow> b)\n    }  = do {\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      b \\<leftarrow> coin_spmf;\n      p \\<leftarrow> \\<A>1 (f y);\n      _ \\<leftarrow> assert_spmf (valid_plain (fst (fst p)) \\<and> valid_plain (snd (fst p)));\n      ya \\<leftarrow> sample_uniform (order \\<G>);\n      b' \\<leftarrow> \\<A>2 (f ya,\n                 xor (f (y * ya)) (if b then fst (fst p) else snd (fst p)))\n             (snd p);\n      return_spmf (b' \\<longleftrightarrow> b)\n    }\"", "lemma\n  \"do {\n      x \\<leftarrow> A :: nat spmf;\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      if a = b then do {\n        return_spmf x\n      } else do {\n        y \\<leftarrow> C;\n        return_spmf (x + y)\n      }\n   } = do {\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      if b = a then A else do {\n        y \\<leftarrow> C;\n        x \\<leftarrow> A;\n        return_spmf (y + x)\n      }\n   }\"", "lemma\n  \"do {\n      x \\<leftarrow> A :: nat spmf;\n      p \\<leftarrow> do {\n        a \\<leftarrow> B;\n        b \\<leftarrow> B;\n        return_spmf (a, b)\n      };\n      q \\<leftarrow> coin_spmf;\n      if q then do {\n        return_spmf (x + fst p)\n      } else do {\n        y \\<leftarrow> C;\n        return_spmf (y + snd p)\n      }\n   } = do {\n      q \\<leftarrow> coin_spmf;\n      if q then do {\n        x \\<leftarrow> A;\n        a \\<leftarrow> B;\n        _ \\<leftarrow> B;\n        return_spmf (x + a)\n      } else do {\n        y \\<leftarrow> C;\n        a \\<leftarrow> B;\n        _ \\<leftarrow> B;\n        _ \\<leftarrow> A;\n        return_spmf (y + a)\n      }\n   }\"", "lemma\n  fixes f :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat + nat\"\n  shows\n  \"do {\n      x \\<leftarrow> (A::nat set);\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      case f a b of\n        Inl c \\<Rightarrow> {x}\n      | Inr c \\<Rightarrow> do {\n          y \\<leftarrow> C x;\n          {(x + y + c)}\n        }\n   } = do {\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      case f b a of\n        Inl c \\<Rightarrow> A\n      | Inr c \\<Rightarrow> do {\n          x \\<leftarrow> A;\n          y \\<leftarrow> C x;\n          {(y + c + x)}\n      }\n   }\"", "lemma \"do {a \\<leftarrow> A; b \\<leftarrow> A; Some (a \\<and> b, b)} =\n       do {a \\<leftarrow> A; b \\<leftarrow> A; Some (a \\<and> b, a)}\"", "lemma\n  \"do {a \\<leftarrow> f A; b \\<leftarrow> f B; c \\<leftarrow> D b; d \\<leftarrow> f C; F a c d} = \n   do {b \\<leftarrow> f B; c \\<leftarrow> D b; a \\<leftarrow> f A; d \\<leftarrow> f C; F a c d}\"\n  for f :: \"'b \\<Rightarrow> 'a option\" and D :: \"'a \\<Rightarrow> 'a option\"", "lemma\n  \"do {a \\<leftarrow> f E; b \\<leftarrow> f B; c \\<leftarrow> D b; d \\<leftarrow> f C; F a c d} = \n   do {b \\<leftarrow> f B; c \\<leftarrow> D b; a \\<leftarrow> f E; d \\<leftarrow> f C; F a c d}\"\n  for f :: \"'b \\<Rightarrow> 'a option\" and D :: \"'a \\<Rightarrow> 'a option\""], "translations": [["", "lemma\n  assumes \"f = id\"\n  shows\n    \"do {x \\<leftarrow> B; z \\<leftarrow> C x; d \\<leftarrow> E z x; a \\<leftarrow> D z x; y \\<leftarrow> A; return_pmf (x,y)} =\n     do {y \\<leftarrow> A; x \\<leftarrow> B; z \\<leftarrow> C x; a \\<leftarrow> D z x; d \\<leftarrow> E z x; return_pmf (f (x,y))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<bind>\n    (\\<lambda>x.\n        C x \\<bind>\n        (\\<lambda>z.\n            E z x \\<bind>\n            (\\<lambda>d.\n                D z x \\<bind>\n                (\\<lambda>a. A \\<bind> (\\<lambda>y. return_pmf (x, y)))))) =\n    A \\<bind>\n    (\\<lambda>y.\n        B \\<bind>\n        (\\<lambda>x.\n            C x \\<bind>\n            (\\<lambda>z.\n                D z x \\<bind>\n                (\\<lambda>a.\n                    E z x \\<bind> (\\<lambda>d. return_pmf (f (x, y)))))))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<bind> (\\<lambda>x. A \\<bind> (\\<lambda>y. return_pmf (x, y))) =\n    B \\<bind> (\\<lambda>x. A \\<bind> (\\<lambda>y. return_pmf (f (x, y))))", "apply (simp add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"(do {a \\<leftarrow> E; b \\<leftarrow> E; w \\<leftarrow> B b a; z \\<leftarrow> B a b; return_pmf (w,z)}) =\n       (do {a \\<leftarrow> E; b \\<leftarrow> E; z \\<leftarrow> B a b; w \\<leftarrow> B b a; return_pmf (w,z)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<bind>\n    (\\<lambda>a.\n        E \\<bind>\n        (\\<lambda>b.\n            B b a \\<bind>\n            (\\<lambda>w. B a b \\<bind> (\\<lambda>z. return_pmf (w, z))))) =\n    E \\<bind>\n    (\\<lambda>a.\n        E \\<bind>\n        (\\<lambda>b.\n            B a b \\<bind>\n            (\\<lambda>z. B b a \\<bind> (\\<lambda>w. return_pmf (w, z)))))", "by (simp)"], ["", "lemma \"(do {a \\<leftarrow> E; b \\<leftarrow> E; w \\<leftarrow> B b a; z \\<leftarrow> B a b; return_pmf (w,z)}) =\n       (do {a \\<leftarrow> E; b \\<leftarrow> E; z \\<leftarrow> B a b; w \\<leftarrow> B b a; return_pmf (w,z)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<bind>\n    (\\<lambda>a.\n        E \\<bind>\n        (\\<lambda>b.\n            B b a \\<bind>\n            (\\<lambda>w. B a b \\<bind> (\\<lambda>z. return_pmf (w, z))))) =\n    E \\<bind>\n    (\\<lambda>a.\n        E \\<bind>\n        (\\<lambda>b.\n            B a b \\<bind>\n            (\\<lambda>z. B b a \\<bind> (\\<lambda>w. return_pmf (w, z)))))", "by (simp)"], ["", "lemma \"do {y \\<leftarrow> A; x \\<leftarrow> A; z \\<leftarrow> B x y y; w \\<leftarrow> B x x y; Some (x,y)} =\n       do {x \\<leftarrow> A; y \\<leftarrow> A; z \\<leftarrow> B x x y; w \\<leftarrow> B x y y; Some (x,y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind>\n    (\\<lambda>y.\n        A \\<bind>\n        (\\<lambda>x.\n            B x y y \\<bind>\n            (\\<lambda>z. B x x y \\<bind> (\\<lambda>w. Some (x, y))))) =\n    A \\<bind>\n    (\\<lambda>x.\n        A \\<bind>\n        (\\<lambda>y.\n            B x x y \\<bind>\n            (\\<lambda>z. B x y y \\<bind> (\\<lambda>w. Some (x, y)))))", "by (simp)"], ["", "lemma \"do {y \\<leftarrow> A; x \\<leftarrow> A; z \\<leftarrow> B x y y; w \\<leftarrow> B x x y; {x,y}} =\n       do {x \\<leftarrow> A; y \\<leftarrow> A; z \\<leftarrow> B x x y; w \\<leftarrow> B x y y; {x,y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind>\n    (\\<lambda>y.\n        A \\<bind>\n        (\\<lambda>x.\n            B x y y \\<bind>\n            (\\<lambda>z. B x x y \\<bind> (\\<lambda>w. {x, y})))) =\n    A \\<bind>\n    (\\<lambda>x.\n        A \\<bind>\n        (\\<lambda>y.\n            B x x y \\<bind>\n            (\\<lambda>z. B x y y \\<bind> (\\<lambda>w. {x, y}))))", "by (simp)"], ["", "lemma \"do {y \\<leftarrow> A; x \\<leftarrow> A; z \\<leftarrow> B x y y; w \\<leftarrow> B x x y; return_pmf (x,y)} =\n       do {x \\<leftarrow> A; y \\<leftarrow> A; z \\<leftarrow> B x x y; w \\<leftarrow> B x y y; return_pmf (x,y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind>\n    (\\<lambda>y.\n        A \\<bind>\n        (\\<lambda>x.\n            B x y y \\<bind>\n            (\\<lambda>z.\n                B x x y \\<bind> (\\<lambda>w. return_pmf (x, y))))) =\n    A \\<bind>\n    (\\<lambda>x.\n        A \\<bind>\n        (\\<lambda>y.\n            B x x y \\<bind>\n            (\\<lambda>z. B x y y \\<bind> (\\<lambda>w. return_pmf (x, y)))))", "by (simp)"], ["", "lemma \"do {x \\<leftarrow> A 0; y \\<leftarrow> A x; w \\<leftarrow> B y y; z \\<leftarrow> B x y; a \\<leftarrow> C; Predicate.single (a,a)} =\n       do {x \\<leftarrow> A 0; y \\<leftarrow> A x; z \\<leftarrow> B x y; w \\<leftarrow> B y y; a \\<leftarrow> C; Predicate.single (a,a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (0::'b) \\<bind>\n    (\\<lambda>x.\n        A x \\<bind>\n        (\\<lambda>y.\n            B y y \\<bind>\n            (\\<lambda>w.\n                B x y \\<bind>\n                (\\<lambda>z.\n                    C \\<bind> (\\<lambda>a. Predicate.single (a, a)))))) =\n    A (0::'b) \\<bind>\n    (\\<lambda>x.\n        A x \\<bind>\n        (\\<lambda>y.\n            B x y \\<bind>\n            (\\<lambda>z.\n                B y y \\<bind>\n                (\\<lambda>w.\n                    C \\<bind> (\\<lambda>a. Predicate.single (a, a))))))", "by (simp)"], ["", "lemma \"do {x \\<leftarrow> A 0; y \\<leftarrow> A x; z \\<leftarrow> B x y; w \\<leftarrow> B y y; a \\<leftarrow> C; return_pmf (a,a)} =\n       do {x \\<leftarrow> A 0; y \\<leftarrow> A x; z \\<leftarrow> B y y; w \\<leftarrow> B x y; a \\<leftarrow> C; return_pmf (a,a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (0::'b) \\<bind>\n    (\\<lambda>x.\n        A x \\<bind>\n        (\\<lambda>y.\n            B x y \\<bind>\n            (\\<lambda>z.\n                B y y \\<bind>\n                (\\<lambda>w. C \\<bind> (\\<lambda>a. return_pmf (a, a)))))) =\n    A (0::'b) \\<bind>\n    (\\<lambda>x.\n        A x \\<bind>\n        (\\<lambda>y.\n            B y y \\<bind>\n            (\\<lambda>z.\n                B x y \\<bind>\n                (\\<lambda>w. C \\<bind> (\\<lambda>a. return_pmf (a, a))))))", "by (simp)"], ["", "lemma \"do {x \\<leftarrow> B; z \\<leftarrow> C x; d \\<leftarrow> E z x; a \\<leftarrow> D z x; y \\<leftarrow> A; return_pmf (x,y)} =\n       do {y \\<leftarrow> A; x \\<leftarrow> B; z \\<leftarrow> C x; a \\<leftarrow> D z x; d \\<leftarrow> E z x; return_pmf (x,y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<bind>\n    (\\<lambda>x.\n        C x \\<bind>\n        (\\<lambda>z.\n            E z x \\<bind>\n            (\\<lambda>d.\n                D z x \\<bind>\n                (\\<lambda>a. A \\<bind> (\\<lambda>y. return_pmf (x, y)))))) =\n    A \\<bind>\n    (\\<lambda>y.\n        B \\<bind>\n        (\\<lambda>x.\n            C x \\<bind>\n            (\\<lambda>z.\n                D z x \\<bind>\n                (\\<lambda>a.\n                    E z x \\<bind> (\\<lambda>d. return_pmf (x, y))))))", "by (simp)"], ["", "no_adhoc_overloading Monad_Syntax.bind bind_pmf"], ["", "context\n  fixes \\<A>1 :: \"'a \\<Rightarrow> (('a \\<times> 'a) \\<times> 'b) spmf\"\n  and \\<A>2 :: \"'a \\<times> 'a \\<Rightarrow> 'b \\<Rightarrow> bool spmf\"\n  and sample_uniform :: \"nat \\<Rightarrow> nat spmf\"\n  and order :: \"'a \\<Rightarrow> nat\"\nbegin"], ["", "lemma \n  \"do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      z \\<leftarrow> sample_uniform (order \\<G>);\n      b \\<leftarrow> coin_spmf;\n      ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 (f x);\n      _ :: unit \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n      guess \\<leftarrow> \\<A>2 (f y, xor (f z) (if b then msg1 else msg2)) \\<sigma>;\n      return_spmf (guess \\<longleftrightarrow> b)\n    } = do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 (f x);\n      _ :: unit \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n      b \\<leftarrow> coin_spmf;\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      guess \\<leftarrow> \\<A>2 (f y, xor (f x) (if b then msg1 else msg2)) \\<sigma>;\n      return_spmf (guess \\<longleftrightarrow> b)\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>y.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>z.\n                coin_spmf \\<bind>\n                (\\<lambda>b.\n                    \\<A>1 (f x) \\<bind>\n                    (\\<lambda>((msg1, msg2), \\<sigma>).\n                        assert_spmf\n                         (valid_plain msg1 \\<and> valid_plain msg2) \\<bind>\n                        (\\<lambda>_.\n                            \\<A>2\n                             (f y, xor (f z) (if b then msg1 else msg2))\n                             \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                return_spmf (guess = b)))))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>y.\n            \\<A>1 (f x) \\<bind>\n            (\\<lambda>((msg1, msg2), \\<sigma>).\n                assert_spmf\n                 (valid_plain msg1 \\<and> valid_plain msg2) \\<bind>\n                (\\<lambda>_.\n                    coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        sample_uniform (order \\<G>) \\<bind>\n                        (\\<lambda>x.\n                            \\<A>2\n                             (f y, xor (f x) (if b then msg1 else msg2))\n                             \\<sigma> \\<bind>\n                            (\\<lambda>guess. return_spmf (guess = b))))))))", "by (simp add: split_def)"], ["", "lemma\n  \"do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      xa \\<leftarrow> sample_uniform (order \\<G>);\n      x \\<leftarrow> \\<A>1 (f x);\n      case x of\n      (x, xb) \\<Rightarrow>\n        (case x of\n         (msg1, msg2) \\<Rightarrow>\n           \\<lambda>\\<sigma>. do {\n                a \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n                x \\<leftarrow> coin_spmf;\n                xaa \\<leftarrow> map_spmf f (sample_uniform (order \\<G>));\n                guess \\<leftarrow> \\<A>2 (f xa, xaa) \\<sigma>;\n                return_spmf (guess \\<longleftrightarrow> x)\n              })\n         xb\n    } = do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      xa \\<leftarrow> sample_uniform (order \\<G>);\n      x \\<leftarrow> \\<A>1 (f x);\n      case x of\n      (x, xb) \\<Rightarrow>\n        (case x of\n         (msg1, msg2) \\<Rightarrow>\n           \\<lambda>\\<sigma>. do {\n                a \\<leftarrow> assert_spmf (valid_plain msg1 \\<and> valid_plain msg2);\n                z \\<leftarrow> map_spmf f (sample_uniform (order \\<G>));\n                guess \\<leftarrow> \\<A>2 (f xa, z) \\<sigma>;\n                map_spmf ((\\<longleftrightarrow>) guess) coin_spmf\n              })\n         xb\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            \\<A>1 (f x) \\<bind>\n            (\\<lambda>x.\n                case x of\n                (x, xb) \\<Rightarrow>\n                  (case x of\n                   (msg1, msg2) \\<Rightarrow>\n                     \\<lambda>\\<sigma>.\n                        assert_spmf\n                         (valid_plain msg1 \\<and> valid_plain msg2) \\<bind>\n                        (\\<lambda>a.\n                            coin_spmf \\<bind>\n                            (\\<lambda>x.\n                                map_spmf f\n                                 (sample_uniform (order \\<G>)) \\<bind>\n                                (\\<lambda>xaa.\n                                    \\<A>2 (f xa, xaa) \\<sigma> \\<bind>\n                                    (\\<lambda>guess.\n  return_spmf (guess = x))))))\n                   xb))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            \\<A>1 (f x) \\<bind>\n            (\\<lambda>x.\n                case x of\n                (x, xb) \\<Rightarrow>\n                  (case x of\n                   (msg1, msg2) \\<Rightarrow>\n                     \\<lambda>\\<sigma>.\n                        assert_spmf\n                         (valid_plain msg1 \\<and> valid_plain msg2) \\<bind>\n                        (\\<lambda>a.\n                            map_spmf f (sample_uniform (order \\<G>)) \\<bind>\n                            (\\<lambda>z.\n                                \\<A>2 (f xa, z) \\<sigma> \\<bind>\n                                (\\<lambda>guess.\n                                    map_spmf ((=) guess) coin_spmf))))\n                   xb)))", "by (simp add: map_spmf_conv_bind_spmf)"], ["", "lemma elgamal_step3:\n  \"do {\n      x \\<leftarrow> sample_uniform (order \\<G>);\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      b \\<leftarrow> coin_spmf;\n      p \\<leftarrow> \\<A>1 (f x);\n      _ \\<leftarrow> assert_spmf (valid_plain (fst (fst p)) \\<and> valid_plain (snd (fst p)));\n      guess \\<leftarrow>\n        \\<A>2 (f y, xor (f (x * y)) (if b then fst (fst p) else snd (fst p)))\n         (snd p);\n      return_spmf (guess \\<longleftrightarrow> b)\n    }  = do {\n      y \\<leftarrow> sample_uniform (order \\<G>);\n      b \\<leftarrow> coin_spmf;\n      p \\<leftarrow> \\<A>1 (f y);\n      _ \\<leftarrow> assert_spmf (valid_plain (fst (fst p)) \\<and> valid_plain (snd (fst p)));\n      ya \\<leftarrow> sample_uniform (order \\<G>);\n      b' \\<leftarrow> \\<A>2 (f ya,\n                 xor (f (y * ya)) (if b then fst (fst p) else snd (fst p)))\n             (snd p);\n      return_spmf (b' \\<longleftrightarrow> b)\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>y.\n            coin_spmf \\<bind>\n            (\\<lambda>b.\n                \\<A>1 (f x) \\<bind>\n                (\\<lambda>p.\n                    assert_spmf\n                     (valid_plain (fst (fst p)) \\<and>\n                      valid_plain (snd (fst p))) \\<bind>\n                    (\\<lambda>_.\n                        \\<A>2\n                         (f y,\n                          xor (f (x * y))\n                           (if b then fst (fst p) else snd (fst p)))\n                         (snd p) \\<bind>\n                        (\\<lambda>guess. return_spmf (guess = b))))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>y.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            \\<A>1 (f y) \\<bind>\n            (\\<lambda>p.\n                assert_spmf\n                 (valid_plain (fst (fst p)) \\<and>\n                  valid_plain (snd (fst p))) \\<bind>\n                (\\<lambda>_.\n                    sample_uniform (order \\<G>) \\<bind>\n                    (\\<lambda>ya.\n                        \\<A>2\n                         (f ya,\n                          xor (f (y * ya))\n                           (if b then fst (fst p) else snd (fst p)))\n                         (snd p) \\<bind>\n                        (\\<lambda>b'. return_spmf (b' = b)))))))", "by (simp)"], ["", "end"], ["", "text \\<open>Distributivity\\<close>"], ["", "lemma\n  \"do {\n      x \\<leftarrow> A :: nat spmf;\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      if a = b then do {\n        return_spmf x\n      } else do {\n        y \\<leftarrow> C;\n        return_spmf (x + y)\n      }\n   } = do {\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      if b = a then A else do {\n        y \\<leftarrow> C;\n        x \\<leftarrow> A;\n        return_spmf (y + x)\n      }\n   }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind>\n    (\\<lambda>x.\n        B \\<bind>\n        (\\<lambda>a.\n            B \\<bind>\n            (\\<lambda>b.\n                if a = b then return_spmf x\n                else C \\<bind> (\\<lambda>y. return_spmf (x + y))))) =\n    B \\<bind>\n    (\\<lambda>a.\n        B \\<bind>\n        (\\<lambda>b.\n            if b = a then A\n            else C \\<bind>\n                 (\\<lambda>y. A \\<bind> (\\<lambda>x. return_spmf (y + x)))))", "by (simp add: add.commute cong: if_cong)"], ["", "lemma\n  \"do {\n      x \\<leftarrow> A :: nat spmf;\n      p \\<leftarrow> do {\n        a \\<leftarrow> B;\n        b \\<leftarrow> B;\n        return_spmf (a, b)\n      };\n      q \\<leftarrow> coin_spmf;\n      if q then do {\n        return_spmf (x + fst p)\n      } else do {\n        y \\<leftarrow> C;\n        return_spmf (y + snd p)\n      }\n   } = do {\n      q \\<leftarrow> coin_spmf;\n      if q then do {\n        x \\<leftarrow> A;\n        a \\<leftarrow> B;\n        _ \\<leftarrow> B;\n        return_spmf (x + a)\n      } else do {\n        y \\<leftarrow> C;\n        a \\<leftarrow> B;\n        _ \\<leftarrow> B;\n        _ \\<leftarrow> A;\n        return_spmf (y + a)\n      }\n   }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind>\n    (\\<lambda>x.\n        B \\<bind>\n        (\\<lambda>a. B \\<bind> (\\<lambda>b. return_spmf (a, b))) \\<bind>\n        (\\<lambda>p.\n            coin_spmf \\<bind>\n            (\\<lambda>q.\n                if q then return_spmf (x + fst p)\n                else C \\<bind> (\\<lambda>y. return_spmf (y + snd p))))) =\n    coin_spmf \\<bind>\n    (\\<lambda>q.\n        if q\n        then A \\<bind>\n             (\\<lambda>x.\n                 B \\<bind>\n                 (\\<lambda>a. B \\<bind> (\\<lambda>_. return_spmf (x + a))))\n        else C \\<bind>\n             (\\<lambda>y.\n                 B \\<bind>\n                 (\\<lambda>a.\n                     B \\<bind>\n                     (\\<lambda>_.\n                         A \\<bind> (\\<lambda>_. return_spmf (y + a))))))", "by (simp cong: if_cong)"], ["", "lemma\n  fixes f :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat + nat\"\n  shows\n  \"do {\n      x \\<leftarrow> (A::nat set);\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      case f a b of\n        Inl c \\<Rightarrow> {x}\n      | Inr c \\<Rightarrow> do {\n          y \\<leftarrow> C x;\n          {(x + y + c)}\n        }\n   } = do {\n      a \\<leftarrow> B;\n      b \\<leftarrow> B;\n      case f b a of\n        Inl c \\<Rightarrow> A\n      | Inr c \\<Rightarrow> do {\n          x \\<leftarrow> A;\n          y \\<leftarrow> C x;\n          {(y + c + x)}\n      }\n   }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind>\n    (\\<lambda>x.\n        B \\<bind>\n        (\\<lambda>a.\n            B \\<bind>\n            (\\<lambda>b.\n                case f a b of Inl c \\<Rightarrow> {x}\n                | Inr c \\<Rightarrow>\n                    C x \\<bind> (\\<lambda>y. {x + y + c})))) =\n    B \\<bind>\n    (\\<lambda>a.\n        B \\<bind>\n        (\\<lambda>b.\n            case f b a of Inl c \\<Rightarrow> A\n            | Inr c \\<Rightarrow>\n                A \\<bind>\n                (\\<lambda>x. C x \\<bind> (\\<lambda>y. {y + c + x}))))", "by (simp add: add.commute add.left_commute cong: sum.case_cong)"], ["", "section \\<open>Limits\\<close>"], ["", "text \\<open>\n  The following example shows that the combination of monad normalisation and regular ordered\n  rewriting is not necessarily confluent.\n\\<close>"], ["", "lemma \"do {a \\<leftarrow> A; b \\<leftarrow> A; Some (a \\<and> b, b)} =\n       do {a \\<leftarrow> A; b \\<leftarrow> A; Some (a \\<and> b, a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>a. A \\<bind> (\\<lambda>b. Some (a \\<and> b, b))) =\n    A \\<bind> (\\<lambda>a. A \\<bind> (\\<lambda>b. Some (a \\<and> b, a)))", "apply (simp add: conj_comms)?       \\<comment> \\<open>no progress made\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>a. A \\<bind> (\\<lambda>b. Some (a \\<and> b, b))) =\n    A \\<bind> (\\<lambda>a. A \\<bind> (\\<lambda>b. Some (a \\<and> b, a)))", "apply (rewrite option_bind_commute) \\<comment> \\<open>force a particular binder order\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>a. Some (a \\<and> y, y))) =\n    A \\<bind> (\\<lambda>a. A \\<bind> (\\<lambda>b. Some (a \\<and> b, a)))", "apply (simp only: conj_comms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The next example shows that even monad normalisation alone is not confluent because \n  the term ordering prevents the reordering of \\<open>f A\\<close> with \\<open>f B\\<close>.\n  But if we change \\<open>A\\<close> to \\<open>E\\<close>, then the reordering works as expected.\n\\<close>"], ["", "lemma\n  \"do {a \\<leftarrow> f A; b \\<leftarrow> f B; c \\<leftarrow> D b; d \\<leftarrow> f C; F a c d} = \n   do {b \\<leftarrow> f B; c \\<leftarrow> D b; a \\<leftarrow> f A; d \\<leftarrow> f C; F a c d}\"\n  for f :: \"'b \\<Rightarrow> 'a option\" and D :: \"'a \\<Rightarrow> 'a option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A \\<bind>\n    (\\<lambda>a.\n        f B \\<bind>\n        (\\<lambda>b. D b \\<bind> (\\<lambda>c. f C \\<bind> F a c))) =\n    f B \\<bind>\n    (\\<lambda>b.\n        D b \\<bind>\n        (\\<lambda>c. f A \\<bind> (\\<lambda>a. f C \\<bind> F a c)))", "apply(simp)? \\<comment> \\<open>no progress made\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f A \\<bind>\n    (\\<lambda>a.\n        f B \\<bind>\n        (\\<lambda>b. D b \\<bind> (\\<lambda>c. f C \\<bind> F a c))) =\n    f B \\<bind>\n    (\\<lambda>b.\n        D b \\<bind>\n        (\\<lambda>c. f A \\<bind> (\\<lambda>a. f C \\<bind> F a c)))", "apply(subst option_bind_commute, subst (2) option_bind_commute, rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  \"do {a \\<leftarrow> f E; b \\<leftarrow> f B; c \\<leftarrow> D b; d \\<leftarrow> f C; F a c d} = \n   do {b \\<leftarrow> f B; c \\<leftarrow> D b; a \\<leftarrow> f E; d \\<leftarrow> f C; F a c d}\"\n  for f :: \"'b \\<Rightarrow> 'a option\" and D :: \"'a \\<Rightarrow> 'a option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f E \\<bind>\n    (\\<lambda>a.\n        f B \\<bind>\n        (\\<lambda>b. D b \\<bind> (\\<lambda>c. f C \\<bind> F a c))) =\n    f B \\<bind>\n    (\\<lambda>b.\n        D b \\<bind>\n        (\\<lambda>c. f E \\<bind> (\\<lambda>a. f C \\<bind> F a c)))", "by simp"], ["", "end"], ["", "end"]]}