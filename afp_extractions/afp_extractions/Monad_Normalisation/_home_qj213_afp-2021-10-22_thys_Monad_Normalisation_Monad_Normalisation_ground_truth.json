{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Normalisation/Monad_Normalisation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Normalisation", "problem_names": ["lemmas [monad_rule] = Set.bind_bind", "lemma set_bind_commute [monad_rule]:\n  fixes A :: \"'a set\" and B :: \"'b set\"\n  shows \"A \\<bind> (\\<lambda>x. B \\<bind> C x) = B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))\"", "lemma set_return_bind [monad_rule]:\n  fixes A :: \"'a \\<Rightarrow> 'b set\"\n  shows \"{x} \\<bind> A = A x\"", "lemma set_bind_return [monad_rule]:\n  fixes A :: \"'a set\"\n  shows \"A \\<bind> (\\<lambda>x. {x}) = A\"", "lemmas [monad_rule] = Predicate.bind_bind Predicate.bind_single Predicate.single_bind", "lemma predicate_bind_commute [monad_rule]:\n  fixes A :: \"'a Predicate.pred\" and B :: \"'b Predicate.pred\"\n  shows \"A \\<bind> (\\<lambda>x. B \\<bind> C x) = B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))\"", "lemmas [monad_rule] = Option.bind_assoc Option.bind_lunit Option.bind_runit", "lemma option_bind_commute [monad_rule]:\n  fixes A :: \"'a option\" and B :: \"'b option\"\n  shows \"A \\<bind> (\\<lambda>x. B \\<bind> C x) = B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))\"", "lemmas [monad_rule] =\n  bind_assoc_pmf\n  bind_commute_pmf\n  bind_return_pmf\n  bind_return_pmf'", "lemmas [monad_rule] =\n  bind_spmf_assoc\n  bind_commute_spmf\n  bind_return_spmf\n  return_bind_spmf", "lemma bind_if [monad_distrib]:\n  \"f A (\\<lambda>x. if P then B x else C x) = (if P then f A B else f A C)\"", "lemma bind_case_prod [monad_distrib]:\n  \"f A (\\<lambda>x. case y of (a,b) \\<Rightarrow> B a b x) = (case y of (a,b) \\<Rightarrow> f A (B a b))\"", "lemma bind_case_sum [monad_distrib]:\n  \"f A (\\<lambda>x. case y of Inl a \\<Rightarrow> B a x | Inr a \\<Rightarrow> C a x) =\n    (case y of Inl a \\<Rightarrow> f A (B a) | Inr a \\<Rightarrow> f A (C a))\"", "lemma bind_case_option [monad_distrib]:\n  \"f A (\\<lambda>x. case y of Some a \\<Rightarrow> B a x | None \\<Rightarrow> C x) =\n    (case y of Some a \\<Rightarrow> f A (B a) | None \\<Rightarrow> f A C)\"", "lemma bind_case_list [monad_distrib]:\n  \"f A (\\<lambda>x. case y of [] \\<Rightarrow> B x | y # ys \\<Rightarrow> C y ys x) = (case y of [] \\<Rightarrow> f A B | y # ys \\<Rightarrow> f A (C y ys))\"", "lemma bind_case_nat [monad_distrib]:\n  \"f A (\\<lambda>x. case y of 0 \\<Rightarrow> B x | Suc n \\<Rightarrow> C n x) = (case y of 0 \\<Rightarrow> f A B | Suc n \\<Rightarrow> f A (C n))\""], "translations": [["", "lemmas [monad_rule] = Set.bind_bind"], ["", "lemma set_bind_commute [monad_rule]:\n  fixes A :: \"'a set\" and B :: \"'b set\"\n  shows \"A \\<bind> (\\<lambda>x. B \\<bind> C x) = B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>x. B \\<bind> C x) =\n    B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))", "unfolding Set.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Bex ((\\<lambda>x. {xa. Bex (C x ` B) ((\\<in>) xa)}) ` A)\n         ((\\<in>) x)} =\n    {x. Bex ((\\<lambda>y. {x. Bex ((\\<lambda>x. C x y) ` A) ((\\<in>) x)}) `\n             B)\n         ((\\<in>) x)}", "by auto"], ["", "lemma set_return_bind [monad_rule]:\n  fixes A :: \"'a \\<Rightarrow> 'b set\"\n  shows \"{x} \\<bind> A = A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<bind> A = A x", "unfolding Set.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa. Bex (A ` {x}) ((\\<in>) xa)} = A x", "by auto"], ["", "lemma set_bind_return [monad_rule]:\n  fixes A :: \"'a set\"\n  shows \"A \\<bind> (\\<lambda>x. {x}) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>x. {x}) = A", "unfolding Set.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Bex ((\\<lambda>x. {x}) ` A) ((\\<in>) x)} = A", "by auto"], ["", "lemmas [monad_rule] = Predicate.bind_bind Predicate.bind_single Predicate.single_bind"], ["", "lemma predicate_bind_commute [monad_rule]:\n  fixes A :: \"'a Predicate.pred\" and B :: \"'b Predicate.pred\"\n  shows \"A \\<bind> (\\<lambda>x. B \\<bind> C x) = B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>x. B \\<bind> C x) =\n    B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))", "by (intro pred_eqI) auto"], ["", "lemmas [monad_rule] = Option.bind_assoc Option.bind_lunit Option.bind_runit"], ["", "lemma option_bind_commute [monad_rule]:\n  fixes A :: \"'a option\" and B :: \"'b option\"\n  shows \"A \\<bind> (\\<lambda>x. B \\<bind> C x) = B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bind> (\\<lambda>x. B \\<bind> C x) =\n    B \\<bind> (\\<lambda>y. A \\<bind> (\\<lambda>x. C x y))", "by (cases A) auto"], ["", "lemmas [monad_rule] =\n  bind_assoc_pmf\n  bind_commute_pmf\n  bind_return_pmf\n  bind_return_pmf'"], ["", "lemmas [monad_rule] =\n  bind_spmf_assoc\n  bind_commute_spmf\n  bind_return_spmf\n  return_bind_spmf"], ["", "subsection \\<open>Distributive operators\\<close>"], ["", "lemma bind_if [monad_distrib]:\n  \"f A (\\<lambda>x. if P then B x else C x) = (if P then f A B else f A C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A (\\<lambda>x. if P then B x else C x) = (if P then f A B else f A C)", "by simp"], ["", "lemma bind_case_prod [monad_distrib]:\n  \"f A (\\<lambda>x. case y of (a,b) \\<Rightarrow> B a b x) = (case y of (a,b) \\<Rightarrow> f A (B a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A (\\<lambda>x. case y of (a, b) \\<Rightarrow> B a b x) =\n    (case y of (a, b) \\<Rightarrow> f A (B a b))", "by (simp split: prod.split)"], ["", "lemma bind_case_sum [monad_distrib]:\n  \"f A (\\<lambda>x. case y of Inl a \\<Rightarrow> B a x | Inr a \\<Rightarrow> C a x) =\n    (case y of Inl a \\<Rightarrow> f A (B a) | Inr a \\<Rightarrow> f A (C a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A (\\<lambda>x.\n            case y of Inl a \\<Rightarrow> B a x\n            | Inr a \\<Rightarrow> C a x) =\n    (case y of Inl a \\<Rightarrow> f A (B a)\n     | Inr a \\<Rightarrow> f A (C a))", "by (simp split: sum.split)"], ["", "lemma bind_case_option [monad_distrib]:\n  \"f A (\\<lambda>x. case y of Some a \\<Rightarrow> B a x | None \\<Rightarrow> C x) =\n    (case y of Some a \\<Rightarrow> f A (B a) | None \\<Rightarrow> f A C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A (\\<lambda>x.\n            case y of None \\<Rightarrow> C x | Some a \\<Rightarrow> B a x) =\n    (case y of None \\<Rightarrow> f A C | Some a \\<Rightarrow> f A (B a))", "by (simp split: option.split)"], ["", "lemma bind_case_list [monad_distrib]:\n  \"f A (\\<lambda>x. case y of [] \\<Rightarrow> B x | y # ys \\<Rightarrow> C y ys x) = (case y of [] \\<Rightarrow> f A B | y # ys \\<Rightarrow> f A (C y ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A (\\<lambda>x.\n            case y of [] \\<Rightarrow> B x\n            | y # ys \\<Rightarrow> C y ys x) =\n    (case y of [] \\<Rightarrow> f A B | y # ys \\<Rightarrow> f A (C y ys))", "by (simp split: list.split)"], ["", "lemma bind_case_nat [monad_distrib]:\n  \"f A (\\<lambda>x. case y of 0 \\<Rightarrow> B x | Suc n \\<Rightarrow> C n x) = (case y of 0 \\<Rightarrow> f A B | Suc n \\<Rightarrow> f A (C n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f A (\\<lambda>x.\n            case y of 0 \\<Rightarrow> B x | Suc n \\<Rightarrow> C n x) =\n    (case y of 0 \\<Rightarrow> f A B | Suc n \\<Rightarrow> f A (C n))", "by (simp split: nat.split)"], ["", "subsection \\<open>Setup of the normalisation simproc\\<close>"], ["", "ML_file \\<open>monad_normalisation.ML\\<close>"], ["", "simproc_setup monad_normalisation (\"f x y\") = \\<open>K Monad_Normalisation.normalise_step\\<close>"], ["", "declare [[simproc del: monad_normalisation]]"], ["", "text \\<open>\n  The following bundle enables normalisation of monadic expressions by the simplifier.\n  We use @{attribute monad_rule_internal} instead of \\<open>monad_rule[simp]\\<close> such that\n  the theorems in @{thm [source] monad_rule} get dynamically added to the simpset instead of\n  only those that are in there when the bundle is declared.\n\\<close>"], ["", "bundle monad_normalisation = [[simproc add: monad_normalisation, monad_rule_internal]]"], ["", "end"]]}