{"file_name": "/home/qj213/afp-2021-10-22/thys/Simplex/Linear_Poly_Maps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simplex", "problem_names": ["lemma [transfer_rule]: \"(((=) ===> (=)) ===> pcr_linear_poly ===> (=)) (=) pcr_linear_poly\"", "lemma [transfer_rule]: \"(pcr_fmap (=) (=) ===> pcr_linear_poly) (\\<lambda> f x. case f x of None \\<Rightarrow> 0 | Some x \\<Rightarrow> x) LinearPoly\"", "lemma certificate[code abstype]:\n  \"LinearPoly (linear_poly_map lp) = lp\"", "lemma [code abstract]:\n  \"linear_poly_map 0 = zero\"", "lemma lookup_add_monom:\n  \"get_var_coeff lp v + c \\<noteq> 0 \\<Longrightarrow>\n    fmlookup (add_monom c v lp) v = Some (get_var_coeff lp v + c)\"\n  \"get_var_coeff lp v + c = 0 \\<Longrightarrow>\n    fmlookup (add_monom c v lp) v = None\"\n  \"x \\<noteq> v \\<Longrightarrow> fmlookup (add_monom c v lp) x = fmlookup lp x\"", "lemma fmlookup_fold_not_mem: \"x \\<notin> set k1 \\<Longrightarrow>\n  fmlookup (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 k1) x\n    = fmlookup P2 x\"", "lemma [code abstract]:\n  \"linear_poly_map (p1 + p2) = add (linear_poly_map p1) (linear_poly_map p2)\"", "lemma [code abstract]:\n  \"linear_poly_map (r *R p) = scale r (linear_poly_map p)\"", "lemma coeff_code [code]:\n  \"coeff lp = get_var_coeff (linear_poly_map lp)\"", "lemma Var_code[code abstract]:\n  \"linear_poly_map (Var x) = set_var_coeff x 1 fmempty\"", "lemma vars_code[code]: \"vars lp = fset (fmdom (linear_poly_map lp))\"", "lemma vars_list_code[code]: \"vars_list lp = ordered_keys (linear_poly_map lp)\"", "lemma valuate_code[code]:  \"valuate lp val = (\n  let lpm = linear_poly_map lp\n  in sum_list (map (\\<lambda> x. (the (fmlookup lpm x)) *R (val x)) (vars_list lp)))\"", "lemma lp_monom_code[code]: \"linear_poly_map (lp_monom c x) = (if c = 0 then fmempty else fmupd x c fmempty)\""], "translations": [["", "lemma [transfer_rule]: \"(((=) ===> (=)) ===> pcr_linear_poly ===> (=)) (=) pcr_linear_poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (=)) ===> pcr_linear_poly ===> (=)) (=) pcr_linear_poly", "by(standard,auto simp: pcr_linear_poly_def cr_linear_poly_def rel_fun_def OO_def)"], ["", "lemma [transfer_rule]: \"(pcr_fmap (=) (=) ===> pcr_linear_poly) (\\<lambda> f x. case f x of None \\<Rightarrow> 0 | Some x \\<Rightarrow> x) LinearPoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_fmap (=) (=) ===> pcr_linear_poly)\n     (\\<lambda>f x.\n         case f x of None \\<Rightarrow> 0 | Some x \\<Rightarrow> x)\n     LinearPoly", "by (standard, transfer, auto simp:get_var_coeff_def fmap.pcr_cr_eq cr_fmap_def)"], ["", "lift_definition linear_poly_map :: \"linear_poly \\<Rightarrow> (var, rat) fmap\" is\n  \"\\<lambda> lp x. if lp x = 0 then None else Some (lp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       Abstract_Linear_Poly.inv fun \\<Longrightarrow>\n       finite (dom (\\<lambda>x. if fun x = 0 then None else Some (fun x)))", "by (auto simp: dom_def)"], ["", "lemma certificate[code abstype]:\n  \"LinearPoly (linear_poly_map lp) = lp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearPoly (linear_poly_map lp) = lp", "by (transfer, auto)"], ["", "text\\<open>Zero\\<close>"], ["", "definition zero :: \"(var, rat)fmap\" where \"zero = fmempty\""], ["", "lemma [code abstract]:\n  \"linear_poly_map 0 = zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map 0 = zero", "unfolding zero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map 0 = fmempty", "by (transfer, auto)"], ["", "text\\<open>Addition\\<close>"], ["", "definition add_monom :: \"rat \\<Rightarrow> var \\<Rightarrow> (var, rat) fmap \\<Rightarrow> (var, rat) fmap\" where\n  \"add_monom c v lp == set_var_coeff v (c + get_var_coeff lp v) lp\""], ["", "definition add :: \"(var, rat) fmap \\<Rightarrow> (var, rat) fmap \\<Rightarrow> (var, rat) fmap\" where\n  \"add lp1 lp2 = foldl (\\<lambda> lp v. add_monom (get_var_coeff lp1 v) v lp) lp2 (ordered_keys lp1)\""], ["", "lemma lookup_add_monom:\n  \"get_var_coeff lp v + c \\<noteq> 0 \\<Longrightarrow>\n    fmlookup (add_monom c v lp) v = Some (get_var_coeff lp v + c)\"\n  \"get_var_coeff lp v + c = 0 \\<Longrightarrow>\n    fmlookup (add_monom c v lp) v = None\"\n  \"x \\<noteq> v \\<Longrightarrow> fmlookup (add_monom c v lp) x = fmlookup lp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (get_var_coeff lp v + c \\<noteq> 0 \\<Longrightarrow>\n     fmlookup (add_monom c v lp) v = Some (get_var_coeff lp v + c)) &&&\n    (get_var_coeff lp v + c = 0 \\<Longrightarrow>\n     fmlookup (add_monom c v lp) v = None) &&&\n    (x \\<noteq> v \\<Longrightarrow>\n     fmlookup (add_monom c v lp) x = fmlookup lp x)", "unfolding add_monom_def get_var_coeff_def set_var_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case fmlookup lp v of None \\<Rightarrow> 0 | Some c \\<Rightarrow> c) +\n     c \\<noteq>\n     0 \\<Longrightarrow>\n     fmlookup\n      (if c +\n          (case fmlookup lp v of None \\<Rightarrow> 0\n           | Some c \\<Rightarrow> c) =\n          0\n       then fmdrop v lp\n       else fmupd v\n             (c +\n              (case fmlookup lp v of None \\<Rightarrow> 0\n               | Some c \\<Rightarrow> c))\n             lp)\n      v =\n     Some\n      ((case fmlookup lp v of None \\<Rightarrow> 0\n        | Some c \\<Rightarrow> c) +\n       c)) &&&\n    ((case fmlookup lp v of None \\<Rightarrow> 0 | Some c \\<Rightarrow> c) +\n     c =\n     0 \\<Longrightarrow>\n     fmlookup\n      (if c +\n          (case fmlookup lp v of None \\<Rightarrow> 0\n           | Some c \\<Rightarrow> c) =\n          0\n       then fmdrop v lp\n       else fmupd v\n             (c +\n              (case fmlookup lp v of None \\<Rightarrow> 0\n               | Some c \\<Rightarrow> c))\n             lp)\n      v =\n     None) &&&\n    (x \\<noteq> v \\<Longrightarrow>\n     fmlookup\n      (if c +\n          (case fmlookup lp v of None \\<Rightarrow> 0\n           | Some c \\<Rightarrow> c) =\n          0\n       then fmdrop v lp\n       else fmupd v\n             (c +\n              (case fmlookup lp v of None \\<Rightarrow> 0\n               | Some c \\<Rightarrow> c))\n             lp)\n      x =\n     fmlookup lp x)", "by auto"], ["", "lemma fmlookup_fold_not_mem: \"x \\<notin> set k1 \\<Longrightarrow>\n  fmlookup (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 k1) x\n    = fmlookup P2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set k1 \\<Longrightarrow>\n    fmlookup\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 k1) x =\n    fmlookup P2 x", "by (induct k1 arbitrary: P2, auto simp: lookup_add_monom)"], ["", "lemma [code abstract]:\n  \"linear_poly_map (p1 + p2) = add (linear_poly_map p1) (linear_poly_map p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (p1 + p2) =\n    add (linear_poly_map p1) (linear_poly_map p2)", "proof (rule fmap_ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "fix x :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "(* index *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "let ?p1 = \"fmlookup (linear_poly_map p1) x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "let ?p2 = \"fmlookup (linear_poly_map p2) x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "define P1 where \"P1 = linear_poly_map p1\""], ["proof (state)\nthis:\n  P1 = linear_poly_map p1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "define P2 where \"P2 = linear_poly_map p2\""], ["proof (state)\nthis:\n  P2 = linear_poly_map p2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "define k1 where \"k1 = ordered_keys P1\""], ["proof (state)\nthis:\n  k1 = ordered_keys P1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "have k1: \"distinct k1 \\<and> fset (fmdom P1) = set k1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct k1 \\<and> fset (fmdom P1) = set k1", "unfolding k1_def P1_def ordered_keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_list_of_set (fset (fmdom (linear_poly_map p1)))) \\<and>\n    fset (fmdom (linear_poly_map p1)) =\n    set (sorted_list_of_set (fset (fmdom (linear_poly_map p1))))", "by auto"], ["proof (state)\nthis:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "have id: \"fmlookup (linear_poly_map (p1 + p2)) x = (case ?p1 of None \\<Rightarrow> ?p2 | Some y1 \\<Rightarrow>\n    (case ?p2 of None \\<Rightarrow> Some y1 | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (linear_poly_map (p1 + p2)) x =\n    (case fmlookup (linear_poly_map p1) x of\n     None \\<Rightarrow> fmlookup (linear_poly_map p2) x\n     | Some y1 \\<Rightarrow>\n         case fmlookup (linear_poly_map p2) x of None \\<Rightarrow> Some y1\n         | Some y2 \\<Rightarrow>\n             if y1 + y2 = 0 then None else Some (y1 + y2))", "by (transfer, auto)"], ["proof (state)\nthis:\n  fmlookup (linear_poly_map (p1 + p2)) x =\n  (case fmlookup (linear_poly_map p1) x of\n   None \\<Rightarrow> fmlookup (linear_poly_map p2) x\n   | Some y1 \\<Rightarrow>\n       case fmlookup (linear_poly_map p2) x of None \\<Rightarrow> Some y1\n       | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "show \"fmlookup (linear_poly_map (p1 + p2)) x = fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "proof (cases \"fmlookup P1 x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fmlookup P1 x = None \\<Longrightarrow>\n    fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n 2. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "case None"], ["proof (state)\nthis:\n  fmlookup P1 x = None\n\ngoal (2 subgoals):\n 1. fmlookup P1 x = None \\<Longrightarrow>\n    fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n 2. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "from fmdom_notI[OF None]"], ["proof (chain)\npicking this:\n  x |\\<notin>| fmdom P1", "have \"x \\<notin> fset (fmdom P1)\""], ["proof (prove)\nusing this:\n  x |\\<notin>| fmdom P1\n\ngoal (1 subgoal):\n 1. x \\<notin> fset (fmdom P1)", "by (meson notin_fset)"], ["proof (state)\nthis:\n  x \\<notin> fset (fmdom P1)\n\ngoal (2 subgoals):\n 1. fmlookup P1 x = None \\<Longrightarrow>\n    fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n 2. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "with k1"], ["proof (chain)\npicking this:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n  x \\<notin> fset (fmdom P1)", "have x: \"x \\<notin> set k1\""], ["proof (prove)\nusing this:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n  x \\<notin> fset (fmdom P1)\n\ngoal (1 subgoal):\n 1. x \\<notin> set k1", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set k1\n\ngoal (2 subgoals):\n 1. fmlookup P1 x = None \\<Longrightarrow>\n    fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n 2. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "unfolding id P1_def[symmetric] P2_def[symmetric] None"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> fmlookup P2 x\n     | Some y1 \\<Rightarrow>\n         case fmlookup P2 x of None \\<Rightarrow> Some y1\n         | Some y2 \\<Rightarrow>\n             if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup (add P1 P2) x", "unfolding add_def k1_def[symmetric] fmlookup_fold_not_mem[OF x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> fmlookup P2 x\n     | Some y1 \\<Rightarrow>\n         case fmlookup P2 x of None \\<Rightarrow> Some y1\n         | Some y2 \\<Rightarrow>\n             if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup P2 x", "by auto"], ["proof (state)\nthis:\n  fmlookup (linear_poly_map (p1 + p2)) x =\n  fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "case (Some y1)"], ["proof (state)\nthis:\n  fmlookup P1 x = Some y1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "from fmdomI[OF this]"], ["proof (chain)\npicking this:\n  x |\\<in>| fmdom P1", "have \"x \\<in> fset (fmdom P1)\""], ["proof (prove)\nusing this:\n  x |\\<in>| fmdom P1\n\ngoal (1 subgoal):\n 1. x \\<in> fset (fmdom P1)", "by (meson notin_fset)"], ["proof (state)\nthis:\n  x \\<in> fset (fmdom P1)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "with k1"], ["proof (chain)\npicking this:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n  x \\<in> fset (fmdom P1)", "have \"x \\<in> set k1\""], ["proof (prove)\nusing this:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n  x \\<in> fset (fmdom P1)\n\ngoal (1 subgoal):\n 1. x \\<in> set k1", "by auto"], ["proof (state)\nthis:\n  x \\<in> set k1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. k1 = ys @ x # zs", "obtain bef aft where k1_id: \"k1 = bef @ x # aft\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. k1 = ys @ x # zs\n\ngoal (1 subgoal):\n 1. (\\<And>bef aft.\n        k1 = bef @ x # aft \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k1 = bef @ x # aft\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "with k1"], ["proof (chain)\npicking this:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n  k1 = bef @ x # aft", "have x: \"x \\<notin> set bef\" \"x \\<notin> set aft\""], ["proof (prove)\nusing this:\n  distinct k1 \\<and> fset (fmdom P1) = set k1\n  k1 = bef @ x # aft\n\ngoal (1 subgoal):\n 1. x \\<notin> set bef &&& x \\<notin> set aft", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set bef\n  x \\<notin> set aft\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "have xy1: \"get_var_coeff P1 x = y1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_var_coeff P1 x = y1", "using Some"], ["proof (prove)\nusing this:\n  fmlookup P1 x = Some y1\n\ngoal (1 subgoal):\n 1. get_var_coeff P1 x = y1", "unfolding get_var_coeff_def"], ["proof (prove)\nusing this:\n  fmlookup P1 x = Some y1\n\ngoal (1 subgoal):\n 1. (case fmlookup P1 x of None \\<Rightarrow> 0 | Some c \\<Rightarrow> c) =\n    y1", "by auto"], ["proof (state)\nthis:\n  get_var_coeff P1 x = y1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "let ?P = \"foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup P1 x = Some a \\<Longrightarrow>\n       fmlookup (linear_poly_map (p1 + p2)) x =\n       fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (linear_poly_map (p1 + p2)) x =\n    fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x", "unfolding id P1_def[symmetric] P2_def[symmetric] Some option.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup (add P1 P2) x", "unfolding add_def k1_def[symmetric] k1_id foldl_append foldl_Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp)\n       (add_monom (get_var_coeff P1 x) x\n         (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2\n           bef))\n       aft)\n     x", "unfolding fmlookup_fold_not_mem[OF x(2)] xy1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "show \"(case fmlookup P2 x of None \\<Rightarrow> Some y1 | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2))\n        = fmlookup (add_monom y1 x ?P) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "proof (cases \"get_var_coeff ?P x + y1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 =\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x\n 2. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 \\<noteq>\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "case True"], ["proof (state)\nthis:\n  get_var_coeff\n   (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n  y1 =\n  0\n\ngoal (2 subgoals):\n 1. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 =\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x\n 2. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 \\<noteq>\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "from Some[unfolded P1_def]"], ["proof (chain)\npicking this:\n  fmlookup (linear_poly_map p1) x = Some y1", "have y1: \"y1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  fmlookup (linear_poly_map p1) x = Some y1\n\ngoal (1 subgoal):\n 1. y1 \\<noteq> 0", "by (transfer, auto split: if_splits)"], ["proof (state)\nthis:\n  y1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 =\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x\n 2. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 \\<noteq>\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "then"], ["proof (chain)\npicking this:\n  y1 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  y1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "unfolding lookup_add_monom(2)[OF True]"], ["proof (prove)\nusing this:\n  y1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    None", "using True"], ["proof (prove)\nusing this:\n  y1 \\<noteq> 0\n  get_var_coeff\n   (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n  y1 =\n  0\n\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    None", "unfolding get_var_coeff_def[of _ x] fmlookup_fold_not_mem[OF x(1)]"], ["proof (prove)\nusing this:\n  y1 \\<noteq> 0\n  (case fmlookup P2 x of None \\<Rightarrow> 0 | Some c \\<Rightarrow> c) +\n  y1 =\n  0\n\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    None", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  (case fmlookup P2 x of None \\<Rightarrow> Some y1\n   | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n  fmlookup\n   (add_monom y1 x\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n   x\n\ngoal (1 subgoal):\n 1. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 \\<noteq>\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 \\<noteq>\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "case False"], ["proof (state)\nthis:\n  get_var_coeff\n   (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n  y1 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. get_var_coeff\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n    y1 \\<noteq>\n    0 \\<Longrightarrow>\n    (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    fmlookup\n     (add_monom y1 x\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n     x", "unfolding lookup_add_monom(1)[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    Some\n     (get_var_coeff\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef)\n       x +\n      y1)", "using False"], ["proof (prove)\nusing this:\n  get_var_coeff\n   (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef) x +\n  y1 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    Some\n     (get_var_coeff\n       (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef)\n       x +\n      y1)", "unfolding get_var_coeff_def[of _ x] fmlookup_fold_not_mem[OF x(1)]"], ["proof (prove)\nusing this:\n  (case fmlookup P2 x of None \\<Rightarrow> 0 | Some c \\<Rightarrow> c) +\n  y1 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (case fmlookup P2 x of None \\<Rightarrow> Some y1\n     | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n    Some\n     ((case fmlookup P2 x of None \\<Rightarrow> 0\n       | Some c \\<Rightarrow> c) +\n      y1)", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  (case fmlookup P2 x of None \\<Rightarrow> Some y1\n   | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n  fmlookup\n   (add_monom y1 x\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case fmlookup P2 x of None \\<Rightarrow> Some y1\n   | Some y2 \\<Rightarrow> if y1 + y2 = 0 then None else Some (y1 + y2)) =\n  fmlookup\n   (add_monom y1 x\n     (foldl (\\<lambda>lp v. add_monom (get_var_coeff P1 v) v lp) P2 bef))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmlookup (linear_poly_map (p1 + p2)) x =\n  fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmlookup (linear_poly_map (p1 + p2)) x =\n  fmlookup (add (linear_poly_map p1) (linear_poly_map p2)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Scaling\\<close>"], ["", "definition scale :: \"rat \\<Rightarrow> (var, rat) fmap \\<Rightarrow> (var, rat) fmap\" where\n  \"scale r lp = (if r = 0 then fmempty else (fmmap ((*) r) lp))\""], ["", "lemma [code abstract]:\n  \"linear_poly_map (r *R p) = scale r (linear_poly_map p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = scale r (linear_poly_map p)", "proof (cases \"r = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "case True"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "then"], ["proof (chain)\npicking this:\n  r = 0", "have *: \"(r = 0) = True\""], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. (r = 0) = True", "by simp"], ["proof (state)\nthis:\n  (r = 0) = True\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = scale r (linear_poly_map p)", "unfolding scale_def * if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = fmempty", "using True"], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = fmempty", "by (transfer, auto)"], ["proof (state)\nthis:\n  linear_poly_map (r *R p) = scale r (linear_poly_map p)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "case False"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> 0", "have *: \"(r = 0) = False\""], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (r = 0) = False", "by simp"], ["proof (state)\nthis:\n  (r = 0) = False\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    linear_poly_map (r *R p) = scale r (linear_poly_map p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = scale r (linear_poly_map p)", "unfolding scale_def * if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = fmmap ((*) r) (linear_poly_map p)", "using False"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. linear_poly_map (r *R p) = fmmap ((*) r) (linear_poly_map p)", "by (transfer, auto)"], ["proof (state)\nthis:\n  linear_poly_map (r *R p) = scale r (linear_poly_map p)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Coeff *)"], ["", "lemma coeff_code [code]:\n  \"coeff lp = get_var_coeff (linear_poly_map lp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff lp = get_var_coeff (linear_poly_map lp)", "by (rule ext, unfold get_var_coeff_def, transfer, auto)"], ["", "(* Var *)"], ["", "lemma Var_code[code abstract]:\n  \"linear_poly_map (Var x) = set_var_coeff x 1 fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (Var x) = set_var_coeff x 1 fmempty", "unfolding set_var_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (Var x) =\n    (if 1 = 0 then fmdrop x fmempty else fmupd x 1 fmempty)", "by (transfer, auto split: if_splits simp: fun_eq_iff map_upd_def)"], ["", "(* vars *)"], ["", "lemma vars_code[code]: \"vars lp = fset (fmdom (linear_poly_map lp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars lp = fset (fmdom (linear_poly_map lp))", "by (transfer, auto simp: Transfer.Rel_def rel_fun_def pcr_fset_def cr_fset_def)"], ["", "(* vars_list *)"], ["", "lemma vars_list_code[code]: \"vars_list lp = ordered_keys (linear_poly_map lp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_list lp = ordered_keys (linear_poly_map lp)", "unfolding ordered_keys_def vars_code[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_list lp = sorted_list_of_set (vars lp)", "by (transfer, auto)"], ["", "(* valuate *)"], ["", "lemma valuate_code[code]:  \"valuate lp val = (\n  let lpm = linear_poly_map lp\n  in sum_list (map (\\<lambda> x. (the (fmlookup lpm x)) *R (val x)) (vars_list lp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<lbrace> val \\<rbrace> =\n    (let lpm = linear_poly_map lp\n     in \\<Sum>x\\<leftarrow>vars_list lp. the (fmlookup lpm x) *R val x)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<lbrace> val \\<rbrace> =\n    (\\<Sum>x\\<leftarrow>vars_list\n                         lp. the (fmlookup (linear_poly_map lp) x) *R val x)", "proof (subst sum_list_distinct_conv_sum_set)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (vars_list lp)\n 2. lp \\<lbrace> val \\<rbrace> =\n    (\\<Sum>x\\<in>set (vars_list lp).\n       the (fmlookup (linear_poly_map lp) x) *R val x)", "show \"distinct (vars_list lp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (vars_list lp)", "by (transfer, auto)"], ["proof (state)\nthis:\n  distinct (vars_list lp)\n\ngoal (1 subgoal):\n 1. lp \\<lbrace> val \\<rbrace> =\n    (\\<Sum>x\\<in>set (vars_list lp).\n       the (fmlookup (linear_poly_map lp) x) *R val x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lp \\<lbrace> val \\<rbrace> =\n    (\\<Sum>x\\<in>set (vars_list lp).\n       the (fmlookup (linear_poly_map lp) x) *R val x)", "show \"lp \\<lbrace> val \\<rbrace> =\n        (\\<Sum>x\\<in>set (vars_list lp). the (fmlookup (linear_poly_map lp) x) *R val x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<lbrace> val \\<rbrace> =\n    (\\<Sum>x\\<in>set (vars_list lp).\n       the (fmlookup (linear_poly_map lp) x) *R val x)", "unfolding set_vars_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<lbrace> val \\<rbrace> =\n    (\\<Sum>x\\<in>vars lp. the (fmlookup (linear_poly_map lp) x) *R val x)", "by (transfer, auto)"], ["proof (state)\nthis:\n  lp \\<lbrace> val \\<rbrace> =\n  (\\<Sum>x\\<in>set (vars_list lp).\n     the (fmlookup (linear_poly_map lp) x) *R val x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lp_monom_code[code]: \"linear_poly_map (lp_monom c x) = (if c = 0 then fmempty else fmupd x c fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_poly_map (lp_monom c x) =\n    (if c = 0 then fmempty else fmupd x c fmempty)", "proof (rule fmap_ext, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       fmlookup (linear_poly_map (lp_monom c x)) xa =\n       fmlookup (if c = 0 then fmempty else fmupd x c fmempty) xa", "case (1 y)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       fmlookup (linear_poly_map (lp_monom c x)) xa =\n       fmlookup (if c = 0 then fmempty else fmupd x c fmempty) xa", "include fmap.lifting"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       fmlookup (linear_poly_map (lp_monom c x)) xa =\n       fmlookup (if c = 0 then fmempty else fmupd x c fmempty) xa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (linear_poly_map (lp_monom c x)) y =\n    fmlookup (if c = 0 then fmempty else fmupd x c fmempty) y", "by (cases \"c = 0\", (transfer, auto)+)"], ["proof (state)\nthis:\n  fmlookup (linear_poly_map (lp_monom c x)) y =\n  fmlookup (if c = 0 then fmempty else fmupd x c fmempty) y\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation linear_poly :: equal\nbegin"], ["", "definition \"equal_linear_poly x y = (linear_poly_map x = linear_poly_map y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(linear_poly, equal_class)", "proof (standard, unfold equal_linear_poly_def, standard)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. linear_poly_map x = linear_poly_map y \\<Longrightarrow> x = y\n 2. \\<And>x y. x = y \\<Longrightarrow> linear_poly_map x = linear_poly_map y", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. linear_poly_map x = linear_poly_map y \\<Longrightarrow> x = y\n 2. \\<And>x y. x = y \\<Longrightarrow> linear_poly_map x = linear_poly_map y", "assume \"linear_poly_map x = linear_poly_map y\""], ["proof (state)\nthis:\n  linear_poly_map x = linear_poly_map y\n\ngoal (2 subgoals):\n 1. \\<And>x y. linear_poly_map x = linear_poly_map y \\<Longrightarrow> x = y\n 2. \\<And>x y. x = y \\<Longrightarrow> linear_poly_map x = linear_poly_map y", "from arg_cong[OF this, of LinearPoly, unfolded certificate]"], ["proof (chain)\npicking this:\n  x = y", "show \"x = y\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x = y \\<Longrightarrow> linear_poly_map x = linear_poly_map y", "qed auto"], ["", "end"], ["", "end"]]}