{"file_name": "/home/qj213/afp-2021-10-22/thys/Simplex/QDelta.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simplex", "problem_names": ["lemma [simp]: \"QDelta (qdfst qd) (qdsnd qd) = qd\"", "lemma [simp]: \"\\<lbrakk>QDelta.qdsnd x = QDelta.qdsnd y; QDelta.qdfst y = QDelta.qdfst x\\<rbrakk> \\<Longrightarrow> x = y\"", "lemma val_plus: \n  \"val (qd1 + qd2) \\<delta> = val qd1 \\<delta> + val qd2 \\<delta>\"", "lemma val_scaleRat:\n  \"val (c *R qd) \\<delta> = c * val qd \\<delta>\"", "lemma qdfst_setsum:\n  \"finite A \\<Longrightarrow> qdfst (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. qdfst (f x))\"", "lemma qdsnd_setsum:\n  \"finite A \\<Longrightarrow> qdsnd (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. qdsnd (f x))\"", "lemma valuate_valuate_rat:\n  \"lp \\<lbrace>(\\<lambda>v. (QDelta (vl v) 0))\\<rbrace> = QDelta (lp\\<lbrace>vl\\<rbrace>) 0\"", "lemma valuate_rat_valuate:\n  \"lp\\<lbrace>(\\<lambda>v. val (vl v) \\<delta>)\\<rbrace> = val (lp\\<lbrace>vl\\<rbrace>) \\<delta>\"", "lemma delta0:\n  assumes \"qd1 \\<le> qd2\"\n  shows \"\\<forall> \\<epsilon>. \\<epsilon> > 0 \\<and> \\<epsilon> \\<le> (\\<delta>0 qd1 qd2) \\<longrightarrow> val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>\"", "lemma delta_gt_zero:\n  \"\\<delta>_min l > 0\"", "lemma delta_le_one: \n  \"\\<delta>_min l \\<le> 1\"", "lemma delta_min_append:\n  \"\\<delta>_min (as @ bs) = min (\\<delta>_min as) (\\<delta>_min bs)\"", "lemma delta_min_mono: \"set as \\<subseteq> set bs \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min as\"", "lemma delta_min:\n  assumes \"\\<forall> qd1 qd2. (qd1, qd2) \\<in> set qd \\<longrightarrow> qd1 \\<le> qd2\"\n  shows \"\\<forall> \\<epsilon>. \\<epsilon> > 0 \\<and> \\<epsilon> \\<le> \\<delta>_min qd \\<longrightarrow> (\\<forall> qd1 qd2. (qd1, qd2) \\<in> set qd \\<longrightarrow> val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>)\"", "lemma QDelta_0_0: \"QDelta 0 0 = 0\"", "lemma qdsnd_0: \"qdsnd 0 = 0\"", "lemma qdfst_0: \"qdfst 0 = 0\""], "translations": [["", "lemma [simp]: \"QDelta (qdfst qd) (qdsnd qd) = qd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QDelta (qdfst qd) (qdsnd qd) = qd", "by (cases qd) auto"], ["", "lemma [simp]: \"\\<lbrakk>QDelta.qdsnd x = QDelta.qdsnd y; QDelta.qdfst y = QDelta.qdfst x\\<rbrakk> \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qdsnd x = qdsnd y; qdfst y = qdfst x\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (cases x) auto"], ["", "instantiation QDelta :: rational_vector\nbegin"], ["", "definition zero_QDelta :: \"QDelta\"\n  where\n    \"0 = QDelta 0 0\""], ["", "definition plus_QDelta :: \"QDelta \\<Rightarrow> QDelta \\<Rightarrow> QDelta\"\n  where\n    \"qd1 + qd2 = QDelta (qdfst qd1 + qdfst qd2) (qdsnd qd1 + qdsnd qd2)\""], ["", "definition minus_QDelta :: \"QDelta \\<Rightarrow> QDelta \\<Rightarrow> QDelta\"\n  where\n    \"qd1 - qd2 = QDelta (qdfst qd1 - qdfst qd2) (qdsnd qd1 - qdsnd qd2)\""], ["", "definition uminus_QDelta :: \"QDelta \\<Rightarrow> QDelta\"\n  where\n    \"- qd = QDelta (- (qdfst qd)) (- (qdsnd qd))\""], ["", "definition scaleRat_QDelta :: \"rat \\<Rightarrow> QDelta \\<Rightarrow> QDelta\"\n  where\n    \"r *R qd = QDelta (r*(qdfst qd)) (r*(qdsnd qd))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(QDelta, rational_vector_class)", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a\n 4. \\<And>a. - a + a = 0\n 5. \\<And>a b. a - b = a + - b\n 6. \\<And>a x y. a *R (x + y) = a *R x + a *R y\n 7. \\<And>a b x. (a + b) *R x = a *R x + b *R x\n 8. \\<And>a b x. a *R b *R x = (a * b) *R x\n 9. \\<And>x. 1 *R x = x", "qed (auto simp add: plus_QDelta_def zero_QDelta_def uminus_QDelta_def minus_QDelta_def scaleRat_QDelta_def field_simps)"], ["", "end"], ["", "instantiation QDelta :: linorder\nbegin"], ["", "definition less_eq_QDelta :: \"QDelta \\<Rightarrow> QDelta \\<Rightarrow> bool\"\n  where\n    \"qd1 \\<le> qd2 \\<longleftrightarrow> (qdfst qd1 < qdfst qd2) \\<or> (qdfst qd1 = qdfst qd2 \\<and> qdsnd qd1 \\<le> qdsnd qd2)\""], ["", "definition less_QDelta :: \"QDelta \\<Rightarrow> QDelta \\<Rightarrow> bool\"\n  where\n    \"qd1 < qd2 \\<longleftrightarrow> (qdfst qd1 < qdfst qd2) \\<or> (qdfst qd1 = qdfst qd2 \\<and> qdsnd qd1 < qdsnd qd2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(QDelta, linorder_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "qed (auto simp add: less_QDelta_def less_eq_QDelta_def)"], ["", "end"], ["", "instantiation QDelta:: linordered_rational_vector\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(QDelta, linordered_rational_vector_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a < b \\<Longrightarrow> a + c < b + c\n 2. \\<And>a b k.\n       \\<lbrakk>a < b; 0 < k\\<rbrakk> \\<Longrightarrow> k *R a < k *R b\n 3. \\<And>a b k.\n       \\<lbrakk>a < b; k < 0\\<rbrakk> \\<Longrightarrow> k *R b < k *R a", "qed (auto simp add: plus_QDelta_def less_QDelta_def scaleRat_QDelta_def mult_strict_left_mono mult_strict_left_mono_neg)"], ["", "end"], ["", "instantiation QDelta :: lrv\nbegin"], ["", "definition one_QDelta where\n  \"one_QDelta = QDelta 1 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(QDelta, lrv_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "qed (auto simp add: one_QDelta_def zero_QDelta_def)"], ["", "end"], ["", "definition \\<delta>0 :: \"QDelta \\<Rightarrow> QDelta \\<Rightarrow> rat\"\n  where\n    \"\\<delta>0 qd1 qd2 ==\n    let c1 = qdfst qd1; c2 = qdfst qd2; k1 = qdsnd qd1; k2 = qdsnd qd2 in\n      (if (c1 < c2 \\<and> k1 > k2) then \n              (c2 - c1) / (k1 - k2) \n       else\n               1\n       )\n    \""], ["", "definition val :: \"QDelta \\<Rightarrow> rat \\<Rightarrow> rat\"\n  where \"val qd \\<delta> = (qdfst qd) + \\<delta> * (qdsnd qd)\""], ["", "lemma val_plus: \n  \"val (qd1 + qd2) \\<delta> = val qd1 \\<delta> + val qd2 \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (qd1 + qd2) \\<delta> = val qd1 \\<delta> + val qd2 \\<delta>", "by (simp add: field_simps val_def plus_QDelta_def)"], ["", "lemma val_scaleRat:\n  \"val (c *R qd) \\<delta> = c * val qd \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (c *R qd) \\<delta> = c * val qd \\<delta>", "by (simp add: field_simps val_def scaleRat_QDelta_def)"], ["", "lemma qdfst_setsum:\n  \"finite A \\<Longrightarrow> qdfst (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. qdfst (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    qdfst (sum f A) = (\\<Sum>x\\<in>A. qdfst (f x))", "by (induct A rule: finite_induct) (auto simp add: zero_QDelta_def plus_QDelta_def)"], ["", "lemma qdsnd_setsum:\n  \"finite A \\<Longrightarrow> qdsnd (\\<Sum>x\\<in>A. f x) = (\\<Sum>x\\<in>A. qdsnd (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    qdsnd (sum f A) = (\\<Sum>x\\<in>A. qdsnd (f x))", "by (induct A rule: finite_induct) (auto simp add: zero_QDelta_def plus_QDelta_def)"], ["", "lemma valuate_valuate_rat:\n  \"lp \\<lbrace>(\\<lambda>v. (QDelta (vl v) 0))\\<rbrace> = QDelta (lp\\<lbrace>vl\\<rbrace>) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<lbrace> \\<lambda>v. QDelta (vl v) 0 \\<rbrace> =\n    QDelta lp \\<lbrace> vl \\<rbrace> 0", "using Rep_linear_poly"], ["proof (prove)\nusing this:\n  Rep_linear_poly ?x \\<in> {c. Abstract_Linear_Poly.inv c}\n\ngoal (1 subgoal):\n 1. lp \\<lbrace> \\<lambda>v. QDelta (vl v) 0 \\<rbrace> =\n    QDelta lp \\<lbrace> vl \\<rbrace> 0", "by (simp add: valuate_def scaleRat_QDelta_def qdsnd_setsum qdfst_setsum)"], ["", "lemma valuate_rat_valuate:\n  \"lp\\<lbrace>(\\<lambda>v. val (vl v) \\<delta>)\\<rbrace> = val (lp\\<lbrace>vl\\<rbrace>) \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<lbrace> \\<lambda>v. val (vl v) \\<delta> \\<rbrace> =\n    val lp \\<lbrace> vl \\<rbrace> \\<delta>", "unfolding valuate_def val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun Rep_linear_poly id fun_valuate lp\n     (\\<lambda>v. qdfst (vl v) + \\<delta> * qdsnd (vl v)) =\n    qdfst (map_fun Rep_linear_poly id fun_valuate lp vl) +\n    \\<delta> * qdsnd (map_fun Rep_linear_poly id fun_valuate lp vl)", "using rational_vector.scale_sum_right[of \\<delta> \"\\<lambda>x. Rep_linear_poly lp x * qdsnd (vl x)\" \"{v :: nat. Rep_linear_poly lp v \\<noteq> (0 :: rat)}\"]"], ["proof (prove)\nusing this:\n  \\<delta> *R\n  (\\<Sum>x\\<in>{v. Rep_linear_poly lp v \\<noteq> 0}.\n     Rep_linear_poly lp x * qdsnd (vl x)) =\n  (\\<Sum>x\\<in>{v. Rep_linear_poly lp v \\<noteq> 0}.\n     \\<delta> *R (Rep_linear_poly lp x * qdsnd (vl x)))\n\ngoal (1 subgoal):\n 1. map_fun Rep_linear_poly id fun_valuate lp\n     (\\<lambda>v. qdfst (vl v) + \\<delta> * qdsnd (vl v)) =\n    qdfst (map_fun Rep_linear_poly id fun_valuate lp vl) +\n    \\<delta> * qdsnd (map_fun Rep_linear_poly id fun_valuate lp vl)", "using Rep_linear_poly"], ["proof (prove)\nusing this:\n  \\<delta> *R\n  (\\<Sum>x\\<in>{v. Rep_linear_poly lp v \\<noteq> 0}.\n     Rep_linear_poly lp x * qdsnd (vl x)) =\n  (\\<Sum>x\\<in>{v. Rep_linear_poly lp v \\<noteq> 0}.\n     \\<delta> *R (Rep_linear_poly lp x * qdsnd (vl x)))\n  Rep_linear_poly ?x \\<in> {c. Abstract_Linear_Poly.inv c}\n\ngoal (1 subgoal):\n 1. map_fun Rep_linear_poly id fun_valuate lp\n     (\\<lambda>v. qdfst (vl v) + \\<delta> * qdsnd (vl v)) =\n    qdfst (map_fun Rep_linear_poly id fun_valuate lp vl) +\n    \\<delta> * qdsnd (map_fun Rep_linear_poly id fun_valuate lp vl)", "by (auto simp add: field_simps sum.distrib qdfst_setsum qdsnd_setsum) (auto simp add: scaleRat_QDelta_def)"], ["", "lemma delta0:\n  assumes \"qd1 \\<le> qd2\"\n  shows \"\\<forall> \\<epsilon>. \\<epsilon> > 0 \\<and> \\<epsilon> \\<le> (\\<delta>0 qd1 qd2) \\<longrightarrow> val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>0 qd1 qd2 \\<longrightarrow>\n       val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>0 qd1 qd2 \\<longrightarrow>\n       val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>", "have \"\\<And> e c1 c2 k1 k2 :: rat. \\<lbrakk>e \\<ge> 0; c1 < c2; k1 \\<le> k2\\<rbrakk> \\<Longrightarrow> c1 + e*k1 \\<le> c2 + e*k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e c1 c2 k1 k2.\n       \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n       \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e c1 c2 k1 k2.\n       \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n       \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2", "fix e c1 c2 k1 k2 :: rat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e c1 c2 k1 k2.\n       \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n       \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2", "show \"\\<lbrakk>e \\<ge> 0; c1 < c2; k1 \\<le> k2\\<rbrakk> \\<Longrightarrow> c1 + e*k1 \\<le> c2 + e*k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n    \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2", "using mult_left_mono[of \"k1\" \"k2\" \"e\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>k1 \\<le> k2; 0 \\<le> e\\<rbrakk>\n  \\<Longrightarrow> e * k1 \\<le> e * k2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n    \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2", "using add_less_le_mono[of \"c1\" \"c2\" \"e*k1\" \"e*k2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>k1 \\<le> k2; 0 \\<le> e\\<rbrakk>\n  \\<Longrightarrow> e * k1 \\<le> e * k2\n  \\<lbrakk>c1 < c2; e * k1 \\<le> e * k2\\<rbrakk>\n  \\<Longrightarrow> c1 + e * k1 < c2 + e * k2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n    \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> e; c1 < c2; k1 \\<le> k2\\<rbrakk>\n  \\<Longrightarrow> c1 + e * k1 \\<le> c2 + e * k2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?e; ?c1.0 < ?c2.0; ?k1.0 \\<le> ?k2.0\\<rbrakk>\n  \\<Longrightarrow> ?c1.0 + ?e * ?k1.0 \\<le> ?c2.0 + ?e * ?k2.0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>0 qd1 qd2 \\<longrightarrow>\n       val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?e; ?c1.0 < ?c2.0; ?k1.0 \\<le> ?k2.0\\<rbrakk>\n  \\<Longrightarrow> ?c1.0 + ?e * ?k1.0 \\<le> ?c2.0 + ?e * ?k2.0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?e; ?c1.0 < ?c2.0; ?k1.0 \\<le> ?k2.0\\<rbrakk>\n  \\<Longrightarrow> ?c1.0 + ?e * ?k1.0 \\<le> ?c2.0 + ?e * ?k2.0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>0 qd1 qd2 \\<longrightarrow>\n       val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?e; ?c1.0 < ?c2.0; ?k1.0 \\<le> ?k2.0\\<rbrakk>\n  \\<Longrightarrow> ?c1.0 + ?e * ?k1.0 \\<le> ?c2.0 + ?e * ?k2.0\n  qd1 \\<le> qd2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>0 qd1 qd2 \\<longrightarrow>\n       val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>", "by (auto simp add: \\<delta>0_def val_def less_eq_QDelta_def Let_def field_simps mult_left_mono)"], ["proof (state)\nthis:\n  \\<forall>\\<epsilon>.\n     0 < \\<epsilon> \\<and>\n     \\<epsilon> \\<le> \\<delta>0 qd1 qd2 \\<longrightarrow>\n     val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec\n  \\<delta>_min ::\"(QDelta \\<times> QDelta) list \\<Rightarrow> rat\" where\n  \"\\<delta>_min [] = 1\" |\n  \"\\<delta>_min (h # t) = min (\\<delta>_min t) (\\<delta>0 (fst h) (snd h))\""], ["", "lemma delta_gt_zero:\n  \"\\<delta>_min l > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<delta>_min l", "by (induct l) (auto simp add: Let_def field_simps \\<delta>0_def)"], ["", "lemma delta_le_one: \n  \"\\<delta>_min l \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_min l \\<le> 1", "by (induct l, auto)"], ["", "lemma delta_min_append:\n  \"\\<delta>_min (as @ bs) = min (\\<delta>_min as) (\\<delta>_min bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_min (as @ bs) = min (\\<delta>_min as) (\\<delta>_min bs)", "by (induct as, insert delta_le_one[of bs], auto)"], ["", "lemma delta_min_mono: \"set as \\<subseteq> set bs \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set as \\<subseteq> set bs \\<Longrightarrow>\n    \\<delta>_min bs \\<le> \\<delta>_min as", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set bs \\<Longrightarrow>\n    \\<delta>_min bs \\<le> \\<delta>_min []\n 2. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set bs\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set bs \\<Longrightarrow>\n    \\<delta>_min bs \\<le> \\<delta>_min []\n 2. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> set bs", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> set bs\n\ngoal (1 subgoal):\n 1. \\<delta>_min bs \\<le> \\<delta>_min []", "using delta_le_one"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> set bs\n  \\<delta>_min ?l \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<delta>_min bs \\<le> \\<delta>_min []", "by simp"], ["proof (state)\nthis:\n  \\<delta>_min bs \\<le> \\<delta>_min []\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "case (Cons a as)"], ["proof (state)\nthis:\n  set as \\<subseteq> set bs \\<Longrightarrow>\n  \\<delta>_min bs \\<le> \\<delta>_min as\n  set (a # as) \\<subseteq> set bs\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "from Cons(2)"], ["proof (chain)\npicking this:\n  set (a # as) \\<subseteq> set bs", "have \"a \\<in> set bs\""], ["proof (prove)\nusing this:\n  set (a # as) \\<subseteq> set bs\n\ngoal (1 subgoal):\n 1. a \\<in> set bs", "by auto"], ["proof (state)\nthis:\n  a \\<in> set bs\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. bs = ys @ a # zs", "obtain bs1 bs2 where bs: \"bs = bs1 @ [a] @ bs2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. bs = ys @ a # zs\n\ngoal (1 subgoal):\n 1. (\\<And>bs1 bs2.\n        bs = bs1 @ [a] @ bs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bs = bs1 @ [a] @ bs2\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "have bs: \"\\<delta>_min bs = \\<delta>_min ([a] @ bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_min bs = \\<delta>_min ([a] @ bs)", "unfolding bs delta_min_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (\\<delta>_min bs1) (min (\\<delta>_min [a]) (\\<delta>_min bs2)) =\n    min (\\<delta>_min [a])\n     (min (\\<delta>_min bs1) (min (\\<delta>_min [a]) (\\<delta>_min bs2)))", "by auto"], ["proof (state)\nthis:\n  \\<delta>_min bs = \\<delta>_min ([a] @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>set as \\<subseteq> set bs \\<Longrightarrow>\n                \\<delta>_min bs \\<le> \\<delta>_min as;\n        set (a # as) \\<subseteq> set bs\\<rbrakk>\n       \\<Longrightarrow> \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_min bs \\<le> \\<delta>_min (a # as)", "unfolding bs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_min ([a] @ bs) \\<le> \\<delta>_min (a # as)", "using Cons(1-2)"], ["proof (prove)\nusing this:\n  set as \\<subseteq> set bs \\<Longrightarrow>\n  \\<delta>_min bs \\<le> \\<delta>_min as\n  set (a # as) \\<subseteq> set bs\n\ngoal (1 subgoal):\n 1. \\<delta>_min ([a] @ bs) \\<le> \\<delta>_min (a # as)", "by auto"], ["proof (state)\nthis:\n  \\<delta>_min bs \\<le> \\<delta>_min (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delta_min:\n  assumes \"\\<forall> qd1 qd2. (qd1, qd2) \\<in> set qd \\<longrightarrow> qd1 \\<le> qd2\"\n  shows \"\\<forall> \\<epsilon>. \\<epsilon> > 0 \\<and> \\<epsilon> \\<le> \\<delta>_min qd \\<longrightarrow> (\\<forall> qd1 qd2. (qd1, qd2) \\<in> set qd \\<longrightarrow> val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>_min qd \\<longrightarrow>\n       (\\<forall>qd1 qd2.\n           (qd1, qd2) \\<in> set qd \\<longrightarrow>\n           val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>qd1 qd2. (qd1, qd2) \\<in> set qd \\<longrightarrow> qd1 \\<le> qd2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>_min qd \\<longrightarrow>\n       (\\<forall>qd1 qd2.\n           (qd1, qd2) \\<in> set qd \\<longrightarrow>\n           val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>)", "using delta0"], ["proof (prove)\nusing this:\n  \\<forall>qd1 qd2. (qd1, qd2) \\<in> set qd \\<longrightarrow> qd1 \\<le> qd2\n  ?qd1.0 \\<le> ?qd2.0 \\<Longrightarrow>\n  \\<forall>\\<epsilon>.\n     0 < \\<epsilon> \\<and>\n     \\<epsilon> \\<le> \\<delta>0 ?qd1.0 ?qd2.0 \\<longrightarrow>\n     val ?qd1.0 \\<epsilon> \\<le> val ?qd2.0 \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>.\n       0 < \\<epsilon> \\<and>\n       \\<epsilon> \\<le> \\<delta>_min qd \\<longrightarrow>\n       (\\<forall>qd1 qd2.\n           (qd1, qd2) \\<in> set qd \\<longrightarrow>\n           val qd1 \\<epsilon> \\<le> val qd2 \\<epsilon>)", "by (induct qd, auto)"], ["", "lemma QDelta_0_0: \"QDelta 0 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QDelta 0 0 = 0", "by code_simp"], ["", "lemma qdsnd_0: \"qdsnd 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qdsnd 0 = 0", "by code_simp"], ["", "lemma qdfst_0: \"qdfst 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qdfst 0 = 0", "by code_simp"], ["", "end"]]}