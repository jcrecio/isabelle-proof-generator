{"file_name": "/home/qj213/afp-2021-10-22/thys/Simplex/Simplex_Incremental.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simplex", "problem_names": ["lemma assert_all_s_ok: \"invariant_s t as s \\<Longrightarrow> assert_all_s bs s = Inr s' \\<Longrightarrow> \n    invariant_s t (set bs \\<union> as) s'\"", "lemma assert_all_s_unsat: \"invariant_s t as s \\<Longrightarrow> assert_all_s bs s = Unsat I \\<Longrightarrow> \n   minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set bs)\"", "lemma invariant_sD: assumes \"invariant_s t as s\" \n  shows \"\\<not> \\<U> s\" \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\" \"\\<triangle> (\\<T> s)\" \"\\<nabla> s\" \"\\<diamond> s\"  \n    \"Simplex.flat as \\<doteq> \\<B> s\" \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\" \"index_valid as s\"\n    \"(\\<forall> v :: (var \\<Rightarrow> 'a). v \\<Turnstile>\\<^sub>t \\<T> s \\<longleftrightarrow> v \\<Turnstile>\\<^sub>t t)\"", "lemma minimal_unsat_state_core_translation: assumes \n  unsat: \"minimal_unsat_state_core (s :: ('i,'a::lrv)state)\" and\n  tabl: \"\\<forall>(v :: 'a valuation). v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\" and\n  index: \"index_valid as s\" and\n  imp: \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\" and\n  I: \"I = the (\\<U>\\<^sub>c s)\" \nshows \"minimal_unsat_core_tabl_atoms (set I) t as\"", "lemma incremental_atom_ops: \"Incremental_Atom_Ops \n  init assert_s check_s \\<V> checkpoint_s backtrack_s \\<triangle> invariant_s checked_s\"", "lemma list_map_to_fun_create_map: \"set (list_map_to_fun (create_map ias) i) = set ias \\<inter> {i} \\<times> UNIV\"", "lemma i_satisfies_atom_set_inter_right: \"((I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s (ats \\<inter> (J \\<times> UNIV))) \\<longleftrightarrow> ((I \\<inter> J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s ats)\"", "lemma ns_constraints_ops: \"Incremental_NS_Constraint_Ops init_nsc (assert_nsc assert_all_s)\n  (check_nsc check_s) (solution_nsc solution_s) (checkpoint_nsc checkpoint_s) (backtrack_nsc backtrack_s)\n  invariant_nsc checked_nsc\"", "lemma case_sum_case_sum: \"(case (case x of Inl y \\<Rightarrow> Inl (f1 y) | Inr z \\<Rightarrow> Inr (f2 z)) \n  of Inl y \\<Rightarrow> Inl (g1 y) | Inr z \\<Rightarrow> Inr (g2 z)) = (case x of Inl y \\<Rightarrow> Inl (g1 (f1 y)) | Inr z \\<Rightarrow> Inr (g2 (f2 z)))\"", "lemmas code_lemmas =\n  fun_cong[OF init_simplex'_def, of cs for cs, unfolded init_cs_def \n    Incremental_Atom_Ops_For_NS_Constraint_Ops_Default.init_nsc_def]\n  fun_cong[OF fun_cong[OF assert_simplex'_def], of i \"(cs,((asi,tv,ui),s))\" for i cs asi tv ui s, \n    unfolded assert_cs.simps assert_nsc_code_def assert_nsc_def case_sum_case_sum split]\n  fun_cong[OF check_simplex'_def, of \"(cs,(asi_tv,s))\" for cs asi_tv s, \n    unfolded check_cs_def check_nsc_code_def check_nsc_def sum_wrap.simps case_sum_case_sum] \n  fun_cong[OF solution_simplex'_def, of \"(cs,((asi,tv),s))\" for cs asi tv s, \n    unfolded solution_cs.simps solution_nsc_code_def solution_nsc.simps]\n  fun_cong[OF checkpoint_simplex'_def, of \"(cs,(asi_tv,s))\" for cs asi_tv s,\n    unfolded checkpoint_nsc_code_def checkpoint_cs.simps checkpoint_nsc.simps]\n  fun_cong[OF fun_cong[OF backtrack_simplex'_def], of c \"(cs,(asi_tv,s))\" for c cs asi_tv s,\n    unfolded backtrack_nsc_code_def backtrack_nsc.simps backtrack_cs.simps]", "lemma init_simplex': \"init_simplex cs = Simplex_State (init_simplex' cs)\"", "lemma assert_simplex': \"assert_simplex i (Simplex_State s) = map_sum id Simplex_State (assert_simplex' i s)\"", "lemma check_simplex': \"check_simplex (Simplex_State s) = map_sum id Simplex_State (check_simplex' s)\"", "lemma solution_simplex': \"solution_simplex (Simplex_State s) = solution_simplex' s\"", "lemma checkpoint_simplex': \"checkpoint_simplex (Simplex_State s) = Simplex_Checkpoint (checkpoint_simplex' s)\"", "lemma backtrack_simplex': \"backtrack_simplex (Simplex_Checkpoint c) (Simplex_State s) = Simplex_State (backtrack_simplex' c s)\"", "lemma init_simplex: \"checked_simplex cs {} (init_simplex cs)\"", "lemma assert_simplex_ok:\n  \"invariant_simplex cs J s \\<Longrightarrow> assert_simplex j s = Inr s' \\<Longrightarrow> invariant_simplex cs (insert j J) s'\"", "lemma assert_simplex_unsat:\n  \"invariant_simplex cs J s \\<Longrightarrow> assert_simplex j s = Inl I \\<Longrightarrow> \n     set I \\<subseteq> insert j J \\<and> minimal_unsat_core (set I) cs\"", "lemma check_simplex_ok:\n  \"invariant_simplex cs J s \\<Longrightarrow> check_simplex s = Inr s' \\<Longrightarrow> checked_simplex cs J s'\"", "lemma check_simplex_unsat:\n  \"invariant_simplex cs J s \\<Longrightarrow> check_simplex s = Unsat I \\<Longrightarrow> \n     set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\"", "lemma solution_simplex:\n  \"checked_simplex cs J s \\<Longrightarrow> solution_simplex s = v \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\"", "lemma backtrack_simplex:\n  \"checked_simplex cs J s \\<Longrightarrow>\n   checkpoint_simplex s = c \\<Longrightarrow>\n   invariant_simplex cs K s' \\<Longrightarrow> \n   backtrack_simplex c s' = s'' \\<Longrightarrow> \n   J \\<subseteq> K \\<Longrightarrow> \n   invariant_simplex cs J s''\"", "lemma checked_invariant_simplex:\n  \"checked_simplex cs J s \\<Longrightarrow> invariant_simplex cs J s\"", "lemma assert_all_simplex_ok: \"invariant_simplex cs J s \\<Longrightarrow> assert_all_simplex K s = Inr s' \\<Longrightarrow> \n    invariant_simplex cs (J \\<union> set K) s'\"", "lemma assert_all_simplex_unsat: \"invariant_simplex cs J s \\<Longrightarrow> assert_all_simplex K s = Unsat I \\<Longrightarrow> \n    set I \\<subseteq> set K \\<union> J \\<and> minimal_unsat_core (set I) cs\"", "lemmas incremental_simplex = \n  init_simplex\n  assert_simplex_ok\n  assert_simplex_unsat\n  assert_all_simplex_ok\n  assert_all_simplex_unsat\n  check_simplex_ok\n  check_simplex_unsat\n  solution_simplex\n  backtrack_simplex\n  checked_invariant_simplex"], "translations": [["", "lemma assert_all_s_ok: \"invariant_s t as s \\<Longrightarrow> assert_all_s bs s = Inr s' \\<Longrightarrow> \n    invariant_s t (set bs \\<union> as) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_s t as s; assert_all_s bs s = Inr s'\\<rbrakk>\n    \\<Longrightarrow> invariant_s t (set bs \\<union> as) s'", "proof (induct bs arbitrary: s as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set [] \\<union> as) s'\n 2. \\<And>a bs s as.\n       \\<lbrakk>\\<And>s as.\n                   \\<lbrakk>invariant_s t as s;\n                    assert_all_s bs s = Inr s'\\<rbrakk>\n                   \\<Longrightarrow> invariant_s t (set bs \\<union> as) s';\n        invariant_s t as s; assert_all_s (a # bs) s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set (a # bs) \\<union> as) s'", "case (Cons b bs s as)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_s t ?as ?s; assert_all_s bs ?s = Inr s'\\<rbrakk>\n  \\<Longrightarrow> invariant_s t (set bs \\<union> ?as) s'\n  invariant_s t as s\n  assert_all_s (b # bs) s = Inr s'\n\ngoal (2 subgoals):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set [] \\<union> as) s'\n 2. \\<And>a bs s as.\n       \\<lbrakk>\\<And>s as.\n                   \\<lbrakk>invariant_s t as s;\n                    assert_all_s bs s = Inr s'\\<rbrakk>\n                   \\<Longrightarrow> invariant_s t (set bs \\<union> as) s';\n        invariant_s t as s; assert_all_s (a # bs) s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set (a # bs) \\<union> as) s'", "from Cons(3)"], ["proof (chain)\npicking this:\n  assert_all_s (b # bs) s = Inr s'", "obtain s'' where ass: \"assert_s b s = Inr s''\" and rec: \"assert_all_s bs s'' = Inr s'\""], ["proof (prove)\nusing this:\n  assert_all_s (b # bs) s = Inr s'\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>assert_s b s = Inr s'';\n         assert_all_s bs s'' = Inr s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  assert_s b s = Inr s''\n  assert_all_s bs s'' = Inr s'\n\ngoal (2 subgoals):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set [] \\<union> as) s'\n 2. \\<And>a bs s as.\n       \\<lbrakk>\\<And>s as.\n                   \\<lbrakk>invariant_s t as s;\n                    assert_all_s bs s = Inr s'\\<rbrakk>\n                   \\<Longrightarrow> invariant_s t (set bs \\<union> as) s';\n        invariant_s t as s; assert_all_s (a # bs) s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set (a # bs) \\<union> as) s'", "from Cons(1)[OF assert_s_ok[OF Cons(2) ass] rec]"], ["proof (chain)\npicking this:\n  invariant_s t (set bs \\<union> insert b as) s'", "show ?case"], ["proof (prove)\nusing this:\n  invariant_s t (set bs \\<union> insert b as) s'\n\ngoal (1 subgoal):\n 1. invariant_s t (set (b # bs) \\<union> as) s'", "by auto"], ["proof (state)\nthis:\n  invariant_s t (set (b # bs) \\<union> as) s'\n\ngoal (1 subgoal):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (set [] \\<union> as) s'", "qed auto"], ["", "lemma assert_all_s_unsat: \"invariant_s t as s \\<Longrightarrow> assert_all_s bs s = Unsat I \\<Longrightarrow> \n   minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_s t as s; assert_all_s bs s = Inl I\\<rbrakk>\n    \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                       (as \\<union> set bs)", "proof (induct bs arbitrary: s as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (as \\<union> set [])\n 2. \\<And>a bs s as.\n       \\<lbrakk>\\<And>s as.\n                   \\<lbrakk>invariant_s t as s;\n                    assert_all_s bs s = Inl I\\<rbrakk>\n                   \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n(as \\<union> set bs);\n        invariant_s t as s; assert_all_s (a # bs) s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (as \\<union> set (a # bs))", "case (Cons b bs s as)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_s t ?as ?s; assert_all_s bs ?s = Inl I\\<rbrakk>\n  \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                     (?as \\<union> set bs)\n  invariant_s t as s\n  assert_all_s (b # bs) s = Inl I\n\ngoal (2 subgoals):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (as \\<union> set [])\n 2. \\<And>a bs s as.\n       \\<lbrakk>\\<And>s as.\n                   \\<lbrakk>invariant_s t as s;\n                    assert_all_s bs s = Inl I\\<rbrakk>\n                   \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n(as \\<union> set bs);\n        invariant_s t as s; assert_all_s (a # bs) s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (as \\<union> set (a # bs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "proof (cases \"assert_s b s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_s b s = Inl a \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n 2. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "case unsat: (Inl J)"], ["proof (state)\nthis:\n  assert_s b s = Inl J\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_s b s = Inl a \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n 2. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>invariant_s t ?as ?s; assert_all_s bs ?s = Inl I\\<rbrakk>\n  \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                     (?as \\<union> set bs)\n  invariant_s t as s\n  assert_all_s (b # bs) s = Inl I\n  assert_s b s = Inl J", "have J: \"J = I\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_s t ?as ?s; assert_all_s bs ?s = Inl I\\<rbrakk>\n  \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                     (?as \\<union> set bs)\n  invariant_s t as s\n  assert_all_s (b # bs) s = Inl I\n  assert_s b s = Inl J\n\ngoal (1 subgoal):\n 1. J = I", "by auto"], ["proof (state)\nthis:\n  J = I\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_s b s = Inl a \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n 2. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "from assert_s_unsat[OF Cons(2) unsat] J"], ["proof (chain)\npicking this:\n  minimal_unsat_core_tabl_atoms (set J) t (insert b as)\n  J = I", "have min: \"minimal_unsat_core_tabl_atoms (set I) t (insert b as)\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set J) t (insert b as)\n  J = I\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (insert b as)", "by auto"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (insert b as)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_s b s = Inl a \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n 2. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "by (rule minimal_unsat_core_tabl_atoms_mono[OF _ min], auto)"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n\ngoal (1 subgoal):\n 1. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "case (Inr s')"], ["proof (state)\nthis:\n  assert_s b s = Inr s'\n\ngoal (1 subgoal):\n 1. \\<And>ba.\n       assert_s b s = Inr ba \\<Longrightarrow>\n       minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "from Cons(1)[OF assert_s_ok[OF Cons(2) Inr]] Cons(3) Inr"], ["proof (chain)\npicking this:\n  assert_all_s bs s' = Inl I \\<Longrightarrow>\n  minimal_unsat_core_tabl_atoms (set I) t (insert b as \\<union> set bs)\n  assert_all_s (b # bs) s = Inl I\n  assert_s b s = Inr s'", "show ?thesis"], ["proof (prove)\nusing this:\n  assert_all_s bs s' = Inl I \\<Longrightarrow>\n  minimal_unsat_core_tabl_atoms (set I) t (insert b as \\<union> set bs)\n  assert_all_s (b # bs) s = Inl I\n  assert_s b s = Inr s'\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))", "by auto"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (as \\<union> set (b # bs))\n\ngoal (1 subgoal):\n 1. \\<And>s as.\n       \\<lbrakk>invariant_s t as s; assert_all_s [] s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (as \\<union> set [])", "qed simp"], ["", "end"], ["", "text \\<open>Implementation of the interface via the Simplex operations init, check, and assert-bound.\\<close>"], ["", "locale Incremental_State_Ops_Simplex = AssertBoundNoLhs assert_bound + Init init + Check check\n  for assert_bound :: \"('i,'a::lrv) i_atom \\<Rightarrow> ('i,'a) state \\<Rightarrow> ('i,'a) state\" and\n    init :: \"tableau \\<Rightarrow> ('i,'a) state\" and\n    check :: \"('i,'a) state \\<Rightarrow> ('i,'a) state\"\nbegin"], ["", "definition invariant_s where \n  \"invariant_s t (as :: ('i,'a)i_atom set) s = \n    (\\<not> \\<U> s \\<and> \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s \\<and> \n     \\<triangle> (\\<T> s) \\<and> \n     \\<nabla> s \\<and> \n     \\<diamond> s \\<and> \n     (\\<forall> v :: (var \\<Rightarrow> 'a). v \\<Turnstile>\\<^sub>t \\<T> s \\<longleftrightarrow> v \\<Turnstile>\\<^sub>t t) \\<and>\n     index_valid as s \\<and>\n     Simplex.flat as \\<doteq> \\<B> s \\<and> \n     as \\<Turnstile>\\<^sub>i \\<B>\\<I> s)\""], ["", "definition checked_s where \n  \"checked_s t as s = (invariant_s t as s \\<and> \\<Turnstile> s)\""], ["", "definition assert_s where \"assert_s a s = (let s' = assert_bound a s in\n  if \\<U> s' then Inl (the (\\<U>\\<^sub>c s')) else Inr s')\""], ["", "definition check_s where \"check_s s = (let s' = check s in \n  if \\<U> s' then Inl (the (\\<U>\\<^sub>c s')) else Inr s')\""], ["", "definition checkpoint_s where \"checkpoint_s s = \\<B>\\<^sub>i s\""], ["", "fun backtrack_s where \"backtrack_s (bl, bu) (State t bl_old bu_old v u uc) = State t bl bu v u uc\""], ["", "lemma invariant_sD: assumes \"invariant_s t as s\" \n  shows \"\\<not> \\<U> s\" \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\" \"\\<triangle> (\\<T> s)\" \"\\<nabla> s\" \"\\<diamond> s\"  \n    \"Simplex.flat as \\<doteq> \\<B> s\" \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\" \"index_valid as s\"\n    \"(\\<forall> v :: (var \\<Rightarrow> 'a). v \\<Turnstile>\\<^sub>t \\<T> s \\<longleftrightarrow> v \\<Turnstile>\\<^sub>t t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<not> \\<U> s &&&\n      \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s) &&&\n     \\<triangle> (\\<T> s) &&& \\<nabla> s) &&&\n    (\\<diamond> s &&& (snd ` as) \\<doteq> \\<B> s) &&&\n    as \\<Turnstile>\\<^sub>i \\<B>\\<I> s &&&\n    index_valid as s &&&\n    \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "using assms"], ["proof (prove)\nusing this:\n  invariant_s t as s\n\ngoal (1 subgoal):\n 1. ((\\<not> \\<U> s &&&\n      \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s) &&&\n     \\<triangle> (\\<T> s) &&& \\<nabla> s) &&&\n    (\\<diamond> s &&& (snd ` as) \\<doteq> \\<B> s) &&&\n    as \\<Turnstile>\\<^sub>i \\<B>\\<I> s &&&\n    index_valid as s &&&\n    \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "unfolding invariant_s_def"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s \\<and>\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s \\<and>\n  \\<triangle> (\\<T> s) \\<and>\n  \\<nabla> s \\<and>\n  \\<diamond> s \\<and>\n  (\\<forall>v.\n      v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t) \\<and>\n  index_valid as s \\<and>\n  (snd ` as) \\<doteq> \\<B> s \\<and> as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. ((\\<not> \\<U> s &&&\n      \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s) &&&\n     \\<triangle> (\\<T> s) &&& \\<nabla> s) &&&\n    (\\<diamond> s &&& (snd ` as) \\<doteq> \\<B> s) &&&\n    as \\<Turnstile>\\<^sub>i \\<B>\\<I> s &&&\n    index_valid as s &&&\n    \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "by auto"], ["", "lemma minimal_unsat_state_core_translation: assumes \n  unsat: \"minimal_unsat_state_core (s :: ('i,'a::lrv)state)\" and\n  tabl: \"\\<forall>(v :: 'a valuation). v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\" and\n  index: \"index_valid as s\" and\n  imp: \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\" and\n  I: \"I = the (\\<U>\\<^sub>c s)\" \nshows \"minimal_unsat_core_tabl_atoms (set I) t as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t as", "unfolding minimal_unsat_core_tabl_atoms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set I \\<subseteq> fst ` as \\<and>\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>t t \\<and>\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as) \\<and>\n    (distinct_indices_atoms as \\<longrightarrow>\n     (\\<forall>J\\<subset>set I.\n         \\<exists>v.\n            v \\<Turnstile>\\<^sub>t t \\<and>\n            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s as))", "proof (intro conjI impI notI allI; (elim exE conjE)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. set I \\<subseteq> fst ` as\n 2. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from unsat[unfolded minimal_unsat_state_core_def]"], ["proof (chain)\npicking this:\n  unsat_state_core s \\<and>\n  (distinct_indices_state s \\<longrightarrow> subsets_sat_core s)", "have unsat: \"unsat_state_core s\" \n    and minimal: \"distinct_indices_state s \\<Longrightarrow> subsets_sat_core s\""], ["proof (prove)\nusing this:\n  unsat_state_core s \\<and>\n  (distinct_indices_state s \\<longrightarrow> subsets_sat_core s)\n\ngoal (1 subgoal):\n 1. unsat_state_core s &&&\n    (distinct_indices_state s \\<Longrightarrow> subsets_sat_core s)", "by auto"], ["proof (state)\nthis:\n  unsat_state_core s\n  distinct_indices_state s \\<Longrightarrow> subsets_sat_core s\n\ngoal (3 subgoals):\n 1. set I \\<subseteq> fst ` as\n 2. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from unsat[unfolded unsat_state_core_def I[symmetric]]"], ["proof (chain)\npicking this:\n  set I \\<subseteq> indices_state s \\<and>\n  (\\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s)", "have Is: \"set I \\<subseteq> indices_state s\" and unsat: \"(\\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s)\""], ["proof (prove)\nusing this:\n  set I \\<subseteq> indices_state s \\<and>\n  (\\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s)\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> indices_state s &&&\n    \\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> indices_state s\n  \\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s\n\ngoal (3 subgoals):\n 1. set I \\<subseteq> fst ` as\n 2. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from Is index"], ["proof (chain)\npicking this:\n  set I \\<subseteq> indices_state s\n  index_valid as s", "show \"set I \\<subseteq> fst ` as\""], ["proof (prove)\nusing this:\n  set I \\<subseteq> indices_state s\n  index_valid as s\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> fst ` as", "using index_valid_indices_state"], ["proof (prove)\nusing this:\n  set I \\<subseteq> indices_state s\n  index_valid as s\n  index_valid ?as ?s \\<Longrightarrow>\n  indices_state ?s \\<subseteq> fst ` ?as\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> fst ` as", "by blast"], ["proof (state)\nthis:\n  set I \\<subseteq> fst ` as\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "{"], ["proof (state)\nthis:\n  set I \\<subseteq> fst ` as\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "assume t: \"v \\<Turnstile>\\<^sub>t t\" and as: \"(set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\""], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>t t\n  (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from t tabl"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>t t\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "have t: \"v \\<Turnstile>\\<^sub>t \\<T> s\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t t\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>t \\<T> s", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>t \\<T> s\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>t \\<T> s", "have \"(set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t \\<T> s\n\ngoal (1 subgoal):\n 1. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s", "using as imp"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t \\<T> s\n  (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s", "using atoms_imply_bounds_index.simps satisfies_state_index.simps"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t \\<T> s\n  (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n  ?as \\<Turnstile>\\<^sub>i ?bi =\n  (\\<forall>I v.\n      (I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s ?as \\<longrightarrow>\n      (I, v) \\<Turnstile>\\<^sub>i\\<^sub>b ?bi)\n  (?I, ?v) \\<Turnstile>\\<^sub>i\\<^sub>s ?s =\n  (?v \\<Turnstile>\\<^sub>t \\<T> ?s \\<and>\n   (?I, ?v) \\<Turnstile>\\<^sub>i\\<^sub>b \\<B>\\<I> ?s)\n\ngoal (1 subgoal):\n 1. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s", "by blast"], ["proof (state)\nthis:\n  (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<Turnstile>\\<^sub>t t;\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "with unsat"], ["proof (chain)\npicking this:\n  \\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s\n  (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>v. (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s\n  (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>s s\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<Turnstile>\\<^sub>t t;\n   (set I, ?v2) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<Turnstile>\\<^sub>t t;\n   (set I, ?v2) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s as\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "fix J"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "assume dist: \"distinct_indices_atoms as\" \n      and J: \"J \\<subset> set I\""], ["proof (state)\nthis:\n  distinct_indices_atoms as\n  J \\<subset> set I\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from J Is"], ["proof (chain)\npicking this:\n  J \\<subset> set I\n  set I \\<subseteq> indices_state s", "have J': \"J \\<subseteq> indices_state s\""], ["proof (prove)\nusing this:\n  J \\<subset> set I\n  set I \\<subseteq> indices_state s\n\ngoal (1 subgoal):\n 1. J \\<subseteq> indices_state s", "by auto"], ["proof (state)\nthis:\n  J \\<subseteq> indices_state s\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from dist index"], ["proof (chain)\npicking this:\n  distinct_indices_atoms as\n  index_valid as s", "have \"distinct_indices_state s\""], ["proof (prove)\nusing this:\n  distinct_indices_atoms as\n  index_valid as s\n\ngoal (1 subgoal):\n 1. distinct_indices_state s", "by (metis index_valid_distinct_indices)"], ["proof (state)\nthis:\n  distinct_indices_state s\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "with minimal"], ["proof (chain)\npicking this:\n  distinct_indices_state s \\<Longrightarrow> subsets_sat_core s\n  distinct_indices_state s", "have \"subsets_sat_core s\""], ["proof (prove)\nusing this:\n  distinct_indices_state s \\<Longrightarrow> subsets_sat_core s\n  distinct_indices_state s\n\ngoal (1 subgoal):\n 1. subsets_sat_core s", "."], ["proof (state)\nthis:\n  subsets_sat_core s\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from this[unfolded subsets_sat_core_def I[symmetric], rule_format, OF J]"], ["proof (chain)\npicking this:\n  \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>s\\<^sub>e s", "obtain v where \"(J, v) \\<Turnstile>\\<^sub>i\\<^sub>s\\<^sub>e s\""], ["proof (prove)\nusing this:\n  \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>s\\<^sub>e s\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (J, v) \\<Turnstile>\\<^sub>i\\<^sub>s\\<^sub>e s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (J, v) \\<Turnstile>\\<^sub>i\\<^sub>s\\<^sub>e s\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>distinct_indices_atoms as; J \\<subset> set I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            v \\<Turnstile>\\<^sub>t t \\<and>\n                            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                            as", "from satisfying_state_valuation_to_atom_tabl[OF J' this index dist] tabl"], ["proof (chain)\npicking this:\n  (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s as\n  v \\<Turnstile>\\<^sub>t \\<T> s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "show \"\\<exists>v. v \\<Turnstile>\\<^sub>t t \\<and> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s as\""], ["proof (prove)\nusing this:\n  (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s as\n  v \\<Turnstile>\\<^sub>t \\<T> s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s as", "by blast"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and>\n     (J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s as\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distinct_indices_atoms as; ?J2 \\<subset> set I\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<Turnstile>\\<^sub>t t \\<and>\n                       (?J2, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n                       as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma incremental_atom_ops: \"Incremental_Atom_Ops \n  init assert_s check_s \\<V> checkpoint_s backtrack_s \\<triangle> invariant_s checked_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Incremental_Atom_Ops init assert_s check_s \\<V> checkpoint_s backtrack_s\n     \\<triangle> invariant_s checked_s", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case (1 t as s a s')"], ["proof (state)\nthis:\n  invariant_s t as s\n  assert_s a s = Inr s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* assert ok *)"], ["proof (state)\nthis:\n  invariant_s t as s\n  assert_s a s = Inr s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 1(2)[unfolded assert_s_def Let_def]"], ["proof (chain)\npicking this:\n  (if \\<U> (assert_bound a s)\n   then Inl (the (\\<U>\\<^sub>c (assert_bound a s)))\n   else Inr (assert_bound a s)) =\n  Inr s'", "have U: \"\\<not> \\<U> (assert_bound a s)\" and s': \"s' = assert_bound a s\""], ["proof (prove)\nusing this:\n  (if \\<U> (assert_bound a s)\n   then Inl (the (\\<U>\\<^sub>c (assert_bound a s)))\n   else Inr (assert_bound a s)) =\n  Inr s'\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (assert_bound a s) &&& s' = assert_bound a s", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  \\<not> \\<U> (assert_bound a s)\n  s' = assert_bound a s\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note * = invariant_sD[OF 1(1)]"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  (snd ` as) \\<doteq> \\<B> s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n  index_valid as s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_tableau_id[OF *(1-5)]"], ["proof (chain)\npicking this:\n  \\<T> (assert_bound ?a s) = \\<T> s", "have T: \"\\<T> s' = \\<T> s\""], ["proof (prove)\nusing this:\n  \\<T> (assert_bound ?a s) = \\<T> s\n\ngoal (1 subgoal):\n 1. \\<T> s' = \\<T> s", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<T> (assert_bound ?a s) = \\<T> s\n\ngoal (1 subgoal):\n 1. \\<T> (assert_bound a s) = \\<T> s", "by auto"], ["proof (state)\nthis:\n  \\<T> s' = \\<T> s\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from *(3,9)"], ["proof (chain)\npicking this:\n  \\<triangle> (\\<T> s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "have \"\\<triangle> (\\<T> s')\" \"\\<forall> v :: var \\<Rightarrow> 'a. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\""], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<triangle> (\\<T> s') &&&\n    \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t", "unfolding T"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<triangle> (\\<T> s) &&&\n    \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "by blast+"], ["proof (state)\nthis:\n  \\<triangle> (\\<T> s')\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<triangle> (\\<T> s')\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_sat[OF *(1-5) U]"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n   (assert_bound a s) \\<and>\n  \\<diamond> (assert_bound a s)", "have \" \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\" \"\\<diamond> s'\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n   (assert_bound a s) \\<and>\n  \\<diamond> (assert_bound a s)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s' &&&\n    \\<diamond> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n   (assert_bound a s) \\<and>\n  \\<diamond> (assert_bound a s)\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n     (assert_bound a s) &&&\n    \\<diamond> (assert_bound a s)", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_atoms_equiv_bounds[OF *(1-6), of a]"], ["proof (chain)\npicking this:\n  (snd ` (as \\<union> {a})) \\<doteq> \\<B> (assert_bound a s)", "have \"Simplex.flat (insert a as) \\<doteq> \\<B> s'\""], ["proof (prove)\nusing this:\n  (snd ` (as \\<union> {a})) \\<doteq> \\<B> (assert_bound a s)\n\ngoal (1 subgoal):\n 1. (snd ` insert a as) \\<doteq> \\<B> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  (snd ` (as \\<union> {a})) \\<doteq> \\<B> (assert_bound a s)\n\ngoal (1 subgoal):\n 1. (snd ` insert a as) \\<doteq> \\<B> (assert_bound a s)", "by auto"], ["proof (state)\nthis:\n  (snd ` insert a as) \\<doteq> \\<B> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  (snd ` insert a as) \\<doteq> \\<B> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_atoms_imply_bounds_index[OF *(1-5,7)]"], ["proof (chain)\npicking this:\n  insert ?a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound ?a s)", "have \"insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\""], ["proof (prove)\nusing this:\n  insert ?a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  insert ?a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound a s)", "."], ["proof (state)\nthis:\n  insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_tableau_valuated[OF *(1-5)]"], ["proof (chain)\npicking this:\n  \\<nabla> (assert_bound ?a s)", "have \"\\<nabla> s'\""], ["proof (prove)\nusing this:\n  \\<nabla> (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. \\<nabla> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<nabla> (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. \\<nabla> (assert_bound a s)", "."], ["proof (state)\nthis:\n  \\<nabla> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<nabla> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_index_valid[OF *(1-5,8)]"], ["proof (chain)\npicking this:\n  index_valid (insert ?a as) (assert_bound ?a s)", "have \"index_valid (insert a as) s'\""], ["proof (prove)\nusing this:\n  index_valid (insert ?a as) (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. index_valid (insert a as) s'", "unfolding s'"], ["proof (prove)\nusing this:\n  index_valid (insert ?a as) (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. index_valid (insert a as) (assert_bound a s)", "by auto"], ["proof (state)\nthis:\n  index_valid (insert a as) s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  index_valid (insert a as) s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from U s'"], ["proof (chain)\npicking this:\n  \\<not> \\<U> (assert_bound a s)\n  s' = assert_bound a s", "have \"\\<not> \\<U> s'\""], ["proof (prove)\nusing this:\n  \\<not> \\<U> (assert_bound a s)\n  s' = assert_bound a s\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> s'", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<U> s'\n\ngoal (8 subgoals):\n 1. \\<And>t as s a s'.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_s t (insert a as) s'\n 2. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 3. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 4. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 5. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 6. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 7. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 8. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "ultimately"], ["proof (chain)\npicking this:\n  \\<triangle> (\\<T> s')\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n  (snd ` insert a as) \\<doteq> \\<B> s'\n  insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  \\<nabla> s'\n  index_valid (insert a as) s'\n  \\<not> \\<U> s'", "show ?case"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s')\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n  (snd ` insert a as) \\<doteq> \\<B> s'\n  insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  \\<nabla> s'\n  index_valid (insert a as) s'\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. invariant_s t (insert a as) s'", "unfolding invariant_s_def"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s')\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n  (snd ` insert a as) \\<doteq> \\<B> s'\n  insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  \\<nabla> s'\n  index_valid (insert a as) s'\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> s' \\<and>\n    \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s' \\<and>\n    \\<triangle> (\\<T> s') \\<and>\n    \\<nabla> s' \\<and>\n    \\<diamond> s' \\<and>\n    (\\<forall>v.\n        v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t) \\<and>\n    index_valid (insert a as) s' \\<and>\n    (snd ` insert a as) \\<doteq> \\<B> s' \\<and>\n    insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'", "by auto"], ["proof (state)\nthis:\n  invariant_s t (insert a as) s'\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case (2 t as s a I)"], ["proof (state)\nthis:\n  invariant_s t as s\n  assert_s a s = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* assert unsat *)"], ["proof (state)\nthis:\n  invariant_s t as s\n  assert_s a s = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 2(2)[unfolded assert_s_def Let_def]"], ["proof (chain)\npicking this:\n  (if \\<U> (assert_bound a s)\n   then Inl (the (\\<U>\\<^sub>c (assert_bound a s)))\n   else Inr (assert_bound a s)) =\n  Inl I", "obtain s' where s': \"s' = assert_bound a s\" and U: \"\\<U> (assert_bound a s)\" \n    and I: \"I = the (\\<U>\\<^sub>c s')\""], ["proof (prove)\nusing this:\n  (if \\<U> (assert_bound a s)\n   then Inl (the (\\<U>\\<^sub>c (assert_bound a s)))\n   else Inr (assert_bound a s)) =\n  Inl I\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' = assert_bound a s; \\<U> (assert_bound a s);\n         I = the (\\<U>\\<^sub>c s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s' = assert_bound a s\n  \\<U> (assert_bound a s)\n  I = the (\\<U>\\<^sub>c s')\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note * = invariant_sD[OF 2(1)]"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  (snd ` as) \\<doteq> \\<B> s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n  index_valid as s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_tableau_id[OF *(1-5)]"], ["proof (chain)\npicking this:\n  \\<T> (assert_bound ?a s) = \\<T> s", "have T: \"\\<T> s' = \\<T> s\""], ["proof (prove)\nusing this:\n  \\<T> (assert_bound ?a s) = \\<T> s\n\ngoal (1 subgoal):\n 1. \\<T> s' = \\<T> s", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<T> (assert_bound ?a s) = \\<T> s\n\ngoal (1 subgoal):\n 1. \\<T> (assert_bound a s) = \\<T> s", "by auto"], ["proof (state)\nthis:\n  \\<T> s' = \\<T> s\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from *(3,9)"], ["proof (chain)\npicking this:\n  \\<triangle> (\\<T> s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "have tabl: \"\\<forall> v :: var \\<Rightarrow> 'a. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\""], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t", "unfolding T"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "by blast+"], ["proof (state)\nthis:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_unsat[OF *(1-5,8) U] s'"], ["proof (chain)\npicking this:\n  minimal_unsat_state_core (assert_bound a s)\n  s' = assert_bound a s", "have unsat: \"minimal_unsat_state_core s'\""], ["proof (prove)\nusing this:\n  minimal_unsat_state_core (assert_bound a s)\n  s' = assert_bound a s\n\ngoal (1 subgoal):\n 1. minimal_unsat_state_core s'", "by auto"], ["proof (state)\nthis:\n  minimal_unsat_state_core s'\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_index_valid[OF *(1-5,8)]"], ["proof (chain)\npicking this:\n  index_valid (insert ?a as) (assert_bound ?a s)", "have index: \"index_valid (insert a as) s'\""], ["proof (prove)\nusing this:\n  index_valid (insert ?a as) (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. index_valid (insert a as) s'", "unfolding s'"], ["proof (prove)\nusing this:\n  index_valid (insert ?a as) (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. index_valid (insert a as) (assert_bound a s)", "by auto"], ["proof (state)\nthis:\n  index_valid (insert a as) s'\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from assert_bound_nolhs_atoms_imply_bounds_index[OF *(1-5,7)]"], ["proof (chain)\npicking this:\n  insert ?a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound ?a s)", "have imp: \"insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\""], ["proof (prove)\nusing this:\n  insert ?a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  insert ?a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound ?a s)\n\ngoal (1 subgoal):\n 1. insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> (assert_bound a s)", "."], ["proof (state)\nthis:\n  insert a as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n\ngoal (7 subgoals):\n 1. \\<And>t as s a I.\n       \\<lbrakk>invariant_s t as s; assert_s a s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t\n                          (insert a as)\n 2. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 3. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 4. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 5. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 6. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 7. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from minimal_unsat_state_core_translation[OF unsat tabl index imp I]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_tabl_atoms (set I) t (insert a as)", "show ?case"], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t (insert a as)\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (insert a as)", "."], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (insert a as)\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case (3 t as s s')"], ["proof (state)\nthis:\n  invariant_s t as s\n  check_s s = Inr s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* check ok *)"], ["proof (state)\nthis:\n  invariant_s t as s\n  check_s s = Inr s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 3(2)[unfolded check_s_def Let_def]"], ["proof (chain)\npicking this:\n  (if \\<U> (check s) then Inl (the (\\<U>\\<^sub>c (check s)))\n   else Inr (check s)) =\n  Inr s'", "have U: \"\\<not> \\<U> (check s)\" and s': \"s' = check s\""], ["proof (prove)\nusing this:\n  (if \\<U> (check s) then Inl (the (\\<U>\\<^sub>c (check s)))\n   else Inr (check s)) =\n  Inr s'\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (check s) &&& s' = check s", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  \\<not> \\<U> (check s)\n  s' = check s\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note * = invariant_sD[OF 3(1)]"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  (snd ` as) \\<doteq> \\<B> s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n  index_valid as s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note ** = *(1,2,5,3,4)"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_tableau_equiv[OF **] *(9)"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s = ?v \\<Turnstile>\\<^sub>t \\<T> (check s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "have \"\\<forall>v :: _ \\<Rightarrow> 'a. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s = ?v \\<Turnstile>\\<^sub>t \\<T> (check s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t", "unfolding s'"], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s = ?v \\<Turnstile>\\<^sub>t \\<T> (check s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       v \\<Turnstile>\\<^sub>t \\<T> (check s) = v \\<Turnstile>\\<^sub>t t", "by auto"], ["proof (state)\nthis:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_tableau_index_valid[OF **] *(8)"], ["proof (chain)\npicking this:\n  index_valid ?as (check s) = index_valid ?as s\n  index_valid as s", "have \"index_valid as s'\""], ["proof (prove)\nusing this:\n  index_valid ?as (check s) = index_valid ?as s\n  index_valid as s\n\ngoal (1 subgoal):\n 1. index_valid as s'", "unfolding s'"], ["proof (prove)\nusing this:\n  index_valid ?as (check s) = index_valid ?as s\n  index_valid as s\n\ngoal (1 subgoal):\n 1. index_valid as (check s)", "by auto"], ["proof (state)\nthis:\n  index_valid as s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  index_valid as s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_tableau_normalized[OF **]"], ["proof (chain)\npicking this:\n  \\<triangle> (\\<T> (check s))", "have \"\\<triangle> (\\<T> s')\""], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> (check s))\n\ngoal (1 subgoal):\n 1. \\<triangle> (\\<T> s')", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> (check s))\n\ngoal (1 subgoal):\n 1. \\<triangle> (\\<T> (check s))", "."], ["proof (state)\nthis:\n  \\<triangle> (\\<T> s')\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<triangle> (\\<T> s')\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_tableau_valuated[OF **]"], ["proof (chain)\npicking this:\n  \\<nabla> (check s)", "have \"\\<nabla> s'\""], ["proof (prove)\nusing this:\n  \\<nabla> (check s)\n\ngoal (1 subgoal):\n 1. \\<nabla> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<nabla> (check s)\n\ngoal (1 subgoal):\n 1. \\<nabla> (check s)", "."], ["proof (state)\nthis:\n  \\<nabla> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<nabla> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_sat[OF ** U]"], ["proof (chain)\npicking this:\n  \\<Turnstile> (check s)", "have \"\\<Turnstile> s'\""], ["proof (prove)\nusing this:\n  \\<Turnstile> (check s)\n\ngoal (1 subgoal):\n 1. \\<Turnstile> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<Turnstile> (check s)\n\ngoal (1 subgoal):\n 1. \\<Turnstile> (check s)", "."], ["proof (state)\nthis:\n  \\<Turnstile> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<Turnstile> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from satisfies_satisfies_no_lhs[OF this] satisfies_consistent[of s'] this"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<Turnstile> s' \\<longrightarrow> \\<diamond> s'\n  \\<Turnstile> s'", "have \" \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\" \"\\<diamond> s'\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<Turnstile> s' \\<longrightarrow> \\<diamond> s'\n  \\<Turnstile> s'\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s' &&&\n    \\<diamond> s'", "by blast+"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_bounds_id[OF **] *(6)"], ["proof (chain)\npicking this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  (snd ` as) \\<doteq> \\<B> s", "have \"Simplex.flat as \\<doteq> \\<B> s'\""], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  (snd ` as) \\<doteq> \\<B> s\n\ngoal (1 subgoal):\n 1. (snd ` as) \\<doteq> \\<B> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  (snd ` as) \\<doteq> \\<B> s\n\ngoal (1 subgoal):\n 1. (snd ` as) \\<doteq> \\<B> (check s)", "by (auto simp: boundsu_def boundsl_def)"], ["proof (state)\nthis:\n  (snd ` as) \\<doteq> \\<B> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  (snd ` as) \\<doteq> \\<B> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_bounds_id[OF **] *(7)"], ["proof (chain)\npicking this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s", "have \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\""], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. as \\<Turnstile>\\<^sub>i \\<B>\\<I> (check s)", "by (auto simp: boundsu_def boundsl_def indexu_def indexl_def)"], ["proof (state)\nthis:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from U"], ["proof (chain)\npicking this:\n  \\<not> \\<U> (check s)", "have \"\\<not> \\<U> s'\""], ["proof (prove)\nusing this:\n  \\<not> \\<U> (check s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<not> \\<U> (check s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (check s)", "."], ["proof (state)\nthis:\n  \\<not> \\<U> s'\n\ngoal (6 subgoals):\n 1. \\<And>t as s s'.\n       \\<lbrakk>invariant_s t as s; check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_s t as s'\n 2. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 3. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 4. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 5. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 6. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n  index_valid as s'\n  \\<triangle> (\\<T> s')\n  \\<nabla> s'\n  \\<Turnstile> s'\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n  (snd ` as) \\<doteq> \\<B> s'\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  \\<not> \\<U> s'", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n  index_valid as s'\n  \\<triangle> (\\<T> s')\n  \\<nabla> s'\n  \\<Turnstile> s'\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n  (snd ` as) \\<doteq> \\<B> s'\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. checked_s t as s'", "unfolding invariant_s_def checked_s_def"], ["proof (prove)\nusing this:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n  index_valid as s'\n  \\<triangle> (\\<T> s')\n  \\<nabla> s'\n  \\<Turnstile> s'\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<diamond> s'\n  (snd ` as) \\<doteq> \\<B> s'\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. (\\<not> \\<U> s' \\<and>\n     \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s' \\<and>\n     \\<triangle> (\\<T> s') \\<and>\n     \\<nabla> s' \\<and>\n     \\<diamond> s' \\<and>\n     (\\<forall>v.\n         v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t) \\<and>\n     index_valid as s' \\<and>\n     (snd ` as) \\<doteq> \\<B> s' \\<and>\n     as \\<Turnstile>\\<^sub>i \\<B>\\<I> s') \\<and>\n    \\<Turnstile> s'", "by auto"], ["proof (state)\nthis:\n  checked_s t as s'\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case (4 t as s I)"], ["proof (state)\nthis:\n  invariant_s t as s\n  check_s s = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* check Unsat *)"], ["proof (state)\nthis:\n  invariant_s t as s\n  check_s s = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 4(2)[unfolded check_s_def Let_def]"], ["proof (chain)\npicking this:\n  (if \\<U> (check s) then Inl (the (\\<U>\\<^sub>c (check s)))\n   else Inr (check s)) =\n  Inl I", "obtain s' where s': \"s' = check s\" and U: \"\\<U> (check s)\" \n    and I: \"I = the (\\<U>\\<^sub>c s')\""], ["proof (prove)\nusing this:\n  (if \\<U> (check s) then Inl (the (\\<U>\\<^sub>c (check s)))\n   else Inr (check s)) =\n  Inl I\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' = check s; \\<U> (check s);\n         I = the (\\<U>\\<^sub>c s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s' = check s\n  \\<U> (check s)\n  I = the (\\<U>\\<^sub>c s')\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note * = invariant_sD[OF 4(1)]"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  (snd ` as) \\<doteq> \\<B> s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n  index_valid as s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note ** = *(1,2,5,3,4)"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_unsat[OF ** U]"], ["proof (chain)\npicking this:\n  minimal_unsat_state_core (check s)", "have unsat: \"minimal_unsat_state_core s'\""], ["proof (prove)\nusing this:\n  minimal_unsat_state_core (check s)\n\ngoal (1 subgoal):\n 1. minimal_unsat_state_core s'", "unfolding s'"], ["proof (prove)\nusing this:\n  minimal_unsat_state_core (check s)\n\ngoal (1 subgoal):\n 1. minimal_unsat_state_core (check s)", "by auto"], ["proof (state)\nthis:\n  minimal_unsat_state_core s'\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_tableau_equiv[OF **] *(9)"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s = ?v \\<Turnstile>\\<^sub>t \\<T> (check s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t", "have tabl: \"\\<forall>v :: _ \\<Rightarrow> 'a. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s = ?v \\<Turnstile>\\<^sub>t \\<T> (check s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t", "unfolding s'"], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s = ?v \\<Turnstile>\\<^sub>t \\<T> (check s)\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       v \\<Turnstile>\\<^sub>t \\<T> (check s) = v \\<Turnstile>\\<^sub>t t", "by auto"], ["proof (state)\nthis:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_tableau_index_valid[OF **] *(8)"], ["proof (chain)\npicking this:\n  index_valid ?as (check s) = index_valid ?as s\n  index_valid as s", "have index: \"index_valid as s'\""], ["proof (prove)\nusing this:\n  index_valid ?as (check s) = index_valid ?as s\n  index_valid as s\n\ngoal (1 subgoal):\n 1. index_valid as s'", "unfolding s'"], ["proof (prove)\nusing this:\n  index_valid ?as (check s) = index_valid ?as s\n  index_valid as s\n\ngoal (1 subgoal):\n 1. index_valid as (check s)", "by auto"], ["proof (state)\nthis:\n  index_valid as s'\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from check_bounds_id[OF **] *(7)"], ["proof (chain)\npicking this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s", "have imp: \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\""], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'", "unfolding s'"], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i (check s) = \\<B>\\<^sub>i s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. as \\<Turnstile>\\<^sub>i \\<B>\\<I> (check s)", "by (auto simp: boundsu_def boundsl_def indexu_def indexl_def)"], ["proof (state)\nthis:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n\ngoal (5 subgoals):\n 1. \\<And>t as s I.\n       \\<lbrakk>invariant_s t as s; check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> minimal_unsat_core_tabl_atoms (set I) t as\n 2. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 3. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 4. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 5. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from minimal_unsat_state_core_translation[OF unsat tabl index imp I]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_tabl_atoms (set I) t as", "show ?case"], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t as\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t as", "."], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t as\n\ngoal (4 subgoals):\n 1. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 2. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 3. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 4. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 2. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 3. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 4. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case *: (5 t)"], ["proof (state)\nthis:\n  \\<triangle> t\n\ngoal (4 subgoals):\n 1. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 2. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 3. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 4. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* init *)"], ["proof (state)\nthis:\n  \\<triangle> t\n\ngoal (4 subgoals):\n 1. \\<And>t. \\<triangle> t \\<Longrightarrow> checked_s t {} (init t)\n 2. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 3. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 4. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_s t {} (init t)", "unfolding checked_s_def invariant_s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> \\<U> (init t) \\<and>\n     \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s (init t) \\<and>\n     \\<triangle> (\\<T> (init t)) \\<and>\n     \\<nabla> (init t) \\<and>\n     \\<diamond> (init t) \\<and>\n     (\\<forall>v.\n         v \\<Turnstile>\\<^sub>t \\<T> (init t) =\n         v \\<Turnstile>\\<^sub>t t) \\<and>\n     index_valid {} (init t) \\<and>\n     (snd ` {}) \\<doteq> \\<B> (init t) \\<and>\n     {} \\<Turnstile>\\<^sub>i \\<B>\\<I> (init t)) \\<and>\n    \\<Turnstile> (init t)", "using \n      init_tableau_normalized[OF *] \n      init_index_valid[of _ t]\n      init_atoms_imply_bounds_index[of t]\n      init_satisfies[of t]\n      init_atoms_equiv_bounds[of t]\n      init_tableau_id[of t]\n      init_unsat_flag[of t]\n      init_tableau_valuated[of t]\n      satisfies_consistent[of \"init t\"] satisfies_satisfies_no_lhs[of \"init t\"]"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> (init t))\n  index_valid ?as (init t)\n  {} \\<Turnstile>\\<^sub>i \\<B>\\<I> (init t)\n  \\<Turnstile> (init t)\n  {} \\<doteq> \\<B> (init t)\n  \\<T> (init t) = t\n  \\<not> \\<U> (init t)\n  \\<nabla> (init t)\n  \\<Turnstile> (init t) \\<longrightarrow> \\<diamond> (init t)\n  \\<Turnstile> (init t) \\<Longrightarrow>\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s (init t)\n\ngoal (1 subgoal):\n 1. (\\<not> \\<U> (init t) \\<and>\n     \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s (init t) \\<and>\n     \\<triangle> (\\<T> (init t)) \\<and>\n     \\<nabla> (init t) \\<and>\n     \\<diamond> (init t) \\<and>\n     (\\<forall>v.\n         v \\<Turnstile>\\<^sub>t \\<T> (init t) =\n         v \\<Turnstile>\\<^sub>t t) \\<and>\n     index_valid {} (init t) \\<and>\n     (snd ` {}) \\<doteq> \\<B> (init t) \\<and>\n     {} \\<Turnstile>\\<^sub>i \\<B>\\<I> (init t)) \\<and>\n    \\<Turnstile> (init t)", "by auto"], ["proof (state)\nthis:\n  checked_s t {} (init t)\n\ngoal (3 subgoals):\n 1. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 2. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 3. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 2. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 3. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case (6 t as s v)"], ["proof (state)\nthis:\n  checked_s t as s\n  \\<V> s = v\n\ngoal (3 subgoals):\n 1. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 2. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 3. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* solution *)"], ["proof (state)\nthis:\n  checked_s t as s\n  \\<V> s = v\n\ngoal (3 subgoals):\n 1. \\<And>t as s v.\n       \\<lbrakk>checked_s t as s; \\<V> s = v\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                         \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                         (snd ` as)\n 2. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 3. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "then"], ["proof (chain)\npicking this:\n  checked_s t as s\n  \\<V> s = v", "show ?case"], ["proof (prove)\nusing this:\n  checked_s t as s\n  \\<V> s = v\n\ngoal (1 subgoal):\n 1. \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n    \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` as)", "unfolding checked_s_def invariant_s_def"], ["proof (prove)\nusing this:\n  (\\<not> \\<U> s \\<and>\n   \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s \\<and>\n   \\<triangle> (\\<T> s) \\<and>\n   \\<nabla> s \\<and>\n   \\<diamond> s \\<and>\n   (\\<forall>v.\n       v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t) \\<and>\n   index_valid as s \\<and>\n   (snd ` as) \\<doteq> \\<B> s \\<and>\n   as \\<Turnstile>\\<^sub>i \\<B>\\<I> s) \\<and>\n  \\<Turnstile> s\n  \\<V> s = v\n\ngoal (1 subgoal):\n 1. \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n    \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` as)", "by (meson atoms_equiv_bounds.simps curr_val_satisfies_state_def satisfies_state_def)"], ["proof (state)\nthis:\n  \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n  \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` as)\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "case (7 t as s c bs s' s'')"], ["proof (state)\nthis:\n  checked_s t as s\n  checkpoint_s s = c\n  invariant_s t bs s'\n  backtrack_s c s' = s''\n  as \\<subseteq> bs\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "(* checkpoint and backtrack *)"], ["proof (state)\nthis:\n  checked_s t as s\n  checkpoint_s s = c\n  invariant_s t bs s'\n  backtrack_s c s' = s''\n  as \\<subseteq> bs\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 7(1)[unfolded checked_s_def]"], ["proof (chain)\npicking this:\n  invariant_s t as s \\<and> \\<Turnstile> s", "have inv_s: \"invariant_s t as s\" and s: \"\\<Turnstile> s\""], ["proof (prove)\nusing this:\n  invariant_s t as s \\<and> \\<Turnstile> s\n\ngoal (1 subgoal):\n 1. invariant_s t as s &&& \\<Turnstile> s", "by auto"], ["proof (state)\nthis:\n  invariant_s t as s\n  \\<Turnstile> s\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 7(2)"], ["proof (chain)\npicking this:\n  checkpoint_s s = c", "have c: \"c = \\<B>\\<^sub>i s\""], ["proof (prove)\nusing this:\n  checkpoint_s s = c\n\ngoal (1 subgoal):\n 1. c = \\<B>\\<^sub>i s", "unfolding checkpoint_s_def"], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>i s = c\n\ngoal (1 subgoal):\n 1. c = \\<B>\\<^sub>i s", "by auto"], ["proof (state)\nthis:\n  c = \\<B>\\<^sub>i s\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "have s'': \"\\<T> s'' = \\<T> s'\" \"\\<V> s'' = \\<V> s'\" \"\\<B>\\<^sub>i s'' = \\<B>\\<^sub>i s\" \"\\<U> s'' = \\<U> s'\" \"\\<U>\\<^sub>c s'' = \\<U>\\<^sub>c s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<T> s'' = \\<T> s' &&& \\<V> s'' = \\<V> s') &&&\n    \\<B>\\<^sub>i s'' = \\<B>\\<^sub>i s &&&\n    \\<U> s'' = \\<U> s' &&& \\<U>\\<^sub>c s'' = \\<U>\\<^sub>c s'", "unfolding 7(4)[symmetric] c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<T> (backtrack_s (\\<B>\\<^sub>i s) s') = \\<T> s' &&&\n     \\<V> (backtrack_s (\\<B>\\<^sub>i s) s') = \\<V> s') &&&\n    \\<B>\\<^sub>i (backtrack_s (\\<B>\\<^sub>i s) s') = \\<B>\\<^sub>i s &&&\n    \\<U> (backtrack_s (\\<B>\\<^sub>i s) s') = \\<U> s' &&&\n    \\<U>\\<^sub>c (backtrack_s (\\<B>\\<^sub>i s) s') = \\<U>\\<^sub>c s'", "by (atomize(full), cases s', auto)"], ["proof (state)\nthis:\n  \\<T> s'' = \\<T> s'\n  \\<V> s'' = \\<V> s'\n  \\<B>\\<^sub>i s'' = \\<B>\\<^sub>i s\n  \\<U> s'' = \\<U> s'\n  \\<U>\\<^sub>c s'' = \\<U>\\<^sub>c s'\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "then"], ["proof (chain)\npicking this:\n  \\<T> s'' = \\<T> s'\n  \\<V> s'' = \\<V> s'\n  \\<B>\\<^sub>i s'' = \\<B>\\<^sub>i s\n  \\<U> s'' = \\<U> s'\n  \\<U>\\<^sub>c s'' = \\<U>\\<^sub>c s'", "have BI: \"\\<B> s'' = \\<B> s\" \"\\<I> s'' = \\<I> s\""], ["proof (prove)\nusing this:\n  \\<T> s'' = \\<T> s'\n  \\<V> s'' = \\<V> s'\n  \\<B>\\<^sub>i s'' = \\<B>\\<^sub>i s\n  \\<U> s'' = \\<U> s'\n  \\<U>\\<^sub>c s'' = \\<U>\\<^sub>c s'\n\ngoal (1 subgoal):\n 1. \\<B> s'' = \\<B> s &&& \\<I> s'' = \\<I> s", "by (auto simp: boundsu_def boundsl_def indexu_def indexl_def)"], ["proof (state)\nthis:\n  \\<B> s'' = \\<B> s\n  \\<I> s'' = \\<I> s\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note * = invariant_sD[OF inv_s]"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  (snd ` as) \\<doteq> \\<B> s\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n  index_valid as s\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t t\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "note ** = invariant_sD[OF 7(3)]"], ["proof (state)\nthis:\n  \\<not> \\<U> s'\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n  \\<triangle> (\\<T> s')\n  \\<nabla> s'\n  \\<diamond> s'\n  (snd ` bs) \\<doteq> \\<B> s'\n  bs \\<Turnstile>\\<^sub>i \\<B>\\<I> s'\n  index_valid bs s'\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from **(1)"], ["proof (chain)\npicking this:\n  \\<not> \\<U> s'", "have \"\\<not> \\<U> s''\""], ["proof (prove)\nusing this:\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> s''", "unfolding s''"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> s'", "."], ["proof (state)\nthis:\n  \\<not> \\<U> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<not> \\<U> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from **(3)"], ["proof (chain)\npicking this:\n  \\<triangle> (\\<T> s')", "have \"\\<triangle> (\\<T> s'')\""], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s')\n\ngoal (1 subgoal):\n 1. \\<triangle> (\\<T> s'')", "unfolding s''"], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> s')\n\ngoal (1 subgoal):\n 1. \\<triangle> (\\<T> s')", "."], ["proof (state)\nthis:\n  \\<triangle> (\\<T> s'')\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<triangle> (\\<T> s'')\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from **(4)"], ["proof (chain)\npicking this:\n  \\<nabla> s'", "have \"\\<nabla> s''\""], ["proof (prove)\nusing this:\n  \\<nabla> s'\n\ngoal (1 subgoal):\n 1. \\<nabla> s''", "unfolding tableau_valuated_def s''"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>tvars (\\<T> s'). Mapping.lookup (\\<V> s') x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>tvars (\\<T> s'). Mapping.lookup (\\<V> s') x \\<noteq> None", "."], ["proof (state)\nthis:\n  \\<nabla> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<nabla> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from **(9)"], ["proof (chain)\npicking this:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t", "have \"\\<forall>v :: _ \\<Rightarrow> 'a. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t\""], ["proof (prove)\nusing this:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t", "unfolding s''"], ["proof (prove)\nusing this:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s' = v \\<Turnstile>\\<^sub>t t", "."], ["proof (state)\nthis:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from *(6)"], ["proof (chain)\npicking this:\n  (snd ` as) \\<doteq> \\<B> s", "have \"Simplex.flat as \\<doteq> \\<B> s''\""], ["proof (prove)\nusing this:\n  (snd ` as) \\<doteq> \\<B> s\n\ngoal (1 subgoal):\n 1. (snd ` as) \\<doteq> \\<B> s''", "unfolding BI"], ["proof (prove)\nusing this:\n  (snd ` as) \\<doteq> \\<B> s\n\ngoal (1 subgoal):\n 1. (snd ` as) \\<doteq> \\<B> s", "."], ["proof (state)\nthis:\n  (snd ` as) \\<doteq> \\<B> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  (snd ` as) \\<doteq> \\<B> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from *(7)"], ["proof (chain)\npicking this:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s", "have \"as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''\""], ["proof (prove)\nusing this:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''", "unfolding BI"], ["proof (prove)\nusing this:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s\n\ngoal (1 subgoal):\n 1. as \\<Turnstile>\\<^sub>i \\<B>\\<I> s", "."], ["proof (state)\nthis:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from *(8)"], ["proof (chain)\npicking this:\n  index_valid as s", "have \"index_valid as s''\""], ["proof (prove)\nusing this:\n  index_valid as s\n\ngoal (1 subgoal):\n 1. index_valid as s''", "unfolding index_valid_def"], ["proof (prove)\nusing this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n\ngoal (1 subgoal):\n 1. \\<forall>x b i.\n       (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s'') x =\n        Some (i, b) \\<longrightarrow>\n        (i, Geq x b) \\<in> as) \\<and>\n       (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s'') x =\n        Some (i, b) \\<longrightarrow>\n        (i, Leq x b) \\<in> as)", "using s''"], ["proof (prove)\nusing this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n  \\<T> s'' = \\<T> s'\n  \\<V> s'' = \\<V> s'\n  \\<B>\\<^sub>i s'' = \\<B>\\<^sub>i s\n  \\<U> s'' = \\<U> s'\n  \\<U>\\<^sub>c s'' = \\<U>\\<^sub>c s'\n\ngoal (1 subgoal):\n 1. \\<forall>x b i.\n       (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s'') x =\n        Some (i, b) \\<longrightarrow>\n        (i, Geq x b) \\<in> as) \\<and>\n       (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s'') x =\n        Some (i, b) \\<longrightarrow>\n        (i, Leq x b) \\<in> as)", "by auto"], ["proof (state)\nthis:\n  index_valid as s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  index_valid as s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from **(4)"], ["proof (chain)\npicking this:\n  \\<nabla> s'", "have \"\\<nabla> s''\""], ["proof (prove)\nusing this:\n  \\<nabla> s'\n\ngoal (1 subgoal):\n 1. \\<nabla> s''", "unfolding tableau_valuated_def s''"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>tvars (\\<T> s'). Mapping.lookup (\\<V> s') x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>tvars (\\<T> s'). Mapping.lookup (\\<V> s') x \\<noteq> None", "."], ["proof (state)\nthis:\n  \\<nabla> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<nabla> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from satisfies_consistent[of s] s"], ["proof (chain)\npicking this:\n  \\<Turnstile> s \\<longrightarrow> \\<diamond> s\n  \\<Turnstile> s", "have \"\\<diamond> s''\""], ["proof (prove)\nusing this:\n  \\<Turnstile> s \\<longrightarrow> \\<diamond> s\n  \\<Turnstile> s\n\ngoal (1 subgoal):\n 1. \\<diamond> s''", "unfolding bounds_consistent_def"], ["proof (prove)\nusing this:\n  \\<Turnstile> s \\<longrightarrow>\n  (\\<forall>x.\n      if \\<B>\\<^sub>l s x = None \\<or> \\<B>\\<^sub>u s x = None then True\n      else the (\\<B>\\<^sub>l s x) \\<le> the (\\<B>\\<^sub>u s x))\n  \\<Turnstile> s\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       if \\<B>\\<^sub>l s'' x = None \\<or> \\<B>\\<^sub>u s'' x = None\n       then True\n       else the (\\<B>\\<^sub>l s'' x) \\<le> the (\\<B>\\<^sub>u s'' x)", "using BI"], ["proof (prove)\nusing this:\n  \\<Turnstile> s \\<longrightarrow>\n  (\\<forall>x.\n      if \\<B>\\<^sub>l s x = None \\<or> \\<B>\\<^sub>u s x = None then True\n      else the (\\<B>\\<^sub>l s x) \\<le> the (\\<B>\\<^sub>u s x))\n  \\<Turnstile> s\n  \\<B> s'' = \\<B> s\n  \\<I> s'' = \\<I> s\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       if \\<B>\\<^sub>l s'' x = None \\<or> \\<B>\\<^sub>u s'' x = None\n       then True\n       else the (\\<B>\\<^sub>l s'' x) \\<le> the (\\<B>\\<^sub>u s'' x)", "by auto"], ["proof (state)\nthis:\n  \\<diamond> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "moreover"], ["proof (state)\nthis:\n  \\<diamond> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from 7(5) *(6) **(6)"], ["proof (chain)\npicking this:\n  as \\<subseteq> bs\n  (snd ` as) \\<doteq> \\<B> s\n  (snd ` bs) \\<doteq> \\<B> s'", "have vB: \"v \\<Turnstile>\\<^sub>b \\<B> s' \\<Longrightarrow> v \\<Turnstile>\\<^sub>b \\<B> s''\" for v"], ["proof (prove)\nusing this:\n  as \\<subseteq> bs\n  (snd ` as) \\<doteq> \\<B> s\n  (snd ` bs) \\<doteq> \\<B> s'\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>b \\<B> s' \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>b \\<B> s''", "unfolding atoms_equiv_bounds.simps satisfies_atom_set_def BI"], ["proof (prove)\nusing this:\n  as \\<subseteq> bs\n  \\<forall>v.\n     (\\<forall>a\\<in>snd ` as. v \\<Turnstile>\\<^sub>a a) =\n     v \\<Turnstile>\\<^sub>b \\<B> s\n  \\<forall>v.\n     (\\<forall>a\\<in>snd ` bs. v \\<Turnstile>\\<^sub>a a) =\n     v \\<Turnstile>\\<^sub>b \\<B> s'\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>b \\<B> s' \\<Longrightarrow>\n    v \\<Turnstile>\\<^sub>b \\<B> s", "by force"], ["proof (state)\nthis:\n  ?v \\<Turnstile>\\<^sub>b \\<B> s' \\<Longrightarrow>\n  ?v \\<Turnstile>\\<^sub>b \\<B> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from **(2)"], ["proof (chain)\npicking this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'", "have t: \"\\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s'\" and b: \"\\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel> - lvars (\\<T> s')\""], ["proof (prove)\nusing this:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\n\ngoal (1 subgoal):\n 1. \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s' &&&\n    \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel>\n    - lvars (\\<T> s')", "unfolding curr_val_satisfies_no_lhs_def"], ["proof (prove)\nusing this:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s' \\<and>\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel>\n  - lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s' &&&\n    \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel>\n    - lvars (\\<T> s')", "by auto"], ["proof (state)\nthis:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s'\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel>\n  - lvars (\\<T> s')\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "let ?v = \"\\<lambda> x. if x \\<in> lvars (\\<T> s') then case \\<B>\\<^sub>l s' x of None \\<Rightarrow> the (\\<B>\\<^sub>u s' x) | Some b \\<Rightarrow> b else \\<langle>\\<V> s'\\<rangle> x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "have \"?v \\<Turnstile>\\<^sub>b \\<B> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x \\<in> lvars (\\<T> s')\n        then case \\<B>\\<^sub>l s' x of\n             None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n             | Some b \\<Rightarrow> b\n        else \\<langle>\\<V> s'\\<rangle> x) \\<Turnstile>\\<^sub>b\n    \\<B> s'", "unfolding satisfies_bounds.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       in_bounds x\n        (\\<lambda>x.\n            if x \\<in> lvars (\\<T> s')\n            then case \\<B>\\<^sub>l s' x of\n                 None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n                 | Some b \\<Rightarrow> b\n            else \\<langle>\\<V> s'\\<rangle> x)\n        (\\<B> s')", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       in_bounds x\n        (\\<lambda>x.\n            if x \\<in> lvars (\\<T> s')\n            then case \\<B>\\<^sub>l s' x of\n                 None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n                 | Some b \\<Rightarrow> b\n            else \\<langle>\\<V> s'\\<rangle> x)\n        (\\<B> s')", "fix x :: var"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       in_bounds x\n        (\\<lambda>x.\n            if x \\<in> lvars (\\<T> s')\n            then case \\<B>\\<^sub>l s' x of\n                 None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n                 | Some b \\<Rightarrow> b\n            else \\<langle>\\<V> s'\\<rangle> x)\n        (\\<B> s')", "show \"in_bounds x ?v (\\<B> s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "proof (cases \"x \\<in> lvars (\\<T> s')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')\n 2. x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "case True"], ["proof (state)\nthis:\n  x \\<in> lvars (\\<T> s')\n\ngoal (2 subgoals):\n 1. x \\<in> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')\n 2. x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "with **(5)[unfolded bounds_consistent_def, rule_format, of x]"], ["proof (chain)\npicking this:\n  if \\<B>\\<^sub>l s' x = None \\<or> \\<B>\\<^sub>u s' x = None then True\n  else the (\\<B>\\<^sub>l s' x) \\<le> the (\\<B>\\<^sub>u s' x)\n  x \\<in> lvars (\\<T> s')", "show ?thesis"], ["proof (prove)\nusing this:\n  if \\<B>\\<^sub>l s' x = None \\<or> \\<B>\\<^sub>u s' x = None then True\n  else the (\\<B>\\<^sub>l s' x) \\<le> the (\\<B>\\<^sub>u s' x)\n  x \\<in> lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "by (cases \"\\<B>\\<^sub>l s' x\"; cases \"\\<B>\\<^sub>u s' x\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  in_bounds x\n   (\\<lambda>x.\n       if x \\<in> lvars (\\<T> s')\n       then case \\<B>\\<^sub>l s' x of\n            None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n            | Some b \\<Rightarrow> b\n       else \\<langle>\\<V> s'\\<rangle> x)\n   (\\<B> s')\n\ngoal (1 subgoal):\n 1. x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "case False"], ["proof (state)\nthis:\n  x \\<notin> lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n    in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "with b"], ["proof (chain)\npicking this:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel>\n  - lvars (\\<T> s')\n  x \\<notin> lvars (\\<T> s')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s' \\<parallel>\n  - lvars (\\<T> s')\n  x \\<notin> lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "unfolding satisfies_bounds_set.simps"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>- lvars (\\<T> s').\n     in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s')\n  x \\<notin> lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. in_bounds x\n     (\\<lambda>x.\n         if x \\<in> lvars (\\<T> s')\n         then case \\<B>\\<^sub>l s' x of\n              None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n              | Some b \\<Rightarrow> b\n         else \\<langle>\\<V> s'\\<rangle> x)\n     (\\<B> s')", "by auto"], ["proof (state)\nthis:\n  in_bounds x\n   (\\<lambda>x.\n       if x \\<in> lvars (\\<T> s')\n       then case \\<B>\\<^sub>l s' x of\n            None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n            | Some b \\<Rightarrow> b\n       else \\<langle>\\<V> s'\\<rangle> x)\n   (\\<B> s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_bounds x\n   (\\<lambda>x.\n       if x \\<in> lvars (\\<T> s')\n       then case \\<B>\\<^sub>l s' x of\n            None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n            | Some b \\<Rightarrow> b\n       else \\<langle>\\<V> s'\\<rangle> x)\n   (\\<B> s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if x \\<in> lvars (\\<T> s')\n      then case \\<B>\\<^sub>l s' x of\n           None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n           | Some b \\<Rightarrow> b\n      else \\<langle>\\<V> s'\\<rangle> x) \\<Turnstile>\\<^sub>b\n  \\<B> s'\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "from vB[OF this]"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      if x \\<in> lvars (\\<T> s')\n      then case \\<B>\\<^sub>l s' x of\n           None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n           | Some b \\<Rightarrow> b\n      else \\<langle>\\<V> s'\\<rangle> x) \\<Turnstile>\\<^sub>b\n  \\<B> s''", "have v: \"?v \\<Turnstile>\\<^sub>b \\<B> s''\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      if x \\<in> lvars (\\<T> s')\n      then case \\<B>\\<^sub>l s' x of\n           None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n           | Some b \\<Rightarrow> b\n      else \\<langle>\\<V> s'\\<rangle> x) \\<Turnstile>\\<^sub>b\n  \\<B> s''\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x \\<in> lvars (\\<T> s')\n        then case \\<B>\\<^sub>l s' x of\n             None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n             | Some b \\<Rightarrow> b\n        else \\<langle>\\<V> s'\\<rangle> x) \\<Turnstile>\\<^sub>b\n    \\<B> s''", "."], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if x \\<in> lvars (\\<T> s')\n      then case \\<B>\\<^sub>l s' x of\n           None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n           | Some b \\<Rightarrow> b\n      else \\<langle>\\<V> s'\\<rangle> x) \\<Turnstile>\\<^sub>b\n  \\<B> s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "have \"\\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel> - lvars (\\<T> s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel>\n    - lvars (\\<T> s')", "unfolding satisfies_bounds_set.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s').\n       in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n       in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n       in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')", "assume \"x \\<notin> lvars (\\<T> s')\""], ["proof (state)\nthis:\n  x \\<notin> lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> lvars (\\<T> s') \\<Longrightarrow>\n       in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')", "with v[unfolded satisfies_bounds.simps, rule_format, of x]"], ["proof (chain)\npicking this:\n  in_bounds x\n   (\\<lambda>x.\n       if x \\<in> lvars (\\<T> s')\n       then case \\<B>\\<^sub>l s' x of\n            None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n            | Some b \\<Rightarrow> b\n       else \\<langle>\\<V> s'\\<rangle> x)\n   (\\<B> s'')\n  x \\<notin> lvars (\\<T> s')", "show \"in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')\""], ["proof (prove)\nusing this:\n  in_bounds x\n   (\\<lambda>x.\n       if x \\<in> lvars (\\<T> s')\n       then case \\<B>\\<^sub>l s' x of\n            None \\<Rightarrow> the (\\<B>\\<^sub>u s' x)\n            | Some b \\<Rightarrow> b\n       else \\<langle>\\<V> s'\\<rangle> x)\n   (\\<B> s'')\n  x \\<notin> lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')", "by auto"], ["proof (state)\nthis:\n  in_bounds x \\<langle>\\<V> s'\\<rangle> (\\<B> s'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel>\n  - lvars (\\<T> s')\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "with t"], ["proof (chain)\npicking this:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s'\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel>\n  - lvars (\\<T> s')", "have \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s''\""], ["proof (prove)\nusing this:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s'\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel>\n  - lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s''", "unfolding curr_val_satisfies_no_lhs_def s''"], ["proof (prove)\nusing this:\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s'\n  \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel>\n  - lvars (\\<T> s')\n\ngoal (1 subgoal):\n 1. \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s' \\<and>\n    \\<langle>\\<V> s'\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s'' \\<parallel>\n    - lvars (\\<T> s')", "by auto"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s''\n\ngoal (2 subgoals):\n 1. \\<And>t as s c bs s' s''.\n       \\<lbrakk>checked_s t as s; checkpoint_s s = c; invariant_s t bs s';\n        backtrack_s c s' = s''; as \\<subseteq> bs\\<rbrakk>\n       \\<Longrightarrow> invariant_s t as s''\n 2. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> \\<U> s''\n  \\<triangle> (\\<T> s'')\n  \\<nabla> s''\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t\n  (snd ` as) \\<doteq> \\<B> s''\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''\n  index_valid as s''\n  \\<nabla> s''\n  \\<diamond> s''\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s''", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s''\n  \\<triangle> (\\<T> s'')\n  \\<nabla> s''\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t\n  (snd ` as) \\<doteq> \\<B> s''\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''\n  index_valid as s''\n  \\<nabla> s''\n  \\<diamond> s''\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s''\n\ngoal (1 subgoal):\n 1. invariant_s t as s''", "unfolding invariant_s_def"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s''\n  \\<triangle> (\\<T> s'')\n  \\<nabla> s''\n  \\<forall>v. v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t\n  (snd ` as) \\<doteq> \\<B> s''\n  as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''\n  index_valid as s''\n  \\<nabla> s''\n  \\<diamond> s''\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s''\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> s'' \\<and>\n    \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'' \\<and>\n    \\<triangle> (\\<T> s'') \\<and>\n    \\<nabla> s'' \\<and>\n    \\<diamond> s'' \\<and>\n    (\\<forall>v.\n        v \\<Turnstile>\\<^sub>t \\<T> s'' = v \\<Turnstile>\\<^sub>t t) \\<and>\n    index_valid as s'' \\<and>\n    (snd ` as) \\<doteq> \\<B> s'' \\<and> as \\<Turnstile>\\<^sub>i \\<B>\\<I> s''", "by blast"], ["proof (state)\nthis:\n  invariant_s t as s''\n\ngoal (1 subgoal):\n 1. \\<And>t as s. checked_s t as s \\<Longrightarrow> invariant_s t as s", "qed (auto simp: checked_s_def)"], ["", "end"], ["", "subsection \\<open>Intermediate Layer: Incremental Non-Strict Constraints\\<close>"], ["", "text \\<open>Interface\\<close>"], ["", "locale Incremental_NS_Constraint_Ops = fixes \n  init_nsc :: \"('i,'a :: lrv) i_ns_constraint list \\<Rightarrow> 's\" and\n  assert_nsc :: \"'i \\<Rightarrow> 's \\<Rightarrow> 'i list + 's\" and\n  check_nsc :: \"'s \\<Rightarrow> 'i list + 's\" and\n  solution_nsc :: \"'s \\<Rightarrow> (var, 'a) mapping\" and\n  checkpoint_nsc :: \"'s \\<Rightarrow> 'c\" and\n  backtrack_nsc :: \"'c \\<Rightarrow> 's \\<Rightarrow> 's\" and\n  invariant_nsc :: \"('i,'a) i_ns_constraint list \\<Rightarrow> 'i set \\<Rightarrow> 's \\<Rightarrow> bool\" and\n  checked_nsc :: \"('i,'a) i_ns_constraint list \\<Rightarrow> 'i set \\<Rightarrow> 's \\<Rightarrow> bool\"\nassumes \n  assert_nsc_ok: \"invariant_nsc nsc J s \\<Longrightarrow> assert_nsc j s = Inr s' \\<Longrightarrow> \n    invariant_nsc nsc (insert j J) s'\" and\n  assert_nsc_unsat: \"invariant_nsc nsc J s \\<Longrightarrow> assert_nsc j s = Unsat I \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and> minimal_unsat_core_ns (set I) (set nsc)\" and\n  check_nsc_ok: \"invariant_nsc nsc J s \\<Longrightarrow> check_nsc s = Inr s' \\<Longrightarrow> \n    checked_nsc nsc J s'\" and\n  check_nsc_unsat: \"invariant_nsc nsc J s \\<Longrightarrow> check_nsc s = Unsat I \\<Longrightarrow> \n    set I \\<subseteq> J \\<and> minimal_unsat_core_ns (set I) (set nsc)\" and\n  init_nsc: \"checked_nsc nsc {} (init_nsc nsc)\" and\n  solution_nsc: \"checked_nsc nsc J s \\<Longrightarrow> solution_nsc s = v \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s set nsc\" and\n  backtrack_nsc: \"checked_nsc nsc J s \\<Longrightarrow> checkpoint_nsc s = c \n    \\<Longrightarrow> invariant_nsc nsc K s' \\<Longrightarrow> backtrack_nsc c s' = s'' \\<Longrightarrow> J \\<subseteq> K \\<Longrightarrow> invariant_nsc nsc J s''\" and\n  checked_invariant_nsc: \"checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s\""], ["", "text \\<open>Implementation via the Simplex operation preprocess and the incremental operations for atoms.\\<close>"], ["", "fun create_map :: \"('i \\<times> 'a)list \\<Rightarrow> ('i, ('i \\<times> 'a) list)mapping\" where\n  \"create_map [] = Mapping.empty\" \n| \"create_map ((i,a) # xs) = (let m = create_map xs in\n     case Mapping.lookup m i of \n       None \\<Rightarrow> Mapping.update i [(i,a)] m \n     | Some ias \\<Rightarrow> Mapping.update i ((i,a) # ias) m)\""], ["", "definition list_map_to_fun :: \"('i, ('i \\<times> 'a) list)mapping \\<Rightarrow> 'i \\<Rightarrow> ('i \\<times> 'a) list\" where\n  \"list_map_to_fun m i = (case Mapping.lookup m i of None \\<Rightarrow> [] | Some ias \\<Rightarrow> ias)\""], ["", "lemma list_map_to_fun_create_map: \"set (list_map_to_fun (create_map ias) i) = set ias \\<inter> {i} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_map_to_fun (create_map ias) i) =\n    set ias \\<inter> {i} \\<times> UNIV", "proof (induct ias)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (list_map_to_fun (create_map []) i) =\n    set [] \\<inter> {i} \\<times> UNIV\n 2. \\<And>a ias.\n       set (list_map_to_fun (create_map ias) i) =\n       set ias \\<inter> {i} \\<times> UNIV \\<Longrightarrow>\n       set (list_map_to_fun (create_map (a # ias)) i) =\n       set (a # ias) \\<inter> {i} \\<times> UNIV", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. set (list_map_to_fun (create_map []) i) =\n    set [] \\<inter> {i} \\<times> UNIV\n 2. \\<And>a ias.\n       set (list_map_to_fun (create_map ias) i) =\n       set ias \\<inter> {i} \\<times> UNIV \\<Longrightarrow>\n       set (list_map_to_fun (create_map (a # ias)) i) =\n       set (a # ias) \\<inter> {i} \\<times> UNIV", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_map_to_fun (create_map []) i) =\n    set [] \\<inter> {i} \\<times> UNIV", "unfolding list_map_to_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (case Mapping.lookup (create_map []) i of None \\<Rightarrow> []\n         | Some ias \\<Rightarrow> ias) =\n    set [] \\<inter> {i} \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  set (list_map_to_fun (create_map []) i) =\n  set [] \\<inter> {i} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a ias.\n       set (list_map_to_fun (create_map ias) i) =\n       set ias \\<inter> {i} \\<times> UNIV \\<Longrightarrow>\n       set (list_map_to_fun (create_map (a # ias)) i) =\n       set (a # ias) \\<inter> {i} \\<times> UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ias.\n       set (list_map_to_fun (create_map ias) i) =\n       set ias \\<inter> {i} \\<times> UNIV \\<Longrightarrow>\n       set (list_map_to_fun (create_map (a # ias)) i) =\n       set (a # ias) \\<inter> {i} \\<times> UNIV", "case (Cons ja ias)"], ["proof (state)\nthis:\n  set (list_map_to_fun (create_map ias) i) =\n  set ias \\<inter> {i} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a ias.\n       set (list_map_to_fun (create_map ias) i) =\n       set ias \\<inter> {i} \\<times> UNIV \\<Longrightarrow>\n       set (list_map_to_fun (create_map (a # ias)) i) =\n       set (a # ias) \\<inter> {i} \\<times> UNIV", "obtain j a where ja: \"ja = (j,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j a. ja = (j, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ja = (j, a)\n\ngoal (1 subgoal):\n 1. \\<And>a ias.\n       set (list_map_to_fun (create_map ias) i) =\n       set ias \\<inter> {i} \\<times> UNIV \\<Longrightarrow>\n       set (list_map_to_fun (create_map (a # ias)) i) =\n       set (a # ias) \\<inter> {i} \\<times> UNIV", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "proof (cases \"j = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV\n 2. j \\<noteq> i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "case False"], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV\n 2. j \\<noteq> i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "then"], ["proof (chain)\npicking this:\n  j \\<noteq> i", "have id: \"list_map_to_fun (create_map (ja # ias)) i = list_map_to_fun (create_map ias) i\""], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. list_map_to_fun (create_map (ja # ias)) i =\n    list_map_to_fun (create_map ias) i", "unfolding ja list_map_to_fun_def"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. (case Mapping.lookup (create_map ((j, a) # ias)) i of\n     None \\<Rightarrow> [] | Some ias \\<Rightarrow> ias) =\n    (case Mapping.lookup (create_map ias) i of None \\<Rightarrow> []\n     | Some ias \\<Rightarrow> ias)", "by (auto simp: Let_def split: option.splits)"], ["proof (state)\nthis:\n  list_map_to_fun (create_map (ja # ias)) i =\n  list_map_to_fun (create_map ias) i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV\n 2. j \\<noteq> i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "unfolding id Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ias \\<inter> {i} \\<times> UNIV =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "unfolding ja"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ias \\<inter> {i} \\<times> UNIV =\n    set ((j, a) # ias) \\<inter> {i} \\<times> UNIV", "using False"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. set ias \\<inter> {i} \\<times> UNIV =\n    set ((j, a) # ias) \\<inter> {i} \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  set (list_map_to_fun (create_map (ja # ias)) i) =\n  set (ja # ias) \\<inter> {i} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "case True"], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "with ja"], ["proof (chain)\npicking this:\n  ja = (j, a)\n  j = i", "have ja: \"ja = (i,a)\""], ["proof (prove)\nusing this:\n  ja = (j, a)\n  j = i\n\ngoal (1 subgoal):\n 1. ja = (i, a)", "by auto"], ["proof (state)\nthis:\n  ja = (i, a)\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "have id: \"list_map_to_fun (create_map (ja # ias)) i = ja # list_map_to_fun (create_map ias) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_map_to_fun (create_map (ja # ias)) i =\n    ja # list_map_to_fun (create_map ias) i", "unfolding ja list_map_to_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Mapping.lookup (create_map ((i, a) # ias)) i of\n     None \\<Rightarrow> [] | Some ias \\<Rightarrow> ias) =\n    (i, a) #\n    (case Mapping.lookup (create_map ias) i of None \\<Rightarrow> []\n     | Some ias \\<Rightarrow> ias)", "by (auto simp: Let_def split: option.splits)"], ["proof (state)\nthis:\n  list_map_to_fun (create_map (ja # ias)) i =\n  ja # list_map_to_fun (create_map ias) i\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_map_to_fun (create_map (ja # ias)) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ja # list_map_to_fun (create_map ias) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "using Cons"], ["proof (prove)\nusing this:\n  set (list_map_to_fun (create_map ias) i) =\n  set ias \\<inter> {i} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set (ja # list_map_to_fun (create_map ias) i) =\n    set (ja # ias) \\<inter> {i} \\<times> UNIV", "unfolding ja"], ["proof (prove)\nusing this:\n  set (list_map_to_fun (create_map ias) i) =\n  set ias \\<inter> {i} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set ((i, a) # list_map_to_fun (create_map ias) i) =\n    set ((i, a) # ias) \\<inter> {i} \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  set (list_map_to_fun (create_map (ja # ias)) i) =\n  set (ja # ias) \\<inter> {i} \\<times> UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (list_map_to_fun (create_map (ja # ias)) i) =\n  set (ja # ias) \\<inter> {i} \\<times> UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "fun sum_wrap :: \"('c \\<Rightarrow> 's \\<Rightarrow> 'i list + 's)\n  \\<Rightarrow> 'c \\<times> 's \\<Rightarrow> 'i list + ('c \\<times> 's)\" where\n  \"sum_wrap f (asi,s) = (case f asi s of Unsat I \\<Rightarrow> Unsat I | Inr s' \\<Rightarrow> Inr (asi,s'))\""], ["", "definition check_nsc where \"check_nsc check_s = sum_wrap (\\<lambda> asitv. check_s)\""], ["", "definition assert_nsc where \"assert_nsc assert_all_s i = (\\<lambda> ((asi,tv,ui),s). \n  if i \\<in> set ui then Unsat [i] else \n  case assert_all_s (list_map_to_fun asi i) s of Unsat I \\<Rightarrow> Unsat I | Inr s' \\<Rightarrow> Inr ((asi,tv,ui),s'))\""], ["", "fun checkpoint_nsc where \"checkpoint_nsc checkpoint_s (asi_tv_ui,s) = checkpoint_s s\""], ["", "fun backtrack_nsc where \"backtrack_nsc backtrack_s c (asi_tv_ui,s) = (asi_tv_ui, backtrack_s c s)\""], ["", "fun solution_nsc where \"solution_nsc solution_s ((asi,tv,ui),s) = tv (solution_s s)\""], ["", "locale Incremental_Atom_Ops_For_NS_Constraint_Ops =\n  Incremental_Atom_Ops init_s assert_s check_s solution_s checkpoint_s backtrack_s \\<triangle>\n  invariant_s checked_s\n  + Preprocess preprocess\n  for \n    init_s :: \"tableau \\<Rightarrow> 's\" and\n    assert_s :: \"('i :: linorder,'a :: lrv) i_atom \\<Rightarrow> 's \\<Rightarrow> 'i list + 's\" and\n    check_s :: \"'s \\<Rightarrow> 'i list + 's\" and\n    solution_s :: \"'s \\<Rightarrow> (var, 'a) mapping\" and\n    checkpoint_s :: \"'s \\<Rightarrow> 'c\" and\n    backtrack_s :: \"'c \\<Rightarrow> 's \\<Rightarrow> 's\" and\n    invariant_s :: \"tableau \\<Rightarrow> ('i,'a) i_atom set \\<Rightarrow> 's \\<Rightarrow> bool\" and\n    checked_s :: \"tableau \\<Rightarrow> ('i,'a) i_atom set \\<Rightarrow> 's \\<Rightarrow> bool\" and\n    preprocess :: \"('i,'a) i_ns_constraint list \\<Rightarrow> tableau \\<times> ('i,'a) i_atom list \\<times> ((var,'a)mapping \\<Rightarrow> (var,'a)mapping) \\<times> 'i list\" \nbegin"], ["", "definition \"init_nsc nsc = (case preprocess nsc of (t,as,trans_v,ui) \\<Rightarrow> \n   ((create_map as, trans_v, remdups ui), init_s t))\""], ["", "fun invariant_as_asi where \"invariant_as_asi as asi tc tc' ui ui' = (tc = tc' \\<and> set ui = set ui' \\<and> \n    (\\<forall> i. set (list_map_to_fun asi i) = (as \\<inter> ({i} \\<times> UNIV))))\""], ["", "fun invariant_nsc where \n  \"invariant_nsc nsc J ((asi,tv,ui),s) = (case preprocess nsc of (t,as,tv',ui') \\<Rightarrow> invariant_as_asi (set as) asi tv tv' ui ui' \\<and> \n     invariant_s t (set as \\<inter> (J \\<times> UNIV)) s \\<and> J \\<inter> set ui = {})\""], ["", "fun checked_nsc where \n  \"checked_nsc nsc J ((asi,tv,ui),s) = (case preprocess nsc of (t,as,tv',ui') \\<Rightarrow> invariant_as_asi (set as) asi tv tv' ui ui' \\<and> \n     checked_s t (set as \\<inter> (J \\<times> UNIV)) s \\<and> J \\<inter> set ui = {})\""], ["", "lemma i_satisfies_atom_set_inter_right: \"((I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s (ats \\<inter> (J \\<times> UNIV))) \\<longleftrightarrow> ((I \\<inter> J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s ats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s\n    (ats \\<inter> J \\<times> UNIV) =\n    (I \\<inter> J, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s ats", "unfolding i_satisfies_atom_set.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>a\\<^sub>s\n    (snd ` (ats \\<inter> J \\<times> UNIV \\<inter> I \\<times> UNIV)) =\n    v \\<Turnstile>\\<^sub>a\\<^sub>s\n    (snd ` (ats \\<inter> (I \\<inter> J) \\<times> UNIV))", "by (rule arg_cong[of _ _ \"\\<lambda> x. v \\<Turnstile>\\<^sub>a\\<^sub>s x\"], auto)"], ["", "lemma ns_constraints_ops: \"Incremental_NS_Constraint_Ops init_nsc (assert_nsc assert_all_s)\n  (check_nsc check_s) (solution_nsc solution_s) (checkpoint_nsc checkpoint_s) (backtrack_nsc backtrack_s)\n  invariant_nsc checked_nsc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Incremental_NS_Constraint_Ops init_nsc (assert_nsc assert_all_s)\n     (check_nsc check_s) (solution_nsc solution_s)\n     (checkpoint_nsc checkpoint_s) (backtrack_nsc backtrack_s) invariant_nsc\n     checked_nsc", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (1 nsc J S j S')"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  assert_nsc assert_all_s j S = Inr S'\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* assert ok *)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  assert_nsc assert_all_s j S = Inr S'\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi tv s ui where S: \"S = ((asi,tv,ui),s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi tv ui s.\n        S = ((asi, tv, ui), s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = ((asi, tv, ui), s)\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain t as tv' ui' where prep[simp]: \"preprocess nsc = (t, as, tv', ui')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t as tv' ui'.\n        preprocess nsc = (t, as, tv', ui') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess nsc\")"], ["proof (state)\nthis:\n  preprocess nsc = (t, as, tv', ui')\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "note pre = 1[unfolded S assert_nsc_def]"], ["proof (state)\nthis:\n  invariant_nsc nsc J ((asi, tv, ui), s)\n  (case ((asi, tv, ui), s) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (asi, tv, ui) \\<Rightarrow>\n        \\<lambda>s.\n           if j \\<in> set ui then Inl [j]\n           else case assert_all_s (list_map_to_fun asi j) s of\n                Inl x \\<Rightarrow> Inl x\n                | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s'))\n      xa) =\n  Inr S'\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from pre(2)"], ["proof (chain)\npicking this:\n  (case ((asi, tv, ui), s) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (asi, tv, ui) \\<Rightarrow>\n        \\<lambda>s.\n           if j \\<in> set ui then Inl [j]\n           else case assert_all_s (list_map_to_fun asi j) s of\n                Inl x \\<Rightarrow> Inl x\n                | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s'))\n      xa) =\n  Inr S'", "obtain s' where\n    ok: \"assert_all_s (list_map_to_fun asi j) s = Inr s'\" and S': \"S' = ((asi,tv,ui),s')\" and j: \"j \\<notin> set ui\""], ["proof (prove)\nusing this:\n  (case ((asi, tv, ui), s) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (asi, tv, ui) \\<Rightarrow>\n        \\<lambda>s.\n           if j \\<in> set ui then Inl [j]\n           else case assert_all_s (list_map_to_fun asi j) s of\n                Inl x \\<Rightarrow> Inl x\n                | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s'))\n      xa) =\n  Inr S'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>assert_all_s (list_map_to_fun asi j) s = Inr s';\n         S' = ((asi, tv, ui), s'); j \\<notin> set ui\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: sum.splits if_splits)"], ["proof (state)\nthis:\n  assert_all_s (list_map_to_fun asi j) s = Inr s'\n  S' = ((asi, tv, ui), s')\n  j \\<notin> set ui\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from pre(1)[simplified]"], ["proof (chain)\npicking this:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}", "have inv: \"invariant_s t (set as \\<inter> J \\<times> UNIV) s\" \n    and asi: \"set (list_map_to_fun asi j) = set as \\<inter> {j} \\<times> UNIV\" \"invariant_as_asi (set as) asi tv tv' ui ui'\" \"J \\<inter> set ui = {}\""], ["proof (prove)\nusing this:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n\ngoal (1 subgoal):\n 1. invariant_s t (set as \\<inter> J \\<times> UNIV) s &&&\n    set (list_map_to_fun asi j) = set as \\<inter> {j} \\<times> UNIV &&&\n    invariant_as_asi (set as) asi tv tv' ui ui' &&& J \\<inter> set ui = {}", "by auto"], ["proof (state)\nthis:\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s\n  set (list_map_to_fun asi j) = set as \\<inter> {j} \\<times> UNIV\n  invariant_as_asi (set as) asi tv tv' ui ui'\n  J \\<inter> set ui = {}\n\ngoal (8 subgoals):\n 1. \\<And>nsc J s j s'.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc (insert j J) s'\n 2. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 4. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 5. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 6. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 7. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 8. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from assert_all_s_ok[OF inv ok, unfolded asi] asi(2-) j"], ["proof (chain)\npicking this:\n  invariant_s t\n   (set as \\<inter> {j} \\<times> UNIV \\<union>\n    set as \\<inter> J \\<times> UNIV)\n   s'\n  invariant_as_asi (set as) asi tv tv' ui ui'\n  J \\<inter> set ui = {}\n  j \\<notin> set ui", "show ?case"], ["proof (prove)\nusing this:\n  invariant_s t\n   (set as \\<inter> {j} \\<times> UNIV \\<union>\n    set as \\<inter> J \\<times> UNIV)\n   s'\n  invariant_as_asi (set as) asi tv tv' ui ui'\n  J \\<inter> set ui = {}\n  j \\<notin> set ui\n\ngoal (1 subgoal):\n 1. invariant_nsc nsc (insert j J) S'", "unfolding invariant_nsc.simps S' prep split"], ["proof (prove)\nusing this:\n  invariant_s t\n   (set as \\<inter> {j} \\<times> UNIV \\<union>\n    set as \\<inter> J \\<times> UNIV)\n   s'\n  invariant_as_asi (set as) asi tv tv' ui ui'\n  J \\<inter> set ui = {}\n  j \\<notin> set ui\n\ngoal (1 subgoal):\n 1. invariant_as_asi (set as) asi tv tv' ui ui' \\<and>\n    invariant_s t (set as \\<inter> insert j J \\<times> UNIV) s' \\<and>\n    insert j J \\<inter> set ui = {}", "by (metis Int_insert_left Sigma_Un_distrib1 inf_sup_distrib1 insert_is_Un)"], ["proof (state)\nthis:\n  invariant_nsc nsc (insert j J) S'\n\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (2 nsc J S j I)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  assert_nsc assert_all_s j S = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* assert unsat *)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  assert_nsc assert_all_s j S = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi s tv ui where S: \"S = ((asi,tv,ui),s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi tv ui s.\n        S = ((asi, tv, ui), s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = ((asi, tv, ui), s)\n\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain t as tv' ui' where prep[simp]: \"preprocess nsc = (t, as, tv', ui')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t as tv' ui'.\n        preprocess nsc = (t, as, tv', ui') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess nsc\")"], ["proof (state)\nthis:\n  preprocess nsc = (t, as, tv', ui')\n\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "note pre = 2[unfolded S assert_nsc_def split]"], ["proof (state)\nthis:\n  invariant_nsc nsc J ((asi, tv, ui), s)\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n\ngoal (7 subgoals):\n 1. \\<And>nsc J s j I.\n       \\<lbrakk>invariant_nsc nsc J s;\n        assert_nsc assert_all_s j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 3. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 4. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 5. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 6. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 7. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "proof (cases \"j \\<in> set ui\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "case False"], ["proof (state)\nthis:\n  j \\<notin> set ui\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "with pre(2)"], ["proof (chain)\npicking this:\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  j \\<notin> set ui", "have unsat: \"assert_all_s (list_map_to_fun asi j) s = Unsat I\""], ["proof (prove)\nusing this:\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  j \\<notin> set ui\n\ngoal (1 subgoal):\n 1. assert_all_s (list_map_to_fun asi j) s = Inl I", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  assert_all_s (list_map_to_fun asi j) s = Inl I\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "from pre(1)"], ["proof (chain)\npicking this:\n  invariant_nsc nsc J ((asi, tv, ui), s)", "have inv: \"invariant_s t (set as \\<inter> J \\<times> UNIV) s\" \n      and asi: \"set (list_map_to_fun asi j) = set as \\<inter> {j} \\<times> UNIV\""], ["proof (prove)\nusing this:\n  invariant_nsc nsc J ((asi, tv, ui), s)\n\ngoal (1 subgoal):\n 1. invariant_s t (set as \\<inter> J \\<times> UNIV) s &&&\n    set (list_map_to_fun asi j) = set as \\<inter> {j} \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s\n  set (list_map_to_fun asi j) = set as \\<inter> {j} \\<times> UNIV\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "from assert_all_s_unsat[OF inv unsat, unfolded asi]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> J \\<times> UNIV \\<union>\n    set as \\<inter> {j} \\<times> UNIV)", "have \"minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> J \\<times> UNIV \\<union> set as \\<inter> {j} \\<times> UNIV)\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> J \\<times> UNIV \\<union>\n    set as \\<inter> {j} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t\n     (set as \\<inter> J \\<times> UNIV \\<union>\n      set as \\<inter> {j} \\<times> UNIV)", "."], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> J \\<times> UNIV \\<union>\n    set as \\<inter> {j} \\<times> UNIV)\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "also"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> J \\<times> UNIV \\<union>\n    set as \\<inter> {j} \\<times> UNIV)\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "have \"set as \\<inter> J \\<times> UNIV \\<union> set as \\<inter> {j} \\<times> UNIV = set as \\<inter> insert j J \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set as \\<inter> J \\<times> UNIV \\<union>\n    set as \\<inter> {j} \\<times> UNIV =\n    set as \\<inter> insert j J \\<times> UNIV", "by blast"], ["proof (state)\nthis:\n  set as \\<inter> J \\<times> UNIV \\<union>\n  set as \\<inter> {j} \\<times> UNIV =\n  set as \\<inter> insert j J \\<times> UNIV\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "finally"], ["proof (chain)\npicking this:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> insert j J \\<times> UNIV)", "have unsat: \"minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> insert j J \\<times> UNIV)\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> insert j J \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t\n     (set as \\<inter> insert j J \\<times> UNIV)", "."], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> insert j J \\<times> UNIV)\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "hence I: \"set I \\<subseteq> insert j J\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t\n   (set as \\<inter> insert j J \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J", "unfolding minimal_unsat_core_tabl_atoms_def"], ["proof (prove)\nusing this:\n  set I \\<subseteq> fst ` (set as \\<inter> insert j J \\<times> UNIV) \\<and>\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>t t \\<and>\n      (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s\n      (set as \\<inter> insert j J \\<times> UNIV)) \\<and>\n  (distinct_indices_atoms\n    (set as \\<inter> insert j J \\<times> UNIV) \\<longrightarrow>\n   (\\<forall>Ja\\<subset>set I.\n       \\<exists>v.\n          v \\<Turnstile>\\<^sub>t t \\<and>\n          (Ja, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n          (set as \\<inter> insert j J \\<times> UNIV)))\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J", "by force"], ["proof (state)\nthis:\n  set I \\<subseteq> insert j J\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "with False pre"], ["proof (chain)\npicking this:\n  j \\<notin> set ui\n  invariant_nsc nsc J ((asi, tv, ui), s)\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  set I \\<subseteq> insert j J", "have empty: \"set I \\<inter> set ui' = {}\""], ["proof (prove)\nusing this:\n  j \\<notin> set ui\n  invariant_nsc nsc J ((asi, tv, ui), s)\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  set I \\<subseteq> insert j J\n\ngoal (1 subgoal):\n 1. set I \\<inter> set ui' = {}", "by auto"], ["proof (state)\nthis:\n  set I \\<inter> set ui' = {}\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "have \"minimal_unsat_core_tabl_atoms (set I) t (set as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (set as)", "by (rule minimal_unsat_core_tabl_atoms_mono[OF _ unsat], auto)"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (set as)\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "from preprocess_minimal_unsat_core[OF prep this empty]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_ns (set I) (set nsc)", "have \"minimal_unsat_core_ns (set I) (set nsc)\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_ns (set I) (set nsc)", "."], ["proof (state)\nthis:\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (2 subgoals):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)\n 2. j \\<notin> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "then"], ["proof (chain)\npicking this:\n  minimal_unsat_core_ns (set I) (set nsc)", "show ?thesis"], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "using I"], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns (set I) (set nsc)\n  set I \\<subseteq> insert j J\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "by blast"], ["proof (state)\nthis:\n  set I \\<subseteq> insert j J \\<and>\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (1 subgoal):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "case True"], ["proof (state)\nthis:\n  j \\<in> set ui\n\ngoal (1 subgoal):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "with pre(2)"], ["proof (chain)\npicking this:\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  j \\<in> set ui", "have I: \"I = [j]\""], ["proof (prove)\nusing this:\n  (if j \\<in> set ui then Inl [j]\n   else case assert_all_s (list_map_to_fun asi j) s of\n        Inl x \\<Rightarrow> Inl x\n        | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  j \\<in> set ui\n\ngoal (1 subgoal):\n 1. I = [j]", "by auto"], ["proof (state)\nthis:\n  I = [j]\n\ngoal (1 subgoal):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "from pre(1)[unfolded invariant_nsc.simps prep split invariant_as_asi.simps]"], ["proof (chain)\npicking this:\n  (tv = tv' \\<and>\n   set ui = set ui' \\<and>\n   (\\<forall>i.\n       set (list_map_to_fun asi i) =\n       set as \\<inter> {i} \\<times> UNIV)) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}", "have \"set ui = set ui'\""], ["proof (prove)\nusing this:\n  (tv = tv' \\<and>\n   set ui = set ui' \\<and>\n   (\\<forall>i.\n       set (list_map_to_fun asi i) =\n       set as \\<inter> {i} \\<times> UNIV)) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n\ngoal (1 subgoal):\n 1. set ui = set ui'", "by simp"], ["proof (state)\nthis:\n  set ui = set ui'\n\ngoal (1 subgoal):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "with True"], ["proof (chain)\npicking this:\n  j \\<in> set ui\n  set ui = set ui'", "have j: \"j \\<in> set ui'\""], ["proof (prove)\nusing this:\n  j \\<in> set ui\n  set ui = set ui'\n\ngoal (1 subgoal):\n 1. j \\<in> set ui'", "by auto"], ["proof (state)\nthis:\n  j \\<in> set ui'\n\ngoal (1 subgoal):\n 1. j \\<in> set ui \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "from preprocess_unsat_index[OF prep j]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_ns {j} (set nsc)", "show ?thesis"], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns {j} (set nsc)\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set I) (set nsc)", "unfolding I"], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns {j} (set nsc)\n\ngoal (1 subgoal):\n 1. set [j] \\<subseteq> insert j J \\<and>\n    minimal_unsat_core_ns (set [j]) (set nsc)", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> insert j J \\<and>\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set I \\<subseteq> insert j J \\<and>\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (6 subgoals):\n 1. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 2. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 4. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 5. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 6. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 2. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 4. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 5. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 6. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (3 nsc J S S')"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inr S'\n\ngoal (6 subgoals):\n 1. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 2. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 4. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 5. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 6. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* check ok *)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inr S'\n\ngoal (6 subgoals):\n 1. \\<And>nsc J s s'.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_nsc nsc J s'\n 2. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 3. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 4. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 5. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 6. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "then"], ["proof (chain)\npicking this:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inr S'", "show ?case"], ["proof (prove)\nusing this:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inr S'\n\ngoal (1 subgoal):\n 1. checked_nsc nsc J S'", "using check_s_ok"], ["proof (prove)\nusing this:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inr S'\n  \\<lbrakk>invariant_s ?t ?as ?s; check_s ?s = Inr ?s'\\<rbrakk>\n  \\<Longrightarrow> checked_s ?t ?as ?s'\n\ngoal (1 subgoal):\n 1. checked_nsc nsc J S'", "unfolding check_nsc_def"], ["proof (prove)\nusing this:\n  invariant_nsc nsc J S\n  sum_wrap (\\<lambda>asitv. check_s) S = Inr S'\n  \\<lbrakk>invariant_s ?t ?as ?s; check_s ?s = Inr ?s'\\<rbrakk>\n  \\<Longrightarrow> checked_s ?t ?as ?s'\n\ngoal (1 subgoal):\n 1. checked_nsc nsc J S'", "by (cases S, auto split: sum.splits)"], ["proof (state)\nthis:\n  checked_nsc nsc J S'\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (4 nsc J S I)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* check unsat *)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n  check_nsc check_s S = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi s tv ui where S: \"S = ((asi,tv,ui),s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi tv ui s.\n        S = ((asi, tv, ui), s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = ((asi, tv, ui), s)\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain t as tv' ui' where prep[simp]: \"preprocess nsc = (t, as, tv', ui')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t as tv' ui'.\n        preprocess nsc = (t, as, tv', ui') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess nsc\")"], ["proof (state)\nthis:\n  preprocess nsc = (t, as, tv', ui')\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "note pre = 4[unfolded S check_nsc_def, simplified]"], ["proof (state)\nthis:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n  (case check_s s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from pre"], ["proof (chain)\npicking this:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n  (case check_s s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I", "have \n    unsat: \"check_s s = Unsat I\"  and\n    inv: \"invariant_s t (set as \\<inter> J \\<times> UNIV) s\""], ["proof (prove)\nusing this:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n  (case check_s s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n\ngoal (1 subgoal):\n 1. check_s s = Inl I &&& invariant_s t (set as \\<inter> J \\<times> UNIV) s", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  check_s s = Inl I\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from check_s_unsat[OF inv unsat]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> J \\<times> UNIV)", "have unsat: \"minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> J \\<times> UNIV)\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> J \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t\n     (set as \\<inter> J \\<times> UNIV)", "."], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> J \\<times> UNIV)\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "hence I: \"set I \\<subseteq> J\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_tabl_atoms (set I) t (set as \\<inter> J \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J", "unfolding minimal_unsat_core_tabl_atoms_def"], ["proof (prove)\nusing this:\n  set I \\<subseteq> fst ` (set as \\<inter> J \\<times> UNIV) \\<and>\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>t t \\<and>\n      (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s\n      (set as \\<inter> J \\<times> UNIV)) \\<and>\n  (distinct_indices_atoms\n    (set as \\<inter> J \\<times> UNIV) \\<longrightarrow>\n   (\\<forall>Ja\\<subset>set I.\n       \\<exists>v.\n          v \\<Turnstile>\\<^sub>t t \\<and>\n          (Ja, v) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>e\\<^sub>s\n          (set as \\<inter> J \\<times> UNIV)))\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J", "by force"], ["proof (state)\nthis:\n  set I \\<subseteq> J\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "with pre"], ["proof (chain)\npicking this:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n  (case check_s s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  set I \\<subseteq> J", "have empty: \"set I \\<inter> set ui' = {}\""], ["proof (prove)\nusing this:\n  tv = tv' \\<and>\n  set ui = set ui' \\<and>\n  (\\<forall>i.\n      set (list_map_to_fun asi i) =\n      set as \\<inter> {i} \\<times> UNIV) \\<and>\n  invariant_s t (set as \\<inter> J \\<times> UNIV) s \\<and>\n  J \\<inter> set ui = {}\n  (case check_s s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr ((asi, tv, ui), s')) =\n  Inl I\n  set I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. set I \\<inter> set ui' = {}", "by auto"], ["proof (state)\nthis:\n  set I \\<inter> set ui' = {}\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "have \"minimal_unsat_core_tabl_atoms (set I) t (set as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_tabl_atoms (set I) t (set as)", "by (rule minimal_unsat_core_tabl_atoms_mono[OF _ unsat], auto)"], ["proof (state)\nthis:\n  minimal_unsat_core_tabl_atoms (set I) t (set as)\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from preprocess_minimal_unsat_core[OF prep this empty]"], ["proof (chain)\npicking this:\n  minimal_unsat_core_ns (set I) (set nsc)", "have \"minimal_unsat_core_ns (set I) (set nsc)\""], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_ns (set I) (set nsc)", "."], ["proof (state)\nthis:\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (5 subgoals):\n 1. \\<And>nsc J s I.\n       \\<lbrakk>invariant_nsc nsc J s; check_nsc check_s s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core_ns (set I) (set nsc)\n 2. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 3. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 4. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 5. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "then"], ["proof (chain)\npicking this:\n  minimal_unsat_core_ns (set I) (set nsc)", "show ?case"], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J \\<and> minimal_unsat_core_ns (set I) (set nsc)", "using I"], ["proof (prove)\nusing this:\n  minimal_unsat_core_ns (set I) (set nsc)\n  set I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J \\<and> minimal_unsat_core_ns (set I) (set nsc)", "by blast"], ["proof (state)\nthis:\n  set I \\<subseteq> J \\<and> minimal_unsat_core_ns (set I) (set nsc)\n\ngoal (4 subgoals):\n 1. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 2. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 3. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 4. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 2. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 3. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 4. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (5 nsc)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 2. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 3. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 4. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* init *)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 2. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 3. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 4. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain t as tv' ui' where prep[simp]: \"preprocess nsc = (t, as, tv', ui')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t as tv' ui'.\n        preprocess nsc = (t, as, tv', ui') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess nsc\")"], ["proof (state)\nthis:\n  preprocess nsc = (t, as, tv', ui')\n\ngoal (4 subgoals):\n 1. \\<And>nsc. checked_nsc nsc {} (init_nsc nsc)\n 2. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 3. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 4. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_nsc nsc {} (init_nsc nsc)", "unfolding init_nsc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_nsc nsc {}\n     (case preprocess nsc of\n      (t, as, trans_v, ui) \\<Rightarrow>\n        ((create_map as, trans_v, remdups ui), init_s t))", "using init_s preprocess_tableau_normalized[OF prep]"], ["proof (prove)\nusing this:\n  \\<triangle> ?t \\<Longrightarrow> checked_s ?t {} (init_s ?t)\n  \\<triangle> t\n\ngoal (1 subgoal):\n 1. checked_nsc nsc {}\n     (case preprocess nsc of\n      (t, as, trans_v, ui) \\<Rightarrow>\n        ((create_map as, trans_v, remdups ui), init_s t))", "by (auto simp: list_map_to_fun_create_map)"], ["proof (state)\nthis:\n  checked_nsc nsc {} (init_nsc nsc)\n\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (6 nsc J S v)"], ["proof (state)\nthis:\n  checked_nsc nsc J S\n  solution_nsc solution_s S = v\n\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* solution *)"], ["proof (state)\nthis:\n  checked_nsc nsc J S\n  solution_nsc solution_s S = v\n\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi s tv ui where S: \"S = ((asi,tv,ui),s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi tv ui s.\n        S = ((asi, tv, ui), s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = ((asi, tv, ui), s)\n\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain t as tv' ui' where prep[simp]: \"preprocess nsc = (t, as, tv', ui')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t as tv' ui'.\n        preprocess nsc = (t, as, tv', ui') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess nsc\")"], ["proof (state)\nthis:\n  preprocess nsc = (t, as, tv', ui')\n\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "have \"(J,\\<langle>solution_s s\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s set as\" \"\\<langle>solution_s s\\<rangle> \\<Turnstile>\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (J, \\<langle>solution_s s\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s\n    set as &&&\n    \\<langle>solution_s s\\<rangle> \\<Turnstile>\\<^sub>t t", "using 6 S solution_s[of t _ s]"], ["proof (prove)\nusing this:\n  checked_nsc nsc J S\n  solution_nsc solution_s S = v\n  S = ((asi, tv, ui), s)\n  \\<lbrakk>checked_s t ?as s; solution_s s = ?v\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n                    \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s\n                    (snd ` ?as)\n\ngoal (1 subgoal):\n 1. (J, \\<langle>solution_s s\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s\n    set as &&&\n    \\<langle>solution_s s\\<rangle> \\<Turnstile>\\<^sub>t t", "by auto"], ["proof (state)\nthis:\n  (J, \\<langle>solution_s s\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>a\\<^sub>s\n  set as\n  \\<langle>solution_s s\\<rangle> \\<Turnstile>\\<^sub>t t\n\ngoal (3 subgoals):\n 1. \\<And>nsc J s v.\n       \\<lbrakk>checked_nsc nsc J s; solution_nsc solution_s s = v\\<rbrakk>\n       \\<Longrightarrow> (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n                         set nsc\n 2. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 3. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from i_preprocess_sat[OF prep _ this]"], ["proof (chain)\npicking this:\n  J \\<inter> set ui' = {} \\<Longrightarrow>\n  (J, \\<langle>tv' (solution_s\n                     s)\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set nsc", "show ?case"], ["proof (prove)\nusing this:\n  J \\<inter> set ui' = {} \\<Longrightarrow>\n  (J, \\<langle>tv' (solution_s\n                     s)\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set nsc\n\ngoal (1 subgoal):\n 1. (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n    set nsc", "using 6 S"], ["proof (prove)\nusing this:\n  J \\<inter> set ui' = {} \\<Longrightarrow>\n  (J, \\<langle>tv' (solution_s\n                     s)\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set nsc\n  checked_nsc nsc J S\n  solution_nsc solution_s S = v\n  S = ((asi, tv, ui), s)\n\ngoal (1 subgoal):\n 1. (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n    set nsc", "by auto"], ["proof (state)\nthis:\n  (J, \\<langle>v\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set nsc\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (7 nsc J S c K S' S'')"], ["proof (state)\nthis:\n  checked_nsc nsc J S\n  checkpoint_nsc checkpoint_s S = c\n  invariant_nsc nsc K S'\n  backtrack_nsc backtrack_s c S' = S''\n  J \\<subseteq> K\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "(* backtrack *)"], ["proof (state)\nthis:\n  checked_nsc nsc J S\n  checkpoint_nsc checkpoint_s S = c\n  invariant_nsc nsc K S'\n  backtrack_nsc backtrack_s c S' = S''\n  J \\<subseteq> K\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain t as tvp uip where prep[simp]: \"preprocess nsc = (t, as, tvp, uip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t as tvp uip.\n        preprocess nsc = (t, as, tvp, uip) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess nsc\")"], ["proof (state)\nthis:\n  preprocess nsc = (t, as, tvp, uip)\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi s tv ui where S: \"S = ((asi,tv,ui),s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi tv ui s.\n        S = ((asi, tv, ui), s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = ((asi, tv, ui), s)\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi' s' tv' ui' where S': \"S' = ((asi',tv',ui'),s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi' tv' ui' s'.\n        S' = ((asi', tv', ui'), s') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S', auto)"], ["proof (state)\nthis:\n  S' = ((asi', tv', ui'), s')\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "obtain asi'' s'' tv'' ui'' where S'': \"S'' = ((asi'',tv'',ui''),s'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>asi'' tv'' ui'' s''.\n        S'' = ((asi'', tv'', ui''), s'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S'', auto)"], ["proof (state)\nthis:\n  S'' = ((asi'', tv'', ui''), s'')\n\ngoal (2 subgoals):\n 1. \\<And>nsc J s c K s' s''.\n       \\<lbrakk>checked_nsc nsc J s; checkpoint_nsc checkpoint_s s = c;\n        invariant_nsc nsc K s'; backtrack_nsc backtrack_s c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_nsc nsc J s''\n 2. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "from backtrack_s[of t _ s c _ s' s'']"], ["proof (chain)\npicking this:\n  \\<lbrakk>checked_s t ?as s; checkpoint_s s = c; invariant_s t ?bs s';\n   backtrack_s c s' = s''; ?as \\<subseteq> ?bs\\<rbrakk>\n  \\<Longrightarrow> invariant_s t ?as s''", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>checked_s t ?as s; checkpoint_s s = c; invariant_s t ?bs s';\n   backtrack_s c s' = s''; ?as \\<subseteq> ?bs\\<rbrakk>\n  \\<Longrightarrow> invariant_s t ?as s''\n\ngoal (1 subgoal):\n 1. invariant_nsc nsc J S''", "using 7 S S' S''"], ["proof (prove)\nusing this:\n  \\<lbrakk>checked_s t ?as s; checkpoint_s s = c; invariant_s t ?bs s';\n   backtrack_s c s' = s''; ?as \\<subseteq> ?bs\\<rbrakk>\n  \\<Longrightarrow> invariant_s t ?as s''\n  checked_nsc nsc J S\n  checkpoint_nsc checkpoint_s S = c\n  invariant_nsc nsc K S'\n  backtrack_nsc backtrack_s c S' = S''\n  J \\<subseteq> K\n  S = ((asi, tv, ui), s)\n  S' = ((asi', tv', ui'), s')\n  S'' = ((asi'', tv'', ui''), s'')\n\ngoal (1 subgoal):\n 1. invariant_nsc nsc J S''", "by auto"], ["proof (state)\nthis:\n  invariant_nsc nsc J S''\n\ngoal (1 subgoal):\n 1. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "case (8 nsc J S)"], ["proof (state)\nthis:\n  checked_nsc nsc J S\n\ngoal (1 subgoal):\n 1. \\<And>nsc J s.\n       checked_nsc nsc J s \\<Longrightarrow> invariant_nsc nsc J s", "then"], ["proof (chain)\npicking this:\n  checked_nsc nsc J S", "show ?case"], ["proof (prove)\nusing this:\n  checked_nsc nsc J S\n\ngoal (1 subgoal):\n 1. invariant_nsc nsc J S", "using checked_invariant_s"], ["proof (prove)\nusing this:\n  checked_nsc nsc J S\n  checked_s ?t ?as ?s \\<Longrightarrow> invariant_s ?t ?as ?s\n\ngoal (1 subgoal):\n 1. invariant_nsc nsc J S", "by (cases S, auto)"], ["proof (state)\nthis:\n  invariant_nsc nsc J S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Highest Layer: Incremental Constraints\\<close>"], ["", "text \\<open>Interface\\<close>"], ["", "locale Incremental_Simplex_Ops = fixes \n  init_cs :: \"'i i_constraint list \\<Rightarrow> 's\" and\n  assert_cs :: \"'i \\<Rightarrow> 's \\<Rightarrow> 'i list + 's\" and\n  check_cs :: \"'s \\<Rightarrow> 'i list + 's\" and\n  solution_cs :: \"'s \\<Rightarrow> rat valuation\" and\n  checkpoint_cs :: \"'s \\<Rightarrow> 'c\" and\n  backtrack_cs :: \"'c \\<Rightarrow> 's \\<Rightarrow> 's\" and\n  invariant_cs :: \"'i i_constraint list \\<Rightarrow> 'i set \\<Rightarrow> 's \\<Rightarrow> bool\" and\n  checked_cs :: \"'i i_constraint list \\<Rightarrow> 'i set \\<Rightarrow> 's \\<Rightarrow> bool\"\nassumes \n  assert_cs_ok: \"invariant_cs cs J s \\<Longrightarrow> assert_cs j s = Inr s' \\<Longrightarrow> \n    invariant_cs cs (insert j J) s'\" and\n  assert_cs_unsat: \"invariant_cs cs J s \\<Longrightarrow> assert_cs j s = Unsat I \\<Longrightarrow>\n    set I \\<subseteq> insert j J \\<and> minimal_unsat_core (set I) cs\" and\n  check_cs_ok: \"invariant_cs cs J s \\<Longrightarrow> check_cs s = Inr s' \\<Longrightarrow> \n    checked_cs cs J s'\" and\n  check_cs_unsat: \"invariant_cs cs J s \\<Longrightarrow> check_cs s = Unsat I \\<Longrightarrow>\n    set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\" and\n  init_cs: \"checked_cs cs {} (init_cs cs)\" and\n  solution_cs: \"checked_cs cs J s \\<Longrightarrow> solution_cs s = v \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\" and\n  backtrack_cs: \"checked_cs cs J s \\<Longrightarrow> checkpoint_cs s = c \n    \\<Longrightarrow> invariant_cs cs K s' \\<Longrightarrow> backtrack_cs c s' = s'' \\<Longrightarrow> J \\<subseteq> K \\<Longrightarrow> invariant_cs cs J s''\" and\n  checked_invariant_cs: \"checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s\""], ["", "text \\<open>Implementation via the Simplex-operation To-Ns and the Incremental Operations for Non-Strict Constraints\\<close>"], ["", "fun assert_cs where \"assert_cs ass i (cs,s) = (case ass i s of \n    Unsat I \\<Rightarrow> Unsat I \n  | Inr s' \\<Rightarrow> Inr (cs, s'))\""], ["", "definition \"init_cs init tons cs = (let tons_cs = tons cs in (map snd (tons_cs), init tons_cs))\""], ["", "definition \"check_cs check s = sum_wrap (\\<lambda> cs. check) s\""], ["", "fun checkpoint_cs where \"checkpoint_cs checkp (cs,s) = (checkp s)\""], ["", "fun backtrack_cs where \"backtrack_cs backt c (cs,s) = (cs, backt c s)\""], ["", "fun solution_cs where \"solution_cs sol from (cs,s) = (\\<langle>from (sol s) cs\\<rangle>)\""], ["", "locale Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex =\n  Incremental_NS_Constraint_Ops init_nsc assert_nsc check_nsc solution_nsc checkpoint_nsc backtrack_nsc \n  invariant_nsc checked_nsc + To_ns to_ns from_ns\n  for \n    init_nsc :: \"('i,'a :: lrv) i_ns_constraint list \\<Rightarrow> 's\" and\n    assert_nsc :: \"'i \\<Rightarrow> 's \\<Rightarrow> 'i list + 's\" and\n    check_nsc :: \"'s \\<Rightarrow> 'i list + 's\" and\n    solution_nsc :: \"'s \\<Rightarrow> (var, 'a) mapping\" and\n    checkpoint_nsc :: \"'s \\<Rightarrow> 'c\" and\n    backtrack_nsc :: \"'c \\<Rightarrow> 's \\<Rightarrow> 's\" and\n    invariant_nsc :: \"('i,'a) i_ns_constraint list \\<Rightarrow> 'i set \\<Rightarrow> 's \\<Rightarrow> bool\" and\n    checked_nsc :: \"('i,'a) i_ns_constraint list \\<Rightarrow> 'i set \\<Rightarrow> 's \\<Rightarrow> bool\" and\n    to_ns :: \"'i i_constraint list \\<Rightarrow> ('i,'a) i_ns_constraint list\" and\n    from_ns :: \"(var, 'a) mapping \\<Rightarrow> 'a ns_constraint list \\<Rightarrow> (var, rat) mapping\"\nbegin"], ["", "fun invariant_cs where \n  \"invariant_cs cs J (ds,s) = (ds = map snd (to_ns cs) \\<and> invariant_nsc (to_ns cs) J s)\""], ["", "fun checked_cs where \n  \"checked_cs cs J (ds,s) = (ds = map snd (to_ns cs) \\<and> checked_nsc (to_ns cs) J s)\""], ["", "sublocale Incremental_Simplex_Ops \"init_cs init_nsc to_ns\" \"assert_cs assert_nsc\"\n  \"check_cs check_nsc\" \"solution_cs solution_nsc from_ns\" \"checkpoint_cs checkpoint_nsc\" \"backtrack_cs backtrack_nsc\" \n  invariant_cs checked_cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Incremental_Simplex_Ops (init_cs init_nsc to_ns) (assert_cs assert_nsc)\n     (check_cs check_nsc) (solution_cs solution_nsc from_ns)\n     (checkpoint_cs checkpoint_nsc) (backtrack_cs backtrack_nsc)\n     invariant_cs checked_cs", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (1 cs J S j S')"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inr S'\n\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* assert ok *)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inr S'\n\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inr S'", "obtain s where S: \"S = (map snd (to_ns cs),s)\""], ["proof (prove)\nusing this:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inr S'\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        S = (map snd (to_ns cs), s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = (map snd (to_ns cs), s)\n\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "note pre = 1[unfolded S assert_cs.simps]"], ["proof (state)\nthis:\n  invariant_cs cs J (map snd (to_ns cs), s)\n  (case assert_nsc j s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr (map snd (to_ns cs), s')) =\n  Inr S'\n\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre(2)"], ["proof (chain)\npicking this:\n  (case assert_nsc j s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr (map snd (to_ns cs), s')) =\n  Inr S'", "obtain s' where\n    ok: \"assert_nsc j s = Inr s'\" and S': \"S' = (map snd (to_ns cs),s')\""], ["proof (prove)\nusing this:\n  (case assert_nsc j s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr (map snd (to_ns cs), s')) =\n  Inr S'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>assert_nsc j s = Inr s';\n         S' = (map snd (to_ns cs), s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  assert_nsc j s = Inr s'\n  S' = (map snd (to_ns cs), s')\n\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre(1)"], ["proof (chain)\npicking this:\n  invariant_cs cs J (map snd (to_ns cs), s)", "have inv: \"invariant_nsc (to_ns cs) J s\""], ["proof (prove)\nusing this:\n  invariant_cs cs J (map snd (to_ns cs), s)\n\ngoal (1 subgoal):\n 1. invariant_nsc (to_ns cs) J s", "by simp"], ["proof (state)\nthis:\n  invariant_nsc (to_ns cs) J s\n\ngoal (8 subgoals):\n 1. \\<And>cs J s j s'.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs (insert j J) s'\n 2. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 4. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 5. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 6. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 7. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 8. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from assert_nsc_ok[OF inv ok]"], ["proof (chain)\npicking this:\n  invariant_nsc (to_ns cs) (insert j J) s'", "show ?case"], ["proof (prove)\nusing this:\n  invariant_nsc (to_ns cs) (insert j J) s'\n\ngoal (1 subgoal):\n 1. invariant_cs cs (insert j J) S'", "unfolding invariant_cs.simps S' split"], ["proof (prove)\nusing this:\n  invariant_nsc (to_ns cs) (insert j J) s'\n\ngoal (1 subgoal):\n 1. map snd (to_ns cs) = map snd (to_ns cs) \\<and>\n    invariant_nsc (to_ns cs) (insert j J) s'", "by auto"], ["proof (state)\nthis:\n  invariant_cs cs (insert j J) S'\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (2 cs J S j I)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* assert unsat *)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inl I", "obtain s where S: \"S = (map snd (to_ns cs), s)\""], ["proof (prove)\nusing this:\n  invariant_cs cs J S\n  assert_cs assert_nsc j S = Inl I\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        S = (map snd (to_ns cs), s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = (map snd (to_ns cs), s)\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "note pre = 2[unfolded S assert_cs.simps]"], ["proof (state)\nthis:\n  invariant_cs cs J (map snd (to_ns cs), s)\n  (case assert_nsc j s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr (map snd (to_ns cs), s')) =\n  Inl I\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre(2)"], ["proof (chain)\npicking this:\n  (case assert_nsc j s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr (map snd (to_ns cs), s')) =\n  Inl I", "have unsat: \"assert_nsc j s = Unsat I\""], ["proof (prove)\nusing this:\n  (case assert_nsc j s of Inl x \\<Rightarrow> Inl x\n   | Inr s' \\<Rightarrow> Inr (map snd (to_ns cs), s')) =\n  Inl I\n\ngoal (1 subgoal):\n 1. assert_nsc j s = Inl I", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  assert_nsc j s = Inl I\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre(1)"], ["proof (chain)\npicking this:\n  invariant_cs cs J (map snd (to_ns cs), s)", "have inv: \"invariant_nsc (to_ns cs) J s\""], ["proof (prove)\nusing this:\n  invariant_cs cs J (map snd (to_ns cs), s)\n\ngoal (1 subgoal):\n 1. invariant_nsc (to_ns cs) J s", "by auto"], ["proof (state)\nthis:\n  invariant_nsc (to_ns cs) J s\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from assert_nsc_unsat[OF inv unsat]"], ["proof (chain)\npicking this:\n  set I \\<subseteq> insert j J \\<and>\n  minimal_unsat_core_ns (set I) (set (to_ns cs))", "have \"set I \\<subseteq> insert j J\" \"minimal_unsat_core_ns (set I) (set (to_ns cs))\""], ["proof (prove)\nusing this:\n  set I \\<subseteq> insert j J \\<and>\n  minimal_unsat_core_ns (set I) (set (to_ns cs))\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J &&&\n    minimal_unsat_core_ns (set I) (set (to_ns cs))", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> insert j J\n  minimal_unsat_core_ns (set I) (set (to_ns cs))\n\ngoal (7 subgoals):\n 1. \\<And>cs J s j I.\n       \\<lbrakk>invariant_cs cs J s;\n        assert_cs assert_nsc j s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 3. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 4. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 5. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 6. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 7. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from to_ns_unsat[OF this(2)] this(1)"], ["proof (chain)\npicking this:\n  minimal_unsat_core (set I) cs\n  set I \\<subseteq> insert j J", "show ?case"], ["proof (prove)\nusing this:\n  minimal_unsat_core (set I) cs\n  set I \\<subseteq> insert j J\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> insert j J \\<and> minimal_unsat_core (set I) cs", "by blast"], ["proof (state)\nthis:\n  set I \\<subseteq> insert j J \\<and> minimal_unsat_core (set I) cs\n\ngoal (6 subgoals):\n 1. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 2. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 4. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 5. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 6. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 2. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 4. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 5. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 6. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (3 cs J S S')"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inr S'\n\ngoal (6 subgoals):\n 1. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 2. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 4. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 5. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 6. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* check ok *)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inr S'\n\ngoal (6 subgoals):\n 1. \\<And>cs J s s'.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> checked_cs cs J s'\n 2. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 3. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 4. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 5. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 6. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inr S'", "show ?case"], ["proof (prove)\nusing this:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inr S'\n\ngoal (1 subgoal):\n 1. checked_cs cs J S'", "using check_nsc_ok"], ["proof (prove)\nusing this:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inr S'\n  \\<lbrakk>invariant_nsc ?nsc ?J ?s; check_nsc ?s = Inr ?s'\\<rbrakk>\n  \\<Longrightarrow> checked_nsc ?nsc ?J ?s'\n\ngoal (1 subgoal):\n 1. checked_cs cs J S'", "unfolding check_cs_def"], ["proof (prove)\nusing this:\n  invariant_cs cs J S\n  sum_wrap (\\<lambda>cs. check_nsc) S = Inr S'\n  \\<lbrakk>invariant_nsc ?nsc ?J ?s; check_nsc ?s = Inr ?s'\\<rbrakk>\n  \\<Longrightarrow> checked_nsc ?nsc ?J ?s'\n\ngoal (1 subgoal):\n 1. checked_cs cs J S'", "by (cases S, auto split: sum.splits)"], ["proof (state)\nthis:\n  checked_cs cs J S'\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (4 cs J S I)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* check unsat *)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inl I", "obtain s where S: \"S = (map snd (to_ns cs),s)\""], ["proof (prove)\nusing this:\n  invariant_cs cs J S\n  check_cs check_nsc S = Inl I\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        S = (map snd (to_ns cs), s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = (map snd (to_ns cs), s)\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "note pre = 4[unfolded S check_cs_def]"], ["proof (state)\nthis:\n  invariant_cs cs J (map snd (to_ns cs), s)\n  sum_wrap (\\<lambda>cs. check_nsc) (map snd (to_ns cs), s) = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre(2)"], ["proof (chain)\npicking this:\n  sum_wrap (\\<lambda>cs. check_nsc) (map snd (to_ns cs), s) = Inl I", "have unsat: \"check_nsc s = Unsat I\""], ["proof (prove)\nusing this:\n  sum_wrap (\\<lambda>cs. check_nsc) (map snd (to_ns cs), s) = Inl I\n\ngoal (1 subgoal):\n 1. check_nsc s = Inl I", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  check_nsc s = Inl I\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre(1)"], ["proof (chain)\npicking this:\n  invariant_cs cs J (map snd (to_ns cs), s)", "have inv: \"invariant_nsc (to_ns cs) J s\""], ["proof (prove)\nusing this:\n  invariant_cs cs J (map snd (to_ns cs), s)\n\ngoal (1 subgoal):\n 1. invariant_nsc (to_ns cs) J s", "by auto"], ["proof (state)\nthis:\n  invariant_nsc (to_ns cs) J s\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from check_nsc_unsat[OF inv unsat]"], ["proof (chain)\npicking this:\n  set I \\<subseteq> J \\<and> minimal_unsat_core_ns (set I) (set (to_ns cs))", "have \"set I \\<subseteq> J\" \"minimal_unsat_core_ns (set I) (set (to_ns cs))\""], ["proof (prove)\nusing this:\n  set I \\<subseteq> J \\<and> minimal_unsat_core_ns (set I) (set (to_ns cs))\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J &&& minimal_unsat_core_ns (set I) (set (to_ns cs))", "unfolding minimal_unsat_core_ns_def"], ["proof (prove)\nusing this:\n  set I \\<subseteq> J \\<and>\n  set I \\<subseteq> fst ` set (to_ns cs) \\<and>\n  (\\<nexists>v.\n      (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n      set (to_ns cs)) \\<and>\n  (distinct_indices_ns (set (to_ns cs)) \\<longrightarrow>\n   (\\<forall>J\\<subset>set I.\n       \\<exists>v.\n          (J, v) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n          set (to_ns cs)))\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J &&&\n    set I \\<subseteq> fst ` set (to_ns cs) \\<and>\n    (\\<nexists>v.\n        (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n        set (to_ns cs)) \\<and>\n    (distinct_indices_ns (set (to_ns cs)) \\<longrightarrow>\n     (\\<forall>J\\<subset>set I.\n         \\<exists>v.\n            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n            set (to_ns cs)))", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> J\n  minimal_unsat_core_ns (set I) (set (to_ns cs))\n\ngoal (5 subgoals):\n 1. \\<And>cs J s I.\n       \\<lbrakk>invariant_cs cs J s; check_cs check_nsc s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 3. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 4. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 5. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from to_ns_unsat[OF this(2)] this(1)"], ["proof (chain)\npicking this:\n  minimal_unsat_core (set I) cs\n  set I \\<subseteq> J", "show ?case"], ["proof (prove)\nusing this:\n  minimal_unsat_core (set I) cs\n  set I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs", "by blast"], ["proof (state)\nthis:\n  set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\n\ngoal (4 subgoals):\n 1. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 2. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 3. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 4. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 2. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 3. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 4. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (5 cs)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 2. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 3. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 4. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* init *)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>cs. checked_cs cs {} (init_cs init_nsc to_ns cs)\n 2. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 3. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 4. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_cs cs {} (init_cs init_nsc to_ns cs)", "unfolding init_cs_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_cs cs {} (map snd (to_ns cs), init_nsc (to_ns cs))", "using init_nsc"], ["proof (prove)\nusing this:\n  checked_nsc ?nsc {} (init_nsc ?nsc)\n\ngoal (1 subgoal):\n 1. checked_cs cs {} (map snd (to_ns cs), init_nsc (to_ns cs))", "by auto"], ["proof (state)\nthis:\n  checked_cs cs {} (init_cs init_nsc to_ns cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (6 cs J S v)"], ["proof (state)\nthis:\n  checked_cs cs J S\n  solution_cs solution_nsc from_ns S = v\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* solution *)"], ["proof (state)\nthis:\n  checked_cs cs J S\n  solution_cs solution_nsc from_ns S = v\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  checked_cs cs J S\n  solution_cs solution_nsc from_ns S = v", "obtain s where S: \"S = (map snd (to_ns cs),s)\""], ["proof (prove)\nusing this:\n  checked_cs cs J S\n  solution_cs solution_nsc from_ns S = v\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        S = (map snd (to_ns cs), s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S, auto)"], ["proof (state)\nthis:\n  S = (map snd (to_ns cs), s)\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "obtain w where w: \"solution_nsc s = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. solution_nsc s = w \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  solution_nsc s = w\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "note pre = 6[unfolded S solution_cs.simps w Let_def]"], ["proof (state)\nthis:\n  checked_cs cs J (map snd (to_ns cs), s)\n  \\<langle>from_ns w (map snd (to_ns cs))\\<rangle> = v\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from pre"], ["proof (chain)\npicking this:\n  checked_cs cs J (map snd (to_ns cs), s)\n  \\<langle>from_ns w (map snd (to_ns cs))\\<rangle> = v", "have\n    inv: \"checked_nsc (to_ns cs) J s\" and\n    v: \"v = \\<langle>from_ns w (map snd (to_ns cs))\\<rangle>\""], ["proof (prove)\nusing this:\n  checked_cs cs J (map snd (to_ns cs), s)\n  \\<langle>from_ns w (map snd (to_ns cs))\\<rangle> = v\n\ngoal (1 subgoal):\n 1. checked_nsc (to_ns cs) J s &&&\n    v = \\<langle>from_ns w (map snd (to_ns cs))\\<rangle>", "by auto"], ["proof (state)\nthis:\n  checked_nsc (to_ns cs) J s\n  v = \\<langle>from_ns w (map snd (to_ns cs))\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from solution_nsc[OF inv w]"], ["proof (chain)\npicking this:\n  (J, \\<langle>w\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set (to_ns cs)", "have w: \"(J, \\<langle>w\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s  set (to_ns cs)\""], ["proof (prove)\nusing this:\n  (J, \\<langle>w\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set (to_ns cs)\n\ngoal (1 subgoal):\n 1. (J, \\<langle>w\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n    set (to_ns cs)", "."], ["proof (state)\nthis:\n  (J, \\<langle>w\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>n\\<^sub>s\\<^sub>s \n  set (to_ns cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs J s v.\n       \\<lbrakk>checked_cs cs J s;\n        solution_cs solution_nsc from_ns s = v\\<rbrakk>\n       \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n 2. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 3. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "from i_to_ns_sat[OF w]"], ["proof (chain)\npicking this:\n  (J, \\<langle>from_ns w\n                (map snd\n                  (to_ns cs))\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s\n  set cs", "show ?case"], ["proof (prove)\nusing this:\n  (J, \\<langle>from_ns w\n                (map snd\n                  (to_ns cs))\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s\n  set cs\n\ngoal (1 subgoal):\n 1. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs", "unfolding v"], ["proof (prove)\nusing this:\n  (J, \\<langle>from_ns w\n                (map snd\n                  (to_ns cs))\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s\n  set cs\n\ngoal (1 subgoal):\n 1. (J, \\<langle>from_ns w\n                  (map snd\n                    (to_ns\n                      cs))\\<rangle>) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s\n    set cs", "."], ["proof (state)\nthis:\n  (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n\ngoal (2 subgoals):\n 1. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 2. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 2. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (7 cs J S c K S' S'')"], ["proof (state)\nthis:\n  checked_cs cs J S\n  checkpoint_cs checkpoint_nsc S = c\n  invariant_cs cs K S'\n  backtrack_cs backtrack_nsc c S' = S''\n  J \\<subseteq> K\n\ngoal (2 subgoals):\n 1. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 2. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "(* backtrack *)"], ["proof (state)\nthis:\n  checked_cs cs J S\n  checkpoint_cs checkpoint_nsc S = c\n  invariant_cs cs K S'\n  backtrack_cs backtrack_nsc c S' = S''\n  J \\<subseteq> K\n\ngoal (2 subgoals):\n 1. \\<And>cs J s c K s' s''.\n       \\<lbrakk>checked_cs cs J s; checkpoint_cs checkpoint_nsc s = c;\n        invariant_cs cs K s'; backtrack_cs backtrack_nsc c s' = s'';\n        J \\<subseteq> K\\<rbrakk>\n       \\<Longrightarrow> invariant_cs cs J s''\n 2. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  checked_cs cs J S\n  checkpoint_cs checkpoint_nsc S = c\n  invariant_cs cs K S'\n  backtrack_cs backtrack_nsc c S' = S''\n  J \\<subseteq> K", "show ?case"], ["proof (prove)\nusing this:\n  checked_cs cs J S\n  checkpoint_cs checkpoint_nsc S = c\n  invariant_cs cs K S'\n  backtrack_cs backtrack_nsc c S' = S''\n  J \\<subseteq> K\n\ngoal (1 subgoal):\n 1. invariant_cs cs J S''", "using backtrack_nsc[of \"to_ns cs\" J]"], ["proof (prove)\nusing this:\n  checked_cs cs J S\n  checkpoint_cs checkpoint_nsc S = c\n  invariant_cs cs K S'\n  backtrack_cs backtrack_nsc c S' = S''\n  J \\<subseteq> K\n  \\<lbrakk>checked_nsc (to_ns cs) J ?s; checkpoint_nsc ?s = ?c;\n   invariant_nsc (to_ns cs) ?K ?s'; backtrack_nsc ?c ?s' = ?s'';\n   J \\<subseteq> ?K\\<rbrakk>\n  \\<Longrightarrow> invariant_nsc (to_ns cs) J ?s''\n\ngoal (1 subgoal):\n 1. invariant_cs cs J S''", "by (cases S, cases S', cases S'', auto)"], ["proof (state)\nthis:\n  invariant_cs cs J S''\n\ngoal (1 subgoal):\n 1. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "case (8 cs J S)"], ["proof (state)\nthis:\n  checked_cs cs J S\n\ngoal (1 subgoal):\n 1. \\<And>cs J s. checked_cs cs J s \\<Longrightarrow> invariant_cs cs J s", "then"], ["proof (chain)\npicking this:\n  checked_cs cs J S", "show ?case"], ["proof (prove)\nusing this:\n  checked_cs cs J S\n\ngoal (1 subgoal):\n 1. invariant_cs cs J S", "using checked_invariant_nsc"], ["proof (prove)\nusing this:\n  checked_cs cs J S\n  checked_nsc ?nsc ?J ?s \\<Longrightarrow> invariant_nsc ?nsc ?J ?s\n\ngoal (1 subgoal):\n 1. invariant_cs cs J S", "by (cases S, auto)"], ["proof (state)\nthis:\n  invariant_cs cs J S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Concrete Implementation\\<close>"], ["", "subsubsection \\<open>Connecting all the locales\\<close>"], ["", "definition \"assert_s = Incremental_State_Ops_Simplex.assert_s assert_bound_code\""], ["", "definition \"check_s = Incremental_State_Ops_Simplex.check_s check_code\""], ["", "definition \"checkpoint_s = Incremental_State_Ops_Simplex.checkpoint_s\""], ["", "definition \"backtrack_s = Incremental_State_Ops_Simplex.backtrack_s\""], ["", "definition \"invariant_s = Incremental_State_Ops_Simplex.invariant_s\""], ["", "definition \"checked_s = Incremental_State_Ops_Simplex.checked_s\""], ["", "global_interpretation Incremental_State_Ops_Simplex_Default:\n  Incremental_State_Ops_Simplex assert_bound_code init_state check_code \n  rewrites\n    \"Incremental_State_Ops_Simplex.assert_s assert_bound_code = assert_s\" and\n    \"Incremental_State_Ops_Simplex.check_s check_code = check_s\" and\n    \"Incremental_State_Ops_Simplex.backtrack_s = backtrack_s\" and\n    \"Incremental_State_Ops_Simplex.checkpoint_s = checkpoint_s\" and \n    \"Incremental_State_Ops_Simplex.invariant_s = invariant_s\" and\n    \"Incremental_State_Ops_Simplex.checked_s = checked_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Incremental_State_Ops_Simplex assert_bound_code init_state\n      check_code &&&\n     Incremental_State_Ops_Simplex.assert_s assert_bound_code = assert_s &&&\n     Incremental_State_Ops_Simplex.check_s check_code = check_s) &&&\n    (Incremental_State_Ops_Simplex.backtrack_s = backtrack_s &&&\n     Incremental_State_Ops_Simplex.checkpoint_s = checkpoint_s) &&&\n    Incremental_State_Ops_Simplex.invariant_s = invariant_s &&&\n    Incremental_State_Ops_Simplex.checked_s = checked_s", "by (unfold_locales, auto simp: \n      assert_s_def \n      check_s_def \n      checkpoint_s_def\n      backtrack_s_def\n      checked_s_def\n      invariant_s_def)"], ["", "definition \"assert_all_s = Incremental_Atom_Ops.assert_all_s assert_s\""], ["", "global_interpretation Incremental_Atom_Ops_Default:  \n  Incremental_Atom_Ops init_state assert_s check_s \\<V> checkpoint_s backtrack_s \\<triangle> invariant_s checked_s\n  rewrites \"Incremental_Atom_Ops.assert_all_s assert_s = assert_all_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Incremental_Atom_Ops init_state assert_s check_s \\<V> checkpoint_s\n     backtrack_s \\<triangle> invariant_s checked_s &&&\n    Incremental_Atom_Ops.assert_all_s assert_s = assert_all_s", "using Incremental_State_Ops_Simplex_Default.incremental_atom_ops"], ["proof (prove)\nusing this:\n  Incremental_Atom_Ops init_state assert_s check_s \\<V> checkpoint_s\n   backtrack_s \\<triangle> invariant_s checked_s\n\ngoal (1 subgoal):\n 1. Incremental_Atom_Ops init_state assert_s check_s \\<V> checkpoint_s\n     backtrack_s \\<triangle> invariant_s checked_s &&&\n    Incremental_Atom_Ops.assert_all_s assert_s = assert_all_s", "by (auto simp: assert_all_s_def)"], ["", "definition \"init_nsc_code = (Incremental_Atom_Ops_For_NS_Constraint_Ops.init_nsc init_state preprocess :: _ \\<Rightarrow> (('a :: linorder, ('a \\<times> QDelta atom) list) mapping \\<times> _) \\<times> ('a, QDelta) state)\""], ["", "definition \"assert_nsc_code = assert_nsc assert_all_s\""], ["", "definition \"check_nsc_code = check_nsc check_s\""], ["", "definition \"checkpoint_nsc_code = checkpoint_nsc checkpoint_s\""], ["", "definition \"solution_nsc_code = solution_nsc \\<V>\""], ["", "definition \"backtrack_nsc_code = backtrack_nsc backtrack_s\""], ["", "definition \"invariant_nsc = Incremental_Atom_Ops_For_NS_Constraint_Ops.invariant_nsc invariant_s preprocess\""], ["", "definition \"checked_nsc = Incremental_Atom_Ops_For_NS_Constraint_Ops.checked_nsc checked_s preprocess\""], ["", "global_interpretation Incremental_Atom_Ops_For_NS_Constraint_Ops_Default: \n  Incremental_Atom_Ops_For_NS_Constraint_Ops init_state assert_s check_s \\<V> \n  checkpoint_s backtrack_s invariant_s checked_s preprocess\n  rewrites \n    \"Incremental_Atom_Ops_For_NS_Constraint_Ops.init_nsc init_state preprocess = init_nsc_code\" and\n    \"check_nsc check_s = check_nsc_code\" and\n    \"checkpoint_nsc checkpoint_s = checkpoint_nsc_code\" and\n    \"solution_nsc \\<V> = solution_nsc_code\" and\n    \"backtrack_nsc backtrack_s = backtrack_nsc_code\" and \n    \"assert_nsc assert_all_s = assert_nsc_code\" and \n    \"Incremental_Atom_Ops_For_NS_Constraint_Ops.invariant_nsc invariant_s preprocess = invariant_nsc\" and\n    \"Incremental_Atom_Ops_For_NS_Constraint_Ops.checked_nsc checked_s preprocess = checked_nsc\" and\n    \"Incremental_Atom_Ops.assert_all_s assert_s = assert_all_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Incremental_Atom_Ops_For_NS_Constraint_Ops init_state assert_s check_s\n       \\<V> checkpoint_s backtrack_s invariant_s checked_s preprocess &&&\n      Incremental_Atom_Ops_For_NS_Constraint_Ops.init_nsc init_state\n       preprocess =\n      init_nsc_code) &&&\n     check_nsc check_s = check_nsc_code &&&\n     checkpoint_nsc checkpoint_s = checkpoint_nsc_code &&&\n     solution_nsc \\<V> = solution_nsc_code) &&&\n    (backtrack_nsc backtrack_s = backtrack_nsc_code &&&\n     assert_nsc assert_all_s = assert_nsc_code) &&&\n    Incremental_Atom_Ops_For_NS_Constraint_Ops.invariant_nsc invariant_s\n     preprocess =\n    invariant_nsc &&&\n    Incremental_Atom_Ops_For_NS_Constraint_Ops.checked_nsc checked_s\n     preprocess =\n    checked_nsc &&&\n    Incremental_Atom_Ops.assert_all_s assert_s = assert_all_s", "by (unfold_locales, auto simp: \n      init_nsc_code_def\n      assert_nsc_code_def\n      check_nsc_code_def\n      checkpoint_nsc_code_def\n      solution_nsc_code_def\n      backtrack_nsc_code_def\n      invariant_nsc_def\n      checked_nsc_def\n      assert_all_s_def\n      )"], ["", "type_synonym 'i simplex_state' = \"QDelta ns_constraint list \n  \\<times> (('i, ('i \\<times> QDelta atom) list) mapping \\<times> ((var,QDelta)mapping \\<Rightarrow> (var,QDelta)mapping) \\<times> 'i list) \n  \\<times> ('i, QDelta) state\""], ["", "definition \"init_simplex' = (init_cs init_nsc_code to_ns :: 'i :: linorder i_constraint list \\<Rightarrow> 'i simplex_state')\""], ["", "definition \"assert_simplex' = (assert_cs assert_nsc_code :: 'i \\<Rightarrow> 'i simplex_state' \\<Rightarrow> 'i list + 'i simplex_state')\""], ["", "definition \"check_simplex' = (check_cs check_nsc_code :: 'i simplex_state' \\<Rightarrow> 'i list + 'i simplex_state')\""], ["", "definition \"solution_simplex' = (solution_cs solution_nsc_code from_ns :: 'i simplex_state' \\<Rightarrow> _)\""], ["", "definition \"backtrack_simplex' = (backtrack_cs backtrack_nsc_code :: _ \\<Rightarrow> 'i simplex_state' \\<Rightarrow> _)\""], ["", "definition \"checkpoint_simplex' = (checkpoint_cs checkpoint_nsc_code :: 'i simplex_state' \\<Rightarrow> _)\""], ["", "definition \"invariant_simplex' = Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.invariant_cs invariant_nsc to_ns\""], ["", "definition \"checked_simplex' = Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.checked_cs checked_nsc to_ns\""], ["", "lemma case_sum_case_sum: \"(case (case x of Inl y \\<Rightarrow> Inl (f1 y) | Inr z \\<Rightarrow> Inr (f2 z)) \n  of Inl y \\<Rightarrow> Inl (g1 y) | Inr z \\<Rightarrow> Inr (g2 z)) = (case x of Inl y \\<Rightarrow> Inl (g1 (f1 y)) | Inr z \\<Rightarrow> Inr (g2 (f2 z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case x of Inl y \\<Rightarrow> Inl (f1 y)\n          | Inr z \\<Rightarrow> Inr (f2 z) of\n     Inl y \\<Rightarrow> Inl (g1 y) | Inr z \\<Rightarrow> Inr (g2 z)) =\n    (case x of Inl y \\<Rightarrow> Inl (g1 (f1 y))\n     | Inr z \\<Rightarrow> Inr (g2 (f2 z)))", "by (cases x, auto)"], ["", "text \\<open>The following code-lemmas unfold some layers in the code of the simplex-operations, \n  so that the implementation immediately points to\n  the operations working on simplex type @{typ \"('i,QDelta) state\"}.\\<close>"], ["", "lemmas code_lemmas =\n  fun_cong[OF init_simplex'_def, of cs for cs, unfolded init_cs_def \n    Incremental_Atom_Ops_For_NS_Constraint_Ops_Default.init_nsc_def]\n  fun_cong[OF fun_cong[OF assert_simplex'_def], of i \"(cs,((asi,tv,ui),s))\" for i cs asi tv ui s, \n    unfolded assert_cs.simps assert_nsc_code_def assert_nsc_def case_sum_case_sum split]\n  fun_cong[OF check_simplex'_def, of \"(cs,(asi_tv,s))\" for cs asi_tv s, \n    unfolded check_cs_def check_nsc_code_def check_nsc_def sum_wrap.simps case_sum_case_sum] \n  fun_cong[OF solution_simplex'_def, of \"(cs,((asi,tv),s))\" for cs asi tv s, \n    unfolded solution_cs.simps solution_nsc_code_def solution_nsc.simps]\n  fun_cong[OF checkpoint_simplex'_def, of \"(cs,(asi_tv,s))\" for cs asi_tv s,\n    unfolded checkpoint_nsc_code_def checkpoint_cs.simps checkpoint_nsc.simps]\n  fun_cong[OF fun_cong[OF backtrack_simplex'_def], of c \"(cs,(asi_tv,s))\" for c cs asi_tv s,\n    unfolded backtrack_nsc_code_def backtrack_nsc.simps backtrack_cs.simps]"], ["", "declare code_lemmas[code]"], ["", "global_interpretation Incremental_Simplex:\n  Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex \n  init_nsc_code assert_nsc_code check_nsc_code solution_nsc_code checkpoint_nsc_code backtrack_nsc_code \n  invariant_nsc checked_nsc to_ns from_ns\n  rewrites \n    \"init_cs init_nsc_code to_ns = init_simplex'\" and\n    \"backtrack_cs backtrack_nsc_code = backtrack_simplex'\" and\n    \"checkpoint_cs checkpoint_nsc_code = checkpoint_simplex'\" and\n    \"check_cs check_nsc_code = check_simplex'\" and\n    \"assert_cs assert_nsc_code = assert_simplex'\" and\n    \"solution_cs solution_nsc_code from_ns = solution_simplex'\" and\n    \"Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.invariant_cs invariant_nsc to_ns = invariant_simplex'\" and\n    \"Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.checked_cs checked_nsc to_ns = checked_simplex'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex\n       init_nsc_code assert_nsc_code check_nsc_code solution_nsc_code\n       checkpoint_nsc_code backtrack_nsc_code invariant_nsc checked_nsc\n       to_ns from_ns &&&\n      init_cs init_nsc_code to_ns = init_simplex') &&&\n     backtrack_cs backtrack_nsc_code = backtrack_simplex' &&&\n     checkpoint_cs checkpoint_nsc_code = checkpoint_simplex') &&&\n    (check_cs check_nsc_code = check_simplex' &&&\n     assert_cs assert_nsc_code = assert_simplex') &&&\n    solution_cs solution_nsc_code from_ns = solution_simplex' &&&\n    Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.invariant_cs\n     invariant_nsc to_ns =\n    invariant_simplex' &&&\n    Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.checked_cs\n     checked_nsc to_ns =\n    checked_simplex'", "proof -"], ["proof (state)\ngoal (9 subgoals):\n 1. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex\n     init_nsc_code assert_nsc_code check_nsc_code solution_nsc_code\n     checkpoint_nsc_code backtrack_nsc_code invariant_nsc checked_nsc to_ns\n     from_ns\n 2. init_cs init_nsc_code to_ns = init_simplex'\n 3. backtrack_cs backtrack_nsc_code = backtrack_simplex'\n 4. checkpoint_cs checkpoint_nsc_code = checkpoint_simplex'\n 5. check_cs check_nsc_code = check_simplex'\n 6. assert_cs assert_nsc_code = assert_simplex'\n 7. solution_cs solution_nsc_code from_ns = solution_simplex'\n 8. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.invariant_cs\n     invariant_nsc to_ns =\n    invariant_simplex'\n 9. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.checked_cs\n     checked_nsc to_ns =\n    checked_simplex'", "interpret Incremental_NS_Constraint_Ops init_nsc_code assert_nsc_code check_nsc_code solution_nsc_code checkpoint_nsc_code\n    backtrack_nsc_code invariant_nsc checked_nsc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Incremental_NS_Constraint_Ops init_nsc_code assert_nsc_code\n     check_nsc_code solution_nsc_code checkpoint_nsc_code backtrack_nsc_code\n     invariant_nsc checked_nsc", "using Incremental_Atom_Ops_For_NS_Constraint_Ops_Default.ns_constraints_ops"], ["proof (prove)\nusing this:\n  Incremental_NS_Constraint_Ops init_nsc_code assert_nsc_code check_nsc_code\n   solution_nsc_code checkpoint_nsc_code backtrack_nsc_code invariant_nsc\n   checked_nsc\n\ngoal (1 subgoal):\n 1. Incremental_NS_Constraint_Ops init_nsc_code assert_nsc_code\n     check_nsc_code solution_nsc_code checkpoint_nsc_code backtrack_nsc_code\n     invariant_nsc checked_nsc", "."], ["proof (state)\ngoal (9 subgoals):\n 1. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex\n     init_nsc_code assert_nsc_code check_nsc_code solution_nsc_code\n     checkpoint_nsc_code backtrack_nsc_code invariant_nsc checked_nsc to_ns\n     from_ns\n 2. init_cs init_nsc_code to_ns = init_simplex'\n 3. backtrack_cs backtrack_nsc_code = backtrack_simplex'\n 4. checkpoint_cs checkpoint_nsc_code = checkpoint_simplex'\n 5. check_cs check_nsc_code = check_simplex'\n 6. assert_cs assert_nsc_code = assert_simplex'\n 7. solution_cs solution_nsc_code from_ns = solution_simplex'\n 8. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.invariant_cs\n     invariant_nsc to_ns =\n    invariant_simplex'\n 9. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.checked_cs\n     checked_nsc to_ns =\n    checked_simplex'", "show \"Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex init_nsc_code assert_nsc_code check_nsc_code\n     solution_nsc_code checkpoint_nsc_code backtrack_nsc_code invariant_nsc checked_nsc to_ns from_ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex\n     init_nsc_code assert_nsc_code check_nsc_code solution_nsc_code\n     checkpoint_nsc_code backtrack_nsc_code invariant_nsc checked_nsc to_ns\n     from_ns", ".."], ["proof (state)\nthis:\n  Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex init_nsc_code\n   assert_nsc_code check_nsc_code solution_nsc_code checkpoint_nsc_code\n   backtrack_nsc_code invariant_nsc checked_nsc to_ns from_ns\n\ngoal (8 subgoals):\n 1. init_cs init_nsc_code to_ns = init_simplex'\n 2. backtrack_cs backtrack_nsc_code = backtrack_simplex'\n 3. checkpoint_cs checkpoint_nsc_code = checkpoint_simplex'\n 4. check_cs check_nsc_code = check_simplex'\n 5. assert_cs assert_nsc_code = assert_simplex'\n 6. solution_cs solution_nsc_code from_ns = solution_simplex'\n 7. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.invariant_cs\n     invariant_nsc to_ns =\n    invariant_simplex'\n 8. Incremental_NS_Constraint_Ops_To_Ns_For_Incremental_Simplex.checked_cs\n     checked_nsc to_ns =\n    checked_simplex'", "qed (auto simp: \n    init_simplex'_def\n    check_simplex'_def\n    solution_simplex'_def\n    backtrack_simplex'_def\n    checkpoint_simplex'_def\n    assert_simplex'_def\n    invariant_simplex'_def\n    checked_simplex'_def\n    )"], ["", "subsubsection \\<open>An implementation which encapsulates the state\\<close>"], ["", "text \\<open>In principle, we now already have a complete implementation of the incremental simplex algorithm with\n  @{const init_simplex'}, @{const assert_simplex'}, etc. However, this implementation results in code where\n  the interal type @{typ \"'i simplex_state'\"} becomes visible. Therefore, we now define all operations\n  on a new type which encapsulates the internal construction.\\<close>"], ["", "datatype 'i simplex_state = Simplex_State \"'i simplex_state'\""], ["", "datatype 'i simplex_checkpoint = Simplex_Checkpoint \"(nat, 'i \\<times> QDelta) mapping \\<times> (nat, 'i \\<times> QDelta) mapping\""], ["", "fun init_simplex where \"init_simplex cs =\n  (let tons_cs = to_ns cs\n   in Simplex_State (map snd tons_cs,\n       case preprocess tons_cs of (t, as, trans_v, ui) \\<Rightarrow> ((create_map as, trans_v, remdups ui), init_state t)))\""], ["", "fun assert_simplex where \"assert_simplex i (Simplex_State (cs, (asi, tv, ui), s)) =\n  (if i \\<in> set ui then Inl [i] else case assert_all_s (list_map_to_fun asi i) s of Inl y \\<Rightarrow> Inl y | Inr s' \\<Rightarrow> Inr (Simplex_State (cs, (asi, tv, ui), s')))\""], ["", "fun check_simplex where \n  \"check_simplex (Simplex_State (cs, asi_tv, s)) = (case check_s s of Inl y \\<Rightarrow> Inl y | Inr s' \\<Rightarrow> Inr (Simplex_State (cs, asi_tv, s')))\""], ["", "fun solution_simplex where\n  \"solution_simplex (Simplex_State (cs, (asi, tv, ui), s)) = \\<langle>from_ns (tv (\\<V> s)) cs\\<rangle>\""], ["", "fun checkpoint_simplex where \"checkpoint_simplex (Simplex_State (cs, asi_tv, s)) = Simplex_Checkpoint (checkpoint_s s)\""], ["", "fun backtrack_simplex where\n  \"backtrack_simplex (Simplex_Checkpoint c) (Simplex_State (cs, asi_tv, s)) = Simplex_State (cs, asi_tv, backtrack_s c s)\""], ["", "subsubsection \\<open>Soundness of the incremental simplex implementation\\<close>"], ["", "text \\<open>First link the unprimed constants against their primed counterparts.\\<close>"], ["", "lemma init_simplex': \"init_simplex cs = Simplex_State (init_simplex' cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_simplex cs = Simplex_State (init_simplex' cs)", "by (simp add: code_lemmas Let_def)"], ["", "lemma assert_simplex': \"assert_simplex i (Simplex_State s) = map_sum id Simplex_State (assert_simplex' i s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert_simplex i (Simplex_State s) =\n    map_sum id Simplex_State (assert_simplex' i s)", "by (cases s, auto simp: code_lemmas split: sum.splits)"], ["", "lemma check_simplex': \"check_simplex (Simplex_State s) = map_sum id Simplex_State (check_simplex' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_simplex (Simplex_State s) =\n    map_sum id Simplex_State (check_simplex' s)", "by (cases s, auto simp: code_lemmas split: sum.splits)"], ["", "lemma solution_simplex': \"solution_simplex (Simplex_State s) = solution_simplex' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution_simplex (Simplex_State s) = solution_simplex' s", "by (cases s, auto simp: code_lemmas)"], ["", "lemma checkpoint_simplex': \"checkpoint_simplex (Simplex_State s) = Simplex_Checkpoint (checkpoint_simplex' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checkpoint_simplex (Simplex_State s) =\n    Simplex_Checkpoint (checkpoint_simplex' s)", "by (cases s, auto simp: code_lemmas split: sum.splits)"], ["", "lemma backtrack_simplex': \"backtrack_simplex (Simplex_Checkpoint c) (Simplex_State s) = Simplex_State (backtrack_simplex' c s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backtrack_simplex (Simplex_Checkpoint c) (Simplex_State s) =\n    Simplex_State (backtrack_simplex' c s)", "by (cases s, auto simp: code_lemmas split: sum.splits)"], ["", "fun invariant_simplex where\n  \"invariant_simplex cs J (Simplex_State s) = invariant_simplex' cs J s\""], ["", "fun checked_simplex where\n  \"checked_simplex cs J (Simplex_State s) = checked_simplex' cs J s\""], ["", "text \\<open>Hide implementation\\<close>"], ["", "declare init_simplex.simps[simp del]"], ["", "declare assert_simplex.simps[simp del]"], ["", "declare check_simplex.simps[simp del]"], ["", "declare solution_simplex.simps[simp del]"], ["", "declare checkpoint_simplex.simps[simp del]"], ["", "declare backtrack_simplex.simps[simp del]"], ["", "text \\<open>Soundness lemmas\\<close>"], ["", "lemma init_simplex: \"checked_simplex cs {} (init_simplex cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_simplex cs {} (init_simplex cs)", "using Incremental_Simplex.init_cs"], ["proof (prove)\nusing this:\n  checked_simplex' ?cs {} (init_simplex' ?cs)\n\ngoal (1 subgoal):\n 1. checked_simplex cs {} (init_simplex cs)", "by (simp add: init_simplex')"], ["", "lemma assert_simplex_ok:\n  \"invariant_simplex cs J s \\<Longrightarrow> assert_simplex j s = Inr s' \\<Longrightarrow> invariant_simplex cs (insert j J) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inr s'\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs (insert j J) s'", "proof (cases s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inr s';\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (insert j J) s'", "case s: (Simplex_State ss)"], ["proof (state)\nthis:\n  s = Simplex_State ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inr s';\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (insert j J) s'", "show \"invariant_simplex cs J s \\<Longrightarrow> assert_simplex j s = Inr s' \\<Longrightarrow> invariant_simplex cs (insert j J) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inr s'\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs (insert j J) s'", "unfolding s invariant_simplex.simps assert_simplex'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (assert_simplex' j ss) = Inr s'\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs (insert j J) s'", "using Incremental_Simplex.assert_cs_ok[of cs J ss j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_simplex' cs J ss;\n   assert_simplex' j ss = Inr ?s'\\<rbrakk>\n  \\<Longrightarrow> invariant_simplex' cs (insert j J) ?s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (assert_simplex' j ss) = Inr s'\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs (insert j J) s'", "by (cases \"assert_simplex' j ss\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inr s'\\<rbrakk>\n  \\<Longrightarrow> invariant_simplex cs (insert j J) s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assert_simplex_unsat:\n  \"invariant_simplex cs J s \\<Longrightarrow> assert_simplex j s = Inl I \\<Longrightarrow> \n     set I \\<subseteq> insert j J \\<and> minimal_unsat_core (set I) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                      minimal_unsat_core (set I) cs", "proof (cases s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inl I;\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs", "case s: (Simplex_State ss)"], ["proof (state)\nthis:\n  s = Simplex_State ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inl I;\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                         minimal_unsat_core (set I) cs", "show \"invariant_simplex cs J s \\<Longrightarrow> assert_simplex j s = Inl I \\<Longrightarrow> \n    set I \\<subseteq> insert j J \\<and> minimal_unsat_core (set I) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                      minimal_unsat_core (set I) cs", "unfolding s invariant_simplex.simps assert_simplex'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (assert_simplex' j ss) = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                      minimal_unsat_core (set I) cs", "using Incremental_Simplex.assert_cs_unsat[of cs J ss j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_simplex' cs J ss;\n   assert_simplex' j ss = Inl ?I\\<rbrakk>\n  \\<Longrightarrow> set ?I \\<subseteq> insert j J \\<and>\n                    minimal_unsat_core (set ?I) cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (assert_simplex' j ss) = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                      minimal_unsat_core (set I) cs", "by (cases \"assert_simplex' j ss\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_simplex cs J s; assert_simplex j s = Inl I\\<rbrakk>\n  \\<Longrightarrow> set I \\<subseteq> insert j J \\<and>\n                    minimal_unsat_core (set I) cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_simplex_ok:\n  \"invariant_simplex cs J s \\<Longrightarrow> check_simplex s = Inr s' \\<Longrightarrow> checked_simplex cs J s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inr s'\\<rbrakk>\n    \\<Longrightarrow> checked_simplex cs J s'", "proof (cases s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inr s';\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> checked_simplex cs J s'", "case s: (Simplex_State ss)"], ["proof (state)\nthis:\n  s = Simplex_State ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inr s';\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> checked_simplex cs J s'", "show \"invariant_simplex cs J s \\<Longrightarrow> check_simplex s = Inr s' \\<Longrightarrow> checked_simplex cs J s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inr s'\\<rbrakk>\n    \\<Longrightarrow> checked_simplex cs J s'", "unfolding s invariant_simplex.simps check_simplex.simps check_simplex'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (check_simplex' ss) = Inr s'\\<rbrakk>\n    \\<Longrightarrow> checked_simplex cs J s'", "using Incremental_Simplex.check_cs_ok[of cs J ss]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_simplex' cs J ss; check_simplex' ss = Inr ?s'\\<rbrakk>\n  \\<Longrightarrow> checked_simplex' cs J ?s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (check_simplex' ss) = Inr s'\\<rbrakk>\n    \\<Longrightarrow> checked_simplex cs J s'", "by (cases \"check_simplex' ss\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inr s'\\<rbrakk>\n  \\<Longrightarrow> checked_simplex cs J s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_simplex_unsat:\n  \"invariant_simplex cs J s \\<Longrightarrow> check_simplex s = Unsat I \\<Longrightarrow> \n     set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                      minimal_unsat_core (set I) cs", "proof (cases s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inl I;\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs", "case s: (Simplex_State ss)"], ["proof (state)\nthis:\n  s = Simplex_State ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inl I;\n        s = Simplex_State x\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                         minimal_unsat_core (set I) cs", "show \"invariant_simplex cs J s \\<Longrightarrow> check_simplex s = Unsat I \\<Longrightarrow> \n    set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                      minimal_unsat_core (set I) cs", "unfolding s invariant_simplex.simps check_simplex.simps check_simplex'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (check_simplex' ss) = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                      minimal_unsat_core (set I) cs", "using Incremental_Simplex.check_cs_unsat[of cs J ss I]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_simplex' cs J ss; check_simplex' ss = Inl I\\<rbrakk>\n  \\<Longrightarrow> set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex' cs J ss;\n     map_sum id Simplex_State (check_simplex' ss) = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> J \\<and>\n                      minimal_unsat_core (set I) cs", "by (cases \"check_simplex' ss\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_simplex cs J s; check_simplex s = Inl I\\<rbrakk>\n  \\<Longrightarrow> set I \\<subseteq> J \\<and> minimal_unsat_core (set I) cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solution_simplex:\n  \"checked_simplex cs J s \\<Longrightarrow> solution_simplex s = v \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; solution_simplex s = v\\<rbrakk>\n    \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs", "using Incremental_Simplex.solution_cs[of cs J]"], ["proof (prove)\nusing this:\n  \\<lbrakk>checked_simplex' cs J ?s; solution_simplex' ?s = ?v\\<rbrakk>\n  \\<Longrightarrow> (J, ?v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; solution_simplex s = v\\<rbrakk>\n    \\<Longrightarrow> (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs", "by (cases s, auto simp: solution_simplex')"], ["", "lemma backtrack_simplex:\n  \"checked_simplex cs J s \\<Longrightarrow>\n   checkpoint_simplex s = c \\<Longrightarrow>\n   invariant_simplex cs K s' \\<Longrightarrow> \n   backtrack_simplex c s' = s'' \\<Longrightarrow> \n   J \\<subseteq> K \\<Longrightarrow> \n   invariant_simplex cs J s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "obtain ss where ss: \"s = Simplex_State ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        s = Simplex_State ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s, auto)"], ["proof (state)\nthis:\n  s = Simplex_State ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "obtain ss' where ss': \"s' = Simplex_State ss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss'.\n        s' = Simplex_State ss' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s', auto)"], ["proof (state)\nthis:\n  s' = Simplex_State ss'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "obtain ss'' where ss'': \"s'' = Simplex_State ss''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss''.\n        s'' = Simplex_State ss'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s'', auto)"], ["proof (state)\nthis:\n  s'' = Simplex_State ss''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "obtain cc where cc: \"c = Simplex_Checkpoint cc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cc.\n        c = Simplex_Checkpoint cc \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases c, auto)"], ["proof (state)\nthis:\n  c = Simplex_Checkpoint cc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "show \"checked_simplex cs J s \\<Longrightarrow>\n   checkpoint_simplex s = c \\<Longrightarrow>\n   invariant_simplex cs K s' \\<Longrightarrow> \n   backtrack_simplex c s' = s'' \\<Longrightarrow> \n   J \\<subseteq> K \\<Longrightarrow> \n   invariant_simplex cs J s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n     invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs J s''", "unfolding ss ss' ss'' cc checked_simplex.simps invariant_simplex.simps checkpoint_simplex' backtrack_simplex'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex' cs J ss;\n     Simplex_Checkpoint (checkpoint_simplex' ss) = Simplex_Checkpoint cc;\n     invariant_simplex' cs K ss';\n     Simplex_State (backtrack_simplex' cc ss') = Simplex_State ss'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex' cs J ss''", "using Incremental_Simplex.backtrack_cs[of cs J ss cc K ss' ss'']"], ["proof (prove)\nusing this:\n  \\<lbrakk>checked_simplex' cs J ss; checkpoint_simplex' ss = cc;\n   invariant_simplex' cs K ss'; backtrack_simplex' cc ss' = ss'';\n   J \\<subseteq> K\\<rbrakk>\n  \\<Longrightarrow> invariant_simplex' cs J ss''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>checked_simplex' cs J ss;\n     Simplex_Checkpoint (checkpoint_simplex' ss) = Simplex_Checkpoint cc;\n     invariant_simplex' cs K ss';\n     Simplex_State (backtrack_simplex' cc ss') = Simplex_State ss'';\n     J \\<subseteq> K\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex' cs J ss''", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>checked_simplex cs J s; checkpoint_simplex s = c;\n   invariant_simplex cs K s'; backtrack_simplex c s' = s'';\n   J \\<subseteq> K\\<rbrakk>\n  \\<Longrightarrow> invariant_simplex cs J s''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma checked_invariant_simplex:\n  \"checked_simplex cs J s \\<Longrightarrow> invariant_simplex cs J s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checked_simplex cs J s \\<Longrightarrow> invariant_simplex cs J s", "using Incremental_Simplex.checked_invariant_cs[of cs J]"], ["proof (prove)\nusing this:\n  checked_simplex' cs J ?s \\<Longrightarrow> invariant_simplex' cs J ?s\n\ngoal (1 subgoal):\n 1. checked_simplex cs J s \\<Longrightarrow> invariant_simplex cs J s", "by (cases s, auto)"], ["", "declare checked_simplex.simps[simp del]"], ["", "declare invariant_simplex.simps[simp del]"], ["", "text \\<open>From this point onwards, one should not look into the types @{typ \"'i simplex_state\"}\n  and @{typ \"'i simplex_checkpoint\"}.\\<close>"], ["", "text \\<open>For convenience: an assert-all function which takes multiple indices.\\<close>"], ["", "fun assert_all_simplex :: \"'i list \\<Rightarrow> 'i simplex_state \\<Rightarrow> 'i list + 'i simplex_state\" where\n  \"assert_all_simplex [] s = Inr s\" \n| \"assert_all_simplex (j # J) s = (case assert_simplex j s of Unsat I \\<Rightarrow> Unsat I \n     | Inr s' \\<Rightarrow> assert_all_simplex J s')\""], ["", "lemma assert_all_simplex_ok: \"invariant_simplex cs J s \\<Longrightarrow> assert_all_simplex K s = Inr s' \\<Longrightarrow> \n    invariant_simplex cs (J \\<union> set K) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s;\n     assert_all_simplex K s = Inr s'\\<rbrakk>\n    \\<Longrightarrow> invariant_simplex cs (J \\<union> set K) s'", "proof (induct K arbitrary: s J)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set []) s'\n 2. \\<And>a K s J.\n       \\<lbrakk>\\<And>s J.\n                   \\<lbrakk>invariant_simplex cs J s;\n                    assert_all_simplex K s = Inr s'\\<rbrakk>\n                   \\<Longrightarrow> invariant_simplex cs (J \\<union> set K)\ns';\n        invariant_simplex cs J s;\n        assert_all_simplex (a # K) s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set (a # K)) s'", "case (Cons k K s J)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_simplex cs ?J ?s;\n   assert_all_simplex K ?s = Inr s'\\<rbrakk>\n  \\<Longrightarrow> invariant_simplex cs (?J \\<union> set K) s'\n  invariant_simplex cs J s\n  assert_all_simplex (k # K) s = Inr s'\n\ngoal (2 subgoals):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set []) s'\n 2. \\<And>a K s J.\n       \\<lbrakk>\\<And>s J.\n                   \\<lbrakk>invariant_simplex cs J s;\n                    assert_all_simplex K s = Inr s'\\<rbrakk>\n                   \\<Longrightarrow> invariant_simplex cs (J \\<union> set K)\ns';\n        invariant_simplex cs J s;\n        assert_all_simplex (a # K) s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set (a # K)) s'", "from Cons(3)"], ["proof (chain)\npicking this:\n  assert_all_simplex (k # K) s = Inr s'", "obtain s'' where ass: \"assert_simplex k s = Inr s''\" and rec: \"assert_all_simplex K s'' = Inr s'\""], ["proof (prove)\nusing this:\n  assert_all_simplex (k # K) s = Inr s'\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>assert_simplex k s = Inr s'';\n         assert_all_simplex K s'' = Inr s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  assert_simplex k s = Inr s''\n  assert_all_simplex K s'' = Inr s'\n\ngoal (2 subgoals):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set []) s'\n 2. \\<And>a K s J.\n       \\<lbrakk>\\<And>s J.\n                   \\<lbrakk>invariant_simplex cs J s;\n                    assert_all_simplex K s = Inr s'\\<rbrakk>\n                   \\<Longrightarrow> invariant_simplex cs (J \\<union> set K)\ns';\n        invariant_simplex cs J s;\n        assert_all_simplex (a # K) s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set (a # K)) s'", "from Cons(1)[OF assert_simplex_ok[OF Cons(2) ass] rec]"], ["proof (chain)\npicking this:\n  invariant_simplex cs (insert k J \\<union> set K) s'", "show ?case"], ["proof (prove)\nusing this:\n  invariant_simplex cs (insert k J \\<union> set K) s'\n\ngoal (1 subgoal):\n 1. invariant_simplex cs (J \\<union> set (k # K)) s'", "by auto"], ["proof (state)\nthis:\n  invariant_simplex cs (J \\<union> set (k # K)) s'\n\ngoal (1 subgoal):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inr s'\\<rbrakk>\n       \\<Longrightarrow> invariant_simplex cs (J \\<union> set []) s'", "qed auto"], ["", "lemma assert_all_simplex_unsat: \"invariant_simplex cs J s \\<Longrightarrow> assert_all_simplex K s = Unsat I \\<Longrightarrow> \n    set I \\<subseteq> set K \\<union> J \\<and> minimal_unsat_core (set I) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_simplex cs J s;\n     assert_all_simplex K s = Inl I\\<rbrakk>\n    \\<Longrightarrow> set I \\<subseteq> set K \\<union> J \\<and>\n                      minimal_unsat_core (set I) cs", "proof (induct K arbitrary: s J)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> set [] \\<union> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>a K s J.\n       \\<lbrakk>\\<And>s J.\n                   \\<lbrakk>invariant_simplex cs J s;\n                    assert_all_simplex K s = Inl I\\<rbrakk>\n                   \\<Longrightarrow> set I\n                                     \\<subseteq> set K \\<union> J \\<and>\n                                     minimal_unsat_core (set I) cs;\n        invariant_simplex cs J s;\n        assert_all_simplex (a # K) s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> set (a # K) \\<union> J \\<and>\n                         minimal_unsat_core (set I) cs", "case (Cons k K s J)"], ["proof (state)\nthis:\n  \\<lbrakk>invariant_simplex cs ?J ?s;\n   assert_all_simplex K ?s = Inl I\\<rbrakk>\n  \\<Longrightarrow> set I \\<subseteq> set K \\<union> ?J \\<and>\n                    minimal_unsat_core (set I) cs\n  invariant_simplex cs J s\n  assert_all_simplex (k # K) s = Inl I\n\ngoal (2 subgoals):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> set [] \\<union> J \\<and>\n                         minimal_unsat_core (set I) cs\n 2. \\<And>a K s J.\n       \\<lbrakk>\\<And>s J.\n                   \\<lbrakk>invariant_simplex cs J s;\n                    assert_all_simplex K s = Inl I\\<rbrakk>\n                   \\<Longrightarrow> set I\n                                     \\<subseteq> set K \\<union> J \\<and>\n                                     minimal_unsat_core (set I) cs;\n        invariant_simplex cs J s;\n        assert_all_simplex (a # K) s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> set (a # K) \\<union> J \\<and>\n                         minimal_unsat_core (set I) cs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set I \\<subseteq> set (k # K) \\<union> J \\<and>\n    minimal_unsat_core (set I) cs", "proof (cases \"assert_simplex k s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_simplex k s = Inl a \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs\n 2. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "case unsat: (Inl J')"], ["proof (state)\nthis:\n  assert_simplex k s = Inl J'\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_simplex k s = Inl a \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs\n 2. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>invariant_simplex cs ?J ?s;\n   assert_all_simplex K ?s = Inl I\\<rbrakk>\n  \\<Longrightarrow> set I \\<subseteq> set K \\<union> ?J \\<and>\n                    minimal_unsat_core (set I) cs\n  invariant_simplex cs J s\n  assert_all_simplex (k # K) s = Inl I\n  assert_simplex k s = Inl J'", "have J': \"J' = I\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_simplex cs ?J ?s;\n   assert_all_simplex K ?s = Inl I\\<rbrakk>\n  \\<Longrightarrow> set I \\<subseteq> set K \\<union> ?J \\<and>\n                    minimal_unsat_core (set I) cs\n  invariant_simplex cs J s\n  assert_all_simplex (k # K) s = Inl I\n  assert_simplex k s = Inl J'\n\ngoal (1 subgoal):\n 1. J' = I", "by auto"], ["proof (state)\nthis:\n  J' = I\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_simplex k s = Inl a \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs\n 2. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "from assert_simplex_unsat[OF Cons(2) unsat]"], ["proof (chain)\npicking this:\n  set J' \\<subseteq> insert k J \\<and> minimal_unsat_core (set J') cs", "have \"set J' \\<subseteq> insert k J\" \"minimal_unsat_core (set J') cs\""], ["proof (prove)\nusing this:\n  set J' \\<subseteq> insert k J \\<and> minimal_unsat_core (set J') cs\n\ngoal (1 subgoal):\n 1. set J' \\<subseteq> insert k J &&& minimal_unsat_core (set J') cs", "by auto"], ["proof (state)\nthis:\n  set J' \\<subseteq> insert k J\n  minimal_unsat_core (set J') cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       assert_simplex k s = Inl a \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs\n 2. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "then"], ["proof (chain)\npicking this:\n  set J' \\<subseteq> insert k J\n  minimal_unsat_core (set J') cs", "show ?thesis"], ["proof (prove)\nusing this:\n  set J' \\<subseteq> insert k J\n  minimal_unsat_core (set J') cs\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> set (k # K) \\<union> J \\<and>\n    minimal_unsat_core (set I) cs", "unfolding J' i_satisfies_cs.simps"], ["proof (prove)\nusing this:\n  set I \\<subseteq> insert k J\n  minimal_unsat_core (set I) cs\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> set (k # K) \\<union> J \\<and>\n    minimal_unsat_core (set I) cs", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> set (k # K) \\<union> J \\<and>\n  minimal_unsat_core (set I) cs\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "case (Inr s')"], ["proof (state)\nthis:\n  assert_simplex k s = Inr s'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       assert_simplex k s = Inr b \\<Longrightarrow>\n       set I \\<subseteq> set (k # K) \\<union> J \\<and>\n       minimal_unsat_core (set I) cs", "from Cons(1)[OF assert_simplex_ok[OF Cons(2) Inr]] Cons(3) Inr"], ["proof (chain)\npicking this:\n  assert_all_simplex K s' = Inl I \\<Longrightarrow>\n  set I \\<subseteq> set K \\<union> insert k J \\<and>\n  minimal_unsat_core (set I) cs\n  assert_all_simplex (k # K) s = Inl I\n  assert_simplex k s = Inr s'", "show ?thesis"], ["proof (prove)\nusing this:\n  assert_all_simplex K s' = Inl I \\<Longrightarrow>\n  set I \\<subseteq> set K \\<union> insert k J \\<and>\n  minimal_unsat_core (set I) cs\n  assert_all_simplex (k # K) s = Inl I\n  assert_simplex k s = Inr s'\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> set (k # K) \\<union> J \\<and>\n    minimal_unsat_core (set I) cs", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> set (k # K) \\<union> J \\<and>\n  minimal_unsat_core (set I) cs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set I \\<subseteq> set (k # K) \\<union> J \\<and>\n  minimal_unsat_core (set I) cs\n\ngoal (1 subgoal):\n 1. \\<And>s J.\n       \\<lbrakk>invariant_simplex cs J s;\n        assert_all_simplex [] s = Inl I\\<rbrakk>\n       \\<Longrightarrow> set I \\<subseteq> set [] \\<union> J \\<and>\n                         minimal_unsat_core (set I) cs", "qed simp"], ["", "text \\<open>The collection of soundness lemmas for the incremental simplex algorithm.\\<close>"], ["", "lemmas incremental_simplex = \n  init_simplex\n  assert_simplex_ok\n  assert_simplex_unsat\n  assert_all_simplex_ok\n  assert_all_simplex_unsat\n  check_simplex_ok\n  check_simplex_unsat\n  solution_simplex\n  backtrack_simplex\n  checked_invariant_simplex"], ["", "subsection \\<open>Test Executability and Example for Incremental Interface\\<close>"], ["", "value (code) \"let cs = [\n    (1 :: int, LT (lp_monom 1 1) 4), \\<comment> \\<open>$x_1 < 4$\\<close>\n    (2, GTPP (lp_monom 2 1) (lp_monom 1 2)), \\<comment> \\<open>$2x_1 > x_2$\\<close>\n    (3, EQPP (lp_monom 1 1) (lp_monom 2 2)), \\<comment> \\<open>$x_1 = 2x_2$\\<close>\n    (4, GT (lp_monom 2 2) 5), \\<comment> \\<open>$2x_2 > 5$\\<close>\n    (5, GT (lp_monom 3 0) 7), \\<comment> \\<open>$3x_0 > 7$\\<close>\n    (6, GT (lp_monom 3 3 + lp_monom (1/3) 2) 2)]; \\<comment> \\<open>$3x_3 + 1/3x_2 > 2$\\<close>\n    s1 = init_simplex cs; \\<comment> \\<open>initialize\\<close>\n    s2 = (case assert_all_simplex [1,2,3] s1 of Inr s \\<Rightarrow> s | Unsat _ \\<Rightarrow> undefined); \\<comment> \\<open>assert 1,2,3\\<close>\n    s3 = (case check_simplex s2 of Inr s \\<Rightarrow> s | Unsat _ \\<Rightarrow> undefined); \\<comment> \\<open>check that 1,2,3 are sat.\\<close>\n    c123 = checkpoint_simplex s3; \\<comment> \\<open>after check, store checkpoint for backtracking\\<close>\n    s4 = (case assert_simplex 4 s2 of Inr s \\<Rightarrow> s | Unsat _ \\<Rightarrow> undefined); \\<comment> \\<open>assert 4\\<close>\n    I = (case check_simplex s4 of Unsat I \\<Rightarrow> I | Inr _ \\<Rightarrow> undefined); \\<comment> \\<open>checking detects unsat-core 1,3,4\\<close>\n    s5 = backtrack_simplex c123 s4; \\<comment> \\<open>backtrack to constraints 1,2,3\\<close>\n    s6 = (case assert_all_simplex [5,6] s5 of Inr s \\<Rightarrow> s | Unsat _ \\<Rightarrow> undefined); \\<comment> \\<open>assert 5,6\\<close>\n    s7 = (case check_simplex s6 of Inr s \\<Rightarrow> s | Unsat _ \\<Rightarrow> undefined); \\<comment> \\<open>check that 1,2,3,5,6 are sat.\\<close>\n    sol = solution_simplex s7 \\<comment> \\<open>solution for 1,2,3,5,6\\<close>\n  in (I, map (\\<lambda> x. (''x_'', x, ''='', sol x)) [0,1,2,3]) \\<comment> \\<open>output unsat core and solution\\<close>\""], ["", "end"]]}