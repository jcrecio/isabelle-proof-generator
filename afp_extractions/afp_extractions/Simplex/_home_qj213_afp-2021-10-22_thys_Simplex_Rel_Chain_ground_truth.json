{"file_name": "/home/qj213/afp-2021-10-22/thys/Simplex/Rel_Chain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simplex", "problem_names": ["lemma \n  rel_chain_Nil: \"rel_chain [] r\" and\n  rel_chain_Cons: \"rel_chain (x # xs) r = (if xs = [] then True else ((x, hd xs) \\<in> r) \\<and> rel_chain xs r)\"", "lemma rel_chain_drop:\n  \"rel_chain l R ==> rel_chain (drop n l) R\"", "lemma rel_chain_take:\n  \"rel_chain l R ==> rel_chain (take n l) R\"", "lemma rel_chain_butlast:\n  \"rel_chain l R ==> rel_chain (butlast l) R\"", "lemma rel_chain_tl:\n  \"rel_chain l R ==> rel_chain (tl l) R\"", "lemma rel_chain_append:\n  assumes \"rel_chain l R\" \"rel_chain l' R\" \"(last l, hd l') \\<in> R\"\n  shows \"rel_chain (l @ l') R\"", "lemma rel_chain_appendD:\n  assumes \"rel_chain (l @ l') R\"\n  shows \"rel_chain l R\" \"rel_chain l' R\" \"l \\<noteq> [] \\<and> l' \\<noteq> [] \\<longrightarrow> (last l, hd l') \\<in> R\"", "lemma rtrancl_rel_chain:\n  \"(x, y) \\<in> R\\<^sup>* \\<longleftrightarrow> (\\<exists> l. l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R)\" \n  (is \"?lhs = ?rhs\")", "lemma trancl_rel_chain:\n  \"(x, y) \\<in> R\\<^sup>+ \\<longleftrightarrow> (\\<exists> l. l \\<noteq> [] \\<and> length l > 1 \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma rel_chain_elems_rtrancl:\n  assumes \"rel_chain l R\" \"i \\<le> j\" \"j < length l\" \n  shows \"(l ! i, l ! j) \\<in> R\\<^sup>*\"", "lemma reorder_cyclic_list:\n  assumes  \"hd l = s\" \"last l = s\" \"length l > 2\" \"sl + 1 < length l\" \n    \"rel_chain l r\"\n  obtains l' :: \"'a list\"\n  where \"hd l' = l ! (sl + 1)\" \"last l' = l ! sl\" \"rel_chain l' r\" \"length l' = length l - 1\"\n    \"\\<forall> i. i + 1 < length l' \\<longrightarrow> \n     (\\<exists> j. j + 1 < length l \\<and> l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\""], "translations": [["", "lemma \n  rel_chain_Nil: \"rel_chain [] r\" and\n  rel_chain_Cons: \"rel_chain (x # xs) r = (if xs = [] then True else ((x, hd xs) \\<in> r) \\<and> rel_chain xs r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain [] r &&&\n    rel_chain (x # xs) r =\n    (if xs = [] then True else (x, hd xs) \\<in> r \\<and> rel_chain xs r)", "by (auto simp add: rel_chain_def hd_conv_nth nth_Cons split: nat.split_asm nat.split)"], ["", "lemma rel_chain_drop:\n  \"rel_chain l R ==> rel_chain (drop n l) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain l R \\<Longrightarrow> rel_chain (drop n l) R", "unfolding rel_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length l - 1. (l ! k, l ! (k + 1)) \\<in> R \\<Longrightarrow>\n    \\<forall>k<length (drop n l) - 1.\n       (drop n l ! k, drop n l ! (k + 1)) \\<in> R", "by simp"], ["", "lemma rel_chain_take:\n  \"rel_chain l R ==> rel_chain (take n l) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain l R \\<Longrightarrow> rel_chain (take n l) R", "unfolding rel_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length l - 1. (l ! k, l ! (k + 1)) \\<in> R \\<Longrightarrow>\n    \\<forall>k<length (take n l) - 1.\n       (take n l ! k, take n l ! (k + 1)) \\<in> R", "by simp"], ["", "lemma rel_chain_butlast:\n  \"rel_chain l R ==> rel_chain (butlast l) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain l R \\<Longrightarrow> rel_chain (butlast l) R", "unfolding rel_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length l - 1. (l ! k, l ! (k + 1)) \\<in> R \\<Longrightarrow>\n    \\<forall>k<length (butlast l) - 1.\n       (butlast l ! k, butlast l ! (k + 1)) \\<in> R", "by (auto simp add: butlast_nth)"], ["", "lemma rel_chain_tl:\n  \"rel_chain l R ==> rel_chain (tl l) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain l R \\<Longrightarrow> rel_chain (tl l) R", "unfolding rel_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length l - 1. (l ! k, l ! (k + 1)) \\<in> R \\<Longrightarrow>\n    \\<forall>k<length (tl l) - 1. (tl l ! k, tl l ! (k + 1)) \\<in> R", "by (cases \"l = []\") (auto simp add: tl_nth)"], ["", "lemma rel_chain_append:\n  assumes \"rel_chain l R\" \"rel_chain l' R\" \"(last l, hd l') \\<in> R\"\n  shows \"rel_chain (l @ l') R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain (l @ l') R", "using assms"], ["proof (prove)\nusing this:\n  rel_chain l R\n  rel_chain l' R\n  (last l, hd l') \\<in> R\n\ngoal (1 subgoal):\n 1. rel_chain (l @ l') R", "by (induct l) (auto simp add: rel_chain_Cons split: if_splits)"], ["", "lemma rel_chain_appendD:\n  assumes \"rel_chain (l @ l') R\"\n  shows \"rel_chain l R\" \"rel_chain l' R\" \"l \\<noteq> [] \\<and> l' \\<noteq> [] \\<longrightarrow> (last l, hd l') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain l R &&&\n    rel_chain l' R &&&\n    l \\<noteq> [] \\<and> l' \\<noteq> [] \\<longrightarrow>\n    (last l, hd l') \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  rel_chain (l @ l') R\n\ngoal (1 subgoal):\n 1. rel_chain l R &&&\n    rel_chain l' R &&&\n    l \\<noteq> [] \\<and> l' \\<noteq> [] \\<longrightarrow>\n    (last l, hd l') \\<in> R", "by (induct l) (auto simp add: rel_chain_Cons rel_chain_Nil split: if_splits)"], ["", "lemma rtrancl_rel_chain:\n  \"(x, y) \\<in> R\\<^sup>* \\<longleftrightarrow> (\\<exists> l. l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R)\" \n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> R\\<^sup>*) =\n    (\\<exists>l.\n        l \\<noteq> [] \\<and>\n        hd l = x \\<and> last l = y \\<and> rel_chain l R)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> R\\<^sup>* \\<Longrightarrow>\n    \\<exists>l.\n       l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n 2. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>*", "assume ?lhs"], ["proof (state)\nthis:\n  (x, y) \\<in> R\\<^sup>*\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> R\\<^sup>* \\<Longrightarrow>\n    \\<exists>l.\n       l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n 2. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> R\\<^sup>*", "show ?rhs"], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R", "by (induct rule: converse_rtrancl_induct) (auto simp add: rel_chain_Cons)"], ["proof (state)\nthis:\n  \\<exists>l.\n     l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>*", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>l.\n     l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R", "obtain l where \"l \\<noteq> []\" \"hd l = x\" \"last l = y\" \"rel_chain l R\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     l \\<noteq> [] \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<noteq> []; hd l = x; last l = y; rel_chain l R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R", "show ?lhs"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R\\<^sup>*", "by (induct l arbitrary: x) (auto simp add: rel_chain_Cons, force)"], ["proof (state)\nthis:\n  (x, y) \\<in> R\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trancl_rel_chain:\n  \"(x, y) \\<in> R\\<^sup>+ \\<longleftrightarrow> (\\<exists> l. l \\<noteq> [] \\<and> length l > 1 \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> R\\<^sup>+) =\n    (\\<exists>l.\n        l \\<noteq> [] \\<and>\n        1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n 2. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "assume ?lhs"], ["proof (state)\nthis:\n  (x, y) \\<in> R\\<^sup>+\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n 2. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> R\\<^sup>+", "obtain z where \"(x, z) \\<in> R\" \"(z, y) \\<in> R\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(x, z) \\<in> R; (z, y) \\<in> R\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: tranclD)"], ["proof (state)\nthis:\n  (x, z) \\<in> R\n  (z, y) \\<in> R\\<^sup>*\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n 2. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  (x, z) \\<in> R\n  (z, y) \\<in> R\\<^sup>*", "obtain l where  \"l \\<noteq> [] \\<and> hd l = z \\<and> last l = y \\<and> rel_chain l R\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> R\n  (z, y) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        l \\<noteq> [] \\<and>\n        hd l = z \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: rtrancl_rel_chain)"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<and> hd l = z \\<and> last l = y \\<and> rel_chain l R\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n 2. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> [] \\<and> hd l = z \\<and> last l = y \\<and> rel_chain l R", "show ?rhs"], ["proof (prove)\nusing this:\n  l \\<noteq> [] \\<and> hd l = z \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R", "using \\<open>(x, z) \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  l \\<noteq> [] \\<and> hd l = z \\<and> last l = y \\<and> rel_chain l R\n  (x, z) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R", "by (rule_tac x=\"x # l\" in exI) (auto simp add: rel_chain_Cons)"], ["proof (state)\nthis:\n  \\<exists>l.\n     l \\<noteq> [] \\<and>\n     1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>l.\n     l \\<noteq> [] \\<and>\n     1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     l \\<noteq> [] \\<and>\n     1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R", "obtain l where \"1 < length l\" \"l \\<noteq> []\" \"hd l = x\" \"last l = y\" \"rel_chain l R\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     l \\<noteq> [] \\<and>\n     1 < length l \\<and> hd l = x \\<and> last l = y \\<and> rel_chain l R\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>1 < length l; l \\<noteq> []; hd l = x; last l = y;\n         rel_chain l R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  1 < length l\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  1 < length l\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R", "obtain l' where\n    \"l' \\<noteq> []\" \"l = x # l'\" \"(x, hd l') \\<in> R\" \"rel_chain l' R\""], ["proof (prove)\nusing this:\n  1 < length l\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' \\<noteq> []; l = x # l'; (x, hd l') \\<in> R;\n         rel_chain l' R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>1 < length l\\<close>"], ["proof (prove)\nusing this:\n  1 < length l\n  l \\<noteq> []\n  hd l = x\n  last l = y\n  rel_chain l R\n  1 < length l\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' \\<noteq> []; l = x # l'; (x, hd l') \\<in> R;\n         rel_chain l' R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l) (auto simp add: rel_chain_Cons)"], ["proof (state)\nthis:\n  l' \\<noteq> []\n  l = x # l'\n  (x, hd l') \\<in> R\n  rel_chain l' R\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  l' \\<noteq> []\n  l = x # l'\n  (x, hd l') \\<in> R\n  rel_chain l' R", "have \"(x, hd l') \\<in> R\" \"(hd l', y) \\<in> R\\<^sup>*\""], ["proof (prove)\nusing this:\n  l' \\<noteq> []\n  l = x # l'\n  (x, hd l') \\<in> R\n  rel_chain l' R\n\ngoal (1 subgoal):\n 1. (x, hd l') \\<in> R &&& (hd l', y) \\<in> R\\<^sup>*", "using \\<open>last l = y\\<close>"], ["proof (prove)\nusing this:\n  l' \\<noteq> []\n  l = x # l'\n  (x, hd l') \\<in> R\n  rel_chain l' R\n  last l = y\n\ngoal (1 subgoal):\n 1. (x, hd l') \\<in> R &&& (hd l', y) \\<in> R\\<^sup>*", "by (auto simp add: rtrancl_rel_chain)"], ["proof (state)\nthis:\n  (x, hd l') \\<in> R\n  (hd l', y) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       l \\<noteq> [] \\<and>\n       1 < length l \\<and>\n       hd l = x \\<and> last l = y \\<and> rel_chain l R \\<Longrightarrow>\n    (x, y) \\<in> R\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  (x, hd l') \\<in> R\n  (hd l', y) \\<in> R\\<^sup>*", "show ?lhs"], ["proof (prove)\nusing this:\n  (x, hd l') \\<in> R\n  (hd l', y) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> R\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_chain_elems_rtrancl:\n  assumes \"rel_chain l R\" \"i \\<le> j\" \"j < length l\" \n  shows \"(l ! i, l ! j) \\<in> R\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l ! i, l ! j) \\<in> R\\<^sup>*", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*\n 2. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*\n 2. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. (l ! i, l ! j) \\<in> R\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (l ! i, l ! j) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j", "have \"i < j\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i < j", "using \\<open>i \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  i < j", "have \"l \\<noteq> []\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. l \\<noteq> []", "using \\<open>j < length l\\<close>"], ["proof (prove)\nusing this:\n  i < j\n  j < length l\n\ngoal (1 subgoal):\n 1. l \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "let ?l = \"drop i (take (j + 1) l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "have \"?l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i (take (j + 1) l) \\<noteq> []", "using \\<open>i < j\\<close> \\<open>j < length l\\<close>"], ["proof (prove)\nusing this:\n  i < j\n  j < length l\n\ngoal (1 subgoal):\n 1. drop i (take (j + 1) l) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  drop i (take (j + 1) l) \\<noteq> []\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  drop i (take (j + 1) l) \\<noteq> []\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "have \"hd ?l = l ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (drop i (take (j + 1) l)) = l ! i", "using \\<open>?l \\<noteq> []\\<close> \\<open>i < j\\<close>"], ["proof (prove)\nusing this:\n  drop i (take (j + 1) l) \\<noteq> []\n  i < j\n\ngoal (1 subgoal):\n 1. hd (drop i (take (j + 1) l)) = l ! i", "by (auto simp add: hd_conv_nth)"], ["proof (state)\nthis:\n  hd (drop i (take (j + 1) l)) = l ! i\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  hd (drop i (take (j + 1) l)) = l ! i\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "have \"last ?l = l ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (drop i (take (j + 1) l)) = l ! j", "using \\<open>?l \\<noteq> []\\<close> \\<open>l \\<noteq> []\\<close> \\<open>i < j\\<close> \\<open>j < length l\\<close>"], ["proof (prove)\nusing this:\n  drop i (take (j + 1) l) \\<noteq> []\n  l \\<noteq> []\n  i < j\n  j < length l\n\ngoal (1 subgoal):\n 1. last (drop i (take (j + 1) l)) = l ! j", "by (cases \"length l = j + 1\") (auto simp add: last_conv_nth min_def)"], ["proof (state)\nthis:\n  last (drop i (take (j + 1) l)) = l ! j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  last (drop i (take (j + 1) l)) = l ! j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "have \"rel_chain ?l R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain (drop i (take (j + 1) l)) R", "using \\<open>rel_chain l R\\<close>"], ["proof (prove)\nusing this:\n  rel_chain l R\n\ngoal (1 subgoal):\n 1. rel_chain (drop i (take (j + 1) l)) R", "by (auto intro: rel_chain_drop rel_chain_take)"], ["proof (state)\nthis:\n  rel_chain (drop i (take (j + 1) l)) R\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> (l ! i, l ! j) \\<in> R\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  drop i (take (j + 1) l) \\<noteq> []\n  hd (drop i (take (j + 1) l)) = l ! i\n  last (drop i (take (j + 1) l)) = l ! j\n  rel_chain (drop i (take (j + 1) l)) R", "show ?thesis"], ["proof (prove)\nusing this:\n  drop i (take (j + 1) l) \\<noteq> []\n  hd (drop i (take (j + 1) l)) = l ! i\n  last (drop i (take (j + 1) l)) = l ! j\n  rel_chain (drop i (take (j + 1) l)) R\n\ngoal (1 subgoal):\n 1. (l ! i, l ! j) \\<in> R\\<^sup>*", "by (subst rtrancl_rel_chain) blast"], ["proof (state)\nthis:\n  (l ! i, l ! j) \\<in> R\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reorder_cyclic_list:\n  assumes  \"hd l = s\" \"last l = s\" \"length l > 2\" \"sl + 1 < length l\" \n    \"rel_chain l r\"\n  obtains l' :: \"'a list\"\n  where \"hd l' = l ! (sl + 1)\" \"last l' = l ! sl\" \"rel_chain l' r\" \"length l' = length l - 1\"\n    \"\\<forall> i. i + 1 < length l' \\<longrightarrow> \n     (\\<exists> j. j + 1 < length l \\<and> l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> []", "using \\<open>length l > 2\\<close>"], ["proof (prove)\nusing this:\n  2 < length l\n\ngoal (1 subgoal):\n 1. l \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have  \"length (tl l) > 1\" \"tl l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (tl l) &&& tl l \\<noteq> []", "using \\<open>length l > 2\\<close>"], ["proof (prove)\nusing this:\n  2 < length l\n\ngoal (1 subgoal):\n 1. 1 < length (tl l) &&& tl l \\<noteq> []", "by (auto simp add: length_0_conv[THEN sym])"], ["proof (state)\nthis:\n  1 < length (tl l)\n  tl l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?l' = \"if sl = 0 then \n                 tl l\n             else\n                 drop (sl + 1) l @ tl (take (sl + 1) l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"hd ?l' = l ! (sl + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n    l ! (sl + 1)", "proof (cases \"sl > 0\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < sl \\<Longrightarrow>\n    hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl\n 2. sl = 0 \\<Longrightarrow> hd (tl l) = l ! Suc 0", "show \"hd (tl l) = l ! (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl l) = l ! Suc 0", "using \\<open>tl l \\<noteq> []\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  tl l \\<noteq> []\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl l) = l ! Suc 0", "by (simp add: hd_conv_nth tl_nth)"], ["proof (state)\nthis:\n  hd (tl l) = l ! Suc 0\n\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl", "assume \"0 < sl\""], ["proof (state)\nthis:\n  0 < sl\n\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl", "show \"hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! (Suc sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl", "using \\<open>sl + 1 < length l\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  sl + 1 < length l\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl", "by (auto simp add: hd_append hd_drop_conv_nth)"], ["proof (state)\nthis:\n  hd (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! Suc sl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! (sl + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  hd (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! (sl + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"last ?l' = l ! sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n    l ! sl", "proof (cases \"sl > 0\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < sl \\<Longrightarrow>\n    last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl\n 2. sl = 0 \\<Longrightarrow> last (tl l) = l ! 0", "show \"last (tl l) = l ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (tl l) = l ! 0", "using \\<open>l \\<noteq> []\\<close> \\<open>last l = s\\<close> \\<open>hd l = s\\<close> \\<open>length l > 2\\<close>"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  last l = s\n  hd l = s\n  2 < length l\n\ngoal (1 subgoal):\n 1. last (tl l) = l ! 0", "by (simp add: hd_conv_nth last_tl)"], ["proof (state)\nthis:\n  last (tl l) = l ! 0\n\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl", "assume \"sl > 0\""], ["proof (state)\nthis:\n  0 < sl\n\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl", "then"], ["proof (chain)\npicking this:\n  0 < sl", "show \"last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl\""], ["proof (prove)\nusing this:\n  0 < sl\n\ngoal (1 subgoal):\n 1. last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl", "using \\<open>l \\<noteq> []\\<close> \\<open>tl l \\<noteq> []\\<close> \\<open>sl + 1 < length l\\<close>"], ["proof (prove)\nusing this:\n  0 < sl\n  l \\<noteq> []\n  tl l \\<noteq> []\n  sl + 1 < length l\n\ngoal (1 subgoal):\n 1. last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl", "by (auto simp add: last_append drop_Suc tl_take last_take_conv_nth tl_nth)"], ["proof (state)\nthis:\n  last (drop (Suc sl) l @ tl (take (Suc sl) l)) = l ! sl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! sl\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  last (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! sl\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"rel_chain ?l' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain\n     (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) r", "proof (cases \"sl = 0\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. sl = 0 \\<Longrightarrow> rel_chain (tl l) r\n 2. 0 < sl \\<Longrightarrow>\n    rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r", "case True"], ["proof (state)\nthis:\n  sl = 0\n\ngoal (2 subgoals):\n 1. sl = 0 \\<Longrightarrow> rel_chain (tl l) r\n 2. 0 < sl \\<Longrightarrow>\n    rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r", "show \"rel_chain (tl l) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain (tl l) r", "using \\<open>rel_chain l r\\<close>"], ["proof (prove)\nusing this:\n  rel_chain l r\n\ngoal (1 subgoal):\n 1. rel_chain (tl l) r", "by (auto intro: rel_chain_tl)"], ["proof (state)\nthis:\n  rel_chain (tl l) r\n\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r", "assume \"sl > 0\""], ["proof (state)\nthis:\n  0 < sl\n\ngoal (1 subgoal):\n 1. 0 < sl \\<Longrightarrow>\n    rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r", "show  \"rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r", "proof (rule rel_chain_append)"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_chain (drop (Suc sl) l) r\n 2. rel_chain (tl (take (Suc sl) l)) r\n 3. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "show \"rel_chain (drop (Suc sl) l) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain (drop (Suc sl) l) r", "using \\<open>rel_chain l r\\<close>"], ["proof (prove)\nusing this:\n  rel_chain l r\n\ngoal (1 subgoal):\n 1. rel_chain (drop (Suc sl) l) r", "by (auto intro: rel_chain_drop)"], ["proof (state)\nthis:\n  rel_chain (drop (Suc sl) l) r\n\ngoal (2 subgoals):\n 1. rel_chain (tl (take (Suc sl) l)) r\n 2. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_chain (tl (take (Suc sl) l)) r\n 2. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "show \"rel_chain (tl (take (Suc sl) l)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_chain (tl (take (Suc sl) l)) r", "using \\<open>rel_chain l r\\<close>"], ["proof (prove)\nusing this:\n  rel_chain l r\n\ngoal (1 subgoal):\n 1. rel_chain (tl (take (Suc sl) l)) r", "by (auto intro: rel_chain_tl rel_chain_take)"], ["proof (state)\nthis:\n  rel_chain (tl (take (Suc sl) l)) r\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "have \"last (drop (sl + 1) l) = l ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (drop (sl + 1) l) = l ! 0", "using \\<open>sl + 1 < length l\\<close> \\<open>last l = s\\<close> \\<open>hd l = s\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  sl + 1 < length l\n  last l = s\n  hd l = s\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (drop (sl + 1) l) = l ! 0", "by (auto simp add: hd_conv_nth)"], ["proof (state)\nthis:\n  last (drop (sl + 1) l) = l ! 0\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "moreover"], ["proof (state)\nthis:\n  last (drop (sl + 1) l) = l ! 0\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "have \"sl > 0 \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sl \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []", "using \\<open>sl + 1 < length l\\<close> \\<open>l \\<noteq> []\\<close> \\<open>tl l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  sl + 1 < length l\n  l \\<noteq> []\n  tl l \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < sl \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []", "by (auto simp add: take_Suc)"], ["proof (state)\nthis:\n  0 < sl \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "then"], ["proof (chain)\npicking this:\n  0 < sl \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []", "have \"sl > 0 \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1\""], ["proof (prove)\nusing this:\n  0 < sl \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1", "using \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  0 < sl \\<longrightarrow> tl (take (sl + 1) l) \\<noteq> []\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1", "by (auto simp add: hd_conv_nth take_Suc tl_nth)"], ["proof (state)\nthis:\n  0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  last (drop (sl + 1) l) = l ! 0\n  0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1", "show \"(last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r\""], ["proof (prove)\nusing this:\n  last (drop (sl + 1) l) = l ! 0\n  0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "using \\<open>rel_chain l r\\<close> \\<open>length l > 2\\<close> \\<open>sl > 0\\<close>"], ["proof (prove)\nusing this:\n  last (drop (sl + 1) l) = l ! 0\n  0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1\n  rel_chain l r\n  2 < length l\n  0 < sl\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "unfolding rel_chain_def"], ["proof (prove)\nusing this:\n  last (drop (sl + 1) l) = l ! 0\n  0 < sl \\<longrightarrow> hd (tl (take (sl + 1) l)) = l ! 1\n  \\<forall>k<length l - 1. (l ! k, l ! (k + 1)) \\<in> r\n  2 < length l\n  0 < sl\n\ngoal (1 subgoal):\n 1. (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r", "by simp"], ["proof (state)\nthis:\n  (last (drop (Suc sl) l), hd (tl (take (Suc sl) l))) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_chain (drop (Suc sl) l @ tl (take (Suc sl) l)) r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_chain\n   (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) r\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  rel_chain\n   (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) r\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"length ?l' = length l - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n    length l - 1", "by auto"], ["proof (state)\nthis:\n  length (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  length l - 1\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  hd (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! (sl + 1)\n  last (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! sl\n  rel_chain\n   (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) r\n  length (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  length l - 1", "obtain l' where *: \"l' = ?l'\" \"hd l' = l ! (sl + 1)\" \"last l' = l ! sl\" \"rel_chain l' r\" \"length l' = length l - 1\""], ["proof (prove)\nusing this:\n  hd (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! (sl + 1)\n  last (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  l ! sl\n  rel_chain\n   (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) r\n  length (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l)) =\n  length l - 1\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' =\n                 (if sl = 0 then tl l\n                  else drop (sl + 1) l @ tl (take (sl + 1) l));\n         hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  hd l' = l ! (sl + 1)\n  last l' = l ! sl\n  rel_chain l' r\n  length l' = length l - 1\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have l'_l: \"\\<forall> i. i + 1 < length l' \\<longrightarrow> \n    (\\<exists> j. j + 1 < length l \\<and> l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i + 1 < length l' \\<longrightarrow>\n       (\\<exists>j.\n           j + 1 < length l \\<and>\n           l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i + 1 < length l' \\<Longrightarrow>\n       \\<exists>j.\n          j + 1 < length l \\<and>\n          l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i + 1 < length l' \\<Longrightarrow>\n       \\<exists>j.\n          j + 1 < length l \\<and>\n          l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "assume \"i + 1 < length l'\""], ["proof (state)\nthis:\n  i + 1 < length l'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i + 1 < length l' \\<Longrightarrow>\n       \\<exists>j.\n          j + 1 < length l \\<and>\n          l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "show \"\\<exists> j. j + 1 < length l \\<and> l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "proof (cases \"sl = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sl = 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "case True"], ["proof (state)\nthis:\n  sl = 0\n\ngoal (2 subgoals):\n 1. sl = 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  sl = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sl = 0\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>i + 1 < length l'\\<close>"], ["proof (prove)\nusing this:\n  sl = 0\n  i + 1 < length l'\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>l' = ?l'\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  sl = 0\n  i + 1 < length l'\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "by (force simp add: tl_nth)"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal (1 subgoal):\n 1. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "case False"], ["proof (state)\nthis:\n  sl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  sl \\<noteq> 0", "have \"length l' = length l - 1\""], ["proof (prove)\nusing this:\n  sl \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length l' = length l - 1", "using \\<open>l' = ?l'\\<close> \\<open>sl + 1 < length l\\<close>"], ["proof (prove)\nusing this:\n  sl \\<noteq> 0\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  sl + 1 < length l\n\ngoal (1 subgoal):\n 1. length l' = length l - 1", "by (simp add: min_def)"], ["proof (state)\nthis:\n  length l' = length l - 1\n\ngoal (1 subgoal):\n 1. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  length l' = length l - 1", "have \"i + 2 < length l\""], ["proof (prove)\nusing this:\n  length l' = length l - 1\n\ngoal (1 subgoal):\n 1. i + 2 < length l", "using \\<open>i + 1 < length l'\\<close>"], ["proof (prove)\nusing this:\n  length l' = length l - 1\n  i + 1 < length l'\n\ngoal (1 subgoal):\n 1. i + 2 < length l", "by simp"], ["proof (state)\nthis:\n  i + 2 < length l\n\ngoal (1 subgoal):\n 1. sl \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "proof (cases \"i + 1 < length (drop (sl + 1) l)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "case True"], ["proof (state)\nthis:\n  i + 1 < length (drop (sl + 1) l)\n\ngoal (2 subgoals):\n 1. i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  i + 1 < length (drop (sl + 1) l)", "show ?thesis"], ["proof (prove)\nusing this:\n  i + 1 < length (drop (sl + 1) l)\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>sl \\<noteq> 0\\<close> \\<open>l' = ?l'\\<close>"], ["proof (prove)\nusing this:\n  i + 1 < length (drop (sl + 1) l)\n  sl \\<noteq> 0\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "by (force simp add: nth_append)"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal (1 subgoal):\n 1. \\<not> i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "case False"], ["proof (state)\nthis:\n  \\<not> i + 1 < length (drop (sl + 1) l)\n\ngoal (1 subgoal):\n 1. \\<not> i + 1 < length (drop (sl + 1) l) \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "proof (cases \"i + 1 > length (drop (sl + 1) l)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "case True"], ["proof (state)\nthis:\n  length (drop (sl + 1) l) < i + 1\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  length (drop (sl + 1) l) < i + 1", "have \"i + 1 > length l - (sl + 1)\""], ["proof (prove)\nusing this:\n  length (drop (sl + 1) l) < i + 1\n\ngoal (1 subgoal):\n 1. length l - (sl + 1) < i + 1", "by auto"], ["proof (state)\nthis:\n  length l - (sl + 1) < i + 1\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "have\n            \"l' ! i = l ! Suc (i - (length l - Suc sl))\" \n            \"l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' ! i = l ! Suc (i - (length l - Suc sl)) &&&\n    l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))", "using \\<open>i + 2 < length l\\<close> \\<open>sl + 1 < length l\\<close>"], ["proof (prove)\nusing this:\n  i + 2 < length l\n  sl + 1 < length l\n\ngoal (1 subgoal):\n 1. l' ! i = l ! Suc (i - (length l - Suc sl)) &&&\n    l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))", "using \\<open>i + 1 > length l - (sl + 1)\\<close>"], ["proof (prove)\nusing this:\n  i + 2 < length l\n  sl + 1 < length l\n  length l - (sl + 1) < i + 1\n\ngoal (1 subgoal):\n 1. l' ! i = l ! Suc (i - (length l - Suc sl)) &&&\n    l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))", "using \\<open>sl \\<noteq> 0\\<close> \\<open>l' = ?l'\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  i + 2 < length l\n  sl + 1 < length l\n  length l - (sl + 1) < i + 1\n  sl \\<noteq> 0\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l' ! i = l ! Suc (i - (length l - Suc sl)) &&&\n    l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))", "using tl_nth[of \"take (sl + 1) l\" \"i - (length l - Suc sl)\"]"], ["proof (prove)\nusing this:\n  i + 2 < length l\n  sl + 1 < length l\n  length l - (sl + 1) < i + 1\n  sl \\<noteq> 0\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  l \\<noteq> []\n  take (sl + 1) l \\<noteq> [] \\<Longrightarrow>\n  tl (take (sl + 1) l) ! (i - (length l - Suc sl)) =\n  take (sl + 1) l ! (i - (length l - Suc sl) + 1)\n\ngoal (1 subgoal):\n 1. l' ! i = l ! Suc (i - (length l - Suc sl)) &&&\n    l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))", "using tl_nth[of \"take (sl + 1) l\" \"Suc i - (length l - Suc sl)\"]"], ["proof (prove)\nusing this:\n  i + 2 < length l\n  sl + 1 < length l\n  length l - (sl + 1) < i + 1\n  sl \\<noteq> 0\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  l \\<noteq> []\n  take (sl + 1) l \\<noteq> [] \\<Longrightarrow>\n  tl (take (sl + 1) l) ! (i - (length l - Suc sl)) =\n  take (sl + 1) l ! (i - (length l - Suc sl) + 1)\n  take (sl + 1) l \\<noteq> [] \\<Longrightarrow>\n  tl (take (sl + 1) l) ! (Suc i - (length l - Suc sl)) =\n  take (sl + 1) l ! (Suc i - (length l - Suc sl) + 1)\n\ngoal (1 subgoal):\n 1. l' ! i = l ! Suc (i - (length l - Suc sl)) &&&\n    l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  l' ! i = l ! Suc (i - (length l - Suc sl))\n  l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "have \"Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1\"\n            \"Suc (Suc i - (length l - Suc sl)) = (i + sl + 1 - length l + 1) + 1\"\n            \"i + sl + 1 - length l + 1 + 1 < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1 &&&\n    Suc (Suc i - (length l - Suc sl)) = i + sl + 1 - length l + 1 + 1 &&&\n    i + sl + 1 - length l + 1 + 1 < length l", "using \\<open>sl + 1 < length l\\<close>"], ["proof (prove)\nusing this:\n  sl + 1 < length l\n\ngoal (1 subgoal):\n 1. Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1 &&&\n    Suc (Suc i - (length l - Suc sl)) = i + sl + 1 - length l + 1 + 1 &&&\n    i + sl + 1 - length l + 1 + 1 < length l", "using \\<open>i + 1 > length l - (sl + 1)\\<close>"], ["proof (prove)\nusing this:\n  sl + 1 < length l\n  length l - (sl + 1) < i + 1\n\ngoal (1 subgoal):\n 1. Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1 &&&\n    Suc (Suc i - (length l - Suc sl)) = i + sl + 1 - length l + 1 + 1 &&&\n    i + sl + 1 - length l + 1 + 1 < length l", "using \\<open>i + 2 < length l\\<close>"], ["proof (prove)\nusing this:\n  sl + 1 < length l\n  length l - (sl + 1) < i + 1\n  i + 2 < length l\n\ngoal (1 subgoal):\n 1. Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1 &&&\n    Suc (Suc i - (length l - Suc sl)) = i + sl + 1 - length l + 1 + 1 &&&\n    i + sl + 1 - length l + 1 + 1 < length l", "by auto"], ["proof (state)\nthis:\n  Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1\n  Suc (Suc i - (length l - Suc sl)) = i + sl + 1 - length l + 1 + 1\n  i + sl + 1 - length l + 1 + 1 < length l\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "have \"l' ! i = l ! (i + sl + 1 - length l + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' ! i = l ! (i + sl + 1 - length l + 1)", "using \\<open>l' ! i = l ! Suc (i - (length l - Suc sl))\\<close>"], ["proof (prove)\nusing this:\n  l' ! i = l ! Suc (i - (length l - Suc sl))\n\ngoal (1 subgoal):\n 1. l' ! i = l ! (i + sl + 1 - length l + 1)", "by (subst \\<open>Suc (i - (length l - Suc sl)) = i + sl + 1 - length l + 1\\<close>[THEN sym])"], ["proof (state)\nthis:\n  l' ! i = l ! (i + sl + 1 - length l + 1)\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "moreover"], ["proof (state)\nthis:\n  l' ! i = l ! (i + sl + 1 - length l + 1)\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "have \"l' ! (i + 1) = l ! ((i + sl + 1 - length l + 1) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' ! (i + 1) = l ! (i + sl + 1 - length l + 1 + 1)", "using \\<open>l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))\\<close>"], ["proof (prove)\nusing this:\n  l' ! (i + 1) = l ! Suc (Suc i - (length l - Suc sl))\n\ngoal (1 subgoal):\n 1. l' ! (i + 1) = l ! (i + sl + 1 - length l + 1 + 1)", "by (subst \\<open>Suc (Suc i - (length l - Suc sl)) = (i + sl + 1 - length l + 1) + 1\\<close>[THEN sym])"], ["proof (state)\nthis:\n  l' ! (i + 1) = l ! (i + sl + 1 - length l + 1 + 1)\n\ngoal (2 subgoals):\n 1. length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n 2. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "ultimately"], ["proof (chain)\npicking this:\n  l' ! i = l ! (i + sl + 1 - length l + 1)\n  l' ! (i + 1) = l ! (i + sl + 1 - length l + 1 + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  l' ! i = l ! (i + sl + 1 - length l + 1)\n  l' ! (i + 1) = l ! (i + sl + 1 - length l + 1 + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>i + sl + 1 - length l + 1 + 1 < length l\\<close>"], ["proof (prove)\nusing this:\n  l' ! i = l ! (i + sl + 1 - length l + 1)\n  l' ! (i + 1) = l ! (i + sl + 1 - length l + 1 + 1)\n  i + sl + 1 - length l + 1 + 1 < length l\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "by force"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal (1 subgoal):\n 1. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "case False"], ["proof (state)\nthis:\n  \\<not> length (drop (sl + 1) l) < i + 1\n\ngoal (1 subgoal):\n 1. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  \\<not> length (drop (sl + 1) l) < i + 1", "have \"i + 1 = length l - sl - 1\""], ["proof (prove)\nusing this:\n  \\<not> length (drop (sl + 1) l) < i + 1\n\ngoal (1 subgoal):\n 1. i + 1 = length l - sl - 1", "using \\<open>\\<not> i + 1 < length (drop (sl + 1) l)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> length (drop (sl + 1) l) < i + 1\n  \\<not> i + 1 < length (drop (sl + 1) l)\n\ngoal (1 subgoal):\n 1. i + 1 = length l - sl - 1", "by simp"], ["proof (state)\nthis:\n  i + 1 = length l - sl - 1\n\ngoal (1 subgoal):\n 1. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  i + 1 = length l - sl - 1", "have \"length l - 1 = sl + i + 1\""], ["proof (prove)\nusing this:\n  i + 1 = length l - sl - 1\n\ngoal (1 subgoal):\n 1. length l - 1 = sl + i + 1", "by auto"], ["proof (state)\nthis:\n  length l - 1 = sl + i + 1\n\ngoal (1 subgoal):\n 1. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  length l - 1 = sl + i + 1", "have \"l ! Suc (sl + i) = last l\""], ["proof (prove)\nusing this:\n  length l - 1 = sl + i + 1\n\ngoal (1 subgoal):\n 1. l ! Suc (sl + i) = last l", "using last_conv_nth[of l, THEN sym] \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  length l - 1 = sl + i + 1\n  l \\<noteq> [] \\<Longrightarrow> l ! (length l - 1) = last l\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l ! Suc (sl + i) = last l", "by simp"], ["proof (state)\nthis:\n  l ! Suc (sl + i) = last l\n\ngoal (1 subgoal):\n 1. \\<not> length (drop (sl + 1) l) < i + 1 \\<Longrightarrow>\n    \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "then"], ["proof (chain)\npicking this:\n  l ! Suc (sl + i) = last l", "show ?thesis"], ["proof (prove)\nusing this:\n  l ! Suc (sl + i) = last l\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>i + 1 = length l - sl - 1\\<close>"], ["proof (prove)\nusing this:\n  l ! Suc (sl + i) = last l\n  i + 1 = length l - sl - 1\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>l' = ?l'\\<close> \\<open>sl \\<noteq> 0\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  l ! Suc (sl + i) = last l\n  i + 1 = length l - sl - 1\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  sl \\<noteq> 0\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using tl_nth[of \"take (sl + 1) l\" 0]"], ["proof (prove)\nusing this:\n  l ! Suc (sl + i) = last l\n  i + 1 = length l - sl - 1\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  sl \\<noteq> 0\n  l \\<noteq> []\n  take (sl + 1) l \\<noteq> [] \\<Longrightarrow>\n  tl (take (sl + 1) l) ! 0 = take (sl + 1) l ! (0 + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "using \\<open>hd l = s\\<close> \\<open>last l = s\\<close>"], ["proof (prove)\nusing this:\n  l ! Suc (sl + i) = last l\n  i + 1 = length l - sl - 1\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  sl \\<noteq> 0\n  l \\<noteq> []\n  take (sl + 1) l \\<noteq> [] \\<Longrightarrow>\n  tl (take (sl + 1) l) ! 0 = take (sl + 1) l ! (0 + 1)\n  hd l = s\n  last l = s\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       j + 1 < length l \\<and>\n       l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)", "by (force simp add: nth_append hd_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j.\n     j + 1 < length l \\<and>\n     l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     i + 1 < length l' \\<longrightarrow>\n     (\\<exists>j.\n         j + 1 < length l \\<and>\n         l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n         length l' = length l - 1;\n         \\<forall>i.\n            i + 1 < length l' \\<longrightarrow>\n            (\\<exists>j.\n                j + 1 < length l \\<and>\n                l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     i + 1 < length l' \\<longrightarrow>\n     (\\<exists>j.\n         j + 1 < length l \\<and>\n         l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))", "show thesis"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i + 1 < length l' \\<longrightarrow>\n     (\\<exists>j.\n         j + 1 < length l \\<and>\n         l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\n\ngoal (1 subgoal):\n 1. thesis", "using * l'_l"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i + 1 < length l' \\<longrightarrow>\n     (\\<exists>j.\n         j + 1 < length l \\<and>\n         l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\n  l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l))\n  hd l' = l ! (sl + 1)\n  last l' = l ! sl\n  rel_chain l' r\n  length l' = length l - 1\n  \\<forall>i.\n     i + 1 < length l' \\<longrightarrow>\n     (\\<exists>j.\n         j + 1 < length l \\<and>\n         l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\n\ngoal (1 subgoal):\n 1. thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                i + 1 < length l' \\<longrightarrow>\n                (\\<exists>j.\n                    j + 1 < length l \\<and>\n                    l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1));\n     l' = (if sl = 0 then tl l else drop (sl + 1) l @ tl (take (sl + 1) l));\n     hd l' = l ! (sl + 1); last l' = l ! sl; rel_chain l' r;\n     length l' = length l - 1;\n     \\<forall>i.\n        i + 1 < length l' \\<longrightarrow>\n        (\\<exists>j.\n            j + 1 < length l \\<and>\n            l' ! i = l ! j \\<and> l' ! (i + 1) = l ! (j + 1))\\<rbrakk>\n    \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}