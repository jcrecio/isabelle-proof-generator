{"file_name": "/home/qj213/afp-2021-10-22/thys/Nat-Interval-Logic/IL_Interval.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nat-Interval-Logic", "problem_names": ["lemmas iT_defs = iFROM_def iTILL_def iIN_def iMOD_def iMODb_def", "lemma iFROM_iff: \"x \\<in> [n\\<dots>] = (n \\<le> x)\"", "lemma iTILL_iff: \"x \\<in> [\\<dots>n] = (x \\<le> n)\"", "lemma iIN_iff:\"x \\<in> [n\\<dots>,d] = (n \\<le> x \\<and> x \\<le> n + d)\"", "lemma iMOD_iff: \"x \\<in> [r, mod m] = (x mod m = r mod m \\<and> r \\<le> x)\"", "lemma iMODb_iff: \"x \\<in> [r, mod m, c] = \n  (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c)\"", "lemma iFROM_D: \"x \\<in> [n\\<dots>] \\<Longrightarrow> (n \\<le> x)\"", "lemma iTILL_D: \"x \\<in> [\\<dots>n] \\<Longrightarrow> (x \\<le> n)\"", "lemmas iT_iff = iFROM_iff iTILL_iff iIN_iff iMOD_iff iMODb_iff", "lemmas iT_drule =\n  iFROM_D\n  iTILL_D\n  iIN_geD iIN_leD\n  iMOD_modD iMOD_geD\n  iMODb_modD iMODb_geD iMODb_leD", "lemma \n  iFROM_I [intro]: \"n \\<le> x \\<Longrightarrow> x \\<in> [n\\<dots>]\" and\n  iTILL_I [intro]: \"x \\<le> n \\<Longrightarrow> x \\<in> [\\<dots>n]\" and\n  iIN_I [intro]:   \"n \\<le> x \\<Longrightarrow> x \\<le> n + d \\<Longrightarrow> x \\<in> [n\\<dots>,d]\" and\n  iMOD_I [intro]:  \"x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> x \\<in> [r, mod m]\" and\n  iMODb_I [intro]: \"x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> x \\<le> r + m * c \\<Longrightarrow> x \\<in> [r, mod m, c]\"", "lemma \n  iFROM_E [elim]:  \"x \\<in> [n\\<dots>] \\<Longrightarrow> (n \\<le> x \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iTILL_E [elim]:  \"x \\<in> [\\<dots>n] \\<Longrightarrow> (x \\<le> n \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iIN_E [elim]:    \"x \\<in> [n\\<dots>,d] \\<Longrightarrow> (n \\<le> x \\<Longrightarrow> x \\<le> n + d \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iMOD_E [elim]:   \"x \\<in> [r, mod m] \\<Longrightarrow> (x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iMODb_E [elim]:   \"x \\<in> [r, mod m, c] \\<Longrightarrow> (x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> x \\<le> r + m * c \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma iIN_Suc_insert_conv: \"\n  insert (Suc (n + d)) [n\\<dots>,d] = [n\\<dots>,Suc d]\"", "lemma iTILL_Suc_insert_conv: \"insert (Suc n) [\\<dots>n] = [\\<dots>Suc n]\"", "lemma iMODb_Suc_insert_conv: \"\n  insert (r + m * Suc c) [r, mod m, c] = [r, mod m, Suc c]\"", "lemma iFROM_pred_insert_conv: \"insert (n - Suc 0) [n\\<dots>] = [n - Suc 0\\<dots>]\"", "lemma iIN_pred_insert_conv: \"\n  0 < n \\<Longrightarrow> insert (n - Suc 0) [n\\<dots>,d] = [n - Suc 0\\<dots>,Suc d]\"", "lemma iMOD_pred_insert_conv: \"\n  m \\<le> r \\<Longrightarrow> insert (r - m) [r, mod m] = [r - m, mod m]\"", "lemma iMODb_pred_insert_conv: \"\n  m \\<le> r \\<Longrightarrow> insert (r - m) [r, mod m, c] = [r - m, mod m, Suc c]\"", "lemma iFROM_Suc_pred_insert_conv: \"insert n [Suc n\\<dots>] = [n\\<dots>]\"", "lemma iIN_Suc_pred_insert_conv: \"insert n [Suc n\\<dots>,d] = [n\\<dots>,Suc d]\"", "lemma iMOD_Suc_pred_insert_conv: \"insert r [r + m, mod m] = [r, mod m]\"", "lemma iMODb_Suc_pred_insert_conv: \"insert r [r + m, mod m, c] = [r, mod m, Suc c]\"", "lemmas iT_Suc_insert =\n  iIN_Suc_insert_conv\n  iTILL_Suc_insert_conv\n  iMODb_Suc_insert_conv", "lemmas iT_pred_insert =\n  iFROM_pred_insert_conv\n  iIN_pred_insert_conv\n  iMOD_pred_insert_conv\n  iMODb_pred_insert_conv", "lemmas iT_Suc_pred_insert =\n  iFROM_Suc_pred_insert_conv\n  iIN_Suc_pred_insert_conv\n  iMOD_Suc_pred_insert_conv\n  iMODb_Suc_pred_insert_conv", "lemma iMOD_mem_diff: \"\\<lbrakk> a \\<in> [r, mod m]; b \\<in> [r, mod m] \\<rbrakk> \\<Longrightarrow> (a - b) mod m = 0\"", "lemma iMODb_mem_diff: \"\\<lbrakk> a \\<in> [r, mod m, c]; b \\<in> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> (a - b) mod m = 0\"", "lemma iIN_0_iTILL_conv:\"[0\\<dots>,n] = [\\<dots>n]\"", "lemma iIN_iTILL_iTILL_conv: \"0 < n \\<Longrightarrow> [n\\<dots>,d] = [\\<dots>n+d] - [\\<dots>n - Suc 0]\"", "lemma iIN_iFROM_iTILL_conv: \"[n\\<dots>,d] = [n\\<dots>] \\<inter> [\\<dots>n+d]\"", "lemma iMODb_iMOD_iTILL_conv: \"[r, mod m, c] = [r, mod m] \\<inter> [\\<dots>r+m*c]\"", "lemma iMODb_iMOD_iIN_conv: \"[r, mod m, c] = [r, mod m] \\<inter> [r\\<dots>,m*c]\"", "lemma iFROM_iTILL_iIN_conv: \"n \\<le> n' \\<Longrightarrow> [n\\<dots>] \\<inter> [\\<dots>n'] = [n\\<dots>,n'-n]\"", "lemma iMOD_iTILL_iMODb_conv: \"\n  r \\<le> n \\<Longrightarrow> [r, mod m] \\<inter> [\\<dots>n] = [r, mod m, (n - r) div m]\"", "lemma iMOD_iIN_iMODb_conv: \"\n  [r, mod m] \\<inter> [r\\<dots>,d] = [r, mod m, d div m]\"", "lemma iFROM_0: \"[0\\<dots>] = UNIV\"", "lemma iTILL_0: \"[\\<dots>0] = {0}\"", "lemma iIN_0: \"[n\\<dots>,0] = {n}\"", "lemma iMOD_0: \"[r, mod 0] = [r\\<dots>,0]\"", "lemma iMODb_mod_0: \"[r, mod 0, c] = [r\\<dots>,0]\"", "lemma iMODb_0: \"[r, mod m, 0] = [r\\<dots>,0]\"", "lemmas iT_0 =\n  iFROM_0\n  iTILL_0\n  iIN_0\n  iMOD_0\n  iMODb_mod_0\n  iMODb_0", "lemma iMOD_1: \"[r, mod Suc 0] = [r\\<dots>]\"", "lemma iMODb_mod_1: \"[r, mod Suc 0, c] = [r\\<dots>,c]\"", "lemma \n  iFROM_not_empty: \"[n\\<dots>] \\<noteq> {}\" and\n  iTILL_not_empty: \"[\\<dots>n] \\<noteq> {}\" and\n  iIN_not_empty: \"[n\\<dots>,d] \\<noteq> {}\" and\n  iMOD_not_empty: \"[r, mod m] \\<noteq> {}\" and\n  iMODb_not_empty: \"[r, mod m, c] \\<noteq> {}\"", "lemmas iT_not_empty = \n  iFROM_not_empty\n  iTILL_not_empty\n  iIN_not_empty\n  iMOD_not_empty\n  iMODb_not_empty", "lemma \n  iTILL_finite: \"finite [\\<dots>n]\" and\n  iIN_finite: \"finite [n\\<dots>,d]\" and\n  iMODb_finite: \"finite [r, mod m, c]\" and\n  iMOD_0_finite: \"finite [r, mod 0]\"", "lemma iFROM_infinite: \"infinite [n\\<dots>]\"", "lemma iMOD_infinite: \"0 < m \\<Longrightarrow> infinite [r, mod m]\"", "lemmas iT_finite =\n  iTILL_finite\n  iIN_finite\n  iMODb_finite iMOD_0_finite", "lemmas iT_infinite =\n  iFROM_infinite\n  iMOD_infinite", "lemma \n  iTILL_Min: \"iMin [\\<dots>n] = 0\" and\n  iFROM_Min: \"iMin [n\\<dots>] = n\" and\n  iIN_Min:   \"iMin [n\\<dots>,d] = n\" and\n  iMOD_Min:  \"iMin [r, mod m] = r\" and\n  iMODb_Min: \"iMin [r, mod m, c] = r\"", "lemmas iT_Min = \n  iIN_Min\n  iTILL_Min\n  iFROM_Min\n  iMOD_Min\n  iMODb_Min", "lemma \n  iTILL_Max: \"Max [\\<dots>n] = n\" and\n  iIN_Max: \"Max [n\\<dots>,d] = n+d\" and\n  iMODb_Max: \"Max [r, mod m, c] = r + m * c\" and\n  iMOD_0_Max: \"Max [r, mod 0] = r\"", "lemmas iT_Max =\n  iTILL_Max\n  iIN_Max\n  iMODb_Max\n  iMOD_0_Max", "lemma\n  iTILL_iMax: \"iMax [\\<dots>n] = enat n\" and\n  iIN_iMax: \"iMax [n\\<dots>,d] = enat (n+d)\" and\n  iMODb_iMax: \"iMax [r, mod m, c] = enat (r + m * c)\" and\n  iMOD_0_iMax: \"iMax [r, mod 0] = enat r\" and\n  iFROM_iMax: \"iMax [n\\<dots>] = \\<infinity>\" and\n  iMOD_iMax: \"0 < m \\<Longrightarrow> iMax [r, mod m] = \\<infinity>\"", "lemmas iT_iMax =\n  iTILL_iMax\n  iIN_iMax\n  iMODb_iMax\n  iMOD_0_iMax\n  iFROM_iMax\n  iMOD_iMax", "lemma \n  iFROM_plus: \"x \\<in> [n\\<dots>] \\<Longrightarrow> x + k \\<in> [n\\<dots>]\" and\n  iFROM_Suc: \"x \\<in> [n\\<dots>] \\<Longrightarrow> Suc x \\<in> [n\\<dots>]\" and\n  iFROM_minus: \"\\<lbrakk> x \\<in> [n\\<dots>]; k \\<le> x - n \\<rbrakk> \\<Longrightarrow> x - k \\<in> [n\\<dots>]\" and\n  iFROM_pred: \"n < x  \\<Longrightarrow> x - Suc 0 \\<in> [n\\<dots>]\"", "lemma \n  iTILL_plus: \"\\<lbrakk> x \\<in> [\\<dots>n]; k \\<le> n - x \\<rbrakk> \\<Longrightarrow> x + k \\<in> [\\<dots>n]\" and\n  iTILL_Suc: \"x < n \\<Longrightarrow> Suc x \\<in> [\\<dots>n]\" and\n  iTILL_minus: \"x \\<in> [\\<dots>n] \\<Longrightarrow> x - k \\<in> [\\<dots>n]\" and\n  iTILL_pred: \"x \\<in> [\\<dots>n] \\<Longrightarrow> x - Suc 0 \\<in> [\\<dots>n]\"", "lemma iIN_plus: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; k \\<le> n + d - x \\<rbrakk> \\<Longrightarrow> x + k \\<in> [n\\<dots>,d]\"", "lemma iIN_Suc: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; x < n + d \\<rbrakk> \\<Longrightarrow> Suc x \\<in> [n\\<dots>,d]\"", "lemma iIN_minus: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; k \\<le> x - n \\<rbrakk> \\<Longrightarrow> x - k \\<in> [n\\<dots>,d]\"", "lemma iIN_pred: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; n < x \\<rbrakk> \\<Longrightarrow> x - Suc 0 \\<in> [n\\<dots>,d]\"", "lemma iMOD_plus_divisor_mult: \"x \\<in> [r, mod m] \\<Longrightarrow> x + k * m \\<in> [r, mod m]\"", "lemma iMOD_minus_divisor_mult: \"\n  \\<lbrakk> x \\<in> [r, mod m]; k * m \\<le> x - r \\<rbrakk> \\<Longrightarrow> x - k * m \\<in> [r, mod m]\"", "lemma iMOD_plus: \"\n  x \\<in> [r, mod m] \\<Longrightarrow> (x + k \\<in> [r, mod m]) = (k mod m = 0)\"", "lemma iMOD_minus: \"\n  \\<lbrakk> x \\<in> [r, mod m]; k \\<le> x - r \\<rbrakk> \\<Longrightarrow> (x - k \\<in> [r, mod m]) = (k mod m = 0)\"", "lemma iMODb_plus_divisor_mult: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k * m \\<le> r + m * c - x \\<rbrakk> \\<Longrightarrow> x + k * m \\<in> [r, mod m, c]\"", "lemma iMODb_plus_divisor_mult2: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k \\<le> c - (x - r) div m \\<rbrakk> \\<Longrightarrow> \n  x + k * m \\<in> [r, mod m, c]\"", "lemma iMODb_plus_divisor: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; x < r + m * c \\<rbrakk> \\<Longrightarrow> x + m \\<in> [r, mod m, c]\"", "lemma iMODb_minus_divisor_mult: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; r + k * m \\<le> x \\<rbrakk>  \\<Longrightarrow> x - k * m \\<in> [r, mod m, c]\"", "lemma iMODb_plus: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k \\<le> r + m * c - x \\<rbrakk> \\<Longrightarrow> \n  (x + k \\<in> [r, mod m, c]) = (k mod m = 0)\"", "lemma iMODb_minus: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k \\<le> x - r \\<rbrakk> \\<Longrightarrow> \n  (x - k \\<in> [r, mod m, c]) = (k mod m = 0)\"", "lemmas iFROM_plus_minus =\n  iFROM_plus\n  iFROM_Suc\n  iFROM_minus\n  iFROM_pred", "lemmas iTILL_plus_minus =\n  iTILL_plus\n  iTILL_Suc\n  iTILL_minus\n  iTILL_pred", "lemmas iIN_plus_minus =\n  iIN_plus\n  iIN_Suc\n  iTILL_minus\n  iIN_pred", "lemmas iMOD_plus_minus_divisor =\n  iMOD_plus_divisor_mult\n  iMOD_plus_divisor\n  iMOD_minus_divisor_mult\n  iMOD_minus_divisor_mult2\n  iMOD_minus_divisor", "lemmas iMOD_plus_minus =\n  iMOD_plus\n  iMOD_Suc\n  iMOD_minus\n  iMOD_pred", "lemmas iMODb_plus_minus_divisor =\n  iMODb_plus_divisor_mult\n  iMODb_plus_divisor_mult2\n  iMODb_plus_divisor\n  iMODb_minus_divisor_mult", "lemmas iMODb_plus_minus =\n  iMODb_plus\n  iMODb_Suc\n  iMODb_minus\n  iMODb_pred", "lemmas iT_plus_minus =\n  iFROM_plus_minus\n  iTILL_plus_minus\n  iIN_plus_minus\n  iMOD_plus_minus_divisor\n  iMOD_plus_minus\n  iMODb_plus_minus_divisor\n  iMODb_plus_minus", "lemma Suc_in_imp_not_subset_iMOD: \"\n  \\<lbrakk> n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> S \\<subseteq> [r, mod m]\"", "lemma Suc_in_imp_not_subset_iMODb: \"\n  \\<lbrakk> n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> S \\<subseteq> [r, mod m, c]\"", "lemma \n  iIN_iFROM_subset_same: \"[n\\<dots>,d] \\<subseteq> [n\\<dots>]\" and\n  iIN_iTILL_subset_same: \"[n\\<dots>,d] \\<subseteq> [\\<dots>n+d]\" and\n  iMOD_iFROM_subset_same: \"[r, mod m] \\<subseteq> [r\\<dots>]\" and\n  iMODb_iTILL_subset_same: \"[r, mod m, c] \\<subseteq> [\\<dots>r+m*c]\" and\n  iMODb_iIN_subset_same: \"[r, mod m, c] \\<subseteq> [r\\<dots>,m*c]\" and\n  iMODb_iMOD_subset_same: \"[r, mod m, c] \\<subseteq> [r, mod m]\"", "lemmas iT_subset_same = \n  iIN_iFROM_subset_same\n  iIN_iTILL_subset_same\n  iMOD_iFROM_subset_same\n  iMODb_iTILL_subset_same\n  iMODb_iIN_subset_same\n  iMODb_iTILL_subset_same\n  iMODb_iMOD_subset_same", "lemma iMODb_imp_iMOD: \"x \\<in> [r, mod m, c] \\<Longrightarrow> x \\<in> [r, mod m]\"", "lemma iMOD_imp_iMODb: \"\n  \\<lbrakk> x \\<in> [r, mod m]; x \\<le> r + m * c \\<rbrakk> \\<Longrightarrow> x \\<in> [r, mod m, c]\"", "lemma iMOD_singleton_subset_conv: \"([r, mod m] \\<subseteq> {a}) = (r = a \\<and> m = 0)\"", "lemma iMOD_singleton_eq_conv: \"([r, mod m] = {a}) = (r = a \\<and> m = 0)\"", "lemma iMODb_singleton_subset_conv: \"\n  ([r, mod m, c] \\<subseteq> {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))\"", "lemma iMODb_singleton_eq_conv: \"\n  ([r, mod m, c] = {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))\"", "lemma iMODb_subset_imp_divisor_mod_0: \"\n  \\<lbrakk> 0 < c'; [r', mod m', c'] \\<subseteq> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> m' mod m = 0\"", "lemma iMOD_subset_imp_divisor_mod_0: \"\n  [r', mod m'] \\<subseteq> [r, mod m] \\<Longrightarrow> m' mod m = 0\"", "lemma iMOD_subset_imp_iMODb_subset: \"\n  \\<lbrakk> [r', mod m'] \\<subseteq> [r, mod m]; r' + m' * c' \\<le> r + m * c \\<rbrakk> \\<Longrightarrow> \n  [r', mod m', c'] \\<subseteq> [r, mod m, c]\"", "lemma iMODb_subset_imp_iMOD_subset: \"\n  \\<lbrakk> [r', mod m', c'] \\<subseteq> [r, mod m, c]; 0 < c' \\<rbrakk> \\<Longrightarrow> \n  [r', mod m'] \\<subseteq> [r, mod m]\"", "lemma iMODb_0_iMOD_subset_conv: \"\n  ([r', mod m', 0] \\<subseteq> [r, mod m]) = \n  (r' mod m = r mod m \\<and> r \\<le> r')\"", "lemma iFROM_subset_conv: \"([n'\\<dots>] \\<subseteq> [n\\<dots>]) = (n \\<le> n')\"", "lemma iFROM_iMOD_subset_conv: \"([n'\\<dots>] \\<subseteq> [r, mod m]) = (r \\<le> n' \\<and> m = Suc 0)\"", "lemma iIN_subset_conv: \"([n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]) = (n \\<le> n' \\<and> n'+d' \\<le> n+d)\"", "lemma iIN_iFROM_subset_conv: \"([n'\\<dots>,d'] \\<subseteq> [n\\<dots>]) = (n \\<le> n')\"", "lemma iIN_iTILL_subset_conv: \"([n'\\<dots>,d'] \\<subseteq> [\\<dots>n]) = (n' + d' \\<le> n)\"", "lemma iIN_iMOD_subset_conv: \"\n  0 < d' \\<Longrightarrow> ([n'\\<dots>,d'] \\<subseteq> [r, mod m]) = (r \\<le> n' \\<and> m = Suc 0)\"", "lemma iIN_iMODb_subset_conv: \"\n  0 < d' \\<Longrightarrow> \n  ([n'\\<dots>,d'] \\<subseteq> [r, mod m, c]) = \n  (r \\<le> n' \\<and> m = Suc 0 \\<and> n' + d' \\<le> r + m * c)\"", "lemma iTILL_subset_conv: \"([\\<dots>n'] \\<subseteq> [\\<dots>n]) = (n' \\<le> n)\"", "lemma iTILL_iFROM_subset_conv: \"([\\<dots>n'] \\<subseteq> [n\\<dots>]) = (n = 0)\"", "lemma iTILL_iIN_subset_conv: \"([\\<dots>n'] \\<subseteq> [n\\<dots>,d]) = (n = 0 \\<and> n' \\<le> d)\"", "lemma iTILL_iMOD_subset_conv: \"\n  0 < n' \\<Longrightarrow> ([\\<dots>n'] \\<subseteq> [r, mod m]) = (r = 0 \\<and> m = Suc 0)\"", "lemma iTILL_iMODb_subset_conv: \"\n  0 < n' \\<Longrightarrow> ([\\<dots>n'] \\<subseteq> [r, mod m, c]) = (r = 0 \\<and> m = Suc 0 \\<and> n' \\<le> r + m * c)\"", "lemma iMOD_iFROM_subset_conv: \"([r', mod m']) \\<subseteq> [n\\<dots>] = (n \\<le> r')\"", "lemma iMODb_iFROM_subset_conv: \"([r', mod m', c'] \\<subseteq> [n\\<dots>]) = (n \\<le> r')\"", "lemma iMODb_iIN_subset_conv: \"\n  ([r', mod m', c'] \\<subseteq> [n\\<dots>,d]) = (n \\<le> r' \\<and> r' + m' * c' \\<le> n + d)\"", "lemma iMODb_iTILL_subset_conv: \"\n  ([r', mod m', c'] \\<subseteq> [\\<dots>n]) = (r' + m' * c' \\<le> n)\"", "lemma iMOD_0_subset_conv: \"([r', mod 0] \\<subseteq> [r, mod m]) = (r' mod m = r mod m  \\<and>  r \\<le> r')\"", "lemma iMOD_subset_conv: \"0 < m \\<Longrightarrow> \n  ([r', mod m'] \\<subseteq> [r, mod m]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0)\"", "lemma iMODb_subset_mod_0_conv: \"\n  ([r', mod m', c'] \\<subseteq> [r, mod 0, c ]) = (r'=r \\<and> (m'=0 \\<or> c'=0))\"", "lemma iMODb_subset_0_conv: \"\n  ([r', mod m', c'] \\<subseteq> [r, mod m, 0 ]) = (r'=r \\<and> (m'=0 \\<or> c'=0))\"", "lemma iMODb_0_subset_conv: \"\n  ([r', mod m', 0] \\<subseteq> [r, mod m, c ]) = (r' \\<in> [r, mod m, c])\"", "lemma iMODb_mod_0_subset_conv: \"\n  ([r', mod 0, c'] \\<subseteq> [r, mod m, c ]) = (r' \\<in> [r, mod m, c])\"", "lemma iMODb_subset_conv': \"\\<lbrakk> 0 < c; 0 < c' \\<rbrakk> \\<Longrightarrow> \n  ([r', mod m', c'] \\<subseteq> [r, mod m, c]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0  \\<and>\n   r' + m' * c' \\<le> r + m * c)\"", "lemma iMODb_subset_conv: \"\\<lbrakk> 0 < m'; 0 < c' \\<rbrakk> \\<Longrightarrow> \n  ([r', mod m', c'] \\<subseteq> [r, mod m, c]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0  \\<and>\n   r' + m' * c' \\<le> r + m * c)\"", "lemma iMODb_iMOD_subset_conv: \"0 < c' \\<Longrightarrow>\n  ([r', mod m', c'] \\<subseteq> [r, mod m]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0)\"", "lemmas iT_subset_conv =\n  iFROM_subset_conv\n  iFROM_iMOD_subset_conv\n  iTILL_subset_conv\n  iTILL_iFROM_subset_conv\n  iTILL_iIN_subset_conv\n  iTILL_iMOD_subset_conv\n  iTILL_iMODb_subset_conv\n  iIN_subset_conv\n  iIN_iFROM_subset_conv\n  iIN_iTILL_subset_conv\n  iIN_iMOD_subset_conv\n  iIN_iMODb_subset_conv\n  iMOD_subset_conv\n  iMOD_iFROM_subset_conv\n  iMODb_subset_conv'\n  iMODb_subset_conv\n  iMODb_iFROM_subset_conv\n  iMODb_iIN_subset_conv\n  iMODb_iTILL_subset_conv\n  iMODb_iMOD_subset_conv", "lemma iFROM_subset: \"n \\<le> n' \\<Longrightarrow> [n'\\<dots>] \\<subseteq> [n\\<dots>]\"", "lemma not_iFROM_iIN_subset: \"\\<not> [n'\\<dots>] \\<subseteq> [n\\<dots>,d]\"", "lemma not_iFROM_iTILL_subset: \"\\<not> [n'\\<dots>] \\<subseteq> [\\<dots>n]\"", "lemma not_iFROM_iMOD_subset: \"m \\<noteq> Suc 0 \\<Longrightarrow> \\<not> [n'\\<dots>] \\<subseteq> [r, mod m]\"", "lemma not_iFROM_iMODb_subset: \"\\<not> [n'\\<dots>] \\<subseteq> [r, mod m, c]\"", "lemma iIN_subset: \"\\<lbrakk> n \\<le> n'; n' + d' \\<le> n + d \\<rbrakk> \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]\"", "lemma iIN_iFROM_subset: \"n \\<le> n' \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [n\\<dots>]\"", "lemma iIN_iTILL_subset: \"n' + d' \\<le> n \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [\\<dots>n]\"", "lemma not_iIN_iMODb_subset: \"\\<lbrakk> 0 < d'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [n'\\<dots>,d'] \\<subseteq> [r, mod m, c]\"", "lemma not_iIN_iMOD_subset: \"\\<lbrakk> 0 < d'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [n'\\<dots>,d'] \\<subseteq> [r, mod m]\"", "lemma iTILL_subset: \"n' \\<le> n \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [\\<dots>n]\"", "lemma iTILL_iFROM_subset: \"([\\<dots>n'] \\<subseteq> [0\\<dots>])\"", "lemma iTILL_iIN_subset: \"n' \\<le> d \\<Longrightarrow> ([\\<dots>n'] \\<subseteq> [0\\<dots>,d])\"", "lemma not_iTILL_iMOD_subset: \"\n  \\<lbrakk> 0 < n'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [\\<dots>n'] \\<subseteq> [r, mod m]\"", "lemma not_iTILL_iMODb_subset: \"\n  \\<lbrakk> 0 < n'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [\\<dots>n'] \\<subseteq> [r, mod m, c]\"", "lemma iMOD_iFROM_subset: \"n \\<le> r' \\<Longrightarrow> [r', mod m'] \\<subseteq> [n\\<dots>]\"", "lemma not_iMOD_iIN_subset: \"0 < m' \\<Longrightarrow> \\<not> [r', mod m'] \\<subseteq> [n\\<dots>,d]\"", "lemma not_iMOD_iTILL_subset: \"0 < m' \\<Longrightarrow> \\<not> [r', mod m'] \\<subseteq> [\\<dots>n]\"", "lemma iMOD_subset: \"\n  \\<lbrakk> r \\<le> r'; r' mod m = r mod m; m' mod m = 0 \\<rbrakk> \\<Longrightarrow> [r', mod m'] \\<subseteq> [r, mod m]\"", "lemma not_iMOD_iMODb_subset: \"0 < m' \\<Longrightarrow> \\<not> [r', mod m'] \\<subseteq> [r, mod m, c]\"", "lemma iMODb_iFROM_subset: \"n \\<le> r' \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [n\\<dots>]\"", "lemma iMODb_iTILL_subset: \"\n  r' + m' * c' \\<le> n \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [\\<dots>n]\"", "lemma iMODb_iIN_subset: \"\n  \\<lbrakk> n \\<le> r'; r' + m' * c' \\<le> n + d \\<rbrakk> \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [n\\<dots>,d]\"", "lemma iMODb_iMOD_subset: \"\n  \\<lbrakk> r \\<le> r'; r' mod m = r mod m; m' mod m = 0 \\<rbrakk> \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [r, mod m]\"", "lemma iMODb_subset: \"\n  \\<lbrakk> r \\<le> r'; r' mod m = r mod m; m' mod m = 0; r' + m' * c' \\<le> r + m * c \\<rbrakk> \\<Longrightarrow> \n  [r', mod m', c'] \\<subseteq> [r, mod m, c]\"", "lemma iFROM_trans: \"\\<lbrakk> y \\<in> [x\\<dots>]; z \\<in> [y\\<dots>] \\<rbrakk> \\<Longrightarrow> z \\<in> [x\\<dots>]\"", "lemma iTILL_trans: \"\\<lbrakk> y \\<in> [\\<dots>x]; z \\<in> [\\<dots>y] \\<rbrakk> \\<Longrightarrow> z \\<in> [\\<dots>x]\"", "lemma iIN_trans: \"\n  \\<lbrakk> y \\<in> [x\\<dots>,d]; z \\<in> [y\\<dots>,d']; d' \\<le> x + d - y \\<rbrakk> \\<Longrightarrow> z \\<in> [x\\<dots>,d]\"", "lemma iMOD_trans: \"\n  \\<lbrakk> y \\<in> [x, mod m]; z \\<in> [y, mod m] \\<rbrakk> \\<Longrightarrow> z \\<in> [x, mod m]\"", "lemma iMODb_trans: \"\n  \\<lbrakk> y \\<in> [x, mod m, c]; z \\<in> [y, mod m, c']; m * c' \\<le> x + m * c - y \\<rbrakk> \\<Longrightarrow> \n  z \\<in> [x, mod m, c]\"", "lemma iMODb_trans': \"\n  \\<lbrakk> y \\<in> [x, mod m, c]; z \\<in> [y, mod m, c']; c' \\<le> x div m + c - y div m \\<rbrakk> \\<Longrightarrow> \n  z \\<in> [x, mod m, c]\"", "lemma iFROM_eq_conv: \"([n\\<dots>] = [n'\\<dots>]) = (n = n')\"", "lemma iIN_eq_conv: \"([n\\<dots>,d] = [n'\\<dots>,d']) = (n = n' \\<and> d = d')\"", "lemma iTILL_eq_conv: \"([\\<dots>n] = [\\<dots>n']) = (n = n')\"", "lemma iMOD_0_eq_conv: \"([r, mod 0] = [r', mod m']) = (r = r' \\<and> m' = 0)\"", "lemma iMOD_eq_conv: \"0 < m \\<Longrightarrow> ([r, mod m] = [r', mod m']) = (r = r' \\<and> m = m')\"", "lemma iMODb_mod_0_eq_conv: \"\n  ([r, mod 0, c] = [r', mod m', c']) = (r = r' \\<and> (m' = 0 \\<or> c' = 0))\"", "lemma iMODb_0_eq_conv: \"\n  ([r, mod m, 0] = [r', mod m', c']) = (r = r' \\<and> (m' = 0 \\<or> c' = 0))\"", "lemma iMODb_eq_conv: \"\\<lbrakk> 0 < m; 0 < c \\<rbrakk> \\<Longrightarrow> \n  ([r, mod m, c] = [r', mod m', c']) = (r = r' \\<and> m = m' \\<and> c = c')\"", "lemma iMOD_iFROM_eq_conv: \"([n\\<dots>] = [r, mod m]) = (n = r \\<and> m = Suc 0)\"", "lemma iMODb_iIN_0_eq_conv: \"\n  ([n\\<dots>,0] = [r, mod m, c]) = (n = r \\<and> (m = 0 \\<or> c = 0))\"", "lemma iMODb_iIN_eq_conv: \"\n  0 < d \\<Longrightarrow> ([n\\<dots>,d] = [r, mod m, c]) = (n = r \\<and> m = Suc 0 \\<and> c = d)\"", "lemma iFROM_iIN_neq: \"[n'\\<dots>] \\<noteq> [n\\<dots>,d]\"", "lemma iIN_iMODb_neq: \"\\<lbrakk> 2 \\<le> m; 0 < c \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [r, mod m, c]\"", "lemma iTILL_iIN_neq: \"0 < n \\<Longrightarrow> [\\<dots>n'] \\<noteq> [n\\<dots>,d]\"", "lemma iMOD_iMODb_neq: \"0 < m \\<Longrightarrow> [r, mod m] \\<noteq> [r', mod m', c']\"", "lemmas iT_neq = \n  iFROM_iTILL_neq iFROM_iIN_neq iFROM_iMOD_neq iFROM_iMODb_neq\n  iTILL_iIN_neq iTILL_iMOD_neq iTILL_iMODb_neq\n  iIN_iMOD_neq  iIN_iMODb_neq iIN_iMODb_neq2\n  iMOD_iMODb_neq", "lemma iFROM_union': \"[n\\<dots>] \\<union> [n'\\<dots>] = [min n n'\\<dots>]\"", "lemma iFROM_inter': \"[n\\<dots>] \\<inter> [n'\\<dots>] = [max n n'\\<dots>]\"", "lemma iTILL_union': \"[\\<dots>n] \\<union> [\\<dots>n'] = [\\<dots>max n n']\"", "lemma iTILL_iFROM_union: \"n \\<le> n' \\<Longrightarrow> [\\<dots>n'] \\<union> [n\\<dots>] = UNIV\"", "lemma iTILL_inter': \"[\\<dots>n] \\<inter> [\\<dots>n'] = [\\<dots>min n n']\"", "lemma iIN_union: \"\n  \\<lbrakk> n \\<le> n'; n' \\<le> Suc (n + d); n + d \\<le> n' + d' \\<rbrakk> \\<Longrightarrow> \n  [n\\<dots>,d] \\<union> [n'\\<dots>,d'] = [n\\<dots>,n' - n + d'] \"", "lemma iIN_append_union: \"\n  [n\\<dots>,d] \\<union> [n + d\\<dots>,d'] = [n\\<dots>,d + d']\"", "lemma iIN_append_union_Suc: \"\n  [n\\<dots>,d] \\<union> [Suc (n + d)\\<dots>,d'] = [n\\<dots>,Suc (d + d')]\"", "lemma iIN_append_union_pred: \"\n  0 < d \\<Longrightarrow> [n\\<dots>,d - Suc 0] \\<union> [n + d\\<dots>,d'] = [n\\<dots>,d + d']\"", "lemma iIN_iFROM_union: \"\n  n' \\<le> Suc (n + d) \\<Longrightarrow> [n\\<dots>,d] \\<union> [n'\\<dots>] = [min n n'\\<dots>]\"", "lemma iIN_iFROM_append_union: \"\n  [n\\<dots>,d] \\<union> [n + d\\<dots>] = [n\\<dots>]\"", "lemma iIN_iFROM_append_union_Suc: \"\n  [n\\<dots>,d] \\<union> [Suc (n + d)\\<dots>] = [n\\<dots>]\"", "lemma iIN_iFROM_append_union_pred: \"\n  0 < d \\<Longrightarrow> [n\\<dots>,d - Suc 0] \\<union> [n + d\\<dots>] = [n\\<dots>]\"", "lemma iIN_inter: \"\n  \\<lbrakk> n \\<le> n'; n' \\<le> n + d; n + d \\<le> n' + d' \\<rbrakk> \\<Longrightarrow>\n  [n\\<dots>,d] \\<inter> [n'\\<dots>,d'] = [n'\\<dots>,n + d - n']\"", "lemma iMOD_union: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m \\<rbrakk> \\<Longrightarrow>\n  [r, mod m] \\<union> [r', mod m] = [r, mod m]\"", "lemma iMOD_union': \"\n  r mod m = r' mod m \\<Longrightarrow>\n  [r, mod m] \\<union> [r', mod m] = [min r r', mod m]\"", "lemma iMOD_inter: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m \\<rbrakk> \\<Longrightarrow>\n  [r, mod m] \\<inter> [r', mod m] = [r', mod m]\"", "lemma iMOD_inter': \"\n  r mod m = r' mod m \\<Longrightarrow> \n  [r, mod m] \\<inter> [r', mod m] = [max r r', mod m]\"", "lemma iMODb_union: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c; r + m * c \\<le> r' + m * c' \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<union> [r', mod m, c'] = [r, mod m, r' div m - r div m + c']\"", "lemma iMODb_append_union: \"\n  [r, mod m, c] \\<union> [ r + m * c, mod m, c'] = [r, mod m, c + c']\"", "lemma iMODb_iMOD_append_union': \"\n  \\<lbrakk> r mod m = r' mod m; r' \\<le> r + m * Suc c \\<rbrakk>  \\<Longrightarrow> \n  [r, mod m, c] \\<union> [ r', mod m ] = [min r r', mod m]\"", "lemma iMODb_iMOD_append_union: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * Suc c \\<rbrakk>  \\<Longrightarrow> \n  [r, mod m, c] \\<union> [ r', mod m ] = [r, mod m]\"", "lemma iMODb_append_union_Suc: \"\n  [r, mod m, c] \\<union> [ r + m * Suc c, mod m, c'] = [r, mod m, Suc (c + c')]\"", "lemma iMODb_append_union_pred: \"\n  0 < c \\<Longrightarrow> [r, mod m, c - Suc 0] \\<union> [ r + m * c, mod m, c'] = [r, mod m, c + c']\"", "lemma iMODb_inter: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c; r + m * c \\<le> r' + m * c' \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<inter> [r', mod m, c'] = [r', mod m, c - (r'-r) div m]\"", "lemmas iT_union' = \n  iFROM_union'\n  iTILL_union'\n  iMOD_union'\n  iMODb_iMOD_append_union'", "lemmas iT_union =\n  iFROM_union\n  iTILL_union\n  iTILL_iFROM_union\n  iIN_union\n  iIN_iFROM_union\n  iMOD_union\n  iMODb_union", "lemmas iT_union_append =\n  iIN_append_union\n  iIN_append_union_Suc\n  iIN_append_union_pred\n  iIN_iFROM_append_union\n  iIN_iFROM_append_union_Suc\n  iIN_iFROM_append_union_pred\n  iMODb_append_union\n  iMODb_iMOD_append_union\n  iMODb_append_union_Suc\n  iMODb_append_union_pred", "lemmas iT_inter' =\n  iFROM_inter'\n  iTILL_inter'\n  iMOD_inter'", "lemmas iT_inter =\n  iFROM_inter\n  iTILL_inter\n  iIN_inter\n  iMOD_inter\n  iMODb_inter", "lemma mod_partition_Union: \"\n  0 < m \\<Longrightarrow> (\\<Union>k. A \\<inter> [k * m\\<dots>,m - Suc 0]) = A\"", "lemma finite_mod_partition_Union: \"\n  \\<lbrakk> 0 < m; finite A \\<rbrakk> \\<Longrightarrow>\n  (\\<Union>k\\<le>Max A div m. A \\<inter> [k*m\\<dots>,m - Suc 0]) = A\"", "lemma mod_partition_is_disjoint: \"\n  \\<lbrakk> 0 < (m::nat); k \\<noteq> k' \\<rbrakk> \\<Longrightarrow> \n  (A \\<inter> [k * m\\<dots>,m - Suc 0]) \\<inter>  (A \\<inter> [k' * m\\<dots>,m - Suc 0]) = {}\"", "lemma iTILL_cut_le: \"[\\<dots>n] \\<down>\\<le> t = (if t \\<le> n then [\\<dots>t] else [\\<dots>n])\"", "lemma iFROM_cut_le: \"\n  [n\\<dots>] \\<down>\\<le> t = \n  (if t < n then {} else [n\\<dots>,t-n])\"", "lemma iIN_cut_le: \"\n  [n\\<dots>,d] \\<down>\\<le> t = (\n  if t < n then {} else \n  if t \\<le> n+d then [n\\<dots>,t-n]\n  else [n\\<dots>,d])\"", "lemma iMOD_cut_le: \"\n  [r, mod m] \\<down>\\<le> t = (\n  if t < r then {} \n  else [r, mod m, (t - r) div m])\"", "lemma iMOD_cut_le1: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> \n  [r, mod m] \\<down>\\<le> t = [r, mod m, (t - r) div m]\"", "lemma iMODb_cut_le: \"\n  [r, mod m, c] \\<down>\\<le> t = (\n    if t < r then {} \n    else if t < r + m * c then [r, mod m, (t - r) div m]\n    else [r, mod m, c])\"", "lemma iMODb_cut_le1: \"\n  t \\<in> [r, mod m, c] \\<Longrightarrow> \n  [r, mod m, c] \\<down>\\<le> t = [r, mod m, (t - r) div m]\"", "lemma iTILL_cut_less: \"\n  [\\<dots>n] \\<down>< t = (\n    if n < t then [\\<dots>n] else\n    if t = 0 then {} \n    else [\\<dots>t - Suc 0])\"", "lemma iTILL_cut_less1: \"\n  \\<lbrakk> t \\<in> [\\<dots>n]; 0 < t \\<rbrakk> \\<Longrightarrow> [\\<dots>n] \\<down>< t = [\\<dots>t - Suc 0]\"", "lemma iFROM_cut_less: \"\n  [n\\<dots>] \\<down>< t = (\n    if t \\<le> n then {}\n    else [n\\<dots>,t - Suc n])\"", "lemma iFROM_cut_less1: \"\n  n < t \\<Longrightarrow> [n\\<dots>] \\<down>< t = [n\\<dots>,t - Suc n]\"", "lemma iIN_cut_less: \"\n  [n\\<dots>,d] \\<down>< t = ( \n    if t \\<le> n then {} else\n    if t \\<le> n + d then [n\\<dots>, t - Suc n]\n    else [n\\<dots>,d])\"", "lemma iIN_cut_less1: \"\n  \\<lbrakk> t \\<in> [n\\<dots>,d]; n < t \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<down>< t = [n\\<dots>, t - Suc n]\"", "lemma iMOD_cut_less: \"\n  [r, mod m] \\<down>< t = (\n    if t \\<le> r then {} \n    else [r, mod m, (t - Suc r) div m])\"", "lemma iMOD_cut_less1: \"\n  \\<lbrakk> t \\<in> [r, mod m]; r < t \\<rbrakk> \\<Longrightarrow> \n  [r, mod m] \\<down>< t = [r, mod m, (t - r) div m - Suc 0]\"", "lemma iMODb_cut_less: \"\n  [r, mod m, c] \\<down>< t = (\n    if t \\<le> r then {} else\n    if r + m * c < t then [r, mod m, c]\n    else [r, mod m, (t - Suc r) div m])\"", "lemma iMODb_cut_less1: \"\\<lbrakk> t \\<in> [r, mod m, c]; r < t \\<rbrakk> \\<Longrightarrow> \n  [r, mod m, c] \\<down>< t = [r, mod m, (t - r) div m - Suc 0]\"", "lemmas iT_cut_le =\n  iTILL_cut_le\n  iFROM_cut_le\n  iIN_cut_le\n  iMOD_cut_le\n  iMODb_cut_le", "lemmas iT_cut_le1 =\n  iTILL_cut_le1\n  iFROM_cut_le1\n  iIN_cut_le1\n  iMOD_cut_le1\n  iMODb_cut_le1", "lemmas iT_cut_less =\n  iTILL_cut_less\n  iFROM_cut_less\n  iIN_cut_less\n  iMOD_cut_less\n  iMODb_cut_less", "lemmas iT_cut_less1 =\n  iTILL_cut_less1\n  iFROM_cut_less1\n  iIN_cut_less1\n  iMOD_cut_less1\n  iMODb_cut_less1", "lemmas iT_cut_le_less =\n  iTILL_cut_le\n  iTILL_cut_less\n  iFROM_cut_le\n  iFROM_cut_less\n  iIN_cut_le\n  iIN_cut_less\n  iMOD_cut_le\n  iMOD_cut_less\n  iMODb_cut_le\n  iMODb_cut_less", "lemmas iT_cut_le_less1 =\n  iTILL_cut_le1\n  iTILL_cut_less1\n  iFROM_cut_le1\n  iFROM_cut_less1\n  iIN_cut_le1\n  iIN_cut_less1\n  iMOD_cut_le1\n  iMOD_cut_less1\n  iMODb_cut_le1\n  iMODb_cut_less1", "lemma iTILL_cut_ge: \"\n  [\\<dots>n] \\<down>\\<ge> t = (if n < t then {} else [t\\<dots>,n-t])\"", "lemma iTILL_cut_greater: \"\n  [\\<dots>n] \\<down>> t = (if n \\<le> t then {} else [Suc t\\<dots>,n - Suc t])\"", "lemma iFROM_cut_ge: \"\n  [n\\<dots>] \\<down>\\<ge> t = (if n \\<le> t then [t\\<dots>] else [n\\<dots>])\"", "lemma iFROM_cut_greater: \"\n  [n\\<dots>] \\<down>> t = (if n \\<le> t then [Suc t\\<dots>] else [n\\<dots>])\"", "lemma iIN_cut_ge: \"\n  [n\\<dots>,d] \\<down>\\<ge> t = (\n    if t < n then [n\\<dots>,d] else \n    if t \\<le> n+d then [t\\<dots>,n+d-t]\n    else {})\"", "lemma iIN_cut_greater: \"\n  [n\\<dots>,d] \\<down>> t = (\n    if t < n then [n\\<dots>,d] else \n    if t < n+d then [Suc t\\<dots>,n + d - Suc t]\n    else {})\"", "lemma mod_cut_greater_aux_t_less: \"\n  \\<lbrakk> 0 < (m::nat); r \\<le> t \\<rbrakk> \\<Longrightarrow> \n  t < t + m - (t - r) mod m\"", "lemma mod_cut_greater_aux_le_x: \"\n  \\<lbrakk> (r::nat) \\<le> t; t < x; x mod m = r mod m\\<rbrakk> \\<Longrightarrow> \n  t + m - (t - r) mod m \\<le> x\"", "lemma iMOD_cut_greater: \"\n  [r, mod m] \\<down>> t = (\n    if t < r then [r, mod m] else\n    if m = 0 then {}\n    else [t + m - (t - r) mod m, mod m])\"", "lemma iMOD_cut_greater1: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> \n  [r, mod m] \\<down>> t = (\n    if m = 0 then {}\n    else [t + m, mod m])\"", "lemma iMODb_cut_greater_aux: \"\n  \\<lbrakk> 0 < m; t < r + m * c; r \\<le> t\\<rbrakk> \\<Longrightarrow> \n  (r + m * c - (t + m - (t - r) mod m)) div m =\n  c - Suc ((t - r) div m)\"", "lemma iMODb_cut_greater: \"\n  [r, mod m, c] \\<down>> t = (\n    if t < r then [r, mod m, c] else\n    if r + m * c \\<le> t then {}\n    else [t + m - (t - r) mod m, mod m, c - Suc ((t-r) div m)])\"", "lemma iMODb_cut_greater1: \"\n  t \\<in> [r, mod m, c] \\<Longrightarrow> \n    [r, mod m, c] \\<down>> t = (\n    if r + m * c \\<le> t then {}\n    else [t + m, mod m, c - Suc ((t-r) div m)])\"", "lemma iMOD_cut_ge: \"\n  [r, mod m] \\<down>\\<ge> t = (\n    if t \\<le> r then [r, mod m] else\n    if m = 0 then {} \n    else [t + m - Suc ((t - Suc r) mod m), mod m])\"", "lemma iMOD_cut_ge1: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> \n  [r, mod m] \\<down>\\<ge> t = [t, mod m]\"", "lemma iMODb_cut_ge: \"\n  [r, mod m, c] \\<down>\\<ge> t = (\n    if t \\<le> r then [r, mod m, c] else\n    if r + m * c < t then {} \n    else [t + m - Suc ((t - Suc r) mod m), mod m, c - (t + m - Suc r) div m])\"", "lemma iMODb_cut_ge1: \"\n  t \\<in> [r, mod m, c] \\<Longrightarrow>\n  [r, mod m, c] \\<down>\\<ge> t = (\n    if r + m * c < t then {} \n    else [t, mod m, c - (t - r) div m])\"", "lemma iMOD_0_cut_greater: \"\n  t \\<in> [r, mod 0] \\<Longrightarrow> [r, mod 0] \\<down>> t = {}\"", "lemma iMODb_0_cut_greater: \"t \\<in> [r, mod 0, c] \\<Longrightarrow>\n  [r, mod 0, c] \\<down>> t = {}\"", "lemmas iT_cut_ge =\n  iTILL_cut_ge\n  iFROM_cut_ge\n  iIN_cut_ge\n  iMOD_cut_ge\n  iMODb_cut_ge", "lemmas iT_cut_ge1 =\n  iTILL_cut_ge1\n  iFROM_cut_ge1\n  iIN_cut_ge1\n  iMOD_cut_ge1\n  iMODb_cut_ge1", "lemmas iT_cut_greater =\n  iTILL_cut_greater\n  iFROM_cut_greater\n  iIN_cut_greater\n  iMOD_cut_greater\n  iMODb_cut_greater", "lemmas iT_cut_greater1 =\n  iTILL_cut_greater1\n  iFROM_cut_greater1\n  iIN_cut_greater1\n  iMOD_cut_greater1\n  iMODb_cut_greater1", "lemmas iT_cut_ge_greater =\n  iTILL_cut_ge\n  iTILL_cut_greater\n  iFROM_cut_ge\n  iFROM_cut_greater\n  iIN_cut_ge\n  iIN_cut_greater\n  iMOD_cut_ge\n  iMOD_cut_greater\n  iMODb_cut_ge\n  iMODb_cut_greater", "lemmas iT_cut_ge_greater1 =\n  iTILL_cut_ge1\n  iTILL_cut_greater1\n  iFROM_cut_ge1\n  iFROM_cut_greater1\n  iIN_cut_ge1\n  iIN_cut_greater1\n  iMOD_cut_ge1\n  iMOD_cut_greater1\n  iMODb_cut_ge1\n  iMODb_cut_greater1", "lemma iFROM_card: \"card [n\\<dots>] = 0\"", "lemma iTILL_card: \"card [\\<dots>n] = Suc n\"", "lemma iIN_card: \"card [n\\<dots>,d] = Suc d\"", "lemma iMOD_0_card: \"card [r, mod 0] = Suc 0\"", "lemma iMOD_card: \"0 < m \\<Longrightarrow> card [r, mod m] = 0\"", "lemma iMOD_card_if: \"card [r, mod m] = (if m = 0 then Suc 0 else 0)\"", "lemma iMODb_mod_0_card: \"card [r, mod 0, c] = Suc 0\"", "lemma iMODb_card: \"0 < m \\<Longrightarrow> card [r, mod m, c] = Suc c\"", "lemma iMODb_card_if: \"\n  card [r, mod m, c] = (if m = 0 then Suc 0 else Suc c)\"", "lemmas iT_card =\n  iFROM_card\n  iTILL_card\n  iIN_card\n  iMOD_card_if\n  iMODb_card_if", "lemma iFROM_icard: \"icard [n\\<dots>] = \\<infinity>\"", "lemma iTILL_icard: \"icard [\\<dots>n] = enat (Suc n)\"", "lemma iIN_icard: \"icard [n\\<dots>,d] = enat (Suc d)\"", "lemma iMOD_0_icard: \"icard [r, mod 0] = eSuc 0\"", "lemma iMOD_icard: \"0 < m \\<Longrightarrow> icard [r, mod m] = \\<infinity>\"", "lemma iMOD_icard_if: \"icard [r, mod m] = (if m = 0 then eSuc 0 else \\<infinity>)\"", "lemma iMODb_mod_0_icard: \"icard [r, mod 0, c] = eSuc 0\"", "lemma iMODb_icard: \"0 < m \\<Longrightarrow> icard [r, mod m, c] = enat (Suc c)\"", "lemma iMODb_icard_if: \"icard [r, mod m, c] = enat (if m = 0 then Suc 0 else Suc c)\"", "lemmas iT_icard =\n  iFROM_icard\n  iTILL_icard\n  iIN_icard\n  iMOD_icard_if\n  iMODb_icard_if", "lemma \n  iFROM_inext: \"t \\<in> [n\\<dots>] \\<Longrightarrow> inext t [n\\<dots>] = Suc t\" and\n  iTILL_inext: \"t < n \\<Longrightarrow> inext t [\\<dots>n] = Suc t\" and\n  iIN_inext: \"\\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> inext t [n\\<dots>,d] = Suc t\"", "lemma \n  iFROM_iprev': \"t \\<in> [n\\<dots>] \\<Longrightarrow> iprev (Suc t) [n\\<dots>] = t\" and\n  iFROM_iprev: \"n < t  \\<Longrightarrow> iprev t [n\\<dots>] = t - Suc 0\" and\n  iTILL_iprev: \"t \\<in> [\\<dots>n] \\<Longrightarrow> iprev t [\\<dots>n] = t - Suc 0\" and\n  iIN_iprev: \"\\<lbrakk> n < t; t \\<le> n + d \\<rbrakk> \\<Longrightarrow> iprev t [n\\<dots>,d] = t - Suc 0\" and\n  iIN_iprev': \"\\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> iprev (Suc t) [n\\<dots>,d] = t\"", "lemma iMOD_inext: \"t \\<in> [r, mod m] \\<Longrightarrow> inext t [r, mod m] = t + m\"", "lemma iMOD_iprev: \"\\<lbrakk> t \\<in> [r, mod m]; r < t \\<rbrakk> \\<Longrightarrow> iprev t [r, mod m] = t - m\"", "lemma iMOD_iprev': \"t \\<in> [r, mod m] \\<Longrightarrow> iprev (t + m) [r, mod m] = t\"", "lemma iMODb_inext: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> \n  inext t [r, mod m, c] = t + m\"", "lemma iMODb_iprev: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; r < t \\<rbrakk> \\<Longrightarrow> \n  iprev t [r, mod m, c] = t - m\"", "lemma iMODb_iprev': \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> \n  iprev (t + m) [r, mod m, c] = t\"", "lemmas iT_inext =\n  iFROM_inext\n  iTILL_inext\n  iIN_inext\n  iMOD_inext\n  iMODb_inext", "lemmas iT_iprev =\n  iFROM_iprev'\n  iFROM_iprev\n  iTILL_iprev\n  iIN_iprev\n  iIN_iprev'\n  iMOD_iprev\n  iMOD_iprev'\n  iMODb_iprev\n  iMODb_iprev'", "lemma iFROM_inext_if: \"\n  inext t [n\\<dots>] = (if t \\<in> [n\\<dots>] then Suc t else t)\"", "lemma iTILL_inext_if: \"\n  inext t [\\<dots>n] = (if t < n then Suc t else t)\"", "lemma iIN_inext_if: \"\n  inext t [n\\<dots>,d] = (if n \\<le> t \\<and> t < n + d then Suc t else t)\"", "lemma iMOD_inext_if: \"\n  inext t [r, mod m] = (if t \\<in> [r, mod m] then t + m else t)\"", "lemma iMODb_inext_if: \"\n  inext t [r, mod m, c] = \n  (if t \\<in> [r, mod m, c] \\<and> t < r + m * c then t + m else t)\"", "lemmas iT_inext_if =\n  iFROM_inext_if\n  iTILL_inext_if\n  iIN_inext_if\n  iMOD_inext_if\n  iMODb_inext_if", "lemma iFROM_iprev_if: \"\n  iprev t [n\\<dots>] = (if n < t then t - Suc 0 else t)\"", "lemma iTILL_iprev_if: \"\n  iprev t [\\<dots>n] = (if t \\<in> [\\<dots>n] then t - Suc 0 else t)\"", "lemma iIN_iprev_if: \"\n  iprev t [n\\<dots>,d] = (if n < t \\<and> t \\<le> n + d  then t - Suc 0 else t)\"", "lemma iMOD_iprev_if: \"\n  iprev t [r, mod m] = \n  (if t \\<in> [r, mod m] \\<and> r < t then t - m else t)\"", "lemma iMODb_iprev_if: \"\n  iprev t [r, mod m, c] = \n  (if t \\<in> [r, mod m, c] \\<and> r < t then t - m else t)\"", "lemmas iT_iprev_if =\n  iFROM_iprev_if\n  iTILL_iprev_if\n  iIN_iprev_if\n  iMOD_iprev_if\n  iMODb_iprev_if", "lemma iFROM_inext_diff_const: \"\n  t \\<in> [n\\<dots>] \\<Longrightarrow> inext t [n\\<dots>] - t = Suc 0\"", "lemma iFROM_iprev_diff_const: \"\n  n < t \\<Longrightarrow> t - iprev t [n\\<dots>] = Suc 0\"", "lemma iFROM_iprev_diff_const': \"\n  t \\<in> [n\\<dots>] \\<Longrightarrow> Suc t - iprev (Suc t) [n\\<dots>] = Suc 0\"", "lemma iTILL_inext_diff_const: \"\n  t < n \\<Longrightarrow> inext t [\\<dots>n] - t = Suc 0\"", "lemma iTILL_iprev_diff_const: \"\n  \\<lbrakk> t \\<in> [\\<dots>n]; 0 < t \\<rbrakk> \\<Longrightarrow> t - iprev t [\\<dots>n] = Suc 0\"", "lemma iIN_inext_diff_const: \"\n  \\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> inext t [n\\<dots>,d] - t = Suc 0\"", "lemma iIN_iprev_diff_const: \"\n  \\<lbrakk> n < t; t \\<le> n + d \\<rbrakk> \\<Longrightarrow> t - iprev t [n\\<dots>,d] = Suc 0\"", "lemma iIN_iprev_diff_const': \"\n  \\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> Suc t - iprev (Suc t) [n\\<dots>,d] = Suc 0\"", "lemma iMOD_inext_diff_const: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> inext t [r, mod m] - t = m\"", "lemma iMOD_iprev_diff_const': \"\n  t \\<in> [r, mod m] \\<Longrightarrow> (t + m) - iprev (t + m) [r, mod m] = m\"", "lemma iMOD_iprev_diff_const: \"\n  \\<lbrakk> t \\<in> [r, mod m]; r < t \\<rbrakk> \\<Longrightarrow> t - iprev t [r, mod m] = m\"", "lemma iMODb_inext_diff_const: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> inext t [r, mod m, c] - t = m\"", "lemma iMODb_iprev_diff_const': \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> (t + m) - iprev (t + m) [r, mod m, c] = m\"", "lemma iMODb_iprev_diff_const: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; r < t \\<rbrakk> \\<Longrightarrow> t - iprev t [r, mod m, c] = m\"", "lemmas iT_inext_diff_const =\n  iFROM_inext_diff_const\n  iTILL_inext_diff_const\n  iIN_inext_diff_const\n  iMOD_inext_diff_const\n  iMODb_inext_diff_const", "lemmas iT_iprev_diff_const =\n  iFROM_iprev_diff_const\n  iFROM_iprev_diff_const'\n  iTILL_iprev_diff_const\n  iIN_iprev_diff_const\n  iIN_iprev_diff_const'\n  iMOD_iprev_diff_const'\n  iMOD_iprev_diff_const\n  iMODb_iprev_diff_const'\n  iMODb_iprev_diff_const", "lemma \n  iIN_mirror_elem: \"mirror_elem x [n\\<dots>,d] = n + n + d - x\" and\n  iTILL_mirror_elem: \"mirror_elem x [\\<dots>n] = n - x\" and\n  iMODb_mirror_elem: \"mirror_elem x [r, mod m, c] = r + r + m * c - x\"", "lemma iMODb_imirror_bounds: \"\n  r' + m' * c' \\<le> l + r \\<Longrightarrow> \n  imirror_bounds [r', mod m', c'] l r = [l + r - r' - m' * c', mod m', c']\"", "lemma iIN_imirror_bounds: \"\n  n + d \\<le> l + r \\<Longrightarrow> imirror_bounds [n\\<dots>,d] l r = [l + r - n - d\\<dots>,d]\"", "lemma iTILL_imirror_bounds: \"\n  n \\<le> l + r \\<Longrightarrow> imirror_bounds [\\<dots>n] l r = [l + r - n\\<dots>,n]\"", "lemmas iT_imirror_bounds =\n  iTILL_imirror_bounds\n  iIN_imirror_bounds\n  iMODb_imirror_bounds", "lemma iMODb_imirror_ident: \"imirror [r, mod m, c] = [r, mod m, c]\"", "lemma iIN_imirror_ident: \"imirror [n\\<dots>,d] = [n\\<dots>,d]\"", "lemma iTILL_imirror_ident: \"imirror [\\<dots>n] = [\\<dots>n]\"", "lemmas iT_imirror_ident =\n  iTILL_imirror_ident\n  iIN_imirror_ident\n  iMODb_imirror_ident", "lemma iFROM_inext_nth : \"[n\\<dots>] \\<rightarrow> a = n + a\"", "lemma iIN_inext_nth : \"a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<rightarrow> a = n + a\"", "lemma iIN_iprev_nth: \"a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<leftarrow> a = n + d - a\"", "lemma iIN_inext_nth_if : \"\n  [n\\<dots>,d] \\<rightarrow> a = (if a \\<le> d then n + a else n + d)\"", "lemma iIN_iprev_nth_if: \"\n  [n\\<dots>,d] \\<leftarrow> a = (if a \\<le> d then n + d - a else n)\"", "lemma iTILL_inext_nth : \"a \\<le> n \\<Longrightarrow> [\\<dots>n] \\<rightarrow> a = a\"", "lemma iTILL_inext_nth_if : \"\n  [\\<dots>n] \\<rightarrow> a = (if a \\<le> n then a else n)\"", "lemma iTILL_iprev_nth: \"a \\<le> n \\<Longrightarrow> [\\<dots>n] \\<leftarrow> a = n - a\"", "lemma iTILL_iprev_nth_if: \"\n  [\\<dots>n] \\<leftarrow> a= (if a \\<le> n then n - a else 0)\"", "lemma iMOD_inext_nth: \"[r, mod m] \\<rightarrow> a = r + m * a\"", "lemma iMODb_inext_nth: \"a \\<le> c \\<Longrightarrow> [r, mod m, c] \\<rightarrow> a = r + m * a\"", "lemma iMODb_inext_nth_if: \"\n  [r, mod m, c] \\<rightarrow> a = (if a \\<le> c then r + m * a else r + m * c)\"", "lemma iMODb_iprev_nth: \"\n  a \\<le> c \\<Longrightarrow> [r, mod m, c] \\<leftarrow> a = r + m * (c - a)\"", "lemma iMODb_iprev_nth_if: \"\n  [r, mod m, c] \\<leftarrow> a = (if a \\<le> c then r + m * (c - a) else r)\"", "lemma iIN_iFROM_inext_nth: \"\n  a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<rightarrow> a = [n\\<dots>] \\<rightarrow> a\"", "lemma iIN_iFROM_inext: \"\n  a < n + d \\<Longrightarrow> inext a [n\\<dots>,d] = inext a [n\\<dots>]\"", "lemma iMOD_iMODb_inext_nth: \"\n  a \\<le> c \\<Longrightarrow> [r, mod m, c] \\<rightarrow> a = [r, mod m] \\<rightarrow> a\"", "lemma iMOD_iMODb_inext: \"\n  a < r + m * c \\<Longrightarrow> inext a [r, mod m, c] = inext a [r, mod m]\"", "lemma iMOD_inext_nth_Suc_diff: \"\n  ([r, mod m] \\<rightarrow> (Suc n)) - ([r, mod m] \\<rightarrow> n) = m\"", "lemma iMOD_inext_nth_diff: \"\n  ([r, mod m] \\<rightarrow> a) - ([r, mod m] \\<rightarrow> b) = (a - b) * m\"", "lemma iMODb_inext_nth_diff: \"\\<lbrakk> a \\<le> c; b \\<le> c \\<rbrakk> \\<Longrightarrow>\n  ([r, mod m, c] \\<rightarrow> a) - ([r, mod m, c] \\<rightarrow> b) = (a - b) * m\"", "lemma iFROM_induct: \"\n  \\<lbrakk> P n; \\<And>k. \\<lbrakk> k \\<in> [n\\<dots>]; P k \\<rbrakk> \\<Longrightarrow> P (Suc k); a \\<in> [n\\<dots>] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iIN_induct: \"\n  \\<lbrakk> P n; \\<And>k. \\<lbrakk> k \\<in> [n\\<dots>,d]; k \\<noteq> n + d; P k \\<rbrakk> \\<Longrightarrow> P (Suc k); a \\<in> [n\\<dots>,d] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iTILL_induct: \"\n  \\<lbrakk> P 0; \\<And>k. \\<lbrakk> k \\<in> [\\<dots>n]; k \\<noteq> n; P k \\<rbrakk> \\<Longrightarrow> P (Suc k); a \\<in> [\\<dots>n] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iMOD_induct: \"\n  \\<lbrakk> P r; \\<And>k. \\<lbrakk> k \\<in> [r, mod m]; P k \\<rbrakk> \\<Longrightarrow> P (k + m); a \\<in> [r, mod m] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iMODb_induct: \"\n  \\<lbrakk> P r; \\<And>k. \\<lbrakk> k \\<in> [r, mod m, c]; k \\<noteq> r + m * c; P k \\<rbrakk> \\<Longrightarrow> P (k + m); a \\<in> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iIN_rev_induct: \"\n  \\<lbrakk> P (n + d); \\<And>k. \\<lbrakk> k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k \\<rbrakk> \\<Longrightarrow> P (k - Suc 0); a \\<in> [n\\<dots>,d] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iTILL_rev_induct: \"\n  \\<lbrakk> P n; \\<And>k. \\<lbrakk> k \\<in> [\\<dots>n]; 0 < k; P k \\<rbrakk> \\<Longrightarrow> P (k - Suc 0); a \\<in> [\\<dots>n] \\<rbrakk> \\<Longrightarrow> P a\"", "lemma iMODb_rev_induct: \"\n  \\<lbrakk> P (r + m * c); \\<And>k. \\<lbrakk> k \\<in> [r, mod m, c]; k \\<noteq> r; P k \\<rbrakk> \\<Longrightarrow> P (k - m); a \\<in> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> P a\""], "translations": [["", "lemmas iT_defs = iFROM_def iTILL_def iIN_def iMOD_def iMODb_def"], ["", "lemma iFROM_iff: \"x \\<in> [n\\<dots>] = (n \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> [n\\<dots>]) = (n \\<le> x)", "by (simp add: iFROM_def)"], ["", "lemma iTILL_iff: \"x \\<in> [\\<dots>n] = (x \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> [\\<dots>n]) = (x \\<le> n)", "by (simp add: iTILL_def)"], ["", "lemma iIN_iff:\"x \\<in> [n\\<dots>,d] = (n \\<le> x \\<and> x \\<le> n + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> [n\\<dots>,d]) = (n \\<le> x \\<and> x \\<le> n + d)", "by (simp add: iIN_def)"], ["", "lemma iMOD_iff: \"x \\<in> [r, mod m] = (x mod m = r mod m \\<and> r \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> [ r, mod m ]) = (x mod m = r mod m \\<and> r \\<le> x)", "by (simp add: iMOD_def)"], ["", "lemma iMODb_iff: \"x \\<in> [r, mod m, c] = \n  (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> [ r, mod m, c ]) =\n    (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c)", "by (simp add: iMODb_def)"], ["", "lemma iFROM_D: \"x \\<in> [n\\<dots>] \\<Longrightarrow> (n \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [n\\<dots>] \\<Longrightarrow> n \\<le> x", "by (rule iFROM_iff[THEN iffD1])"], ["", "lemma iTILL_D: \"x \\<in> [\\<dots>n] \\<Longrightarrow> (x \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [\\<dots>n] \\<Longrightarrow> x \\<le> n", "by (rule iTILL_iff[THEN iffD1])"], ["", "corollary iIN_geD: \"x \\<in> [n\\<dots>,d] \\<Longrightarrow> n \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [n\\<dots>,d] \\<Longrightarrow> n \\<le> x", "by (simp add: iIN_iff)"], ["", "corollary iIN_leD: \"x \\<in> [n\\<dots>,d] \\<Longrightarrow> x \\<le> n + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [n\\<dots>,d] \\<Longrightarrow> x \\<le> n + d", "by (simp add: iIN_iff)"], ["", "corollary iMOD_modD: \"x \\<in> [r, mod m] \\<Longrightarrow> x mod m = r mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m ] \\<Longrightarrow> x mod m = r mod m", "by (simp add: iMOD_iff)"], ["", "corollary iMOD_geD: \"x \\<in> [r, mod m] \\<Longrightarrow> r \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m ] \\<Longrightarrow> r \\<le> x", "by (simp add: iMOD_iff)"], ["", "corollary iMODb_modD: \"x \\<in> [r, mod m, c] \\<Longrightarrow> x mod m = r mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m, c ] \\<Longrightarrow> x mod m = r mod m", "by (simp add: iMODb_iff)"], ["", "corollary iMODb_geD: \"x \\<in> [r, mod m, c] \\<Longrightarrow> r \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m, c ] \\<Longrightarrow> r \\<le> x", "by (simp add: iMODb_iff)"], ["", "corollary iMODb_leD: \"x \\<in> [r, mod m, c] \\<Longrightarrow> x \\<le> r + m * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m, c ] \\<Longrightarrow> x \\<le> r + m * c", "by (simp add: iMODb_iff)"], ["", "lemmas iT_iff = iFROM_iff iTILL_iff iIN_iff iMOD_iff iMODb_iff"], ["", "lemmas iT_drule =\n  iFROM_D\n  iTILL_D\n  iIN_geD iIN_leD\n  iMOD_modD iMOD_geD\n  iMODb_modD iMODb_geD iMODb_leD"], ["", "lemma \n  iFROM_I [intro]: \"n \\<le> x \\<Longrightarrow> x \\<in> [n\\<dots>]\" and\n  iTILL_I [intro]: \"x \\<le> n \\<Longrightarrow> x \\<in> [\\<dots>n]\" and\n  iIN_I [intro]:   \"n \\<le> x \\<Longrightarrow> x \\<le> n + d \\<Longrightarrow> x \\<in> [n\\<dots>,d]\" and\n  iMOD_I [intro]:  \"x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> x \\<in> [r, mod m]\" and\n  iMODb_I [intro]: \"x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> x \\<le> r + m * c \\<Longrightarrow> x \\<in> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n \\<le> x \\<Longrightarrow> x \\<in> [n\\<dots>]) &&&\n     (x \\<le> n \\<Longrightarrow> x \\<in> [\\<dots>n])) &&&\n    (\\<lbrakk>n \\<le> x; x \\<le> n + d\\<rbrakk>\n     \\<Longrightarrow> x \\<in> [n\\<dots>,d]) &&&\n    (\\<lbrakk>x mod m = r mod m; r \\<le> x\\<rbrakk>\n     \\<Longrightarrow> x \\<in> [ r, mod m ]) &&&\n    (\\<lbrakk>x mod m = r mod m; r \\<le> x; x \\<le> r + m * c\\<rbrakk>\n     \\<Longrightarrow> x \\<in> [ r, mod m, c ])", "by (simp add: iT_iff)+"], ["", "lemma \n  iFROM_E [elim]:  \"x \\<in> [n\\<dots>] \\<Longrightarrow> (n \\<le> x \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iTILL_E [elim]:  \"x \\<in> [\\<dots>n] \\<Longrightarrow> (x \\<le> n \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iIN_E [elim]:    \"x \\<in> [n\\<dots>,d] \\<Longrightarrow> (n \\<le> x \\<Longrightarrow> x \\<le> n + d \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iMOD_E [elim]:   \"x \\<in> [r, mod m] \\<Longrightarrow> (x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> P) \\<Longrightarrow> P\" and \n  iMODb_E [elim]:   \"x \\<in> [r, mod m, c] \\<Longrightarrow> (x mod m = r mod m \\<Longrightarrow> r \\<le> x \\<Longrightarrow> x \\<le> r + m * c \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>x \\<in> [n\\<dots>]; n \\<le> x \\<Longrightarrow> P\\<rbrakk>\n      \\<Longrightarrow> P) &&&\n     (\\<lbrakk>x \\<in> [\\<dots>n]; x \\<le> n \\<Longrightarrow> P\\<rbrakk>\n      \\<Longrightarrow> P)) &&&\n    (\\<lbrakk>x \\<in> [n\\<dots>,d];\n      \\<lbrakk>n \\<le> x; x \\<le> n + d\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P) &&&\n    (\\<lbrakk>x \\<in> [ r, mod m ];\n      \\<lbrakk>x mod m = r mod m; r \\<le> x\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P) &&&\n    (\\<lbrakk>x \\<in> [ r, mod m, c ];\n      \\<lbrakk>x mod m = r mod m; r \\<le> x; x \\<le> r + m * c\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P)", "by (simp add: iT_iff)+"], ["", "(*\nlemma \"0 < n \\<Longrightarrow> \\<exists>x \\<in> [n\\<dots>,2*n]. x mod 2 = 0\"\napply (simp add: iT_defs)\napply (rule_tac x=\"2*n\" in bexI)\napply simp\napply simp\ndone\nlemma \"0 < n \\<Longrightarrow> \\<exists>x \\<in> [n\\<dots>,2*n]. x mod 2 = 0\"\napply (simp add: iT_defs atLeastAtMost_def atLeast_def atMost_def Collect_conj_eq[symmetric])\napply (rule_tac x=\"2*n\" in exI)\napply simp\ndone\n*)"], ["", "lemma iIN_Suc_insert_conv: \"\n  insert (Suc (n + d)) [n\\<dots>,d] = [n\\<dots>,Suc d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Suc (n + d)) [n\\<dots>,d] = [n\\<dots>,Suc d]", "by (fastforce simp: iIN_iff)"], ["", "lemma iTILL_Suc_insert_conv: \"insert (Suc n) [\\<dots>n] = [\\<dots>Suc n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Suc n) [\\<dots>n] = [\\<dots>Suc n]", "by (fastforce simp: iIN_Suc_insert_conv[of 0 n])"], ["", "lemma iMODb_Suc_insert_conv: \"\n  insert (r + m * Suc c) [r, mod m, c] = [r, mod m, Suc c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (r + m * Suc c) [ r, mod m, c ] = [ r, mod m, Suc c ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> insert (r + m * Suc c) [ r, mod m, c ]) =\n       (x \\<in> [ r, mod m, Suc c ])", "apply (simp add: iMODb_iff add.commute[of _ r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x = r + (m + m * c) \\<or>\n        x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c) =\n       (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + (m + m * c))", "apply (simp add: add.commute[of m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x = r + (m * c + m) \\<or>\n        x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c) =\n       (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + (m * c + m))", "apply (simp add: add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x = r + m * c + m \\<or>\n        x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c) =\n       (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c + m)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = r + m * c + m \\<or>\n       x mod m = r mod m \\<and>\n       r \\<le> x \\<and> x \\<le> r + m * c \\<Longrightarrow>\n       x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c + m\n 2. \\<And>x.\n       x mod m = r mod m \\<and>\n       r \\<le> x \\<and> x \\<le> r + m * c + m \\<Longrightarrow>\n       x = r + m * c + m \\<or>\n       x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x mod m = r mod m \\<and>\n       r \\<le> x \\<and> x \\<le> r + m * c + m \\<Longrightarrow>\n       x = r + m * c + m \\<or>\n       x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x \\<le> r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c", "apply (drule_tac x=x in order_le_less[THEN iffD1, rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x;\n        x < r + m * c + m \\<or> x = r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x < r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c\n 2. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x = r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c", "apply (frule less_mod_eq_imp_add_divisor_le[where m=m], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x < r + m * c + m;\n        x + m \\<le> r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c\n 2. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x = r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c", "apply (drule add_le_imp_le_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x < r + m * c + m;\n        x \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c\n 2. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x = r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = r mod m; r \\<le> x; x = r + m * c + m\\<rbrakk>\n       \\<Longrightarrow> x = r + m * c + m \\<or>\n                         x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iFROM_pred_insert_conv: \"insert (n - Suc 0) [n\\<dots>] = [n - Suc 0\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (n - Suc 0) [n\\<dots>] = [n - Suc 0\\<dots>]", "by (fastforce simp: iFROM_iff)"], ["", "lemma iIN_pred_insert_conv: \"\n  0 < n \\<Longrightarrow> insert (n - Suc 0) [n\\<dots>,d] = [n - Suc 0\\<dots>,Suc d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    insert (n - Suc 0) [n\\<dots>,d] = [n - Suc 0\\<dots>,Suc d]", "by (fastforce simp: iIN_iff)"], ["", "lemma iMOD_pred_insert_conv: \"\n  m \\<le> r \\<Longrightarrow> insert (r - m) [r, mod m] = [r - m, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> r \\<Longrightarrow>\n    insert (r - m) [ r, mod m ] = [ r - m, mod m ]", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> r; m = 0\\<rbrakk>\n    \\<Longrightarrow> insert (r - m) [ r, mod m ] = [ r - m, mod m ]\n 2. \\<lbrakk>m \\<le> r; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> insert (r - m) [ r, mod m ] = [ r - m, mod m ]", "apply (simp add: iMOD_iff insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> r; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> insert (r - m) [ r, mod m ] = [ r - m, mod m ]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> r; 0 < m\\<rbrakk>\n    \\<Longrightarrow> insert (r - m) [ r, mod m ] = [ r - m, mod m ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> insert (r - m) [ r, mod m ]) =\n                         (x \\<in> [ r - m, mod m ])", "apply (simp add: iMOD_iff mod_diff_self2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m\\<rbrakk>\n       \\<Longrightarrow> (x = r - m \\<or>\n                          x mod m = r mod m \\<and> r \\<le> x) =\n                         (x mod m = r mod m \\<and> r - m \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r - m \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x mod m = r mod m \\<and> r - m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x = r - m\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r - m \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x mod m = r mod m \\<and> r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r - m \\<le> x\n 3. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x mod m = r mod m \\<and> r - m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (simp add: mod_diff_self2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x mod m = r mod m \\<and> r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r - m \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x mod m = r mod m \\<and> r - m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (simp add: le_imp_diff_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m;\n        x mod m = r mod m \\<and> r - m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (drule order_le_less[THEN iffD1, of \"r-m\"], erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m < x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m = x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m = x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m < x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m < x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (frule order_less_le_trans[of _ m r], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; r - m < x;\n        0 < r\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (drule less_mod_eq_imp_add_divisor_le[of \"r-m\" _ m])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; 0 < r\\<rbrakk>\n       \\<Longrightarrow> (r - m) mod m = x mod m\n 2. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; 0 < r;\n        r - m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply (simp add: mod_diff_self2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r; 0 < m; x mod m = r mod m; 0 < r;\n        r - m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = r - m \\<or> x mod m = r mod m \\<and> r \\<le> x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_pred_insert_conv: \"\n  m \\<le> r \\<Longrightarrow> insert (r - m) [r, mod m, c] = [r - m, mod m, Suc c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> r \\<Longrightarrow>\n    insert (r - m) [ r, mod m, c ] = [ r - m, mod m, Suc c ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       m \\<le> r \\<Longrightarrow>\n       (x \\<in> insert (r - m) [ r, mod m, c ]) =\n       (x \\<in> [ r - m, mod m, Suc c ])", "apply (frule iMOD_pred_insert_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r;\n        insert (r - m) [ r, mod m ] = [ r - m, mod m ]\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> insert (r - m) [ r, mod m, c ]) =\n                         (x \\<in> [ r - m, mod m, Suc c ])", "apply (drule_tac f=\"\\<lambda>s. x \\<in> s\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>m \\<le> r;\n        (x \\<in> insert (r - m) [ r, mod m ]) =\n        (x \\<in> [ r - m, mod m ])\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> insert (r - m) [ r, mod m, c ]) =\n                         (x \\<in> [ r - m, mod m, Suc c ])", "apply (force simp: iMOD_iff iMODb_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iFROM_Suc_pred_insert_conv: \"insert n [Suc n\\<dots>] = [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n [Suc n\\<dots>] = [n\\<dots>]", "by (insert iFROM_pred_insert_conv[of \"Suc n\"], simp)"], ["", "lemma iIN_Suc_pred_insert_conv: \"insert n [Suc n\\<dots>,d] = [n\\<dots>,Suc d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n [Suc n\\<dots>,d] = [n\\<dots>,Suc d]", "by (insert iIN_pred_insert_conv[of \"Suc n\"], simp)"], ["", "lemma iMOD_Suc_pred_insert_conv: \"insert r [r + m, mod m] = [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert r [ r + m, mod m ] = [ r, mod m ]", "by (insert iMOD_pred_insert_conv[of m \"r + m\"], simp)"], ["", "lemma iMODb_Suc_pred_insert_conv: \"insert r [r + m, mod m, c] = [r, mod m, Suc c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert r [ r + m, mod m, c ] = [ r, mod m, Suc c ]", "by (insert iMODb_pred_insert_conv[of m \"r + m\"], simp)"], ["", "lemmas iT_Suc_insert =\n  iIN_Suc_insert_conv\n  iTILL_Suc_insert_conv\n  iMODb_Suc_insert_conv"], ["", "lemmas iT_pred_insert =\n  iFROM_pred_insert_conv\n  iIN_pred_insert_conv\n  iMOD_pred_insert_conv\n  iMODb_pred_insert_conv"], ["", "lemmas iT_Suc_pred_insert =\n  iFROM_Suc_pred_insert_conv\n  iIN_Suc_pred_insert_conv\n  iMOD_Suc_pred_insert_conv\n  iMODb_Suc_pred_insert_conv"], ["", "lemma iMOD_mem_diff: \"\\<lbrakk> a \\<in> [r, mod m]; b \\<in> [r, mod m] \\<rbrakk> \\<Longrightarrow> (a - b) mod m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> [ r, mod m ]; b \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> (a - b) mod m = 0", "by (simp add: iMOD_iff mod_eq_imp_diff_mod_0)"], ["", "lemma iMODb_mem_diff: \"\\<lbrakk> a \\<in> [r, mod m, c]; b \\<in> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> (a - b) mod m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> [ r, mod m, c ]; b \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> (a - b) mod m = 0", "by (simp add: iMODb_iff mod_eq_imp_diff_mod_0)"], ["", "subsubsection \\<open>Interval conversions\\<close>"], ["", "lemma iIN_0_iTILL_conv:\"[0\\<dots>,n] = [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0\\<dots>,n] = [\\<dots>n]", "by (simp add: iTILL_def iIN_def atMost_atLeastAtMost_0_conv)"], ["", "lemma iIN_iTILL_iTILL_conv: \"0 < n \\<Longrightarrow> [n\\<dots>,d] = [\\<dots>n+d] - [\\<dots>n - Suc 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    [n\\<dots>,d] = [\\<dots>n + d] - [\\<dots>n - Suc 0]", "by (fastforce simp: iTILL_iff iIN_iff)"], ["", "lemma iIN_iFROM_iTILL_conv: \"[n\\<dots>,d] = [n\\<dots>] \\<inter> [\\<dots>n+d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] = [n\\<dots>] \\<inter> [\\<dots>n + d]", "by (simp add: iT_defs atLeastAtMost_def)"], ["", "lemma iMODb_iMOD_iTILL_conv: \"[r, mod m, c] = [r, mod m] \\<inter> [\\<dots>r+m*c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] = [ r, mod m ] \\<inter> [\\<dots>r + m * c]", "by (force simp: iT_defs set_interval_defs)"], ["", "lemma iMODb_iMOD_iIN_conv: \"[r, mod m, c] = [r, mod m] \\<inter> [r\\<dots>,m*c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] = [ r, mod m ] \\<inter> [r\\<dots>,m * c]", "by (force simp: iT_defs set_interval_defs)"], ["", "lemma iFROM_iTILL_iIN_conv: \"n \\<le> n' \\<Longrightarrow> [n\\<dots>] \\<inter> [\\<dots>n'] = [n\\<dots>,n'-n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<Longrightarrow>\n    [n\\<dots>] \\<inter> [\\<dots>n'] = [n\\<dots>,n' - n]", "by (simp add: iT_defs atLeastAtMost_def)"], ["", "lemma iMOD_iTILL_iMODb_conv: \"\n  r \\<le> n \\<Longrightarrow> [r, mod m] \\<inter> [\\<dots>n] = [r, mod m, (n - r) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> n \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [\\<dots>n] = [ r, mod m, (n - r) div m ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       r \\<le> n \\<Longrightarrow>\n       (x \\<in> [ r, mod m ] \\<inter> [\\<dots>n]) =\n       (x \\<in> [ r, mod m, (n - r) div m ])", "apply (simp add: iT_iff minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       r \\<le> n \\<Longrightarrow>\n       (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> n) =\n       (x mod m = r mod m \\<and>\n        r \\<le> x \\<and> x \\<le> r + (n - (r + (n - r) mod m)))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> n;\n        x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and>\n                         r \\<le> x \\<and>\n                         x \\<le> r + (n - (r + (n - r) mod m))\n 2. \\<And>x.\n       \\<lbrakk>r \\<le> n;\n        x mod m = r mod m \\<and>\n        r \\<le> x \\<and> x \\<le> r + (n - (r + (n - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> n", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> n; x mod m = r mod m; r \\<le> x; x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (n - (r + (n - r) mod m))\n 2. \\<And>x.\n       \\<lbrakk>r \\<le> n;\n        x mod m = r mod m \\<and>\n        r \\<le> x \\<and> x \\<le> r + (n - (r + (n - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> n", "apply (frule_tac x=x and y=n and m=m in le_imp_sub_mod_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> n; x mod m = r mod m; r \\<le> x; x \\<le> n;\n        x \\<le> n - (n - x) mod m\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (n - (r + (n - r) mod m))\n 2. \\<And>x.\n       \\<lbrakk>r \\<le> n;\n        x mod m = r mod m \\<and>\n        r \\<le> x \\<and> x \\<le> r + (n - (r + (n - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> n", "apply (simp add: mod_diff_right_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> n;\n        x mod m = r mod m \\<and>\n        r \\<le> x \\<and> x \\<le> r + (n - (r + (n - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> n", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_iIN_iMODb_conv: \"\n  [r, mod m] \\<inter> [r\\<dots>,d] = [r, mod m, d div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<inter> [r\\<dots>,d] = [ r, mod m, d div m ]", "apply (case_tac \"r = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [r\\<dots>,d] = [ r, mod m, d div m ]\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [r\\<dots>,d] = [ r, mod m, d div m ]", "apply (simp add: iIN_0_iTILL_conv iMOD_iTILL_iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [r\\<dots>,d] = [ r, mod m, d div m ]", "apply (simp add: iIN_iTILL_iTILL_conv Diff_Int_distrib iMOD_iTILL_iMODb_conv diff_add_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow>\n    [ r, mod m, d div m ] - [ r, mod m ] \\<inter> [\\<dots>r - Suc 0] =\n    [ r, mod m, d div m ]", "apply (rule subst[of \"{}\" _ \"\\<lambda>t. \\<forall>x.(x - t) = x\", THEN spec])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < r \\<Longrightarrow> {} = [ r, mod m ] \\<inter> [\\<dots>r - Suc 0]\n 2. 0 < r \\<Longrightarrow> \\<forall>x. x - {} = x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < r \\<Longrightarrow> \\<forall>x. x - {} = x\n 2. 0 < r \\<Longrightarrow> {} = [ r, mod m ] \\<inter> [\\<dots>r - Suc 0]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> {} = [ r, mod m ] \\<inter> [\\<dots>r - Suc 0]", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> [ r, mod m ] \\<inter> [\\<dots>r - Suc 0] = {}", "apply (fastforce simp: disjoint_iff_not_equal iMOD_iff iTILL_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iFROM_0: \"[0\\<dots>] = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0\\<dots>] = UNIV", "by (simp add: iFROM_def)"], ["", "lemma iTILL_0: \"[\\<dots>0] = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>0] = {0}", "by (simp add: iTILL_def)"], ["", "lemma iIN_0: \"[n\\<dots>,0] = {n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,0] = {n}", "by (simp add: iIN_def)"], ["", "lemma iMOD_0: \"[r, mod 0] = [r\\<dots>,0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod 0 ] = [r\\<dots>,0]", "by (fastforce simp: iIN_0 iMOD_def)"], ["", "lemma iMODb_mod_0: \"[r, mod 0, c] = [r\\<dots>,0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod 0, c ] = [r\\<dots>,0]", "by (fastforce simp: iMODb_def iIN_0)"], ["", "lemma iMODb_0: \"[r, mod m, 0] = [r\\<dots>,0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, 0 ] = [r\\<dots>,0]", "by (fastforce simp: iMODb_def iIN_0 set_eq_iff)"], ["", "lemmas iT_0 =\n  iFROM_0\n  iTILL_0\n  iIN_0\n  iMOD_0\n  iMODb_mod_0\n  iMODb_0"], ["", "lemma iMOD_1: \"[r, mod Suc 0] = [r\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod Suc 0 ] = [r\\<dots>]", "by (fastforce simp: iFROM_iff)"], ["", "lemma iMODb_mod_1: \"[r, mod Suc 0, c] = [r\\<dots>,c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod Suc 0, c ] = [r\\<dots>,c]", "by (fastforce simp: iT_iff)"], ["", "subsubsection \\<open>Finiteness and emptiness of intervals\\<close>"], ["", "lemma \n  iFROM_not_empty: \"[n\\<dots>] \\<noteq> {}\" and\n  iTILL_not_empty: \"[\\<dots>n] \\<noteq> {}\" and\n  iIN_not_empty: \"[n\\<dots>,d] \\<noteq> {}\" and\n  iMOD_not_empty: \"[r, mod m] \\<noteq> {}\" and\n  iMODb_not_empty: \"[r, mod m, c] \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>] \\<noteq> {} &&& [\\<dots>n] \\<noteq> {}) &&&\n    [n\\<dots>,d] \\<noteq> {} &&&\n    [ r, mod m ] \\<noteq> {} &&& [ r, mod m, c ] \\<noteq> {}", "by (fastforce simp: iT_iff)+"], ["", "lemmas iT_not_empty = \n  iFROM_not_empty\n  iTILL_not_empty\n  iIN_not_empty\n  iMOD_not_empty\n  iMODb_not_empty"], ["", "lemma \n  iTILL_finite: \"finite [\\<dots>n]\" and\n  iIN_finite: \"finite [n\\<dots>,d]\" and\n  iMODb_finite: \"finite [r, mod m, c]\" and\n  iMOD_0_finite: \"finite [r, mod 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite [\\<dots>n] &&& finite [n\\<dots>,d]) &&&\n    finite [ r, mod m, c ] &&& finite [ r, mod 0 ]", "by (simp add: iT_defs)+"], ["", "lemma iFROM_infinite: \"infinite [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite [n\\<dots>]", "by (simp add: iT_defs infinite_atLeast)"], ["", "lemma iMOD_infinite: \"0 < m \\<Longrightarrow> infinite [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> infinite [ r, mod m ]", "apply (rule infinite_nat_iff_asc_chain[THEN iffD2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow> [ r, mod m ] \\<noteq> {}\n 2. 0 < m \\<Longrightarrow>\n    \\<forall>ma\\<in>[ r, mod m ]. \\<exists>n\\<in>[ r, mod m ]. ma < n", "apply (rule iT_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    \\<forall>ma\\<in>[ r, mod m ]. \\<exists>n\\<in>[ r, mod m ]. ma < n", "apply (rule ballI, rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < m; n \\<in> [ r, mod m ]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na\\<in>[ r, mod m ]. n < na", "apply (rule_tac x=\"n+m\" in bexI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < m; n \\<in> [ r, mod m ]\\<rbrakk>\n       \\<Longrightarrow> n + m \\<in> [ r, mod m ]", "apply (simp add: iMOD_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_finite =\n  iTILL_finite\n  iIN_finite\n  iMODb_finite iMOD_0_finite"], ["", "lemmas iT_infinite =\n  iFROM_infinite\n  iMOD_infinite"], ["", "subsubsection \\<open>\\<open>Min\\<close> and \\<open>Max\\<close> element of an interval\\<close>"], ["", "lemma \n  iTILL_Min: \"iMin [\\<dots>n] = 0\" and\n  iFROM_Min: \"iMin [n\\<dots>] = n\" and\n  iIN_Min:   \"iMin [n\\<dots>,d] = n\" and\n  iMOD_Min:  \"iMin [r, mod m] = r\" and\n  iMODb_Min: \"iMin [r, mod m, c] = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iMin [\\<dots>n] = 0 &&& iMin [n\\<dots>] = n) &&&\n    iMin [n\\<dots>,d] = n &&&\n    iMin [ r, mod m ] = r &&& iMin [ r, mod m, c ] = r", "by (rule iMin_equality, (simp add: iT_iff)+)+"], ["", "lemmas iT_Min = \n  iIN_Min\n  iTILL_Min\n  iFROM_Min\n  iMOD_Min\n  iMODb_Min"], ["", "lemma \n  iTILL_Max: \"Max [\\<dots>n] = n\" and\n  iIN_Max: \"Max [n\\<dots>,d] = n+d\" and\n  iMODb_Max: \"Max [r, mod m, c] = r + m * c\" and\n  iMOD_0_Max: \"Max [r, mod 0] = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Max [\\<dots>n] = n &&& Max [n\\<dots>,d] = n + d) &&&\n    Max [ r, mod m, c ] = r + m * c &&& Max [ r, mod 0 ] = r", "by (rule Max_equality, (simp add: iT_iff iT_finite)+)+"], ["", "lemmas iT_Max =\n  iTILL_Max\n  iIN_Max\n  iMODb_Max\n  iMOD_0_Max"], ["", "lemma\n  iTILL_iMax: \"iMax [\\<dots>n] = enat n\" and\n  iIN_iMax: \"iMax [n\\<dots>,d] = enat (n+d)\" and\n  iMODb_iMax: \"iMax [r, mod m, c] = enat (r + m * c)\" and\n  iMOD_0_iMax: \"iMax [r, mod 0] = enat r\" and\n  iFROM_iMax: \"iMax [n\\<dots>] = \\<infinity>\" and\n  iMOD_iMax: \"0 < m \\<Longrightarrow> iMax [r, mod m] = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iMax [\\<dots>n] = enat n &&&\n     iMax [n\\<dots>,d] = enat (n + d) &&&\n     iMax [ r, mod m, c ] = enat (r + m * c)) &&&\n    iMax [ r, mod 0 ] = enat r &&&\n    iMax [n\\<dots>] = \\<infinity> &&&\n    (0 < m \\<Longrightarrow> iMax [ r, mod m ] = \\<infinity>)", "by (simp add: iMax_def iT_finite iT_infinite iT_Max)+"], ["", "lemmas iT_iMax =\n  iTILL_iMax\n  iIN_iMax\n  iMODb_iMax\n  iMOD_0_iMax\n  iFROM_iMax\n  iMOD_iMax"], ["", "subsection \\<open>Adding and subtracting constants to interval elements\\<close>"], ["", "lemma \n  iFROM_plus: \"x \\<in> [n\\<dots>] \\<Longrightarrow> x + k \\<in> [n\\<dots>]\" and\n  iFROM_Suc: \"x \\<in> [n\\<dots>] \\<Longrightarrow> Suc x \\<in> [n\\<dots>]\" and\n  iFROM_minus: \"\\<lbrakk> x \\<in> [n\\<dots>]; k \\<le> x - n \\<rbrakk> \\<Longrightarrow> x - k \\<in> [n\\<dots>]\" and\n  iFROM_pred: \"n < x  \\<Longrightarrow> x - Suc 0 \\<in> [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<in> [n\\<dots>] \\<Longrightarrow> x + k \\<in> [n\\<dots>]) &&&\n     (x \\<in> [n\\<dots>] \\<Longrightarrow> Suc x \\<in> [n\\<dots>])) &&&\n    (\\<lbrakk>x \\<in> [n\\<dots>]; k \\<le> x - n\\<rbrakk>\n     \\<Longrightarrow> x - k \\<in> [n\\<dots>]) &&&\n    (n < x \\<Longrightarrow> x - Suc 0 \\<in> [n\\<dots>])", "by (simp add: iFROM_iff)+"], ["", "lemma \n  iTILL_plus: \"\\<lbrakk> x \\<in> [\\<dots>n]; k \\<le> n - x \\<rbrakk> \\<Longrightarrow> x + k \\<in> [\\<dots>n]\" and\n  iTILL_Suc: \"x < n \\<Longrightarrow> Suc x \\<in> [\\<dots>n]\" and\n  iTILL_minus: \"x \\<in> [\\<dots>n] \\<Longrightarrow> x - k \\<in> [\\<dots>n]\" and\n  iTILL_pred: \"x \\<in> [\\<dots>n] \\<Longrightarrow> x - Suc 0 \\<in> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>x \\<in> [\\<dots>n]; k \\<le> n - x\\<rbrakk>\n      \\<Longrightarrow> x + k \\<in> [\\<dots>n]) &&&\n     (x < n \\<Longrightarrow> Suc x \\<in> [\\<dots>n])) &&&\n    (x \\<in> [\\<dots>n] \\<Longrightarrow> x - k \\<in> [\\<dots>n]) &&&\n    (x \\<in> [\\<dots>n] \\<Longrightarrow> x - Suc 0 \\<in> [\\<dots>n])", "by (simp add: iTILL_iff)+"], ["", "lemma iIN_plus: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; k \\<le> n + d - x \\<rbrakk> \\<Longrightarrow> x + k \\<in> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [n\\<dots>,d]; k \\<le> n + d - x\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [n\\<dots>,d]", "by (fastforce simp: iIN_iff)"], ["", "lemma iIN_Suc: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; x < n + d \\<rbrakk> \\<Longrightarrow> Suc x \\<in> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [n\\<dots>,d]; x < n + d\\<rbrakk>\n    \\<Longrightarrow> Suc x \\<in> [n\\<dots>,d]", "by (simp add: iIN_iff)"], ["", "lemma iIN_minus: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; k \\<le> x - n \\<rbrakk> \\<Longrightarrow> x - k \\<in> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [n\\<dots>,d]; k \\<le> x - n\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [n\\<dots>,d]", "by (fastforce simp: iIN_iff)"], ["", "lemma iIN_pred: \"\\<lbrakk> x \\<in> [n\\<dots>,d]; n < x \\<rbrakk> \\<Longrightarrow> x - Suc 0 \\<in> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [n\\<dots>,d]; n < x\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [n\\<dots>,d]", "by (fastforce simp: iIN_iff)"], ["", "lemma iMOD_plus_divisor_mult: \"x \\<in> [r, mod m] \\<Longrightarrow> x + k * m \\<in> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m ] \\<Longrightarrow> x + k * m \\<in> [ r, mod m ]", "by (simp add: iMOD_def)"], ["", "corollary iMOD_plus_divisor: \"x \\<in> [r, mod m] \\<Longrightarrow> x + m \\<in> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m ] \\<Longrightarrow> x + m \\<in> [ r, mod m ]", "by (simp add: iMOD_def)"], ["", "lemma iMOD_minus_divisor_mult: \"\n  \\<lbrakk> x \\<in> [r, mod m]; k * m \\<le> x - r \\<rbrakk> \\<Longrightarrow> x - k * m \\<in> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; k * m \\<le> x - r\\<rbrakk>\n    \\<Longrightarrow> x - k * m \\<in> [ r, mod m ]", "by (fastforce simp: iMOD_def mod_diff_mult_self1)"], ["", "corollary iMOD_minus_divisor_mult2: \"\n  \\<lbrakk> x \\<in> [r, mod m]; k \\<le> (x - r) div m \\<rbrakk> \\<Longrightarrow> x - k * m \\<in> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> (x - r) div m\\<rbrakk>\n    \\<Longrightarrow> x - k * m \\<in> [ r, mod m ]", "apply (rule iMOD_minus_divisor_mult, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> (x - r) div m\\<rbrakk>\n    \\<Longrightarrow> k * m \\<le> x - r", "apply (clarsimp simp: iMOD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> (x - r) div m; x mod m = r mod m; r \\<le> x\\<rbrakk>\n    \\<Longrightarrow> k * m \\<le> x - r", "apply (drule mult_le_mono1[of _ _ m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod m = r mod m; r \\<le> x;\n     k * m \\<le> (x - r) div m * m\\<rbrakk>\n    \\<Longrightarrow> k * m \\<le> x - r", "apply (simp add: mod_0_div_mult_cancel[THEN iffD1, OF mod_eq_imp_diff_mod_0])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_minus_divisor: \"\n  \\<lbrakk> x \\<in> [r, mod m]; m + r \\<le> x \\<rbrakk> \\<Longrightarrow> x - m \\<in> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; m + r \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - m \\<in> [ r, mod m ]", "apply (frule iMOD_geD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; m + r \\<le> x; r \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - m \\<in> [ r, mod m ]", "apply (insert iMOD_minus_divisor_mult[of x r m 1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; m + r \\<le> x; r \\<le> x;\n     \\<lbrakk>x \\<in> [ r, mod m ]; 1 * m \\<le> x - r\\<rbrakk>\n     \\<Longrightarrow> x - 1 * m \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> x - m \\<in> [ r, mod m ]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_plus: \"\n  x \\<in> [r, mod m] \\<Longrightarrow> (x + k \\<in> [r, mod m]) = (k mod m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m ] \\<Longrightarrow>\n    (x + k \\<in> [ r, mod m ]) = (k mod m = 0)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; x + k \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> k mod m = 0\n 2. \\<lbrakk>x \\<in> [ r, mod m ]; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m ]", "apply (drule iMOD_modD)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod m = r mod m; (x + k) mod m = r mod m\\<rbrakk>\n    \\<Longrightarrow> k mod m = 0\n 2. \\<lbrakk>x \\<in> [ r, mod m ]; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m ]", "apply (rule mod_add_eq_imp_mod_0[of x, THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod m = r mod m; (x + k) mod m = r mod m\\<rbrakk>\n    \\<Longrightarrow> (x + k) mod m = x mod m\n 2. \\<lbrakk>x \\<in> [ r, mod m ]; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m ]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m ]", "apply (erule dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>x \\<in> [ r, mod m ]; k = m * ka\\<rbrakk>\n       \\<Longrightarrow> x + k \\<in> [ r, mod m ]", "apply (simp add: mult.commute iMOD_plus_divisor_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_Suc: \"\n  x \\<in> [r, mod m] \\<Longrightarrow> (Suc x \\<in> [r, mod m]) = (m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m ] \\<Longrightarrow>\n    (Suc x \\<in> [ r, mod m ]) = (m = Suc 0)", "apply (simp add: iMOD_iff, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod m = r mod m; r \\<le> x; Suc x mod m = r mod m\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x mod Suc 0 = r mod Suc 0; r \\<le> x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc x mod Suc 0 = r mod Suc 0", "apply (simp add: mod_Suc, split if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x mod m = r mod m; r \\<le> x; Suc (r mod m) = m;\n     0 = r mod m\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x mod m = r mod m; r \\<le> x; Suc (r mod m) \\<noteq> m;\n     Suc (x mod m) = r mod m\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 3. \\<lbrakk>x mod Suc 0 = r mod Suc 0; r \\<le> x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc x mod Suc 0 = r mod Suc 0", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_minus: \"\n  \\<lbrakk> x \\<in> [r, mod m]; k \\<le> x - r \\<rbrakk> \\<Longrightarrow> (x - k \\<in> [r, mod m]) = (k mod m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r\\<rbrakk>\n    \\<Longrightarrow> (x - k \\<in> [ r, mod m ]) = (k mod m = 0)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r;\n     x - k \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> k mod m = 0\n 2. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [ r, mod m ]", "apply (clarsimp simp: iMOD_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> x - r; x mod m = r mod m; r \\<le> x;\n     (x - k) mod m = r mod m; r \\<le> x - k\\<rbrakk>\n    \\<Longrightarrow> k mod m = 0\n 2. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [ r, mod m ]", "apply (rule mod_add_eq_imp_mod_0[of \"x - k\" k, THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> x - r; x mod m = r mod m; r \\<le> x;\n     (x - k) mod m = r mod m; r \\<le> x - k\\<rbrakk>\n    \\<Longrightarrow> (x - k + k) mod m = (x - k) mod m\n 2. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [ r, mod m ]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r; m dvd k\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [ r, mod m ]", "apply (erule dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>x \\<in> [ r, mod m ]; k \\<le> x - r; k = m * ka\\<rbrakk>\n       \\<Longrightarrow> x - k \\<in> [ r, mod m ]", "apply (simp add: mult.commute iMOD_minus_divisor_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_pred: \"\n  \\<lbrakk> x \\<in> [r, mod m]; r < x \\<rbrakk> \\<Longrightarrow> (x - Suc 0 \\<in> [r, mod m]) = (m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; r < x\\<rbrakk>\n    \\<Longrightarrow> (x - Suc 0 \\<in> [ r, mod m ]) = (m = Suc 0)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x \\<in> [ r, mod Suc 0 ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod Suc 0 ]", "apply (simp add: iMOD_Suc[of \"x - Suc 0\" r, THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod Suc 0 ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod Suc 0 ]", "apply (simp add: iMOD_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_plus_divisor_mult: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k * m \\<le> r + m * c - x \\<rbrakk> \\<Longrightarrow> x + k * m \\<in> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k * m \\<le> r + m * c - x\\<rbrakk>\n    \\<Longrightarrow> x + k * m \\<in> [ r, mod m, c ]", "by (fastforce simp: iMODb_def)"], ["", "lemma iMODb_plus_divisor_mult2: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k \\<le> c - (x - r) div m \\<rbrakk> \\<Longrightarrow> \n  x + k * m \\<in> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> c - (x - r) div m\\<rbrakk>\n    \\<Longrightarrow> x + k * m \\<in> [ r, mod m, c ]", "apply (rule iMODb_plus_divisor_mult, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> c - (x - r) div m\\<rbrakk>\n    \\<Longrightarrow> k * m \\<le> r + m * c - x", "apply (clarsimp simp: iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> c - (x - r) div m; x mod m = r mod m; r \\<le> x;\n     x \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> k * m \\<le> r + m * c - x", "apply (drule mult_le_mono1[of _ _ m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod m = r mod m; r \\<le> x; x \\<le> r + m * c;\n     k * m \\<le> (c - (x - r) div m) * m\\<rbrakk>\n    \\<Longrightarrow> k * m \\<le> r + m * c - x", "apply (simp add: diff_mult_distrib\n  mod_0_div_mult_cancel[THEN iffD1, OF mod_eq_imp_diff_mod_0]\n  add.commute[of r] mult.commute[of c])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_plus_divisor: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; x < r + m * c \\<rbrakk> \\<Longrightarrow> x + m \\<in> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; x < r + m * c\\<rbrakk>\n    \\<Longrightarrow> x + m \\<in> [ r, mod m, c ]", "by (simp add: iMODb_iff less_mod_eq_imp_add_divisor_le)"], ["", "lemma iMODb_minus_divisor_mult: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; r + k * m \\<le> x \\<rbrakk>  \\<Longrightarrow> x - k * m \\<in> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r + k * m \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x - k * m \\<in> [ r, mod m, c ]", "by (fastforce simp: iMODb_def mod_diff_mult_self1)"], ["", "lemma iMODb_plus: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k \\<le> r + m * c - x \\<rbrakk> \\<Longrightarrow> \n  (x + k \\<in> [r, mod m, c]) = (k mod m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> r + m * c - x\\<rbrakk>\n    \\<Longrightarrow> (x + k \\<in> [ r, mod m, c ]) = (k mod m = 0)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> r + m * c - x;\n     x + k \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> k mod m = 0\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> r + m * c - x;\n     m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m, c ]", "apply (rule mod_add_eq_imp_mod_0[of x, THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> r + m * c - x;\n     x + k \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> (x + k) mod m = x mod m\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> r + m * c - x;\n     m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m, c ]", "apply (simp add: iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> r + m * c - x;\n     m dvd k\\<rbrakk>\n    \\<Longrightarrow> x + k \\<in> [ r, mod m, c ]", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMODb_Suc: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; x < r + m * c \\<rbrakk> \\<Longrightarrow> \n  (Suc x \\<in> [r, mod m, c]) = (m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; x < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (Suc x \\<in> [ r, mod m, c ]) = (m = Suc 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; x < r + m * c;\n     Suc x \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; x < r + m * c; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc x \\<in> [ r, mod m, c ]", "apply (simp add: iMODb_iMOD_iTILL_conv iMOD_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; x < r + m * c; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc x \\<in> [ r, mod m, c ]", "apply (simp add: iMODb_iMOD_iTILL_conv iMOD_1 iFROM_Suc iTILL_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_minus: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; k \\<le> x - r \\<rbrakk> \\<Longrightarrow> \n  (x - k \\<in> [r, mod m, c]) = (k mod m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> x - r\\<rbrakk>\n    \\<Longrightarrow> (x - k \\<in> [ r, mod m, c ]) = (k mod m = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> x - r;\n     x - k \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> k mod m = 0\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> x - r; k mod m = 0\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [ r, mod m, c ]", "apply (simp add: iMODb_iMOD_iTILL_conv iMOD_minus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; k \\<le> x - r; k mod m = 0\\<rbrakk>\n    \\<Longrightarrow> x - k \\<in> [ r, mod m, c ]", "apply (simp add: iMODb_iMOD_iTILL_conv iMOD_minus iTILL_minus)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMODb_pred: \"\n  \\<lbrakk> x \\<in> [r, mod m, c]; r < x \\<rbrakk> \\<Longrightarrow> \n  (x - Suc 0 \\<in> [r, mod m, c]) = (m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x\\<rbrakk>\n    \\<Longrightarrow> (x - Suc 0 \\<in> [ r, mod m, c ]) = (m = Suc 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod m, c ]", "apply (subgoal_tac \"x \\<in> [r, mod m] \\<and> x - Suc 0 \\<in> [r, mod m]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m, c ];\n     x \\<in> [ r, mod m ] \\<and> x - Suc 0 \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> x \\<in> [ r, mod m ] \\<and>\n                      x - Suc 0 \\<in> [ r, mod m ]\n 3. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod m, c ]", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> x \\<in> [ r, mod m ] \\<and>\n                      x - Suc 0 \\<in> [ r, mod m ]\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m, c ];\n     x \\<in> [ r, mod m ] \\<and> x - Suc 0 \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 3. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod m, c ]", "apply (simp add: iT_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x;\n     x - Suc 0 \\<in> [ r, mod m, c ];\n     x \\<in> [ r, mod m ] \\<and> x - Suc 0 \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod m, c ]", "apply (clarsimp simp: iMOD_pred)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m, c ]; r < x; m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> x - Suc 0 \\<in> [ r, mod m, c ]", "apply (fastforce simp add: iMODb_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iFROM_plus_minus =\n  iFROM_plus\n  iFROM_Suc\n  iFROM_minus\n  iFROM_pred"], ["", "lemmas iTILL_plus_minus =\n  iTILL_plus\n  iTILL_Suc\n  iTILL_minus\n  iTILL_pred"], ["", "lemmas iIN_plus_minus =\n  iIN_plus\n  iIN_Suc\n  iTILL_minus\n  iIN_pred"], ["", "lemmas iMOD_plus_minus_divisor =\n  iMOD_plus_divisor_mult\n  iMOD_plus_divisor\n  iMOD_minus_divisor_mult\n  iMOD_minus_divisor_mult2\n  iMOD_minus_divisor"], ["", "lemmas iMOD_plus_minus =\n  iMOD_plus\n  iMOD_Suc\n  iMOD_minus\n  iMOD_pred"], ["", "lemmas iMODb_plus_minus_divisor =\n  iMODb_plus_divisor_mult\n  iMODb_plus_divisor_mult2\n  iMODb_plus_divisor\n  iMODb_minus_divisor_mult"], ["", "lemmas iMODb_plus_minus =\n  iMODb_plus\n  iMODb_Suc\n  iMODb_minus\n  iMODb_pred"], ["", "lemmas iT_plus_minus =\n  iFROM_plus_minus\n  iTILL_plus_minus\n  iIN_plus_minus\n  iMOD_plus_minus_divisor\n  iMOD_plus_minus\n  iMODb_plus_minus_divisor\n  iMODb_plus_minus"], ["", "(*\nlemma \"a \\<in> [3\\<dots>,2] \\<Longrightarrow> 3 \\<le> a \\<and> a \\<le> 5\"\nby (simp add: iT_iff)\nlemma \"15 \\<in> [5, mod 10]\"\nby (simp add: iT_iff)\n\n\nlemma \"n \\<in> [15, mod 10] \\<Longrightarrow> n \\<in> [5, mod 10]\"\nby (simp add: iT_iff)\n\nlemma \"[15, mod 10] \\<subseteq> [5, mod 10]\"\nby (fastforce simp: iMOD_def)\n\nlemma \"n \\<le> i \\<Longrightarrow> n \\<in> [\\<dots>i]\"\nby (simp add: iT_iff)\nlemma \"\\<forall>n \\<in> [\\<dots>i]. n \\<le> i\"\nby (simp add: iT_iff)\n\nlemma \"\\<exists>n \\<in> [2, mod 10].n \\<notin> [12, mod 10]\"\napply (simp add: iT_defs)\napply (rule_tac x=2 in exI)\napply simp\ndone\n*)"], ["", "subsection \\<open>Relations between intervals\\<close>"], ["", "subsubsection \\<open>Auxiliary lemmata\\<close>"], ["", "lemma Suc_in_imp_not_subset_iMOD: \"\n  \\<lbrakk> n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> S \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> S \\<subseteq> [ r, mod m ]", "by (blast intro: iMOD_Suc[THEN iffD1])"], ["", "corollary Suc_in_imp_neq_iMOD: \"\n  \\<lbrakk> n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> S \\<noteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> S \\<noteq> [ r, mod m ]", "by (blast dest: Suc_in_imp_not_subset_iMOD)"], ["", "lemma Suc_in_imp_not_subset_iMODb: \"\n  \\<lbrakk> n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> S \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> S \\<subseteq> [ r, mod m, c ]", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     S \\<subseteq> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule subsetD[of _ _ n], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     S \\<subseteq> [ r, mod m, c ]; n \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule subsetD[of _ _ \"Suc n\"], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule iMODb_Suc[THEN iffD1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> n < r + m * c\n 2. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> Suc n \\<in> [ r, mod m, c ]\n 3. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ];\n     m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule iMODb_leD[of \"Suc n\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> n < r + m * c\n 2. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> Suc n \\<in> [ r, mod m, c ]\n 3. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ];\n     m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> Suc n \\<in> [ r, mod m, c ]\n 2. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0;\n     n \\<in> [ r, mod m, c ]; Suc n \\<in> [ r, mod m, c ];\n     m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary Suc_in_imp_neq_iMODb: \"\n  \\<lbrakk> n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> S \\<noteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> S; Suc n \\<in> S; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> S \\<noteq> [ r, mod m, c ]", "by (blast dest: Suc_in_imp_not_subset_iMODb)"], ["", "subsubsection \\<open>Subset relation between intervals\\<close>"], ["", "lemma \n  iIN_iFROM_subset_same: \"[n\\<dots>,d] \\<subseteq> [n\\<dots>]\" and\n  iIN_iTILL_subset_same: \"[n\\<dots>,d] \\<subseteq> [\\<dots>n+d]\" and\n  iMOD_iFROM_subset_same: \"[r, mod m] \\<subseteq> [r\\<dots>]\" and\n  iMODb_iTILL_subset_same: \"[r, mod m, c] \\<subseteq> [\\<dots>r+m*c]\" and\n  iMODb_iIN_subset_same: \"[r, mod m, c] \\<subseteq> [r\\<dots>,m*c]\" and\n  iMODb_iMOD_subset_same: \"[r, mod m, c] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>,d] \\<subseteq> [n\\<dots>] &&&\n     [n\\<dots>,d] \\<subseteq> [\\<dots>n + d] &&&\n     [ r, mod m ] \\<subseteq> [r\\<dots>]) &&&\n    [ r, mod m, c ] \\<subseteq> [\\<dots>r + m * c] &&&\n    [ r, mod m, c ] \\<subseteq> [r\\<dots>,m * c] &&&\n    [ r, mod m, c ] \\<subseteq> [ r, mod m ]", "by (simp add: subset_iff iT_iff)+"], ["", "lemmas iT_subset_same = \n  iIN_iFROM_subset_same\n  iIN_iTILL_subset_same\n  iMOD_iFROM_subset_same\n  iMODb_iTILL_subset_same\n  iMODb_iIN_subset_same\n  iMODb_iTILL_subset_same\n  iMODb_iMOD_subset_same"], ["", "lemma iMODb_imp_iMOD: \"x \\<in> [r, mod m, c] \\<Longrightarrow> x \\<in> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> [ r, mod m, c ] \\<Longrightarrow> x \\<in> [ r, mod m ]", "by (blast intro: iMODb_iMOD_subset_same)"], ["", "lemma iMOD_imp_iMODb: \"\n  \\<lbrakk> x \\<in> [r, mod m]; x \\<le> r + m * c \\<rbrakk> \\<Longrightarrow> x \\<in> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [ r, mod m ]; x \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> x \\<in> [ r, mod m, c ]", "by (simp add: iT_iff)"], ["", "lemma iMOD_singleton_subset_conv: \"([r, mod m] \\<subseteq> {a}) = (r = a \\<and> m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m ] \\<subseteq> {a}) = (r = a \\<and> m = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [ r, mod m ] \\<subseteq> {a} \\<Longrightarrow> r = a \\<and> m = 0\n 2. r = a \\<and> m = 0 \\<Longrightarrow> [ r, mod m ] \\<subseteq> {a}", "apply (simp add: subset_singleton_conv iT_not_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [ r, mod m ] = {a} \\<Longrightarrow> r = a \\<and> m = 0\n 2. r = a \\<and> m = 0 \\<Longrightarrow> [ r, mod m ] \\<subseteq> {a}", "apply (simp add: set_eq_iff iT_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       (x mod m = r mod m \\<and> r \\<le> x) = (x = a) \\<Longrightarrow>\n    r = a \\<and> m = 0\n 2. r = a \\<and> m = 0 \\<Longrightarrow> [ r, mod m ] \\<subseteq> {a}", "apply (frule_tac x=r in spec, drule_tac x=\"r+m\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(r mod m = r mod m \\<and> r \\<le> r) = (r = a);\n     ((r + m) mod m = r mod m \\<and> r \\<le> r + m) = (r + m = a)\\<rbrakk>\n    \\<Longrightarrow> r = a \\<and> m = 0\n 2. r = a \\<and> m = 0 \\<Longrightarrow> [ r, mod m ] \\<subseteq> {a}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = a \\<and> m = 0 \\<Longrightarrow> [ r, mod m ] \\<subseteq> {a}", "apply (simp add: iMOD_0 iIN_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_singleton_eq_conv: \"([r, mod m] = {a}) = (r = a \\<and> m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m ] = {a}) = (r = a \\<and> m = 0)", "apply (rule_tac t=\"[r, mod m] = {a}\" and s=\"[r, mod m] \\<subseteq> {a}\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([ r, mod m ] \\<subseteq> {a}) = ([ r, mod m ] = {a})\n 2. ([ r, mod m ] \\<subseteq> {a}) = (r = a \\<and> m = 0)", "apply (simp add: subset_singleton_conv iMOD_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m ] \\<subseteq> {a}) = (r = a \\<and> m = 0)", "apply (simp add: iMOD_singleton_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_singleton_subset_conv: \"\n  ([r, mod m, c] \\<subseteq> {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m, c ] \\<subseteq> {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [ r, mod m, c ] \\<subseteq> {a} \\<Longrightarrow>\n    r = a \\<and> (m = 0 \\<or> c = 0)\n 2. r = a \\<and> (m = 0 \\<or> c = 0) \\<Longrightarrow>\n    [ r, mod m, c ] \\<subseteq> {a}", "apply (simp add: subset_singleton_conv iT_not_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [ r, mod m, c ] = {a} \\<Longrightarrow> r = a \\<and> (m = 0 \\<or> c = 0)\n 2. r = a \\<and> (m = 0 \\<or> c = 0) \\<Longrightarrow>\n    [ r, mod m, c ] \\<subseteq> {a}", "apply (simp add: set_eq_iff iT_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       (x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c) =\n       (x = a) \\<Longrightarrow>\n    r = a \\<and> (m = 0 \\<or> c = 0)\n 2. r = a \\<and> (m = 0 \\<or> c = 0) \\<Longrightarrow>\n    [ r, mod m, c ] \\<subseteq> {a}", "apply (frule_tac x=r in spec, drule_tac x=\"r+m\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(r mod m = r mod m \\<and> r \\<le> r \\<and> r \\<le> r + m * c) =\n             (r = a);\n     ((r + m) mod m = r mod m \\<and>\n      r \\<le> r + m \\<and> r + m \\<le> r + m * c) =\n     (r + m = a)\\<rbrakk>\n    \\<Longrightarrow> r = a \\<and> (m = 0 \\<or> c = 0)\n 2. r = a \\<and> (m = 0 \\<or> c = 0) \\<Longrightarrow>\n    [ r, mod m, c ] \\<subseteq> {a}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = a \\<and> (m = 0 \\<or> c = 0) \\<Longrightarrow>\n    [ r, mod m, c ] \\<subseteq> {a}", "apply (fastforce simp: iMODb_0 iMODb_mod_0 iIN_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_singleton_eq_conv: \"\n  ([r, mod m, c] = {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m, c ] = {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))", "apply (rule_tac t=\"[r, mod m, c] = {a}\" and s=\"[r, mod m, c] \\<subseteq> {a}\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([ r, mod m, c ] \\<subseteq> {a}) = ([ r, mod m, c ] = {a})\n 2. ([ r, mod m, c ] \\<subseteq> {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))", "apply (simp add:  subset_singleton_conv iMODb_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m, c ] \\<subseteq> {a}) = (r = a \\<and> (m = 0 \\<or> c = 0))", "apply (simp add: iMODb_singleton_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_subset_imp_divisor_mod_0: \"\n  \\<lbrakk> 0 < c'; [r', mod m', c'] \\<subseteq> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> m' mod m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0", "apply (simp add: subset_iff iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c';\n     \\<forall>t.\n        t mod m' = r' mod m' \\<and>\n        r' \\<le> t \\<and> t \\<le> r' + m' * c' \\<longrightarrow>\n        t mod m = r mod m \\<and> r \\<le> t \\<and> t \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0", "apply (drule gr0_imp_self_le_mult1[of _ m'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                t mod m' = r' mod m' \\<and>\n                r' \\<le> t \\<and> t \\<le> r' + m' * c' \\<longrightarrow>\n                t mod m = r mod m \\<and> r \\<le> t \\<and> t \\<le> r + m * c;\n     m' \\<le> m' * c'\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0", "apply (rule mod_add_eq_imp_mod_0[of r' m' m, THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t.\n                t mod m' = r' mod m' \\<and>\n                r' \\<le> t \\<and> t \\<le> r' + m' * c' \\<longrightarrow>\n                t mod m = r mod m \\<and> r \\<le> t \\<and> t \\<le> r + m * c;\n     m' \\<le> m' * c'\\<rbrakk>\n    \\<Longrightarrow> (r' + m') mod m = r' mod m", "apply (frule_tac x=r' in spec, drule_tac x=\"r'+m'\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<le> m' * c';\n     r' mod m' = r' mod m' \\<and>\n     r' \\<le> r' \\<and> r' \\<le> r' + m' * c' \\<longrightarrow>\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> r' \\<le> r + m * c;\n     (r' + m') mod m' = r' mod m' \\<and>\n     r' \\<le> r' + m' \\<and> r' + m' \\<le> r' + m' * c' \\<longrightarrow>\n     (r' + m') mod m = r mod m \\<and>\n     r \\<le> r' + m' \\<and> r' + m' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> (r' + m') mod m = r' mod m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_subset_imp_divisor_mod_0: \"\n  [r', mod m'] \\<subseteq> [r, mod m] \\<Longrightarrow> m' mod m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r', mod m' ] \\<subseteq> [ r, mod m ] \\<Longrightarrow> m' mod m = 0", "apply (simp add: subset_iff iMOD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t mod m' = r' mod m' \\<and> r' \\<le> t \\<longrightarrow>\n       t mod m = r mod m \\<and> r \\<le> t \\<Longrightarrow>\n    m' mod m = 0", "apply (rule mod_add_eq_imp_mod_0[of r' m' m, THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t mod m' = r' mod m' \\<and> r' \\<le> t \\<longrightarrow>\n       t mod m = r mod m \\<and> r \\<le> t \\<Longrightarrow>\n    (r' + m') mod m = r' mod m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_subset_imp_iMODb_subset: \"\n  \\<lbrakk> [r', mod m'] \\<subseteq> [r, mod m]; r' + m' * c' \\<le> r + m * c \\<rbrakk> \\<Longrightarrow> \n  [r', mod m', c'] \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[ r', mod m' ] \\<subseteq> [ r, mod m ];\n     r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "by (simp add: subset_iff iT_iff)"], ["", "lemma iMODb_subset_imp_iMOD_subset: \"\n  \\<lbrakk> [r', mod m', c'] \\<subseteq> [r, mod m, c]; 0 < c' \\<rbrakk> \\<Longrightarrow> \n  [r', mod m'] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c'\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (frule subsetD[of _ _ r'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c'\\<rbrakk>\n    \\<Longrightarrow> r' \\<in> [ r', mod m', c' ]\n 2. \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n     r' \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n     r' \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n        r' \\<in> [ r, mod m, c ]; x \\<in> [ r', mod m' ]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [ r, mod m ]", "apply (simp add: iMOD_iff iMODb_iff, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n        r' mod m = r mod m; x mod m' = r' mod m'; r' \\<le> x; r \\<le> r';\n        r' \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m", "apply (drule mod_eq_mod_0_imp_mod_eq[where m=m and m'=m'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n        r' mod m = r mod m; r' \\<le> x; r \\<le> r';\n        r' \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> m' mod m = 0\n 2. \\<And>x.\n       \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n        r' mod m = r mod m; r' \\<le> x; r \\<le> r'; r' \\<le> r + m * c;\n        x mod m = r' mod m\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m", "apply (simp add: iMODb_subset_imp_divisor_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]; 0 < c';\n        r' mod m = r mod m; r' \\<le> x; r \\<le> r'; r' \\<le> r + m * c;\n        x mod m = r' mod m\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_0_iMOD_subset_conv: \"\n  ([r', mod m', 0] \\<subseteq> [r, mod m]) = \n  (r' mod m = r mod m \\<and> r \\<le> r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', 0 ] \\<subseteq> [ r, mod m ]) =\n    (r' mod m = r mod m \\<and> r \\<le> r')", "by (simp add: iMODb_0 iIN_0 singleton_subset_conv iMOD_iff)"], ["", "lemma iFROM_subset_conv: \"([n'\\<dots>] \\<subseteq> [n\\<dots>]) = (n \\<le> n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n'\\<dots>] \\<subseteq> [n\\<dots>]) = (n \\<le> n')", "by (simp add: iFROM_def)"], ["", "lemma iFROM_iMOD_subset_conv: \"([n'\\<dots>] \\<subseteq> [r, mod m]) = (r \\<le> n' \\<and> m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n'\\<dots>] \\<subseteq> [ r, mod m ]) = (r \\<le> n' \\<and> m = Suc 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n'\\<dots>] \\<subseteq> [ r, mod m ] \\<Longrightarrow>\n    r \\<le> n' \\<and> m = Suc 0\n 2. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [n'\\<dots>] \\<subseteq> [ r, mod m ] \\<Longrightarrow> r \\<le> n'\n 2. [n'\\<dots>] \\<subseteq> [ r, mod m ] \\<Longrightarrow> m = Suc 0\n 3. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (drule iMin_subset[OF iFROM_not_empty])"], ["proof (prove)\ngoal (3 subgoals):\n 1. iMin [ r, mod m ] \\<le> iMin [n'\\<dots>] \\<Longrightarrow> r \\<le> n'\n 2. [n'\\<dots>] \\<subseteq> [ r, mod m ] \\<Longrightarrow> m = Suc 0\n 3. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (simp add: iT_Min)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n'\\<dots>] \\<subseteq> [ r, mod m ] \\<Longrightarrow> m = Suc 0\n 2. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[n'\\<dots>] \\<subseteq> [ r, mod m ]; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (cut_tac Suc_in_imp_not_subset_iMOD[of n' \"[n'\\<dots>]\" m r])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>[n'\\<dots>] \\<subseteq> [ r, mod m ]; m \\<noteq> Suc 0;\n     \\<not> [n'\\<dots>] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>[n'\\<dots>] \\<subseteq> [ r, mod m ]; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> n' \\<in> [n'\\<dots>]\n 3. \\<lbrakk>[n'\\<dots>] \\<subseteq> [ r, mod m ]; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc n' \\<in> [n'\\<dots>]\n 4. \\<lbrakk>[n'\\<dots>] \\<subseteq> [ r, mod m ]; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> m \\<noteq> Suc 0\n 5. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (simp add: iT_iff)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> n' \\<and> m = Suc 0 \\<Longrightarrow>\n    [n'\\<dots>] \\<subseteq> [ r, mod Suc 0 ]", "apply (simp add: subset_iff iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_subset_conv: \"([n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]) = (n \\<le> n' \\<and> n'+d' \\<le> n+d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]) =\n    (n \\<le> n' \\<and> n' + d' \\<le> n + d)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d] \\<Longrightarrow>\n    n \\<le> n' \\<and> n' + d' \\<le> n + d\n 2. n \\<le> n' \\<and> n' + d' \\<le> n + d \\<Longrightarrow>\n    [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]", "apply (frule iMin_subset[OF iIN_not_empty])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d];\n     iMin [n\\<dots>,d] \\<le> iMin [n'\\<dots>,d']\\<rbrakk>\n    \\<Longrightarrow> n \\<le> n' \\<and> n' + d' \\<le> n + d\n 2. n \\<le> n' \\<and> n' + d' \\<le> n + d \\<Longrightarrow>\n    [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]", "apply (drule Max_subset[OF iIN_not_empty _ iIN_finite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>iMin [n\\<dots>,d] \\<le> iMin [n'\\<dots>,d'];\n     Max [n'\\<dots>,d'] \\<le> Max [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> n \\<le> n' \\<and> n' + d' \\<le> n + d\n 2. n \\<le> n' \\<and> n' + d' \\<le> n + d \\<Longrightarrow>\n    [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]", "apply (simp add: iIN_Min iIN_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<and> n' + d' \\<le> n + d \\<Longrightarrow>\n    [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]", "apply (simp add: subset_iff iIN_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_iFROM_subset_conv: \"([n'\\<dots>,d'] \\<subseteq> [n\\<dots>]) = (n \\<le> n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n'\\<dots>,d'] \\<subseteq> [n\\<dots>]) = (n \\<le> n')", "by (fastforce simp: subset_iff iFROM_iff iIN_iff)"], ["", "lemma iIN_iTILL_subset_conv: \"([n'\\<dots>,d'] \\<subseteq> [\\<dots>n]) = (n' + d' \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n'\\<dots>,d'] \\<subseteq> [\\<dots>n]) = (n' + d' \\<le> n)", "by (fastforce simp: subset_iff iT_iff)"], ["", "lemma iIN_iMOD_subset_conv: \"\n  0 < d' \\<Longrightarrow> ([n'\\<dots>,d'] \\<subseteq> [r, mod m]) = (r \\<le> n' \\<and> m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d' \\<Longrightarrow>\n    ([n'\\<dots>,d'] \\<subseteq> [ r, mod m ]) =\n    (r \\<le> n' \\<and> m = Suc 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r \\<le> n' \\<and> m = Suc 0\n 2. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (frule iMin_subset[OF iIN_not_empty])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     iMin [ r, mod m ] \\<le> iMin [n'\\<dots>,d']\\<rbrakk>\n    \\<Longrightarrow> r \\<le> n' \\<and> m = Suc 0\n 2. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (simp add: iT_Min)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     r \\<le> n'\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (subgoal_tac \"n' \\<in> [n'\\<dots>,d']\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     r \\<le> n'\\<rbrakk>\n    \\<Longrightarrow> n' \\<in> [n'\\<dots>,d']\n 3. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     r \\<le> n'\\<rbrakk>\n    \\<Longrightarrow> n' \\<in> [n'\\<dots>,d']\n 2. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 3. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (simp add: iIN_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']\\<rbrakk>\n    \\<Longrightarrow> m = Suc 0\n 2. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (frule Suc_in_imp_not_subset_iMOD[where r=r and m=m])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc n' \\<in> [n'\\<dots>,d']\n 2. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> m \\<noteq> Suc 0\n 3. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n';\n     n' \\<in> [n'\\<dots>,d']; m \\<noteq> Suc 0;\n     \\<not> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (simp add: iIN_Suc)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d'; r \\<le> n' \\<and> m = Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod Suc 0 ]", "apply (simp add: iMOD_1 iIN_iFROM_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_iMODb_subset_conv: \"\n  0 < d' \\<Longrightarrow> \n  ([n'\\<dots>,d'] \\<subseteq> [r, mod m, c]) = \n  (r \\<le> n' \\<and> m = Suc 0 \\<and> n' + d' \\<le> r + m * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d' \\<Longrightarrow>\n    ([n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ]) =\n    (r \\<le> n' \\<and> m = Suc 0 \\<and> n' + d' \\<le> r + m * c)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> r \\<le> n' \\<and>\n                      m = Suc 0 \\<and> n' + d' \\<le> r + m * c\n 2. \\<lbrakk>0 < d';\n     r \\<le> n' \\<and> m = Suc 0 \\<and> n' + d' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ]", "apply (frule subset_trans[OF _ iMODb_iMOD_subset_same])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; [n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ];\n     [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r \\<le> n' \\<and>\n                      m = Suc 0 \\<and> n' + d' \\<le> r + m * c\n 2. \\<lbrakk>0 < d';\n     r \\<le> n' \\<and> m = Suc 0 \\<and> n' + d' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ]", "apply (simp add: iIN_iMOD_subset_conv iMODb_mod_1 iIN_subset_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d';\n     r \\<le> n' \\<and> m = Suc 0 \\<and> n' + d' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ]", "apply (clarsimp simp: iMODb_mod_1 iIN_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_subset_conv: \"([\\<dots>n'] \\<subseteq> [\\<dots>n]) = (n' \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<dots>n'] \\<subseteq> [\\<dots>n]) = (n' \\<le> n)", "by (simp add: iTILL_def)"], ["", "lemma iTILL_iFROM_subset_conv: \"([\\<dots>n'] \\<subseteq> [n\\<dots>]) = (n = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<dots>n'] \\<subseteq> [n\\<dots>]) = (n = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [\\<dots>n'] \\<subseteq> [n\\<dots>] \\<Longrightarrow> n = 0\n 2. n = 0 \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [n\\<dots>]", "apply (drule subsetD[of _ _ 0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<in> [\\<dots>n']\n 2. 0 \\<in> [n\\<dots>] \\<Longrightarrow> n = 0\n 3. n = 0 \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [n\\<dots>]", "apply (simp add: iT_iff)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [0\\<dots>]", "apply (simp add: iFROM_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_iIN_subset_conv: \"([\\<dots>n'] \\<subseteq> [n\\<dots>,d]) = (n = 0 \\<and> n' \\<le> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<dots>n'] \\<subseteq> [n\\<dots>,d]) = (n = 0 \\<and> n' \\<le> d)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [\\<dots>n'] \\<subseteq> [n\\<dots>,d] \\<Longrightarrow>\n    n = 0 \\<and> n' \\<le> d\n 2. n = 0 \\<and> n' \\<le> d \\<Longrightarrow>\n    [\\<dots>n'] \\<subseteq> [n\\<dots>,d]", "apply (frule iMin_subset[OF iTILL_not_empty])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[\\<dots>n'] \\<subseteq> [n\\<dots>,d];\n     iMin [n\\<dots>,d] \\<le> iMin [\\<dots>n']\\<rbrakk>\n    \\<Longrightarrow> n = 0 \\<and> n' \\<le> d\n 2. n = 0 \\<and> n' \\<le> d \\<Longrightarrow>\n    [\\<dots>n'] \\<subseteq> [n\\<dots>,d]", "apply (drule Max_subset[OF iTILL_not_empty _ iIN_finite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>iMin [n\\<dots>,d] \\<le> iMin [\\<dots>n'];\n     Max [\\<dots>n'] \\<le> Max [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> n = 0 \\<and> n' \\<le> d\n 2. n = 0 \\<and> n' \\<le> d \\<Longrightarrow>\n    [\\<dots>n'] \\<subseteq> [n\\<dots>,d]", "apply (simp add: iT_Min iT_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<and> n' \\<le> d \\<Longrightarrow>\n    [\\<dots>n'] \\<subseteq> [n\\<dots>,d]", "apply (simp add: iIN_0_iTILL_conv iTILL_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_iMOD_subset_conv: \"\n  0 < n' \\<Longrightarrow> ([\\<dots>n'] \\<subseteq> [r, mod m]) = (r = 0 \\<and> m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n' \\<Longrightarrow>\n    ([\\<dots>n'] \\<subseteq> [ r, mod m ]) = (r = 0 \\<and> m = Suc 0)", "apply (drule iIN_iMOD_subset_conv[of n' 0 r m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([0\\<dots>,n'] \\<subseteq> [ r, mod m ]) =\n    (r \\<le> 0 \\<and> m = Suc 0) \\<Longrightarrow>\n    ([\\<dots>n'] \\<subseteq> [ r, mod m ]) = (r = 0 \\<and> m = Suc 0)", "apply (simp add: iIN_0_iTILL_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_iMODb_subset_conv: \"\n  0 < n' \\<Longrightarrow> ([\\<dots>n'] \\<subseteq> [r, mod m, c]) = (r = 0 \\<and> m = Suc 0 \\<and> n' \\<le> r + m * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n' \\<Longrightarrow>\n    ([\\<dots>n'] \\<subseteq> [ r, mod m, c ]) =\n    (r = 0 \\<and> m = Suc 0 \\<and> n' \\<le> r + m * c)", "apply (drule iIN_iMODb_subset_conv[of n' 0 r m c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([0\\<dots>,n'] \\<subseteq> [ r, mod m, c ]) =\n    (r \\<le> 0 \\<and>\n     m = Suc 0 \\<and> 0 + n' \\<le> r + m * c) \\<Longrightarrow>\n    ([\\<dots>n'] \\<subseteq> [ r, mod m, c ]) =\n    (r = 0 \\<and> m = Suc 0 \\<and> n' \\<le> r + m * c)", "apply (simp add: iIN_0_iTILL_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_iFROM_subset_conv: \"([r', mod m']) \\<subseteq> [n\\<dots>] = (n \\<le> r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m' ] \\<subseteq> [n\\<dots>]) = (n \\<le> r')", "by (fastforce simp: subset_iff iT_iff)"], ["", "lemma iMODb_iFROM_subset_conv: \"([r', mod m', c'] \\<subseteq> [n\\<dots>]) = (n \\<le> r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', c' ] \\<subseteq> [n\\<dots>]) = (n \\<le> r')", "by (fastforce simp: subset_iff iT_iff)"], ["", "lemma iMODb_iIN_subset_conv: \"\n  ([r', mod m', c'] \\<subseteq> [n\\<dots>,d]) = (n \\<le> r' \\<and> r' + m' * c' \\<le> n + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', c' ] \\<subseteq> [n\\<dots>,d]) =\n    (n \\<le> r' \\<and> r' + m' * c' \\<le> n + d)", "by (fastforce simp: subset_iff iT_iff)"], ["", "lemma iMODb_iTILL_subset_conv: \"\n  ([r', mod m', c'] \\<subseteq> [\\<dots>n]) = (r' + m' * c' \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', c' ] \\<subseteq> [\\<dots>n]) = (r' + m' * c' \\<le> n)", "by (fastforce simp: subset_iff iT_iff)"], ["", "lemma iMOD_0_subset_conv: \"([r', mod 0] \\<subseteq> [r, mod m]) = (r' mod m = r mod m  \\<and>  r \\<le> r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod 0 ] \\<subseteq> [ r, mod m ]) =\n    (r' mod m = r mod m \\<and> r \\<le> r')", "by (fastforce simp: iMOD_0 iIN_0 singleton_subset_conv iMOD_iff)"], ["", "lemma iMOD_subset_conv: \"0 < m \\<Longrightarrow> \n  ([r', mod m'] \\<subseteq> [r, mod m]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    ([ r', mod m' ] \\<subseteq> [ r, mod m ]) =\n    (r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; [ r', mod m' ] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and> m' mod m = 0\n 2. \\<lbrakk>0 < m;\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (frule subsetD[of _ _ r'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; [ r', mod m' ] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' \\<in> [ r', mod m' ]\n 2. \\<lbrakk>0 < m; [ r', mod m' ] \\<subseteq> [ r, mod m ];\n     r' \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and> m' mod m = 0\n 3. \\<lbrakk>0 < m;\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMOD_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; [ r', mod m' ] \\<subseteq> [ r, mod m ];\n     r' \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and> m' mod m = 0\n 2. \\<lbrakk>0 < m;\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (drule iMOD_subset_imp_divisor_mod_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r' \\<in> [ r, mod m ]; m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and> m' mod m = 0\n 2. \\<lbrakk>0 < m;\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMOD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m;\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m;\n        r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0;\n        x \\<in> [ r', mod m' ]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [ r, mod m ]", "apply (simp add: iMOD_iff, elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r' mod m = r mod m; x mod m' = r' mod m'; r' \\<le> x;\n        r \\<le> r'; m' mod m = 0\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m", "apply (drule mod_eq_mod_0_imp_mod_eq[where m'=m' and m=m])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r' mod m = r mod m; r' \\<le> x; r \\<le> r';\n        m' mod m = 0\\<rbrakk>\n       \\<Longrightarrow> m' mod m = 0\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r' mod m = r mod m; r' \\<le> x; r \\<le> r';\n        m' mod m = 0; x mod m = r' mod m\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_subset_mod_0_conv: \"\n  ([r', mod m', c'] \\<subseteq> [r, mod 0, c ]) = (r'=r \\<and> (m'=0 \\<or> c'=0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', c' ] \\<subseteq> [ r, mod 0, c ]) =\n    (r' = r \\<and> (m' = 0 \\<or> c' = 0))", "by (simp add: iMODb_mod_0 iIN_0 iMODb_singleton_subset_conv)"], ["", "lemma iMODb_subset_0_conv: \"\n  ([r', mod m', c'] \\<subseteq> [r, mod m, 0 ]) = (r'=r \\<and> (m'=0 \\<or> c'=0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', c' ] \\<subseteq> [ r, mod m, 0 ]) =\n    (r' = r \\<and> (m' = 0 \\<or> c' = 0))", "by (simp add: iMODb_0 iIN_0 iMODb_singleton_subset_conv)"], ["", "lemma iMODb_0_subset_conv: \"\n  ([r', mod m', 0] \\<subseteq> [r, mod m, c ]) = (r' \\<in> [r, mod m, c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod m', 0 ] \\<subseteq> [ r, mod m, c ]) =\n    (r' \\<in> [ r, mod m, c ])", "by (simp add: iMODb_0 iIN_0)"], ["", "lemma iMODb_mod_0_subset_conv: \"\n  ([r', mod 0, c'] \\<subseteq> [r, mod m, c ]) = (r' \\<in> [r, mod m, c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r', mod 0, c' ] \\<subseteq> [ r, mod m, c ]) =\n    (r' \\<in> [ r, mod m, c ])", "by (simp add: iMODb_mod_0 iIN_0)"], ["", "lemma iMODb_subset_conv': \"\\<lbrakk> 0 < c; 0 < c' \\<rbrakk> \\<Longrightarrow> \n  ([r', mod m', c'] \\<subseteq> [r, mod m, c]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0  \\<and>\n   r' + m' * c' \\<le> r + m * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; 0 < c'\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < c';\n     [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and>\n                      m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\n 2. \\<lbrakk>0 < c; 0 < c';\n     r' mod m = r mod m \\<and>\n     r \\<le> r' \\<and>\n     m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (frule iMODb_subset_imp_iMOD_subset, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ];\n     [ r', mod m' ] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and>\n                      m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\n 2. \\<lbrakk>0 < c; 0 < c';\n     r' mod m = r mod m \\<and>\n     r \\<le> r' \\<and>\n     m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (drule iMOD_subset_imp_divisor_mod_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ];\n     m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and>\n                      m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\n 2. \\<lbrakk>0 < c; 0 < c';\n     r' mod m = r mod m \\<and>\n     r \\<le> r' \\<and>\n     m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (frule subsetD[OF _ iMinI_ex2[OF iMODb_not_empty]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ];\n     m' mod m = 0; iMin [ r', mod m', c' ] \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and>\n                      m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\n 2. \\<lbrakk>0 < c; 0 < c';\n     r' mod m = r mod m \\<and>\n     r \\<le> r' \\<and>\n     m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (drule Max_subset[OF iMODb_not_empty _ iMODb_finite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < c'; m' mod m = 0;\n     iMin [ r', mod m', c' ] \\<in> [ r, mod m, c ];\n     Max [ r', mod m', c' ] \\<le> Max [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and>\n                      m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\n 2. \\<lbrakk>0 < c; 0 < c';\n     r' mod m = r mod m \\<and>\n     r \\<le> r' \\<and>\n     m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (simp add: iMODb_iff iMODb_Min iMODb_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; 0 < c';\n     r' mod m = r mod m \\<and>\n     r \\<le> r' \\<and>\n     m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; 0 < c'; r' mod m = r mod m; r \\<le> r'; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (case_tac \"m = 0\", simp add: iMODb_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; 0 < c'; r' mod m = r mod m; r \\<le> r'; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (simp add: iMOD_subset_imp_iMODb_subset iMOD_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_subset_conv: \"\\<lbrakk> 0 < m'; 0 < c' \\<rbrakk> \\<Longrightarrow> \n  ([r', mod m', c'] \\<subseteq> [r, mod m, c]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0  \\<and>\n   r' + m' * c' \\<le> r + m * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m'; 0 < c'\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (case_tac \"c = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m'; 0 < c'; c = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)\n 2. \\<lbrakk>0 < m'; 0 < c'; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (simp add: iMODb_0 iIN_0 iMODb_singleton_subset_conv linorder_not_le, intro impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m'; 0 < c'; c = 0; r' mod m = r mod m\\<rbrakk>\n    \\<Longrightarrow> r' < r \\<or> 0 < m' mod m \\<or> r < r' + m' * c'\n 2. \\<lbrakk>0 < m'; 0 < c'; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (case_tac \"r' < r\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m'; 0 < c'; c = 0; r' mod m = r mod m;\n     \\<not> r' < r\\<rbrakk>\n    \\<Longrightarrow> r' < r \\<or> 0 < m' mod m \\<or> r < r' + m' * c'\n 2. \\<lbrakk>0 < m'; 0 < c'; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (simp add: linorder_not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m'; 0 < c'; c = 0; r' mod m = r mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> 0 < m' mod m \\<or> r < r' + m' * c'\n 2. \\<lbrakk>0 < m'; 0 < c'; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (insert add_less_le_mono[of 0 \"m' * c'\" r r'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m'; 0 < c'; c = 0; r' mod m = r mod m; r \\<le> r';\n     \\<lbrakk>0 < m' * c'; r \\<le> r'\\<rbrakk>\n     \\<Longrightarrow> 0 + r < m' * c' + r'\\<rbrakk>\n    \\<Longrightarrow> 0 < m' mod m \\<or> r < r' + m' * c'\n 2. \\<lbrakk>0 < m'; 0 < c'; c \\<noteq> 0;\n     \\<lbrakk>0 < m' * c'; r \\<le> r'\\<rbrakk>\n     \\<Longrightarrow> 0 + r < m' * c' + r'\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m'; 0 < c'; c \\<noteq> 0;\n     \\<lbrakk>0 < m' * c'; r \\<le> r'\\<rbrakk>\n     \\<Longrightarrow> 0 + r < m' * c' + r'\\<rbrakk>\n    \\<Longrightarrow> ([ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]) =\n                      (r' mod m = r mod m \\<and>\n                       r \\<le> r' \\<and>\n                       m' mod m = 0 \\<and> r' + m' * c' \\<le> r + m * c)", "apply (simp add: iMODb_subset_conv')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_iMOD_subset_conv: \"0 < c' \\<Longrightarrow>\n  ([r', mod m', c'] \\<subseteq> [r, mod m]) = \n  (r' mod m = r mod m  \\<and>  r \\<le> r'  \\<and>  m' mod m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c' \\<Longrightarrow>\n    ([ r', mod m', c' ] \\<subseteq> [ r, mod m ]) =\n    (r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and> m' mod m = 0\n 2. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (frule subsetD[OF _ iMinI_ex2[OF iMODb_not_empty]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m ];\n     iMin [ r', mod m', c' ] \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> r' mod m = r mod m \\<and>\n                      r \\<le> r' \\<and> m' mod m = 0\n 2. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMODb_Min iMOD_iff, elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c'; [ r', mod m', c' ] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0\n 2. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c';\n     [ r', mod m' ] \\<inter> [\\<dots>r' + m' * c'] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0\n 2. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (subgoal_tac \"[ r', mod m', c' ] \\<subseteq> [ r, mod m ] \\<inter> [\\<dots>r' + m' * c']\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < c';\n     [ r', mod m' ] \\<inter> [\\<dots>r' + m' * c'] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r';\n     [ r', mod m', c' ]\n     \\<subseteq> [ r, mod m ] \\<inter> [\\<dots>r' + m' * c']\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0\n 2. \\<lbrakk>0 < c';\n     [ r', mod m' ] \\<inter> [\\<dots>r' + m' * c'] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ]\n                      \\<subseteq> [ r, mod m ] \\<inter>\n                                  [\\<dots>r' + m' * c']\n 3. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < c';\n     [ r', mod m' ] \\<inter> [\\<dots>r' + m' * c'] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ]\n                      \\<subseteq> [ r, mod m ] \\<inter>\n                                  [\\<dots>r' + m' * c']\n 2. \\<lbrakk>0 < c';\n     [ r', mod m' ] \\<inter> [\\<dots>r' + m' * c'] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r';\n     [ r', mod m', c' ]\n     \\<subseteq> [ r, mod m ] \\<inter> [\\<dots>r' + m' * c']\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0\n 3. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c';\n     [ r', mod m' ] \\<inter> [\\<dots>r' + m' * c'] \\<subseteq> [ r, mod m ];\n     r' mod m = r mod m; r \\<le> r';\n     [ r', mod m', c' ]\n     \\<subseteq> [ r, mod m ] \\<inter> [\\<dots>r' + m' * c']\\<rbrakk>\n    \\<Longrightarrow> m' mod m = 0\n 2. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMOD_iTILL_iMODb_conv iMODb_subset_imp_divisor_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (rule subset_trans[OF iMODb_iMOD_subset_same])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (case_tac \"m = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c';\n     r' mod m = r mod m \\<and> r \\<le> r' \\<and> m' mod m = 0;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMOD_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_subset_conv =\n  iFROM_subset_conv\n  iFROM_iMOD_subset_conv\n  iTILL_subset_conv\n  iTILL_iFROM_subset_conv\n  iTILL_iIN_subset_conv\n  iTILL_iMOD_subset_conv\n  iTILL_iMODb_subset_conv\n  iIN_subset_conv\n  iIN_iFROM_subset_conv\n  iIN_iTILL_subset_conv\n  iIN_iMOD_subset_conv\n  iIN_iMODb_subset_conv\n  iMOD_subset_conv\n  iMOD_iFROM_subset_conv\n  iMODb_subset_conv'\n  iMODb_subset_conv\n  iMODb_iFROM_subset_conv\n  iMODb_iIN_subset_conv\n  iMODb_iTILL_subset_conv\n  iMODb_iMOD_subset_conv"], ["", "lemma iFROM_subset: \"n \\<le> n' \\<Longrightarrow> [n'\\<dots>] \\<subseteq> [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<Longrightarrow> [n'\\<dots>] \\<subseteq> [n\\<dots>]", "by (simp add: iFROM_subset_conv)"], ["", "lemma not_iFROM_iIN_subset: \"\\<not> [n'\\<dots>] \\<subseteq> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> [n'\\<dots>] \\<subseteq> [n\\<dots>,d]", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [n'\\<dots>] \\<subseteq> [n\\<dots>,d] \\<Longrightarrow> False", "apply (drule subsetD[of _ _ \"max n' (Suc (n + d))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. max n' (Suc (n + d)) \\<in> [n'\\<dots>]\n 2. max n' (Suc (n + d)) \\<in> [n\\<dots>,d] \\<Longrightarrow> False", "apply (simp add: iFROM_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. max n' (Suc (n + d)) \\<in> [n\\<dots>,d] \\<Longrightarrow> False", "apply (simp add: iIN_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_iFROM_iTILL_subset: \"\\<not> [n'\\<dots>] \\<subseteq> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> [n'\\<dots>] \\<subseteq> [\\<dots>n]", "by (simp add: iIN_0_iTILL_conv [symmetric] not_iFROM_iIN_subset)"], ["", "lemma not_iFROM_iMOD_subset: \"m \\<noteq> Suc 0 \\<Longrightarrow> \\<not> [n'\\<dots>] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> Suc 0 \\<Longrightarrow>\n    \\<not> [n'\\<dots>] \\<subseteq> [ r, mod m ]", "apply (rule Suc_in_imp_not_subset_iMOD[of n'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. m \\<noteq> Suc 0 \\<Longrightarrow> n' \\<in> [n'\\<dots>]\n 2. m \\<noteq> Suc 0 \\<Longrightarrow> Suc n' \\<in> [n'\\<dots>]\n 3. m \\<noteq> Suc 0 \\<Longrightarrow> m \\<noteq> Suc 0", "apply (simp add: iT_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_iFROM_iMODb_subset: \"\\<not> [n'\\<dots>] \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> [n'\\<dots>] \\<subseteq> [ r, mod m, c ]", "by (rule infinite_not_subset_finite[OF iFROM_infinite iMODb_finite])"], ["", "lemma iIN_subset: \"\\<lbrakk> n \\<le> n'; n' + d' \\<le> n + d \\<rbrakk> \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> n'; n' + d' \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d]", "by (simp add: iIN_subset_conv)"], ["", "lemma iIN_iFROM_subset: \"n \\<le> n' \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [n\\<dots>]", "by (simp add: subset_iff iT_iff)"], ["", "lemma iIN_iTILL_subset: \"n' + d' \\<le> n \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' + d' \\<le> n \\<Longrightarrow> [n'\\<dots>,d'] \\<subseteq> [\\<dots>n]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_subset)"], ["", "lemma not_iIN_iMODb_subset: \"\\<lbrakk> 0 < d'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [n'\\<dots>,d'] \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> [n'\\<dots>,d'] \\<subseteq> [ r, mod m, c ]", "apply (rule Suc_in_imp_not_subset_iMODb[of n'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> n' \\<in> [n'\\<dots>,d']\n 2. \\<lbrakk>0 < d'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc n' \\<in> [n'\\<dots>,d']\n 3. \\<lbrakk>0 < d'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> m \\<noteq> Suc 0", "apply (simp add: iIN_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_iIN_iMOD_subset: \"\\<lbrakk> 0 < d'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [n'\\<dots>,d'] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0;\n     [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (case_tac \"r \\<le> n' + d'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0;\n     [n'\\<dots>,d'] \\<subseteq> [ r, mod m ]; r \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>0 < d'; m \\<noteq> Suc 0;\n     [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     \\<not> r \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule Int_greatest[OF _ iIN_iTILL_subset[OF order_refl]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0; r \\<le> n' + d';\n     [n'\\<dots>,d']\n     \\<subseteq> [ r, mod m ] \\<inter> [\\<dots>n' + d']\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>0 < d'; m \\<noteq> Suc 0;\n     [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     \\<not> r \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: iMOD_iTILL_iMODb_conv not_iIN_iMODb_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0;\n     [n'\\<dots>,d'] \\<subseteq> [ r, mod m ];\n     \\<not> r \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule subsetD[of _ _ \"n'+d'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d'; m \\<noteq> Suc 0; \\<not> r \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> n' + d' \\<in> [n'\\<dots>,d']\n 2. \\<lbrakk>0 < d'; m \\<noteq> Suc 0; \\<not> r \\<le> n' + d';\n     n' + d' \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: iT_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_subset: \"n' \\<le> n \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<le> n \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [\\<dots>n]", "by (rule iTILL_subset_conv[THEN iffD2])"], ["", "lemma iTILL_iFROM_subset: \"([\\<dots>n'] \\<subseteq> [0\\<dots>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n'] \\<subseteq> [0\\<dots>]", "by (simp add: iFROM_0)"], ["", "lemma iTILL_iIN_subset: \"n' \\<le> d \\<Longrightarrow> ([\\<dots>n'] \\<subseteq> [0\\<dots>,d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<le> d \\<Longrightarrow> [\\<dots>n'] \\<subseteq> [0\\<dots>,d]", "by (simp add: iIN_0_iTILL_conv iTILL_subset)"], ["", "lemma not_iTILL_iMOD_subset: \"\n  \\<lbrakk> 0 < n'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [\\<dots>n'] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> [\\<dots>n'] \\<subseteq> [ r, mod m ]", "by (simp add: iIN_0_iTILL_conv[symmetric] not_iIN_iMOD_subset)"], ["", "lemma not_iTILL_iMODb_subset: \"\n  \\<lbrakk> 0 < n'; m \\<noteq> Suc 0 \\<rbrakk> \\<Longrightarrow> \\<not> [\\<dots>n'] \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n'; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> [\\<dots>n'] \\<subseteq> [ r, mod m, c ]", "by (simp add: iIN_0_iTILL_conv[symmetric] not_iIN_iMODb_subset)"], ["", "lemma iMOD_iFROM_subset: \"n \\<le> r' \\<Longrightarrow> [r', mod m'] \\<subseteq> [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> r' \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [n\\<dots>]", "by (rule iMOD_iFROM_subset_conv[THEN iffD2])"], ["", "lemma not_iMOD_iIN_subset: \"0 < m' \\<Longrightarrow> \\<not> [r', mod m'] \\<subseteq> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m' \\<Longrightarrow> \\<not> [ r', mod m' ] \\<subseteq> [n\\<dots>,d]", "by (rule infinite_not_subset_finite[OF iMOD_infinite iIN_finite])"], ["", "lemma not_iMOD_iTILL_subset: \"0 < m' \\<Longrightarrow> \\<not> [r', mod m'] \\<subseteq> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m' \\<Longrightarrow> \\<not> [ r', mod m' ] \\<subseteq> [\\<dots>n]", "by (rule infinite_not_subset_finite[OF iMOD_infinite iTILL_finite])"], ["", "lemma iMOD_subset: \"\n  \\<lbrakk> r \\<le> r'; r' mod m = r mod m; m' mod m = 0 \\<rbrakk> \\<Longrightarrow> [r', mod m'] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (case_tac \"m = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMOD_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_iMOD_iMODb_subset: \"0 < m' \\<Longrightarrow> \\<not> [r', mod m'] \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m' \\<Longrightarrow>\n    \\<not> [ r', mod m' ] \\<subseteq> [ r, mod m, c ]", "by (rule infinite_not_subset_finite[OF iMOD_infinite iMODb_finite])"], ["", "lemma iMODb_iFROM_subset: \"n \\<le> r' \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> r' \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [n\\<dots>]", "by (rule iMODb_iFROM_subset_conv[THEN iffD2])"], ["", "lemma iMODb_iTILL_subset: \"\n  r' + m' * c' \\<le> n \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' + m' * c' \\<le> n \\<Longrightarrow>\n    [ r', mod m', c' ] \\<subseteq> [\\<dots>n]", "by (rule iMODb_iTILL_subset_conv[THEN iffD2])"], ["", "lemma iMODb_iIN_subset: \"\n  \\<lbrakk> n \\<le> r'; r' + m' * c' \\<le> n + d \\<rbrakk> \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> r'; r' + m' * c' \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [n\\<dots>,d]", "by (simp add: iMODb_iIN_subset_conv)"], ["", "lemma iMODb_iMOD_subset: \"\n  \\<lbrakk> r \\<le> r'; r' mod m = r mod m; m' mod m = 0 \\<rbrakk> \\<Longrightarrow> [r', mod m', c'] \\<subseteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (case_tac \"c' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0; c' = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]\n 2. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     c' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMODb_0 iIN_0 iMOD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     c' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m ]", "apply (simp add: iMODb_iMOD_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_subset: \"\n  \\<lbrakk> r \\<le> r'; r' mod m = r mod m; m' mod m = 0; r' + m' * c' \\<le> r + m * c \\<rbrakk> \\<Longrightarrow> \n  [r', mod m', c'] \\<subseteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (case_tac \"m' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m' = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]\n 2. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (simp add: iMODb_mod_0 iIN_0 iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (case_tac \"c' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m' \\<noteq> 0; c' = 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]\n 2. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m' \\<noteq> 0; c' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (simp add: iMODb_0 iIN_0 iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r' mod m = r mod m; m' mod m = 0;\n     r' + m' * c' \\<le> r + m * c; m' \\<noteq> 0; c' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c' ] \\<subseteq> [ r, mod m, c ]", "apply (simp add: iMODb_subset_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iFROM_trans: \"\\<lbrakk> y \\<in> [x\\<dots>]; z \\<in> [y\\<dots>] \\<rbrakk> \\<Longrightarrow> z \\<in> [x\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [x\\<dots>]; z \\<in> [y\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> z \\<in> [x\\<dots>]", "by (rule subsetD[OF iFROM_subset[OF iFROM_D]])"], ["", "lemma iTILL_trans: \"\\<lbrakk> y \\<in> [\\<dots>x]; z \\<in> [\\<dots>y] \\<rbrakk> \\<Longrightarrow> z \\<in> [\\<dots>x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [\\<dots>x]; z \\<in> [\\<dots>y]\\<rbrakk>\n    \\<Longrightarrow> z \\<in> [\\<dots>x]", "by (rule subsetD[OF iTILL_subset[OF iTILL_D]])"], ["", "lemma iIN_trans: \"\n  \\<lbrakk> y \\<in> [x\\<dots>,d]; z \\<in> [y\\<dots>,d']; d' \\<le> x + d - y \\<rbrakk> \\<Longrightarrow> z \\<in> [x\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [x\\<dots>,d]; z \\<in> [y\\<dots>,d'];\n     d' \\<le> x + d - y\\<rbrakk>\n    \\<Longrightarrow> z \\<in> [x\\<dots>,d]", "by fastforce"], ["", "lemma iMOD_trans: \"\n  \\<lbrakk> y \\<in> [x, mod m]; z \\<in> [y, mod m] \\<rbrakk> \\<Longrightarrow> z \\<in> [x, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m ]; z \\<in> [ y, mod m ]\\<rbrakk>\n    \\<Longrightarrow> z \\<in> [ x, mod m ]", "by (rule subsetD[OF iMOD_subset[OF iMOD_geD iMOD_modD mod_self]])"], ["", "lemma iMODb_trans: \"\n  \\<lbrakk> y \\<in> [x, mod m, c]; z \\<in> [y, mod m, c']; m * c' \\<le> x + m * c - y \\<rbrakk> \\<Longrightarrow> \n  z \\<in> [x, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ];\n     m * c' \\<le> x + m * c - y\\<rbrakk>\n    \\<Longrightarrow> z \\<in> [ x, mod m, c ]", "by fastforce"], ["", "lemma iMODb_trans': \"\n  \\<lbrakk> y \\<in> [x, mod m, c]; z \\<in> [y, mod m, c']; c' \\<le> x div m + c - y div m \\<rbrakk> \\<Longrightarrow> \n  z \\<in> [x, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ];\n     c' \\<le> x div m + c - y div m\\<rbrakk>\n    \\<Longrightarrow> z \\<in> [ x, mod m, c ]", "apply (rule iMODb_trans[where c'=c'], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ];\n     c' \\<le> x div m + c - y div m\\<rbrakk>\n    \\<Longrightarrow> m * c' \\<le> x + m * c - y", "apply (frule iMODb_geD, frule div_le_mono[of x y m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ];\n     c' \\<le> x div m + c - y div m; x \\<le> y;\n     x div m \\<le> y div m\\<rbrakk>\n    \\<Longrightarrow> m * c' \\<le> x + m * c - y", "apply (simp add: add.commute[of _ c] add.commute[of _ \"m*c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ];\n     c' \\<le> c + x div m - y div m; x \\<le> y;\n     x div m \\<le> y div m\\<rbrakk>\n    \\<Longrightarrow> m * c' \\<le> m * c + x - y", "apply (drule mult_le_mono[OF le_refl, of _ _ m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ]; x \\<le> y;\n     x div m \\<le> y div m;\n     m * c' \\<le> m * (c + x div m - y div m)\\<rbrakk>\n    \\<Longrightarrow> m * c' \\<le> m * c + x - y", "apply (simp add: add_mult_distrib2 diff_mult_distrib2 minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> [ x, mod m, c ]; z \\<in> [ y, mod m, c' ]; x \\<le> y;\n     x div m \\<le> y div m;\n     m * c' \\<le> m * c + x - (x mod m + y - y mod m)\\<rbrakk>\n    \\<Longrightarrow> m * c' \\<le> m * c + x - y", "apply (simp add: iMODb_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Equality of intervals\\<close>"], ["", "lemma iFROM_eq_conv: \"([n\\<dots>] = [n'\\<dots>]) = (n = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>] = [n'\\<dots>]) = (n = n')", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n\\<dots>] = [n'\\<dots>] \\<Longrightarrow> n = n'\n 2. n = n' \\<Longrightarrow> [n\\<dots>] = [n'\\<dots>]", "apply (drule set_eq_subset[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n\\<dots>] \\<subseteq> [n'\\<dots>] \\<and>\n    [n'\\<dots>] \\<subseteq> [n\\<dots>] \\<Longrightarrow>\n    n = n'\n 2. n = n' \\<Longrightarrow> [n\\<dots>] = [n'\\<dots>]", "apply (simp add: iFROM_subset_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n' \\<Longrightarrow> [n\\<dots>] = [n'\\<dots>]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_eq_conv: \"([n\\<dots>,d] = [n'\\<dots>,d']) = (n = n' \\<and> d = d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>,d] = [n'\\<dots>,d']) = (n = n' \\<and> d = d')", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n\\<dots>,d] = [n'\\<dots>,d'] \\<Longrightarrow> n = n' \\<and> d = d'\n 2. n = n' \\<and> d = d' \\<Longrightarrow> [n\\<dots>,d] = [n'\\<dots>,d']", "apply (drule set_eq_subset[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. [n\\<dots>,d] \\<subseteq> [n'\\<dots>,d'] \\<and>\n    [n'\\<dots>,d'] \\<subseteq> [n\\<dots>,d] \\<Longrightarrow>\n    n = n' \\<and> d = d'\n 2. n = n' \\<and> d = d' \\<Longrightarrow> [n\\<dots>,d] = [n'\\<dots>,d']", "apply (simp add: iIN_subset_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n' \\<and> d = d' \\<Longrightarrow> [n\\<dots>,d] = [n'\\<dots>,d']", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_eq_conv: \"([\\<dots>n] = [\\<dots>n']) = (n = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<dots>n] = [\\<dots>n']) = (n = n')", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_eq_conv)"], ["", "lemma iMOD_0_eq_conv: \"([r, mod 0] = [r', mod m']) = (r = r' \\<and> m' = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod 0 ] = [ r', mod m' ]) = (r = r' \\<and> m' = 0)", "apply (simp add: iMOD_0 iIN_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({r} = [ r', mod m' ]) = (r = r' \\<and> m' = 0)", "apply (simp add: iMOD_singleton_eq_conv eq_sym_conv[of \"{r}\"] eq_sym_conv[of \"r\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_eq_conv: \"0 < m \\<Longrightarrow> ([r, mod m] = [r', mod m']) = (r = r' \\<and> m = m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    ([ r, mod m ] = [ r', mod m' ]) = (r = r' \\<and> m = m')", "apply (case_tac \"m' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; m' = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] = [ r', mod m' ]) =\n                      (r = r' \\<and> m = m')\n 2. \\<lbrakk>0 < m; m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] = [ r', mod m' ]) =\n                      (r = r' \\<and> m = m')", "apply (simp add: eq_sym_conv[of \"[r, mod m]\"] iMOD_0_eq_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] = [ r', mod m' ]) =\n                      (r = r' \\<and> m = m')", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; m' \\<noteq> 0; [ r, mod m ] = [ r', mod m' ]\\<rbrakk>\n    \\<Longrightarrow> r = r' \\<and> m = m'\n 2. \\<lbrakk>0 < m; m' \\<noteq> 0; r = r' \\<and> m = m'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] = [ r', mod m' ]", "apply (fastforce simp add: set_eq_subset iMOD_subset_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m' \\<noteq> 0; r = r' \\<and> m = m'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] = [ r', mod m' ]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_mod_0_eq_conv: \"\n  ([r, mod 0, c] = [r', mod m', c']) = (r = r' \\<and> (m' = 0 \\<or> c' = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod 0, c ] = [ r', mod m', c' ]) =\n    (r = r' \\<and> (m' = 0 \\<or> c' = 0))", "apply (simp add: iMODb_mod_0 iIN_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({r} = [ r', mod m', c' ]) = (r = r' \\<and> (m' = 0 \\<or> c' = 0))", "apply (fastforce simp: iMODb_singleton_eq_conv eq_sym_conv[of \"{r}\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_0_eq_conv: \"\n  ([r, mod m, 0] = [r', mod m', c']) = (r = r' \\<and> (m' = 0 \\<or> c' = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m, 0 ] = [ r', mod m', c' ]) =\n    (r = r' \\<and> (m' = 0 \\<or> c' = 0))", "apply (simp add: iMODb_0 iIN_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({r} = [ r', mod m', c' ]) = (r = r' \\<and> (m' = 0 \\<or> c' = 0))", "apply (fastforce simp: iMODb_singleton_eq_conv eq_sym_conv[of \"{r}\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_eq_conv: \"\\<lbrakk> 0 < m; 0 < c \\<rbrakk> \\<Longrightarrow> \n  ([r, mod m, c] = [r', mod m', c']) = (r = r' \\<and> m = m' \\<and> c = c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; 0 < c\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m, c ] = [ r', mod m', c' ]) =\n                      (r = r' \\<and> m = m' \\<and> c = c')", "apply (case_tac \"c' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; 0 < c; c' = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m, c ] = [ r', mod m', c' ]) =\n                      (r = r' \\<and> m = m' \\<and> c = c')\n 2. \\<lbrakk>0 < m; 0 < c; c' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m, c ] = [ r', mod m', c' ]) =\n                      (r = r' \\<and> m = m' \\<and> c = c')", "apply (simp add: iMODb_0 iIN_0 iMODb_singleton_eq_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; 0 < c; c' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m, c ] = [ r', mod m', c' ]) =\n                      (r = r' \\<and> m = m' \\<and> c = c')", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; 0 < c; c' \\<noteq> 0;\n     [ r, mod m, c ] = [ r', mod m', c' ]\\<rbrakk>\n    \\<Longrightarrow> r = r' \\<and> m = m' \\<and> c = c'\n 2. \\<lbrakk>0 < m; 0 < c; c' \\<noteq> 0;\n     r = r' \\<and> m = m' \\<and> c = c'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] = [ r', mod m', c' ]", "apply (fastforce simp: set_eq_subset iMODb_subset_conv')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; 0 < c; c' \\<noteq> 0;\n     r = r' \\<and> m = m' \\<and> c = c'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] = [ r', mod m', c' ]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_iFROM_eq_conv: \"([n\\<dots>] = [r, mod m]) = (n = r \\<and> m = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>] = [ r, mod m ]) = (n = r \\<and> m = Suc 0)", "by (fastforce simp: iMOD_1[symmetric] iMOD_eq_conv)"], ["", "lemma iMODb_iIN_0_eq_conv: \"\n  ([n\\<dots>,0] = [r, mod m, c]) = (n = r \\<and> (m = 0 \\<or> c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>,0] = [ r, mod m, c ]) = (n = r \\<and> (m = 0 \\<or> c = 0))", "by (simp add: iIN_0 eq_commute[of \"{n}\"] eq_commute[of n] iMODb_singleton_eq_conv)"], ["", "lemma iMODb_iIN_eq_conv: \"\n  0 < d \\<Longrightarrow> ([n\\<dots>,d] = [r, mod m, c]) = (n = r \\<and> m = Suc 0 \\<and> c = d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    ([n\\<dots>,d] = [ r, mod m, c ]) = (n = r \\<and> m = Suc 0 \\<and> c = d)", "by (fastforce simp: iMODb_mod_1[symmetric] iMODb_eq_conv)"], ["", "subsubsection \\<open>Inequality of intervals\\<close>"], ["", "lemma iFROM_iIN_neq: \"[n'\\<dots>] \\<noteq> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n'\\<dots>] \\<noteq> [n\\<dots>,d]", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> [n'\\<dots>] \\<noteq> [n\\<dots>,d] \\<Longrightarrow> False", "apply (insert iFROM_infinite[of n'], insert iIN_finite[of n d])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> [n'\\<dots>] \\<noteq> [n\\<dots>,d]; infinite [n'\\<dots>];\n     finite [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iFROM_iTILL_neq: \"[n'\\<dots>] \\<noteq> [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n'\\<dots>] \\<noteq> [\\<dots>n]", "by (simp add: iIN_0_iTILL_conv[symmetric] iFROM_iIN_neq)"], ["", "corollary iFROM_iMOD_neq: \"m \\<noteq> Suc 0 \\<Longrightarrow> [n\\<dots>] \\<noteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> Suc 0 \\<Longrightarrow> [n\\<dots>] \\<noteq> [ r, mod m ]", "apply (subgoal_tac \"n \\<in> [n\\<dots>]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> Suc 0; n \\<in> [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>] \\<noteq> [ r, mod m ]\n 2. m \\<noteq> Suc 0 \\<Longrightarrow> n \\<in> [n\\<dots>]", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<noteq> Suc 0 \\<Longrightarrow> n \\<in> [n\\<dots>]\n 2. \\<lbrakk>m \\<noteq> Suc 0; n \\<in> [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>] \\<noteq> [ r, mod m ]", "apply (simp add: iFROM_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; n \\<in> [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>] \\<noteq> [ r, mod m ]", "apply (simp add: Suc_in_imp_neq_iMOD iFROM_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iFROM_iMODb_neq: \"[n\\<dots>] \\<noteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<noteq> [ r, mod m, c ]", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> [n\\<dots>] \\<noteq> [ r, mod m, c ] \\<Longrightarrow> False", "apply (insert iMODb_finite[of r m c], insert iFROM_infinite[of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> [n\\<dots>] \\<noteq> [ r, mod m, c ];\n     finite [ r, mod m, c ]; infinite [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iIN_iMOD_neq: \"0 < m \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m ]", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; \\<not> [n\\<dots>,d] \\<noteq> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (insert iMOD_infinite[of m r], insert iIN_finite[of n d])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; \\<not> [n\\<dots>,d] \\<noteq> [ r, mod m ];\n     0 < m \\<Longrightarrow> infinite [ r, mod m ];\n     finite [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iIN_iMODb_neq2: \"\\<lbrakk> m \\<noteq> Suc 0; 0 < d \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; 0 < d\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (subgoal_tac \"n \\<in> [n\\<dots>,d]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> Suc 0; 0 < d; n \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]\n 2. \\<lbrakk>m \\<noteq> Suc 0; 0 < d\\<rbrakk>\n    \\<Longrightarrow> n \\<in> [n\\<dots>,d]", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> Suc 0; 0 < d\\<rbrakk>\n    \\<Longrightarrow> n \\<in> [n\\<dots>,d]\n 2. \\<lbrakk>m \\<noteq> Suc 0; 0 < d; n \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (simp add: iIN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; 0 < d; n \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (simp add: Suc_in_imp_neq_iMODb iIN_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_iMODb_neq: \"\\<lbrakk> 2 \\<le> m; 0 < c \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 \\<le> m; 0 < c\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (simp add: nat_ge2_conv, elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; 0 < m; m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (case_tac \"d=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < m; m \\<noteq> Suc 0; d = 0\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]\n 2. \\<lbrakk>0 < c; 0 < m; m \\<noteq> Suc 0; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (rule not_sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; 0 < m; m \\<noteq> Suc 0; d = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<noteq> [n\\<dots>,d]\n 2. \\<lbrakk>0 < c; 0 < m; m \\<noteq> Suc 0; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (simp add: iIN_0 iMODb_singleton_eq_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; 0 < m; m \\<noteq> Suc 0; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<noteq> [ r, mod m, c ]", "apply (simp add: iIN_iMODb_neq2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_iIN_neq: \"0 < n \\<Longrightarrow> [\\<dots>n'] \\<noteq> [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> [\\<dots>n'] \\<noteq> [n\\<dots>,d]", "by (fastforce simp: set_eq_iff iT_iff)"], ["", "corollary iTILL_iMOD_neq: \"0 < m \\<Longrightarrow> [\\<dots>n] \\<noteq> [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> [\\<dots>n] \\<noteq> [ r, mod m ]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_iMOD_neq)"], ["", "corollary iTILL_iMODb_neq: \"\n  \\<lbrakk> m \\<noteq> Suc 0; 0 < n \\<rbrakk> \\<Longrightarrow> [\\<dots>n] \\<noteq> [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; 0 < n\\<rbrakk>\n    \\<Longrightarrow> [\\<dots>n] \\<noteq> [ r, mod m, c ]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_iMODb_neq2)"], ["", "lemma iMOD_iMODb_neq: \"0 < m \\<Longrightarrow> [r, mod m] \\<noteq> [r', mod m', c']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> [ r, mod m ] \\<noteq> [ r', mod m', c' ]", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; \\<not> [ r, mod m ] \\<noteq> [ r', mod m', c' ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (insert iMODb_finite[of r' m' c'], insert iMOD_infinite[of m r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; \\<not> [ r, mod m ] \\<noteq> [ r', mod m', c' ];\n     finite [ r', mod m', c' ];\n     0 < m \\<Longrightarrow> infinite [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_neq = \n  iFROM_iTILL_neq iFROM_iIN_neq iFROM_iMOD_neq iFROM_iMODb_neq\n  iTILL_iIN_neq iTILL_iMOD_neq iTILL_iMODb_neq\n  iIN_iMOD_neq  iIN_iMODb_neq iIN_iMODb_neq2\n  iMOD_iMODb_neq"], ["", "subsection \\<open>Union and intersection of intervals\\<close>"], ["", "lemma iFROM_union': \"[n\\<dots>] \\<union> [n'\\<dots>] = [min n n'\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<union> [n'\\<dots>] = [min n n'\\<dots>]", "by (fastforce simp: iFROM_iff)"], ["", "corollary iFROM_union: \"n \\<le> n' \\<Longrightarrow> [n\\<dots>] \\<union> [n'\\<dots>] = [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<Longrightarrow>\n    [n\\<dots>] \\<union> [n'\\<dots>] = [n\\<dots>]", "by (simp add: iFROM_union' min_eqL)"], ["", "lemma iFROM_inter': \"[n\\<dots>] \\<inter> [n'\\<dots>] = [max n n'\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<inter> [n'\\<dots>] = [max n n'\\<dots>]", "by (fastforce simp: iFROM_iff)"], ["", "corollary iFROM_inter: \"n' \\<le> n \\<Longrightarrow> [n\\<dots>] \\<inter> [n'\\<dots>] = [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<le> n \\<Longrightarrow>\n    [n\\<dots>] \\<inter> [n'\\<dots>] = [n\\<dots>]", "by (simp add: iFROM_inter' max_eqL)"], ["", "lemma iTILL_union': \"[\\<dots>n] \\<union> [\\<dots>n'] = [\\<dots>max n n']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<union> [\\<dots>n'] = [\\<dots>max n n']", "by (fastforce simp: iTILL_iff)"], ["", "corollary iTILL_union: \"n' \\<le> n \\<Longrightarrow> [\\<dots>n] \\<union> [\\<dots>n'] = [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<le> n \\<Longrightarrow>\n    [\\<dots>n] \\<union> [\\<dots>n'] = [\\<dots>n]", "by (simp add: iTILL_union' max_eqL)"], ["", "lemma iTILL_iFROM_union: \"n \\<le> n' \\<Longrightarrow> [\\<dots>n'] \\<union> [n\\<dots>] = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<Longrightarrow> [\\<dots>n'] \\<union> [n\\<dots>] = UNIV", "by (fastforce simp: iT_iff)"], ["", "lemma iTILL_inter': \"[\\<dots>n] \\<inter> [\\<dots>n'] = [\\<dots>min n n']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<inter> [\\<dots>n'] = [\\<dots>min n n']", "by (fastforce simp: iT_iff)"], ["", "corollary iTILL_inter: \"n \\<le> n' \\<Longrightarrow> [\\<dots>n] \\<inter> [\\<dots>n'] = [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n' \\<Longrightarrow>\n    [\\<dots>n] \\<inter> [\\<dots>n'] = [\\<dots>n]", "by (simp add: iTILL_inter' min_eqL)"], ["", "text \\<open>\n  Union and intersection for iIN \n  only when there intersection is not empty and \n  none of them is other's subset,\n  for instance: \n  ..  n    ..   n+d\n  ..      n'    ..   n'+d'\n\\<close>"], ["", "lemma iIN_union: \"\n  \\<lbrakk> n \\<le> n'; n' \\<le> Suc (n + d); n + d \\<le> n' + d' \\<rbrakk> \\<Longrightarrow> \n  [n\\<dots>,d] \\<union> [n'\\<dots>,d'] = [n\\<dots>,n' - n + d'] \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> n'; n' \\<le> Suc (n + d); n + d \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<union> [n'\\<dots>,d'] =\n                      [n\\<dots>,n' - n + d']", "by (fastforce simp add: iIN_iff)"], ["", "(* The case of the second interval starting directly after the first one *)"], ["", "lemma iIN_append_union: \"\n  [n\\<dots>,d] \\<union> [n + d\\<dots>,d'] = [n\\<dots>,d + d']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<union> [n + d\\<dots>,d'] = [n\\<dots>,d + d']", "by (simp add: iIN_union)"], ["", "lemma iIN_append_union_Suc: \"\n  [n\\<dots>,d] \\<union> [Suc (n + d)\\<dots>,d'] = [n\\<dots>,Suc (d + d')]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<union> [Suc (n + d)\\<dots>,d'] = [n\\<dots>,Suc (d + d')]", "by (simp add: iIN_union)"], ["", "lemma iIN_append_union_pred: \"\n  0 < d \\<Longrightarrow> [n\\<dots>,d - Suc 0] \\<union> [n + d\\<dots>,d'] = [n\\<dots>,d + d']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    [n\\<dots>,d - Suc 0] \\<union> [n + d\\<dots>,d'] = [n\\<dots>,d + d']", "by (simp add: iIN_union)"], ["", "lemma iIN_iFROM_union: \"\n  n' \\<le> Suc (n + d) \\<Longrightarrow> [n\\<dots>,d] \\<union> [n'\\<dots>] = [min n n'\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<le> Suc (n + d) \\<Longrightarrow>\n    [n\\<dots>,d] \\<union> [n'\\<dots>] = [min n n'\\<dots>]", "by (fastforce simp: iIN_iff)"], ["", "lemma iIN_iFROM_append_union: \"\n  [n\\<dots>,d] \\<union> [n + d\\<dots>] = [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<union> [n + d\\<dots>] = [n\\<dots>]", "by (simp add: iIN_iFROM_union min_eqL)"], ["", "lemma iIN_iFROM_append_union_Suc: \"\n  [n\\<dots>,d] \\<union> [Suc (n + d)\\<dots>] = [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<union> [Suc (n + d)\\<dots>] = [n\\<dots>]", "by (simp add: iIN_iFROM_union min_eqL)"], ["", "lemma iIN_iFROM_append_union_pred: \"\n  0 < d \\<Longrightarrow> [n\\<dots>,d - Suc 0] \\<union> [n + d\\<dots>] = [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    [n\\<dots>,d - Suc 0] \\<union> [n + d\\<dots>] = [n\\<dots>]", "by (simp add: iIN_iFROM_union min_eqL)"], ["", "lemma iIN_inter: \"\n  \\<lbrakk> n \\<le> n'; n' \\<le> n + d; n + d \\<le> n' + d' \\<rbrakk> \\<Longrightarrow>\n  [n\\<dots>,d] \\<inter> [n'\\<dots>,d'] = [n'\\<dots>,n + d - n']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> n'; n' \\<le> n + d; n + d \\<le> n' + d'\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<inter> [n'\\<dots>,d'] =\n                      [n'\\<dots>,n + d - n']", "by (fastforce simp: iIN_iff)"], ["", "lemma iMOD_union: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m \\<rbrakk> \\<Longrightarrow>\n  [r, mod m] \\<union> [r', mod m] = [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r mod m = r' mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<union> [ r', mod m ] = [ r, mod m ]", "by (fastforce simp: iT_iff)"], ["", "lemma iMOD_union': \"\n  r mod m = r' mod m \\<Longrightarrow>\n  [r, mod m] \\<union> [r', mod m] = [min r r', mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r mod m = r' mod m \\<Longrightarrow>\n    [ r, mod m ] \\<union> [ r', mod m ] = [ min r r', mod m ]", "apply (case_tac \"r \\<le> r'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r mod m = r' mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<union> [ r', mod m ] =\n                      [ min r r', mod m ]\n 2. \\<lbrakk>r mod m = r' mod m; \\<not> r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<union> [ r', mod m ] =\n                      [ min r r', mod m ]", "apply (fastforce simp: iMOD_union min_eq)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_inter: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m \\<rbrakk> \\<Longrightarrow>\n  [r, mod m] \\<inter> [r', mod m] = [r', mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r mod m = r' mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [ r', mod m ] = [ r', mod m ]", "by (fastforce simp: iT_iff)"], ["", "lemma iMOD_inter': \"\n  r mod m = r' mod m \\<Longrightarrow> \n  [r, mod m] \\<inter> [r', mod m] = [max r r', mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r mod m = r' mod m \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [ r', mod m ] = [ max r r', mod m ]", "apply (case_tac \"r \\<le> r'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r mod m = r' mod m; r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [ r', mod m ] =\n                      [ max r r', mod m ]\n 2. \\<lbrakk>r mod m = r' mod m; \\<not> r \\<le> r'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [ r', mod m ] =\n                      [ max r r', mod m ]", "apply (fastforce simp: iMOD_inter max_eq)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_union: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c; r + m * c \\<le> r' + m * c' \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<union> [r', mod m, c'] = [r, mod m, r' div m - r div m + c']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n     r + m * c \\<le> r' + m * c'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r', mod m, c' ] =\n                      [ r, mod m, r' div m - r div m + c' ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> [ r, mod m, c ] \\<union>\n                                  [ r', mod m, c' ]) =\n                         (x \\<in> [ r, mod m, r' div m - r div m + c' ])", "apply (simp add: iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n                          x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * (r' div m - r div m + c'))", "apply (drule sym[of \"r mod m\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r' \\<le> r + m * c; r + m * c \\<le> r' + m * c';\n        r' mod m = r mod m\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and>\n                          r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n                          x mod m = r mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * (r' div m - r div m + c'))", "apply (fastforce simp: add_mult_distrib2 diff_mult_distrib2 minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_append_union: \"\n  [r, mod m, c] \\<union> [ r + m * c, mod m, c'] = [r, mod m, c + c']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<union> [ r + m * c, mod m, c' ] = [ r, mod m, c + c' ]", "apply (insert iMODb_union[of r \"r + m * c\" m c c'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<le> r + m * c; r mod m = (r + m * c) mod m;\n      r + m * c \\<le> r + m * c; r + m * c \\<le> r + m * c + m * c'\\<rbrakk>\n     \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r + m * c, mod m, c' ] =\n                       [ r, mod m, (r + m * c) div m - r div m +\n                                   c' ]) \\<Longrightarrow>\n    [ r, mod m, c ] \\<union> [ r + m * c, mod m, c' ] = [ r, mod m, c + c' ]", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>r \\<le> r + m * c; r mod m = (r + m * c) mod m;\n              r + m * c \\<le> r + m * c;\n              r + m * c \\<le> r + m * c + m * c'\\<rbrakk>\n             \\<Longrightarrow> [ r, mod m, c ] \\<union>\n                               [ r + m * c, mod m, c' ] =\n                               [ r, mod m, (r + m * c) div m - r div m +\n     c' ];\n     m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r + m * c, mod m, c' ] =\n                      [ r, mod m, c + c' ]\n 2. \\<lbrakk>\\<lbrakk>r \\<le> r + m * c; r mod m = (r + m * c) mod m;\n              r + m * c \\<le> r + m * c;\n              r + m * c \\<le> r + m * c + m * c'\\<rbrakk>\n             \\<Longrightarrow> [ r, mod m, c ] \\<union>\n                               [ r + m * c, mod m, c' ] =\n                               [ r, mod m, (r + m * c) div m - r div m +\n     c' ];\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r + m * c, mod m, c' ] =\n                      [ r, mod m, c + c' ]", "apply (simp add: iMODb_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>r \\<le> r + m * c; r mod m = (r + m * c) mod m;\n              r + m * c \\<le> r + m * c;\n              r + m * c \\<le> r + m * c + m * c'\\<rbrakk>\n             \\<Longrightarrow> [ r, mod m, c ] \\<union>\n                               [ r + m * c, mod m, c' ] =\n                               [ r, mod m, (r + m * c) div m - r div m +\n     c' ];\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r + m * c, mod m, c' ] =\n                      [ r, mod m, c + c' ]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_iMOD_append_union': \"\n  \\<lbrakk> r mod m = r' mod m; r' \\<le> r + m * Suc c \\<rbrakk>  \\<Longrightarrow> \n  [r, mod m, c] \\<union> [ r', mod m ] = [min r r', mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r', mod m ] =\n                      [ min r r', mod m ]", "apply (subgoal_tac \"(min r r') mod m = r' mod m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c;\n     min r r' mod m = r' mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r', mod m ] =\n                      [ min r r', mod m ]\n 2. \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c\\<rbrakk>\n    \\<Longrightarrow> min r r' mod m = r' mod m", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c\\<rbrakk>\n    \\<Longrightarrow> min r r' mod m = r' mod m\n 2. \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c;\n     min r r' mod m = r' mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r', mod m ] =\n                      [ min r r', mod m ]", "apply (simp add: min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c;\n     min r r' mod m = r' mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r', mod m ] =\n                      [ min r r', mod m ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r mod m = r' mod m; r' \\<le> r + m * Suc c;\n        min r r' mod m = r' mod m\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> [ r, mod m, c ] \\<union> [ r', mod m ]) =\n                         (x \\<in> [ min r r', mod m ])", "apply (simp add: iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r mod m = r' mod m; r' \\<le> r + (m + m * c);\n        min r r' mod m = r' mod m\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n                          x mod m = r' mod m \\<and> r' \\<le> x) =\n                         (x mod m = r' mod m \\<and> min r r' \\<le> x)", "apply (drule sym[of \"r mod m\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and>\n                          r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n                          x mod m = r mod m \\<and> r' \\<le> x) =\n                         (x mod m = r mod m \\<and> min r r' \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m;\n        x mod m = r mod m \\<and> r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n        x mod m = r mod m \\<and> r' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and> min r r' \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m;\n        x mod m = r mod m \\<and> min r r' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n                         x mod m = r mod m \\<and> r' \\<le> x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m;\n        x mod m = r mod m \\<and> min r r' \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m = r mod m \\<and>\n                         r \\<le> x \\<and> x \\<le> r + m * c \\<or>\n                         x mod m = r mod m \\<and> r' \\<le> x", "apply (clarsimp simp: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m; x mod m = r mod m; min r r' \\<le> x;\n        x < r'\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> x \\<le> r + m * c", "apply (case_tac \"r \\<le> r'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m; x mod m = r mod m; min r r' \\<le> x; x < r';\n        r \\<le> r'\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> x \\<le> r + m * c\n 2. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m; x mod m = r mod m; min r r' \\<le> x; x < r';\n        \\<not> r \\<le> r'\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> x \\<le> r + m * c", "apply (simp add: min_eqL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); r' mod m = r mod m;\n        x mod m = r mod m; r \\<le> x; x < r'\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 2. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m; x mod m = r mod m; min r r' \\<le> x; x < r';\n        \\<not> r \\<le> r'\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> x \\<le> r + m * c", "apply (rule add_le_imp_le_right[of _ m])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); r' mod m = r mod m;\n        x mod m = r mod m; r \\<le> x; x < r'\\<rbrakk>\n       \\<Longrightarrow> x + m \\<le> r + m * c + m\n 2. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m; x mod m = r mod m; min r r' \\<le> x; x < r';\n        \\<not> r \\<le> r'\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> x \\<le> r + m * c", "apply (rule less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); r' mod m = r mod m;\n        x mod m = r mod m; r \\<le> x; x < r'\\<rbrakk>\n       \\<Longrightarrow> x < r + m * c + m\n 2. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); r' mod m = r mod m;\n        x mod m = r mod m; r \\<le> x; x < r'\\<rbrakk>\n       \\<Longrightarrow> x mod m = (r + m * c + m) mod m\n 3. \\<And>x.\n       \\<lbrakk>r' \\<le> r + (m + m * c); min r r' mod m = r mod m;\n        r' mod m = r mod m; x mod m = r mod m; min r r' \\<le> x; x < r';\n        \\<not> r \\<le> r'\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> x \\<le> r + m * c", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_iMOD_append_union: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * Suc c \\<rbrakk>  \\<Longrightarrow> \n  [r, mod m, c] \\<union> [ r', mod m ] = [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * Suc c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<union> [ r', mod m ] = [ r, mod m ]", "by (simp add: iMODb_iMOD_append_union' min_eqL)"], ["", "lemma iMODb_append_union_Suc: \"\n  [r, mod m, c] \\<union> [ r + m * Suc c, mod m, c'] = [r, mod m, Suc (c + c')]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<union> [ r + m * Suc c, mod m, c' ] =\n    [ r, mod m, Suc (c + c') ]", "apply (subst insert_absorb[of \"r + m * c\" \"[r, mod m, c] \\<union> [ r + m * Suc c, mod m, c']\", symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. r + m * c \\<in> [ r, mod m, c ] \\<union> [ r + m * Suc c, mod m, c' ]\n 2. insert (r + m * c)\n     ([ r, mod m, c ] \\<union> [ r + m * Suc c, mod m, c' ]) =\n    [ r, mod m, Suc (c + c') ]", "apply (simp add: iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (r + m * c)\n     ([ r, mod m, c ] \\<union> [ r + m * Suc c, mod m, c' ]) =\n    [ r, mod m, Suc (c + c') ]", "apply (simp del: Un_insert_right add: Un_insert_right[symmetric] add.commute[of m] add.assoc[symmetric] iMODb_Suc_pred_insert_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<union> [ r + m * c, mod m, Suc c' ] =\n    [ r, mod m, Suc (c + c') ]", "apply (simp add: iMODb_append_union)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_append_union_pred: \"\n  0 < c \\<Longrightarrow> [r, mod m, c - Suc 0] \\<union> [ r + m * c, mod m, c'] = [r, mod m, c + c']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    [ r, mod m, c - Suc 0 ] \\<union> [ r + m * c, mod m, c' ] =\n    [ r, mod m, c + c' ]", "by (insert iMODb_append_union_Suc[of r m \"c - Suc 0\" c'], simp)"], ["", "lemma iMODb_inter: \"\n  \\<lbrakk> r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c; r + m * c \\<le> r' + m * c' \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<inter> [r', mod m, c'] = [r', mod m, c - (r'-r) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n     r + m * c \\<le> r' + m * c'\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<inter> [ r', mod m, c' ] =\n                      [ r', mod m, c - (r' - r) div m ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> [ r, mod m, c ] \\<inter>\n                                  [ r', mod m, c' ]) =\n                         (x \\<in> [ r', mod m, c - (r' - r) div m ])", "apply (simp add: iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and>\n                          x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and>\n                          x \\<le> r' + m * (c - (r' - r) div m))", "apply (simp add: diff_mult_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and>\n                          x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and>\n                          x \\<le> r' + (m * c - m * ((r' - r) div m)))", "apply (simp add: mult.commute[of _ \"(r' - r) div m\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and>\n                          x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and>\n                          x \\<le> r' + (m * c - (r' - r) div m * m))", "apply (simp add: mod_0_div_mult_cancel[THEN iffD1, OF mod_eq_imp_diff_mod_0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and>\n                          x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> m * c + r)", "apply (simp add: add.commute[of _ r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<le> r'; r mod m = r' mod m; r' \\<le> r + m * c;\n        r + m * c \\<le> r' + m * c'\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r' mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and>\n                          x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r' + m * c') =\n                         (x mod m = r' mod m \\<and>\n                          r' \\<le> x \\<and> x \\<le> r + m * c)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_union' = \n  iFROM_union'\n  iTILL_union'\n  iMOD_union'\n  iMODb_iMOD_append_union'"], ["", "lemmas iT_union =\n  iFROM_union\n  iTILL_union\n  iTILL_iFROM_union\n  iIN_union\n  iIN_iFROM_union\n  iMOD_union\n  iMODb_union"], ["", "lemmas iT_union_append =\n  iIN_append_union\n  iIN_append_union_Suc\n  iIN_append_union_pred\n  iIN_iFROM_append_union\n  iIN_iFROM_append_union_Suc\n  iIN_iFROM_append_union_pred\n  iMODb_append_union\n  iMODb_iMOD_append_union\n  iMODb_append_union_Suc\n  iMODb_append_union_pred"], ["", "lemmas iT_inter' =\n  iFROM_inter'\n  iTILL_inter'\n  iMOD_inter'"], ["", "lemmas iT_inter =\n  iFROM_inter\n  iTILL_inter\n  iIN_inter\n  iMOD_inter\n  iMODb_inter"], ["", "lemma mod_partition_Union: \"\n  0 < m \\<Longrightarrow> (\\<Union>k. A \\<inter> [k * m\\<dots>,m - Suc 0]) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    (\\<Union>k. A \\<inter> [k * m\\<dots>,m - Suc 0]) = A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    A \\<inter> (\\<Union>x. [x * m\\<dots>,m - Suc 0]) = A", "apply (rule subst[where s=UNIV and P=\"\\<lambda>x. A \\<inter> x = A\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow> UNIV = (\\<Union>x. [x * m\\<dots>,m - Suc 0])\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (rule set_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       (x \\<in> UNIV) = (x \\<in> (\\<Union>x. [x * m\\<dots>,m - Suc 0]))\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (simp add: iT_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       \\<exists>xa. xa * m \\<le> x \\<and> x \\<le> xa * m + m - Suc 0\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (rule_tac x=\"x div m\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       x div m * m \\<le> x \\<and> x \\<le> x div m * m + m - Suc 0\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 < m \\<Longrightarrow> x \\<le> x + m - Suc (x mod m)\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (subst add.commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 < m \\<Longrightarrow> x \\<le> m + x - Suc (x mod m)\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (rule le_add_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 < m \\<Longrightarrow> Suc (x mod m) \\<le> m\n 2. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply (simp add: Suc_mod_le_divisor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> A \\<inter> UNIV = A", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_mod_partition_Union: \"\n  \\<lbrakk> 0 < m; finite A \\<rbrakk> \\<Longrightarrow>\n  (\\<Union>k\\<le>Max A div m. A \\<inter> [k*m\\<dots>,m - Suc 0]) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; finite A\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>k\\<le>Max A div m.\n                          A \\<inter> [k * m\\<dots>,m - Suc 0]) =\n                      A", "apply (rule subst[OF mod_partition_Union[of m], where\n  P=\"\\<lambda>x. (\\<Union>k\\<le>Max A div m. A \\<inter> [k*m\\<dots>,m - Suc 0]) = x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; finite A\\<rbrakk> \\<Longrightarrow> 0 < m\n 2. \\<lbrakk>0 < m; finite A\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>k\\<le>Max A div m.\n                          A \\<inter> [k * m\\<dots>,m - Suc 0]) =\n                      (\\<Union>k. A \\<inter> [k * m\\<dots>,m - Suc 0])", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; finite A\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>k\\<le>Max A div m.\n                          A \\<inter> [k * m\\<dots>,m - Suc 0]) =\n                      (\\<Union>k. A \\<inter> [k * m\\<dots>,m - Suc 0])", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; finite A\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> (\\<Union>k\\<le>Max A div m.\nA \\<inter> [k * m\\<dots>,m - Suc 0])) =\n                         (x \\<in> (\\<Union>k.\nA \\<inter> [k * m\\<dots>,m - Suc 0]))", "apply (simp add: iIN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; finite A\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> A \\<and>\n                          (\\<exists>xa\\<in>{..Max A div m}.\n                              xa * m \\<le> x \\<and>\n                              x \\<le> xa * m + m - Suc 0)) =\n                         (x \\<in> A \\<and>\n                          (\\<exists>xa.\n                              xa * m \\<le> x \\<and>\n                              x \\<le> xa * m + m - Suc 0))", "apply (rule iffI, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; finite A;\n        x \\<in> A \\<and>\n        (\\<exists>xa.\n            xa * m \\<le> x \\<and> x \\<le> xa * m + m - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A \\<and>\n                         (\\<exists>xa\\<in>{..Max A div m}.\n                             xa * m \\<le> x \\<and>\n                             x \\<le> xa * m + m - Suc 0)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; xa * m \\<le> x;\n        x \\<le> xa * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>{..Max A div m}.\n                            xa * m \\<le> x \\<and> x \\<le> xa * m + m - Suc 0", "apply (rename_tac x x1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>{..Max A div m}.\n                            xa * m \\<le> x \\<and> x \\<le> xa * m + m - Suc 0", "apply (rule_tac x=\"x div m\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m * m \\<le> x \\<and>\n                         x \\<le> x div m * m + m - Suc 0\n 2. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply (frule in_imp_not_empty[where A=A])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> x div m * m \\<le> x \\<and>\n                         x \\<le> x div m * m + m - Suc 0\n 2. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply (frule_tac Max_ge, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {}; x \\<le> Max A\\<rbrakk>\n       \\<Longrightarrow> x div m * m \\<le> x \\<and>\n                         x \\<le> x div m * m + m - Suc 0\n 2. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply (cut_tac n=x and k=\"x div m\" and m=m in div_imp_le_less)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {}; x \\<le> Max A\\<rbrakk>\n       \\<Longrightarrow> x div m = x div m\n 2. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {}; x \\<le> Max A\\<rbrakk>\n       \\<Longrightarrow> 0 < m\n 3. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {}; x \\<le> Max A;\n        x div m * m \\<le> x \\<and> x < Suc (x div m) * m\\<rbrakk>\n       \\<Longrightarrow> x div m * m \\<le> x \\<and>\n                         x \\<le> x div m * m + m - Suc 0\n 4. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply clarsimp+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {};\n        x < m + x div m * m\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x div m * m + m - Suc 0\n 2. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply (drule_tac m=x in less_imp_le_pred)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0; A \\<noteq> {};\n        x \\<le> m + x div m * m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x div m * m + m - Suc 0\n 2. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply (simp add: add.commute[of m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1.\n       \\<lbrakk>0 < m; finite A; x \\<in> A; x1 * m \\<le> x;\n        x \\<le> x1 * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m \\<in> {..Max A div m}", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_partition_is_disjoint: \"\n  \\<lbrakk> 0 < (m::nat); k \\<noteq> k' \\<rbrakk> \\<Longrightarrow> \n  (A \\<inter> [k * m\\<dots>,m - Suc 0]) \\<inter>  (A \\<inter> [k' * m\\<dots>,m - Suc 0]) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; k \\<noteq> k'\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [k * m\\<dots>,m - Suc 0] \\<inter>\n                      (A \\<inter> [k' * m\\<dots>,m - Suc 0]) =\n                      {}", "apply (clarsimp simp add: all_not_in_conv[symmetric] iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; k \\<noteq> k'; k' * m \\<le> x; x \\<in> A;\n        x \\<le> k * m + m - Suc 0; k * m \\<le> x;\n        x \\<le> k' * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"\\<And>k. \\<lbrakk> k * m \\<le> x; x \\<le> k * m + m - Suc 0 \\<rbrakk> \\<Longrightarrow> x div m = k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; k \\<noteq> k'; k' * m \\<le> x; x \\<in> A;\n        x \\<le> k * m + m - Suc 0; k * m \\<le> x;\n        x \\<le> k' * m + m - Suc 0;\n        \\<And>k.\n           \\<lbrakk>k * m \\<le> x; x \\<le> k * m + m - Suc 0\\<rbrakk>\n           \\<Longrightarrow> x div m = k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x ka.\n       \\<lbrakk>0 < m; k \\<noteq> k'; k' * m \\<le> x; x \\<in> A;\n        x \\<le> k * m + m - Suc 0; k * m \\<le> x;\n        x \\<le> k' * m + m - Suc 0; ka * m \\<le> x;\n        x \\<le> ka * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m = ka", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ka.\n       \\<lbrakk>0 < m; k \\<noteq> k'; k' * m \\<le> x; x \\<in> A;\n        x \\<le> k * m + m - Suc 0; k * m \\<le> x;\n        x \\<le> k' * m + m - Suc 0; ka * m \\<le> x;\n        x \\<le> ka * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x div m = ka", "apply (rule le_less_imp_div, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ka.\n       \\<lbrakk>0 < m; k \\<noteq> k'; k' * m \\<le> x; x \\<in> A;\n        x \\<le> k * m + m - Suc 0; k * m \\<le> x;\n        x \\<le> k' * m + m - Suc 0; ka * m \\<le> x;\n        x \\<le> ka * m + m - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x < Suc ka * m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Cutting intervals\\<close>"], ["", "(*\nlemma \"[10\\<dots>,5] \\<down>< 12 = [10\\<dots>,1]\"\napply (simp add: iT_iff cut_less_def)\napply (simp add: iT_defs set_interval_defs Collect_conj_eq[symmetric])\napply fastforce\ndone\n*)"], ["", "lemma iTILL_cut_le: \"[\\<dots>n] \\<down>\\<le> t = (if t \\<le> n then [\\<dots>t] else [\\<dots>n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<down>\\<le> t =\n    (if t \\<le> n then [\\<dots>t] else [\\<dots>n])", "unfolding i_cut_defs iT_defs atMost_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {x. x \\<le> n}. x \\<le> t} =\n    (if t \\<le> n then {x. x \\<le> t} else {x. x \\<le> n})", "by force"], ["", "corollary iTILL_cut_le1: \"t \\<in> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>\\<le> t = [\\<dots>t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [\\<dots>n] \\<Longrightarrow>\n    [\\<dots>n] \\<down>\\<le> t = [\\<dots>t]", "by (simp add: iTILL_cut_le iT_iff)"], ["", "corollary iTILL_cut_le2: \"t \\<notin> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>\\<le> t = [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> [\\<dots>n] \\<Longrightarrow>\n    [\\<dots>n] \\<down>\\<le> t = [\\<dots>n]", "by (simp add: iTILL_cut_le iT_iff)"], ["", "lemma iFROM_cut_le: \"\n  [n\\<dots>] \\<down>\\<le> t = \n  (if t < n then {} else [n\\<dots>,t-n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<down>\\<le> t = (if t < n then {} else [n\\<dots>,t - n])", "by (simp add: set_eq_iff i_cut_mem_iff iT_iff)"], ["", "corollary iFROM_cut_le1: \"t \\<in> [n\\<dots>] \\<Longrightarrow> [n\\<dots>] \\<down>\\<le> t = [n\\<dots>,t - n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>] \\<Longrightarrow>\n    [n\\<dots>] \\<down>\\<le> t = [n\\<dots>,t - n]", "by (simp add: iFROM_cut_le iT_iff)"], ["", "lemma iIN_cut_le: \"\n  [n\\<dots>,d] \\<down>\\<le> t = (\n  if t < n then {} else \n  if t \\<le> n+d then [n\\<dots>,t-n]\n  else [n\\<dots>,d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<down>\\<le> t =\n    (if t < n then {}\n     else if t \\<le> n + d then [n\\<dots>,t - n] else [n\\<dots>,d])", "by (force simp: set_eq_iff i_cut_mem_iff iT_iff)"], ["", "corollary iIN_cut_le1: \"\n  t \\<in> [n\\<dots>,d] \\<Longrightarrow> [n\\<dots>,d] \\<down>\\<le> t = [n\\<dots>,t - n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>,d] \\<Longrightarrow>\n    [n\\<dots>,d] \\<down>\\<le> t = [n\\<dots>,t - n]", "by (simp add: iIN_cut_le iT_iff)"], ["", "lemma iMOD_cut_le: \"\n  [r, mod m] \\<down>\\<le> t = (\n  if t < r then {} \n  else [r, mod m, (t - r) div m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<down>\\<le> t =\n    (if t < r then {} else [ r, mod m, (t - r) div m ])", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<le> t =\n    (if t < r then {} else [ r, mod m, (t - r) div m ])\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<le> t =\n    (if t < r then {} else [ r, mod m, (t - r) div m ])", "apply (simp add: iMOD_0 iMODb_0 iIN_0 i_cut_empty i_cut_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<le> t =\n    (if t < r then {} else [ r, mod m, (t - r) div m ])", "apply (case_tac \"t < r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>\\<le> t =\n                      (if t < r then {} else [ r, mod m, (t - r) div m ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>\\<le> t =\n                      (if t < r then {} else [ r, mod m, (t - r) div m ])", "apply (simp add: cut_le_Min_empty iMOD_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>\\<le> t =\n                      (if t < r then {} else [ r, mod m, (t - r) div m ])", "apply (clarsimp simp: linorder_not_less set_eq_iff i_cut_mem_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and>\n                          r \\<le> x \\<and> x \\<le> t) =\n                         (x mod m = r mod m \\<and>\n                          r \\<le> x \\<and> x \\<le> r + m * ((t - r) div m))", "apply (rule conj_cong, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) = (x \\<le> r + m * ((t - r) div m))", "apply (clarsimp simp: minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))", "apply (drule_tac x=r and y=x in le_imp_less_or_eq, erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r < x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r = x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r = x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r < x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r < x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))", "apply (drule_tac x=r and y=x and m=m in less_mod_eq_imp_add_divisor_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) =\n                         (x \\<le> r + (t - (r + (t - r) mod m)))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (t - (r + (t - r) mod m))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (rule_tac x=x in subst[OF mod_eq_imp_diff_mod_eq[of _ m r t], rule_format], simp+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (t - (r + (t - x) mod m))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (subgoal_tac \"r + (t - x) mod m \\<le> t\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t;\n        r + (t - x) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (t - (r + (t - x) mod m))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t\\<rbrakk>\n       \\<Longrightarrow> r + (t - x) mod m \\<le> t\n 3. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t\\<rbrakk>\n       \\<Longrightarrow> r + (t - x) mod m \\<le> t\n 2. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t;\n        r + (t - x) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (t - (r + (t - x) mod m))\n 3. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (simp add: order_trans[OF add_le_mono2[OF mod_le_divisor]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t;\n        r + (t - x) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + (t - (r + (t - x) mod m))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r + m \\<le> x; x \\<le> t;\n        r + (t - x) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t - (t - x) mod m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (simp add: le_imp_sub_mod_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (subgoal_tac \"r + (t - r) mod m \\<le> t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m));\n        r + (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> r + (t - r) mod m \\<le> t", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m))\\<rbrakk>\n       \\<Longrightarrow> r + (t - r) mod m \\<le> t\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m));\n        r + (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m));\n        \\<not> r + (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m));\n        r + (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; x mod m = r mod m; r + m \\<le> x;\n        x \\<le> r + (t - (r + (t - r) mod m));\n        r + (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_cut_le1: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> \n  [r, mod m] \\<down>\\<le> t = [r, mod m, (t - r) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<le> t = [ r, mod m, (t - r) div m ]", "by (simp add: iMOD_cut_le iT_iff)"], ["", "lemma iMODb_cut_le: \"\n  [r, mod m, c] \\<down>\\<le> t = (\n    if t < r then {} \n    else if t < r + m * c then [r, mod m, (t - r) div m]\n    else [r, mod m, c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<down>\\<le> t =\n    (if t < r then {}\n     else if t < r + m * c then [ r, mod m, (t - r) div m ]\n          else [ r, mod m, c ])", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<le> t =\n    (if t < r then {}\n     else if t < r + m * c then [ r, mod m, (t - r) div m ]\n          else [ r, mod m, c ])\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<le> t =\n    (if t < r then {}\n     else if t < r + m * c then [ r, mod m, (t - r) div m ]\n          else [ r, mod m, c ])", "apply (simp add: iMODb_mod_0 iIN_0 cut_le_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<le> t =\n    (if t < r then {}\n     else if t < r + m * c then [ r, mod m, (t - r) div m ]\n          else [ r, mod m, c ])", "apply (case_tac \"t < r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      (if t < r then {}\n                       else if t < r + m * c\n                            then [ r, mod m, (t - r) div m ]\n                            else [ r, mod m, c ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      (if t < r then {}\n                       else if t < r + m * c\n                            then [ r, mod m, (t - r) div m ]\n                            else [ r, mod m, c ])", "apply (simp add: cut_le_Min_empty iT_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      (if t < r then {}\n                       else if t < r + m * c\n                            then [ r, mod m, (t - r) div m ]\n                            else [ r, mod m, c ])", "apply (case_tac \"r + m * c \\<le> t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> t < r; r + m * c \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      (if t < r then {}\n                       else if t < r + m * c\n                            then [ r, mod m, (t - r) div m ]\n                            else [ r, mod m, c ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> t < r; \\<not> r + m * c \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      (if t < r then {}\n                       else if t < r + m * c\n                            then [ r, mod m, (t - r) div m ]\n                            else [ r, mod m, c ])", "apply (simp add: cut_le_Max_all iT_Max iT_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> t < r; \\<not> r + m * c \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      (if t < r then {}\n                       else if t < r + m * c\n                            then [ r, mod m, (t - r) div m ]\n                            else [ r, mod m, c ])", "apply (simp add: linorder_not_le linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> t; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t =\n                      [ r, mod m, (t - r) div m ]", "apply (rule_tac t=c and s=\"(r + m * c - r) div m\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> t; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, (r + m * c - r) div m ] \\<down>\\<le> t =\n                      [ r, mod m, (t - r) div m ]", "apply (subst iMOD_iTILL_iMODb_conv[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> t; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<inter>\n                       [\\<dots>r + m * c]) \\<down>\\<le>\n                      t =\n                      [ r, mod m, (t - r) div m ]", "apply (simp add: cut_le_Int_right iTILL_cut_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> t; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [\\<dots>t] =\n                      [ r, mod m, (t - r) div m ]", "apply (simp add: iMOD_iTILL_iMODb_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_cut_le1: \"\n  t \\<in> [r, mod m, c] \\<Longrightarrow> \n  [r, mod m, c] \\<down>\\<le> t = [r, mod m, (t - r) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m, c ] \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<le> t = [ r, mod m, (t - r) div m ]", "by (clarsimp simp: iMODb_cut_le iT_iff iMODb_mod_0)"], ["", "lemma iTILL_cut_less: \"\n  [\\<dots>n] \\<down>< t = (\n    if n < t then [\\<dots>n] else\n    if t = 0 then {} \n    else [\\<dots>t - Suc 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<down>< t =\n    (if n < t then [\\<dots>n] else if t = 0 then {} else [\\<dots>t - Suc 0])", "apply (case_tac \"n < t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < t \\<Longrightarrow>\n    [\\<dots>n] \\<down>< t =\n    (if n < t then [\\<dots>n] else if t = 0 then {} else [\\<dots>t - Suc 0])\n 2. \\<not> n < t \\<Longrightarrow>\n    [\\<dots>n] \\<down>< t =\n    (if n < t then [\\<dots>n] else if t = 0 then {} else [\\<dots>t - Suc 0])", "apply (simp add: cut_less_Max_all iT_Max iT_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < t \\<Longrightarrow>\n    [\\<dots>n] \\<down>< t =\n    (if n < t then [\\<dots>n] else if t = 0 then {} else [\\<dots>t - Suc 0])", "apply (case_tac \"t = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < t; t = 0\\<rbrakk>\n    \\<Longrightarrow> [\\<dots>n] \\<down>< t =\n                      (if n < t then [\\<dots>n]\n                       else if t = 0 then {} else [\\<dots>t - Suc 0])\n 2. \\<lbrakk>\\<not> n < t; t \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [\\<dots>n] \\<down>< t =\n                      (if n < t then [\\<dots>n]\n                       else if t = 0 then {} else [\\<dots>t - Suc 0])", "apply (simp add: cut_less_0_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < t; t \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [\\<dots>n] \\<down>< t =\n                      (if n < t then [\\<dots>n]\n                       else if t = 0 then {} else [\\<dots>t - Suc 0])", "apply (fastforce simp: nat_cut_less_le_conv iTILL_cut_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_cut_less1: \"\n  \\<lbrakk> t \\<in> [\\<dots>n]; 0 < t \\<rbrakk> \\<Longrightarrow> [\\<dots>n] \\<down>< t = [\\<dots>t - Suc 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [\\<dots>n]; 0 < t\\<rbrakk>\n    \\<Longrightarrow> [\\<dots>n] \\<down>< t = [\\<dots>t - Suc 0]", "by (simp add: iTILL_cut_less iT_iff)"], ["", "lemma iFROM_cut_less: \"\n  [n\\<dots>] \\<down>< t = (\n    if t \\<le> n then {}\n    else [n\\<dots>,t - Suc n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<down>< t = (if t \\<le> n then {} else [n\\<dots>,t - Suc n])", "apply (case_tac \"t \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> n \\<Longrightarrow>\n    [n\\<dots>] \\<down>< t = (if t \\<le> n then {} else [n\\<dots>,t - Suc n])\n 2. \\<not> t \\<le> n \\<Longrightarrow>\n    [n\\<dots>] \\<down>< t = (if t \\<le> n then {} else [n\\<dots>,t - Suc n])", "apply (simp add: cut_less_Min_empty iT_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> n \\<Longrightarrow>\n    [n\\<dots>] \\<down>< t = (if t \\<le> n then {} else [n\\<dots>,t - Suc n])", "apply (fastforce simp: nat_cut_less_le_conv iFROM_cut_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iFROM_cut_less1: \"\n  n < t \\<Longrightarrow> [n\\<dots>] \\<down>< t = [n\\<dots>,t - Suc n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < t \\<Longrightarrow> [n\\<dots>] \\<down>< t = [n\\<dots>,t - Suc n]", "by (simp add: iFROM_cut_less)"], ["", "lemma iIN_cut_less: \"\n  [n\\<dots>,d] \\<down>< t = ( \n    if t \\<le> n then {} else\n    if t \\<le> n + d then [n\\<dots>, t - Suc n]\n    else [n\\<dots>,d])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<down>< t =\n    (if t \\<le> n then {}\n     else if t \\<le> n + d then [n\\<dots>,t - Suc n] else [n\\<dots>,d])", "apply (case_tac \"t \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> n \\<Longrightarrow>\n    [n\\<dots>,d] \\<down>< t =\n    (if t \\<le> n then {}\n     else if t \\<le> n + d then [n\\<dots>,t - Suc n] else [n\\<dots>,d])\n 2. \\<not> t \\<le> n \\<Longrightarrow>\n    [n\\<dots>,d] \\<down>< t =\n    (if t \\<le> n then {}\n     else if t \\<le> n + d then [n\\<dots>,t - Suc n] else [n\\<dots>,d])", "apply (simp add: cut_less_Min_empty iT_Min )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> n \\<Longrightarrow>\n    [n\\<dots>,d] \\<down>< t =\n    (if t \\<le> n then {}\n     else if t \\<le> n + d then [n\\<dots>,t - Suc n] else [n\\<dots>,d])", "apply (case_tac \"n + d < t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> t \\<le> n; n + d < t\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<down>< t =\n                      (if t \\<le> n then {}\n                       else if t \\<le> n + d then [n\\<dots>,t - Suc n]\n                            else [n\\<dots>,d])\n 2. \\<lbrakk>\\<not> t \\<le> n; \\<not> n + d < t\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<down>< t =\n                      (if t \\<le> n then {}\n                       else if t \\<le> n + d then [n\\<dots>,t - Suc n]\n                            else [n\\<dots>,d])", "apply (simp add: cut_less_Max_all iT_Max iT_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> t \\<le> n; \\<not> n + d < t\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<down>< t =\n                      (if t \\<le> n then {}\n                       else if t \\<le> n + d then [n\\<dots>,t - Suc n]\n                            else [n\\<dots>,d])", "apply (fastforce simp: nat_cut_less_le_conv iIN_cut_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_cut_less1: \"\n  \\<lbrakk> t \\<in> [n\\<dots>,d]; n < t \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<down>< t = [n\\<dots>, t - Suc n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [n\\<dots>,d]; n < t\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<down>< t = [n\\<dots>,t - Suc n]", "by (simp add: iIN_cut_less iT_iff)"], ["", "lemma iMOD_cut_less: \"\n  [r, mod m] \\<down>< t = (\n    if t \\<le> r then {} \n    else [r, mod m, (t - Suc r) div m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<down>< t =\n    (if t \\<le> r then {} else [ r, mod m, (t - Suc r) div m ])", "apply (case_tac \"t = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t = 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>< t =\n    (if t \\<le> r then {} else [ r, mod m, (t - Suc r) div m ])\n 2. t \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>< t =\n    (if t \\<le> r then {} else [ r, mod m, (t - Suc r) div m ])", "apply (simp add: cut_less_0_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>< t =\n    (if t \\<le> r then {} else [ r, mod m, (t - Suc r) div m ])", "apply (simp add: nat_cut_less_le_conv iMOD_cut_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t - Suc 0 < r \\<longrightarrow>\n     \\<not> t \\<le> r \\<longrightarrow> {} = [ r, mod m, 0 ]) \\<and>\n    (\\<not> t - Suc 0 < r \\<longrightarrow>\n     t \\<le> r \\<longrightarrow> [ r, mod m, 0 ] = {})", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_cut_less1: \"\n  \\<lbrakk> t \\<in> [r, mod m]; r < t \\<rbrakk> \\<Longrightarrow> \n  [r, mod m] \\<down>< t = [r, mod m, (t - r) div m - Suc 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t; m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]\n 2. \\<lbrakk>t \\<in> [ r, mod m ]; r < t; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (simp add: iMOD_0 iMODb_mod_0 iIN_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (simp add: iMOD_cut_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t; 0 < m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, (t - Suc r) div m ] =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (simp add: mod_0_imp_diff_Suc_div_conv mod_eq_imp_diff_mod_0 iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_cut_less: \"\n  [r, mod m, c] \\<down>< t = (\n    if t \\<le> r then {} else\n    if r + m * c < t then [r, mod m, c]\n    else [r, mod m, (t - Suc r) div m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<down>< t =\n    (if t \\<le> r then {}\n     else if r + m * c < t then [ r, mod m, c ]\n          else [ r, mod m, (t - Suc r) div m ])", "apply (case_tac \"t = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t = 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>< t =\n    (if t \\<le> r then {}\n     else if r + m * c < t then [ r, mod m, c ]\n          else [ r, mod m, (t - Suc r) div m ])\n 2. t \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>< t =\n    (if t \\<le> r then {}\n     else if r + m * c < t then [ r, mod m, c ]\n          else [ r, mod m, (t - Suc r) div m ])", "apply (simp add: cut_less_0_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>< t =\n    (if t \\<le> r then {}\n     else if r + m * c < t then [ r, mod m, c ]\n          else [ r, mod m, (t - Suc r) div m ])", "apply (simp add: nat_cut_less_le_conv iMODb_cut_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t - Suc 0 < r + m * c \\<longrightarrow>\n     (t - Suc 0 < r \\<longrightarrow>\n      (r + m * c < t \\<longrightarrow> {} = [ r, mod m, c ]) \\<and>\n      (\\<not> r + m * c < t \\<longrightarrow>\n       \\<not> t \\<le> r \\<longrightarrow> {} = [ r, mod m, 0 ])) \\<and>\n     (\\<not> t - Suc 0 < r \\<longrightarrow>\n      (r + m * c < t \\<longrightarrow>\n       [ r, mod m, 0 ] = [ r, mod m, c ]) \\<and>\n      (\\<not> r + m * c < t \\<longrightarrow>\n       t \\<le> r \\<longrightarrow> [ r, mod m, 0 ] = {}))) \\<and>\n    (\\<not> t - Suc 0 < r + m * c \\<longrightarrow>\n     \\<not> r + m * c < t \\<longrightarrow>\n     (t \\<le> r \\<longrightarrow> [ r, mod m, 0 ] = {}) \\<and>\n     (\\<not> t \\<le> r \\<longrightarrow> [ r, mod m, c ] = [ r, mod m, 0 ]))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_cut_less1: \"\\<lbrakk> t \\<in> [r, mod m, c]; r < t \\<rbrakk> \\<Longrightarrow> \n  [r, mod m, c] \\<down>< t = [r, mod m, (t - r) div m - Suc 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t; m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]\n 2. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (simp add: iMODb_mod_0 iIN_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>< t =\n                      [ r, mod m, (t - r) div m - Suc 0 ]", "apply (simp add: iMODb_cut_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t; 0 < m\\<rbrakk>\n    \\<Longrightarrow> (r + m * c < t \\<longrightarrow>\n                       [ r, mod m, c ] =\n                       [ r, mod m, (t - r) div m - Suc 0 ]) \\<and>\n                      (\\<not> r + m * c < t \\<longrightarrow>\n                       [ r, mod m, (t - Suc r) div m ] =\n                       [ r, mod m, (t - r) div m - Suc 0 ])", "apply (simp add: mod_0_imp_diff_Suc_div_conv mod_eq_imp_diff_mod_0 iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_cut_le =\n  iTILL_cut_le\n  iFROM_cut_le\n  iIN_cut_le\n  iMOD_cut_le\n  iMODb_cut_le"], ["", "lemmas iT_cut_le1 =\n  iTILL_cut_le1\n  iFROM_cut_le1\n  iIN_cut_le1\n  iMOD_cut_le1\n  iMODb_cut_le1"], ["", "lemmas iT_cut_less =\n  iTILL_cut_less\n  iFROM_cut_less\n  iIN_cut_less\n  iMOD_cut_less\n  iMODb_cut_less"], ["", "lemmas iT_cut_less1 =\n  iTILL_cut_less1\n  iFROM_cut_less1\n  iIN_cut_less1\n  iMOD_cut_less1\n  iMODb_cut_less1"], ["", "lemmas iT_cut_le_less =\n  iTILL_cut_le\n  iTILL_cut_less\n  iFROM_cut_le\n  iFROM_cut_less\n  iIN_cut_le\n  iIN_cut_less\n  iMOD_cut_le\n  iMOD_cut_less\n  iMODb_cut_le\n  iMODb_cut_less"], ["", "lemmas iT_cut_le_less1 =\n  iTILL_cut_le1\n  iTILL_cut_less1\n  iFROM_cut_le1\n  iFROM_cut_less1\n  iIN_cut_le1\n  iIN_cut_less1\n  iMOD_cut_le1\n  iMOD_cut_less1\n  iMODb_cut_le1\n  iMODb_cut_less1"], ["", "lemma iTILL_cut_ge: \"\n  [\\<dots>n] \\<down>\\<ge> t = (if n < t then {} else [t\\<dots>,n-t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<down>\\<ge> t = (if n < t then {} else [t\\<dots>,n - t])", "by (force simp: i_cut_mem_iff iT_iff)"], ["", "corollary iTILL_cut_ge1: \"t \\<in> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>\\<ge> t = [t\\<dots>,n-t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [\\<dots>n] \\<Longrightarrow>\n    [\\<dots>n] \\<down>\\<ge> t = [t\\<dots>,n - t]", "by (simp add: iTILL_cut_ge iT_iff)"], ["", "corollary iTILL_cut_ge2: \"t \\<notin> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>\\<ge> t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>\\<ge> t = {}", "by (simp add: iTILL_cut_ge iT_iff)"], ["", "lemma iTILL_cut_greater: \"\n  [\\<dots>n] \\<down>> t = (if n \\<le> t then {} else [Suc t\\<dots>,n - Suc t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<down>> t =\n    (if n \\<le> t then {} else [Suc t\\<dots>,n - Suc t])", "by (force simp: i_cut_mem_iff iT_iff)"], ["", "corollary iTILL_cut_greater1: \"\n  t \\<in> [\\<dots>n] \\<Longrightarrow> t < n \\<Longrightarrow> [\\<dots>n] \\<down>> t = [Suc t\\<dots>,n - Suc t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [\\<dots>n]; t < n\\<rbrakk>\n    \\<Longrightarrow> [\\<dots>n] \\<down>> t = [Suc t\\<dots>,n - Suc t]", "by (simp add: iTILL_cut_greater iT_iff)"], ["", "corollary iTILL_cut_greater2: \"t \\<notin> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>> t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> [\\<dots>n] \\<Longrightarrow> [\\<dots>n] \\<down>> t = {}", "by (simp add: iTILL_cut_greater iT_iff)"], ["", "lemma iFROM_cut_ge: \"\n  [n\\<dots>] \\<down>\\<ge> t = (if n \\<le> t then [t\\<dots>] else [n\\<dots>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<down>\\<ge> t =\n    (if n \\<le> t then [t\\<dots>] else [n\\<dots>])", "by (force simp: i_cut_mem_iff iT_iff)"], ["", "corollary iFROM_cut_ge1: \"t \\<in> [n\\<dots>] \\<Longrightarrow> [n\\<dots>] \\<down>\\<ge> t = [t\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>] \\<Longrightarrow>\n    [n\\<dots>] \\<down>\\<ge> t = [t\\<dots>]", "by (simp add: iFROM_cut_ge iT_iff)"], ["", "lemma iFROM_cut_greater: \"\n  [n\\<dots>] \\<down>> t = (if n \\<le> t then [Suc t\\<dots>] else [n\\<dots>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<down>> t =\n    (if n \\<le> t then [Suc t\\<dots>] else [n\\<dots>])", "by (force simp: i_cut_mem_iff iT_iff)"], ["", "corollary iFROM_cut_greater1: \"\n  t \\<in> [n\\<dots>] \\<Longrightarrow> [n\\<dots>] \\<down>> t = [Suc t\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>] \\<Longrightarrow>\n    [n\\<dots>] \\<down>> t = [Suc t\\<dots>]", "by (simp add: iFROM_cut_greater iT_iff)"], ["", "lemma iIN_cut_ge: \"\n  [n\\<dots>,d] \\<down>\\<ge> t = (\n    if t < n then [n\\<dots>,d] else \n    if t \\<le> n+d then [t\\<dots>,n+d-t]\n    else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<down>\\<ge> t =\n    (if t < n then [n\\<dots>,d]\n     else if t \\<le> n + d then [t\\<dots>,n + d - t] else {})", "by (force simp: i_cut_mem_iff iT_iff)"], ["", "corollary iIN_cut_ge1: \"t \\<in> [n\\<dots>,d] \\<Longrightarrow> \n  [n\\<dots>,d] \\<down>\\<ge> t = [t\\<dots>,n+d-t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>,d] \\<Longrightarrow>\n    [n\\<dots>,d] \\<down>\\<ge> t = [t\\<dots>,n + d - t]", "by (simp add: iIN_cut_ge iT_iff)"], ["", "corollary iIN_cut_ge2: \"t \\<notin> [n\\<dots>,d] \\<Longrightarrow> \n  [n\\<dots>,d] \\<down>\\<ge> t = (if t < n then [n\\<dots>,d] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> [n\\<dots>,d] \\<Longrightarrow>\n    [n\\<dots>,d] \\<down>\\<ge> t = (if t < n then [n\\<dots>,d] else {})", "by (simp add: iIN_cut_ge iT_iff)"], ["", "lemma iIN_cut_greater: \"\n  [n\\<dots>,d] \\<down>> t = (\n    if t < n then [n\\<dots>,d] else \n    if t < n+d then [Suc t\\<dots>,n + d - Suc t]\n    else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<down>> t =\n    (if t < n then [n\\<dots>,d]\n     else if t < n + d then [Suc t\\<dots>,n + d - Suc t] else {})", "by (force simp: i_cut_mem_iff iT_iff)"], ["", "corollary iIN_cut_greater1: \"\n  \\<lbrakk> t \\<in> [n\\<dots>,d]; t < n + d \\<rbrakk>\\<Longrightarrow>\n  [n\\<dots>,d] \\<down>> t = [Suc t\\<dots>,n + d - Suc t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [n\\<dots>,d]; t < n + d\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<down>> t = [Suc t\\<dots>,n + d - Suc t]", "by (simp add: iIN_cut_greater iT_iff)"], ["", "(*\nlemma \"let m=5 in let r = 12 in let t = 16 in\n  [r, mod m] \\<down>> t = (\n  if t < r then [r, mod m] else\n  if (m = 0 \\<and> r \\<le> t) then {}\n  else [r + (t - r) div m * m + m, mod m])\"\napply (simp add: Let_def)\noops\nlemma \"let m=5 in let r = 12 in let t = 16 in\n  [r, mod m] \\<down>> t = (\n  if t < r then [r, mod m] else\n  if (m = 0 \\<and> r \\<le> t) then {}\n  else [t + m - (t - r) mod m, mod m])\"\napply (simp add: Let_def)\noops\n*)"], ["", "lemma mod_cut_greater_aux_t_less: \"\n  \\<lbrakk> 0 < (m::nat); r \\<le> t \\<rbrakk> \\<Longrightarrow> \n  t < t + m - (t - r) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> t < t + m - (t - r) mod m", "by (simp add: less_add_diff add.commute)"], ["", "lemma mod_cut_greater_aux_le_x: \"\n  \\<lbrakk> (r::nat) \\<le> t; t < x; x mod m = r mod m\\<rbrakk> \\<Longrightarrow> \n  t + m - (t - r) mod m \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> t; t < x; x mod m = r mod m\\<rbrakk>\n    \\<Longrightarrow> t + m - (t - r) mod m \\<le> x", "apply (insert diff_mod_le[of t r m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> t; t < x; x mod m = r mod m;\n     (t - r) mod m \\<le> t\\<rbrakk>\n    \\<Longrightarrow> t + m - (t - r) mod m \\<le> x", "apply (subst diff_add_assoc2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> t; t < x; x mod m = r mod m;\n     (t - r) mod m \\<le> t\\<rbrakk>\n    \\<Longrightarrow> t - (t - r) mod m + m \\<le> x", "apply (rule less_mod_eq_imp_add_divisor_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> t; t < x; x mod m = r mod m;\n     (t - r) mod m \\<le> t\\<rbrakk>\n    \\<Longrightarrow> (t - (t - r) mod m) mod m = x mod m", "apply (simp add: sub_diff_mod_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_cut_greater: \"\n  [r, mod m] \\<down>> t = (\n    if t < r then [r, mod m] else\n    if m = 0 then {}\n    else [t + m - (t - r) mod m, mod m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<down>> t =\n    (if t < r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - (t - r) mod m, mod m ])", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>> t =\n    (if t < r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - (t - r) mod m, mod m ])\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>> t =\n    (if t < r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - (t - r) mod m, mod m ])", "apply (simp add: iMOD_0 iIN_0 i_cut_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>> t =\n    (if t < r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - (t - r) mod m, mod m ])", "apply (case_tac \"t < r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>> t =\n                      (if t < r then [ r, mod m ]\n                       else if m = 0 then {}\n                            else [ t + m - (t - r) mod m, mod m ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>> t =\n                      (if t < r then [ r, mod m ]\n                       else if m = 0 then {}\n                            else [ t + m - (t - r) mod m, mod m ])", "apply (simp add: iT_Min cut_greater_Min_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>> t =\n                      (if t < r then [ r, mod m ]\n                       else if m = 0 then {}\n                            else [ t + m - (t - r) mod m, mod m ])", "apply (simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<down>> t =\n                      [ t + m - (t - r) mod m, mod m ]", "apply (simp add: set_eq_iff i_cut_mem_iff iT_iff, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and> r \\<le> x \\<and> t < x) =\n                         (x mod m = (t + m - (t - r) mod m) mod m \\<and>\n                          t + m - (t - r) mod m \\<le> x)", "apply (subgoal_tac \"(t - r) mod m \\<le> t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and> r \\<le> x \\<and> t < x) =\n                         (x mod m = (t + m - (t - r) mod m) mod m \\<and>\n                          t + m - (t - r) mod m \\<le> x)\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (t - r) mod m \\<le> t", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (t - r) mod m \\<le> t\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and> r \\<le> x \\<and> t < x) =\n                         (x mod m = (t + m - (t - r) mod m) mod m \\<and>\n                          t + m - (t - r) mod m \\<le> x)", "apply (rule order_trans[OF mod_le_dividend], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and> r \\<le> x \\<and> t < x) =\n                         (x mod m = (t + m - (t - r) mod m) mod m \\<and>\n                          t + m - (t - r) mod m \\<le> x)", "apply (simp add: diff_add_assoc2 del: add_diff_assoc2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and> r \\<le> x \\<and> t < x) =\n                         (x mod m = (t - (t - r) mod m) mod m \\<and>\n                          t - (t - r) mod m + m \\<le> x)", "apply (simp add: sub_diff_mod_eq del: add_diff_assoc2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and> r \\<le> x \\<and> t < x) =\n                         (x mod m = r mod m \\<and>\n                          t - (t - r) mod m + m \\<le> x)", "apply (rule conj_cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t;\n        x mod m = r mod m\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and> t < x) =\n                         (t - (t - r) mod m + m \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        r \\<le> x \\<and> t < x\\<rbrakk>\n       \\<Longrightarrow> t - (t - r) mod m + m \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        r \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> t - (t - r) mod m + m \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply (rule less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        r \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> t - (t - r) mod m < x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        r \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> (t - (t - r) mod m) mod m = x mod m\n 3. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        r \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> (t - (t - r) mod m) mod m = x mod m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply (simp add: sub_diff_mod_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply (subgoal_tac \"t < x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> t < x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> t < x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply (rule_tac y=\"t - (t - r) mod m + m\" in order_less_le_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> t < t - (t - r) mod m + m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> t - (t - r) mod m + m \\<le> x\n 3. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply (simp add: mod_cut_greater_aux_t_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x\\<rbrakk>\n       \\<Longrightarrow> t - (t - r) mod m + m \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; r \\<le> t; (t - r) mod m \\<le> t; x mod m = r mod m;\n        t - (t - r) mod m + m \\<le> x; t < x\\<rbrakk>\n       \\<Longrightarrow> r \\<le> x \\<and> t < x", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_cut_greater1: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> \n  [r, mod m] \\<down>> t = (\n    if m = 0 then {}\n    else [t + m, mod m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow>\n    [ r, mod m ] \\<down>> t = (if m = 0 then {} else [ t + m, mod m ])", "by (simp add: iMOD_cut_greater iT_iff mod_eq_imp_diff_mod_0)"], ["", "lemma iMODb_cut_greater_aux: \"\n  \\<lbrakk> 0 < m; t < r + m * c; r \\<le> t\\<rbrakk> \\<Longrightarrow> \n  (r + m * c - (t + m - (t - r) mod m)) div m =\n  c - Suc ((t - r) div m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - Suc ((t - r) div m)", "apply (subgoal_tac \"r \\<le> t + m - (t - r) mod m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - Suc ((t - r) div m)\n 2. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> r \\<le> t + m - (t - r) mod m", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> r \\<le> t + m - (t - r) mod m\n 2. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - Suc ((t - r) div m)", "apply (rule order_trans[of _ t], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> t \\<le> t + m - (t - r) mod m\n 2. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - Suc ((t - r) div m)", "apply (simp add: mod_cut_greater_aux_t_less less_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - Suc ((t - r) div m)", "apply (rule_tac t=\"(r + m * c - (t + m - (t - r) mod m))\" and s=\"m * (c - Suc ((t - r) div m))\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> m * (c - Suc ((t - r) div m)) =\n                      r + m * c - (t + m - (t - r) mod m)\n 2. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> m * (c - Suc ((t - r) div m)) div m =\n                      c - Suc ((t - r) div m)", "apply (simp add: diff_mult_distrib2 minus_mod_eq_mult_div [symmetric] del: diff_diff_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t;\n     r \\<le> t + m - (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> m * (c - Suc ((t - r) div m)) div m =\n                      c - Suc ((t - r) div m)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_cut_greater: \"\n  [r, mod m, c] \\<down>> t = (\n    if t < r then [r, mod m, c] else\n    if r + m * c \\<le> t then {}\n    else [t + m - (t - r) mod m, mod m, c - Suc ((t-r) div m)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<down>> t =\n    (if t < r then [ r, mod m, c ]\n     else if r + m * c \\<le> t then {}\n          else [ t + m - (t - r) mod m, mod m, c - Suc ((t - r) div m) ])", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>> t =\n    (if t < r then [ r, mod m, c ]\n     else if r + m * c \\<le> t then {}\n          else [ t + m - (t - r) mod m, mod m, c - Suc ((t - r) div m) ])\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>> t =\n    (if t < r then [ r, mod m, c ]\n     else if r + m * c \\<le> t then {}\n          else [ t + m - (t - r) mod m, mod m, c - Suc ((t - r) div m) ])", "apply (simp add: iMODb_mod_0 iIN_0 i_cut_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>> t =\n    (if t < r then [ r, mod m, c ]\n     else if r + m * c \\<le> t then {}\n          else [ t + m - (t - r) mod m, mod m, c - Suc ((t - r) div m) ])", "apply (case_tac \"r + m * c \\<le> t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; r + m * c \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      (if t < r then [ r, mod m, c ]\n                       else if r + m * c \\<le> t then {}\n                            else [ t + m -\n                                   (t - r) mod\n                                   m, mod m, c - Suc ((t - r) div m) ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      (if t < r then [ r, mod m, c ]\n                       else if r + m * c \\<le> t then {}\n                            else [ t + m -\n                                   (t - r) mod\n                                   m, mod m, c - Suc ((t - r) div m) ])", "apply (simp add: cut_greater_Max_empty iT_Max iT_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      (if t < r then [ r, mod m, c ]\n                       else if r + m * c \\<le> t then {}\n                            else [ t + m -\n                                   (t - r) mod\n                                   m, mod m, c - Suc ((t - r) div m) ])", "apply (case_tac \"t < r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c \\<le> t; t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      (if t < r then [ r, mod m, c ]\n                       else if r + m * c \\<le> t then {}\n                            else [ t + m -\n                                   (t - r) mod\n                                   m, mod m, c - Suc ((t - r) div m) ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c \\<le> t; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      (if t < r then [ r, mod m, c ]\n                       else if r + m * c \\<le> t then {}\n                            else [ t + m -\n                                   (t - r) mod\n                                   m, mod m, c - Suc ((t - r) div m) ])", "apply (simp add: cut_greater_Min_all iT_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c \\<le> t; \\<not> t < r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      (if t < r then [ r, mod m, c ]\n                       else if r + m * c \\<le> t then {}\n                            else [ t + m -\n                                   (t - r) mod\n                                   m, mod m, c - Suc ((t - r) div m) ])", "apply (simp add: linorder_not_less linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>> t =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - Suc ((t - r) div m) ]", "apply (rule_tac t=\"[ r, mod m, c ]\" and s=\"[ r, mod m ] \\<inter> [\\<dots>r + m * c]\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [\\<dots>r + m * c] =\n                      [ r, mod m, c ]\n 2. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<inter> [\\<dots>r + m * c]) \\<down>>\n                      t =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - Suc ((t - r) div m) ]", "apply (simp add: iMOD_iTILL_iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<inter> [\\<dots>r + m * c]) \\<down>>\n                      t =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - Suc ((t - r) div m) ]", "apply (simp add: i_cut_Int_left iMOD_cut_greater)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ t + m - (t - r) mod m, mod m ] \\<inter>\n                      [\\<dots>r + m * c] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - Suc ((t - r) div m) ]", "apply (subst iMOD_iTILL_iMODb_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> t + m - (t - r) mod m \\<le> r + m * c\n 2. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ t + m -\n                        (t - r) mod\n                        m, mod m, (r + m * c - (t + m - (t - r) mod m)) div\n                                  m ] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - Suc ((t - r) div m) ]", "apply (rule mod_cut_greater_aux_le_x, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t < r + m * c; r \\<le> t\\<rbrakk>\n    \\<Longrightarrow> [ t + m -\n                        (t - r) mod\n                        m, mod m, (r + m * c - (t + m - (t - r) mod m)) div\n                                  m ] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - Suc ((t - r) div m) ]", "apply (simp add: iMODb_cut_greater_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_cut_greater1: \"\n  t \\<in> [r, mod m, c] \\<Longrightarrow> \n    [r, mod m, c] \\<down>> t = (\n    if r + m * c \\<le> t then {}\n    else [t + m, mod m, c - Suc ((t-r) div m)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m, c ] \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>> t =\n    (if r + m * c \\<le> t then {}\n     else [ t + m, mod m, c - Suc ((t - r) div m) ])", "by (simp add: iMODb_cut_greater iT_iff mod_eq_imp_diff_mod_0)"], ["", "(*\nlemma \"let m=5 in let r = 12 in let t = 17 in\n  [r, mod m] \\<down>\\<ge> t = (\n  if t \\<le> r then [r, mod m] else\n  if m=0 then {}\n  else [t + m - Suc ((t - Suc r) mod m), mod m])\"\napply (simp add: Let_def)\noops\n*)"], ["", "lemma iMOD_cut_ge: \"\n  [r, mod m] \\<down>\\<ge> t = (\n    if t \\<le> r then [r, mod m] else\n    if m = 0 then {} \n    else [t + m - Suc ((t - Suc r) mod m), mod m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - Suc ((t - Suc r) mod m), mod m ])", "apply (case_tac \"t = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t = 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - Suc ((t - Suc r) mod m), mod m ])\n 2. t \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - Suc ((t - Suc r) mod m), mod m ])", "apply (simp add: cut_ge_0_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m ]\n     else if m = 0 then {} else [ t + m - Suc ((t - Suc r) mod m), mod m ])", "apply (force simp: nat_cut_greater_ge_conv[symmetric] iMOD_cut_greater)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_cut_ge1: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> \n  [r, mod m] \\<down>\\<ge> t = [t, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow>\n    [ r, mod m ] \\<down>\\<ge> t = [ t, mod m ]", "by (fastforce simp: iMOD_cut_ge)"], ["", "(*\nlemma \"let m=5 in let r = 12 in let t = 21 in let c=5 in\n  [r, mod m, c] \\<down>\\<ge> t = (\n    if t \\<le> r then [r, mod m, c] else\n    if r + m * c < t then {} \n    else [t + m - Suc ((t - Suc r) mod m), mod m, c - (t + m - Suc r) div m])\"\napply (simp add: Let_def)\noops\n*)"], ["", "lemma iMODb_cut_ge: \"\n  [r, mod m, c] \\<down>\\<ge> t = (\n    if t \\<le> r then [r, mod m, c] else\n    if r + m * c < t then {} \n    else [t + m - Suc ((t - Suc r) mod m), mod m, c - (t + m - Suc r) div m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m, c ]\n     else if r + m * c < t then {}\n          else [ t + m -\n                 Suc ((t - Suc r) mod\n                      m), mod m, c - (t + m - Suc r) div m ])", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m, c ]\n     else if r + m * c < t then {}\n          else [ t + m -\n                 Suc ((t - Suc r) mod\n                      m), mod m, c - (t + m - Suc r) div m ])\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m, c ]\n     else if r + m * c < t then {}\n          else [ t + m -\n                 Suc ((t - Suc r) mod\n                      m), mod m, c - (t + m - Suc r) div m ])", "apply (simp add: iMODb_mod_0 iIN_0 i_cut_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<ge> t =\n    (if t \\<le> r then [ r, mod m, c ]\n     else if r + m * c < t then {}\n          else [ t + m -\n                 Suc ((t - Suc r) mod\n                      m), mod m, c - (t + m - Suc r) div m ])", "apply (case_tac \"r + m * c < t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; r + m * c < t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if t \\<le> r then [ r, mod m, c ]\n                       else if r + m * c < t then {}\n                            else [ t + m -\n                                   Suc ((t - Suc r) mod\n  m), mod m, c - (t + m - Suc r) div m ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c < t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if t \\<le> r then [ r, mod m, c ]\n                       else if r + m * c < t then {}\n                            else [ t + m -\n                                   Suc ((t - Suc r) mod\n  m), mod m, c - (t + m - Suc r) div m ])", "apply (simp add: cut_ge_Max_empty iT_Max iT_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c < t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if t \\<le> r then [ r, mod m, c ]\n                       else if r + m * c < t then {}\n                            else [ t + m -\n                                   Suc ((t - Suc r) mod\n  m), mod m, c - (t + m - Suc r) div m ])", "apply (case_tac \"t \\<le> r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c < t; t \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if t \\<le> r then [ r, mod m, c ]\n                       else if r + m * c < t then {}\n                            else [ t + m -\n                                   Suc ((t - Suc r) mod\n  m), mod m, c - (t + m - Suc r) div m ])\n 2. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c < t; \\<not> t \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if t \\<le> r then [ r, mod m, c ]\n                       else if r + m * c < t then {}\n                            else [ t + m -\n                                   Suc ((t - Suc r) mod\n  m), mod m, c - (t + m - Suc r) div m ])", "apply (simp add: cut_ge_Min_all iT_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; \\<not> r + m * c < t; \\<not> t \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if t \\<le> r then [ r, mod m, c ]\n                       else if r + m * c < t then {}\n                            else [ t + m -\n                                   Suc ((t - Suc r) mod\n  m), mod m, c - (t + m - Suc r) div m ])", "apply (simp add: linorder_not_less linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (case_tac \"r mod m = t mod m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: diff_mod_pred)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - (t + m - Suc r) div m ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: mod_0_imp_diff_Suc_div_conv mod_eq_diff_mod_0_conv diff_add_assoc2 del: add_diff_assoc2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (subgoal_tac \"0 < (t - r) div m\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < (t - r) div m\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < (t - r) div m\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (frule_tac x=r in less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0\\<rbrakk>\n    \\<Longrightarrow> r mod ?m14 = t mod ?m14\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     r + ?m14 \\<le> t\\<rbrakk>\n    \\<Longrightarrow> 0 < (t - r) div m\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 4. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: mod_eq_diff_mod_0_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     r + m \\<le> t\\<rbrakk>\n    \\<Longrightarrow> 0 < (t - r) div m\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (drule add_le_imp_le_diff2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     m \\<le> t - r\\<rbrakk>\n    \\<Longrightarrow> 0 < (t - r) div m\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (drule_tac m=m and k=m in div_le_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     m div m \\<le> (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> 0 < (t - r) div m\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n     0 < (t - r) div m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t, mod m, c - Suc ((t - r) div m - Suc 0) ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: set_eq_iff i_cut_mem_iff iT_iff, intro allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; (t - r) mod m = 0;\n        0 < (t - r) div m\\<rbrakk>\n       \\<Longrightarrow> (x mod m = r mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (x mod m = t mod m \\<and>\n                          t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: mod_eq_diff_mod_0_conv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m\\<rbrakk>\n       \\<Longrightarrow> (x mod m = t mod m \\<and>\n                          r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (x mod m = t mod m \\<and>\n                          t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (rule conj_cong, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m; x mod m = t mod m\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (case_tac \"t \\<le> x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m; x mod m = t mod m; t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m; x mod m = t mod m; \\<not> t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m; x mod m = t mod m; \\<not> t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 2. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m; x mod m = t mod m; t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m = t mod m;\n        0 < (t - r) div m; x mod m = t mod m; t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (r \\<le> x \\<and>\n                          x \\<le> r + m * c \\<and> t \\<le> x) =\n                         (t \\<le> x \\<and>\n                          x \\<le> t + m * (c - (t - r) div m))\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: diff_mult_distrib2 minus_mod_eq_mult_div [symmetric] mod_eq_diff_mod_0_conv add.commute[of r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (subgoal_tac \"Suc ((t - Suc r) mod m) = (t - r) mod m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> Suc ((t - Suc r) mod m) = (t - r) mod m", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t;\n     r mod m \\<noteq> t mod m\\<rbrakk>\n    \\<Longrightarrow> Suc ((t - Suc r) mod m) = (t - r) mod m\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (clarsimp simp add: diff_mod_pred mod_eq_diff_mod_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (rule_tac t=\"[ r, mod m, c ]\" and s=\"[ r, mod m ] \\<inter> [\\<dots>r + m * c]\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [\\<dots>r + m * c] =\n                      [ r, mod m, c ]\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<inter>\n                       [\\<dots>r + m * c]) \\<down>\\<ge>\n                      t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: iMOD_iTILL_iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<inter>\n                       [\\<dots>r + m * c]) \\<down>\\<ge>\n                      t =\n                      [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ]", "apply (simp add: i_cut_Int_left iMOD_cut_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ t + m - (t - r) mod m, mod m ] \\<inter>\n                      [\\<dots>r + m * c] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - (t + m - Suc r) div m ]", "apply (subst iMOD_iTILL_iMODb_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> t + m - (t - r) mod m \\<le> r + m * c\n 2. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ t + m -\n                        (t - r) mod\n                        m, mod m, (r + m * c - (t + m - (t - r) mod m)) div\n                                  m ] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - (t + m - Suc r) div m ]", "apply (drule_tac x=t in le_imp_less_or_eq, erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> t + m - (t - r) mod m \\<le> r + m * c\n 2. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t = r + m * c\\<rbrakk>\n    \\<Longrightarrow> t + m - (t - r) mod m \\<le> r + m * c\n 3. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ t + m -\n                        (t - r) mod\n                        m, mod m, (r + m * c - (t + m - (t - r) mod m)) div\n                                  m ] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - (t + m - Suc r) div m ]", "apply (rule mod_cut_greater_aux_le_x, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> [ t + m -\n                        (t - r) mod\n                        m, mod m, (r + m * c - (t + m - (t - r) mod m)) div\n                                  m ] =\n                      [ t + m -\n                        (t - r) mod m, mod m, c - (t + m - Suc r) div m ]", "apply (rule arg_cong [where y=\"c - (t + m - Suc r) div m\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t \\<le> r + m * c; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - (t + m - Suc r) div m", "apply (drule_tac x=t in le_imp_less_or_eq, erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - (t + m - Suc r) div m\n 2. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t = r + m * c\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - (t + m - Suc r) div m", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t = r + m * c\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - (t + m - Suc r) div m\n 2. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - (t + m - Suc r) div m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - (t + m - (t - r) mod m)) div m =\n                      c - (t + m - Suc r) div m", "apply (simp add: iMODb_cut_greater_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> c - Suc ((t - r) div m) = c - (t + m - Suc r) div m", "apply (rule arg_cong[where f=\"(-) c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> Suc ((t - r) div m) = (t + m - Suc r) div m", "apply (simp add: diff_add_assoc2 del: add_diff_assoc2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (t - r) div m = (t - Suc r) div m", "apply (rule_tac t=\"t - Suc r\" and s=\"t - r - Suc 0\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (t - r) div m = (t - r - Suc 0) div m", "apply (subst div_diff1_eq[of _ \"Suc 0\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> (t - r) div m =\n                      (t - r) div m - Suc 0 div m -\n                      (m + Suc 0 mod m - Suc ((t - r) mod m)) div m", "apply (case_tac \"m = Suc 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < t; r mod m \\<noteq> t mod m;\n     Suc ((t - Suc r) mod m) = (t - r) mod m; t < r + m * c;\n     m \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> (t - r) div m =\n                      (t - r) div m - Suc 0 div m -\n                      (m + Suc 0 mod m - Suc ((t - r) mod m)) div m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_cut_ge1: \"\n  t \\<in> [r, mod m, c] \\<Longrightarrow>\n  [r, mod m, c] \\<down>\\<ge> t = (\n    if r + m * c < t then {} \n    else [t, mod m, c - (t - r) div m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m, c ] \\<Longrightarrow>\n    [ r, mod m, c ] \\<down>\\<ge> t =\n    (if r + m * c < t then {} else [ t, mod m, c - (t - r) div m ])", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if r + m * c < t then {}\n                       else [ t, mod m, c - (t - r) div m ])\n 2. \\<lbrakk>t \\<in> [ r, mod m, c ]; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if r + m * c < t then {}\n                       else [ t, mod m, c - (t - r) div m ])", "apply (simp add: iMODb_mod_0 iT_iff iIN_0 i_cut_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t =\n                      (if r + m * c < t then {}\n                       else [ t, mod m, c - (t - r) div m ])", "apply (clarsimp simp: iMODb_cut_ge iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t mod m = r mod m; r \\<le> t; t \\<le> r + m * c;\n     t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> [ t + m -\n                        Suc ((t - Suc r) mod\n                             m), mod m, c - (t + m - Suc r) div m ] =\n                      [ t, mod m, c - (t - r) div m ]", "apply (simp add: mod_eq_imp_diff_mod_eq_divisor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t mod m = r mod m; r \\<le> t; t \\<le> r + m * c;\n     t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> [ t, mod m, c - (t + m - Suc r) div m ] =\n                      [ t, mod m, c - (t - r) div m ]", "apply (rule_tac t=\"t + m - Suc r\" and s=\"t - r + (m - Suc 0)\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t mod m = r mod m; r \\<le> t; t \\<le> r + m * c;\n     t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> [ t, mod m, c - (t - r + (m - Suc 0)) div m ] =\n                      [ t, mod m, c - (t - r) div m ]", "apply (subst div_add1_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; t mod m = r mod m; r \\<le> t; t \\<le> r + m * c;\n     t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> [ t, mod m, c -\n                                  ((t - r) div m + (m - Suc 0) div m +\n                                   ((t - r) mod m + (m - Suc 0) mod m) div\n                                   m) ] =\n                      [ t, mod m, c - (t - r) div m ]", "apply (simp add: mod_eq_imp_diff_mod_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_0_cut_greater: \"\n  t \\<in> [r, mod 0] \\<Longrightarrow> [r, mod 0] \\<down>> t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod 0 ] \\<Longrightarrow> [ r, mod 0 ] \\<down>> t = {}", "by (simp add: iT_iff iMOD_0 iIN_0 i_cut_singleton)"], ["", "lemma iMODb_0_cut_greater: \"t \\<in> [r, mod 0, c] \\<Longrightarrow>\n  [r, mod 0, c] \\<down>> t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod 0, c ] \\<Longrightarrow>\n    [ r, mod 0, c ] \\<down>> t = {}", "by (simp add: iT_iff iMODb_mod_0 iIN_0 i_cut_singleton)"], ["", "lemmas iT_cut_ge =\n  iTILL_cut_ge\n  iFROM_cut_ge\n  iIN_cut_ge\n  iMOD_cut_ge\n  iMODb_cut_ge"], ["", "lemmas iT_cut_ge1 =\n  iTILL_cut_ge1\n  iFROM_cut_ge1\n  iIN_cut_ge1\n  iMOD_cut_ge1\n  iMODb_cut_ge1"], ["", "lemmas iT_cut_greater =\n  iTILL_cut_greater\n  iFROM_cut_greater\n  iIN_cut_greater\n  iMOD_cut_greater\n  iMODb_cut_greater"], ["", "lemmas iT_cut_greater1 =\n  iTILL_cut_greater1\n  iFROM_cut_greater1\n  iIN_cut_greater1\n  iMOD_cut_greater1\n  iMODb_cut_greater1"], ["", "lemmas iT_cut_ge_greater =\n  iTILL_cut_ge\n  iTILL_cut_greater\n  iFROM_cut_ge\n  iFROM_cut_greater\n  iIN_cut_ge\n  iIN_cut_greater\n  iMOD_cut_ge\n  iMOD_cut_greater\n  iMODb_cut_ge\n  iMODb_cut_greater"], ["", "lemmas iT_cut_ge_greater1 =\n  iTILL_cut_ge1\n  iTILL_cut_greater1\n  iFROM_cut_ge1\n  iFROM_cut_greater1\n  iIN_cut_ge1\n  iIN_cut_greater1\n  iMOD_cut_ge1\n  iMOD_cut_greater1\n  iMODb_cut_ge1\n  iMODb_cut_greater1"], ["", "subsection \\<open>Cardinality of intervals\\<close>"], ["", "lemma iFROM_card: \"card [n\\<dots>] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [n\\<dots>] = 0", "by (simp add: iFROM_infinite)"], ["", "lemma iTILL_card: \"card [\\<dots>n] = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [\\<dots>n] = Suc n", "by (simp add: iTILL_def)"], ["", "lemma iIN_card: \"card [n\\<dots>,d] = Suc d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [n\\<dots>,d] = Suc d", "by (simp add: iIN_def)"], ["", "lemma iMOD_0_card: \"card [r, mod 0] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [ r, mod 0 ] = Suc 0", "by (simp add: iMOD_0 iIN_card)"], ["", "lemma iMOD_card: \"0 < m \\<Longrightarrow> card [r, mod m] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> card [ r, mod m ] = 0", "by (simp add: iMOD_infinite)"], ["", "lemma iMOD_card_if: \"card [r, mod m] = (if m = 0 then Suc 0 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [ r, mod m ] = (if m = 0 then Suc 0 else 0)", "by (simp add: iMOD_0_card iMOD_card)"], ["", "lemma iMODb_mod_0_card: \"card [r, mod 0, c] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [ r, mod 0, c ] = Suc 0", "by (simp add: iMODb_mod_0 iIN_card)"], ["", "lemma iMODb_card: \"0 < m \\<Longrightarrow> card [r, mod m, c] = Suc c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow> card [ r, mod m, 0 ] = Suc 0\n 2. \\<And>c.\n       \\<lbrakk>0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> card [ r, mod m, Suc c ] = Suc (Suc c)", "apply (simp add: iMODb_0 iIN_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> card [ r, mod m, Suc c ] = Suc (Suc c)", "apply (subst iMODb_Suc_insert_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> card (insert (r + m * Suc c) [ r, mod m, c ]) =\n                         Suc (Suc c)", "apply (subst card_insert_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> finite [ r, mod m, c ]\n 2. \\<And>c.\n       \\<lbrakk>0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> r + m * Suc c \\<notin> [ r, mod m, c ]\n 3. \\<And>c.\n       \\<lbrakk>0 < m \\<Longrightarrow> card [ r, mod m, c ] = Suc c;\n        0 < m\\<rbrakk>\n       \\<Longrightarrow> Suc (card [ r, mod m, c ]) = Suc (Suc c)", "apply (simp add: iT_finite iT_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_card_if: \"\n  card [r, mod m, c] = (if m = 0 then Suc 0 else Suc c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card [ r, mod m, c ] = (if m = 0 then Suc 0 else Suc c)", "by (simp add: iMODb_mod_0_card iMODb_card)"], ["", "lemmas iT_card =\n  iFROM_card\n  iTILL_card\n  iIN_card\n  iMOD_card_if\n  iMODb_card_if"], ["", "text \\<open>Cardinality with \\<open>icard\\<close>\\<close>"], ["", "lemma iFROM_icard: \"icard [n\\<dots>] = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [n\\<dots>] = \\<infinity>", "by (simp add: iFROM_infinite)"], ["", "lemma iTILL_icard: \"icard [\\<dots>n] = enat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [\\<dots>n] = enat (Suc n)", "by (simp add: icard_finite iT_finite iT_card)"], ["", "lemma iIN_icard: \"icard [n\\<dots>,d] = enat (Suc d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [n\\<dots>,d] = enat (Suc d)", "by (simp add: icard_finite iT_finite iT_card)"], ["", "lemma iMOD_0_icard: \"icard [r, mod 0] = eSuc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [ r, mod 0 ] = eSuc 0", "by (simp add: icard_finite iT_finite iT_card eSuc_enat)"], ["", "lemma iMOD_icard: \"0 < m \\<Longrightarrow> icard [r, mod m] = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> icard [ r, mod m ] = \\<infinity>", "by (simp add: iMOD_infinite)"], ["", "lemma iMOD_icard_if: \"icard [r, mod m] = (if m = 0 then eSuc 0 else \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [ r, mod m ] = (if m = 0 then eSuc 0 else \\<infinity>)", "by (simp add: icard_finite iT_finite iT_infinite eSuc_enat iT_card)"], ["", "lemma iMODb_mod_0_icard: \"icard [r, mod 0, c] = eSuc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [ r, mod 0, c ] = eSuc 0", "by (simp add: icard_finite iT_finite eSuc_enat iT_card)"], ["", "lemma iMODb_icard: \"0 < m \\<Longrightarrow> icard [r, mod m, c] = enat (Suc c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> icard [ r, mod m, c ] = enat (Suc c)", "by (simp add: icard_finite iT_finite iMODb_card)"], ["", "lemma iMODb_icard_if: \"icard [r, mod m, c] = enat (if m = 0 then Suc 0 else Suc c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard [ r, mod m, c ] = enat (if m = 0 then Suc 0 else Suc c)", "by (simp add: icard_finite iT_finite iMODb_card_if)"], ["", "lemmas iT_icard =\n  iFROM_icard\n  iTILL_icard\n  iIN_icard\n  iMOD_icard_if\n  iMODb_icard_if"], ["", "subsection \\<open>Functions \\<open>inext\\<close> and \\<open>iprev\\<close> with intervals\\<close>"], ["", "(*\nlemma \"inext 5 [\\<dots>10] = 6\"\napply (simp add: inext_def)\napply (simp add: iT_iff)\napply (simp add: iT_cut_greater)\napply (simp add: iT_not_empty)\napply (simp add: iT_Min)\ndone\nlemma \"inext 12 [\\<dots>10] = 12\"\napply (simp add: inext_def)\napply (simp add: iT_iff)\ndone\n\nlemma \"inext 5 [4\\<dots>,5] = 6\"\napply (simp add: inext_def)\napply (simp add: iT_iff)\napply (simp add: iT_cut_greater)\napply (simp add: iT_not_empty)\napply (simp add: iT_Min)\ndone\nlemma \"inext 14 [2, mod 4] = 18\"\napply (simp add: inext_def)\napply safe\napply (simp add: iMOD_cut_greater iT_iff \n  iT_Min)\napply (simp add: iT_iff)\napply (simp add: iMOD_cut_greater iT_iff \n  iT_not_empty)\ndone\n\nlemma \"iprev 5 [\\<dots>10] = 4\"\napply (simp add: iprev_def)\napply (simp add: iT_iff)\napply (simp add: i_cut_defs)\napply safe\napply (simp add: iT_iff)\napply (rule le_antisym)\napply (rule iffD2[OF Max_le_iff])\napply fastforce+\ndone\n*)"], ["", "lemma \n  iFROM_inext: \"t \\<in> [n\\<dots>] \\<Longrightarrow> inext t [n\\<dots>] = Suc t\" and\n  iTILL_inext: \"t < n \\<Longrightarrow> inext t [\\<dots>n] = Suc t\" and\n  iIN_inext: \"\\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> inext t [n\\<dots>,d] = Suc t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> [n\\<dots>] \\<Longrightarrow> inext t [n\\<dots>] = Suc t) &&&\n    (t < n \\<Longrightarrow> inext t [\\<dots>n] = Suc t) &&&\n    (\\<lbrakk>n \\<le> t; t < n + d\\<rbrakk>\n     \\<Longrightarrow> inext t [n\\<dots>,d] = Suc t)", "by (simp add: iT_defs inext_atLeast inext_atMost inext_atLeastAtMost)+"], ["", "lemma \n  iFROM_iprev': \"t \\<in> [n\\<dots>] \\<Longrightarrow> iprev (Suc t) [n\\<dots>] = t\" and\n  iFROM_iprev: \"n < t  \\<Longrightarrow> iprev t [n\\<dots>] = t - Suc 0\" and\n  iTILL_iprev: \"t \\<in> [\\<dots>n] \\<Longrightarrow> iprev t [\\<dots>n] = t - Suc 0\" and\n  iIN_iprev: \"\\<lbrakk> n < t; t \\<le> n + d \\<rbrakk> \\<Longrightarrow> iprev t [n\\<dots>,d] = t - Suc 0\" and\n  iIN_iprev': \"\\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> iprev (Suc t) [n\\<dots>,d] = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((t \\<in> [n\\<dots>] \\<Longrightarrow> iprev (Suc t) [n\\<dots>] = t) &&&\n     (n < t \\<Longrightarrow> iprev t [n\\<dots>] = t - Suc 0)) &&&\n    (t \\<in> [\\<dots>n] \\<Longrightarrow>\n     iprev t [\\<dots>n] = t - Suc 0) &&&\n    (\\<lbrakk>n < t; t \\<le> n + d\\<rbrakk>\n     \\<Longrightarrow> iprev t [n\\<dots>,d] = t - Suc 0) &&&\n    (\\<lbrakk>n \\<le> t; t < n + d\\<rbrakk>\n     \\<Longrightarrow> iprev (Suc t) [n\\<dots>,d] = t)", "by (simp add: iT_defs iprev_atLeast iprev_atMost iprev_atLeastAtMost)+"], ["", "lemma iMOD_inext: \"t \\<in> [r, mod m] \\<Longrightarrow> inext t [r, mod m] = t + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow> inext t [ r, mod m ] = t + m", "by (clarsimp simp add: inext_def iMOD_cut_greater iT_iff iT_Min iT_not_empty mod_eq_imp_diff_mod_0)"], ["", "lemma iMOD_iprev: \"\\<lbrakk> t \\<in> [r, mod m]; r < t \\<rbrakk> \\<Longrightarrow> iprev t [r, mod m] = t - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t\\<rbrakk>\n    \\<Longrightarrow> iprev t [ r, mod m ] = t - m", "apply (case_tac \"m = 0\", simp add: iMOD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev t [ r, mod m ] = t - m", "apply (clarsimp simp add: iprev_def iMOD_cut_less iT_iff iT_Max iT_not_empty minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t mod m = r mod m; r < t; 0 < m\\<rbrakk>\n    \\<Longrightarrow> r + (t - Suc (r + (t - Suc r) mod m)) = t - m", "apply (simp del: add_Suc_right add: add_Suc_right[symmetric] mod_eq_imp_diff_mod_eq_divisor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t mod m = r mod m; r < t; 0 < m\\<rbrakk>\n    \\<Longrightarrow> r + (t - (r + m)) = t - m", "apply (simp add: less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_iprev': \"t \\<in> [r, mod m] \\<Longrightarrow> iprev (t + m) [r, mod m] = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow> iprev (t + m) [ r, mod m ] = t", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; m = 0\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m ] = t\n 2. \\<lbrakk>t \\<in> [ r, mod m ]; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m ] = t", "apply (simp add: iMOD_0 iIN_0 iprev_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m ] = t", "apply (simp add: iMOD_iprev iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_inext: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> \n  inext t [r, mod m, c] = t + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> inext t [ r, mod m, c ] = t + m", "by (clarsimp simp add: inext_def iMODb_cut_greater iT_iff iT_Min iT_not_empty mod_eq_imp_diff_mod_0)"], ["", "lemma iMODb_iprev: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; r < t \\<rbrakk> \\<Longrightarrow> \n  iprev t [r, mod m, c] = t - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t\\<rbrakk>\n    \\<Longrightarrow> iprev t [ r, mod m, c ] = t - m", "apply (case_tac \"m = 0\", simp add: iMODb_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev t [ r, mod m, c ] = t - m", "apply (clarsimp simp add: iprev_def iMODb_cut_less iT_iff iT_Max iT_not_empty minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < t; 0 < m; t mod m = r mod m; t \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> r + (t - Suc (r + (t - Suc r) mod m)) = t - m", "apply (simp del: add_Suc_right add: add_Suc_right[symmetric] mod_eq_imp_diff_mod_eq_divisor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < t; 0 < m; t mod m = r mod m; t \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> r + (t - (r + m)) = t - m", "apply (simp add: less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_iprev': \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> \n  iprev (t + m) [r, mod m, c] = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m, c ] = t", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c; m = 0\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m, c ] = t\n 2. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m, c ] = t", "apply (simp add: iMODb_mod_0 iIN_0 iprev_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev (t + m) [ r, mod m, c ] = t", "apply (simp add: iMODb_iprev iT_iff less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_inext =\n  iFROM_inext\n  iTILL_inext\n  iIN_inext\n  iMOD_inext\n  iMODb_inext"], ["", "lemmas iT_iprev =\n  iFROM_iprev'\n  iFROM_iprev\n  iTILL_iprev\n  iIN_iprev\n  iIN_iprev'\n  iMOD_iprev\n  iMOD_iprev'\n  iMODb_iprev\n  iMODb_iprev'"], ["", "lemma iFROM_inext_if: \"\n  inext t [n\\<dots>] = (if t \\<in> [n\\<dots>] then Suc t else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext t [n\\<dots>] = (if t \\<in> [n\\<dots>] then Suc t else t)", "by (simp add: iFROM_inext not_in_inext_fix)"], ["", "lemma iTILL_inext_if: \"\n  inext t [\\<dots>n] = (if t < n then Suc t else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext t [\\<dots>n] = (if t < n then Suc t else t)", "by (simp add: iTILL_inext iT_finite iT_Max inext_ge_Max)"], ["", "lemma iIN_inext_if: \"\n  inext t [n\\<dots>,d] = (if n \\<le> t \\<and> t < n + d then Suc t else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext t [n\\<dots>,d] = (if n \\<le> t \\<and> t < n + d then Suc t else t)", "by (fastforce simp: iIN_inext iT_iff not_in_inext_fix iT_finite iT_Max inext_ge_Max)"], ["", "lemma iMOD_inext_if: \"\n  inext t [r, mod m] = (if t \\<in> [r, mod m] then t + m else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext t [ r, mod m ] = (if t \\<in> [ r, mod m ] then t + m else t)", "by (simp add: iMOD_inext not_in_inext_fix)"], ["", "lemma iMODb_inext_if: \"\n  inext t [r, mod m, c] = \n  (if t \\<in> [r, mod m, c] \\<and> t < r + m * c then t + m else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext t [ r, mod m, c ] =\n    (if t \\<in> [ r, mod m, c ] \\<and> t < r + m * c then t + m else t)", "by (fastforce simp: iMODb_inext iT_iff not_in_inext_fix iT_finite iT_Max inext_ge_Max)"], ["", "lemmas iT_inext_if =\n  iFROM_inext_if\n  iTILL_inext_if\n  iIN_inext_if\n  iMOD_inext_if\n  iMODb_inext_if"], ["", "lemma iFROM_iprev_if: \"\n  iprev t [n\\<dots>] = (if n < t then t - Suc 0 else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev t [n\\<dots>] = (if n < t then t - Suc 0 else t)", "by (simp add: iFROM_iprev iT_Min iprev_le_iMin)"], ["", "lemma iTILL_iprev_if: \"\n  iprev t [\\<dots>n] = (if t \\<in> [\\<dots>n] then t - Suc 0 else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev t [\\<dots>n] = (if t \\<in> [\\<dots>n] then t - Suc 0 else t)", "by (simp add: iTILL_iprev not_in_iprev_fix)"], ["", "lemma iIN_iprev_if: \"\n  iprev t [n\\<dots>,d] = (if n < t \\<and> t \\<le> n + d  then t - Suc 0 else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev t [n\\<dots>,d] =\n    (if n < t \\<and> t \\<le> n + d then t - Suc 0 else t)", "by (fastforce simp: iIN_iprev iT_iff not_in_iprev_fix iT_Min iprev_le_iMin)"], ["", "lemma iMOD_iprev_if: \"\n  iprev t [r, mod m] = \n  (if t \\<in> [r, mod m] \\<and> r < t then t - m else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev t [ r, mod m ] =\n    (if t \\<in> [ r, mod m ] \\<and> r < t then t - m else t)", "by (fastforce simp add: iMOD_iprev iT_iff not_in_iprev_fix iT_Min iprev_le_iMin)"], ["", "lemma iMODb_iprev_if: \"\n  iprev t [r, mod m, c] = \n  (if t \\<in> [r, mod m, c] \\<and> r < t then t - m else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev t [ r, mod m, c ] =\n    (if t \\<in> [ r, mod m, c ] \\<and> r < t then t - m else t)", "by (fastforce simp add: iMODb_iprev iT_iff not_in_iprev_fix iT_Min iprev_le_iMin)"], ["", "lemmas iT_iprev_if =\n  iFROM_iprev_if\n  iTILL_iprev_if\n  iIN_iprev_if\n  iMOD_iprev_if\n  iMODb_iprev_if"], ["", "text \\<open>\n  The difference between an element and the next/previous element is constant\n  if the element is different from Min/Max of the interval\\<close>"], ["", "lemma iFROM_inext_diff_const: \"\n  t \\<in> [n\\<dots>] \\<Longrightarrow> inext t [n\\<dots>] - t = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>] \\<Longrightarrow> inext t [n\\<dots>] - t = Suc 0", "by (simp add: iFROM_inext)"], ["", "lemma iFROM_iprev_diff_const: \"\n  n < t \\<Longrightarrow> t - iprev t [n\\<dots>] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < t \\<Longrightarrow> t - iprev t [n\\<dots>] = Suc 0", "by (simp add: iFROM_iprev )"], ["", "lemma iFROM_iprev_diff_const': \"\n  t \\<in> [n\\<dots>] \\<Longrightarrow> Suc t - iprev (Suc t) [n\\<dots>] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [n\\<dots>] \\<Longrightarrow>\n    Suc t - iprev (Suc t) [n\\<dots>] = Suc 0", "by (simp add: iFROM_iprev')"], ["", "lemma iTILL_inext_diff_const: \"\n  t < n \\<Longrightarrow> inext t [\\<dots>n] - t = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < n \\<Longrightarrow> inext t [\\<dots>n] - t = Suc 0", "by (simp add: iTILL_inext)"], ["", "lemma iTILL_iprev_diff_const: \"\n  \\<lbrakk> t \\<in> [\\<dots>n]; 0 < t \\<rbrakk> \\<Longrightarrow> t - iprev t [\\<dots>n] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [\\<dots>n]; 0 < t\\<rbrakk>\n    \\<Longrightarrow> t - iprev t [\\<dots>n] = Suc 0", "by (simp add: iTILL_iprev)"], ["", "lemma iIN_inext_diff_const: \"\n  \\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> inext t [n\\<dots>,d] - t = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> t; t < n + d\\<rbrakk>\n    \\<Longrightarrow> inext t [n\\<dots>,d] - t = Suc 0", "by (simp add: iIN_inext)"], ["", "lemma iIN_iprev_diff_const: \"\n  \\<lbrakk> n < t; t \\<le> n + d \\<rbrakk> \\<Longrightarrow> t - iprev t [n\\<dots>,d] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < t; t \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> t - iprev t [n\\<dots>,d] = Suc 0", "by (simp add: iIN_iprev)"], ["", "lemma iIN_iprev_diff_const': \"\n  \\<lbrakk> n \\<le> t; t < n + d \\<rbrakk> \\<Longrightarrow> Suc t - iprev (Suc t) [n\\<dots>,d] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> t; t < n + d\\<rbrakk>\n    \\<Longrightarrow> Suc t - iprev (Suc t) [n\\<dots>,d] = Suc 0", "by (simp add: iIN_iprev)"], ["", "lemma iMOD_inext_diff_const: \"\n  t \\<in> [r, mod m] \\<Longrightarrow> inext t [r, mod m] - t = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow> inext t [ r, mod m ] - t = m", "by (simp add: iMOD_inext)"], ["", "lemma iMOD_iprev_diff_const': \"\n  t \\<in> [r, mod m] \\<Longrightarrow> (t + m) - iprev (t + m) [r, mod m] = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> [ r, mod m ] \\<Longrightarrow>\n    t + m - iprev (t + m) [ r, mod m ] = m", "by (simp add: iMOD_iprev')"], ["", "lemma iMOD_iprev_diff_const: \"\n  \\<lbrakk> t \\<in> [r, mod m]; r < t \\<rbrakk> \\<Longrightarrow> t - iprev t [r, mod m] = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m ]; r < t\\<rbrakk>\n    \\<Longrightarrow> t - iprev t [ r, mod m ] = m", "apply (simp add: iMOD_iprev iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t mod m = r mod m; r < t\\<rbrakk>\n    \\<Longrightarrow> t - (t - m) = m", "apply (drule less_mod_eq_imp_add_divisor_le[where m=m], simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_inext_diff_const: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> inext t [r, mod m, c] - t = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> inext t [ r, mod m, c ] - t = m", "by (simp add: iMODb_inext)"], ["", "lemma iMODb_iprev_diff_const': \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; t < r + m * c \\<rbrakk> \\<Longrightarrow> (t + m) - iprev (t + m) [r, mod m, c] = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; t < r + m * c\\<rbrakk>\n    \\<Longrightarrow> t + m - iprev (t + m) [ r, mod m, c ] = m", "by (simp add: iMODb_iprev')"], ["", "lemma iMODb_iprev_diff_const: \"\n  \\<lbrakk> t \\<in> [r, mod m, c]; r < t \\<rbrakk> \\<Longrightarrow> t - iprev t [r, mod m, c] = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> [ r, mod m, c ]; r < t\\<rbrakk>\n    \\<Longrightarrow> t - iprev t [ r, mod m, c ] = m", "apply (simp add: iMODb_iprev iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t mod m = r mod m \\<and> t \\<le> r + m * c; r < t\\<rbrakk>\n    \\<Longrightarrow> t - (t - m) = m", "apply (drule less_mod_eq_imp_add_divisor_le[where m=m], simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_inext_diff_const =\n  iFROM_inext_diff_const\n  iTILL_inext_diff_const\n  iIN_inext_diff_const\n  iMOD_inext_diff_const\n  iMODb_inext_diff_const"], ["", "lemmas iT_iprev_diff_const =\n  iFROM_iprev_diff_const\n  iFROM_iprev_diff_const'\n  iTILL_iprev_diff_const\n  iIN_iprev_diff_const\n  iIN_iprev_diff_const'\n  iMOD_iprev_diff_const'\n  iMOD_iprev_diff_const\n  iMODb_iprev_diff_const'\n  iMODb_iprev_diff_const"], ["", "subsubsection \\<open>Mirroring of intervals\\<close>"], ["", "lemma \n  iIN_mirror_elem: \"mirror_elem x [n\\<dots>,d] = n + n + d - x\" and\n  iTILL_mirror_elem: \"mirror_elem x [\\<dots>n] = n - x\" and\n  iMODb_mirror_elem: \"mirror_elem x [r, mod m, c] = r + r + m * c - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mirror_elem x [n\\<dots>,d] = n + n + d - x &&&\n    mirror_elem x [\\<dots>n] = n - x &&&\n    mirror_elem x [ r, mod m, c ] = r + r + m * c - x", "by (simp add: mirror_elem_def nat_mirror_def iT_Min iT_Max)+"], ["", "lemma iMODb_imirror_bounds: \"\n  r' + m' * c' \\<le> l + r \\<Longrightarrow> \n  imirror_bounds [r', mod m', c'] l r = [l + r - r' - m' * c', mod m', c']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' + m' * c' \\<le> l + r \\<Longrightarrow>\n    imirror_bounds [ r', mod m', c' ] l r =\n    [ l + r - r' - m' * c', mod m', c' ]", "apply (clarsimp simp: set_eq_iff Bex_def imirror_bounds_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       r' + m' * c' \\<le> l + r \\<Longrightarrow>\n       (\\<exists>xa.\n           xa mod m' = r' mod m' \\<and>\n           r' \\<le> xa \\<and> xa \\<le> r' + m' * c' \\<and> x = l + r - xa) =\n       (x mod m' = (l + r - (r' + m' * c')) mod m' \\<and>\n        l + r - (r' + m' * c') \\<le> x \\<and> x \\<le> l + r - r')", "apply (frule diff_le_mono[of _ _ r'], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa mod m' = r' mod m' \\<and>\n                             r' \\<le> xa \\<and>\n                             xa \\<le> r' + m' * c' \\<and> x = l + r - xa) =\n                         (x mod m' = (l + r - (r' + m' * c')) mod m' \\<and>\n                          l + r - (r' + m' * c') \\<le> x \\<and>\n                          x \\<le> l + r - r')", "apply (simp add: mod_diff_right_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa mod m' = r' mod m' \\<and>\n                             r' \\<le> xa \\<and>\n                             xa \\<le> r' + m' * c' \\<and> x = l + r - xa) =\n                         (x mod m' = (l + r - r' mod m') mod m' \\<and>\n                          l + r - (r' + m' * c') \\<le> x \\<and>\n                          x \\<le> l + r - r')", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        \\<exists>xa.\n           xa mod m' = r' mod m' \\<and>\n           r' \\<le> xa \\<and>\n           xa \\<le> r' + m' * c' \\<and> x = l + r - xa\\<rbrakk>\n       \\<Longrightarrow> x mod m' = (l + r - r' mod m') mod m' \\<and>\n                         l + r - (r' + m' * c') \\<le> x \\<and>\n                         x \\<le> l + r - r'\n 2. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m' \\<and>\n        l + r - (r' + m' * c') \\<le> x \\<and> x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m' = r' mod m' \\<and>\n                            r' \\<le> xa \\<and>\n                            xa \\<le> r' + m' * c' \\<and> x = l + r - xa", "apply (clarsimp, rename_tac x')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x' mod m' = r' mod m'; r' \\<le> x'; x' \\<le> r' + m' * c'\\<rbrakk>\n       \\<Longrightarrow> (l + r - x') mod m' =\n                         (l + r - r' mod m') mod m' \\<and>\n                         l + r - (r' + m' * c') \\<le> l + r - x' \\<and>\n                         l + r - x' \\<le> l + r - r'\n 2. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m' \\<and>\n        l + r - (r' + m' * c') \\<le> x \\<and> x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m' = r' mod m' \\<and>\n                            r' \\<le> xa \\<and>\n                            xa \\<le> r' + m' * c' \\<and> x = l + r - xa", "apply (rule_tac a=x' in ssubst[OF mod_diff_right_eq, rule_format], simp+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x' mod m' = r' mod m'; r' \\<le> x'; x' \\<le> r' + m' * c'\\<rbrakk>\n       \\<Longrightarrow> l + r - (r' + m' * c') \\<le> l + r - x' \\<and>\n                         l + r - x' \\<le> l + r - r'\n 2. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m' \\<and>\n        l + r - (r' + m' * c') \\<le> x \\<and> x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m' = r' mod m' \\<and>\n                            r' \\<le> xa \\<and>\n                            xa \\<le> r' + m' * c' \\<and> x = l + r - xa", "apply (simp add: diff_le_mono2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m' \\<and>\n        l + r - (r' + m' * c') \\<le> x \\<and> x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m' = r' mod m' \\<and>\n                            r' \\<le> xa \\<and>\n                            xa \\<le> r' + m' * c' \\<and> x = l + r - xa", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m';\n        l + r - (r' + m' * c') \\<le> x; x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m' = r' mod m' \\<and>\n                            r' \\<le> xa \\<and>\n                            xa \\<le> r' + m' * c' \\<and> x = l + r - xa", "apply (rule_tac x=\"l+r-x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m';\n        l + r - (r' + m' * c') \\<le> x; x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> (l + r - x) mod m' = r' mod m' \\<and>\n                         r' \\<le> l + r - x \\<and>\n                         l + r - x \\<le> r' + m' * c' \\<and>\n                         x = l + r - (l + r - x)", "apply (simp add: le_diff_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r; m' * c' \\<le> l + r - r';\n        x mod m' = (l + r - r' mod m') mod m'; l + r - x \\<le> r' + m' * c';\n        x \\<le> l + r - r'\\<rbrakk>\n       \\<Longrightarrow> (l + r - x) mod m' = r' mod m' \\<and>\n                         r' \\<le> l + r - x", "apply (simp add: le_diff_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r;\n        x mod m' = (l + r - r' mod m') mod m'; l + r - x \\<le> r' + m' * c';\n        x + r' \\<le> l + r\\<rbrakk>\n       \\<Longrightarrow> (l + r - x) mod m' = r' mod m'", "apply (subst mod_sub_eq_mod_swap, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r' + m' * c' \\<le> l + r;\n        x mod m' = (l + r - r' mod m') mod m'; l + r - x \\<le> r' + m' * c';\n        x + r' \\<le> l + r\\<rbrakk>\n       \\<Longrightarrow> (l + r - r') mod m' = (l + r - r' mod m') mod m'", "apply (simp add: mod_diff_right_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_imirror_bounds: \"\n  n + d \\<le> l + r \\<Longrightarrow> imirror_bounds [n\\<dots>,d] l r = [l + r - n - d\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + d \\<le> l + r \\<Longrightarrow>\n    imirror_bounds [n\\<dots>,d] l r = [l + r - n - d\\<dots>,d]", "apply (insert iMODb_imirror_bounds[of n \"Suc 0\" d l r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n + d \\<le> l + r;\n     n + Suc 0 * d \\<le> l + r \\<Longrightarrow>\n     imirror_bounds [ n, mod Suc 0, d ] l r =\n     [ l + r - n - Suc 0 * d, mod Suc 0, d ]\\<rbrakk>\n    \\<Longrightarrow> imirror_bounds [n\\<dots>,d] l r =\n                      [l + r - n - d\\<dots>,d]", "apply (simp add: iMODb_mod_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_imirror_bounds: \"\n  n \\<le> l + r \\<Longrightarrow> imirror_bounds [\\<dots>n] l r = [l + r - n\\<dots>,n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> l + r \\<Longrightarrow>\n    imirror_bounds [\\<dots>n] l r = [l + r - n\\<dots>,n]", "apply (insert iIN_imirror_bounds[of 0 n l r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> l + r;\n     0 + n \\<le> l + r \\<Longrightarrow>\n     imirror_bounds [0\\<dots>,n] l r = [l + r - 0 - n\\<dots>,n]\\<rbrakk>\n    \\<Longrightarrow> imirror_bounds [\\<dots>n] l r = [l + r - n\\<dots>,n]", "apply (simp add: iIN_0_iTILL_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_imirror_bounds =\n  iTILL_imirror_bounds\n  iIN_imirror_bounds\n  iMODb_imirror_bounds"], ["", "lemma iMODb_imirror_ident: \"imirror [r, mod m, c] = [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imirror [ r, mod m, c ] = [ r, mod m, c ]", "by (simp add: imirror_eq_imirror_bounds iMODb_Min iMODb_Max iMODb_imirror_bounds)"], ["", "lemma iIN_imirror_ident: \"imirror [n\\<dots>,d] = [n\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imirror [n\\<dots>,d] = [n\\<dots>,d]", "by (simp add: iMODb_mod_1[symmetric] iMODb_imirror_ident)"], ["", "lemma iTILL_imirror_ident: \"imirror [\\<dots>n] = [\\<dots>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imirror [\\<dots>n] = [\\<dots>n]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_imirror_ident)"], ["", "lemmas iT_imirror_ident =\n  iTILL_imirror_ident\n  iIN_imirror_ident\n  iMODb_imirror_ident"], ["", "subsubsection \\<open>Functions @{term inext_nth} and @{term iprev_nth} on intervals\\<close>"], ["", "lemma iFROM_inext_nth : \"[n\\<dots>] \\<rightarrow> a = n + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<rightarrow> a = n + a", "by (simp add: iT_defs inext_nth_atLeast)"], ["", "lemma iIN_inext_nth : \"a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<rightarrow> a = n + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<rightarrow> a = n + a", "by (simp add: iT_defs inext_nth_atLeastAtMost)"], ["", "lemma iIN_iprev_nth: \"a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<leftarrow> a = n + d - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<leftarrow> a = n + d - a", "by (simp add: iT_defs iprev_nth_atLeastAtMost)"], ["", "lemma iIN_inext_nth_if : \"\n  [n\\<dots>,d] \\<rightarrow> a = (if a \\<le> d then n + a else n + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<rightarrow> a = (if a \\<le> d then n + a else n + d)", "by (simp add: iIN_inext_nth inext_nth_card_Max iT_finite iT_not_empty iT_Max iT_card)"], ["", "lemma iIN_iprev_nth_if: \"\n  [n\\<dots>,d] \\<leftarrow> a = (if a \\<le> d then n + d - a else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<leftarrow> a = (if a \\<le> d then n + d - a else n)", "by (simp add: iIN_iprev_nth iprev_nth_card_iMin iT_finite iT_not_empty iT_Min iT_card)"], ["", "lemma iTILL_inext_nth : \"a \\<le> n \\<Longrightarrow> [\\<dots>n] \\<rightarrow> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> n \\<Longrightarrow> [\\<dots>n] \\<rightarrow> a = a", "by (simp add: iTILL_def inext_nth_atMost)"], ["", "lemma iTILL_inext_nth_if : \"\n  [\\<dots>n] \\<rightarrow> a = (if a \\<le> n then a else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<rightarrow> a = (if a \\<le> n then a else n)", "by (insert iIN_inext_nth_if[of 0 n a], simp add: iIN_0_iTILL_conv)"], ["", "lemma iTILL_iprev_nth: \"a \\<le> n \\<Longrightarrow> [\\<dots>n] \\<leftarrow> a = n - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> n \\<Longrightarrow> [\\<dots>n] \\<leftarrow> a = n - a", "by (simp add: iTILL_def iprev_nth_atMost)"], ["", "lemma iTILL_iprev_nth_if: \"\n  [\\<dots>n] \\<leftarrow> a= (if a \\<le> n then n - a else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<leftarrow> a = (if a \\<le> n then n - a else 0)", "by (insert iIN_iprev_nth_if[of 0 n a], simp add: iIN_0_iTILL_conv)"], ["", "lemma iMOD_inext_nth: \"[r, mod m] \\<rightarrow> a = r + m * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<rightarrow> a = r + m * a", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [ r, mod m ] \\<rightarrow> 0 = r + m * 0\n 2. \\<And>a.\n       [ r, mod m ] \\<rightarrow> a = r + m * a \\<Longrightarrow>\n       [ r, mod m ] \\<rightarrow> Suc a = r + m * Suc a", "apply (simp add: iT_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       [ r, mod m ] \\<rightarrow> a = r + m * a \\<Longrightarrow>\n       [ r, mod m ] \\<rightarrow> Suc a = r + m * Suc a", "apply (simp add: iMOD_inext_if iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_inext_nth: \"a \\<le> c \\<Longrightarrow> [r, mod m, c] \\<rightarrow> a = r + m * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> c \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> a = r + m * a", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> c; m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> a = r + m * a\n 2. \\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> a = r + m * a", "apply (simp add: iMODb_mod_0 iIN_0 inext_nth_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> a = r + m * a", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> 0 = r + m * 0\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> a =\n                                  r + m * a;\n        Suc a \\<le> c; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> Suc a = r + m * Suc a", "apply (simp add: iMODb_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> a =\n                                  r + m * a;\n        Suc a \\<le> c; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<rightarrow> Suc a = r + m * Suc a", "apply (simp add: iMODb_inext_if iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_inext_nth_if: \"\n  [r, mod m, c] \\<rightarrow> a = (if a \\<le> c then r + m * a else r + m * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<rightarrow> a =\n    (if a \\<le> c then r + m * a else r + m * c)", "by (simp add: iMODb_inext_nth inext_nth_card_Max iT_finite iT_not_empty iT_Max iT_card)"], ["", "lemma iMODb_iprev_nth: \"\n  a \\<le> c \\<Longrightarrow> [r, mod m, c] \\<leftarrow> a = r + m * (c - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> c \\<Longrightarrow>\n    [ r, mod m, c ] \\<leftarrow> a = r + m * (c - a)", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> c; m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> a = r + m * (c - a)\n 2. \\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> a = r + m * (c - a)", "apply (simp add: iMODb_mod_0 iIN_0 iprev_nth_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> a = r + m * (c - a)", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> c; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> 0 = r + m * (c - 0)\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> a =\n                                  r + m * (c - a);\n        Suc a \\<le> c; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> Suc a =\n                         r + m * (c - Suc a)", "apply (simp add: iMODb_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>a \\<le> c; m \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> a =\n                                  r + m * (c - a);\n        Suc a \\<le> c; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<leftarrow> Suc a =\n                         r + m * (c - Suc a)", "apply (simp add: iMODb_iprev_if iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>[ r, mod m, c ] \\<leftarrow> a = r + m * (c - a);\n        Suc a \\<le> c; 0 < m\\<rbrakk>\n       \\<Longrightarrow> r + m * (c - a) - m = r + m * (c - Suc a)", "apply (frule mult_left_mono[of _ _ m], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>[ r, mod m, c ] \\<leftarrow> a = r + m * (c - a);\n        Suc a \\<le> c; 0 < m; m * Suc a \\<le> m * c\\<rbrakk>\n       \\<Longrightarrow> r + m * (c - a) - m = r + m * (c - Suc a)", "apply (simp add: diff_mult_distrib2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_iprev_nth_if: \"\n  [r, mod m, c] \\<leftarrow> a = (if a \\<le> c then r + m * (c - a) else r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<leftarrow> a =\n    (if a \\<le> c then r + m * (c - a) else r)", "by (simp add: iMODb_iprev_nth iprev_nth_card_iMin iT_finite iT_not_empty iT_Min iT_card)"], ["", "lemma iIN_iFROM_inext_nth: \"\n  a \\<le> d \\<Longrightarrow> [n\\<dots>,d] \\<rightarrow> a = [n\\<dots>] \\<rightarrow> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> d \\<Longrightarrow>\n    [n\\<dots>,d] \\<rightarrow> a = [n\\<dots>] \\<rightarrow> a", "by (simp add: iIN_inext_nth iFROM_inext_nth)"], ["", "lemma iIN_iFROM_inext: \"\n  a < n + d \\<Longrightarrow> inext a [n\\<dots>,d] = inext a [n\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < n + d \\<Longrightarrow> inext a [n\\<dots>,d] = inext a [n\\<dots>]", "by (simp add: iT_inext_if iT_iff)"], ["", "lemma iMOD_iMODb_inext_nth: \"\n  a \\<le> c \\<Longrightarrow> [r, mod m, c] \\<rightarrow> a = [r, mod m] \\<rightarrow> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> c \\<Longrightarrow>\n    [ r, mod m, c ] \\<rightarrow> a = [ r, mod m ] \\<rightarrow> a", "by (simp add: iMOD_inext_nth iMODb_inext_nth)"], ["", "lemma iMOD_iMODb_inext: \"\n  a < r + m * c \\<Longrightarrow> inext a [r, mod m, c] = inext a [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < r + m * c \\<Longrightarrow>\n    inext a [ r, mod m, c ] = inext a [ r, mod m ]", "by (simp add: iT_inext_if iT_iff)"], ["", "lemma iMOD_inext_nth_Suc_diff: \"\n  ([r, mod m] \\<rightarrow> (Suc n)) - ([r, mod m] \\<rightarrow> n) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m ] \\<rightarrow> Suc n) - ([ r, mod m ] \\<rightarrow> n) = m", "by (simp add: iMOD_inext_nth del: inext_nth.simps)"], ["", "lemma iMOD_inext_nth_diff: \"\n  ([r, mod m] \\<rightarrow> a) - ([r, mod m] \\<rightarrow> b) = (a - b) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m ] \\<rightarrow> a) - ([ r, mod m ] \\<rightarrow> b) =\n    (a - b) * m", "by (simp add: iMOD_inext_nth diff_mult_distrib mult.commute[of m])"], ["", "lemma iMODb_inext_nth_diff: \"\\<lbrakk> a \\<le> c; b \\<le> c \\<rbrakk> \\<Longrightarrow>\n  ([r, mod m, c] \\<rightarrow> a) - ([r, mod m, c] \\<rightarrow> b) = (a - b) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> c; b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m, c ] \\<rightarrow> a) -\n                      ([ r, mod m, c ] \\<rightarrow> b) =\n                      (a - b) * m", "by (simp add: iMODb_inext_nth diff_mult_distrib  mult.commute[of m])"], ["", "subsection \\<open>Induction with intervals\\<close>"], ["", "lemma iFROM_induct: \"\n  \\<lbrakk> P n; \\<And>k. \\<lbrakk> k \\<in> [n\\<dots>]; P k \\<rbrakk> \\<Longrightarrow> P (Suc k); a \\<in> [n\\<dots>] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>]; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule inext_induct[of _ \"[n\\<dots>]\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>]; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> P (iMin [n\\<dots>])\n 2. \\<And>na.\n       \\<lbrakk>P n;\n        \\<And>k.\n           \\<lbrakk>k \\<in> [n\\<dots>]; P k\\<rbrakk>\n           \\<Longrightarrow> P (Suc k);\n        a \\<in> [n\\<dots>]; na \\<in> [n\\<dots>]; P na\\<rbrakk>\n       \\<Longrightarrow> P (inext na [n\\<dots>])\n 3. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>]; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [n\\<dots>]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [n\\<dots>]", "apply (simp add: iT_Min iT_inext_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_induct: \"\n  \\<lbrakk> P n; \\<And>k. \\<lbrakk> k \\<in> [n\\<dots>,d]; k \\<noteq> n + d; P k \\<rbrakk> \\<Longrightarrow> P (Suc k); a \\<in> [n\\<dots>,d] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n + d; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule inext_induct[of _ \"[n\\<dots>,d]\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n + d; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> P (iMin [n\\<dots>,d])\n 2. \\<And>na.\n       \\<lbrakk>P n;\n        \\<And>k.\n           \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n + d; P k\\<rbrakk>\n           \\<Longrightarrow> P (Suc k);\n        a \\<in> [n\\<dots>,d]; na \\<in> [n\\<dots>,d]; P na\\<rbrakk>\n       \\<Longrightarrow> P (inext na [n\\<dots>,d])\n 3. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n + d; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [n\\<dots>,d]", "apply (simp add: iT_Min iT_inext_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_induct: \"\n  \\<lbrakk> P 0; \\<And>k. \\<lbrakk> k \\<in> [\\<dots>n]; k \\<noteq> n; P k \\<rbrakk> \\<Longrightarrow> P (Suc k); a \\<in> [\\<dots>n] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule inext_induct[of _ \"[\\<dots>n]\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P 0;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> P (iMin [\\<dots>n])\n 2. \\<And>na.\n       \\<lbrakk>P 0;\n        \\<And>k.\n           \\<lbrakk>k \\<in> [\\<dots>n]; k \\<noteq> n; P k\\<rbrakk>\n           \\<Longrightarrow> P (Suc k);\n        a \\<in> [\\<dots>n]; na \\<in> [\\<dots>n]; P na\\<rbrakk>\n       \\<Longrightarrow> P (inext na [\\<dots>n])\n 3. \\<lbrakk>P 0;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (Suc k);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [\\<dots>n]", "apply (simp add: iT_Min iT_inext_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_induct: \"\n  \\<lbrakk> P r; \\<And>k. \\<lbrakk> k \\<in> [r, mod m]; P k \\<rbrakk> \\<Longrightarrow> P (k + m); a \\<in> [r, mod m] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P r;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m ]; P k\\<rbrakk>\n        \\<Longrightarrow> P (k + m);\n     a \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule inext_induct[of _ \"[r, mod m]\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P r;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m ]; P k\\<rbrakk>\n        \\<Longrightarrow> P (k + m);\n     a \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> P (iMin [ r, mod m ])\n 2. \\<And>n.\n       \\<lbrakk>P r;\n        \\<And>k.\n           \\<lbrakk>k \\<in> [ r, mod m ]; P k\\<rbrakk>\n           \\<Longrightarrow> P (k + m);\n        a \\<in> [ r, mod m ]; n \\<in> [ r, mod m ]; P n\\<rbrakk>\n       \\<Longrightarrow> P (inext n [ r, mod m ])\n 3. \\<lbrakk>P r;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m ]; P k\\<rbrakk>\n        \\<Longrightarrow> P (k + m);\n     a \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [ r, mod m ]", "apply (simp add: iT_Min iT_inext_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_induct: \"\n  \\<lbrakk> P r; \\<And>k. \\<lbrakk> k \\<in> [r, mod m, c]; k \\<noteq> r + m * c; P k \\<rbrakk> \\<Longrightarrow> P (k + m); a \\<in> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P r;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r + m * c; P k\\<rbrakk>\n        \\<Longrightarrow> P (k + m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule inext_induct[of _ \"[r, mod m, c]\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P r;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r + m * c; P k\\<rbrakk>\n        \\<Longrightarrow> P (k + m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> P (iMin [ r, mod m, c ])\n 2. \\<And>n.\n       \\<lbrakk>P r;\n        \\<And>k.\n           \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r + m * c;\n            P k\\<rbrakk>\n           \\<Longrightarrow> P (k + m);\n        a \\<in> [ r, mod m, c ]; n \\<in> [ r, mod m, c ]; P n\\<rbrakk>\n       \\<Longrightarrow> P (inext n [ r, mod m, c ])\n 3. \\<lbrakk>P r;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r + m * c; P k\\<rbrakk>\n        \\<Longrightarrow> P (k + m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [ r, mod m, c ]", "apply (simp add: iT_Min iT_inext_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_rev_induct: \"\n  \\<lbrakk> P (n + d); \\<And>k. \\<lbrakk> k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k \\<rbrakk> \\<Longrightarrow> P (k - Suc 0); a \\<in> [n\\<dots>,d] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (n + d);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule iprev_induct[of _ \"[n\\<dots>,d]\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>P (n + d);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> P (Max [n\\<dots>,d])\n 2. \\<And>na.\n       \\<lbrakk>P (n + d);\n        \\<And>k.\n           \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k\\<rbrakk>\n           \\<Longrightarrow> P (k - Suc 0);\n        a \\<in> [n\\<dots>,d]; na \\<in> [n\\<dots>,d]; P na\\<rbrakk>\n       \\<Longrightarrow> P (iprev na [n\\<dots>,d])\n 3. \\<lbrakk>P (n + d);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> finite [n\\<dots>,d]\n 4. \\<lbrakk>P (n + d);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [n\\<dots>,d]; k \\<noteq> n; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [n\\<dots>,d]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [n\\<dots>,d]", "apply (simp add: iT_Max iT_finite iT_iprev_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_rev_induct: \"\n  \\<lbrakk> P n; \\<And>k. \\<lbrakk> k \\<in> [\\<dots>n]; 0 < k; P k \\<rbrakk> \\<Longrightarrow> P (k - Suc 0); a \\<in> [\\<dots>n] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; 0 < k; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule iprev_induct[of _ \"[\\<dots>n]\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; 0 < k; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> P (Max [\\<dots>n])\n 2. \\<And>na.\n       \\<lbrakk>P n;\n        \\<And>k.\n           \\<lbrakk>k \\<in> [\\<dots>n]; 0 < k; P k\\<rbrakk>\n           \\<Longrightarrow> P (k - Suc 0);\n        a \\<in> [\\<dots>n]; na \\<in> [\\<dots>n]; P na\\<rbrakk>\n       \\<Longrightarrow> P (iprev na [\\<dots>n])\n 3. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; 0 < k; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> finite [\\<dots>n]\n 4. \\<lbrakk>P n;\n     \\<And>k.\n        \\<lbrakk>k \\<in> [\\<dots>n]; 0 < k; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - Suc 0);\n     a \\<in> [\\<dots>n]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [\\<dots>n]", "apply (fastforce simp: iT_Max iT_finite iT_iprev_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_rev_induct: \"\n  \\<lbrakk> P (r + m * c); \\<And>k. \\<lbrakk> k \\<in> [r, mod m, c]; k \\<noteq> r; P k \\<rbrakk> \\<Longrightarrow> P (k - m); a \\<in> [r, mod m, c] \\<rbrakk> \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (r + m * c);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> P a", "apply (rule iprev_induct[of _ \"[r, mod m, c]\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>P (r + m * c);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> P (Max [ r, mod m, c ])\n 2. \\<And>n.\n       \\<lbrakk>P (r + m * c);\n        \\<And>k.\n           \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r; P k\\<rbrakk>\n           \\<Longrightarrow> P (k - m);\n        a \\<in> [ r, mod m, c ]; n \\<in> [ r, mod m, c ]; P n\\<rbrakk>\n       \\<Longrightarrow> P (iprev n [ r, mod m, c ])\n 3. \\<lbrakk>P (r + m * c);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> finite [ r, mod m, c ]\n 4. \\<lbrakk>P (r + m * c);\n     \\<And>k.\n        \\<lbrakk>k \\<in> [ r, mod m, c ]; k \\<noteq> r; P k\\<rbrakk>\n        \\<Longrightarrow> P (k - m);\n     a \\<in> [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> a \\<in> [ r, mod m, c ]", "apply (simp add: iT_Max iT_finite iT_iprev_if)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}