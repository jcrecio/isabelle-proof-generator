{"file_name": "/home/qj213/afp-2021-10-22/thys/Nat-Interval-Logic/IL_IntervalOperators.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nat-Interval-Logic", "problem_names": ["lemma iT_Plus_image_conv: \"I \\<oplus> k = (\\<lambda>n.(n + k)) ` I\"", "lemma iT_Mult_image_conv: \"I \\<otimes> k = (\\<lambda>n.(n * k)) ` I\"", "lemma iT_Plus_empty: \"{} \\<oplus> k = {}\"", "lemma iT_Mult_empty: \"{} \\<otimes> k = {}\"", "lemma iT_Plus_not_empty: \"I \\<noteq> {} \\<Longrightarrow> I \\<oplus> k \\<noteq> {}\"", "lemma iT_Mult_not_empty: \"I \\<noteq> {} \\<Longrightarrow> I \\<otimes> k \\<noteq> {}\"", "lemma iT_Plus_empty_iff: \"(I \\<oplus> k = {}) = (I = {})\"", "lemma iT_Mult_empty_iff: \"(I \\<otimes> k = {}) = (I = {})\"", "lemma iT_Plus_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<oplus> k \\<subseteq> B \\<oplus> k\"", "lemma iT_Mult_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<otimes> k \\<subseteq> B \\<otimes> k\"", "lemma iT_Mult_0: \"I \\<noteq> {} \\<Longrightarrow> I \\<otimes> 0 = [\\<dots>0]\"", "lemma iT_Plus_mem_iff: \"x \\<in> (I \\<oplus> k) = (k \\<le> x \\<and> (x - k) \\<in> I)\"", "lemma iT_Plus_mem_iff2: \"x + k \\<in> (I \\<oplus> k) = (x \\<in> I)\"", "lemma iT_Mult_mem_iff_0: \"x \\<in> (I \\<otimes> 0) = (I \\<noteq> {} \\<and> x = 0)\"", "lemma iT_Mult_mem_iff: \"\n  0 < k \\<Longrightarrow> x \\<in> (I \\<otimes> k) = (x mod k = 0 \\<and> x div k \\<in> I)\"", "lemma iT_Mult_mem_iff2: \"0 < k \\<Longrightarrow> x * k \\<in> (I \\<otimes> k) = (x \\<in> I)\"", "lemma iT_Plus_singleton: \"{a} \\<oplus> k = {a + k}\"", "lemma iT_Mult_singleton: \"{a} \\<otimes> k = {a * k}\"", "lemma iT_Plus_Un: \"(A \\<union> B) \\<oplus> k = (A \\<oplus> k) \\<union> (B \\<oplus> k)\"", "lemma iT_Mult_Un: \"(A \\<union> B) \\<otimes> k = (A \\<otimes> k) \\<union> (B \\<otimes> k)\"", "lemma iT_Plus_Int: \"(A \\<inter> B) \\<oplus> k = (A \\<oplus> k) \\<inter> (B \\<oplus> k)\"", "lemma iT_Mult_Int: \"0 < k \\<Longrightarrow> (A \\<inter> B) \\<otimes> k = (A \\<otimes> k) \\<inter> (B \\<otimes> k)\"", "lemma iT_Plus_image: \"f ` I \\<oplus> n = (\\<lambda>x. f x + n) ` I\"", "lemma iT_Mult_image: \"f ` I \\<otimes> n = (\\<lambda>x. f x * n) ` I\"", "lemma iT_Plus_commute: \"I \\<oplus> a \\<oplus> b = I \\<oplus> b \\<oplus> a\"", "lemma iT_Mult_commute: \"I \\<otimes> a \\<otimes> b = I \\<otimes> b \\<otimes> a\"", "lemma iT_Plus_assoc:\"I \\<oplus> a \\<oplus> b = I \\<oplus> (a + b)\"", "lemma iT_Mult_assoc:\"I \\<otimes> a \\<otimes> b = I \\<otimes> (a * b)\"", "lemma iT_Plus_Mult_distrib: \"I \\<oplus> n \\<otimes> m = I \\<otimes> m \\<oplus> n * m\"", "lemma \"i \\<otimes> n1 \\<otimes> n2 \\<otimes> n3 \\<otimes> n4 \\<otimes> n5 \\<otimes> n6 \\<otimes> n7 =\n  i \\<otimes> n1 * n2 * n3 * n4 * n5 * n6 * n7\"", "lemma \"i \\<oplus> n1 \\<oplus> n2 \\<oplus> n3 \\<oplus> n4 \\<oplus> n5 = i \\<oplus> n1 + n2 + n3 + n4 + n5\"", "lemma \"i \\<oplus> n1 \\<otimes> m \\<oplus> n2 = i \\<otimes> m \\<oplus> n1 * m + n2\"", "lemma \"i \\<oplus> n1 \\<otimes> m1 \\<otimes> m2 \\<oplus> n2 = i \\<otimes> m1 * m2 \\<oplus> n1 * m1 * m2 + n2\"", "lemma \"n \\<in> I \\<oplus> k \\<Longrightarrow> k \\<le> n\"", "lemma iT_Plus_finite_iff: \"finite (I \\<oplus> k) = finite I\"", "lemma iT_Mult_0_finite: \"finite (I \\<otimes> 0)\"", "lemma iT_Mult_finite_iff: \"0 < k \\<Longrightarrow> finite (I \\<otimes> k) = finite I\"", "lemma iT_Plus_Min: \"I \\<noteq> {} \\<Longrightarrow> iMin (I \\<oplus> k) = iMin I + k\"", "lemma iT_Mult_Min: \"I \\<noteq> {} \\<Longrightarrow> iMin (I \\<otimes> k) = iMin I * k\"", "lemma iT_Plus_Max: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<oplus> k) = Max I + k\"", "lemma iT_Mult_Max: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<otimes> k) = Max I * k\"", "lemmas iT_mult_0 =\n  iTILL_mult_0\n  iFROM_mult_0\n  iIN_mult_0\n  iMOD_mult_0\n  iMODb_mult_0", "lemma iT_Plus_0: \"I \\<oplus> 0 = I\"", "lemma iT_Mult_1: \"I \\<otimes> Suc 0 = I\"", "lemmas iT_add_Min =\n  iIN_add_Min\n  iTILL_add_Min\n  iFROM_add_Min\n  iMOD_add_Min\n  iMODb_add_Min", "lemmas iT_mult_Min =\n  iIN_mult_Min\n  iTILL_mult_Min\n  iFROM_mult_Min\n  iMOD_mult_Min\n  iMODb_mult_Min", "lemma iFROM_add: \"[n\\<dots>] \\<oplus> k = [n+k\\<dots>]\"", "lemma iIN_add: \"[n\\<dots>,d] \\<oplus> k = [n+k\\<dots>,d]\"", "lemma iTILL_add: \"[\\<dots>i] \\<oplus> k = [k\\<dots>,i]\"", "lemma iMOD_add: \"[r, mod m] \\<oplus> k = [r + k, mod m]\"", "lemma iMODb_add: \"[r, mod m, c] \\<oplus> k = [r + k, mod m, c]\"", "lemmas iT_add =\n  iMOD_add\n  iMODb_add\n  iFROM_add\n  iIN_add\n  iTILL_add\n  iT_Plus_singleton", "lemma iFROM_mult: \"[n\\<dots>] \\<otimes> k = [ n * k, mod k ]\"", "lemma iIN_mult: \"[n\\<dots>,d] \\<otimes> k = [ n * k, mod k, d ]\"", "lemma iTILL_mult: \"[\\<dots>n] \\<otimes> k = [ 0, mod k, n ]\"", "lemma iMOD_mult: \"[r, mod m ] \\<otimes> k = [ r * k, mod m * k ]\"", "lemma iMODb_mult: \"\n  [r, mod m, c ] \\<otimes> k = [ r * k, mod m * k, c ]\"", "lemmas iT_mult =\n  iTILL_mult\n  iFROM_mult\n  iIN_mult\n  iMOD_mult\n  iMODb_mult\n  iT_Mult_singleton", "lemma iFROM_conv: \"[n\\<dots>] = UNIV \\<oplus> n\"", "lemma iIN_conv: \"[n\\<dots>,d] = [\\<dots>d] \\<oplus> n\"", "lemma iMOD_conv: \"[r, mod m] = [0\\<dots>] \\<otimes> m \\<oplus> r\"", "lemma iMODb_conv: \"[r, mod m, c] = [\\<dots>c] \\<otimes> m \\<oplus> r\"", "lemma \"[12, mod 10, 4] = {12, 22, 32, 42, 52}\"", "lemma \"[12, mod 10, 4] = {12, 22, 32, 42, 52}\"", "lemma \"[12, mod 10, 4] = {12, 22, 32, 42, 52}\"", "lemma \"[r, mod m, 4] = {r, r+m, r+2*m, r+3*m, r+4*m}\"", "lemma \"[2, mod 10, 4] = {2, 12, 22, 32, 42}\"", "lemma iT_Plus_neg_mem_iff: \"(x \\<in> I \\<oplus>- k) = (x + k \\<in> I)\"", "lemma iT_Plus_neg_mem_iff2: \"k \\<le> x \\<Longrightarrow> (x - k \\<in> I \\<oplus>- k) = (x \\<in> I)\"", "lemma iT_Plus_neg_image_conv: \"I \\<oplus>- k = (\\<lambda>n.(n - k)) ` (I \\<down>\\<ge> k)\"", "lemma iT_Plus_neg_cut_eq: \"t \\<le> k \\<Longrightarrow> (I \\<down>\\<ge> t) \\<oplus>- k = I \\<oplus>- k\"", "lemma iT_Plus_neg_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<oplus>- k \\<subseteq> B \\<oplus>- k\"", "lemma iT_Plus_neg_empty: \"{} \\<oplus>- k = {}\"", "lemma iT_Plus_neg_Max_less_empty: \"\n  \\<lbrakk> finite I; Max I < k \\<rbrakk> \\<Longrightarrow> I \\<oplus>- k = {}\"", "lemma iT_Plus_neg_not_empty_iff: \"(I \\<oplus>- k \\<noteq> {}) = (\\<exists>x\\<in>I. k \\<le> x)\"", "lemma iT_Plus_neg_empty_iff: \"\n  (I \\<oplus>- k = {}) = (I = {} \\<or> (finite I \\<and> Max I < k))\"", "lemma iT_Plus_neg_assoc: \"(I \\<oplus>- a) \\<oplus>- b = I \\<oplus>- (a + b)\"", "lemma iT_Plus_neg_commute: \"I \\<oplus>- a \\<oplus>- b = I \\<oplus>- b \\<oplus>- a\"", "lemma iT_Plus_neg_0: \"I \\<oplus>- 0 = I\"", "lemma iT_Plus_Plus_neg_assoc: \"b \\<le> a \\<Longrightarrow> I \\<oplus> a \\<oplus>- b = I \\<oplus> (a - b)\"", "lemma iT_Plus_Plus_neg_assoc2: \"a \\<le> b \\<Longrightarrow> I \\<oplus> a \\<oplus>- b = I \\<oplus>- (b - a)\"", "lemma iT_Plus_neg_Plus_le_cut_eq: \"\n  a \\<le> b \\<Longrightarrow> (I \\<oplus>- a) \\<oplus> b = (I \\<down>\\<ge> a) \\<oplus> (b - a)\"", "lemma iT_Plus_neg_Plus_ge_cut_eq: \"\n  b \\<le> a \\<Longrightarrow> (I \\<oplus>- a) \\<oplus> b = (I \\<down>\\<ge> a) \\<oplus>- (a - b)\"", "lemma iT_Plus_neg_Mult_distrib: \"\n  0 < m \\<Longrightarrow> I \\<oplus>- n \\<otimes> m = I \\<otimes> m \\<oplus>- n * m\"", "lemma iT_Plus_neg_Plus_le_inverse: \"k \\<le> iMin I \\<Longrightarrow> I \\<oplus>- k \\<oplus> k = I\"", "lemma iT_Plus_neg_Plus_inverse: \"I \\<oplus>- k \\<oplus> k = I \\<down>\\<ge> k\"", "lemma iT_Plus_Plus_neg_inverse: \"I \\<oplus> k \\<oplus>- k = I\"", "lemma iT_Plus_neg_Un: \"(A \\<union> B) \\<oplus>- k = (A \\<oplus>- k) \\<union> (B \\<oplus>- k)\"", "lemma iT_Plus_neg_Int: \"(A \\<inter> B) \\<oplus>- k = (A \\<oplus>- k) \\<inter> (B \\<oplus>- k)\"", "lemma iT_Plus_neg_Max_singleton: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> I \\<oplus>- Max I= {0}\"", "lemma iT_Plus_neg_singleton: \"{a} \\<oplus>- k = (if k \\<le> a then {a - k} else {})\"", "lemma iT_Plus_neg_finite_iff: \"finite (I \\<oplus>- k) = finite I\"", "lemma iT_Plus_neg_Min: \"\n  I \\<oplus>- k \\<noteq> {} \\<Longrightarrow> iMin (I \\<oplus>- k) = iMin (I \\<down>\\<ge> k) - k\"", "lemma iT_Plus_neg_Max: \"\n  \\<lbrakk> finite I; I \\<oplus>- k \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<oplus>- k) = Max I - k\"", "lemma iFROM_add_neg: \"[n\\<dots>] \\<oplus>- k = [n - k\\<dots>]\"", "lemma iTILL_add_neg: \"[\\<dots>n] \\<oplus>- k = (if k \\<le> n then [\\<dots>n - k] else {})\"", "lemma iTILL_add_neg1: \"k \\<le> n \\<Longrightarrow> [\\<dots>n] \\<oplus>- k = [\\<dots>n-k]\"", "lemma iTILL_add_neg2: \"n < k \\<Longrightarrow> [\\<dots>n] \\<oplus>- k = {}\"", "lemma iIN_add_neg: \"\n  [n\\<dots>,d] \\<oplus>- k = (\n    if k \\<le> n then [n - k\\<dots>,d]\n    else if k \\<le> n + d then [\\<dots>n + d - k] else {})\"", "lemma iIN_add_neg1: \"k \\<le> n \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = [n - k\\<dots>,d]\"", "lemma iIN_add_neg2: \"\\<lbrakk> n \\<le> k; k \\<le> n + d \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = [\\<dots>n + d - k]\"", "lemma iIN_add_neg3: \"n + d < k \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = {}\"", "lemma iMOD_0_add_neg: \"[r, mod 0] \\<oplus>- k = {r} \\<oplus>- k\"", "lemma iMOD_gr0_add_neg: \"\n  0 < m \\<Longrightarrow>\n  [r, mod m] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m]\n    else [(m + r mod m - k mod m) mod m, mod m])\"", "lemma iMOD_add_neg: \"\n  [r, mod m] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m]\n    else if 0 < m then [(m + r mod m - k mod m) mod m, mod m] else {})\"", "lemma iMOD_add_neg2: \"\n  \\<lbrakk> 0 < m; r < k \\<rbrakk> \\<Longrightarrow> [r, mod m] \\<oplus>- k = [(m + r mod m - k mod m) mod m, mod m]\"", "lemma iMODb_mod_0_add_neg: \"[r, mod 0, c] \\<oplus>- k = {r} \\<oplus>- k\"", "lemma iMODb_add_neg: \"\n  [r, mod m, c] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m, c]\n    else\n      if k \\<le> r + m * c then\n      [(m + r mod m - k mod m) mod m, mod m, (r + m * c - k) div m]\n      else {})\"", "lemma iMODb_add_neg': \"\n  [r, mod m, c] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m, c]\n    else if k \\<le> r + m * c then\n      if k mod m \\<le> r mod m\n        then [ r mod m - k mod m, mod m, c + r div m - k div m]\n        else [ m + r mod m - k mod m, mod m, c + r div m - Suc (k div m) ]\n      else {})\"", "lemma iMODb_add_neg3: \"r + m * c < k  \\<Longrightarrow> [r, mod m, c] \\<oplus>- k = {}\"", "lemmas iT_add_neg =\n  iFROM_add_neg\n  iIN_add_neg\n  iTILL_add_neg\n  iMOD_add_neg\n  iMODb_add_neg\n  iT_Plus_neg_singleton", "lemma iT_Minus_mem_iff: \"(x \\<in> k \\<ominus> I) = (x \\<le> k \\<and> k - x \\<in> I)\"", "lemma iT_Minus_mono: \"A \\<subseteq> B \\<Longrightarrow> k \\<ominus> A \\<subseteq> k \\<ominus> B\"", "lemma iT_Minus_image_conv: \"k \\<ominus> I = (\\<lambda>x. k - x) ` (I \\<down>\\<le> k)\"", "lemma iT_Minus_cut_eq: \"k \\<le> t \\<Longrightarrow> k \\<ominus> (I \\<down>\\<le> t) = k \\<ominus> I\"", "lemma iT_Minus_Minus_cut_eq: \"k \\<ominus> (k \\<ominus> (I \\<down>\\<le> k)) = I \\<down>\\<le> k\"", "lemma \"10 \\<ominus> [\\<dots>3] = [7\\<dots>,3]\"", "lemma iT_Minus_empty: \"k \\<ominus> {} = {}\"", "lemma iT_Minus_0: \"k \\<ominus> {0} = {k}\"", "lemma iT_Minus_bound: \"x \\<in> k \\<ominus> I \\<Longrightarrow> x \\<le> k\"", "lemma iT_Minus_finite: \"finite (k \\<ominus> I)\"", "lemma iT_Minus_less_Min_empty: \"k < iMin I \\<Longrightarrow> k \\<ominus> I = {}\"", "lemma iT_Minus_Min_singleton: \"I \\<noteq> {} \\<Longrightarrow> (iMin I) \\<ominus> I = {0}\"", "lemma iT_Minus_empty_iff: \"(k \\<ominus> I = {}) = (I = {} \\<or> k < iMin I)\"", "lemma iT_Minus_imirror_conv: \"\n  k \\<ominus> I = imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>- (iMin I + Max (I \\<down>\\<le> k))\"", "lemma iT_Minus_imirror_conv': \"\n  k \\<ominus> I = imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>- (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k))\"", "lemma iT_Minus_Max: \"\n  \\<lbrakk> I \\<noteq> {}; iMin I \\<le> k \\<rbrakk> \\<Longrightarrow> Max (k \\<ominus> I) = k - (iMin I)\"", "lemma iT_Minus_Min: \"\n  \\<lbrakk> I \\<noteq> {}; iMin I \\<le> k \\<rbrakk> \\<Longrightarrow> iMin (k \\<ominus> I) = k - (Max (I \\<down>\\<le> k))\"", "lemma iT_Minus_Minus_eq: \"\\<lbrakk> finite I; Max I \\<le> k \\<rbrakk> \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I\"", "lemma iT_Minus_Minus_eq2: \"I \\<subseteq> [\\<dots>k] \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I\"", "lemma iT_Minus_Minus: \"a \\<ominus> (b \\<ominus> I) = (I \\<down>\\<le> b) \\<oplus> a \\<oplus>- b\"", "lemma iT_Minus_Plus_empty: \"k < n \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = {}\"", "lemma iT_Minus_Plus_commute: \"n \\<le> k \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = (k - n) \\<ominus> I\"", "lemma iT_Minus_Plus_cut_assoc: \"(k \\<ominus> I) \\<oplus> n = (k + n) \\<ominus> (I \\<down>\\<le> k)\"", "lemma iT_Minus_Plus_assoc: \"\n  \\<lbrakk> finite I; Max I \\<le> k \\<rbrakk> \\<Longrightarrow> (k \\<ominus> I) \\<oplus> n = (k + n) \\<ominus> I\"", "lemma iT_Minus_Plus_assoc2: \"\n  I \\<subseteq> [\\<dots>k] \\<Longrightarrow> (k \\<ominus> I) \\<oplus> n = (k + n) \\<ominus> I\"", "lemma iT_Minus_Un: \"k \\<ominus> (A \\<union> B) = (k \\<ominus> A) \\<union> (k \\<ominus> B)\"", "lemma iT_Minus_Int: \"k \\<ominus> (A \\<inter> B) = (k \\<ominus> A) \\<inter> (k \\<ominus> B)\"", "lemma iT_Minus_singleton: \"k \\<ominus> {a} = (if a \\<le> k then {k - a} else {})\"", "lemma iMOD_sub: \"\n  k \\<ominus> [r, mod m] =\n  (if r \\<le> k then [(k - r) mod m, mod m, (k - r) div m] else {})\"", "lemma iTILL_sub: \"k \\<ominus> [\\<dots>n] = (if n \\<le> k then [k - n\\<dots>,n] else [\\<dots>k])\"", "lemma iMODb_sub: \"\n  k \\<ominus> [r, mod m, c] = (\n    if r + m * c \\<le> k then [ k - r - m * c, mod m, c] else\n      if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m] else {})\"", "lemma iFROM_sub: \"k \\<ominus> [n\\<dots>] = (if n \\<le> k then [\\<dots>k - n] else {})\"", "lemma iIN_sub: \"\n  k \\<ominus> [n\\<dots>,d] = (\n  if n + d \\<le> k then [k - (n + d)\\<dots>,d]\n  else if n \\<le> k then [\\<dots>k - n] else {})\"", "lemma iIN_sub1: \"n + d \\<le> k \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = [k - (n + d)\\<dots>,d]\"", "lemma iIN_sub2: \"\\<lbrakk> n \\<le> k; k \\<le> n + d \\<rbrakk> \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = [\\<dots>k - n]\"", "lemma iIN_sub3: \"k < n \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = {}\"", "lemmas iT_sub =\n  iFROM_sub\n  iIN_sub\n  iTILL_sub\n  iMOD_sub\n  iMODb_sub\n  iT_Minus_singleton", "lemma iMOD_div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < k; k \\<le> m \\<rbrakk> \\<Longrightarrow> strict_mono_on (\\<lambda>x. x div k) [r, mod m]\"", "lemma iMOD_mult_div_right_inj_on: \"\n  inj_on (\\<lambda>x. x div (k::nat)) [r, mod (k * m)]\"", "lemma iMOD_mult_div_right_inj_on2: \"\n  m mod k = 0 \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [r, mod m]\"", "lemma iMODb_div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < k; k \\<le> m \\<rbrakk> \\<Longrightarrow> strict_mono_on (\\<lambda>x. x div k) [r, mod m, c]\"", "lemma iMODb_mult_div_right_inj_on: \"\n  inj_on (\\<lambda>x. x div (k::nat)) [r, mod (k * m), c]\"", "lemma iT_Div_image_conv: \"I \\<oslash> k = (\\<lambda>n.(n div k)) ` I\"", "lemma iT_Div_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<oslash> k \\<subseteq> B \\<oslash> k\"", "lemma iT_Div_empty: \"{} \\<oslash> k = {}\"", "lemma iT_Div_not_empty: \"I \\<noteq> {} \\<Longrightarrow> I \\<oslash> k \\<noteq> {}\"", "lemma iT_Div_empty_iff: \"(I \\<oslash> k = {}) = (I = {})\"", "lemma iT_Div_0: \"I \\<noteq> {} \\<Longrightarrow> I \\<oslash> 0 = [\\<dots>0]\"", "lemmas iT_div_0 =\n  iTILL_div_0\n  iFROM_div_0\n  iIN_div_0\n  iMOD_div_0\n  iMODb_div_0", "lemma iT_Div_1: \"I \\<oslash> Suc 0 = I\"", "lemma iT_Div_mem_iff_0: \"x \\<in> (I \\<oslash> 0) = (I \\<noteq> {} \\<and> x = 0)\"", "lemma iT_Div_mem_iff: \"\n  0 < k \\<Longrightarrow> x \\<in> (I \\<oslash> k) = (\\<exists>y \\<in> I. y div k = x)\"", "lemma iT_Div_mem_iff2: \"\n  0 < k \\<Longrightarrow> x div k \\<in> (I \\<oslash> k) = (\\<exists>y \\<in> I. y div k = x div k)\"", "lemma iT_Div_mem_iff_Int: \"\n  0 < k \\<Longrightarrow> x \\<in> (I \\<oslash> k) = (I \\<inter> [x * k\\<dots>,k - Suc 0] \\<noteq> {})\"", "lemma iT_Div_imp_mem: \"\n  0 < k \\<Longrightarrow> x \\<in> I \\<Longrightarrow> x div k \\<in> (I \\<oslash> k)\"", "lemma iT_Div_singleton: \"{a} \\<oslash> k = {a div k}\"", "lemma iT_Div_Un: \"(A \\<union> B) \\<oslash> k = (A \\<oslash> k) \\<union> (B \\<oslash> k)\"", "lemma iT_Div_insert: \"(insert n I) \\<oslash> k = insert (n div k) (I \\<oslash> k)\"", "lemma not_iT_Div_Int: \"\\<not> (\\<forall> k A B. (A \\<inter> B) \\<oslash> k = (A \\<oslash> k) \\<inter> (B \\<oslash> k))\"", "lemma subset_iT_Div_Int: \"A \\<subseteq> B \\<Longrightarrow> (A \\<inter> B) \\<oslash> k = (A \\<oslash> k) \\<inter> (B \\<oslash> k)\"", "lemma iFROM_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; n \\<le> iMin A \\<rbrakk> \\<Longrightarrow> (A \\<inter> [n\\<dots>]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>] \\<oslash> k)\"", "lemma iIN_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; n \\<le> iMin A; \\<forall>x\\<in>A. x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n\\<dots>,d]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>,d] \\<oslash> k)\"", "lemma iIN_iT_Div_Int_mod_0: \"\n  \\<lbrakk> 0 < k; n mod k = 0; \\<forall>x\\<in>A. x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n\\<dots>,d]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>,d] \\<oslash> k)\"", "lemma mod_partition_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; 0 < d \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n * k\\<dots>,d * k - Suc 0]) \\<oslash> k =\n  (A \\<oslash> k) \\<inter> ([n * k\\<dots>,d * k - Suc 0] \\<oslash> k)\"", "lemma \"{0,1,2} \\<otimes> x = {0*x, 1*x, 2*x}\"", "lemma iT_Div_assoc:\"I \\<oslash> a \\<oslash> b = I \\<oslash> (a * b)\"", "lemma iT_Div_commute: \"I \\<oslash> a \\<oslash> b = I \\<oslash> b \\<oslash> a\"", "lemma iT_Mult_Div_self: \"0 < k \\<Longrightarrow> I \\<otimes> k \\<oslash> k = I\"", "lemma iT_Mult_Div: \"\n  \\<lbrakk> 0 < d;  k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<otimes> k \\<oslash> d = I \\<otimes> (k div d)\"", "lemma iT_Div_Mult_self: \"\n  0 < k \\<Longrightarrow> I \\<oslash> k \\<otimes> k = {y. \\<exists>x \\<in> I. y = x - x mod k}\"", "lemma iT_Plus_Div_distrib_mod_less: \"\n  \\<forall>x\\<in>I. x mod m + n mod m < m \\<Longrightarrow> I \\<oplus> n \\<oslash> m = I \\<oslash> m \\<oplus> n div m\"", "lemma iT_Div_Min: \"I \\<noteq> {} \\<Longrightarrow> iMin (I \\<oslash> k) = iMin I div k\"", "lemmas iT_div_Min =\n  iFROM_div_Min\n  iIN_div_Min\n  iTILL_div_Min\n  iMOD_div_Min\n  iMODb_div_Min", "lemma iT_Div_Max: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<oslash> k) = Max I div k\"", "lemma iT_Div_0_finite: \"finite (I \\<oslash> 0)\"", "lemma iT_Div_infinite_iff: \"0 < k \\<Longrightarrow> infinite (I \\<oslash> k) = infinite I\"", "lemma iT_Div_finite_iff: \"0 < k \\<Longrightarrow> finite (I \\<oslash> k) = finite I\"", "lemma iFROM_div: \"0 < k \\<Longrightarrow> [n\\<dots>] \\<oslash> k = [n div k\\<dots>]\"", "lemma iIN_div: \"\n  0 < k \\<Longrightarrow>\n  [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>, d div k + (n mod k + d mod k) div k ]\"", "lemma iTILL_div: \"\n   0 < k \\<Longrightarrow> [\\<dots>n] \\<oslash> k = [\\<dots>n div k]\"", "lemma iMOD_div_ge: \"\n  \\<lbrakk> 0 < m; m \\<le> k \\<rbrakk> \\<Longrightarrow> [r, mod m] \\<oslash> k = [r div k\\<dots>]\"", "lemma iMOD_div: \"\n  \\<lbrakk> 0 < k; m mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  [r, mod m] \\<oslash> k = [r div k, mod (m div k) ]\"", "lemma iMODb_div_self: \"\n  0 < m \\<Longrightarrow> [r, mod m, c] \\<oslash> m = [r div m\\<dots>,c]\"", "lemma iMODb_div_ge: \"\n  \\<lbrakk> 0 < m; m \\<le> k \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oslash> k = [r div k\\<dots>,(r + m * c) div k - r div k]\"", "lemma iMODb_div: \"\n  \\<lbrakk> 0 < k; m mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oslash> k = [r div k, mod (m div k), c ]\"", "lemmas iT_div =\n  iTILL_div\n  iFROM_div\n  iIN_div\n  iMOD_div\n  iMODb_div\n  iT_Div_singleton", "lemma iMODb_div_unique: \"\n  \\<lbrakk> 0 < k; k \\<le> m; k \\<le> c; [r', mod m', c'] = [r, mod m, c] \\<oslash> k \\<rbrakk> \\<Longrightarrow>\n  r' = r div k \\<and> m' = m div k \\<and> c' = c\"", "lemma iMODb_div_mod_gr0_is_0_not_ex0: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  \\<not>(\\<exists>r' m' c'. [r', mod m', c'] = [r, mod m, c] \\<oslash> k)\"", "lemma iMODb_div_mod_gr0_not_ex__arith_aux1: \"\n  \\<lbrakk> (0::nat) < k; k < m; 0 < x1 \\<rbrakk> \\<Longrightarrow>\n  x1 * m + x2 - x mod k + x3 + x mod k = x1 * m + x2 + x3\"", "lemma iMODb_div_mod_gr0_not_ex: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k; k \\<le> c \\<rbrakk> \\<Longrightarrow>\n  \\<not>(\\<exists>r' m' c'. [r', mod m', c'] = [r, mod m, c] \\<oslash> k)\"", "lemma iMOD_div_eq_imp_iMODb_div_eq: \"\n  \\<lbrakk> 0 < k; k \\<le> m; [r', mod m'] = [r, mod m] \\<oslash> k \\<rbrakk> \\<Longrightarrow>\n  [r', mod m', c] = [r, mod m, c] \\<oslash> k\"", "lemma iMOD_div_unique: \"\n  \\<lbrakk> 0 < k; k \\<le> m; [r', mod m'] = [r, mod m] \\<oslash> k \\<rbrakk> \\<Longrightarrow>\n  r' = r div k \\<and> m' = m div k\"", "lemma iMOD_div_mod_gr0_not_ex: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k \\<rbrakk> \\<Longrightarrow>\n  \\<not> (\\<exists>r' m'. [r', mod m'] = [r, mod m] \\<oslash> k)\"", "lemma\n  iT_Plus_cut_le2:      \"(I \\<oplus> k) \\<down>\\<le> (t + k) = (I \\<down>\\<le> t) \\<oplus> k\" and\n  iT_Plus_cut_less2:    \"(I \\<oplus> k) \\<down>< (t + k) = (I \\<down>< t) \\<oplus> k\" and\n  iT_Plus_cut_ge2:      \"(I \\<oplus> k) \\<down>\\<ge> (t + k) = (I \\<down>\\<ge> t) \\<oplus> k\" and\n  iT_Plus_cut_greater2: \"(I \\<oplus> k) \\<down>> (t + k) = (I \\<down>> t) \\<oplus> k\"", "lemma iT_Plus_cut_le: \"\n  (I \\<oplus> k) \\<down>\\<le> t = (if t < k then {} else I \\<down>\\<le> (t - k) \\<oplus> k)\"", "lemma iT_Plus_cut_less: \"(I \\<oplus> k) \\<down>< t = I \\<down>< (t - k) \\<oplus> k\"", "lemma iT_Plus_cut_ge: \"(I \\<oplus> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t - k) \\<oplus> k\"", "lemma iT_Plus_cut_greater: \"\n  (I \\<oplus> k) \\<down>> t = (if t < k then I \\<oplus> k else I \\<down>> (t - k) \\<oplus> k)\"", "lemma\n  iT_Mult_cut_le2:      \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<le> (t * k) = (I \\<down>\\<le> t) \\<otimes> k\" and\n  iT_Mult_cut_less2:    \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>< (t * k) = (I \\<down>< t) \\<otimes> k\" and\n  iT_Mult_cut_ge2:      \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> (t * k) = (I \\<down>\\<ge> t) \\<otimes> k\" and\n  iT_Mult_cut_greater2: \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>> (t * k) = (I \\<down>> t) \\<otimes> k\"", "lemma iT_Mult_cut_le: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<le> t = (I \\<down>\\<le> (t div k)) \\<otimes> k\"", "lemma iT_Mult_cut_less: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>< t =\n    (if t mod k = 0 then (I \\<down>< (t div k)) else I \\<down>< Suc (t div k)) \\<otimes> k\"", "lemma iT_Mult_cut_greater: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>> t = (I \\<down>> (t div k)) \\<otimes> k\"", "lemma iT_Mult_cut_ge: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> t =\n    (if t mod k = 0 then (I \\<down>\\<ge> (t div k)) else I \\<down>\\<ge> Suc (t div k)) \\<otimes> k\"", "lemma iT_Plus_neg_cut_le2: \"k \\<le> t \\<Longrightarrow> (I \\<oplus>- k) \\<down>\\<le> (t - k) = (I \\<down>\\<le> t) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_less2: \"(I \\<oplus>- k) \\<down>< (t - k) = (I \\<down>< t) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_ge2: \"(I \\<oplus>- k) \\<down>\\<ge> (t - k) = (I \\<down>\\<ge> t) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_greater2: \"k \\<le> t \\<Longrightarrow> (I \\<oplus>- k) \\<down>> (t - k) = (I \\<down>> t) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_le: \"(I \\<oplus>- k) \\<down>\\<le> t = I \\<down>\\<le> (t + k) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_less: \"(I \\<oplus>- k) \\<down>< t = I \\<down>< (t + k) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_ge: \"(I \\<oplus>- k) \\<down>\\<ge> t = I \\<down>\\<ge> (t + k) \\<oplus>- k\"", "lemma iT_Plus_neg_cut_greater: \"(I \\<oplus>- k) \\<down>> t = I \\<down>> (t + k) \\<oplus>- k\"", "lemma iT_Minus_cut_le2: \"t \\<le> k \\<Longrightarrow> (k \\<ominus> I) \\<down>\\<le> (k - t) = k \\<ominus> (I \\<down>\\<ge> t)\"", "lemma iT_Minus_cut_less2: \"(k \\<ominus> I) \\<down>< (k - t) = k \\<ominus> (I \\<down>> t)\"", "lemma iT_Minus_cut_ge2: \"(k \\<ominus> I) \\<down>\\<ge> (k - t) = k \\<ominus> (I \\<down>\\<le> t)\"", "lemma iT_Minus_cut_greater2: \"t \\<le> k \\<Longrightarrow> (k \\<ominus> I) \\<down>> (k - t) = k \\<ominus> (I \\<down>< t)\"", "lemma iT_Minus_cut_le: \"(k \\<ominus> I) \\<down>\\<le> t = k \\<ominus> (I \\<down>\\<ge> (k - t))\"", "lemma iT_Minus_cut_less: \"\n  (k \\<ominus> I) \\<down>< t = (if t \\<le> k then k \\<ominus> (I \\<down>> (k - t)) else k \\<ominus> I)\"", "lemma iT_Minus_cut_ge: \"\n  (k \\<ominus> I) \\<down>\\<ge> t = (if t \\<le> k then k \\<ominus> (I \\<down>\\<le> (k - t)) else {})\"", "lemma iT_Minus_cut_greater: \"(k \\<ominus> I) \\<down>> t = k \\<ominus> (I \\<down>< (k - t))\"", "lemma iT_Div_cut_le: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<le> t = I \\<down>\\<le> (t * k + (k - Suc 0)) \\<oslash> k\"", "lemma iT_Div_cut_less: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>< t = I \\<down>< (t * k) \\<oslash> k\"", "lemma iT_Div_cut_ge: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t * k) \\<oslash> k\"", "lemma iT_Div_cut_greater: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>> t = I \\<down>> (t * k + (k - Suc 0)) \\<oslash> k\"", "lemma iT_Div_cut_le2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<le> (t div k) = I \\<down>\\<le> (t - t mod k + (k - Suc 0)) \\<oslash> k\"", "lemma iT_Div_cut_less2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>< (t div k) = I \\<down>< (t - t mod k) \\<oslash> k\"", "lemma iT_Div_cut_ge2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<ge> (t div k) = I \\<down>\\<ge> (t - t mod k) \\<oslash> k\"", "lemma iT_Div_cut_greater2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>> (t div k) = I \\<down>> (t - t mod k + (k - Suc 0)) \\<oslash> k\"", "lemma iT_Plus_inext: \"inext (n + k) (I \\<oplus> k) = (inext n I) + k\"", "lemma iT_Plus_iprev: \"iprev (n + k) (I \\<oplus> k) = (iprev n I) + k\"", "lemma iT_Plus_inext2: \"k \\<le> n \\<Longrightarrow> inext n (I \\<oplus> k) = (inext (n - k) I) + k\"", "lemma iT_Plus_prev2: \"k \\<le> n \\<Longrightarrow> iprev n (I \\<oplus> k) = (iprev (n - k) I) + k\"", "lemma iT_Mult_inext: \"inext (n * k) (I \\<otimes> k) = (inext n I) * k\"", "lemma iT_Mult_iprev: \"iprev (n * k) (I \\<otimes> k) = (iprev n I) * k\"", "lemma iT_Mult_inext2_if: \"\n  inext n (I \\<otimes> k) = (if n mod k = 0 then (inext (n div k) I) * k else n)\"", "lemma iT_Mult_iprev2_if: \"\n  iprev n (I \\<otimes> k) = (if n mod k = 0 then (iprev (n div k) I) * k else n)\"", "lemma iT_Plus_neg_inext: \"\n  k \\<le> n \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k\"", "lemma iT_Plus_neg_iprev: \"\n  iprev (n - k) (I \\<oplus>- k) = iprev n (I \\<down>\\<ge> k) - k\"", "lemma iT_Minus_inext: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I\"", "lemma iT_Minus_iprev: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> iprev (k - n) (k \\<ominus> I) = k - inext n (I \\<down>\\<le> k)\"", "lemma iT_Minus_iprev2: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> iprev n (k \\<ominus> I) = k - inext (k - n) (I \\<down>\\<le> k)\"", "lemma iT_Plus_inext_nth: \"I \\<noteq> {} \\<Longrightarrow> (I \\<oplus> k) \\<rightarrow> n = (I \\<rightarrow> n) + k\"", "lemma iT_Plus_iprev_nth: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> n = (I \\<leftarrow> n) + k\"", "lemma iT_Mult_inext_nth: \"I \\<noteq> {} \\<Longrightarrow> (I \\<otimes> k) \\<rightarrow> n = (I \\<rightarrow> n) * k\"", "lemma iT_Mult_iprev_nth: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> n = (I \\<leftarrow> n) * k\"", "lemma iT_Plus_neg_inext_nth: \"\n  I \\<oplus>- k \\<noteq> {} \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n = (I \\<down>\\<ge> k \\<rightarrow> n) - k\"", "lemma iT_Plus_neg_iprev_nth: \"\n  \\<lbrakk> finite I; I \\<oplus>- k \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n = (I \\<down>\\<ge> k \\<leftarrow> n) - k\"", "lemma iT_Minus_inext_nth: \"\n  k \\<ominus> I \\<noteq> {} \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n = k - ((I \\<down>\\<le> k) \\<leftarrow> n)\"", "lemma iT_Minus_iprev_nth: \"\n  k \\<ominus> I \\<noteq> {} \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n = k - ((I \\<down>\\<le> k) \\<rightarrow> n)\"", "lemma iT_Div_ge_inext_nth: \"\n  \\<lbrakk> I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<rightarrow> n = (I \\<rightarrow> n) div k\"", "lemma iT_Div_mod_inext_nth: \"\n  \\<lbrakk> I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<rightarrow> n = (I \\<rightarrow> n) div k\"", "lemma iT_Div_ge_iprev_nth: \"\n  \\<lbrakk> finite I; I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<leftarrow> n = (I \\<leftarrow> n) div k\"", "lemma iT_Div_mod_iprev_nth: \"\n  \\<lbrakk> finite I; I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<leftarrow> n = (I \\<leftarrow> n) div k\"", "lemma iT_Plus_card: \"card (I \\<oplus> k) = card I\"", "lemma iT_Mult_card: \"0 < k \\<Longrightarrow> card (I \\<otimes> k) = card I\"", "lemma iT_Plus_neg_card: \"card (I \\<oplus>- k) = card (I \\<down>\\<ge> k)\"", "lemma iT_Plus_neg_card_le: \"card (I \\<oplus>- k) \\<le> card I\"", "lemma iT_Minus_card: \"card (k \\<ominus> I) = card (I \\<down>\\<le> k)\"", "lemma iT_Minus_card_le: \"finite I \\<Longrightarrow> card (k \\<ominus> I) \\<le> card I\"", "lemma iT_Div_0_card_if: \"\n  card (I \\<oslash> 0) = (if I ={} then 0 else Suc 0)\"", "lemma Int_empty_sum:\"\n  (\\<Sum>k\\<le>(n::nat). if {} \\<inter> (I k) = {} then 0 else Suc 0) = 0\"", "lemma iT_Div_mod_partition_card:\"\n  card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n  (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\"", "lemma iT_Div_conv_count: \"\n  0 < d \\<Longrightarrow> I \\<oslash> d = {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\"", "lemma iT_Div_conv_count2: \"\n  \\<lbrakk> 0 < d; finite I; Max I div d \\<le> n \\<rbrakk> \\<Longrightarrow>\n  I \\<oslash> d = {k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\"", "lemma mod_partition_count_Suc: \"\n  {k. k \\<le> Suc n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n  {k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} \\<union>\n    (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {} then {Suc n} else {})\"", "lemma iT_Div_card: \"\n  \\<And>I.\\<lbrakk> 0 < d; finite I; Max I div d \\<le> n\\<rbrakk> \\<Longrightarrow>\n  card (I \\<oslash> d) = (\\<Sum>k\\<le>n.\n    if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\"", "lemma iT_Div_card_le: \"0 < k \\<Longrightarrow> card (I \\<oslash> k) \\<le> card I\"", "lemma iT_Div_card_inj_on: \"\n  inj_on (\\<lambda>n. n div k) I \\<Longrightarrow> card (I \\<oslash> k) = card I\"", "lemma mod_Suc': \"\n  0 < n \\<Longrightarrow> Suc m mod n = (if m mod n < n - Suc 0 then Suc (m mod n) else 0)\"", "lemma div_Suc: \"\n  0 < n \\<Longrightarrow> Suc m div n = (if Suc (m mod n) = n then Suc (m div n) else m div n)\"", "lemma div_Suc': \"\n  0 < n \\<Longrightarrow> Suc m div n = (if m mod n < n - Suc 0 then m div n else Suc (m div n))\"", "lemma iT_Div_card_ge_aux: \"\n  \\<And>I. \\<lbrakk> 0 < d; finite I; Max I div d \\<le> n \\<rbrakk> \\<Longrightarrow>\n  card I div d + (if card I mod d = 0 then 0 else Suc 0) \\<le> card (I \\<oslash> d)\"", "lemma iT_Div_card_ge: \"\n  card I div d + (if card I mod d = 0 then 0 else Suc 0) \\<le> card (I \\<oslash> d)\"", "lemma iT_Div_card_ge__is_maximal_lower_bound: \"\n  \\<forall>I d. card I div d + (if card I mod d = 0 then 0 else Suc 0) \\<le> f (card I) d \\<and>\n        f (card I) d \\<le> card (I \\<oslash> d) \\<Longrightarrow>\n  f (card (I::nat set)) d = card I div d + (if card I mod d = 0 then 0 else Suc 0)\"", "lemma iT_Plus_icard: \"icard (I \\<oplus> k) = icard I\"", "lemma iT_Mult_icard: \"0 < k \\<Longrightarrow> icard (I \\<otimes> k) = icard I\"", "lemma iT_Plus_neg_icard: \"icard (I \\<oplus>- k) = icard (I \\<down>\\<ge> k)\"", "lemma iT_Plus_neg_icard_le: \"icard (I \\<oplus>- k) \\<le> icard I\"", "lemma iT_Minus_icard: \"icard (k \\<ominus> I) = icard (I \\<down>\\<le> k)\"", "lemma iT_Minus_icard_le: \"icard (k \\<ominus> I) \\<le> icard I\"", "lemma iT_Div_0_icard_if: \"icard (I \\<oslash> 0) = enat (if I = {} then 0 else Suc 0)\"", "lemma iT_Div_mod_partition_icard: \"\n  icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n  enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\"", "lemma iT_Div_icard: \"\n  \\<lbrakk> 0 < d; finite I \\<Longrightarrow> Max I div d \\<le> n\\<rbrakk> \\<Longrightarrow>\n  icard (I \\<oslash> d) =\n  (if finite I then enat (\\<Sum>k\\<le>n. if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0) else \\<infinity>)\"", "lemma iT_Div_icard_le: \"0 < k \\<Longrightarrow> icard (I \\<oslash> k) \\<le> icard I\"", "lemma iT_Div_icard_inj_on: \"inj_on (\\<lambda>n. n div k) I \\<Longrightarrow> icard (I \\<oslash> k) = icard I\"", "lemma iT_Div_icard_ge: \"icard I div (enat d) + enat (if icard I mod (enat d) = 0 then 0 else Suc 0) \\<le> icard (I \\<oslash> d)\"", "lemma iT_Div_icard_ge__is_maximal_lower_bound: \"\n  \\<forall>I d. icard I div (enat d) + enat (if icard I mod (enat d) = 0 then 0 else Suc 0)\n        \\<le> f (icard I) d \\<and>\n        f (icard I) d \\<le> icard (I \\<oslash> d) \\<Longrightarrow>\n  f (icard (I::nat set)) d =\n  icard I div (enat d) + enat (if icard I mod (enat d) = 0 then 0 else Suc 0)\"", "lemmas i_set_defs =\n  iFROM_set_def iTILL_set_def iIN_set_def\n  iMOD_set_def iMODb_set_def\n  iMOD2_set_def iMODb2_set_def", "lemmas i_UN_set_defs =\n  iFROM_UN_set_def iTILL_UN_set_def iIN_UN_set_def\n  iMOD_UN_set_def iMODb_UN_set_def\n  iMOD2_UN_set_def iMODb2_UN_set_def", "lemma iFROM_set_UN_set_eq: \"iFROM_set = iFROM_UN_set\"", "lemma\n  iTILL_set_UN_set_eq: \"iTILL_set = iTILL_UN_set\" and\n  iIN_set_UN_set_eq:   \"iIN_set = iIN_UN_set\" and\n  iMOD_set_UN_set_eq:  \"iMOD_set = iMOD_UN_set\" and\n  iMODb_set_UN_set_eq: \"iMODb_set = iMODb_UN_set\"", "lemma iMOD2_set_UN_set_eq: \"iMOD2_set = iMOD2_UN_set\"", "lemma iMODb2_set_UN_set_eq: \"iMODb2_set = iMODb2_UN_set\"", "lemmas i_set_i_UN_set_sets_eq =\n  iFROM_set_UN_set_eq\n  iTILL_set_UN_set_eq\n  iIN_set_UN_set_eq\n  iMOD_set_UN_set_eq\n  iMODb_set_UN_set_eq\n  iMOD2_set_UN_set_eq\n  iMODb2_set_UN_set_eq", "lemma iMOD2_set_iMOD_set_subset: \"iMOD2_set \\<subseteq> iMOD_set\"", "lemma iMODb2_set_iMODb_set_subset: \"iMODb2_set \\<subseteq> iMODb_set\"", "lemma i_set_i_UN_set_eq: \"i_set = i_UN_set\"", "lemma i_set_min_i_UN_set_min_eq: \"i_set_min = i_UN_set_min\"", "lemma i_set_min_eq: \"i_set = i_set_min\"", "lemma i_set_min_is_minimal_let: \"\n  let s1 = iFROM_set; s2= iIN_set; s3= iMOD2_set; s4= iMODb2_set in\n  s1 \\<inter> s2 = {} \\<and> s1 \\<inter> s3 = {} \\<and> s1 \\<inter> s4 = {} \\<and>\n  s2 \\<inter> s3 = {} \\<and> s2 \\<inter> s4 = {} \\<and> s3 \\<inter> s4 = {}\"", "lemmas i_set_min_is_minimal = i_set_min_is_minimal_let[simplified]", "lemma i_set_ind_subset_i_set0_ind: \"i_set_ind \\<subseteq> i_set0_ind\"", "lemma\n  i_set0_ind_FROM[intro!] : \"[n\\<dots>] \\<in> i_set0_ind\" and\n  i_set0_ind_TILL[intro!] : \"[\\<dots>n] \\<in> i_set0_ind\" and\n  i_set0_ind_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set0_ind\" and\n  i_set0_ind_MOD[intro!]  : \"[r, mod m] \\<in> i_set0_ind\" and\n  i_set0_ind_MODb[intro!] : \"[r, mod m, c] \\<in> i_set0_ind\"", "lemmas i_set0_ind_intros2 =\n  i_set0_ind_empty\n  i_set0_ind_FROM\n  i_set0_ind_TILL\n  i_set0_ind_IN\n  i_set0_ind_MOD\n  i_set0_ind_MODb", "lemma i_set_i_set_ind_eq: \"i_set = i_set_ind\"", "lemma i_set0_i_set0_ind_eq: \"i_set0 = i_set0_ind\"", "lemma i_set_imp_not_empty: \"I \\<in> i_set \\<Longrightarrow> I \\<noteq> {}\"", "lemma i_set0_i_set_mem_conv: \"(I \\<in> i_set0) = (I \\<in> i_set \\<or> I = {})\"", "lemma i_set_i_set0_mem_conv: \"(I \\<in> i_set) = (I \\<in> i_set0 \\<and> I \\<noteq> {})\"", "lemma i_set0_i_set_conv: \"i_set0 - {{}} = i_set\"", "lemma i_set_singleton: \"{a} \\<in> i_set\"", "lemma i_set0_singleton: \"{a} \\<in> i_set0\"", "lemmas i_set_intros =\n  i_set_FROM\n  i_set_TILL\n  i_set_IN\n  i_set_MOD\n  i_set_MODb", "lemma\n  i_set0_empty[intro!]: \"{} \\<in> i_set0\" and\n  i_set0_FROM[intro!] : \"[n\\<dots>] \\<in> i_set0\" and\n  i_set0_TILL[intro!] : \"[\\<dots>n] \\<in> i_set0\" and\n  i_set0_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set0\" and\n  i_set0_MOD[intro!]  : \"[r, mod m] \\<in> i_set0\" and\n  i_set0_MODb[intro!] : \"[r, mod m, c] \\<in> i_set0\"", "lemmas i_set0_intros =\n  i_set0_empty\n  i_set0_FROM\n  i_set0_TILL\n  i_set0_IN\n  i_set0_MOD\n  i_set0_MODb", "lemma i_set_infinite_as_iMOD:\"\n  \\<lbrakk> I \\<in> i_set; infinite I \\<rbrakk> \\<Longrightarrow> \\<exists>r m. I = [r, mod m]\"", "lemma i_set_finite_as_iMODb:\"\n  \\<lbrakk> I \\<in> i_set; finite I \\<rbrakk> \\<Longrightarrow> \\<exists>r m c. I = [r, mod m, c]\"", "lemma i_set_as_iMOD_iMODb: \"\n  I \\<in> i_set \\<Longrightarrow> (\\<exists>r m. I = [r, mod m]) \\<or> (\\<exists>r m c. I = [r, mod m, c])\"", "lemma i_set_cut_le_ge_closed_disj: \"\n  \\<lbrakk> I \\<in> i_set; t \\<in> I; cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>) \\<rbrakk> \\<Longrightarrow>\n  cut_op I t \\<in> i_set\"", "lemmas i_set_cut_le_ge_closed = i_set_cut_le_closed i_set_cut_ge_closed", "lemma i_set0_cut_closed_disj: \"\n  \\<lbrakk> I \\<in> i_set0;\n    cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<rbrakk> \\<Longrightarrow>\n  cut_op I t \\<in> i_set0\"", "lemmas i_set0_cut_closed =\n  i_set0_cut_le_closed\n  i_set0_cut_less_closed\n  i_set0_cut_ge_closed\n  i_set0_cut_greater_closed", "lemma i_set_Plus_closed: \"I \\<in> i_set \\<Longrightarrow> I \\<oplus> k \\<in> i_set\"", "lemma i_set_Mult_closed: \"I \\<in> i_set \\<Longrightarrow> I \\<otimes> k \\<in> i_set\"", "lemma i_set0_Plus_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<oplus> k \\<in> i_set0\"", "lemma i_set0_Mult_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<otimes> k \\<in> i_set0\"", "lemma i_set_Plus_neg_closed: \"\n  \\<lbrakk> I \\<in> i_set; \\<exists>x\\<in>I. k \\<le> x \\<rbrakk> \\<Longrightarrow> I \\<oplus>- k \\<in> i_set\"", "lemma i_set_Minus_closed: \"\n  \\<lbrakk> I \\<in> i_set; iMin I \\<le> k \\<rbrakk> \\<Longrightarrow> k \\<ominus> I \\<in> i_set\"", "lemma i_set0_Plus_neg_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<oplus>- k \\<in> i_set0\"", "lemma i_set0_Minus_closed: \"I \\<in> i_set0 \\<Longrightarrow> k \\<ominus> I \\<in> i_set0\"", "lemmas i_set_IntOp_closed =\n  i_set_Plus_closed\n  i_set_Mult_closed\n  i_set_Plus_neg_closed\n  i_set_Minus_closed", "lemmas i_set0_IntOp_closed =\n  i_set0_Plus_closed\n  i_set0_Mult_closed\n  i_set0_Plus_neg_closed\n  i_set0_Minus_closed", "lemma iMOD_div_mod_gr0_not_in_i_set: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k \\<rbrakk> \\<Longrightarrow> [r, mod m] \\<oslash> k \\<notin> i_set\"", "lemma iMODb_div_mod_gr0_not_in_i_set: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k; k \\<le> c \\<rbrakk> \\<Longrightarrow> [r, mod m, c] \\<oslash> k \\<notin> i_set\"", "lemma \"[0, mod 3] \\<oslash> 2 \\<notin> i_set\"", "lemma i_set_Div_not_closed: \"Suc 0 < k \\<Longrightarrow> \\<exists>I\\<in>i_set. I \\<oslash> k \\<notin> i_set\"", "lemma i_set0_Div_not_closed: \"Suc 0 < k \\<Longrightarrow> \\<exists>I\\<in>i_set0. I \\<oslash> k \\<notin> i_set0\"", "lemma NatMultiples_ex_divisor: \"m \\<in> NatMultiples F \\<Longrightarrow> \\<exists>k\\<in>F. m mod k = 0\"", "lemma NatMultiples_product_factor: \"\\<lbrakk> a \\<in> F; b \\<in> F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\"", "lemma NatMultiples_product_factor_multiple: \"\n  \\<lbrakk> a \\<in> F; b \\<in> NatMultiples F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\"", "lemma NatMultiples_product_multiple_factor: \"\n  \\<lbrakk> a \\<in> NatMultiples F; b \\<in> F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\"", "lemma NatMultiples_product_multiple: \"\n  \\<lbrakk> a \\<in> NatMultiples F; b \\<in> NatMultiples F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\"", "lemma i_set_cont_subset_i_set: \"i_set_cont \\<subseteq> i_set\"", "lemma i_set0_cont_subset_i_set0: \"i_set0_cont \\<subseteq> i_set0\"", "lemma i_set_cont_min_eq: \"i_set_cont = i_set_cont_min\"", "lemma i_set_cont_inext: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; finite I \\<Longrightarrow> n < Max I \\<rbrakk> \\<Longrightarrow> inext n I = Suc n\"", "lemma i_set_cont_iprev: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; iMin I < n \\<rbrakk> \\<Longrightarrow> iprev n I = n - Suc 0\"", "lemma i_set_cont_inext__less: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I \\<rbrakk> \\<Longrightarrow> inext n I = Suc n\"", "lemma i_set_cont_iprev__greater: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; n0 < n; n0 \\<in> I \\<rbrakk> \\<Longrightarrow> iprev n I = n - Suc 0\"", "lemma\n  i_set0_mult_empty[intro!]: \"{} \\<in> i_set0_mult k\" and\n  i_set0_mult_FROM[intro!] : \"[n\\<dots>] \\<in> i_set0_mult k\" and\n  i_set0_mult_TILL[intro!] : \"[\\<dots>n] \\<in> i_set0_mult k\" and\n  i_set0_mult_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set0_mult k\" and\n  i_set0_mult_MOD[intro!]  : \"[r, mod m * k] \\<in> i_set0_mult k\" and\n  i_set0_mult_MODb[intro!] : \"[r, mod m * k, c] \\<in> i_set0_mult k\"", "lemmas i_set0_mult_intros =\n  i_set0_mult_empty\n  i_set0_mult_FROM\n  i_set0_mult_TILL\n  i_set0_mult_IN\n  i_set0_mult_MOD\n  i_set0_mult_MODb", "lemma i_set_mult_subset_i_set0_mult: \"i_set_mult k \\<subseteq> i_set0_mult k\"", "lemma i_set_mult_subset_i_set: \"i_set_mult k \\<subseteq> i_set\"", "lemma i_set0_mult_subset_i_set0: \"i_set0_mult k \\<subseteq> i_set0\"", "lemma i_set_mult_0_eq_i_set_cont: \"i_set_mult 0 = i_set_cont\"", "lemma i_set0_mult_0_eq_i_set0_cont: \"i_set0_mult 0 = i_set0_cont\"", "lemma i_set_mult_1_eq_i_set: \"i_set_mult (Suc 0) = i_set\"", "lemma i_set0_mult_1_eq_i_set0: \"i_set0_mult (Suc 0) = i_set0\"", "lemma i_set_mult_imp_not_empty: \"I \\<in> i_set_mult k \\<Longrightarrow> I \\<noteq> {}\"", "lemma iMOD_in_i_set_mult_imp_divisor_mod_0: \"\n  \\<lbrakk> m \\<noteq> Suc 0; [r, mod m] \\<in> i_set_mult k \\<rbrakk> \\<Longrightarrow> m mod k = 0\"", "lemma\n  divisor_mod_0_imp_iMOD_in_i_set_mult: \"m mod k = 0 \\<Longrightarrow> [r, mod m] \\<in> i_set_mult k\" and\n  divisor_mod_0_imp_iMODb_in_i_set_mult: \"m mod k = 0 \\<Longrightarrow> [r, mod m, c] \\<in> i_set_mult k\"", "lemma iMOD_in_i_set_mult__divisor_mod_0_conv: \"\n  m \\<noteq> Suc 0 \\<Longrightarrow> ([r, mod m] \\<in> i_set_mult k) = (m mod k = 0)\"", "lemma i_set_mult_neq1_subset_i_set: \"k \\<noteq> Suc 0 \\<Longrightarrow> i_set_mult k \\<subset> i_set\"", "lemma mod_0_imp_i_set_mult_subset: \"\n  a mod b = 0 \\<Longrightarrow> i_set_mult a \\<subseteq> i_set_mult b\"", "lemma i_set_mult_subset_imp_mod_0: \"\n  \\<lbrakk> a \\<noteq> Suc 0; (i_set_mult a \\<subseteq> i_set_mult b) \\<rbrakk> \\<Longrightarrow> a mod b = 0\"", "lemma i_set_mult_subset_conv: \"\n  a \\<noteq> Suc 0 \\<Longrightarrow> (i_set_mult a \\<subseteq> i_set_mult b) = (a mod b = 0)\"", "lemma i_set_mult_mod_0_div: \"\n  \\<lbrakk> I \\<in> i_set_mult k; k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<oslash> d \\<in> i_set_mult (k div d)\"", "lemma i_set_mod_0_mult_in_i_set_mult: \"\n  \\<lbrakk> I \\<in> i_set; m mod k = 0 \\<rbrakk> \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k\"", "lemma i_set_self_mult_in_i_set_mult: \"\n  I \\<in> i_set \\<Longrightarrow> I \\<otimes> k \\<in> i_set_mult k\"", "lemma i_set_mult_mod_gr0_div_not_in_i_set:\"\n  \\<lbrakk> 0 < k; 0 < d; 0 < k mod d \\<rbrakk> \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k. I \\<oslash> d \\<notin> i_set\"", "lemma i_set0_mult_mod_0_div: \"\n  \\<lbrakk> I \\<in> i_set0_mult k; k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<oslash> d \\<in> i_set0_mult (k div d)\"", "lemma i_set0_mod_0_mult_in_i_set0_mult: \"\n  \\<lbrakk> I \\<in> i_set0; m mod k = 0 \\<rbrakk> \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k\"", "lemma i_set0_self_mult_in_i_set0_mult: \"\n  I \\<in> i_set0 \\<Longrightarrow> I \\<otimes> k \\<in> i_set0_mult k\"", "lemma i_set0_mult_mod_gr0_div_not_in_i_set0:\"\n  \\<lbrakk> 0 < k; 0 < d; 0 < k mod d \\<rbrakk> \\<Longrightarrow> \\<exists>I\\<in>i_set0_mult k. I \\<oslash> d \\<notin> i_set0\""], "translations": [["", "lemma iT_Plus_image_conv: \"I \\<oplus> k = (\\<lambda>n.(n + k)) ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus> k = (\\<lambda>n. n + k) ` I", "by (simp add:  iT_Plus_def)"], ["", "lemma iT_Mult_image_conv: \"I \\<otimes> k = (\\<lambda>n.(n * k)) ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<otimes> k = (\\<lambda>n. n * k) ` I", "by (simp add:  iT_Mult_def)"], ["", "lemma iT_Plus_empty: \"{} \\<oplus> k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<oplus> k = {}", "by (simp add: iT_Plus_def)"], ["", "lemma iT_Mult_empty: \"{} \\<otimes> k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<otimes> k = {}", "by (simp add: iT_Mult_def)"], ["", "lemma iT_Plus_not_empty: \"I \\<noteq> {} \\<Longrightarrow> I \\<oplus> k \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> I \\<oplus> k \\<noteq> {}", "by (simp add: iT_Plus_def)"], ["", "lemma iT_Mult_not_empty: \"I \\<noteq> {} \\<Longrightarrow> I \\<otimes> k \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> I \\<otimes> k \\<noteq> {}", "by (simp add: iT_Mult_def)"], ["", "lemma iT_Plus_empty_iff: \"(I \\<oplus> k = {}) = (I = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus> k = {}) = (I = {})", "by (simp add: iT_Plus_def)"], ["", "lemma iT_Mult_empty_iff: \"(I \\<otimes> k = {}) = (I = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<otimes> k = {}) = (I = {})", "by (simp add: iT_Mult_def)"], ["", "lemma iT_Plus_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<oplus> k \\<subseteq> B \\<oplus> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> A \\<oplus> k \\<subseteq> B \\<oplus> k", "by (simp add: iT_Plus_def image_mono)"], ["", "lemma iT_Mult_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<otimes> k \\<subseteq> B \\<otimes> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    A \\<otimes> k \\<subseteq> B \\<otimes> k", "by (simp add: iT_Mult_def image_mono)"], ["", "lemma iT_Mult_0: \"I \\<noteq> {} \\<Longrightarrow> I \\<otimes> 0 = [\\<dots>0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> I \\<otimes> 0 = [\\<dots>0]", "by (fastforce simp add: iTILL_def iT_Mult_def)"], ["", "corollary iT_Mult_0_if: \"I \\<otimes> 0 = (if I = {} then {} else [\\<dots>0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<otimes> 0 = (if I = {} then {} else [\\<dots>0])", "by (simp add: iT_Mult_empty iT_Mult_0)"], ["", "lemma iT_Plus_mem_iff: \"x \\<in> (I \\<oplus> k) = (k \\<le> x \\<and> (x - k) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> I \\<oplus> k) = (k \\<le> x \\<and> x - k \\<in> I)", "apply (simp add: iT_Plus_def image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xa\\<in>I. x = xa + k) = (k \\<le> x \\<and> x - k \\<in> I)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>xa\\<in>I. x = xa + k \\<Longrightarrow>\n    k \\<le> x \\<and> x - k \\<in> I\n 2. k \\<le> x \\<and> x - k \\<in> I \\<Longrightarrow>\n    \\<exists>xa\\<in>I. x = xa + k", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> x \\<and> x - k \\<in> I \\<Longrightarrow>\n    \\<exists>xa\\<in>I. x = xa + k", "apply (rule_tac x=\"x - k\" in bexI, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_mem_iff2: \"x + k \\<in> (I \\<oplus> k) = (x \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + k \\<in> I \\<oplus> k) = (x \\<in> I)", "by (simp add: iT_Plus_def image_iff)"], ["", "lemma iT_Mult_mem_iff_0: \"x \\<in> (I \\<otimes> 0) = (I \\<noteq> {} \\<and> x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> I \\<otimes> 0) = (I \\<noteq> {} \\<and> x = 0)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    (x \\<in> I \\<otimes> 0) = (I \\<noteq> {} \\<and> x = 0)\n 2. I \\<noteq> {} \\<Longrightarrow>\n    (x \\<in> I \\<otimes> 0) = (I \\<noteq> {} \\<and> x = 0)", "apply (simp add: iT_Mult_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (x \\<in> I \\<otimes> 0) = (I \\<noteq> {} \\<and> x = 0)", "apply (simp add: iT_Mult_0 iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_mem_iff: \"\n  0 < k \\<Longrightarrow> x \\<in> (I \\<otimes> k) = (x mod k = 0 \\<and> x div k \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (x \\<in> I \\<otimes> k) = (x mod k = 0 \\<and> x div k \\<in> I)", "by (fastforce simp: iT_Mult_def image_iff)"], ["", "lemma iT_Mult_mem_iff2: \"0 < k \\<Longrightarrow> x * k \\<in> (I \\<otimes> k) = (x \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> (x * k \\<in> I \\<otimes> k) = (x \\<in> I)", "by (simp add: iT_Mult_def image_iff)"], ["", "lemma iT_Plus_singleton: \"{a} \\<oplus> k = {a + k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<oplus> k = {a + k}", "by (simp add: iT_Plus_def)"], ["", "lemma iT_Mult_singleton: \"{a} \\<otimes> k = {a * k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<otimes> k = {a * k}", "by (simp add: iT_Mult_def)"], ["", "lemma iT_Plus_Un: \"(A \\<union> B) \\<oplus> k = (A \\<oplus> k) \\<union> (B \\<oplus> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B \\<oplus> k = (A \\<oplus> k) \\<union> (B \\<oplus> k)", "by (simp add: iT_Plus_def image_Un)"], ["", "lemma iT_Mult_Un: \"(A \\<union> B) \\<otimes> k = (A \\<otimes> k) \\<union> (B \\<otimes> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B \\<otimes> k = (A \\<otimes> k) \\<union> (B \\<otimes> k)", "by (simp add: iT_Mult_def image_Un)"], ["", "lemma iT_Plus_Int: \"(A \\<inter> B) \\<oplus> k = (A \\<oplus> k) \\<inter> (B \\<oplus> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<oplus> k = (A \\<oplus> k) \\<inter> (B \\<oplus> k)", "by (simp add: iT_Plus_def image_Int)"], ["", "lemma iT_Mult_Int: \"0 < k \\<Longrightarrow> (A \\<inter> B) \\<otimes> k = (A \\<otimes> k) \\<inter> (B \\<otimes> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    A \\<inter> B \\<otimes> k = (A \\<otimes> k) \\<inter> (B \\<otimes> k)", "by (simp add: iT_Mult_def image_Int mult_right_inj)"], ["", "lemma iT_Plus_image: \"f ` I \\<oplus> n = (\\<lambda>x. f x + n) ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` I \\<oplus> n = (\\<lambda>x. f x + n) ` I", "by (fastforce simp: iT_Plus_def)"], ["", "lemma iT_Mult_image: \"f ` I \\<otimes> n = (\\<lambda>x. f x * n) ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` I \\<otimes> n = (\\<lambda>x. f x * n) ` I", "by (fastforce simp: iT_Mult_def)"], ["", "lemma iT_Plus_commute: \"I \\<oplus> a \\<oplus> b = I \\<oplus> b \\<oplus> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus> a \\<oplus> b = I \\<oplus> b \\<oplus> a", "by (fastforce simp: iT_Plus_def)"], ["", "lemma iT_Mult_commute: \"I \\<otimes> a \\<otimes> b = I \\<otimes> b \\<otimes> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<otimes> a \\<otimes> b = I \\<otimes> b \\<otimes> a", "by (fastforce simp: iT_Mult_def)"], ["", "lemma iT_Plus_assoc:\"I \\<oplus> a \\<oplus> b = I \\<oplus> (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus> a \\<oplus> b = I \\<oplus> a + b", "by (fastforce simp: iT_Plus_def)"], ["", "lemma iT_Mult_assoc:\"I \\<otimes> a \\<otimes> b = I \\<otimes> (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<otimes> a \\<otimes> b = I \\<otimes> a * b", "by (fastforce simp: iT_Mult_def)"], ["", "lemma iT_Plus_Mult_distrib: \"I \\<oplus> n \\<otimes> m = I \\<otimes> m \\<oplus> n * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus> n \\<otimes> m = I \\<otimes> m \\<oplus> n * m", "by (simp add: iT_Plus_def iT_Mult_def image_image add_mult_distrib)"], ["", "(*<*)"], ["", "lemma \"i \\<otimes> n1 \\<otimes> n2 \\<otimes> n3 \\<otimes> n4 \\<otimes> n5 \\<otimes> n6 \\<otimes> n7 =\n  i \\<otimes> n1 * n2 * n3 * n4 * n5 * n6 * n7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<otimes> n1 \\<otimes> n2 \\<otimes> n3 \\<otimes> n4 \\<otimes>\n    n5 \\<otimes>\n    n6 \\<otimes>\n    n7 =\n    i \\<otimes> n1 * n2 * n3 * n4 * n5 * n6 * n7", "by (simp add: iT_Mult_assoc)"], ["", "lemma \"i \\<oplus> n1 \\<oplus> n2 \\<oplus> n3 \\<oplus> n4 \\<oplus> n5 = i \\<oplus> n1 + n2 + n3 + n4 + n5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<oplus> n1 \\<oplus> n2 \\<oplus> n3 \\<oplus> n4 \\<oplus> n5 =\n    i \\<oplus> n1 + n2 + n3 + n4 + n5", "by (simp add: iT_Plus_assoc)"], ["", "lemma \"i \\<oplus> n1 \\<otimes> m \\<oplus> n2 = i \\<otimes> m \\<oplus> n1 * m + n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<oplus> n1 \\<otimes> m \\<oplus> n2 =\n    i \\<otimes> m \\<oplus> n1 * m + n2", "by (simp add: iT_Plus_assoc iT_Plus_Mult_distrib)"], ["", "lemma \"i \\<oplus> n1 \\<otimes> m1 \\<otimes> m2 \\<oplus> n2 = i \\<otimes> m1 * m2 \\<oplus> n1 * m1 * m2 + n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<oplus> n1 \\<otimes> m1 \\<otimes> m2 \\<oplus> n2 =\n    i \\<otimes> m1 * m2 \\<oplus> n1 * m1 * m2 + n2", "by (simp add: iT_Plus_assoc iT_Mult_assoc iT_Plus_Mult_distrib)"], ["", "lemma \"n \\<in> I \\<oplus> k \\<Longrightarrow> k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> I \\<oplus> k \\<Longrightarrow> k \\<le> n", "by (clarsimp simp add: iT_Plus_def)"], ["", "(*>*)"], ["", "lemma iT_Plus_finite_iff: \"finite (I \\<oplus> k) = finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (I \\<oplus> k) = finite I", "by (simp add: iT_Plus_def inj_on_finite_image_iff)"], ["", "lemma iT_Mult_0_finite: \"finite (I \\<otimes> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (I \\<otimes> 0)", "by (simp add: iT_Mult_0_if iTILL_0)"], ["", "lemma iT_Mult_finite_iff: \"0 < k \\<Longrightarrow> finite (I \\<otimes> k) = finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> finite (I \\<otimes> k) = finite I", "by (simp add: iT_Mult_def inj_on_finite_image_iff[OF inj_imp_inj_on] mult_right_inj)"], ["", "lemma iT_Plus_Min: \"I \\<noteq> {} \\<Longrightarrow> iMin (I \\<oplus> k) = iMin I + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin (I \\<oplus> k) = iMin I + k", "by (simp add: iT_Plus_def iMin_mono2 mono_def)"], ["", "lemma iT_Mult_Min: \"I \\<noteq> {} \\<Longrightarrow> iMin (I \\<otimes> k) = iMin I * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin (I \\<otimes> k) = iMin I * k", "by (simp add: iT_Mult_def iMin_mono2 mono_def)"], ["", "lemma iT_Plus_Max: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<oplus> k) = Max I + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (I \\<oplus> k) = Max I + k", "by (simp add: iT_Plus_def Max_mono2 mono_def)"], ["", "lemma iT_Mult_Max: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<otimes> k) = Max I * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (I \\<otimes> k) = Max I * k", "by (simp add: iT_Mult_def Max_mono2 mono_def)"], ["", "corollary\n  iMOD_mult_0: \"[r, mod m] \\<otimes> 0 = [\\<dots>0]\" and\n  iMODb_mult_0: \"[r, mod m, c] \\<otimes> 0 = [\\<dots>0]\" and\n  iFROM_mult_0: \"[n\\<dots>] \\<otimes> 0 = [\\<dots>0]\" and\n  iIN_mult_0: \"[n\\<dots>,d] \\<otimes> 0 = [\\<dots>0]\" and\n  iTILL_mult_0: \"[\\<dots>n] \\<otimes> 0 = [\\<dots>0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([ r, mod m ] \\<otimes> 0 = [\\<dots>0] &&&\n     [ r, mod m, c ] \\<otimes> 0 = [\\<dots>0]) &&&\n    [n\\<dots>] \\<otimes> 0 = [\\<dots>0] &&&\n    [n\\<dots>,d] \\<otimes> 0 = [\\<dots>0] &&&\n    [\\<dots>n] \\<otimes> 0 = [\\<dots>0]", "by (simp add: iT_not_empty iT_Mult_0)+"], ["", "lemmas iT_mult_0 =\n  iTILL_mult_0\n  iFROM_mult_0\n  iIN_mult_0\n  iMOD_mult_0\n  iMODb_mult_0"], ["", "lemma iT_Plus_0: \"I \\<oplus> 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus> 0 = I", "by (simp add: iT_Plus_def)"], ["", "lemma iT_Mult_1: \"I \\<otimes> Suc 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<otimes> Suc 0 = I", "by (simp add: iT_Mult_def)"], ["", "corollary\n  iFROM_add_Min: \"iMin ([n\\<dots>] \\<oplus> k) = n + k\" and\n  iIN_add_Min:   \"iMin ([n\\<dots>,d] \\<oplus> k) = n + k\" and\n  iTILL_add_Min: \"iMin ([\\<dots>n] \\<oplus> k) = k\" and\n  iMOD_add_Min:  \"iMin ([r, mod m] \\<oplus> k) = r + k\" and\n  iMODb_add_Min: \"iMin ([r, mod m, c] \\<oplus> k) = r + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iMin ([n\\<dots>] \\<oplus> k) = n + k &&&\n     iMin ([n\\<dots>,d] \\<oplus> k) = n + k) &&&\n    iMin ([\\<dots>n] \\<oplus> k) = k &&&\n    iMin ([ r, mod m ] \\<oplus> k) = r + k &&&\n    iMin ([ r, mod m, c ] \\<oplus> k) = r + k", "by (simp add: iT_not_empty iT_Plus_Min iT_Min)+"], ["", "corollary\n  iFROM_mult_Min: \"iMin ([n\\<dots>] \\<otimes> k) = n * k\" and\n  iIN_mult_Min:   \"iMin ([n\\<dots>,d] \\<otimes> k) = n * k\" and\n  iTILL_mult_Min: \"iMin ([\\<dots>n] \\<otimes> k) = 0\" and\n  iMOD_mult_Min:  \"iMin ([r, mod m] \\<otimes> k) = r * k\" and\n  iMODb_mult_Min: \"iMin ([r, mod m, c] \\<otimes> k) = r * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iMin ([n\\<dots>] \\<otimes> k) = n * k &&&\n     iMin ([n\\<dots>,d] \\<otimes> k) = n * k) &&&\n    iMin ([\\<dots>n] \\<otimes> k) = 0 &&&\n    iMin ([ r, mod m ] \\<otimes> k) = r * k &&&\n    iMin ([ r, mod m, c ] \\<otimes> k) = r * k", "by (simp add: iT_not_empty iT_Mult_Min iT_Min)+"], ["", "lemmas iT_add_Min =\n  iIN_add_Min\n  iTILL_add_Min\n  iFROM_add_Min\n  iMOD_add_Min\n  iMODb_add_Min"], ["", "lemmas iT_mult_Min =\n  iIN_mult_Min\n  iTILL_mult_Min\n  iFROM_mult_Min\n  iMOD_mult_Min\n  iMODb_mult_Min"], ["", "lemma iFROM_add: \"[n\\<dots>] \\<oplus> k = [n+k\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<oplus> k = [n + k\\<dots>]", "by (simp add: iFROM_def iT_Plus_def image_add_atLeast)"], ["", "lemma iIN_add: \"[n\\<dots>,d] \\<oplus> k = [n+k\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<oplus> k = [n + k\\<dots>,d]", "by (fastforce simp add: iIN_def iT_Plus_def)"], ["", "lemma iTILL_add: \"[\\<dots>i] \\<oplus> k = [k\\<dots>,i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>i] \\<oplus> k = [k\\<dots>,i]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_add)"], ["", "lemma iMOD_add: \"[r, mod m] \\<oplus> k = [r + k, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<oplus> k = [ r + k, mod m ]", "apply (clarsimp simp: set_eq_iff iMOD_def iT_Plus_def image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>xa.\n           xa mod m = r mod m \\<and> r \\<le> xa \\<and> x = xa + k) =\n       (x mod m = (r + k) mod m \\<and> r + k \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa mod m = r mod m \\<and>\n          r \\<le> xa \\<and> x = xa + k \\<Longrightarrow>\n       x mod m = (r + k) mod m \\<and> r + k \\<le> x\n 2. \\<And>x.\n       x mod m = (r + k) mod m \\<and> r + k \\<le> x \\<Longrightarrow>\n       \\<exists>xa. xa mod m = r mod m \\<and> r \\<le> xa \\<and> x = xa + k", "apply (clarsimp simp: mod_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x mod m = (r + k) mod m \\<and> r + k \\<le> x \\<Longrightarrow>\n       \\<exists>xa. xa mod m = r mod m \\<and> r \\<le> xa \\<and> x = xa + k", "apply (rule_tac x=\"x - k\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x mod m = (r + k) mod m \\<and> r + k \\<le> x \\<Longrightarrow>\n       (x - k) mod m = r mod m \\<and> r \\<le> x - k \\<and> x = x - k + k", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x mod m = (r + k) mod m; r + k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (x - k) mod m = r mod m \\<and> r \\<le> x - k", "apply (simp add: mod_sub_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_add: \"[r, mod m, c] \\<oplus> k = [r + k, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<oplus> k = [ r + k, mod m, c ]", "by (simp add: iMODb_iMOD_iIN_conv iT_Plus_Int iMOD_add iIN_add)"], ["", "lemmas iT_add =\n  iMOD_add\n  iMODb_add\n  iFROM_add\n  iIN_add\n  iTILL_add\n  iT_Plus_singleton"], ["", "lemma iFROM_mult: \"[n\\<dots>] \\<otimes> k = [ n * k, mod k ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<otimes> k = [ n * k, mod k ]", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> [n\\<dots>] \\<otimes> k = [ n * k, mod k ]\n 2. k \\<noteq> 0 \\<Longrightarrow> [n\\<dots>] \\<otimes> k = [ n * k, mod k ]", "apply (simp add: iMOD_0 iT_mult_0 iIN_0 iTILL_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> [n\\<dots>] \\<otimes> k = [ n * k, mod k ]", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> n \\<le> x div k) =\n       (x mod k = 0 \\<and> n * k \\<le> x)", "apply (rule conj_cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> (n \\<le> x div k) = (n * k \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> n * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k", "apply (drule mult_le_mono1[of _ _ k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k\\<rbrakk>\n       \\<Longrightarrow> n * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k", "apply (rule order_trans, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k\\<rbrakk>\n       \\<Longrightarrow> x div k * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k", "apply (drule div_le_mono[of _ _ k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k div k \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_mult: \"[n\\<dots>,d] \\<otimes> k = [ n * k, mod k, d ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<otimes> k = [ n * k, mod k, d ]", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> [n\\<dots>,d] \\<otimes> k = [ n * k, mod k, d ]\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    [n\\<dots>,d] \\<otimes> k = [ n * k, mod k, d ]", "apply (simp add: iMODb_mod_0 iT_mult_0 iIN_0 iTILL_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    [n\\<dots>,d] \\<otimes> k = [ n * k, mod k, d ]", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> n \\<le> x div k \\<and> x div k \\<le> n + d) =\n       (x mod k = 0 \\<and> n * k \\<le> x \\<and> x \\<le> n * k + k * d)", "apply (rule conj_cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> (n \\<le> x div k \\<and> x div k \\<le> n + d) =\n                         (n * k \\<le> x \\<and> x \\<le> n * k + k * d)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n \\<le> x div k \\<and> x div k \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> n * k \\<le> x \\<and> x \\<le> n * k + k * d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n \\<le> x div k;\n        x div k \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> n * k \\<le> x \\<and> x \\<le> n * k + k * d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (drule mult_le_mono1[of _ _ k], drule mult_le_mono1[of _ _ k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k;\n        x div k * k \\<le> (n + d) * k\\<rbrakk>\n       \\<Longrightarrow> n * k \\<le> x \\<and> x \\<le> n * k + k * d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k;\n        x div k * k \\<le> (n + d) * k\\<rbrakk>\n       \\<Longrightarrow> n * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k;\n        x div k * k \\<le> (n + d) * k\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n * k + k * d\n 3. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (rule order_trans, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k;\n        x div k * k \\<le> (n + d) * k\\<rbrakk>\n       \\<Longrightarrow> x div k * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k;\n        x div k * k \\<le> (n + d) * k\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n * k + k * d\n 3. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x div k * k;\n        x div k * k \\<le> (n + d) * k\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n * k + k * d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (simp add: div_mult_cancel add_mult_distrib mult.commute[of k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0;\n        n * k \\<le> x \\<and> x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k \\<le> x;\n        x \\<le> n * k + k * d\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply (drule div_le_mono[of _ _ k], drule div_le_mono[of _ _ k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; n * k div k \\<le> x div k;\n        x div k \\<le> (n * k + k * d) div k\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x div k \\<and> x div k \\<le> n + d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_mult: \"[\\<dots>n] \\<otimes> k = [ 0, mod k, n ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<otimes> k = [ 0, mod k, n ]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_mult)"], ["", "lemma iMOD_mult: \"[r, mod m ] \\<otimes> k = [ r * k, mod m * k ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<otimes> k = [ r * k, mod m * k ]", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> [ r, mod m ] \\<otimes> k = [ r * k, mod m * k ]\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<otimes> k = [ r * k, mod m * k ]", "apply (simp add: iMOD_0 iT_mult_0 iIN_0 iTILL_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<otimes> k = [ r * k, mod m * k ]", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> x div k mod m = r mod m \\<and> r \\<le> x div k) =\n       (x mod (m * k) = k * (r mod m) \\<and> r * k \\<le> x)", "apply (subst mult.commute[of m k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> x div k mod m = r mod m \\<and> r \\<le> x div k) =\n       (x mod (k * m) = k * (r mod m) \\<and> r * k \\<le> x)", "apply (simp add: mod_mult2_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> x div k mod m = r mod m \\<and> r \\<le> x div k) =\n       (k * (x div k mod m) + x mod k = k * (r mod m) \\<and> r * k \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k;\n        x mod k = 0 \\<and>\n        x div k mod m = r mod m \\<and> r \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> k * (x div k mod m) + x mod k =\n                         k * (r mod m) \\<and>\n                         r * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        k * (x div k mod m) + x mod k = k * (r mod m) \\<and>\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k mod m = r mod m;\n        r \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> k * (x div k mod m) + x mod k =\n                         k * (r mod m) \\<and>\n                         r * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        k * (x div k mod m) + x mod k = k * (r mod m) \\<and>\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (drule mult_le_mono1[of _ _ k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k mod m = r mod m;\n        r * k \\<le> x div k * k\\<rbrakk>\n       \\<Longrightarrow> k * (x div k mod m) + x mod k =\n                         k * (r mod m) \\<and>\n                         r * k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        k * (x div k mod m) + x mod k = k * (r mod m) \\<and>\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k;\n        k * (x div k mod m) + x mod k = k * (r mod m) \\<and>\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (subgoal_tac \"x mod k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0\n 2. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (drule_tac arg_cong[where f=\"\\<lambda>x. x mod k\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; r * k \\<le> x;\n        (k * (x div k mod m) + x mod k) mod k = k * (r mod m) mod k\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0\n 2. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (simp add: mult.commute[of k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        r * k \\<le> x; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply (drule div_le_mono[of _ _ k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; k * (x div k mod m) + x mod k = k * (r mod m);\n        x mod k = 0; r * k div k \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> x mod k = 0 \\<and>\n                         x div k mod m = r mod m \\<and> r \\<le> x div k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_mult: \"\n  [r, mod m, c ] \\<otimes> k = [ r * k, mod m * k, c ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<otimes> k = [ r * k, mod m * k, c ]", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<otimes> k = [ r * k, mod m * k, c ]\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<otimes> k = [ r * k, mod m * k, c ]", "apply (simp add: iMODb_mod_0 iT_mult_0 iIN_0 iTILL_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] \\<otimes> k = [ r * k, mod m * k, c ]", "apply (subst iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [\\<dots>r + m * c] \\<otimes> k =\n    [ r * k, mod m * k, c ]", "apply (simp add: iT_Mult_Int iMOD_mult iTILL_mult iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    [ r * k, mod m * k ] \\<inter>\n    ([ 0, mod k ] \\<inter> [\\<dots>k * (r + m * c)]) =\n    [ r * k, mod m * k ] \\<inter> [\\<dots>r * k + m * k * c]", "apply (subst Int_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    [ r * k, mod m * k ] \\<inter> [ 0, mod k ] \\<inter>\n    [\\<dots>k * (r + m * c)] =\n    [ r * k, mod m * k ] \\<inter> [\\<dots>r * k + m * k * c]", "apply (subst Int_absorb2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < k \\<Longrightarrow> [ r * k, mod m * k ] \\<subseteq> [ 0, mod k ]\n 2. 0 < k \\<Longrightarrow>\n    [ r * k, mod m * k ] \\<inter> [\\<dots>k * (r + m * c)] =\n    [ r * k, mod m * k ] \\<inter> [\\<dots>r * k + m * k * c]", "apply (simp add: iMOD_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    [ r * k, mod m * k ] \\<inter> [\\<dots>k * (r + m * c)] =\n    [ r * k, mod m * k ] \\<inter> [\\<dots>r * k + m * k * c]", "apply (simp add: iMOD_iTILL_iMODb_conv add_mult_distrib2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_mult =\n  iTILL_mult\n  iFROM_mult\n  iIN_mult\n  iMOD_mult\n  iMODb_mult\n  iT_Mult_singleton"], ["", "subsubsection \\<open>Some conversions between intervals using constant addition and multiplication\\<close>"], ["", "lemma iFROM_conv: \"[n\\<dots>] = UNIV \\<oplus> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] = UNIV \\<oplus> n", "by (simp add: iFROM_0[symmetric] iFROM_add)"], ["", "lemma iIN_conv: \"[n\\<dots>,d] = [\\<dots>d] \\<oplus> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] = [\\<dots>d] \\<oplus> n", "by (simp add: iTILL_add)"], ["", "lemma iMOD_conv: \"[r, mod m] = [0\\<dots>] \\<otimes> m \\<oplus> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] = [0\\<dots>] \\<otimes> m \\<oplus> r", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> [ r, mod m ] = [0\\<dots>] \\<otimes> m \\<oplus> r\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] = [0\\<dots>] \\<otimes> m \\<oplus> r", "apply (simp add: iMOD_0 iT_mult_0 iTILL_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m ] = [0\\<dots>] \\<otimes> m \\<oplus> r", "apply (simp add: iFROM_mult iMOD_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_conv: \"[r, mod m, c] = [\\<dots>c] \\<otimes> m \\<oplus> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] = [\\<dots>c] \\<otimes> m \\<oplus> r", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    [ r, mod m, c ] = [\\<dots>c] \\<otimes> m \\<oplus> r\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] = [\\<dots>c] \\<otimes> m \\<oplus> r", "apply (simp add: iMODb_mod_0 iT_mult_0 iTILL_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    [ r, mod m, c ] = [\\<dots>c] \\<otimes> m \\<oplus> r", "apply (simp add: iTILL_mult iMODb_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Some examples showing the utility of iMODb\\_conv\\<close>"], ["", "lemma \"[12, mod 10, 4] = {12, 22, 32, 42, 52}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ 12, mod 10, 4 ] = {12, 22, 32, 42, 52}", "apply (simp add: iT_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x mod 10 = 2 \\<and> 12 \\<le> x \\<and> x \\<le> 52} =\n    {12, 22, 32, 42, 52}", "apply safe"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> 12; x \\<noteq> 22; x \\<noteq> 32; x \\<noteq> 42;\n        x \\<notin> {}; x mod 10 = 2; 12 \\<le> x; x \\<le> 52\\<rbrakk>\n       \\<Longrightarrow> x = 52\n 2. \\<And>x. 12 mod 10 = 2\n 3. \\<And>x. 12 \\<le> 52\n 4. \\<And>x. 22 mod 10 = 2\n 5. \\<And>x. 12 \\<le> 22\n 6. \\<And>x. 22 \\<le> 52\n 7. \\<And>x. 32 mod 10 = 2\n 8. \\<And>x. 12 \\<le> 32\n 9. \\<And>x. 32 \\<le> 52\n 10. \\<And>x. 42 mod 10 = 2\nA total of 14 subgoals...", "defer 1"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x. 12 mod 10 = 2\n 2. \\<And>x. 12 \\<le> 52\n 3. \\<And>x. 22 mod 10 = 2\n 4. \\<And>x. 12 \\<le> 22\n 5. \\<And>x. 22 \\<le> 52\n 6. \\<And>x. 32 mod 10 = 2\n 7. \\<And>x. 12 \\<le> 32\n 8. \\<And>x. 32 \\<le> 52\n 9. \\<And>x. 42 mod 10 = 2\n 10. \\<And>x. 12 \\<le> 42\nA total of 14 subgoals...", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> 12; x \\<noteq> 22; x \\<noteq> 32; x \\<noteq> 42;\n        x mod 10 = 2; 12 \\<le> x; x \\<le> 52\\<rbrakk>\n       \\<Longrightarrow> x = 52", "txt \\<open>The direct proof without iMODb\\_conv fails\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> 12; x \\<noteq> 22; x \\<noteq> 32; x \\<noteq> 42;\n        x mod 10 = 2; 12 \\<le> x; x \\<le> 52\\<rbrakk>\n       \\<Longrightarrow> x = 52", "oops"], ["", "lemma \"[12, mod 10, 4] = {12, 22, 32, 42, 52}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ 12, mod 10, 4 ] = {12, 22, 32, 42, 52}", "apply (simp only: iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>4] \\<otimes> 10 \\<oplus> 12 = {12, 22, 32, 42, 52}", "apply (simp add: iT_defs iT_Mult_def iT_Plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4} =\n    {12, 22, 32, 42, 52}", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x n na.\n       \\<lbrakk>na \\<le> 4; na * 10 + 12 \\<noteq> 12;\n        na * 10 + 12 \\<noteq> 22; na * 10 + 12 \\<noteq> 32;\n        na * 10 + 12 \\<noteq> 42; na * 10 + 12 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> na * 10 + 12 = 52\n 2. \\<And>x. 12 \\<in> (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4}\n 3. \\<And>x. 22 \\<in> (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4}\n 4. \\<And>x. 32 \\<in> (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4}\n 5. \\<And>x. 42 \\<in> (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4}\n 6. \\<And>x. 52 \\<in> (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4}", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"[12, mod 10, 4] = {12, 22, 32, 42, 52}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ 12, mod 10, 4 ] = {12, 22, 32, 42, 52}", "apply (simp only: iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>4] \\<otimes> 10 \\<oplus> 12 = {12, 22, 32, 42, 52}", "apply (simp add: iT_defs iT_Mult_def iT_Plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + 12) ` (\\<lambda>n. n * 10) ` {..4} =\n    {12, 22, 32, 42, 52}", "apply (simp add: atMost_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + 12) ` (\\<lambda>x. x * 10) ` {x. x \\<le> 4} =\n    {12, 22, 32, 42, 52}", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb * 10 + 12 \\<noteq> 12; xb * 10 + 12 \\<noteq> 22;\n        xb * 10 + 12 \\<noteq> 32; xb * 10 + 12 \\<noteq> 42;\n        xb * 10 + 12 \\<notin> {}; xb \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> xb * 10 + 12 = 52\n 2. \\<And>x.\n       12 \\<in> (\\<lambda>x. x + 12) ` (\\<lambda>x. x * 10) ` {x. x \\<le> 4}\n 3. \\<And>x.\n       22 \\<in> (\\<lambda>x. x + 12) ` (\\<lambda>x. x * 10) ` {x. x \\<le> 4}\n 4. \\<And>x.\n       32 \\<in> (\\<lambda>x. x + 12) ` (\\<lambda>x. x * 10) ` {x. x \\<le> 4}\n 5. \\<And>x.\n       42 \\<in> (\\<lambda>x. x + 12) ` (\\<lambda>x. x * 10) ` {x. x \\<le> 4}\n 6. \\<And>x.\n       52 \\<in> (\\<lambda>x. x + 12) ` (\\<lambda>x. x * 10) ` {x. x \\<le> 4}", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"[r, mod m, 4] = {r, r+m, r+2*m, r+3*m, r+4*m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, 4 ] = {r, r + m, r + 2 * m, r + 3 * m, r + 4 * m}", "apply (simp only: iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>4] \\<otimes> m \\<oplus> r =\n    {r, r + m, r + 2 * m, r + 3 * m, r + 4 * m}", "apply (simp add: iT_defs iT_Mult_def iT_Plus_def atMost_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. n + r) ` (\\<lambda>n. n * m) ` {x. x \\<le> 4} =\n    {r, r + m, r + 2 * m, r + 3 * m, r + 4 * m}", "apply (simp add: image_Collect)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_ + r |uu_. \\<exists>x. uu_ = x * m \\<and> x \\<le> 4} =\n    {r, r + m, r + 2 * m, r + 3 * m, r + 4 * m}", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x _ xa.\n       \\<lbrakk>xa * m + r \\<noteq> r; xa * m + r \\<noteq> r + m;\n        xa * m + r \\<noteq> r + 2 * m; xa * m + r \\<noteq> r + 3 * m;\n        xa * m + r \\<notin> {}; xa \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> xa * m + r = r + 4 * m\n 2. \\<And>x.\n       \\<exists>uu_.\n          r = uu_ + r \\<and> (\\<exists>x. uu_ = x * m \\<and> x \\<le> 4)\n 3. \\<And>x.\n       \\<exists>uu_.\n          r + m = uu_ + r \\<and> (\\<exists>x. uu_ = x * m \\<and> x \\<le> 4)\n 4. \\<And>x.\n       \\<exists>uu_.\n          r + 2 * m = uu_ + r \\<and>\n          (\\<exists>x. uu_ = x * m \\<and> x \\<le> 4)\n 5. \\<And>x.\n       \\<exists>uu_.\n          r + 3 * m = uu_ + r \\<and>\n          (\\<exists>x. uu_ = x * m \\<and> x \\<le> 4)\n 6. \\<And>x.\n       \\<exists>uu_.\n          r + 4 * m = uu_ + r \\<and>\n          (\\<exists>x. uu_ = x * m \\<and> x \\<le> 4)", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"[2, mod 10, 4] = {2, 12, 22, 32, 42}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ 2, mod 10, 4 ] = {2, 12, 22, 32, 42}", "apply (simp only: iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>4] \\<otimes> 10 \\<oplus> 2 = {2, 12, 22, 32, 42}", "apply (simp add: iT_defs iT_Plus_def iT_Mult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Suc (Suc x)) ` (\\<lambda>n. n * 10) ` {..4} =\n    {2, 12, 22, 32, 42}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Subtraction of constants\\<close>"], ["", "definition iT_Plus_neg :: \"iT \\<Rightarrow> Time \\<Rightarrow> iT\" (infixl \"\\<oplus>-\" 55) where\n  \"I \\<oplus>- k \\<equiv> {x. x + k \\<in> I}\""], ["", "lemma iT_Plus_neg_mem_iff: \"(x \\<in> I \\<oplus>- k) = (x + k \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> I \\<oplus>- k) = (x + k \\<in> I)", "by (simp add: iT_Plus_neg_def)"], ["", "lemma iT_Plus_neg_mem_iff2: \"k \\<le> x \\<Longrightarrow> (x - k \\<in> I \\<oplus>- k) = (x \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> x \\<Longrightarrow> (x - k \\<in> I \\<oplus>- k) = (x \\<in> I)", "by (simp add: iT_Plus_neg_def)"], ["", "lemma iT_Plus_neg_image_conv: \"I \\<oplus>- k = (\\<lambda>n.(n - k)) ` (I \\<down>\\<ge> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- k = (\\<lambda>n. n - k) ` I \\<down>\\<ge> k", "apply (simp add: iT_Plus_neg_def cut_ge_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x + k \\<in> I \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. x - k) ` {x \\<in> I. k \\<le> x}\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> I; k \\<le> xa\\<rbrakk>\n       \\<Longrightarrow> xa - k + k \\<in> I", "apply (rule_tac x=\"x+k\" in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x + k \\<in> I \\<Longrightarrow> x = x + k - k\n 2. \\<And>x.\n       x + k \\<in> I \\<Longrightarrow> x + k \\<in> {x \\<in> I. k \\<le> x}\n 3. \\<And>x xa.\n       \\<lbrakk>xa \\<in> I; k \\<le> xa\\<rbrakk>\n       \\<Longrightarrow> xa - k + k \\<in> I", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_cut_eq: \"t \\<le> k \\<Longrightarrow> (I \\<down>\\<ge> t) \\<oplus>- k = I \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> k \\<Longrightarrow> I \\<down>\\<ge> t \\<oplus>- k = I \\<oplus>- k", "by (simp add: set_eq_iff iT_Plus_neg_mem_iff cut_ge_mem_iff)"], ["", "lemma iT_Plus_neg_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<oplus>- k \\<subseteq> B \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    A \\<oplus>- k \\<subseteq> B \\<oplus>- k", "by (simp add: iT_Plus_neg_def subset_iff)"], ["", "lemma iT_Plus_neg_empty: \"{} \\<oplus>- k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<oplus>- k = {}", "by (simp add: iT_Plus_neg_def)"], ["", "lemma iT_Plus_neg_Max_less_empty: \"\n  \\<lbrakk> finite I; Max I < k \\<rbrakk> \\<Longrightarrow> I \\<oplus>- k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; Max I < k\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus>- k = {}", "by (simp add: iT_Plus_neg_image_conv cut_ge_Max_empty)"], ["", "lemma iT_Plus_neg_not_empty_iff: \"(I \\<oplus>- k \\<noteq> {}) = (\\<exists>x\\<in>I. k \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k \\<noteq> {}) = (\\<exists>x\\<in>I. k \\<le> x)", "by (simp add: iT_Plus_neg_image_conv cut_ge_not_empty_iff)"], ["", "lemma iT_Plus_neg_empty_iff: \"\n  (I \\<oplus>- k = {}) = (I = {} \\<or> (finite I \\<and> Max I < k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k = {}) = (I = {} \\<or> finite I \\<and> Max I < k)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    (I \\<oplus>- k = {}) = (I = {} \\<or> finite I \\<and> Max I < k)\n 2. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<oplus>- k = {}) = (I = {} \\<or> finite I \\<and> Max I < k)", "apply (simp add: iT_Plus_neg_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<oplus>- k = {}) = (I = {} \\<or> finite I \\<and> Max I < k)", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<down>\\<ge> k = {}) = (finite I \\<and> Max I < k)", "apply (case_tac \"infinite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; infinite I\\<rbrakk>\n    \\<Longrightarrow> (I \\<down>\\<ge> k = {}) = (finite I \\<and> Max I < k)\n 2. \\<lbrakk>I \\<noteq> {}; \\<not> infinite I\\<rbrakk>\n    \\<Longrightarrow> (I \\<down>\\<ge> k = {}) = (finite I \\<and> Max I < k)", "apply (simp add: nat_cut_ge_infinite_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; \\<not> infinite I\\<rbrakk>\n    \\<Longrightarrow> (I \\<down>\\<ge> k = {}) = (finite I \\<and> Max I < k)", "apply (simp add: cut_ge_empty_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_assoc: \"(I \\<oplus>- a) \\<oplus>- b = I \\<oplus>- (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- a \\<oplus>- b = I \\<oplus>- a + b", "apply (simp add: iT_Plus_neg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x + b + a \\<in> I} = {x. x + (a + b) \\<in> I}", "apply (simp add: add.assoc add.commute[of b])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_commute: \"I \\<oplus>- a \\<oplus>- b = I \\<oplus>- b \\<oplus>- a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- a \\<oplus>- b = I \\<oplus>- b \\<oplus>- a", "by (simp add: iT_Plus_neg_assoc add.commute[of b])"], ["", "lemma iT_Plus_neg_0: \"I \\<oplus>- 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- 0 = I", "by (simp add: iT_Plus_neg_image_conv cut_ge_0_all)"], ["", "lemma iT_Plus_Plus_neg_assoc: \"b \\<le> a \\<Longrightarrow> I \\<oplus> a \\<oplus>- b = I \\<oplus> (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> I \\<oplus> a \\<oplus>- b = I \\<oplus> a - b", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow>\n    (\\<lambda>n. n - b) ` (I \\<oplus> a) \\<down>\\<ge> b = I \\<oplus> a - b", "apply (clarsimp simp add: set_eq_iff image_iff Bex_def cut_ge_mem_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       b \\<le> a \\<Longrightarrow>\n       (\\<exists>xa\\<ge>a.\n           xa - a \\<in> I \\<and> b \\<le> xa \\<and> x = xa - b) =\n       (a - b \\<le> x \\<and> x + b - a \\<in> I)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>b \\<le> a;\n        \\<exists>xa\\<ge>a.\n           xa - a \\<in> I \\<and> b \\<le> xa \\<and> x = xa - b\\<rbrakk>\n       \\<Longrightarrow> a - b \\<le> x \\<and> x + b - a \\<in> I\n 2. \\<And>x.\n       \\<lbrakk>b \\<le> a; a - b \\<le> x \\<and> x + b - a \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>a.\n                            xa - a \\<in> I \\<and>\n                            b \\<le> xa \\<and> x = xa - b", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b \\<le> a; a - b \\<le> x \\<and> x + b - a \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>a.\n                            xa - a \\<in> I \\<and>\n                            b \\<le> xa \\<and> x = xa - b", "apply (rule_tac x=\"x + b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b \\<le> a; a - b \\<le> x \\<and> x + b - a \\<in> I\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x + b \\<and>\n                         x + b - a \\<in> I \\<and>\n                         b \\<le> x + b \\<and> x = x + b - b", "apply (simp add: le_diff_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_Plus_neg_assoc2: \"a \\<le> b \\<Longrightarrow> I \\<oplus> a \\<oplus>- b = I \\<oplus>- (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> I \\<oplus> a \\<oplus>- b = I \\<oplus>- b - a", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    (\\<lambda>n. n - b) ` (I \\<oplus> a) \\<down>\\<ge> b =\n    (\\<lambda>x. x + a - b) ` I \\<down>\\<ge> (b - a)", "apply (clarsimp simp add: set_eq_iff image_iff Bex_def cut_ge_mem_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a \\<le> b \\<Longrightarrow>\n       (\\<exists>xa\\<ge>a.\n           xa - a \\<in> I \\<and> b \\<le> xa \\<and> x = xa - b) =\n       (\\<exists>xa. xa \\<in> I \\<and> b - a \\<le> xa \\<and> x = xa + a - b)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        \\<exists>xa\\<ge>a.\n           xa - a \\<in> I \\<and> b \\<le> xa \\<and> x = xa - b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and>\n                            b - a \\<le> xa \\<and> x = xa + a - b\n 2. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        \\<exists>xa.\n           xa \\<in> I \\<and> b - a \\<le> xa \\<and> x = xa + a - b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>a.\n                            xa - a \\<in> I \\<and>\n                            b \\<le> xa \\<and> x = xa - b", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        \\<exists>xa.\n           xa \\<in> I \\<and> b - a \\<le> xa \\<and> x = xa + a - b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>a.\n                            xa - a \\<in> I \\<and>\n                            b \\<le> xa \\<and> x = xa - b", "apply (clarify, rename_tac x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; x' \\<in> I; b - a \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<ge>a.\n                            x - a \\<in> I \\<and>\n                            b \\<le> x \\<and> x' + a - b = x - b", "apply (rule_tac x=\"x' + a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; x' \\<in> I; b - a \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x' + a \\<and>\n                         x' + a - a \\<in> I \\<and>\n                         b \\<le> x' + a \\<and> x' + a - b = x' + a - b", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_Plus_le_cut_eq: \"\n  a \\<le> b \\<Longrightarrow> (I \\<oplus>- a) \\<oplus> b = (I \\<down>\\<ge> a) \\<oplus> (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    I \\<oplus>- a \\<oplus> b = I \\<down>\\<ge> a \\<oplus> b - a", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    (\\<lambda>n. n - a) ` I \\<down>\\<ge> a \\<oplus> b =\n    I \\<down>\\<ge> a \\<oplus> b - a", "apply (clarsimp simp add: set_eq_iff image_iff Bex_def cut_ge_mem_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a \\<le> b \\<Longrightarrow>\n       (b \\<le> x \\<and>\n        (\\<exists>xa. xa \\<in> I \\<and> a \\<le> xa \\<and> x - b = xa - a)) =\n       (b - a \\<le> x \\<and> x + a - b \\<in> I \\<and> a \\<le> x + a - b)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b \\<le> x \\<and>\n        (\\<exists>xa.\n            xa \\<in> I \\<and> a \\<le> xa \\<and> x - b = xa - a)\\<rbrakk>\n       \\<Longrightarrow> b - a \\<le> x \\<and>\n                         x + a - b \\<in> I \\<and> a \\<le> x + a - b\n 2. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b - a \\<le> x \\<and>\n        x + a - b \\<in> I \\<and> a \\<le> x + a - b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> x \\<and>\n                         (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             a \\<le> xa \\<and> x - b = xa - a)", "apply (clarify, rename_tac x')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; b \\<le> x; x' \\<in> I; a \\<le> x';\n        x - b = x' - a\\<rbrakk>\n       \\<Longrightarrow> b - a \\<le> x \\<and>\n                         x + a - b \\<in> I \\<and> a \\<le> x + a - b\n 2. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b - a \\<le> x \\<and>\n        x + a - b \\<in> I \\<and> a \\<le> x + a - b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> x \\<and>\n                         (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             a \\<le> xa \\<and> x - b = xa - a)", "apply (subgoal_tac \"x' = x + a - b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; b \\<le> x; x' \\<in> I; a \\<le> x';\n        x - b = x' - a; x' = x + a - b\\<rbrakk>\n       \\<Longrightarrow> b - a \\<le> x \\<and>\n                         x + a - b \\<in> I \\<and> a \\<le> x + a - b\n 2. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; b \\<le> x; x' \\<in> I; a \\<le> x';\n        x - b = x' - a\\<rbrakk>\n       \\<Longrightarrow> x' = x + a - b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b - a \\<le> x \\<and>\n        x + a - b \\<in> I \\<and> a \\<le> x + a - b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> x \\<and>\n                         (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             a \\<le> xa \\<and> x - b = xa - a)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; b \\<le> x; x' \\<in> I; a \\<le> x';\n        x - b = x' - a\\<rbrakk>\n       \\<Longrightarrow> x' = x + a - b\n 2. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; b \\<le> x; x' \\<in> I; a \\<le> x';\n        x - b = x' - a; x' = x + a - b\\<rbrakk>\n       \\<Longrightarrow> b - a \\<le> x \\<and>\n                         x + a - b \\<in> I \\<and> a \\<le> x + a - b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b - a \\<le> x \\<and>\n        x + a - b \\<in> I \\<and> a \\<le> x + a - b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> x \\<and>\n                         (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             a \\<le> xa \\<and> x - b = xa - a)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>a \\<le> b; b \\<le> x; x' \\<in> I; a \\<le> x';\n        x - b = x' - a; x' = x + a - b\\<rbrakk>\n       \\<Longrightarrow> b - a \\<le> x \\<and>\n                         x + a - b \\<in> I \\<and> a \\<le> x + a - b\n 2. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b - a \\<le> x \\<and>\n        x + a - b \\<in> I \\<and> a \\<le> x + a - b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> x \\<and>\n                         (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             a \\<le> xa \\<and> x - b = xa - a)", "apply (simp add: le_imp_diff_le le_add_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> b;\n        b - a \\<le> x \\<and>\n        x + a - b \\<in> I \\<and> a \\<le> x + a - b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> x \\<and>\n                         (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             a \\<le> xa \\<and> x - b = xa - a)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Plus_neg_Plus_le_Min_eq: \"\n  \\<lbrakk> a \\<le> b; a \\<le> iMin I \\<rbrakk> \\<Longrightarrow> (I \\<oplus>- a) \\<oplus> b = I \\<oplus> (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; a \\<le> iMin I\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus>- a \\<oplus> b = I \\<oplus> b - a", "by (simp add: iT_Plus_neg_Plus_le_cut_eq cut_ge_Min_all)"], ["", "lemma iT_Plus_neg_Plus_ge_cut_eq: \"\n  b \\<le> a \\<Longrightarrow> (I \\<oplus>- a) \\<oplus> b = (I \\<down>\\<ge> a) \\<oplus>- (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow>\n    I \\<oplus>- a \\<oplus> b = I \\<down>\\<ge> a \\<oplus>- a - b", "apply (simp add: iT_Plus_neg_image_conv iT_Plus_def cut_cut_ge max_eqL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow>\n    (\\<lambda>n. n + b) ` (\\<lambda>n. n - a) ` I \\<down>\\<ge> a =\n    (\\<lambda>x. x + b - a) ` I \\<down>\\<ge> a", "apply (subst image_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow>\n    ((\\<lambda>n. n + b) \\<circ> (\\<lambda>n. n - a)) ` I \\<down>\\<ge> a =\n    (\\<lambda>x. x + b - a) ` I \\<down>\\<ge> a", "apply (rule image_cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b \\<le> a; x \\<in> I \\<down>\\<ge> a\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>n. n + b) \\<circ> (\\<lambda>n. n - a))\n                          x =\n                         x + b - a", "apply (simp add: cut_ge_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Plus_neg_Plus_ge_Min_eq: \"\n  \\<lbrakk> b \\<le> a; a \\<le> iMin I \\<rbrakk> \\<Longrightarrow> (I \\<oplus>- a) \\<oplus> b = I \\<oplus>- (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> a; a \\<le> iMin I\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus>- a \\<oplus> b = I \\<oplus>- a - b", "by (simp add: iT_Plus_neg_Plus_ge_cut_eq cut_ge_Min_all)"], ["", "lemma iT_Plus_neg_Mult_distrib: \"\n  0 < m \\<Longrightarrow> I \\<oplus>- n \\<otimes> m = I \\<otimes> m \\<oplus>- n * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    I \\<oplus>- n \\<otimes> m = I \\<otimes> m \\<oplus>- n * m", "apply (clarsimp simp: set_eq_iff iT_Plus_neg_image_conv image_iff iT_Plus_def iT_Mult_def Bex_def cut_ge_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       (\\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> n \\<le> x \\<and> xa = x - n) \\<and>\n           x = xa * m) =\n       (\\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> xa = x * m) \\<and>\n           n * m \\<le> xa \\<and> x = xa - n * m)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m;\n        \\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> n \\<le> x \\<and> xa = x - n) \\<and>\n           x = xa * m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x. x \\<in> I \\<and> xa = x * m) \\<and>\n                            n * m \\<le> xa \\<and> x = xa - n * m\n 2. \\<And>x.\n       \\<lbrakk>0 < m;\n        \\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> xa = x * m) \\<and>\n           n * m \\<le> xa \\<and> x = xa - n * m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x.\n                                x \\<in> I \\<and>\n                                n \\<le> x \\<and> xa = x - n) \\<and>\n                            x = xa * m", "apply (clarsimp, rename_tac x')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>0 < m; x' \\<in> I; n \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa \\<in> I \\<and> x = xa * m) \\<and>\n                            n * m \\<le> x \\<and> (x' - n) * m = x - n * m\n 2. \\<And>x.\n       \\<lbrakk>0 < m;\n        \\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> xa = x * m) \\<and>\n           n * m \\<le> xa \\<and> x = xa - n * m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x.\n                                x \\<in> I \\<and>\n                                n \\<le> x \\<and> xa = x - n) \\<and>\n                            x = xa * m", "apply (rule_tac x=\"x' * m\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>0 < m; x' \\<in> I; n \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             x \\<in> I \\<and> x' * m = x * m) \\<and>\n                         n * m \\<le> x' * m \\<and>\n                         (x' - n) * m = x' * m - n * m\n 2. \\<And>x.\n       \\<lbrakk>0 < m;\n        \\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> xa = x * m) \\<and>\n           n * m \\<le> xa \\<and> x = xa - n * m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x.\n                                x \\<in> I \\<and>\n                                n \\<le> x \\<and> xa = x - n) \\<and>\n                            x = xa * m", "apply (simp add: diff_mult_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m;\n        \\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> xa = x * m) \\<and>\n           n * m \\<le> xa \\<and> x = xa - n * m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>x.\n                                x \\<in> I \\<and>\n                                n \\<le> x \\<and> xa = x - n) \\<and>\n                            x = xa * m", "apply (clarsimp, rename_tac x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>0 < m; n \\<le> x'; x' \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                xa \\<in> I \\<and>\n                                n \\<le> xa \\<and> x = xa - n) \\<and>\n                            x' * m - n * m = x * m", "apply (rule_tac x=\"x' - n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>0 < m; n \\<le> x'; x' \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             x \\<in> I \\<and>\n                             n \\<le> x \\<and> x' - n = x - n) \\<and>\n                         x' * m - n * m = (x' - n) * m", "apply (simp add: diff_mult_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>0 < m; n \\<le> x'; x' \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> I \\<and> n \\<le> x \\<and> x' - n = x - n", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_Plus_le_inverse: \"k \\<le> iMin I \\<Longrightarrow> I \\<oplus>- k \\<oplus> k = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> iMin I \\<Longrightarrow> I \\<oplus>- k \\<oplus> k = I", "by (simp add: iT_Plus_neg_Plus_le_Min_eq iT_Plus_0)"], ["", "lemma iT_Plus_neg_Plus_inverse: \"I \\<oplus>- k \\<oplus> k = I \\<down>\\<ge> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- k \\<oplus> k = I \\<down>\\<ge> k", "by (simp add: iT_Plus_neg_Plus_ge_cut_eq iT_Plus_neg_0)"], ["", "lemma iT_Plus_Plus_neg_inverse: \"I \\<oplus> k \\<oplus>- k = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus> k \\<oplus>- k = I", "by (simp add: iT_Plus_Plus_neg_assoc iT_Plus_0)"], ["", "lemma iT_Plus_neg_Un: \"(A \\<union> B) \\<oplus>- k = (A \\<oplus>- k) \\<union> (B \\<oplus>- k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B \\<oplus>- k = (A \\<oplus>- k) \\<union> (B \\<oplus>- k)", "by (fastforce simp: iT_Plus_neg_def)"], ["", "lemma iT_Plus_neg_Int: \"(A \\<inter> B) \\<oplus>- k = (A \\<oplus>- k) \\<inter> (B \\<oplus>- k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<oplus>- k = (A \\<oplus>- k) \\<inter> (B \\<oplus>- k)", "by (fastforce simp: iT_Plus_neg_def)"], ["", "lemma iT_Plus_neg_Max_singleton: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> I \\<oplus>- Max I= {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus>- Max I = {0}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> I \\<oplus>- Max I) = (x \\<in> {0})", "apply (simp add: iT_Plus_neg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (x + Max I \\<in> I) = (x = 0)", "apply (case_tac \"x = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite I; I \\<noteq> {}; x = 0\\<rbrakk>\n       \\<Longrightarrow> (x + Max I \\<in> I) = (x = 0)\n 2. \\<And>x.\n       \\<lbrakk>finite I; I \\<noteq> {}; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x + Max I \\<in> I) = (x = 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite I; I \\<noteq> {}; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x + Max I \\<in> I) = (x = 0)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_singleton: \"{a} \\<oplus>- k = (if k \\<le> a then {a - k} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<oplus>- k = (if k \\<le> a then {a - k} else {})", "by (force simp add: set_eq_iff iT_Plus_neg_mem_iff singleton_iff)"], ["", "corollary iT_Plus_neg_singleton1: \"k \\<le> a \\<Longrightarrow> {a} \\<oplus>- k = {a-k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> a \\<Longrightarrow> {a} \\<oplus>- k = {a - k}", "by (simp add: iT_Plus_neg_singleton)"], ["", "corollary iT_Plus_neg_singleton2: \"a < k \\<Longrightarrow> {a} \\<oplus>- k= {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < k \\<Longrightarrow> {a} \\<oplus>- k = {}", "by (simp add: iT_Plus_neg_singleton)"], ["", "lemma iT_Plus_neg_finite_iff: \"finite (I \\<oplus>- k) = finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (I \\<oplus>- k) = finite I", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) = finite I", "apply (subst inj_on_finite_image_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>n. n - k) (I \\<down>\\<ge> k)\n 2. finite (I \\<down>\\<ge> k) = finite I", "apply (metis cut_geE inj_on_diff_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (I \\<down>\\<ge> k) = finite I", "apply (simp add: nat_cut_ge_finite_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_Min: \"\n  I \\<oplus>- k \\<noteq> {} \\<Longrightarrow> iMin (I \\<oplus>- k) = iMin (I \\<down>\\<ge> k) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- k \\<noteq> {} \\<Longrightarrow>\n    iMin (I \\<oplus>- k) = iMin (I \\<down>\\<ge> k) - k", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<down>\\<ge> k \\<noteq> {} \\<Longrightarrow>\n    iMin ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) =\n    iMin (I \\<down>\\<ge> k) - k", "apply (simp add: iMin_mono2 monoI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_Max: \"\n  \\<lbrakk> finite I; I \\<oplus>- k \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<oplus>- k) = Max I - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (I \\<oplus>- k) = Max I - k", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (MAX n\\<in>I \\<down>\\<ge> k. n - k) = Max I - k", "apply (simp add: Max_mono2 monoI cut_ge_finite cut_ge_Max_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Subtractions of constants from intervals\\<close>"], ["", "lemma iFROM_add_neg: \"[n\\<dots>] \\<oplus>- k = [n - k\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>] \\<oplus>- k = [n - k\\<dots>]", "by (fastforce simp: set_eq_iff iT_Plus_neg_mem_iff)"], ["", "lemma iTILL_add_neg: \"[\\<dots>n] \\<oplus>- k = (if k \\<le> n then [\\<dots>n - k] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<dots>n] \\<oplus>- k = (if k \\<le> n then [\\<dots>n - k] else {})", "by (force simp add: set_eq_iff iT_Plus_neg_mem_iff iT_iff)"], ["", "lemma iTILL_add_neg1: \"k \\<le> n \\<Longrightarrow> [\\<dots>n] \\<oplus>- k = [\\<dots>n-k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow> [\\<dots>n] \\<oplus>- k = [\\<dots>n - k]", "by (simp add: iTILL_add_neg)"], ["", "lemma iTILL_add_neg2: \"n < k \\<Longrightarrow> [\\<dots>n] \\<oplus>- k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < k \\<Longrightarrow> [\\<dots>n] \\<oplus>- k = {}", "by (simp add: iTILL_add_neg)"], ["", "lemma iIN_add_neg: \"\n  [n\\<dots>,d] \\<oplus>- k = (\n    if k \\<le> n then [n - k\\<dots>,d]\n    else if k \\<le> n + d then [\\<dots>n + d - k] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n\\<dots>,d] \\<oplus>- k =\n    (if k \\<le> n then [n - k\\<dots>,d]\n     else if k \\<le> n + d then [\\<dots>n + d - k] else {})", "by (simp add: iIN_iFROM_iTILL_conv iT_Plus_neg_Int iFROM_add_neg iTILL_add_neg iFROM_0)"], ["", "lemma iIN_add_neg1: \"k \\<le> n \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = [n - k\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = [n - k\\<dots>,d]", "by (simp add: iIN_add_neg)"], ["", "lemma iIN_add_neg2: \"\\<lbrakk> n \\<le> k; k \\<le> n + d \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = [\\<dots>n + d - k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> k; k \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = [\\<dots>n + d - k]", "by (simp add: iIN_add_neg iIN_0_iTILL_conv)"], ["", "lemma iIN_add_neg3: \"n + d < k \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + d < k \\<Longrightarrow> [n\\<dots>,d] \\<oplus>- k = {}", "by (simp add: iT_Plus_neg_Max_less_empty iT_finite iT_Max)"], ["", "lemma iMOD_0_add_neg: \"[r, mod 0] \\<oplus>- k = {r} \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod 0 ] \\<oplus>- k = {r} \\<oplus>- k", "by (simp add: iMOD_0 iIN_0)"], ["", "(*\nlemma \"[25, mod 10] \\<oplus>- 32 = [3, mod 10]\"\napply (rule set_eqI)\napply (simp add: iT_Plus_neg_mem_iff iMOD_iff)\napply (simp add: mod_add_eq[of _ 32] mod_Suc)\napply clarify\napply (rule iffI)\napply simp+\ndone\n*)"], ["", "lemma iMOD_gr0_add_neg: \"\n  0 < m \\<Longrightarrow>\n  [r, mod m] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m]\n    else [(m + r mod m - k mod m) mod m, mod m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    [ r, mod m ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m ]\n     else [ (m + r mod m - k mod m) mod m, mod m ])", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       (x \\<in> [ r, mod m ] \\<oplus>- k) =\n       (x \\<in> (if k \\<le> r then [ r - k, mod m ]\n                 else [ (m + r mod m - k mod m) mod m, mod m ]))", "apply (simp add: iMOD_def iT_Plus_neg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       (k \\<le> r \\<longrightarrow>\n        ((x + k) mod m = r mod m \\<and> r \\<le> x + k) =\n        (x mod m = (r - k) mod m \\<and> r - k \\<le> x)) \\<and>\n       (\\<not> k \\<le> r \\<longrightarrow>\n        ((x + k) mod m = r mod m) =\n        (x mod m = (m + r mod m - k mod m) mod m \\<and>\n         (m + r mod m - k mod m) mod m \\<le> x))", "apply (simp add: eq_sym_conv[of _ \"r mod m\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < m \\<Longrightarrow>\n       (k \\<le> r \\<longrightarrow>\n        (r mod m = (x + k) mod m \\<and> r \\<le> x + k) =\n        (x mod m = (r - k) mod m \\<and> r - k \\<le> x)) \\<and>\n       (\\<not> k \\<le> r \\<longrightarrow>\n        (r mod m = (x + k) mod m) =\n        (x mod m = (m + r mod m - k mod m) mod m \\<and>\n         (m + r mod m - k mod m) mod m \\<le> x))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; k \\<le> r\\<rbrakk>\n       \\<Longrightarrow> (r mod m = (x + k) mod m \\<and> r \\<le> x + k) =\n                         (x mod m = (r - k) mod m \\<and> r - k \\<le> x)\n 2. \\<And>x.\n       \\<lbrakk>0 < m; \\<not> k \\<le> r\\<rbrakk>\n       \\<Longrightarrow> (r mod m = (x + k) mod m) =\n                         (x mod m = (m + r mod m - k mod m) mod m \\<and>\n                          (m + r mod m - k mod m) mod m \\<le> x)", "apply (simp add: eq_sym_conv[of _ \"(r - k) mod m\"] mod_sub_add le_diff_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; \\<not> k \\<le> r\\<rbrakk>\n       \\<Longrightarrow> (r mod m = (x + k) mod m) =\n                         (x mod m = (m + r mod m - k mod m) mod m \\<and>\n                          (m + r mod m - k mod m) mod m \\<le> x)", "apply (simp add: eq_commute[of \"r mod m\"] mod_add_eq_mod_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; \\<not> k \\<le> r\\<rbrakk>\n       \\<Longrightarrow> (x mod m = (m + r mod m - k mod m) mod m) =\n                         (x mod m = (m + r mod m - k mod m) mod m \\<and>\n                          (m + r mod m - k mod m) mod m \\<le> x)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; \\<not> k \\<le> r;\n        x mod m = (m + r mod m - k mod m) mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m - k mod m) mod m \\<le> x", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; \\<not> k \\<le> r;\n        (m + r mod m - k mod m) mod m = x mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m - k mod m) mod m \\<le> x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_add_neg: \"\n  [r, mod m] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m]\n    else if 0 < m then [(m + r mod m - k mod m) mod m, mod m] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m ]\n     else if 0 < m then [ (m + r mod m - k mod m) mod m, mod m ] else {})", "apply (case_tac \"0 < m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    [ r, mod m ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m ]\n     else if 0 < m then [ (m + r mod m - k mod m) mod m, mod m ] else {})\n 2. \\<not> 0 < m \\<Longrightarrow>\n    [ r, mod m ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m ]\n     else if 0 < m then [ (m + r mod m - k mod m) mod m, mod m ] else {})", "apply (simp add: iMOD_gr0_add_neg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    [ r, mod m ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m ]\n     else if 0 < m then [ (m + r mod m - k mod m) mod m, mod m ] else {})", "apply (simp add: iMOD_0 iIN_0 iT_Plus_neg_singleton)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_add_neg1: \"\n  k \\<le> r \\<Longrightarrow> [r, mod m] \\<oplus>- k = [r - k, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> r \\<Longrightarrow> [ r, mod m ] \\<oplus>- k = [ r - k, mod m ]", "by (simp add: iMOD_add_neg)"], ["", "lemma iMOD_add_neg2: \"\n  \\<lbrakk> 0 < m; r < k \\<rbrakk> \\<Longrightarrow> [r, mod m] \\<oplus>- k = [(m + r mod m - k mod m) mod m, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r < k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oplus>- k =\n                      [ (m + r mod m - k mod m) mod m, mod m ]", "by (simp add: iMOD_add_neg)"], ["", "lemma iMODb_mod_0_add_neg: \"[r, mod 0, c] \\<oplus>- k = {r} \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod 0, c ] \\<oplus>- k = {r} \\<oplus>- k", "by (simp add: iMODb_mod_0 iIN_0)"], ["", "(*\nlemma \"[25, mod 10, 5] \\<oplus>- 32 = [3, mod 10, 4]\"\napply (rule set_eqI)\napply (simp add: iMODb_conv iT_Plus_neg_mem_iff iT_Plus_mem_iff iT_Mult_mem_iff)\napply (case_tac \"x < 3\", simp)\napply (simp add: linorder_not_less)\napply (rule_tac t=\"(x - 3) mod 10 = 0\" and s=\"x mod 10 = 3\" in subst)\n apply (simp add: mod_eq_diff_mod_0_conv[symmetric])\napply (rule_tac t=\"(7 + x) mod 10 = 0\" and s=\"x mod 10 = 3\" in subst)\n apply (simp add: mod_add1_eq_if[of 7])\napply (rule conj_cong[OF refl])\napply (simp add: div_add1_eq_if)\napply (simp add: div_diff1_eq1)\napply (simp add: iTILL_iff)\ndone\n\nlemma \"[25, mod 10, 5] \\<oplus>- 32 = [3, mod 10, 4]\"\napply (simp add: iT_Plus_neg_image_conv iMODb_cut_ge)\napply (simp add: iMODb_conv iT_Mult_def iT_Plus_def)\napply (rule_tac t=4 and s=\"Suc(Suc(Suc(Suc 0)))\" in subst, simp)\napply (simp add: iTILL_def atMost_Suc)\ndone\n*)"], ["", "lemma iMODb_add_neg: \"\n  [r, mod m, c] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m, c]\n    else\n      if k \\<le> r + m * c then\n      [(m + r mod m - k mod m) mod m, mod m, (r + m * c - k) div m]\n      else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m, c ]\n     else if k \\<le> r + m * c\n          then [ (m + r mod m - k mod m) mod\n                 m, mod m, (r + m * c - k) div m ]\n          else {})", "apply (clarsimp simp add: iMODb_iMOD_iIN_conv iT_Plus_neg_Int iMOD_add_neg iIN_add_neg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; k \\<le> r + m * c; \\<not> k \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ (m + r mod m - k mod m) mod m, mod m ] \\<inter>\n                      [\\<dots>r + m * c - k] =\n                      [ (m + r mod m - k mod m) mod m, mod m ] \\<inter>\n                      [(m + r mod m - k mod m) mod\n                       m\\<dots>,m * ((r + m * c - k) div m)]", "apply (simp add: iMOD_iIN_iMODb_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; k \\<le> r + m * c; \\<not> k \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ (m + r mod m - k mod m) mod m, mod m ] \\<inter>\n                      [\\<dots>r + m * c - k] =\n                      [ (m + r mod m - k mod m) mod\n                        m, mod m, (r + m * c - k) div m ]", "apply (rule_tac t=\"(m + r mod m - k mod m) mod m\" and s=\"(r + m * c - k) mod m\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; k \\<le> r + m * c; \\<not> k \\<le> r\\<rbrakk>\n    \\<Longrightarrow> (r + m * c - k) mod m = (m + r mod m - k mod m) mod m\n 2. \\<lbrakk>0 < m; k \\<le> r + m * c; \\<not> k \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ (r + m * c - k) mod m, mod m ] \\<inter>\n                      [\\<dots>r + m * c - k] =\n                      [ (r + m * c - k) mod\n                        m, mod m, (r + m * c - k) div m ]", "apply (simp add: mod_diff1_eq[of k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; k \\<le> r + m * c; \\<not> k \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ (r + m * c - k) mod m, mod m ] \\<inter>\n                      [\\<dots>r + m * c - k] =\n                      [ (r + m * c - k) mod\n                        m, mod m, (r + m * c - k) div m ]", "apply (subst iMOD_iTILL_iMODb_conv, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; k \\<le> r + m * c; \\<not> k \\<le> r\\<rbrakk>\n    \\<Longrightarrow> [ (r + m * c - k) mod\n                        m, mod m, (r + m * c - k -\n                                   (r + m * c - k) mod m) div\n                                  m ] =\n                      [ (r + m * c - k) mod\n                        m, mod m, (r + m * c - k) div m ]", "apply (subst sub_mod_div_eq_div, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_add_neg': \"\n  [r, mod m, c] \\<oplus>- k = (\n    if k \\<le> r then [r - k, mod m, c]\n    else if k \\<le> r + m * c then\n      if k mod m \\<le> r mod m\n        then [ r mod m - k mod m, mod m, c + r div m - k div m]\n        else [ m + r mod m - k mod m, mod m, c + r div m - Suc (k div m) ]\n      else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ r, mod m, c ] \\<oplus>- k =\n    (if k \\<le> r then [ r - k, mod m, c ]\n     else if k \\<le> r + m * c\n          then if k mod m \\<le> r mod m\n               then [ r mod m - k mod m, mod m, c + r div m - k div m ]\n               else [ m + r mod m -\n                      k mod m, mod m, c + r div m - Suc (k div m) ]\n          else {})", "apply (clarsimp simp add: iMODb_add_neg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k mod m \\<le> r mod m \\<longrightarrow>\n     k \\<le> r + m * c \\<longrightarrow>\n     \\<not> k \\<le> r \\<longrightarrow>\n     [ (m + r mod m - k mod m) mod m, mod m, (r + m * c - k) div m ] =\n     [ r mod m - k mod m, mod m, c + r div m - k div m ]) \\<and>\n    (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n     k \\<le> r + m * c \\<longrightarrow>\n     \\<not> k \\<le> r \\<longrightarrow>\n     [ (m + r mod m - k mod m) mod m, mod m, (r + m * c - k) div m ] =\n     [ m + r mod m - k mod m, mod m, c + r div m - Suc (k div m) ])", "apply (case_tac \"m = 0\", simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    (k mod m \\<le> r mod m \\<longrightarrow>\n     k \\<le> r + m * c \\<longrightarrow>\n     \\<not> k \\<le> r \\<longrightarrow>\n     [ (m + r mod m - k mod m) mod m, mod m, (r + m * c - k) div m ] =\n     [ r mod m - k mod m, mod m, c + r div m - k div m ]) \\<and>\n    (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n     k \\<le> r + m * c \\<longrightarrow>\n     \\<not> k \\<le> r \\<longrightarrow>\n     [ m + r mod m - k mod m, mod m, (r + m * c - k) div m ] =\n     [ m + r mod m - k mod m, mod m, c + r div m - Suc (k div m) ])", "apply (case_tac \"k mod m \\<le> r mod m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; k mod m \\<le> r mod m\\<rbrakk>\n    \\<Longrightarrow> (k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ (m + r mod m - k mod m) mod\n                         m, mod m, (r + m * c - k) div m ] =\n                       [ r mod m -\n                         k mod m, mod m, c + r div m - k div m ]) \\<and>\n                      (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ m + r mod m -\n                         k mod m, mod m, (r + m * c - k) div m ] =\n                       [ m + r mod m -\n                         k mod m, mod m, c + r div m - Suc (k div m) ])\n 2. \\<lbrakk>0 < m; \\<not> k mod m \\<le> r mod m\\<rbrakk>\n    \\<Longrightarrow> (k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ (m + r mod m - k mod m) mod\n                         m, mod m, (r + m * c - k) div m ] =\n                       [ r mod m -\n                         k mod m, mod m, c + r div m - k div m ]) \\<and>\n                      (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ m + r mod m -\n                         k mod m, mod m, (r + m * c - k) div m ] =\n                       [ m + r mod m -\n                         k mod m, mod m, c + r div m - Suc (k div m) ])", "apply (clarsimp simp: linorder_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; k mod m \\<le> r mod m; k \\<le> r + m * c; r < k\\<rbrakk>\n    \\<Longrightarrow> [ (m + r mod m - k mod m) mod\n                        m, mod m, (r + m * c - k) div m ] =\n                      [ r mod m - k mod m, mod m, c + r div m - k div m ]\n 2. \\<lbrakk>0 < m; \\<not> k mod m \\<le> r mod m\\<rbrakk>\n    \\<Longrightarrow> (k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ (m + r mod m - k mod m) mod\n                         m, mod m, (r + m * c - k) div m ] =\n                       [ r mod m -\n                         k mod m, mod m, c + r div m - k div m ]) \\<and>\n                      (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ m + r mod m -\n                         k mod m, mod m, (r + m * c - k) div m ] =\n                       [ m + r mod m -\n                         k mod m, mod m, c + r div m - Suc (k div m) ])", "apply (simp add: divisor_add_diff_mod_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; k mod m \\<le> r mod m; k \\<le> r + m * c; r < k\\<rbrakk>\n    \\<Longrightarrow> [ r mod m - k mod m, mod m, (r + m * c - k) div m ] =\n                      [ r mod m - k mod m, mod m, c + r div m - k div m ]\n 2. \\<lbrakk>0 < m; \\<not> k mod m \\<le> r mod m\\<rbrakk>\n    \\<Longrightarrow> (k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ (m + r mod m - k mod m) mod\n                         m, mod m, (r + m * c - k) div m ] =\n                       [ r mod m -\n                         k mod m, mod m, c + r div m - k div m ]) \\<and>\n                      (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ m + r mod m -\n                         k mod m, mod m, (r + m * c - k) div m ] =\n                       [ m + r mod m -\n                         k mod m, mod m, c + r div m - Suc (k div m) ])", "apply (simp add: div_diff1_eq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; \\<not> k mod m \\<le> r mod m\\<rbrakk>\n    \\<Longrightarrow> (k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ (m + r mod m - k mod m) mod\n                         m, mod m, (r + m * c - k) div m ] =\n                       [ r mod m -\n                         k mod m, mod m, c + r div m - k div m ]) \\<and>\n                      (\\<not> k mod m \\<le> r mod m \\<longrightarrow>\n                       k \\<le> r + m * c \\<longrightarrow>\n                       \\<not> k \\<le> r \\<longrightarrow>\n                       [ m + r mod m -\n                         k mod m, mod m, (r + m * c - k) div m ] =\n                       [ m + r mod m -\n                         k mod m, mod m, c + r div m - Suc (k div m) ])", "apply (clarsimp simp: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r mod m < k mod m; k \\<le> r + m * c; r < k\\<rbrakk>\n    \\<Longrightarrow> [ m + r mod m -\n                        k mod m, mod m, (r + m * c - k) div m ] =\n                      [ m + r mod m -\n                        k mod m, mod m, c + r div m - Suc (k div m) ]", "apply (simp add:  div_diff1_eq_if)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMODb_add_neg1: \"\n  k \\<le> r \\<Longrightarrow> [r, mod m, c] \\<oplus>- k = [r - k, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> r \\<Longrightarrow>\n    [ r, mod m, c ] \\<oplus>- k = [ r - k, mod m, c ]", "by (simp add: iMODb_add_neg)"], ["", "corollary iMODb_add_neg2: \"\n  \\<lbrakk> r < k; k \\<le> r + m * c \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oplus>- k =\n  [(m + r mod m - k mod m) mod m, mod m, (r + m * c - k) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < k; k \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oplus>- k =\n                      [ (m + r mod m - k mod m) mod\n                        m, mod m, (r + m * c - k) div m ]", "by (simp add: iMODb_add_neg)"], ["", "corollary iMODb_add_neg2_mod_le: \"\n  \\<lbrakk> r < k; k \\<le> r + m * c; k mod m \\<le> r mod m \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oplus>- k =\n  [ r mod m - k mod m, mod m, c + r div m - k div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < k; k \\<le> r + m * c; k mod m \\<le> r mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oplus>- k =\n                      [ r mod m - k mod m, mod m, c + r div m - k div m ]", "by (simp add: iMODb_add_neg')"], ["", "corollary iMODb_add_neg2_mod_less: \"\n  \\<lbrakk> r < k; k \\<le> r + m * c; r mod m < k mod m\\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oplus>- k =\n  [ m + r mod m - k mod m, mod m, c + r div m - Suc (k div m) ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < k; k \\<le> r + m * c; r mod m < k mod m\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oplus>- k =\n                      [ m + r mod m -\n                        k mod m, mod m, c + r div m - Suc (k div m) ]", "by (simp add: iMODb_add_neg')"], ["", "lemma iMODb_add_neg3: \"r + m * c < k  \\<Longrightarrow> [r, mod m, c] \\<oplus>- k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r + m * c < k \\<Longrightarrow> [ r, mod m, c ] \\<oplus>- k = {}", "by (simp add: iMODb_add_neg)"], ["", "lemmas iT_add_neg =\n  iFROM_add_neg\n  iIN_add_neg\n  iTILL_add_neg\n  iMOD_add_neg\n  iMODb_add_neg\n  iT_Plus_neg_singleton"], ["", "subsubsection \\<open>Subtraction of intervals from constants\\<close>"], ["", "definition iT_Minus :: \"Time \\<Rightarrow> iT \\<Rightarrow> iT\" (infixl \"\\<ominus>\" 55)\n  where \"k \\<ominus> I \\<equiv> {x. x \\<le> k \\<and> (k - x) \\<in> I}\""], ["", "lemma iT_Minus_mem_iff: \"(x \\<in> k \\<ominus> I) = (x \\<le> k \\<and> k - x \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> k \\<ominus> I) = (x \\<le> k \\<and> k - x \\<in> I)", "by (simp add: iT_Minus_def)"], ["", "lemma iT_Minus_mono: \"A \\<subseteq> B \\<Longrightarrow> k \\<ominus> A \\<subseteq> k \\<ominus> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    k \\<ominus> A \\<subseteq> k \\<ominus> B", "by (simp add: subset_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_image_conv: \"k \\<ominus> I = (\\<lambda>x. k - x) ` (I \\<down>\\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> I = (-) k ` I \\<down>\\<le> k", "by (fastforce simp: iT_Minus_def cut_le_def image_iff)"], ["", "lemma iT_Minus_cut_eq: \"k \\<le> t \\<Longrightarrow> k \\<ominus> (I \\<down>\\<le> t) = k \\<ominus> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow> k \\<ominus> I \\<down>\\<le> t = k \\<ominus> I", "by (fastforce simp: set_eq_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_Minus_cut_eq: \"k \\<ominus> (k \\<ominus> (I \\<down>\\<le> k)) = I \\<down>\\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> (k \\<ominus> I \\<down>\\<le> k) = I \\<down>\\<le> k", "by (fastforce simp: iT_Minus_def)"], ["", "lemma \"10 \\<ominus> [\\<dots>3] = [7\\<dots>,3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 10 \\<ominus> [\\<dots>3] = [7\\<dots>,3]", "by (fastforce simp: iT_Minus_def)"], ["", "lemma iT_Minus_empty: \"k \\<ominus> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> {} = {}", "by (simp add: iT_Minus_def)"], ["", "lemma iT_Minus_0: \"k \\<ominus> {0} = {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> {0} = {k}", "by (simp add: iT_Minus_image_conv cut_le_def image_Collect)"], ["", "lemma iT_Minus_bound: \"x \\<in> k \\<ominus> I \\<Longrightarrow> x \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> k \\<ominus> I \\<Longrightarrow> x \\<le> k", "by (simp add: iT_Minus_def)"], ["", "lemma iT_Minus_finite: \"finite (k \\<ominus> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (k \\<ominus> I)", "apply (rule finite_nat_iff_bounded_le2[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ka. \\<forall>n\\<in>k \\<ominus> I. n \\<le> ka", "apply (rule_tac x=k in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>k \\<ominus> I. n \\<le> k", "apply (simp add: iT_Minus_bound)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_less_Min_empty: \"k < iMin I \\<Longrightarrow> k \\<ominus> I = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < iMin I \\<Longrightarrow> k \\<ominus> I = {}", "by (simp add: iT_Minus_image_conv cut_le_Min_empty)"], ["", "lemma iT_Minus_Min_singleton: \"I \\<noteq> {} \\<Longrightarrow> (iMin I) \\<ominus> I = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin I \\<ominus> I = {0}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       I \\<noteq> {} \\<Longrightarrow>\n       (x \\<in> iMin I \\<ominus> I) = (x \\<in> {0})", "apply (simp add: iT_Minus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       I \\<noteq> {} \\<Longrightarrow>\n       (x \\<le> iMin I \\<and> iMin I - x \\<in> I) = (x = 0)", "apply (fastforce intro: iMinI_ex2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_empty_iff: \"(k \\<ominus> I = {}) = (I = {} \\<or> k < iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I = {}) = (I = {} \\<or> k < iMin I)", "apply (case_tac \"I = {}\", simp add: iT_Minus_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (k \\<ominus> I = {}) = (I = {} \\<or> k < iMin I)", "apply (simp add: iT_Minus_image_conv cut_le_empty_iff iMin_gr_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\nAn example:\n  100 \\<ominus> {60, 70, 80, 90, 95} = {5, 10, 20, 30, 40}\n  imirror {60, 70, 80, 90, 95} = {60, 65, 75, 95, 95}\n  {60, 65, 75, 85, 95} \\<oplus> 100 \\<oplus>- (60 + 95)\n  = {160, 165, 175, 185, 195} \\<oplus>- 155\n  = {5, 10, 20, 30, 40}\n\nI \\<oplus> k \\<oplus>- (iMin I + Max I))\n*)"], ["", "lemma iT_Minus_imirror_conv: \"\n  k \\<ominus> I = imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>- (iMin I + Max (I \\<down>\\<le> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin I + Max (I \\<down>\\<le> k)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin I + Max (I \\<down>\\<le> k)\n 2. I \\<noteq> {} \\<Longrightarrow>\n    k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin I + Max (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_empty cut_le_empty imirror_empty iT_Plus_empty iT_Plus_neg_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin I + Max (I \\<down>\\<le> k)", "apply (case_tac \"k < iMin I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k < iMin I\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin I + Max (I \\<down>\\<le> k)\n 2. \\<lbrakk>I \\<noteq> {}; \\<not> k < iMin I\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin I + Max (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_less_Min_empty cut_le_Min_empty imirror_empty iT_Plus_empty iT_Plus_neg_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; \\<not> k < iMin I\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin I + Max (I \\<down>\\<le> k)", "apply (simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin I + Max (I \\<down>\\<le> k)", "apply (frule cut_le_Min_not_empty[of _ k], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin I + Max (I \\<down>\\<le> k)", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n        I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> k \\<ominus> I) =\n                         (x \\<in> imirror (I \\<down>\\<le> k) \\<oplus>\n                                  k \\<oplus>-\n                                  iMin I + Max (I \\<down>\\<le> k))", "apply (simp add: iT_Minus_image_conv iT_Plus_neg_image_conv iT_Plus_neg_mem_iff iT_Plus_mem_iff imirror_iff image_iff Bex_def i_cut_mem_iff cut_le_Min_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n        I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             xa \\<le> k \\<and> x = k - xa) =\n                         (\\<exists>xa\\<ge>k.\n                             (\\<exists>x.\n                                 x \\<in> I \\<and>\n                                 x \\<le> k \\<and>\n                                 xa - k =\n                                 iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n                             iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n                             x = xa - (iMin I + Max (I \\<down>\\<le> k)))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa. xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>k.\n                            (\\<exists>x.\n                                x \\<in> I \\<and>\n                                x \\<le> k \\<and>\n                                xa - k =\n                                iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n                            iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n                            x = xa - (iMin I + Max (I \\<down>\\<le> k))\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa\\<ge>k.\n           (\\<exists>x.\n               x \\<in> I \\<and>\n               x \\<le> k \\<and>\n               xa - k = iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n           iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n           x = xa - (iMin I + Max (I \\<down>\\<le> k))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa", "apply (clarsimp, rename_tac x')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        x' \\<in> I; x' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<ge>k.\n                            (\\<exists>xa.\n                                xa \\<in> I \\<and>\n                                xa \\<le> k \\<and>\n                                x - k =\n                                iMin I + Max (I \\<down>\\<le> k) - xa) \\<and>\n                            iMin I + Max (I \\<down>\\<le> k) \\<le> x \\<and>\n                            k - x' = x - (iMin I + Max (I \\<down>\\<le> k))\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa\\<ge>k.\n           (\\<exists>x.\n               x \\<in> I \\<and>\n               x \\<le> k \\<and>\n               xa - k = iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n           iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n           x = xa - (iMin I + Max (I \\<down>\\<le> k))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa", "apply (rule_tac x=\"k - x' + iMin I + Max (I \\<down>\\<le> k)\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        x' \\<in> I; x' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> k + iMin I + Max (I \\<down>\\<le> k) -\n                                 x' \\<and>\n                         (\\<exists>x.\n                             x \\<in> I \\<and>\n                             x \\<le> k \\<and>\n                             iMin I + Max (I \\<down>\\<le> k) - x' =\n                             iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n                         iMin I + Max (I \\<down>\\<le> k)\n                         \\<le> k + iMin I + Max (I \\<down>\\<le> k) - x'\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa\\<ge>k.\n           (\\<exists>x.\n               x \\<in> I \\<and>\n               x \\<le> k \\<and>\n               xa - k = iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n           iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n           x = xa - (iMin I + Max (I \\<down>\\<le> k))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa", "apply (simp add: add.assoc le_add_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        x' \\<in> I; x' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> k + (iMin I + Max (I \\<down>\\<le> k)) -\n                                 x' \\<and>\n                         (\\<exists>x.\n                             x \\<in> I \\<and>\n                             x \\<le> k \\<and>\n                             iMin I + Max (I \\<down>\\<le> k) - x' =\n                             iMin I + Max (I \\<down>\\<le> k) - x)\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa\\<ge>k.\n           (\\<exists>x.\n               x \\<in> I \\<and>\n               x \\<le> k \\<and>\n               xa - k = iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n           iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n           x = xa - (iMin I + Max (I \\<down>\\<le> k))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa", "apply (simp add: add.commute[of k] le_add_diff nat_cut_le_finite cut_leI trans_le_add2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        x' \\<in> I; x' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> I \\<and>\n                            x \\<le> k \\<and>\n                            iMin I + Max (I \\<down>\\<le> k) - x' =\n                            iMin I + Max (I \\<down>\\<le> k) - x\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa\\<ge>k.\n           (\\<exists>x.\n               x \\<in> I \\<and>\n               x \\<le> k \\<and>\n               xa - k = iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n           iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n           x = xa - (iMin I + Max (I \\<down>\\<le> k))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa", "apply (rule_tac x=x' in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        \\<exists>xa\\<ge>k.\n           (\\<exists>x.\n               x \\<in> I \\<and>\n               x \\<le> k \\<and>\n               xa - k = iMin I + Max (I \\<down>\\<le> k) - x) \\<and>\n           iMin I + Max (I \\<down>\\<le> k) \\<le> xa \\<and>\n           x = xa - (iMin I + Max (I \\<down>\\<le> k))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and> xa \\<le> k \\<and> x = k - xa", "apply (clarsimp, rename_tac x1 x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        k \\<le> x1; iMin I + Max (I \\<down>\\<le> k) \\<le> x1; x2 \\<in> I;\n        x2 \\<le> k; x1 - k = iMin I + Max (I \\<down>\\<le> k) - x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> I \\<and>\n                            x \\<le> k \\<and>\n                            x1 - (iMin I + Max (I \\<down>\\<le> k)) = k - x", "apply (rule_tac x=x2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        k \\<le> x1; iMin I + Max (I \\<down>\\<le> k) \\<le> x1; x2 \\<in> I;\n        x2 \\<le> k; x1 - k = iMin I + Max (I \\<down>\\<le> k) - x2\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> I \\<and>\n                         x2 \\<le> k \\<and>\n                         x1 - (iMin I + Max (I \\<down>\\<le> k)) = k - x2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        k \\<le> x1; iMin I + Max (I \\<down>\\<le> k) \\<le> x1; x2 \\<in> I;\n        x2 \\<le> k; x1 - k = iMin I + Max (I \\<down>\\<le> k) - x2\\<rbrakk>\n       \\<Longrightarrow> x1 - (iMin I + Max (I \\<down>\\<le> k)) = k - x2", "apply (drule add_right_cancel[THEN iffD2, of _ _ k], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n        iMin I + Max (I \\<down>\\<le> k)\n        \\<le> iMin I + Max (I \\<down>\\<le> k) - x2 + k;\n        x2 \\<in> I; x2 \\<le> k;\n        x1 = iMin I + Max (I \\<down>\\<le> k) - x2 + k\\<rbrakk>\n       \\<Longrightarrow> iMin I + Max (I \\<down>\\<le> k) - x2 + k -\n                         (iMin I + Max (I \\<down>\\<le> k)) =\n                         k - x2", "apply (simp add: trans_le_add2 nat_cut_le_finite cut_le_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_imirror_conv': \"\n  k \\<ominus> I = imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>- (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\n 2. I \\<noteq> {} \\<Longrightarrow>\n    k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_empty cut_le_empty imirror_empty iT_Plus_empty iT_Plus_neg_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    k \\<ominus> I =\n    imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n    iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)", "apply (case_tac \"k < iMin I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k < iMin I\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\n 2. \\<lbrakk>I \\<noteq> {}; \\<not> k < iMin I\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_less_Min_empty cut_le_Min_empty imirror_empty iT_Plus_empty iT_Plus_neg_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; \\<not> k < iMin I\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I =\n                      imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                      iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)", "apply (simp add: cut_le_Min_not_empty cut_le_Min_eq iT_Minus_imirror_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Max: \"\n  \\<lbrakk> I \\<noteq> {}; iMin I \\<le> k \\<rbrakk> \\<Longrightarrow> Max (k \\<ominus> I) = k - (iMin I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> Max (k \\<ominus> I) = k - iMin I", "apply (rule Max_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> k - iMin I \\<in> k \\<ominus> I\n 2. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> finite (k \\<ominus> I)\n 3. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n        x \\<in> k \\<ominus> I\\<rbrakk>\n       \\<Longrightarrow> x \\<le> k - iMin I", "apply (simp add: iT_Minus_mem_iff iMinI_ex2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> finite (k \\<ominus> I)\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n        x \\<in> k \\<ominus> I\\<rbrakk>\n       \\<Longrightarrow> x \\<le> k - iMin I", "apply (simp add: iT_Minus_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n        x \\<in> k \\<ominus> I\\<rbrakk>\n       \\<Longrightarrow> x \\<le> k - iMin I", "apply (fastforce simp: iT_Minus_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Min: \"\n  \\<lbrakk> I \\<noteq> {}; iMin I \\<le> k \\<rbrakk> \\<Longrightarrow> iMin (k \\<ominus> I) = k - (Max (I \\<down>\\<le> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> iMin (k \\<ominus> I) = k - Max (I \\<down>\\<le> k)", "apply (insert nat_cut_le_finite[of I k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k;\n     finite (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> iMin (k \\<ominus> I) = k - Max (I \\<down>\\<le> k)", "apply (frule cut_le_Min_not_empty[of _ k], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iMin (k \\<ominus> I) = k - Max (I \\<down>\\<le> k)", "apply (rule iMin_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k - Max (I \\<down>\\<le> k) \\<in> k \\<ominus> I\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n        I \\<down>\\<le> k \\<noteq> {}; x \\<in> k \\<ominus> I\\<rbrakk>\n       \\<Longrightarrow> k - Max (I \\<down>\\<le> k) \\<le> x", "apply (simp add: iT_Minus_mem_iff nat_cut_le_Max_le del: Max_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (I \\<down>\\<le> k) \\<in> I\n 2. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n        I \\<down>\\<le> k \\<noteq> {}; x \\<in> k \\<ominus> I\\<rbrakk>\n       \\<Longrightarrow> k - Max (I \\<down>\\<le> k) \\<le> x", "apply (simp add: subsetD[OF cut_le_subset, OF Max_in])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n        I \\<down>\\<le> k \\<noteq> {}; x \\<in> k \\<ominus> I\\<rbrakk>\n       \\<Longrightarrow> k - Max (I \\<down>\\<le> k) \\<le> x", "apply (clarsimp simp add: iT_Minus_image_conv image_iff, rename_tac x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n        I \\<down>\\<le> k \\<noteq> {}; x' \\<in> I; x' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> k - Max (I \\<down>\\<le> k) \\<le> k - x'", "apply (rule diff_le_mono2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>I \\<noteq> {}; iMin I \\<le> k; finite (I \\<down>\\<le> k);\n        I \\<down>\\<le> k \\<noteq> {}; x' \\<in> I; x' \\<le> k\\<rbrakk>\n       \\<Longrightarrow> x' \\<le> Max (I \\<down>\\<le> k)", "apply (simp add: Max_ge_iff cut_le_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Minus_eq: \"\\<lbrakk> finite I; Max I \\<le> k \\<rbrakk> \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; Max I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I", "apply (simp add: iT_Minus_cut_eq[of k k I, symmetric] iT_Minus_Minus_cut_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; Max I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<le> k = I", "apply (simp add: cut_le_Max_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Minus_eq2: \"I \\<subseteq> [\\<dots>k] \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> [\\<dots>k] \\<Longrightarrow>\n    k \\<ominus> (k \\<ominus> I) = I", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I = {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I\n 2. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I", "apply (simp add: iT_Minus_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (k \\<ominus> I) = I", "apply (rule iT_Minus_Minus_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite I\n 2. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max I \\<le> k", "apply (simp add: finite_subset iTILL_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max I \\<le> k", "apply (frule Max_subset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<subseteq> ?B4\n 2. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite ?B4\n 3. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {};\n     Max I \\<le> Max ?B4\\<rbrakk>\n    \\<Longrightarrow> Max I \\<le> k", "apply (simp add: iTILL_finite iTILL_Max)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* An example:\n  10 \\<ominus> (100 \\<ominus> {97,98,99,101,102}) = {7,8,9}\n  1000 \\<ominus> (100 \\<ominus> {97,98,99,101,102, 998,1002}) = {997,998,999}\n*)"], ["", "lemma iT_Minus_Minus: \"a \\<ominus> (b \\<ominus> I) = (I \\<down>\\<le> b) \\<oplus> a \\<oplus>- b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<ominus> (b \\<ominus> I) = I \\<down>\\<le> b \\<oplus> a \\<oplus>- b", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<ominus> (b \\<ominus> I)) =\n       (x \\<in> I \\<down>\\<le> b \\<oplus> a \\<oplus>- b)", "apply (simp add: iT_Minus_image_conv iT_Plus_image_conv iT_Plus_neg_image_conv image_iff Bex_def i_cut_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> x \\<le> b \\<and> xa = b - x) \\<and>\n           xa \\<le> a \\<and> x = a - xa) =\n       (\\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> x \\<le> b \\<and> xa = x + a) \\<and>\n           b \\<le> xa \\<and> x = xa - b)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Plus_empty: \"k < n \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = {}", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < n; I = {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = {}\n 2. \\<lbrakk>k < n; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = {}", "apply (simp add: iT_Plus_empty iT_Minus_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < n; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = {}", "apply (simp add: iT_Minus_empty_iff iT_Plus_empty_iff iT_Plus_Min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Plus_commute: \"n \\<le> k \\<Longrightarrow> k \\<ominus> (I \\<oplus> n) = (k - n) \\<ominus> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> k \\<Longrightarrow>\n    k \\<ominus> (I \\<oplus> n) = k - n \\<ominus> I", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> k \\<Longrightarrow>\n       (x \\<in> k \\<ominus> (I \\<oplus> n)) = (x \\<in> k - n \\<ominus> I)", "apply (simp add: iT_Minus_image_conv iT_Plus_image_conv image_iff Bex_def i_cut_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> k \\<Longrightarrow>\n       (\\<exists>xa.\n           (\\<exists>x. x \\<in> I \\<and> xa = x + n) \\<and>\n           xa \\<le> k \\<and> x = k - xa) =\n       (\\<exists>xa.\n           xa \\<in> I \\<and> xa \\<le> k - n \\<and> x = k - (n + xa))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Plus_cut_assoc: \"(k \\<ominus> I) \\<oplus> n = (k + n) \\<ominus> (I \\<down>\\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> I \\<oplus> n = k + n \\<ominus> I \\<down>\\<le> k", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> k \\<ominus> I \\<oplus> n) =\n       (x \\<in> k + n \\<ominus> I \\<down>\\<le> k)", "apply (simp add: iT_Plus_mem_iff iT_Minus_mem_iff cut_le_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (n \\<le> x \\<and> x - n \\<le> k \\<and> k - (x - n) \\<in> I) =\n       (x \\<le> k + n \\<and> k + n - x \\<in> I \\<and> k + n - x \\<le> k)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Plus_assoc: \"\n  \\<lbrakk> finite I; Max I \\<le> k \\<rbrakk> \\<Longrightarrow> (k \\<ominus> I) \\<oplus> n = (k + n) \\<ominus> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; Max I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I \\<oplus> n = k + n \\<ominus> I", "by (insert iT_Minus_Plus_cut_assoc[of k I n], simp add: cut_le_Max_all)"], ["", "lemma iT_Minus_Plus_assoc2: \"\n  I \\<subseteq> [\\<dots>k] \\<Longrightarrow> (k \\<ominus> I) \\<oplus> n = (k + n) \\<ominus> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> [\\<dots>k] \\<Longrightarrow>\n    k \\<ominus> I \\<oplus> n = k + n \\<ominus> I", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I = {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I \\<oplus> n = k + n \\<ominus> I\n 2. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I \\<oplus> n = k + n \\<ominus> I", "apply (simp add: iT_Minus_empty iT_Plus_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I \\<oplus> n = k + n \\<ominus> I", "apply (rule iT_Minus_Plus_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite I\n 2. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max I \\<le> k", "apply (simp add: finite_subset iTILL_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max I \\<le> k", "apply (frule Max_subset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<subseteq> ?B4\n 2. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite ?B4\n 3. \\<lbrakk>I \\<subseteq> [\\<dots>k]; I \\<noteq> {};\n     Max I \\<le> Max ?B4\\<rbrakk>\n    \\<Longrightarrow> Max I \\<le> k", "apply (simp add: iTILL_finite iTILL_Max)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_Un: \"k \\<ominus> (A \\<union> B) = (k \\<ominus> A) \\<union> (k \\<ominus> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> A \\<union> B = (k \\<ominus> A) \\<union> (k \\<ominus> B)", "by (fastforce simp: iT_Minus_def)"], ["", "lemma iT_Minus_Int: \"k \\<ominus> (A \\<inter> B) = (k \\<ominus> A) \\<inter> (k \\<ominus> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> A \\<inter> B = (k \\<ominus> A) \\<inter> (k \\<ominus> B)", "by (fastforce simp: set_eq_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_singleton: \"k \\<ominus> {a} = (if a \\<le> k then {k - a} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> {a} = (if a \\<le> k then {k - a} else {})", "by (simp add: iT_Minus_image_conv cut_le_singleton)"], ["", "corollary iT_Minus_singleton1: \"a \\<le> k \\<Longrightarrow> k \\<ominus> {a} = {k-a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> k \\<Longrightarrow> k \\<ominus> {a} = {k - a}", "by (simp add: iT_Minus_singleton)"], ["", "corollary iT_Minus_singleton2: \"k < a \\<Longrightarrow> k \\<ominus> {a} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < a \\<Longrightarrow> k \\<ominus> {a} = {}", "by (simp add: iT_Minus_singleton)"], ["", "lemma iMOD_sub: \"\n  k \\<ominus> [r, mod m] =\n  (if r \\<le> k then [(k - r) mod m, mod m, (k - r) div m] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> [ r, mod m ] =\n    (if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> k \\<ominus> [ r, mod m ]) =\n       (x \\<in> (if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ]\n                 else {}))", "apply (simp add: iT_Minus_mem_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (r \\<le> k \\<longrightarrow>\n        (x \\<le> k \\<and> (k - x) mod m = r mod m \\<and> r \\<le> k - x) =\n        (x mod m = (k - r) mod m \\<and>\n         (k - r) mod m \\<le> x \\<and> x \\<le> k - r)) \\<and>\n       (\\<not> r \\<le> k \\<longrightarrow>\n        (k - x) mod m = r mod m \\<longrightarrow>\n        x \\<le> k \\<longrightarrow> \\<not> r \\<le> k - x)", "apply (fastforce simp add: mod_sub_eq_mod_swap[of r, symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_sub1: \"\n  r \\<le> k \\<Longrightarrow> k \\<ominus> [r, mod m] = [(k - r) mod m, mod m, (k - r) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<le> k \\<Longrightarrow>\n    k \\<ominus> [ r, mod m ] = [ (k - r) mod m, mod m, (k - r) div m ]", "by (simp add: iMOD_sub)"], ["", "corollary iMOD_sub2: \"k < r \\<Longrightarrow> k \\<ominus> [r, mod m] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < r \\<Longrightarrow> k \\<ominus> [ r, mod m ] = {}", "apply (rule iT_Minus_less_Min_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < r \\<Longrightarrow> k < iMin [ r, mod m ]", "apply (simp add: iMOD_Min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iTILL_sub: \"k \\<ominus> [\\<dots>n] = (if n \\<le> k then [k - n\\<dots>,n] else [\\<dots>k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> [\\<dots>n] =\n    (if n \\<le> k then [k - n\\<dots>,n] else [\\<dots>k])", "by (force simp add: set_eq_iff iT_Minus_mem_iff iT_iff)"], ["", "corollary iTILL_sub1: \"n \\<le> k \\<Longrightarrow> k \\<ominus> [\\<dots>n] = [k - n\\<dots>,n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> k \\<Longrightarrow> k \\<ominus> [\\<dots>n] = [k - n\\<dots>,n]", "by (simp add: iTILL_sub)"], ["", "corollary iTILL_sub2: \"k \\<le> n \\<Longrightarrow> k \\<ominus> [\\<dots>n] = [\\<dots>k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow> k \\<ominus> [\\<dots>n] = [\\<dots>k]", "by (simp add: iTILL_sub iIN_0_iTILL_conv)"], ["", "(* An example: 30 \\<ominus> [2, mod 10] = {8,18,28} *)"], ["", "lemma iMODb_sub: \"\n  k \\<ominus> [r, mod m, c] = (\n    if r + m * c \\<le> k then [ k - r - m * c, mod m, c] else\n      if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> [ r, mod m, c ] =\n    (if r + m * c \\<le> k then [ k - r - m * c, mod m, c ]\n     else if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    k \\<ominus> [ r, mod m, c ] =\n    (if r + m * c \\<le> k then [ k - r - m * c, mod m, c ]\n     else if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    k \\<ominus> [ r, mod m, c ] =\n    (if r + m * c \\<le> k then [ k - r - m * c, mod m, c ]\n     else if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})", "apply (simp add: iMODb_mod_0 iIN_0 iT_Minus_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    k \\<ominus> [ r, mod m, c ] =\n    (if r + m * c \\<le> k then [ k - r - m * c, mod m, c ]\n     else if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})", "apply (subst iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    k \\<ominus> [ r, mod m ] \\<inter> [\\<dots>r + m * c] =\n    (if r + m * c \\<le> k then [ k - r - m * c, mod m, c ]\n     else if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})", "apply (subst iT_Minus_Int)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (k \\<ominus> [ r, mod m ]) \\<inter> (k \\<ominus> [\\<dots>r + m * c]) =\n    (if r + m * c \\<le> k then [ k - r - m * c, mod m, c ]\n     else if r \\<le> k then [ (k - r) mod m, mod m, (k - r) div m ] else {})", "apply (simp add: iMOD_sub iTILL_sub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    r \\<le> k \\<longrightarrow>\n    (r + m * c \\<le> k \\<longrightarrow>\n     [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n     [k - (r + m * c)\\<dots>,r + m * c] =\n     [ k - (r + m * c), mod m, c ]) \\<and>\n    (\\<not> r + m * c \\<le> k \\<longrightarrow>\n     [ (k - r) mod m, mod m, (k - r) div m ] \\<inter> [\\<dots>k] =\n     [ (k - r) mod m, mod m, (k - r) div m ])", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r \\<le> k; r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (subgoal_tac \"(k - r) mod m \\<le> k - (r + m * c)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 3. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 3. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (subgoal_tac \"m * c \\<le> k - r - (k - r) mod m\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     m * c \\<le> k - r - (k - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> m * c \\<le> k - r - (k - r) mod m\n 3. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 4. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> m * c \\<le> k - r - (k - r) mod m\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     m * c \\<le> k - r - (k - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 3. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 4. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (drule add_le_imp_le_diff2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < m; m * c \\<le> k - r\\<rbrakk>\n    \\<Longrightarrow> m * c \\<le> k - r - (k - r) mod m\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     m * c \\<le> k - r - (k - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 3. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 4. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (drule div_le_mono[of _ _ m], simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < m; c \\<le> (k - r) div m\\<rbrakk>\n    \\<Longrightarrow> m * c \\<le> k - (r + (k - r) mod m)\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     m * c \\<le> k - r - (k - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 3. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 4. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (drule mult_le_mono2[of _ _ m])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < m; m * c \\<le> m * ((k - r) div m)\\<rbrakk>\n    \\<Longrightarrow> m * c \\<le> k - (r + (k - r) mod m)\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     m * c \\<le> k - r - (k - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 3. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 4. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (simp add: minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     m * c \\<le> k - r - (k - r) mod m\\<rbrakk>\n    \\<Longrightarrow> (k - r) mod m \\<le> k - (r + m * c)\n 2. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 3. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (simp add: le_diff_conv2[OF mod_le_dividend] del: diff_diff_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (subst iMODb_iMOD_iIN_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m ] \\<inter>\n                      [(k - r) mod m\\<dots>,m * ((k - r) div m)] \\<inter>\n                      [k - (r + m * c)\\<dots>,r + m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (simp add: Int_assoc minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m ] \\<inter>\n                      ([(k - r) mod\n                        m\\<dots>,k - (r + (k - r) mod m)] \\<inter>\n                       [k - (r + m * c)\\<dots>,r + m * c]) =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (subst iIN_inter, simp+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; r + m * c \\<le> k;\n     (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m ] \\<inter>\n                      [k - (r + m * c)\\<dots>,m * c] =\n                      [ k - (r + m * c), mod m, c ]\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (rule set_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; r + m * c \\<le> k;\n        (k - r) mod m \\<le> k - (r + m * c)\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> [ (k - r) mod m, mod m ] \\<inter>\n                                  [k - (r + m * c)\\<dots>,m * c]) =\n                         (x \\<in> [ k - (r + m * c), mod m, c ])\n 2. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (fastforce simp add: iT_iff mod_diff_mult_self2 diff_diff_left[symmetric] simp del: diff_diff_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; r \\<le> k; \\<not> r + m * c \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ (k - r) mod m, mod m, (k - r) div m ] \\<inter>\n                      [\\<dots>k] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "apply (simp add: Int_absorb2 iMODb_iTILL_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMODb_sub1: \"\n  \\<lbrakk> r \\<le> k; k \\<le> r + m * c \\<rbrakk> \\<Longrightarrow>\n  k \\<ominus> [r, mod m, c] = [(k - r) mod m, mod m, (k - r) div m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<le> k; k \\<le> r + m * c\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> [ r, mod m, c ] =\n                      [ (k - r) mod m, mod m, (k - r) div m ]", "by (clarsimp simp: iMODb_sub iMODb_mod_0)"], ["", "corollary iMODb_sub2: \"k < r \\<Longrightarrow> k \\<ominus> [r, mod m, c] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < r \\<Longrightarrow> k \\<ominus> [ r, mod m, c ] = {}", "apply (rule iT_Minus_less_Min_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < r \\<Longrightarrow> k < iMin [ r, mod m, c ]", "apply (simp add: iMODb_Min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMODb_sub3: \"\n  r + m * c \\<le> k \\<Longrightarrow> k \\<ominus> [r, mod m, c] = [ k - r - m * c, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r + m * c \\<le> k \\<Longrightarrow>\n    k \\<ominus> [ r, mod m, c ] = [ k - r - m * c, mod m, c ]", "by (simp add: iMODb_sub)"], ["", "lemma iFROM_sub: \"k \\<ominus> [n\\<dots>] = (if n \\<le> k then [\\<dots>k - n] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> [n\\<dots>] = (if n \\<le> k then [\\<dots>k - n] else {})", "by (simp add: iMOD_1[symmetric] iMOD_sub iMODb_mod_1 iIN_0_iTILL_conv)"], ["", "corollary iFROM_sub1: \"n \\<le> k \\<Longrightarrow> k \\<ominus> [n\\<dots>] = [\\<dots>k-n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> k \\<Longrightarrow> k \\<ominus> [n\\<dots>] = [\\<dots>k - n]", "by (simp add: iFROM_sub)"], ["", "corollary iFROM_sub_empty: \"k < n \\<Longrightarrow> k \\<ominus> [n\\<dots>] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> k \\<ominus> [n\\<dots>] = {}", "by (simp add: iFROM_sub)"], ["", "(* Examples:\n  10 \\<ominus> [2\\<dots>,3] = {3,4,5,6,7,8}\n  10 \\<ominus> [7\\<dots>,5] = {0,1,2,3}\n*)"], ["", "lemma iIN_sub: \"\n  k \\<ominus> [n\\<dots>,d] = (\n  if n + d \\<le> k then [k - (n + d)\\<dots>,d]\n  else if n \\<le> k then [\\<dots>k - n] else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> [n\\<dots>,d] =\n    (if n + d \\<le> k then [k - (n + d)\\<dots>,d]\n     else if n \\<le> k then [\\<dots>k - n] else {})", "apply (simp add: iMODb_mod_1[symmetric] iMODb_sub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> k \\<longrightarrow>\n    \\<not> n + d \\<le> k \\<longrightarrow>\n    [ 0, mod Suc 0, k - n ] = [\\<dots>k - n]", "apply (simp add: iMODb_mod_1 iIN_0_iTILL_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_sub1: \"n + d \\<le> k \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = [k - (n + d)\\<dots>,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + d \\<le> k \\<Longrightarrow>\n    k \\<ominus> [n\\<dots>,d] = [k - (n + d)\\<dots>,d]", "by (simp add: iIN_sub)"], ["", "lemma iIN_sub2: \"\\<lbrakk> n \\<le> k; k \\<le> n + d \\<rbrakk> \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = [\\<dots>k - n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> k; k \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = [\\<dots>k - n]", "by (clarsimp simp: iIN_sub iIN_0_iTILL_conv)"], ["", "lemma iIN_sub3: \"k < n \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> k \\<ominus> [n\\<dots>,d] = {}", "by (simp add: iIN_sub)"], ["", "lemmas iT_sub =\n  iFROM_sub\n  iIN_sub\n  iTILL_sub\n  iMOD_sub\n  iMODb_sub\n  iT_Minus_singleton"], ["", "subsubsection \\<open>Division of intervals by constants\\<close>"], ["", "text \\<open>Monotonicity and injectivity of artithmetic operators\\<close>"], ["", "lemma iMOD_div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < k; k \\<le> m \\<rbrakk> \\<Longrightarrow> strict_mono_on (\\<lambda>x. x div k) [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>x. x div k)\n                       [ r, mod m ]", "apply (rule div_right_strict_mono_on, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>[ r, mod m ].\n                         \\<forall>y\\<in>[ r, mod m ].\n                            x < y \\<longrightarrow> x + k \\<le> y", "apply (clarsimp simp: iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < k; k \\<le> m; y mod m = r mod m; x < y;\n        x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x + k \\<le> y", "apply (drule_tac s=\"y mod m\" in sym, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < k; k \\<le> m; x < y; x mod m = y mod m; r \\<le> x;\n        r mod m = y mod m\\<rbrakk>\n       \\<Longrightarrow> x + k \\<le> y", "apply (rule_tac y=\"x + m\" in order_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < k; k \\<le> m; x < y; x mod m = y mod m; r \\<le> x;\n        r mod m = y mod m\\<rbrakk>\n       \\<Longrightarrow> x + m \\<le> y", "apply (simp add: less_mod_eq_imp_add_divisor_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_div_right_inj_on: \"\n  \\<lbrakk> 0 < k; k \\<le> m \\<rbrakk> \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [ r, mod m ]", "by (rule strict_mono_on_imp_inj_on[OF iMOD_div_right_strict_mono_on])"], ["", "lemma iMOD_mult_div_right_inj_on: \"\n  inj_on (\\<lambda>x. x div (k::nat)) [r, mod (k * m)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x div k) [ r, mod k * m ]", "apply (case_tac \"k * m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k * m = 0 \\<Longrightarrow>\n    inj_on (\\<lambda>x. x div k) [ r, mod k * m ]\n 2. k * m \\<noteq> 0 \\<Longrightarrow>\n    inj_on (\\<lambda>x. x div k) [ r, mod k * m ]", "apply (simp del: mult_is_0 mult_eq_0_iff add: iMOD_0 iIN_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k * m \\<noteq> 0 \\<Longrightarrow>\n    inj_on (\\<lambda>x. x div k) [ r, mod k * m ]", "apply (simp add: iMOD_div_right_inj_on)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_mult_div_right_inj_on2: \"\n  m mod k = 0 \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod k = 0 \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [ r, mod m ]", "by (auto simp add: iMOD_mult_div_right_inj_on)"], ["", "lemma iMODb_div_right_strict_mono_on: \"\n  \\<lbrakk> 0 < k; k \\<le> m \\<rbrakk> \\<Longrightarrow> strict_mono_on (\\<lambda>x. x div k) [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>x. x div k)\n                       [ r, mod m, c ]", "by (rule strict_mono_on_subset[OF iMOD_div_right_strict_mono_on iMODb_iMOD_subset_same])"], ["", "corollary iMODb_div_right_inj_on: \"\n  \\<lbrakk> 0 < k; k \\<le> m \\<rbrakk> \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [ r, mod m, c ]", "by (rule strict_mono_on_imp_inj_on[OF iMODb_div_right_strict_mono_on])"], ["", "lemma iMODb_mult_div_right_inj_on: \"\n  inj_on (\\<lambda>x. x div (k::nat)) [r, mod (k * m), c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x div k) [ r, mod k * m, c ]", "by (rule subset_inj_on[OF iMOD_mult_div_right_inj_on iMODb_iMOD_subset_same])"], ["", "corollary iMODb_mult_div_right_inj_on2: \"\n  m mod k = 0 \\<Longrightarrow> inj_on (\\<lambda>x. x div k) [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod k = 0 \\<Longrightarrow>\n    inj_on (\\<lambda>x. x div k) [ r, mod m, c ]", "by (auto simp add: iMODb_mult_div_right_inj_on)"], ["", "definition iT_Div :: \"iT \\<Rightarrow> Time \\<Rightarrow> iT\" (infixl \"\\<oslash>\" 55)\n  where \"I \\<oslash> k \\<equiv> (\\<lambda>n.(n div k)) ` I\""], ["", "lemma iT_Div_image_conv: \"I \\<oslash> k = (\\<lambda>n.(n div k)) ` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oslash> k = (\\<lambda>n. n div k) ` I", "by (simp add: iT_Div_def)"], ["", "lemma iT_Div_mono: \"A \\<subseteq> B \\<Longrightarrow> A \\<oslash> k \\<subseteq> B \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    A \\<oslash> k \\<subseteq> B \\<oslash> k", "by (simp add: iT_Div_def image_mono)"], ["", "lemma iT_Div_empty: \"{} \\<oslash> k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<oslash> k = {}", "by (simp add: iT_Div_def)"], ["", "lemma iT_Div_not_empty: \"I \\<noteq> {} \\<Longrightarrow> I \\<oslash> k \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> I \\<oslash> k \\<noteq> {}", "by (simp add: iT_Div_def)"], ["", "lemma iT_Div_empty_iff: \"(I \\<oslash> k = {}) = (I = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oslash> k = {}) = (I = {})", "by (simp add: iT_Div_def)"], ["", "lemma iT_Div_0: \"I \\<noteq> {} \\<Longrightarrow> I \\<oslash> 0 = [\\<dots>0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> I \\<oslash> 0 = [\\<dots>0]", "by (force simp: iT_Div_def)"], ["", "corollary iT_Div_0_if: \"I \\<oslash> 0 = (if I = {} then {} else [\\<dots>0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oslash> 0 = (if I = {} then {} else [\\<dots>0])", "by (force simp: iT_Div_def)"], ["", "corollary\n  iFROM_div_0: \"[n\\<dots>] \\<oslash> 0 = [\\<dots>0]\" and\n  iTILL_div_0: \"[\\<dots>n] \\<oslash> 0 = [\\<dots>0]\" and\n  iIN_div_0: \"[n\\<dots>,d] \\<oslash> 0 = [\\<dots>0]\" and\n  iMOD_div_0: \"[r, mod m] \\<oslash> 0 = [\\<dots>0]\" and\n  iMODb_div_0: \"[r, mod m, c] \\<oslash> 0 = [\\<dots>0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>] \\<oslash> 0 = [\\<dots>0] &&&\n     [\\<dots>n] \\<oslash> 0 = [\\<dots>0]) &&&\n    [n\\<dots>,d] \\<oslash> 0 = [\\<dots>0] &&&\n    [ r, mod m ] \\<oslash> 0 = [\\<dots>0] &&&\n    [ r, mod m, c ] \\<oslash> 0 = [\\<dots>0]", "by (simp add: iT_Div_0 iT_not_empty)+"], ["", "lemmas iT_div_0 =\n  iTILL_div_0\n  iFROM_div_0\n  iIN_div_0\n  iMOD_div_0\n  iMODb_div_0"], ["", "lemma iT_Div_1: \"I \\<oslash> Suc 0 = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oslash> Suc 0 = I", "by (simp add: iT_Div_def)"], ["", "lemma iT_Div_mem_iff_0: \"x \\<in> (I \\<oslash> 0) = (I \\<noteq> {} \\<and> x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> I \\<oslash> 0) = (I \\<noteq> {} \\<and> x = 0)", "by (force simp: iT_Div_0_if)"], ["", "lemma iT_Div_mem_iff: \"\n  0 < k \\<Longrightarrow> x \\<in> (I \\<oslash> k) = (\\<exists>y \\<in> I. y div k = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (x \\<in> I \\<oslash> k) = (\\<exists>y\\<in>I. y div k = x)", "by (force simp: iT_Div_def)"], ["", "lemma iT_Div_mem_iff2: \"\n  0 < k \\<Longrightarrow> x div k \\<in> (I \\<oslash> k) = (\\<exists>y \\<in> I. y div k = x div k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (x div k \\<in> I \\<oslash> k) = (\\<exists>y\\<in>I. y div k = x div k)", "by (rule iT_Div_mem_iff)"], ["", "lemma iT_Div_mem_iff_Int: \"\n  0 < k \\<Longrightarrow> x \\<in> (I \\<oslash> k) = (I \\<inter> [x * k\\<dots>,k - Suc 0] \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (x \\<in> I \\<oslash> k) =\n    (I \\<inter> [x * k\\<dots>,k - Suc 0] \\<noteq> {})", "apply (simp add: ex_in_conv[symmetric] iT_Div_mem_iff iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (\\<exists>y\\<in>I. y div k = x) =\n    (\\<exists>xa.\n        xa \\<in> I \\<and> x * k \\<le> xa \\<and> xa \\<le> x * k + k - Suc 0)", "apply (simp add: le_less_div_conv[symmetric] add.commute[of k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (\\<exists>y\\<in>I. x * k \\<le> y \\<and> y < x * k + k) =\n    (\\<exists>xa.\n        xa \\<in> I \\<and> x * k \\<le> xa \\<and> xa \\<le> x * k + k - Suc 0)", "apply (subst less_eq_le_pred, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (\\<exists>y\\<in>I. x * k \\<le> y \\<and> y \\<le> x * k + k - Suc 0) =\n    (\\<exists>xa.\n        xa \\<in> I \\<and> x * k \\<le> xa \\<and> xa \\<le> x * k + k - Suc 0)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_imp_mem: \"\n  0 < k \\<Longrightarrow> x \\<in> I \\<Longrightarrow> x div k \\<in> (I \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; x \\<in> I\\<rbrakk>\n    \\<Longrightarrow> x div k \\<in> I \\<oslash> k", "by (force simp: iT_Div_mem_iff2)"], ["", "lemma iT_Div_singleton: \"{a} \\<oslash> k = {a div k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<oslash> k = {a div k}", "by (simp add: iT_Div_def)"], ["", "lemma iT_Div_Un: \"(A \\<union> B) \\<oslash> k = (A \\<oslash> k) \\<union> (B \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B \\<oslash> k = (A \\<oslash> k) \\<union> (B \\<oslash> k)", "by (fastforce simp: iT_Div_def)"], ["", "lemma iT_Div_insert: \"(insert n I) \\<oslash> k = insert (n div k) (I \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert n I \\<oslash> k = insert (n div k) (I \\<oslash> k)", "by (fastforce simp: iT_Div_def)"], ["", "(* Examples:\n  {1,2,3,4} \\<oslash> 3 \\<inter> {5,6,7} \\<oslash> 3 = {0,1} \\<inter> {1,2} = {1}\n  ({1,2,3,4} \\<inter> {5,6,7}) \\<oslash> 3 = {} \\<oslash> 3 = {}\n*)"], ["", "lemma not_iT_Div_Int: \"\\<not> (\\<forall> k A B. (A \\<inter> B) \\<oslash> k = (A \\<oslash> k) \\<inter> (B \\<oslash> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k A B.\n               A \\<inter> B \\<oslash> k =\n               (A \\<oslash> k) \\<inter> (B \\<oslash> k))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k A B.\n       A \\<inter> B \\<oslash> k \\<noteq>\n       (A \\<oslash> k) \\<inter> (B \\<oslash> k)", "apply (\n  rule_tac x=3 in exI,\n  rule_tac x=\"{0}\" in exI,\n  rule_tac x=\"{1}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0} \\<inter> {1} \\<oslash> 3 \\<noteq>\n    ({0} \\<oslash> 3) \\<inter> ({1} \\<oslash> 3)", "by (simp add: iT_Div_def)"], ["", "lemma subset_iT_Div_Int: \"A \\<subseteq> B \\<Longrightarrow> (A \\<inter> B) \\<oslash> k = (A \\<oslash> k) \\<inter> (B \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    A \\<inter> B \\<oslash> k = (A \\<oslash> k) \\<inter> (B \\<oslash> k)", "by (simp add: iT_Div_def subset_image_Int)"], ["", "lemma iFROM_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; n \\<le> iMin A \\<rbrakk> \\<Longrightarrow> (A \\<inter> [n\\<dots>]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n \\<le> iMin A\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n\\<dots>] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter> ([n\\<dots>] \\<oslash> k)", "apply (rule subset_iT_Div_Int)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n \\<le> iMin A\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> [n\\<dots>]", "apply (blast intro: order_trans iMin_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; n \\<le> iMin A; \\<forall>x\\<in>A. x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n\\<dots>,d]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>,d] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n \\<le> iMin A;\n     \\<forall>x\\<in>A.\n        x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n\\<dots>,d] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter> ([n\\<dots>,d] \\<oslash> k)", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow>\n           x \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> A \\<inter> [n\\<dots>,d] \\<oslash> k) =\n                         (x \\<in> (A \\<oslash> k) \\<inter>\n                                  ([n\\<dots>,d] \\<oslash> k))", "apply (simp add: iT_Div_mem_iff Bex_def iIN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow>\n           x \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa \\<in> A \\<and>\n                             n \\<le> xa \\<and>\n                             xa \\<le> n + d \\<and> xa div k = x) =\n                         ((\\<exists>xa.\n                              xa \\<in> A \\<and> xa div k = x) \\<and>\n                          (\\<exists>xa\\<ge>n.\n                              xa \\<le> n + d \\<and> xa div k = x))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        \\<exists>xa.\n           xa \\<in> A \\<and>\n           n \\<le> xa \\<and> xa \\<le> n + d \\<and> xa div k = x\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa \\<in> A \\<and> xa div k = x) \\<and>\n                         (\\<exists>xa\\<ge>n.\n                             xa \\<le> n + d \\<and> xa div k = x)\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        (\\<exists>xa. xa \\<in> A \\<and> xa div k = x) \\<and>\n        (\\<exists>xa\\<ge>n. xa \\<le> n + d \\<and> xa div k = x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> A \\<and>\n                            n \\<le> xa \\<and>\n                            xa \\<le> n + d \\<and> xa div k = x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        (\\<exists>xa. xa \\<in> A \\<and> xa div k = x) \\<and>\n        (\\<exists>xa\\<ge>n. xa \\<le> n + d \\<and> xa div k = x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> A \\<and>\n                            n \\<le> xa \\<and>\n                            xa \\<le> n + d \\<and> xa div k = x", "apply (clarsimp, rename_tac x1 x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; n \\<le> x2; x2 \\<le> n + d; x2 div k = x1 div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> A \\<and>\n                            n \\<le> x \\<and>\n                            x \\<le> n + d \\<and> x div k = x1 div k", "apply (frule iMin_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; n \\<le> x2; x2 \\<le> n + d; x2 div k = x1 div k;\n        iMin A \\<le> x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> A \\<and>\n                            n \\<le> x \\<and>\n                            x \\<le> n + d \\<and> x div k = x1 div k", "apply (rule_tac x=x1 in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; n \\<le> iMin A;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; n \\<le> x2; x2 \\<le> n + d; x2 div k = x1 div k;\n        iMin A \\<le> x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (drule_tac x=x1 in bspec, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; n \\<le> iMin A; x1 \\<in> A; n \\<le> x2;\n        x2 \\<le> n + d; x2 div k = x1 div k; iMin A \\<le> x1;\n        x1 div k \\<le> (n + d) div k \\<longrightarrow>\n        x1 \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (drule div_le_mono[of _ \"n + d\" k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; n \\<le> iMin A; x1 \\<in> A; n \\<le> x2;\n        x2 div k = x1 div k; iMin A \\<le> x1;\n        x1 div k \\<le> (n + d) div k \\<longrightarrow> x1 \\<le> n + d;\n        x2 div k \\<le> (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iTILL_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; \\<forall>x\\<in>A. x div k \\<le> n div k \\<longrightarrow> x \\<le> n \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [\\<dots>n]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([\\<dots>n] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k;\n     \\<forall>x\\<in>A.\n        x div k \\<le> n div k \\<longrightarrow> x \\<le> n\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [\\<dots>n] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter> ([\\<dots>n] \\<oslash> k)", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_iT_Div_Int)"], ["", "lemma iIN_iT_Div_Int_mod_0: \"\n  \\<lbrakk> 0 < k; n mod k = 0; \\<forall>x\\<in>A. x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n\\<dots>,d]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>,d] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n mod k = 0;\n     \\<forall>x\\<in>A.\n        x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n\\<dots>,d] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter> ([n\\<dots>,d] \\<oslash> k)", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow>\n           x \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> A \\<inter> [n\\<dots>,d] \\<oslash> k) =\n                         (x \\<in> (A \\<oslash> k) \\<inter>\n                                  ([n\\<dots>,d] \\<oslash> k))", "apply (simp add: iT_Div_mem_iff Bex_def iIN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow>\n           x \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa \\<in> A \\<and>\n                             n \\<le> xa \\<and>\n                             xa \\<le> n + d \\<and> xa div k = x) =\n                         ((\\<exists>xa.\n                              xa \\<in> A \\<and> xa div k = x) \\<and>\n                          (\\<exists>xa\\<ge>n.\n                              xa \\<le> n + d \\<and> xa div k = x))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        \\<exists>xa.\n           xa \\<in> A \\<and>\n           n \\<le> xa \\<and> xa \\<le> n + d \\<and> xa div k = x\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa \\<in> A \\<and> xa div k = x) \\<and>\n                         (\\<exists>xa\\<ge>n.\n                             xa \\<le> n + d \\<and> xa div k = x)\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        (\\<exists>xa. xa \\<in> A \\<and> xa div k = x) \\<and>\n        (\\<exists>xa\\<ge>n. xa \\<le> n + d \\<and> xa div k = x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> A \\<and>\n                            n \\<le> xa \\<and>\n                            xa \\<le> n + d \\<and> xa div k = x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        (\\<exists>xa. xa \\<in> A \\<and> xa div k = x) \\<and>\n        (\\<exists>xa\\<ge>n. xa \\<le> n + d \\<and> xa div k = x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> A \\<and>\n                            n \\<le> xa \\<and>\n                            xa \\<le> n + d \\<and> xa div k = x", "apply (elim conjE exE, rename_tac x1 x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> A \\<and>\n                            n \\<le> xa \\<and>\n                            xa \\<le> n + d \\<and> xa div k = x", "apply (rule_tac x=x1 in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x1 \\<and> x1 \\<le> n + d", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> x1\n 2. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (rule ccontr, simp add: linorder_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d; x2 div k = x;\n        x1 < n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (drule_tac m=n and n=x2 and k=k in div_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; x2 \\<le> n + d; x2 div k = x; x1 < n;\n        n div k \\<le> x2 div k\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (drule_tac a=x1 and m=k in less_mod_0_imp_div_less)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; x2 \\<le> n + d; x2 div k = x;\n        n div k \\<le> x2 div k\\<rbrakk>\n       \\<Longrightarrow> n mod k = 0\n 2. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; x2 \\<le> n + d; x2 div k = x;\n        n div k \\<le> x2 div k; x1 div k < n div k\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0;\n        \\<forall>x\\<in>A.\n           x div k \\<le> (n + d) div k \\<longrightarrow> x \\<le> n + d;\n        x1 \\<in> A; x1 div k = x; n \\<le> x2; x2 \\<le> n + d;\n        x2 div k = x\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (drule_tac x=x1 in bspec, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0; x1 \\<in> A; x1 div k = x; n \\<le> x2;\n        x2 \\<le> n + d; x2 div k = x;\n        x1 div k \\<le> (n + d) div k \\<longrightarrow>\n        x1 \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply (drule div_le_mono[of _ \"n + d\" k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>0 < k; n mod k = 0; x1 \\<in> A; x1 div k = x; n \\<le> x2;\n        x2 div k = x;\n        x1 div k \\<le> (n + d) div k \\<longrightarrow> x1 \\<le> n + d;\n        x2 div k \\<le> (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> n + d", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_partition_iT_Div_Int: \"\n  \\<lbrakk> 0 < k; 0 < d \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n * k\\<dots>,d * k - Suc 0]) \\<oslash> k =\n  (A \\<oslash> k) \\<inter> ([n * k\\<dots>,d * k - Suc 0] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n * k\\<dots>,d * k - Suc 0] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter>\n                      ([n * k\\<dots>,d * k - Suc 0] \\<oslash> k)", "apply (rule iIN_iT_Div_Int_mod_0, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>A.\n                         x div k\n                         \\<le> (n * k + d * k - Suc 0) div\n                               k \\<longrightarrow>\n                         x \\<le> n * k + d * k - Suc 0", "apply (clarify, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < d; x \\<in> A;\n        x div k \\<le> (n * k + d * k - Suc 0) div k\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n * k + d * k - Suc 0", "apply (simp add: mod_0_imp_sub_1_div_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < d; x \\<in> A;\n        x div k \\<le> n + d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n * k + d * k - Suc 0", "apply (rule ccontr, simp add: linorder_not_le pred_less_eq_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < d; x \\<in> A; x div k \\<le> n + d - Suc 0;\n        n * k + d * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac n=x and k=k in div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < d; x \\<in> A; x div k \\<le> n + d - Suc 0;\n        (n * k + d * k) div k \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "lemma \"{0,1,2} \\<otimes> x = {0*x, 1*x, 2*x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0, 1, 2} \\<otimes> x = {0 * x, 1 * x, 2 * x}", "by (simp add: iT_Mult_def)"], ["", "(*>*)"], ["", "corollary mod_partition_iT_Div_Int2: \"\n  \\<lbrakk> 0 < k; 0 < d; n mod k = 0; d mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n\\<dots>,d - Suc 0]) \\<oslash> k =\n  (A \\<oslash> k) \\<inter> ([n\\<dots>,d - Suc 0] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; n mod k = 0; d mod k = 0\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n\\<dots>,d - Suc 0] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter>\n                      ([n\\<dots>,d - Suc 0] \\<oslash> k)", "by (auto simp add: ac_simps mod_partition_iT_Div_Int elim!: dvdE)"], ["", "corollary mod_partition_iT_Div_Int_one_segment: \"\n  0 < k \\<Longrightarrow>\n  (A \\<inter> [n * k\\<dots>,k - Suc 0]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n * k\\<dots>,k - Suc 0] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    A \\<inter> [n * k\\<dots>,k - Suc 0] \\<oslash> k =\n    (A \\<oslash> k) \\<inter> ([n * k\\<dots>,k - Suc 0] \\<oslash> k)", "by (insert mod_partition_iT_Div_Int[where d=1], simp)"], ["", "corollary mod_partition_iT_Div_Int_one_segment2: \"\n  \\<lbrakk> 0 < k; n mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  (A \\<inter> [n\\<dots>,k - Suc 0]) \\<oslash> k = (A \\<oslash> k) \\<inter> ([n\\<dots>,k - Suc 0] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n mod k = 0\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n\\<dots>,k - Suc 0] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter>\n                      ([n\\<dots>,k - Suc 0] \\<oslash> k)", "using mod_partition_iT_Div_Int2[where k=k and d=k and n=n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < k; 0 < k; n mod k = 0; k mod k = 0\\<rbrakk>\n  \\<Longrightarrow> ?A \\<inter> [n\\<dots>,k - Suc 0] \\<oslash> k =\n                    (?A \\<oslash> k) \\<inter>\n                    ([n\\<dots>,k - Suc 0] \\<oslash> k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n mod k = 0\\<rbrakk>\n    \\<Longrightarrow> A \\<inter> [n\\<dots>,k - Suc 0] \\<oslash> k =\n                      (A \\<oslash> k) \\<inter>\n                      ([n\\<dots>,k - Suc 0] \\<oslash> k)", "by (insert mod_partition_iT_Div_Int2[where k=k and d=k and n=n], simp)"], ["", "lemma iT_Div_assoc:\"I \\<oslash> a \\<oslash> b = I \\<oslash> (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oslash> a \\<oslash> b = I \\<oslash> a * b", "by (simp add: iT_Div_def image_image div_mult2_eq)"], ["", "lemma iT_Div_commute: \"I \\<oslash> a \\<oslash> b = I \\<oslash> b \\<oslash> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oslash> a \\<oslash> b = I \\<oslash> b \\<oslash> a", "by (simp add: iT_Div_assoc mult.commute[of a])"], ["", "lemma iT_Mult_Div_self: \"0 < k \\<Longrightarrow> I \\<otimes> k \\<oslash> k = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> I \\<otimes> k \\<oslash> k = I", "by (simp add: iT_Mult_def iT_Div_def image_image)"], ["", "lemma iT_Mult_Div: \"\n  \\<lbrakk> 0 < d;  k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<otimes> k \\<oslash> d = I \\<otimes> (k div d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; k mod d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> k \\<oslash> d = I \\<otimes> k div d", "by (auto simp add: ac_simps iT_Mult_assoc[symmetric] iT_Mult_Div_self)"], ["", "lemma iT_Div_Mult_self: \"\n  0 < k \\<Longrightarrow> I \\<oslash> k \\<otimes> k = {y. \\<exists>x \\<in> I. y = x - x mod k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    I \\<oslash> k \\<otimes> k = {y. \\<exists>x\\<in>I. y = x - x mod k}", "by (simp add: set_eq_iff iT_Mult_def iT_Div_def image_image image_iff div_mult_cancel)"], ["", "lemma iT_Plus_Div_distrib_mod_less: \"\n  \\<forall>x\\<in>I. x mod m + n mod m < m \\<Longrightarrow> I \\<oplus> n \\<oslash> m = I \\<oslash> m \\<oplus> n div m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. x mod m + n mod m < m \\<Longrightarrow>\n    I \\<oplus> n \\<oslash> m = I \\<oslash> m \\<oplus> n div m", "by (simp add: set_eq_iff iT_Div_def iT_Plus_def image_image image_iff div_add1_eq1)"], ["", "corollary iT_Plus_Div_distrib_mod_0: \"\n  n mod m = 0 \\<Longrightarrow> I \\<oplus> n \\<oslash> m = I \\<oslash> m \\<oplus> n div m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod m = 0 \\<Longrightarrow>\n    I \\<oplus> n \\<oslash> m = I \\<oslash> m \\<oplus> n div m", "apply (case_tac \"m = 0\", simp add: iT_Plus_0 iT_Div_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n mod m = 0; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus> n \\<oslash> m =\n                      I \\<oslash> m \\<oplus> n div m", "apply (simp add: iT_Plus_Div_distrib_mod_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_Min: \"I \\<noteq> {} \\<Longrightarrow> iMin (I \\<oslash> k) = iMin I div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow> iMin (I \\<oslash> k) = iMin I div k", "by (simp add: iT_Div_def iMin_mono2 mono_def div_le_mono)"], ["", "corollary\n  iFROM_div_Min: \"iMin ([n\\<dots>] \\<oslash> k) = n div k\" and\n  iIN_div_Min:   \"iMin ([n\\<dots>,d] \\<oslash> k) = n div k\" and\n  iTILL_div_Min: \"iMin ([\\<dots>n] \\<oslash> k) = 0\" and\n  iMOD_div_Min:  \"iMin ([r, mod m] \\<oslash> k) = r div k\" and\n  iMODb_div_Min: \"iMin ([r, mod m, c] \\<oslash> k) = r div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iMin ([n\\<dots>] \\<oslash> k) = n div k &&&\n     iMin ([n\\<dots>,d] \\<oslash> k) = n div k) &&&\n    iMin ([\\<dots>n] \\<oslash> k) = 0 &&&\n    iMin ([ r, mod m ] \\<oslash> k) = r div k &&&\n    iMin ([ r, mod m, c ] \\<oslash> k) = r div k", "by (simp add: iT_not_empty iT_Div_Min iT_Min)+"], ["", "lemmas iT_div_Min =\n  iFROM_div_Min\n  iIN_div_Min\n  iTILL_div_Min\n  iMOD_div_Min\n  iMODb_div_Min"], ["", "lemma iT_Div_Max: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> Max (I \\<oslash> k) = Max I div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (I \\<oslash> k) = Max I div k", "by (simp add: iT_Div_def Max_mono2 mono_def div_le_mono)"], ["", "corollary\n  iIN_div_Max:   \"Max ([n\\<dots>,d] \\<oslash> k) = (n + d) div k\" and\n  iTILL_div_Max: \"Max ([\\<dots>n] \\<oslash> k) = n div k\" and\n  iMODb_div_Max: \"Max ([r, mod m, c] \\<oslash> k) = (r + m * c) div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ([n\\<dots>,d] \\<oslash> k) = (n + d) div k &&&\n    Max ([\\<dots>n] \\<oslash> k) = n div k &&&\n    Max ([ r, mod m, c ] \\<oslash> k) = (r + m * c) div k", "by (simp add: iT_not_empty iT_finite iT_Div_Max iT_Max)+"], ["", "lemma iT_Div_0_finite: \"finite (I \\<oslash> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (I \\<oslash> 0)", "by (simp add: iT_Div_0_if iTILL_0)"], ["", "lemma iT_Div_infinite_iff: \"0 < k \\<Longrightarrow> infinite (I \\<oslash> k) = infinite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> infinite (I \\<oslash> k) = infinite I", "apply (unfold iT_Div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    infinite ((\\<lambda>n. n div k) ` I) = infinite I", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; infinite ((\\<lambda>n. n div k) ` I)\\<rbrakk>\n    \\<Longrightarrow> infinite I\n 2. \\<lbrakk>0 < k; infinite I\\<rbrakk>\n    \\<Longrightarrow> infinite ((\\<lambda>n. n div k) ` I)", "apply (rule infinite_image_imp_infinite, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; infinite I\\<rbrakk>\n    \\<Longrightarrow> infinite ((\\<lambda>n. n div k) ` I)", "apply (clarsimp simp: infinite_nat_iff_unbounded_le image_iff, rename_tac x1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<lbrakk>0 < k; \\<forall>m. \\<exists>n\\<ge>m. n \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n\\<ge>x1. \\<exists>x\\<in>I. n = x div k", "apply (drule_tac x=\"x1 * k\" in spec, clarsimp, rename_tac x2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; x1 * k \\<le> x2; x2 \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n\\<ge>x1. \\<exists>x\\<in>I. n = x div k", "apply (drule div_le_mono[of _ _ k], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; x2 \\<in> I; x1 \\<le> x2 div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n\\<ge>x1. \\<exists>x\\<in>I. n = x div k", "apply (rule_tac x=\"x2 div k\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>0 < k; x2 \\<in> I; x1 \\<le> x2 div k\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> x2 div k \\<and>\n                         (\\<exists>x\\<in>I. x2 div k = x div k)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_finite_iff: \"0 < k \\<Longrightarrow> finite (I \\<oslash> k) = finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> finite (I \\<oslash> k) = finite I", "by (insert iT_Div_infinite_iff, simp)"], ["", "lemma iFROM_div: \"0 < k \\<Longrightarrow> [n\\<dots>] \\<oslash> k = [n div k\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> [n\\<dots>] \\<oslash> k = [n div k\\<dots>]", "apply (clarsimp simp: set_eq_iff iT_Div_def image_iff Bex_def iFROM_iff, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (\\<exists>xa\\<ge>n. x = xa div k) = (n div k \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; \\<exists>xa\\<ge>n. x = xa div k\\<rbrakk>\n       \\<Longrightarrow> n div k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n. x = xa div k", "apply (clarsimp simp: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n. x = xa div k", "apply (rule_tac x=\"n mod k + k * x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n mod k + k * x \\<and>\n                         x = (n mod k + k * x) div k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n mod k + k * x", "apply (subst add.commute, subst le_diff_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> n - n mod k \\<le> k * x", "apply (subst minus_mod_eq_mult_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> k * (n div k) \\<le> k * x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iIN_div: \"\n  0 < k \\<Longrightarrow>\n  [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>, d div k + (n mod k + d mod k) div k ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    [n\\<dots>,d] \\<oslash> k =\n    [n div k\\<dots>,d div k + (n mod k + d mod k) div k]", "apply (clarsimp simp: set_eq_iff iT_Div_def image_iff Bex_def iIN_iff, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (\\<exists>xa\\<ge>n. xa \\<le> n + d \\<and> x = xa div k) =\n       (n div k \\<le> x \\<and>\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k;\n        \\<exists>xa\\<ge>n. xa \\<le> n + d \\<and> x = xa div k\\<rbrakk>\n       \\<Longrightarrow> n div k \\<le> x \\<and>\n                         x \\<le> n div k +\n                                 (d div k + (n mod k + d mod k) div k)\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        n div k \\<le> x \\<and>\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>0 < k; n \\<le> xa; xa \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> n div k \\<le> xa div k \\<and>\n                         xa div k\n                         \\<le> n div k +\n                               (d div k + (n mod k + d mod k) div k)\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        n div k \\<le> x \\<and>\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (drule div_le_mono[of n _ k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>0 < k; xa \\<le> n + d; n div k \\<le> xa div k\\<rbrakk>\n       \\<Longrightarrow> n div k \\<le> xa div k \\<and>\n                         xa div k\n                         \\<le> n div k +\n                               (d div k + (n mod k + d mod k) div k)\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        n div k \\<le> x \\<and>\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (drule div_le_mono[of _ \"n + d\" k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>0 < k; n div k \\<le> xa div k;\n        xa div k \\<le> (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> n div k \\<le> xa div k \\<and>\n                         xa div k\n                         \\<le> n div k +\n                               (d div k + (n mod k + d mod k) div k)\n 2. \\<And>x.\n       \\<lbrakk>0 < k;\n        n div k \\<le> x \\<and>\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: div_add1_eq[of n d])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k;\n        n div k \\<le> x \\<and>\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (clarify, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x;\n        x \\<le> n div k + (d div k + (n mod k + d mod k) div k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: add.assoc[symmetric] div_add1_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; x \\<le> (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (frule mult_le_mono1[of \"n div k\" _ k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; x \\<le> (n + d) div k;\n        n div k * k \\<le> x * k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (frule mult_le_mono1[of _ \"(n + d) div k\" k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; x \\<le> (n + d) div k;\n        n div k * k \\<le> x * k; x * k \\<le> (n + d) div k * k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: mult.commute[of _ k] minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; x \\<le> (n + d) div k;\n        n - n mod k \\<le> k * x; k * x \\<le> n + d - (n + d) mod k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: le_diff_conv le_diff_conv2[OF mod_le_dividend])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; x \\<le> (n + d) div k;\n        n \\<le> k * x + n mod k; k * x + (n + d) mod k \\<le> n + d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (drule order_le_less[of _ \"(n + d) div k\", THEN iffD1], erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x < (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (rule_tac x=\"k * x + n mod k\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x < (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> n \\<le> k * x + n mod k \\<and>\n                         k * x + n mod k \\<le> n + d \\<and>\n                         x = (k * x + n mod k) div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: add.commute[of _ \"n mod k\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; x < (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> n mod k + k * x \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (case_tac \"n mod k \\<le> (n + d) mod k\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; x < (n + d) div k;\n        \\<not> n mod k \\<le> (n + d) mod k\\<rbrakk>\n       \\<Longrightarrow> n mod k + k * x \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: linorder_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; x < (n + d) div k;\n        (n + d) mod k < n mod k\\<rbrakk>\n       \\<Longrightarrow> n mod k + k * x \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (drule_tac m=x in less_imp_le_pred)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        x \\<le> (n + d) div k - Suc 0\\<rbrakk>\n       \\<Longrightarrow> n mod k + k * x \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (drule_tac i=x and k=k in mult_le_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> k * ((n + d) div k - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> n mod k + k * x \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: diff_mult_distrib2 minus_mod_eq_mult_div [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> n mod k + k * x \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (subst add.commute[of \"n mod k\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> k * x + n mod k \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (subst le_diff_conv2[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> n mod k \\<le> n + d\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> k * x \\<le> n + d - n mod k\n 3. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: trans_le_add1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> k * x \\<le> n + d - n mod k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (rule order_trans, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> n + d - ((n + d) mod k + k) \\<le> n + d - n mod k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (rule diff_le_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> n mod k + k * x;\n        k * x + (n + d) mod k \\<le> n + d; (n + d) mod k < n mod k;\n        k * x \\<le> n + d - ((n + d) mod k + k)\\<rbrakk>\n       \\<Longrightarrow> n mod k \\<le> (n + d) mod k + k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (simp add: trans_le_add2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; n div k \\<le> x; n \\<le> k * x + n mod k;\n        k * x + (n + d) mod k \\<le> n + d; x = (n + d) div k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>n.\n                            xa \\<le> n + d \\<and> x = xa div k", "apply (rule_tac x=\"n + d\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iIN_div_if: \"\n  0 < k \\<Longrightarrow> [n\\<dots>,d] \\<oslash> k =\n  [n div k\\<dots>, d div k + (if n mod k + d mod k < k then 0 else Suc 0)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    [n\\<dots>,d] \\<oslash> k =\n    [n div k\\<dots>,d div k + (if n mod k + d mod k < k then 0 else Suc 0)]", "apply (simp add: iIN_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    \\<not> n mod k + d mod k < k \\<longrightarrow>\n    [n div k\\<dots>,d div k + (n mod k + d mod k) div k] =\n    [n div k\\<dots>,Suc (d div k)]", "apply (simp add: iIN_def add.assoc[symmetric] div_add1_eq[symmetric] div_add1_eq2[where a=n])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iIN_div_eq1: \"\n  \\<lbrakk> 0 < k; n mod k + d mod k < k \\<rbrakk> \\<Longrightarrow>\n  [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>,d div k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n mod k + d mod k < k\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>,d div k]", "by (simp add: iIN_div_if)"], ["", "corollary iIN_div_eq2: \"\n  \\<lbrakk> 0 < k; k \\<le> n mod k + d mod k \\<rbrakk> \\<Longrightarrow>\n  [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>, Suc (d div k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> n mod k + d mod k\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<oslash> k =\n                      [n div k\\<dots>,Suc (d div k)]", "by (simp add: iIN_div_if)"], ["", "corollary iIN_div_mod_eq_0: \"\n  \\<lbrakk> 0 < k; n mod k = 0 \\<rbrakk> \\<Longrightarrow> [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>,d div k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; n mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [n\\<dots>,d] \\<oslash> k = [n div k\\<dots>,d div k]", "by (simp add: iIN_div_eq1)"], ["", "lemma iTILL_div: \"\n   0 < k \\<Longrightarrow> [\\<dots>n] \\<oslash> k = [\\<dots>n div k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> [\\<dots>n] \\<oslash> k = [\\<dots>n div k]", "by (simp add: iIN_0_iTILL_conv[symmetric] iIN_div_if)"], ["", "lemma iMOD_div_ge: \"\n  \\<lbrakk> 0 < m; m \\<le> k \\<rbrakk> \\<Longrightarrow> [r, mod m] \\<oslash> k = [r div k\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k = [r div k\\<dots>]", "apply (frule less_le_trans[of _ _ k], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> k; 0 < k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k = [r div k\\<dots>]", "apply (clarsimp simp: set_eq_iff iT_Div_mem_iff Bex_def iT_iff, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa mod m = r mod m \\<and>\n                             r \\<le> xa \\<and> xa div k = x) =\n                         (r div k \\<le> x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k;\n        \\<exists>xa.\n           xa mod m = r mod m \\<and> r \\<le> xa \\<and> xa div k = x\\<rbrakk>\n       \\<Longrightarrow> r div k \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m = r mod m \\<and>\n                            r \\<le> xa \\<and> xa div k = x", "apply (fastforce simp: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa mod m = r mod m \\<and>\n                            r \\<le> xa \\<and> xa div k = x", "apply (rule_tac x=\"\n  if x * k < r then r else\n    ((if x * k mod m \\<le> r mod m then 0 else m) + r mod m + (x * k - x * k mod m))\"\n  in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) mod\n                         m =\n                         r mod m \\<and>\n                         r \\<le> (if x * k < r then r\n                                  else (if x * k mod m \\<le> r mod m then 0\n  else m) +\n r mod m +\n (x * k - x * k mod m)) \\<and>\n                         (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) div\n                         k =\n                         x", "apply (case_tac \"x * k < r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x; x * k < r\\<rbrakk>\n       \\<Longrightarrow> (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) mod\n                         m =\n                         r mod m \\<and>\n                         r \\<le> (if x * k < r then r\n                                  else (if x * k mod m \\<le> r mod m then 0\n  else m) +\n r mod m +\n (x * k - x * k mod m)) \\<and>\n                         (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) div\n                         k =\n                         x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x; \\<not> x * k < r\\<rbrakk>\n       \\<Longrightarrow> (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) mod\n                         m =\n                         r mod m \\<and>\n                         r \\<le> (if x * k < r then r\n                                  else (if x * k mod m \\<le> r mod m then 0\n  else m) +\n r mod m +\n (x * k - x * k mod m)) \\<and>\n                         (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) div\n                         k =\n                         x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x; x * k < r\\<rbrakk>\n       \\<Longrightarrow> r div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x; \\<not> x * k < r\\<rbrakk>\n       \\<Longrightarrow> (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) mod\n                         m =\n                         r mod m \\<and>\n                         r \\<le> (if x * k < r then r\n                                  else (if x * k mod m \\<le> r mod m then 0\n  else m) +\n r mod m +\n (x * k - x * k mod m)) \\<and>\n                         (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) div\n                         k =\n                         x", "apply (drule less_imp_le[of _ r], drule div_le_mono[of _ r k], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x; \\<not> x * k < r\\<rbrakk>\n       \\<Longrightarrow> (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) mod\n                         m =\n                         r mod m \\<and>\n                         r \\<le> (if x * k < r then r\n                                  else (if x * k mod m \\<le> r mod m then 0\n  else m) +\n r mod m +\n (x * k - x * k mod m)) \\<and>\n                         (if x * k < r then r\n                          else (if x * k mod m \\<le> r mod m then 0\n                                else m) +\n                               r mod m +\n                               (x * k - x * k mod m)) div\n                         k =\n                         x", "apply (simp add: linorder_not_less linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r div k \\<le> x; r \\<le> x * k\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          (r mod m + x * k - x * k mod m) mod m =\n                          r mod m \\<and>\n                          r \\<le> r mod m + x * k - x * k mod m \\<and>\n                          (r mod m + x * k - x * k mod m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          (m + r mod m + x * k - x * k mod m) mod m =\n                          r mod m \\<and>\n                          r \\<le> m + r mod m + x * k - x * k mod m \\<and>\n                          (m + r mod m + x * k - x * k mod m) div k = x)", "apply (simp add: div_le_conv add.commute[of k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0;\n        r \\<le> x * k\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          (r mod m + x * k - x * k mod m) mod m =\n                          r mod m \\<and>\n                          r \\<le> r mod m + x * k - x * k mod m \\<and>\n                          (r mod m + x * k - x * k mod m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          (m + r mod m + x * k - x * k mod m) mod m =\n                          r mod m \\<and>\n                          r \\<le> m + r mod m + x * k - x * k mod m \\<and>\n                          (m + r mod m + x * k - x * k mod m) div k = x)", "apply (subst diff_add_assoc, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0;\n        r \\<le> x * k\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          (r mod m + (x * k - x * k mod m)) mod m =\n                          r mod m \\<and>\n                          r \\<le> r mod m + (x * k - x * k mod m) \\<and>\n                          (r mod m + (x * k - x * k mod m)) div k =\n                          x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          (m + r mod m + (x * k - x * k mod m)) mod m =\n                          r mod m \\<and>\n                          r \\<le> m + r mod m + (x * k - x * k mod m) \\<and>\n                          (m + r mod m + (x * k - x * k mod m)) div k = x)", "apply (simp add: div_mult_cancel[symmetric] del: add_diff_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0;\n        r \\<le> x * k\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply (case_tac \"x * k mod m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        x * k mod m = 0\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        x * k mod m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply (clarsimp elim!: dvdE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ka.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> m * ka + k - Suc 0;\n        r \\<le> m * ka; x * k = m * ka\\<rbrakk>\n       \\<Longrightarrow> r \\<le> r mod m + ka * m \\<and>\n                         (r mod m + ka * m) div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        x * k mod m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply (drule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ka.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> m * ka + k - Suc 0;\n        r \\<le> m * ka; m * ka = x * k\\<rbrakk>\n       \\<Longrightarrow> r \\<le> r mod m + ka * m \\<and>\n                         (r mod m + ka * m) div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        x * k mod m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply (simp add: mult.commute[of m])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ka.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        ka * m = x * k\\<rbrakk>\n       \\<Longrightarrow> r mod m div k = 0\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        x * k mod m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply (blast intro: div_less order_less_le_trans mod_less_divisor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        x * k mod m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (x * k mod m \\<le> r mod m \\<longrightarrow>\n                          r \\<le> r mod m + x * k div m * m \\<and>\n                          (r mod m + x * k div m * m) div k = x) \\<and>\n                         (r mod m < x * k mod m \\<longrightarrow>\n                          r \\<le> m + r mod m + x * k div m * m \\<and>\n                          (m + r mod m + x * k div m * m) div k = x)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> r mod m + x * k div m * m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> (r mod m + x * k div m * m) div k = x\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 4. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> (r mod m + x * k div m * m) div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> (r mod m + x * k - x * k mod m) div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (subst add.commute, subst diff_add_assoc, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> (x * k + (r mod m - x * k mod m)) div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (subst add.commute, subst div_mult_self1, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> x + (r mod m - x * k mod m) div k = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (subst div_less)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> r mod m - x * k mod m < k\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> x + 0 = x\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 4. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (rule order_less_le_trans[of _ m], simp add: less_imp_diff_less)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> m \\<le> k\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> x + 0 = x\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 4. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; x * k mod m \\<le> r mod m\\<rbrakk>\n       \\<Longrightarrow> x + 0 = x\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 3. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> r \\<le> m + r mod m + x * k div m * m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (rule_tac y=\"x * k\" in order_trans, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> x * k \\<le> m + r mod m + x * k div m * m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> x * k \\<le> m + r mod m + x * k - x * k mod m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (rule le_add_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> x * k mod m \\<le> m + r mod m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (simp add: trans_le_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        0 < x * k mod m; r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k div m * m) div k = x", "apply (simp add: div_mult_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m + x * k - x * k mod m) div k = x", "apply (subst diff_add_assoc2, simp add: trans_le_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; m \\<le> k; r \\<le> x * k + k - Suc 0; r \\<le> x * k;\n        r mod m < x * k mod m\\<rbrakk>\n       \\<Longrightarrow> (m + r mod m - x * k mod m + x * k) div k = x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMOD_div_self: \"\n  0 < m \\<Longrightarrow> [r, mod m] \\<oslash> m = [r div m\\<dots>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> [ r, mod m ] \\<oslash> m = [r div m\\<dots>]", "by (simp add: iMOD_div_ge)"], ["", "lemma iMOD_div: \"\n  \\<lbrakk> 0 < k; m mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  [r, mod m] \\<oslash> k = [r div k, mod (m div k) ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k = [ r div k, mod m div k ]", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; m mod k = 0; m = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k = [ r div k, mod m div k ]\n 2. \\<lbrakk>0 < k; m mod k = 0; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k = [ r div k, mod m div k ]", "apply (simp add: iMOD_0 iIN_0 iT_Div_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k = [ r div k, mod m div k ]", "apply (clarsimp elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>0 < k; 0 < ka; m = k * ka\\<rbrakk>\n       \\<Longrightarrow> [ r, mod k * ka ] \\<oslash> k = [ r div k, mod ka ]", "apply (rename_tac q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q; m = k * q\\<rbrakk>\n       \\<Longrightarrow> [ r, mod k * q ] \\<oslash> k = [ r div k, mod q ]", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q\\<rbrakk>\n       \\<Longrightarrow> [ r, mod k * q ] \\<oslash> k = [ r div k, mod q ]", "apply (cut_tac r=\"r div k\" and k=k and m=q in iMOD_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r div k, mod q ] \\<otimes> k = [ r div k * k, mod q * k ]\\<rbrakk>\n       \\<Longrightarrow> [ r, mod k * q ] \\<oslash> k = [ r div k, mod q ]", "apply (drule arg_cong[where f=\"\\<lambda>x. x \\<oplus> (r mod k)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k =\n        [ r div k * k, mod q * k ] \\<oplus> r mod k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod k * q ] \\<oslash> k = [ r div k, mod q ]", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r div k * k, mod q * k ] \\<oplus> r mod k =\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod k * q ] \\<oslash> k = [ r div k, mod q ]", "apply (simp add: iMOD_add mult.commute[of k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] =\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oplus>\n                         r mod k \\<oslash>\n                         k =\n                         [ r div k, mod q ]", "apply (cut_tac I=\"[r div k, mod q] \\<otimes> k\" and m=k and n=\"r mod k\" in iT_Plus_Div_distrib_mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] =\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>[ r div k, mod q ] \\<otimes> k.\n                            x mod k + r mod k mod k < k\n 2. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k \\<oslash> k =\n        [ r div k, mod q ] \\<otimes> k \\<oslash> k \\<oplus>\n        r mod k div k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oplus>\n                         r mod k \\<oslash>\n                         k =\n                         [ r div k, mod q ]", "apply (rule ballI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        x \\<in> [ r div k, mod q ] \\<otimes> k\\<rbrakk>\n       \\<Longrightarrow> x mod k + r mod k mod k < k\n 2. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k \\<oslash> k =\n        [ r div k, mod q ] \\<otimes> k \\<oslash> k \\<oplus>\n        r mod k div k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oplus>\n                         r mod k \\<oslash>\n                         k =\n                         [ r div k, mod q ]", "apply (simp only: iMOD_mult iMOD_iff, elim conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k * k, mod q * k ] \\<oplus> r mod k;\n        x mod (q * k) = r div k * k mod (q * k);\n        r div k * k \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k + r mod k mod k < k\n 2. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k \\<oslash> k =\n        [ r div k, mod q ] \\<otimes> k \\<oslash> k \\<oplus>\n        r mod k div k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oplus>\n                         r mod k \\<oslash>\n                         k =\n                         [ r div k, mod q ]", "apply (drule mod_factor_imp_mod_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k * k, mod q * k ] \\<oplus> r mod k;\n        r div k * k \\<le> x; x mod k = 0\\<rbrakk>\n       \\<Longrightarrow> x mod k + r mod k mod k < k\n 2. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k \\<oslash> k =\n        [ r div k, mod q ] \\<otimes> k \\<oslash> k \\<oplus>\n        r mod k div k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oplus>\n                         r mod k \\<oslash>\n                         k =\n                         [ r div k, mod q ]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k \\<oslash> k =\n        [ r div k, mod q ] \\<otimes> k \\<oslash> k \\<oplus>\n        r mod k div k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oplus>\n                         r mod k \\<oslash>\n                         k =\n                         [ r div k, mod q ]", "apply (simp add: iT_Plus_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < k; 0 < q;\n        [ r, mod q * k ] = [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k;\n        [ r div k, mod q ] \\<otimes> k \\<oplus> r mod k \\<oslash> k =\n        [ r div k, mod q ] \\<otimes> k \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> [ r div k, mod q ] \\<otimes> k \\<oslash> k =\n                         [ r div k, mod q ]", "apply (simp add: iT_Mult_Div[OF _ mod_self] iT_Mult_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_div_self: \"\n  0 < m \\<Longrightarrow> [r, mod m, c] \\<oslash> m = [r div m\\<dots>,c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow> [ r, mod m, c ] \\<oslash> m = [r div m\\<dots>,c]", "apply (subst iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    [ r, mod m ] \\<inter> [\\<dots>r + m * c] \\<oslash> m =\n    [r div m\\<dots>,c]", "apply (subst iTILL_iT_Div_Int)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < m \\<Longrightarrow> 0 < m\n 2. 0 < m \\<Longrightarrow>\n    \\<forall>x\\<in>[ r, mod m ].\n       x div m \\<le> (r + m * c) div m \\<longrightarrow> x \\<le> r + m * c\n 3. 0 < m \\<Longrightarrow>\n    ([ r, mod m ] \\<oslash> m) \\<inter> ([\\<dots>r + m * c] \\<oslash> m) =\n    [r div m\\<dots>,c]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<forall>x\\<in>[ r, mod m ].\n       x div m \\<le> (r + m * c) div m \\<longrightarrow> x \\<le> r + m * c\n 2. 0 < m \\<Longrightarrow>\n    ([ r, mod m ] \\<oslash> m) \\<inter> ([\\<dots>r + m * c] \\<oslash> m) =\n    [r div m\\<dots>,c]", "apply (clarsimp simp: iT_iff simp del: div_mult_self1 div_mult_self2, rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x div m \\<le> (r + m * c) div m; x mod m = r mod m;\n        r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 2. 0 < m \\<Longrightarrow>\n    ([ r, mod m ] \\<oslash> m) \\<inter> ([\\<dots>r + m * c] \\<oslash> m) =\n    [r div m\\<dots>,c]", "apply (drule div_le_mod_le_imp_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod m \\<le> (r + m * c) mod m\n 2. \\<And>x.\n       \\<lbrakk>0 < m; x mod m = r mod m; r \\<le> x;\n        x \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 3. 0 < m \\<Longrightarrow>\n    ([ r, mod m ] \\<oslash> m) \\<inter> ([\\<dots>r + m * c] \\<oslash> m) =\n    [r div m\\<dots>,c]", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    ([ r, mod m ] \\<oslash> m) \\<inter> ([\\<dots>r + m * c] \\<oslash> m) =\n    [r div m\\<dots>,c]", "apply (simp add: iMOD_div_self iTILL_div iFROM_iTILL_iIN_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_div_ge: \"\n  \\<lbrakk> 0 < m; m \\<le> k \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oslash> k = [r div k\\<dots>,(r + m * c) div k - r div k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [r div k\\<dots>,(r + m * c) div k - r div k]", "apply (case_tac \"m = k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; m \\<le> k; m = k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [r div k\\<dots>,(r + m * c) div k - r div k]\n 2. \\<lbrakk>0 < m; m \\<le> k; m \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [r div k\\<dots>,(r + m * c) div k - r div k]", "apply (simp add: iMODb_div_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> k; m \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [r div k\\<dots>,(r + m * c) div k - r div k]", "apply (drule le_neq_trans, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m < k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [r div k\\<dots>,(r + m * c) div k - r div k]", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < m; m < k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, 0 ] \\<oslash> k =\n                      [r div k\\<dots>,(r + m * 0) div k - r div k]\n 2. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, Suc c ] \\<oslash> k =\n                         [r div k\\<dots>,(r + m * Suc c) div k - r div k]", "apply (simp add: iMODb_0 iIN_0 iT_Div_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, Suc c ] \\<oslash> k =\n                         [r div k\\<dots>,(r + m * Suc c) div k - r div k]", "apply (rule_tac t=\"[ r, mod m, Suc c ]\" and s=\"[ r, mod m, c ] \\<union> {r + m * c + m}\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<union> {r + m * c + m} =\n                         [ r, mod m, Suc c ]\n 2. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<union> {r + m * c + m} \\<oslash>\n                         k =\n                         [r div k\\<dots>,(r + m * Suc c) div k - r div k]", "apply (cut_tac c=c and c'=0 and r=r and m=m in iMODb_append_union_Suc[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k;\n        [ r, mod m, Suc (c + 0) ] =\n        [ r, mod m, c ] \\<union> [ r + m * Suc c, mod m, 0 ]\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<union> {r + m * c + m} =\n                         [ r, mod m, Suc c ]\n 2. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<union> {r + m * c + m} \\<oslash>\n                         k =\n                         [r div k\\<dots>,(r + m * Suc c) div k - r div k]", "apply (simp add: iMODb_0 iIN_0 add.commute[of m] add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<union> {r + m * c + m} \\<oslash>\n                         k =\n                         [r div k\\<dots>,(r + m * Suc c) div k - r div k]", "apply (subst iT_Div_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<lbrakk>0 < m; m < k\\<rbrakk>\n                \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                                  [r div\n                                   k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> ([ r, mod m, c ] \\<oslash> k) \\<union>\n                         ({r + m * c + m} \\<oslash> k) =\n                         [r div k\\<dots>,(r + m * Suc c) div k - r div k]", "apply (simp add: iT_Div_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + (m + m * c)) div k - r div k]", "apply (simp add: add.commute[of m] add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]", "apply (case_tac \"(r + m * c) mod k + m mod k < k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; (r + m * c) mod k + m mod k < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]\n 2. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; \\<not> (r + m * c) mod k + m mod k < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]", "apply (simp add: div_add1_eq1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; (r + m * c) mod k + m < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c) div k - r div k]\n 2. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; \\<not> (r + m * c) mod k + m mod k < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]", "apply (rule insert_absorb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; (r + m * c) mod k + m < k\\<rbrakk>\n       \\<Longrightarrow> (r + m * c) div k\n                         \\<in> [r div k\\<dots>,(r + m * c) div k - r div k]\n 2. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; \\<not> (r + m * c) mod k + m mod k < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]", "apply (simp add: iIN_iff div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; \\<not> (r + m * c) mod k + m mod k < k\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]", "apply (simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; k \\<le> (r + m * c) mod k + m\\<rbrakk>\n       \\<Longrightarrow> insert ((r + m * c + m) div k)\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,(r + m * c + m) div k - r div k]", "apply (simp add: div_add1_eq2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; k \\<le> (r + m * c) mod k + m\\<rbrakk>\n       \\<Longrightarrow> insert (Suc ((r + m * c) div k))\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div k\\<dots>,Suc ((r + m * c) div k) - r div k]", "apply (rule_tac t=\"Suc ((r + m * c) div k)\" and s=\"Suc (r div k + ((r + m * c) div k - r div k))\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; k \\<le> (r + m * c) mod k + m\\<rbrakk>\n       \\<Longrightarrow> Suc (r div k + ((r + m * c) div k - r div k)) =\n                         Suc ((r + m * c) div k)\n 2. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; k \\<le> (r + m * c) mod k + m\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (Suc (r div k + ((r + m * c) div k - r div k)))\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div\n                          k\\<dots>,Suc (r div k +\n  ((r + m * c) div k - r div k)) -\n                                   r div k]", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>[ r, mod m, c ] \\<oslash> k =\n                [r div k\\<dots>,(r + m * c) div k - r div k];\n        0 < m; m < k; k \\<le> (r + m * c) mod k + m\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (Suc (r div k + ((r + m * c) div k - r div k)))\n                          [r div k\\<dots>,(r + m * c) div k - r div k] =\n                         [r div\n                          k\\<dots>,Suc (r div k +\n  ((r + m * c) div k - r div k)) -\n                                   r div k]", "apply (simp add: iIN_Suc_insert_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iMODb_div_ge_if: \"\n  \\<lbrakk> 0 < m; m \\<le> k \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oslash> k =\n  [r div k\\<dots>, m * c div k + (if r mod k + m * c mod k < k then 0 else Suc 0)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; m \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [r div\n                       k\\<dots>,m * c div k +\n                                (if r mod k + m * c mod k < k then 0\n                                 else Suc 0)]", "by (simp add: iMODb_div_ge div_add1_eq_if[of _ r])"], ["", "lemma iMODb_div: \"\n  \\<lbrakk> 0 < k; m mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  [r, mod m, c] \\<oslash> k = [r div k, mod (m div k), c ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k =\n                      [ r div k, mod m div k, c ]", "apply (subst iMODb_iMOD_iTILL_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<inter> [\\<dots>r + m * c] \\<oslash> k =\n                      [ r div k, mod m div k, c ]", "apply (subst iTILL_iT_Div_Int)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk> \\<Longrightarrow> 0 < k\n 2. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>[ r, mod m ].\n                         x div k \\<le> (r + m * c) div k \\<longrightarrow>\n                         x \\<le> r + m * c\n 3. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>[ r, mod m ].\n                         x div k \\<le> (r + m * c) div k \\<longrightarrow>\n                         x \\<le> r + m * c\n 2. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply (simp add: Ball_def iMOD_iff, intro allI impI, elim conjE, rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x div k \\<le> (r + m * c) div k;\n        x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 2. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply (drule div_le_mod_le_imp_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k \\<le> (r + m * c) mod k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x mod m = r mod m; r \\<le> x;\n        x \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 3. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply (subst mod_add1_eq_if)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k\n                         \\<le> (if r mod k + m * c mod k < k\n                                then r mod k + m * c mod k\n                                else r mod k + m * c mod k - k)\n 2. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x mod m = r mod m; r \\<le> x;\n        x \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 3. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply (simp add: mod_0_imp_mod_mult_right_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x mod m = r mod m; r \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x mod k \\<le> r mod k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; m mod k = 0; x mod m = r mod m; r \\<le> x;\n        x \\<le> r + m * c\\<rbrakk>\n       \\<Longrightarrow> x \\<le> r + m * c\n 3. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply (drule mod_eq_mod_0_imp_mod_eq, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> ([ r, mod m ] \\<oslash> k) \\<inter>\n                      ([\\<dots>r + m * c] \\<oslash> k) =\n                      [ r div k, mod m div k, c ]", "apply (simp add: iMOD_div iTILL_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m div k ] \\<inter>\n                      [\\<dots>(r + m * c) div k] =\n                      [ r div k, mod m div k, c ]", "apply (simp add: iMOD_iTILL_iMODb_conv div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r div\n                        k, mod m div\n                               k, ((r + m * c) div k - r div k) div\n                                  (m div k) ] =\n                      [ r div k, mod m div k, c ]", "apply (clarsimp simp: mult.assoc iMODb_mod_0 iMOD_0 elim!: dvdE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas iT_div =\n  iTILL_div\n  iFROM_div\n  iIN_div\n  iMOD_div\n  iMODb_div\n  iT_Div_singleton"], ["", "text \\<open>This lemma is valid for all @{term \"k \\<le> m\"},i. e., also for k with @{term \"m mod k \\<noteq> 0\"}.\\<close>"], ["", "lemma iMODb_div_unique: \"\n  \\<lbrakk> 0 < k; k \\<le> m; k \\<le> c; [r', mod m', c'] = [r, mod m, c] \\<oslash> k \\<rbrakk> \\<Longrightarrow>\n  r' = r div k \\<and> m' = m div k \\<and> c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k \\<and> c' = c", "apply (case_tac \"r' \\<noteq> r div k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r' \\<noteq> r div k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     \\<not> r' \\<noteq> r div k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k \\<and> c' = c", "apply (drule arg_cong[where f=\"iMin\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c; r' \\<noteq> r div k;\n     iMin [ r', mod m', c' ] = iMin ([ r, mod m, c ] \\<oslash> k)\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     \\<not> r' \\<noteq> r div k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k \\<and> c' = c", "apply (simp add: iT_Min iT_not_empty iT_Div_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     \\<not> r' \\<noteq> r div k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k \\<and> c' = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r' = r div k\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (case_tac \"m' = 0 \\<or> c' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (subgoal_tac \"[ r div k, mod m', c' ] = {r div k}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0; [ r div k, mod m', c' ] = {r div k}\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c' ] = {r div k}\n 3. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c' ] = {r div k}\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0; [ r div k, mod m', c' ] = {r div k}\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 3. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (rule iMODb_singleton_eq_conv[THEN iffD2], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0; [ r div k, mod m', c' ] = {r div k}\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     {r div k} = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     m' = 0 \\<or> c' = 0;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (drule arg_cong[where f=\"Max\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c; r' = r div k; m' = 0 \\<or> c' = 0;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     Max {r div k} = Max ([ r, mod m, c ] \\<oslash> k)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (simp add: iMODb_mod_0 iIN_0 iT_Max iT_Div_Max iT_Div_finite_iff iT_Div_not_empty iT_finite iT_not_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c; r' = (r + m * c) div k;\n     m' = 0 \\<or> c' = 0;\n     [ (r + m * c) div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r div k = (r + m * c) div k\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (subgoal_tac \"r div k < (r + m * c) div k\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c; r' = (r + m * c) div k;\n     m' = 0 \\<or> c' = 0;\n     [ (r + m * c) div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r div k = (r + m * c) div k\\<rbrakk>\n    \\<Longrightarrow> r div k < (r + m * c) div k\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (subst div_add1_eq_if, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c; r' = (r + m * c) div k;\n     m' = 0 \\<or> c' = 0;\n     [ (r + m * c) div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r div k = (r + m * c) div k\\<rbrakk>\n    \\<Longrightarrow> r div k\n                      < r div k + m * c div k +\n                        (if r mod k + m * c mod k < k then 0 else Suc 0)\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> m; k \\<le> c; r' = (r + m * c) div k;\n     m' = 0 \\<or> c' = 0;\n     [ (r + m * c) div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r div k = (r + m * c) div k; r mod k + m * c mod k < k\\<rbrakk>\n    \\<Longrightarrow> 0 < m * c div k\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (rule order_less_le_trans[of _ \"k * k div k\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> m; k \\<le> c; r' = (r + m * c) div k;\n     m' = 0 \\<or> c' = 0;\n     [ (r + m * c) div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r div k = (r + m * c) div k; r mod k + m * c mod k < k\\<rbrakk>\n    \\<Longrightarrow> k * k div k \\<le> m * c div k\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (rule div_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> m; k \\<le> c; r' = (r + m * c) div k;\n     m' = 0 \\<or> c' = 0;\n     [ (r + m * c) div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k;\n     r div k = (r + m * c) div k; r mod k + m * c mod k < k\\<rbrakk>\n    \\<Longrightarrow> k * k \\<le> m * c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (simp add: mult_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (subgoal_tac \"c' = c\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0); c' = c\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> c' = c", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0)\\<rbrakk>\n    \\<Longrightarrow> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0); c' = c\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (drule arg_cong[where f=\"\\<lambda>A. card A\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0);\n     card [ r div k, mod m', c' ] =\n     card ([ r, mod m, c ] \\<oslash> k)\\<rbrakk>\n    \\<Longrightarrow> c' = c\n 2. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0); c' = c\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply (simp add: iT_Div_def card_image[OF iMODb_div_right_inj_on] iMODb_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c' ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     \\<not> (m' = 0 \\<or> c' = 0); c' = c\\<rbrakk>\n    \\<Longrightarrow> m' = m div k \\<and> c' = c", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     0 < m'; c' = c\\<rbrakk>\n    \\<Longrightarrow> m' = m div k", "apply (frule iMODb_div_right_strict_mono_on[of k m r c], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     0 < m'; c' = c;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k)\n      [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> m' = m div k", "apply (frule_tac a=k and b=0 and m=m' and r=\"r div k\" and c=c in iMODb_inext_nth_diff, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     0 < m'; c' = c;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m, c ];\n     ([ r div k, mod m', c ] \\<rightarrow> k) -\n     ([ r div k, mod m', c ] \\<rightarrow> 0) =\n     (k - 0) * m'\\<rbrakk>\n    \\<Longrightarrow> m' = m div k", "apply (simp add: iT_Div_Min iT_not_empty iT_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k; r' = r div k;\n     0 < m'; c' = c;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m, c ];\n     (([ r, mod m, c ] \\<oslash> k) \\<rightarrow> k) - r div k =\n     k * m'\\<rbrakk>\n    \\<Longrightarrow> m' = m div k", "apply (simp add: iT_Div_def inext_nth_image[OF iMODb_not_empty])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; k \\<le> c;\n     [ r div k, mod m', c ] = (\\<lambda>n. n div k) ` [ r, mod m, c ];\n     r' = r div k; 0 < m'; c' = c;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m, c ];\n     ([ r, mod m, c ] \\<rightarrow> k) div k - r div k = k * m'\\<rbrakk>\n    \\<Longrightarrow> m' = m div k", "apply (simp add: iMODb_inext_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_div_mod_gr0_is_0_not_ex0: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0 \\<rbrakk> \\<Longrightarrow>\n  \\<not>(\\<exists>r' m' c'. [r', mod m', c'] = [r, mod m, c] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>r' m' c'.\n                         [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k", "apply (rule ccontr, simp, elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m' c'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0;\n        [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac r'=r' and m'=m' and c'=c' and r=r and k=k and m=m and c=c\n  in iMODb_div_unique[OF _ less_imp_le], simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0;\n        [ r div k, mod m div k, c ] = [ r, mod m, c ] \\<oslash> k;\n        r' = r div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule arg_cong[where f=\"Max\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0;\n        r' = r div k;\n        Max [ r div k, mod m div k, c ] =\n        Max ([ r, mod m, c ] \\<oslash> k)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: iT_Max iT_Div_Max iT_Div_finite_iff iT_Div_not_empty iT_finite iT_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0;\n        r' = r div k; r div k + m div k * c = (r + m * c) div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: div_add1_eq1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0;\n        r' = r div k; m div k * c = m * c div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: mult.commute[of m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0;\n        r' = r div k; m div k * c = c * m div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: div_mult1_eq[of c m] div_eq_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>k < m; 0 < m mod k; k \\<le> c; r mod k = 0; r' = r div k;\n        c * (m mod k) < k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"c \\<le> c * (m mod k)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r'.\n       \\<lbrakk>k < m; 0 < m mod k; k \\<le> c; r mod k = 0; r' = r div k;\n        c * (m mod k) < k; c \\<le> c * (m mod k)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>r'.\n       \\<lbrakk>k < m; 0 < m mod k; k \\<le> c; r mod k = 0; r' = r div k;\n        c * (m mod k) < k\\<rbrakk>\n       \\<Longrightarrow> c \\<le> c * (m mod k)", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_div_mod_gr0_not_ex__arith_aux1: \"\n  \\<lbrakk> (0::nat) < k; k < m; 0 < x1 \\<rbrakk> \\<Longrightarrow>\n  x1 * m + x2 - x mod k + x3 + x mod k = x1 * m + x2 + x3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < x1\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply (drule Suc_leI[of _ x1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 \\<le> x1\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply (drule mult_le_mono1[of \"Suc 0\" _ m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply (subgoal_tac \"x mod k \\<le> x1 * m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m;\n     x mod k \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3\n 2. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x mod k \\<le> x1 * m", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x mod k \\<le> x1 * m\n 2. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m;\n     x mod k \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply (rule order_trans[OF mod_le_divisor], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> k \\<le> x1 * m\n 2. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m;\n     x mod k \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply (rule order_less_imp_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> k < x1 * m\n 2. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m;\n     x mod k \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply (rule order_less_le_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> k < ?y11\n 2. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> ?y11 \\<le> x1 * m\n 3. \\<lbrakk>0 < k; k < m; Suc 0 * m \\<le> x1 * m;\n     x mod k \\<le> x1 * m\\<rbrakk>\n    \\<Longrightarrow> x1 * m + x2 - x mod k + x3 + x mod k =\n                      x1 * m + x2 + x3", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_div_mod_gr0_not_ex: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k; k \\<le> c \\<rbrakk> \\<Longrightarrow>\n  \\<not>(\\<exists>r' m' c'. [r', mod m', c'] = [r, mod m, c] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>r' m' c'.\n                         [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k", "apply (case_tac \"r mod k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; r mod k = 0\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>r' m' c'.\n                         [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k\n 2. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n     r mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>r' m' c'.\n                         [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k", "apply (simp add: iMODb_div_mod_gr0_is_0_not_ex0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n     r mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>r' m' c'.\n                         [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k", "apply (rule ccontr, simp, elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m' c'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n        [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac r'=r' and m'=m' and c'=c' and r=r and k=k and m=m and c=c\n  in iMODb_div_unique[OF _ less_imp_le], simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n        [ r div k, mod m div k, c ] = [ r, mod m, c ] \\<oslash> k;\n        r' = r div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     [ r div k, mod m div k, c ] = [ r, mod m, c ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule arg_cong[where f=\"Max\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     Max [ r div k, mod m div k, c ] =\n     Max ([ r, mod m, c ] \\<oslash> k)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: iT_Max iT_Div_Max iT_Div_finite_iff iT_Div_not_empty iT_finite iT_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     r div k + m div k * c = (r + m * c) div k\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: div_add1_eq[of r \"m * c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     m div k * c = m * c div k + (r mod k + m * c mod k) div k\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: mult.commute[of _ c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     c * (m div k) = c * m div k + (r mod k + c * m mod k) div k\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp add: div_mult1_eq[of c m k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     c * (m mod k) div k = 0; (r mod k + c * m mod k) div k = 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"Suc 0 \\<le> c * (m mod k) div k\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k;\n     c * (m mod k) div k = 0; (r mod k + c * m mod k) div k = 0\\<rbrakk>\n    \\<Longrightarrow> Suc 0 \\<le> c * (m mod k) div k", "apply (thin_tac \"_ = 0\")+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c; 0 < r mod k\\<rbrakk>\n    \\<Longrightarrow> Suc 0 \\<le> c * (m mod k) div k", "apply (drule div_le_mono[of k c k], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; 0 < r mod k;\n     Suc 0 \\<le> c div k\\<rbrakk>\n    \\<Longrightarrow> Suc 0 \\<le> c * (m mod k) div k", "apply (rule order_trans[of _ \"c div k\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; 0 < r mod k;\n     Suc 0 \\<le> c div k\\<rbrakk>\n    \\<Longrightarrow> c div k \\<le> c * (m mod k) div k", "apply (rule div_le_mono, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_div_eq_imp_iMODb_div_eq: \"\n  \\<lbrakk> 0 < k; k \\<le> m; [r', mod m'] = [r, mod m] \\<oslash> k \\<rbrakk> \\<Longrightarrow>\n  [r', mod m', c] = [r, mod m, c] \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r', mod m' ] = [ r, mod m ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (subgoal_tac \"r' = r div k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; [ r', mod m' ] = [ r, mod m ] \\<oslash> k;\n     r' = r div k\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c ] = [ r, mod m, c ] \\<oslash> k\n 2. \\<lbrakk>0 < k; k \\<le> m;\n     [ r', mod m' ] = [ r, mod m ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r', mod m' ] = [ r, mod m ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k\n 2. \\<lbrakk>0 < k; k \\<le> m; [ r', mod m' ] = [ r, mod m ] \\<oslash> k;\n     r' = r div k\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (drule arg_cong[where f=iMin])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     iMin [ r', mod m' ] = iMin ([ r, mod m ] \\<oslash> k)\\<rbrakk>\n    \\<Longrightarrow> r' = r div k\n 2. \\<lbrakk>0 < k; k \\<le> m; [ r', mod m' ] = [ r, mod m ] \\<oslash> k;\n     r' = r div k\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (simp add: iT_Div_Min iMOD_not_empty iMOD_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; [ r', mod m' ] = [ r, mod m ] \\<oslash> k;\n     r' = r div k\\<rbrakk>\n    \\<Longrightarrow> [ r', mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (frule iMOD_div_right_strict_mono_on[of _ m r], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (frule card_image[OF strict_mono_on_imp_inj_on[OF iMODb_div_right_strict_mono_on[of k m r c]]], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) =\n     card [ r, mod m, c ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (simp add: iMODb_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (subgoal_tac \"r + m * c \\<in> [r, mod m]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k\n 2. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c\\<rbrakk>\n    \\<Longrightarrow> r + m * c \\<in> [ r, mod m ]", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c\\<rbrakk>\n    \\<Longrightarrow> r + m * c \\<in> [ r, mod m ]\n 2. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (simp add: iMOD_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (subgoal_tac \"[r, mod m, c] = [ r, mod m ] \\<down>\\<le> (r + m * c)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     [ r, mod m, c ] = [ r, mod m ] \\<down>\\<le> (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k\n 2. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] =\n                      [ r, mod m ] \\<down>\\<le> (r + m * c)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] =\n                      [ r, mod m ] \\<down>\\<le> (r + m * c)\n 2. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     [ r, mod m, c ] = [ r, mod m ] \\<down>\\<le> (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (simp add: iMOD_cut_le1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = [ r, mod m ] \\<oslash> k; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m, c ]) = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     [ r, mod m, c ] = [ r, mod m ] \\<down>\\<le> (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] = [ r, mod m, c ] \\<oslash> k", "apply (simp add: iT_Div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = (\\<lambda>n. n div k) ` [ r, mod m ];\n     r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card ((\\<lambda>x. x div k) ` [ r, mod m ] \\<down>\\<le> (r + m * c)) =\n     Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     [ r, mod m, c ] = [ r, mod m ] \\<down>\\<le> (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      (\\<lambda>n. n div k) `\n                      [ r, mod m ] \\<down>\\<le> (r + m * c)", "apply (simp add: cut_le_image[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r div k, mod m' ] = (\\<lambda>n. n div k) ` [ r, mod m ];\n     r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card\n      (((\\<lambda>x. x div k) ` [ r, mod m ]) \\<down>\\<le>\n       ((r + m * c) div k)) =\n     Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     [ r, mod m, c ] = [ r, mod m ] \\<down>\\<le> (r + m * c)\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      ((\\<lambda>n. n div k) ` [ r, mod m ]) \\<down>\\<le>\n                      ((r + m * c) div k)", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card\n      (((\\<lambda>x. x div k) ` [ r, mod m ]) \\<down>\\<le>\n       ((r + m * c) div k)) =\n     Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     [ r, mod m, c ] = [ r, mod m ] \\<down>\\<le> (r + m * c);\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      ((\\<lambda>n. n div k) ` [ r, mod m ]) \\<down>\\<le>\n                      ((r + m * c) div k)", "apply (simp add: iMOD_cut_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card\n      (if (r + m * c) div k < r div k then {}\n       else [ r div k, mod m', ((r + m * c) div k - r div k) div m' ]) =\n     Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ]\\<rbrakk>\n    \\<Longrightarrow> ((r + m * c) div k < r div k \\<longrightarrow>\n                       [ r div k, mod m', c ] = {}) \\<and>\n                      (\\<not> (r + m * c) div k < r div k \\<longrightarrow>\n                       [ r div k, mod m', c ] =\n                       [ r div\n                         k, mod m', ((r + m * c) div k - r div k) div m' ])", "apply (simp add: linorder_not_le[of \"r div k\", symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card\n      (if \\<not> r div k \\<le> (r + m * c) div k then {}\n       else [ r div k, mod m', ((r + m * c) div k - r div k) div m' ]) =\n     Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ]\\<rbrakk>\n    \\<Longrightarrow> (\\<not> r div k\n                              \\<le> (r + m * c) div k \\<longrightarrow>\n                       [ r div k, mod m', c ] = {}) \\<and>\n                      (r div k \\<le> (r + m * c) div k \\<longrightarrow>\n                       [ r div k, mod m', c ] =\n                       [ r div\n                         k, mod m', ((r + m * c) div k - r div k) div m' ])", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card [ r div k, mod m', ((r + m * c) div k - r div k) div m' ] = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ]\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      [ r div\n                        k, mod m', ((r + m * c) div k - r div k) div m' ]", "apply (case_tac \"m' = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card [ r div k, mod m', ((r + m * c) div k - r div k) div m' ] = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ];\n     m' = 0\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      [ r div\n                        k, mod m', ((r + m * c) div k - r div k) div m' ]\n 2. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card [ r div k, mod m', ((r + m * c) div k - r div k) div m' ] = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ];\n     m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      [ r div\n                        k, mod m', ((r + m * c) div k - r div k) div m' ]", "apply (simp add: iMODb_mod_0_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card [ r div k, mod m', ((r + m * c) div k - r div k) div m' ] = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ];\n     m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [ r div k, mod m', c ] =\n                      [ r div\n                        k, mod m', ((r + m * c) div k - r div k) div m' ]", "apply (rule arg_cong[where f=\"\\<lambda>c. [r div k, mod m', c]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; r' = r div k;\n     SetInterval2.strict_mono_on (\\<lambda>x. x div k) [ r, mod m ];\n     card [ r div k, mod m', ((r + m * c) div k - r div k) div m' ] = Suc c;\n     r + m * c \\<in> [ r, mod m ];\n     (\\<lambda>n. n div k) ` [ r, mod m ] = [ r div k, mod m' ];\n     m' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c = ((r + m * c) div k - r div k) div m'", "apply (simp add: iMODb_card)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_div_unique: \"\n  \\<lbrakk> 0 < k; k \\<le> m; [r', mod m'] = [r, mod m] \\<oslash> k \\<rbrakk> \\<Longrightarrow>\n  r' = r div k \\<and> m' = m div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m;\n     [ r', mod m' ] = [ r, mod m ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k", "apply (frule iMOD_div_eq_imp_iMODb_div_eq[of k m r' m' r k], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k \\<le> m; [ r', mod m' ] = [ r, mod m ] \\<oslash> k;\n     [ r', mod m', k ] = [ r, mod m, k ] \\<oslash> k\\<rbrakk>\n    \\<Longrightarrow> r' = r div k \\<and> m' = m div k", "apply (simp add: iMODb_div_unique[of k _ k])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMOD_div_mod_gr0_not_ex: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k \\<rbrakk> \\<Longrightarrow>\n  \\<not> (\\<exists>r' m'. [r', mod m'] = [r, mod m] \\<oslash> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>r' m'.\n                         [ r', mod m' ] = [ r, mod m ] \\<oslash> k", "apply (rule ccontr, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k;\n        [ r', mod m' ] = [ r, mod m ] \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac k=k and m=m and r'=r' and m'=m' and c=k\n  in iMOD_div_eq_imp_iMODb_div_eq[OF _ less_imp_le], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k;\n        [ r', mod m' ] = [ r, mod m ] \\<oslash> k;\n        [ r', mod m', k ] = [ r, mod m, k ] \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule iMODb_div_mod_gr0_not_ex[of k m k r], simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Interval cut operators with arithmetic interval operators\\<close>"], ["", "lemma\n  iT_Plus_cut_le2:      \"(I \\<oplus> k) \\<down>\\<le> (t + k) = (I \\<down>\\<le> t) \\<oplus> k\" and\n  iT_Plus_cut_less2:    \"(I \\<oplus> k) \\<down>< (t + k) = (I \\<down>< t) \\<oplus> k\" and\n  iT_Plus_cut_ge2:      \"(I \\<oplus> k) \\<down>\\<ge> (t + k) = (I \\<down>\\<ge> t) \\<oplus> k\" and\n  iT_Plus_cut_greater2: \"(I \\<oplus> k) \\<down>> (t + k) = (I \\<down>> t) \\<oplus> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((I \\<oplus> k) \\<down>\\<le> (t + k) = I \\<down>\\<le> t \\<oplus> k &&&\n     (I \\<oplus> k) \\<down>< (t + k) = I \\<down>< t \\<oplus> k) &&&\n    (I \\<oplus> k) \\<down>\\<ge> (t + k) = I \\<down>\\<ge> t \\<oplus> k &&&\n    (I \\<oplus> k) \\<down>> (t + k) = I \\<down>> t \\<oplus> k", "unfolding iT_Plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lambda>n. n + k) ` I) \\<down>\\<le> (t + k) =\n     (\\<lambda>n. n + k) ` I \\<down>\\<le> t &&&\n     ((\\<lambda>n. n + k) ` I) \\<down>< (t + k) =\n     (\\<lambda>n. n + k) ` I \\<down>< t) &&&\n    ((\\<lambda>n. n + k) ` I) \\<down>\\<ge> (t + k) =\n    (\\<lambda>n. n + k) ` I \\<down>\\<ge> t &&&\n    ((\\<lambda>n. n + k) ` I) \\<down>> (t + k) =\n    (\\<lambda>n. n + k) ` I \\<down>> t", "by fastforce+"], ["", "lemma iT_Plus_cut_le: \"\n  (I \\<oplus> k) \\<down>\\<le> t = (if t < k then {} else I \\<down>\\<le> (t - k) \\<oplus> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus> k) \\<down>\\<le> t =\n    (if t < k then {} else I \\<down>\\<le> (t - k) \\<oplus> k)", "apply (case_tac \"t < k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>\\<le> t =\n    (if t < k then {} else I \\<down>\\<le> (t - k) \\<oplus> k)\n 2. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>\\<le> t =\n    (if t < k then {} else I \\<down>\\<le> (t - k) \\<oplus> k)", "apply (simp add: cut_le_empty_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>\\<le> t =\n    (if t < k then {} else I \\<down>\\<le> (t - k) \\<oplus> k)", "apply (insert iT_Plus_cut_le2[of I k \"t - k\"], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_cut_less: \"(I \\<oplus> k) \\<down>< t = I \\<down>< (t - k) \\<oplus> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus> k) \\<down>< t = I \\<down>< (t - k) \\<oplus> k", "apply (case_tac \"t < k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>< t = I \\<down>< (t - k) \\<oplus> k\n 2. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>< t = I \\<down>< (t - k) \\<oplus> k", "apply (simp add: cut_less_0_empty iT_Plus_empty cut_less_empty_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>< t = I \\<down>< (t - k) \\<oplus> k", "apply (insert iT_Plus_cut_less2[of I k \"t - k\"], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_cut_ge: \"(I \\<oplus> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t - k) \\<oplus> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t - k) \\<oplus> k", "apply (case_tac \"t < k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t - k) \\<oplus> k\n 2. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t - k) \\<oplus> k", "apply (simp add: cut_ge_0_all cut_ge_all_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t - k) \\<oplus> k", "apply (insert iT_Plus_cut_ge2[of I k \"t - k\"], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_cut_greater: \"\n  (I \\<oplus> k) \\<down>> t = (if t < k then I \\<oplus> k else I \\<down>> (t - k) \\<oplus> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus> k) \\<down>> t =\n    (if t < k then I \\<oplus> k else I \\<down>> (t - k) \\<oplus> k)", "apply (case_tac \"t < k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>> t =\n    (if t < k then I \\<oplus> k else I \\<down>> (t - k) \\<oplus> k)\n 2. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>> t =\n    (if t < k then I \\<oplus> k else I \\<down>> (t - k) \\<oplus> k)", "apply (simp add: cut_greater_all_iff iT_Plus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t < k \\<Longrightarrow>\n    (I \\<oplus> k) \\<down>> t =\n    (if t < k then I \\<oplus> k else I \\<down>> (t - k) \\<oplus> k)", "apply (insert iT_Plus_cut_greater2[of I k \"t - k\"], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  iT_Mult_cut_le2:      \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<le> (t * k) = (I \\<down>\\<le> t) \\<otimes> k\" and\n  iT_Mult_cut_less2:    \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>< (t * k) = (I \\<down>< t) \\<otimes> k\" and\n  iT_Mult_cut_ge2:      \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> (t * k) = (I \\<down>\\<ge> t) \\<otimes> k\" and\n  iT_Mult_cut_greater2: \"0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>> (t * k) = (I \\<down>> t) \\<otimes> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < k \\<Longrightarrow>\n      (I \\<otimes> k) \\<down>\\<le> (t * k) =\n      I \\<down>\\<le> t \\<otimes> k) &&&\n     (0 < k \\<Longrightarrow>\n      (I \\<otimes> k) \\<down>< (t * k) = I \\<down>< t \\<otimes> k)) &&&\n    (0 < k \\<Longrightarrow>\n     (I \\<otimes> k) \\<down>\\<ge> (t * k) =\n     I \\<down>\\<ge> t \\<otimes> k) &&&\n    (0 < k \\<Longrightarrow>\n     (I \\<otimes> k) \\<down>> (t * k) = I \\<down>> t \\<otimes> k)", "unfolding iT_Mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < k \\<Longrightarrow>\n      ((\\<lambda>n. n * k) ` I) \\<down>\\<le> (t * k) =\n      (\\<lambda>n. n * k) ` I \\<down>\\<le> t) &&&\n     (0 < k \\<Longrightarrow>\n      ((\\<lambda>n. n * k) ` I) \\<down>< (t * k) =\n      (\\<lambda>n. n * k) ` I \\<down>< t)) &&&\n    (0 < k \\<Longrightarrow>\n     ((\\<lambda>n. n * k) ` I) \\<down>\\<ge> (t * k) =\n     (\\<lambda>n. n * k) ` I \\<down>\\<ge> t) &&&\n    (0 < k \\<Longrightarrow>\n     ((\\<lambda>n. n * k) ` I) \\<down>> (t * k) =\n     (\\<lambda>n. n * k) ` I \\<down>> t)", "by fastforce+"], ["", "lemma iT_Mult_cut_le: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<le> t = (I \\<down>\\<le> (t div k)) \\<otimes> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<otimes> k) \\<down>\\<le> t = I \\<down>\\<le> (t div k) \\<otimes> k", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff cut_le_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> x div k \\<in> I \\<and> x \\<le> t) =\n       (x mod k = 0 \\<and> x div k \\<in> I \\<and> x div k \\<le> t div k)", "apply (rule conj_cong, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> t) = (x div k \\<le> t div k)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I; x \\<le> t\\<rbrakk>\n       \\<Longrightarrow> x div k \\<le> t div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k\\<rbrakk>\n       \\<Longrightarrow> x \\<le> t", "apply (rule div_le_mod_le_imp_le, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_cut_less: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>< t =\n    (if t mod k = 0 then (I \\<down>< (t div k)) else I \\<down>< Suc (t div k)) \\<otimes> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<otimes> k) \\<down>< t =\n    (if t mod k = 0 then I \\<down>< (t div k)\n     else I \\<down>< Suc (t div k)) \\<otimes>\n    k", "apply (case_tac \"t mod k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; t mod k = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<down>< t =\n                      (if t mod k = 0 then I \\<down>< (t div k)\n                       else I \\<down>< Suc (t div k)) \\<otimes>\n                      k\n 2. \\<lbrakk>0 < k; t mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<down>< t =\n                      (if t mod k = 0 then I \\<down>< (t div k)\n                       else I \\<down>< Suc (t div k)) \\<otimes>\n                      k", "apply (clarsimp simp add: mult.commute[of k] iT_Mult_cut_less2 elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; t mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<down>< t =\n                      (if t mod k = 0 then I \\<down>< (t div k)\n                       else I \\<down>< Suc (t div k)) \\<otimes>\n                      k", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff cut_less_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k\\<rbrakk>\n       \\<Longrightarrow> (x mod k = 0 \\<and> x div k \\<in> I \\<and> x < t) =\n                         (x mod k = 0 \\<and>\n                          x div k \\<in> I \\<and> x div k < Suc (t div k))", "apply (rule conj_cong, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (x < t) = (x div k < Suc (t div k))", "apply (subst less_Suc_eq_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (x < t) = (x div k \\<le> t div k)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x < t\\<rbrakk>\n       \\<Longrightarrow> x div k \\<le> t div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k\\<rbrakk>\n       \\<Longrightarrow> x < t", "apply (rule div_le_mono, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k\\<rbrakk>\n       \\<Longrightarrow> x < t", "apply (rule ccontr, simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k; t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule le_imp_less_or_eq[of t], erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k; t < x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k; t = x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (fastforce dest: less_mod_0_imp_div_less[of t _ k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        x div k \\<le> t div k; t = x\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_cut_greater: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>> t = (I \\<down>> (t div k)) \\<otimes> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<otimes> k) \\<down>> t = I \\<down>> (t div k) \\<otimes> k", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff cut_greater_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < k \\<Longrightarrow>\n       (x mod k = 0 \\<and> x div k \\<in> I \\<and> t < x) =\n       (x mod k = 0 \\<and> x div k \\<in> I \\<and> t div k < x div k)", "apply (rule conj_cong, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (t < x) = (t div k < x div k)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I; t < x\\<rbrakk>\n       \\<Longrightarrow> t div k < x div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I;\n        t div k < x div k\\<rbrakk>\n       \\<Longrightarrow> t < x", "apply (simp add: less_mod_ge_imp_div_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I;\n        t div k < x div k\\<rbrakk>\n       \\<Longrightarrow> t < x", "apply (rule ccontr, simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; x mod k = 0; x div k \\<in> I; t div k < x div k;\n        x \\<le> t\\<rbrakk>\n       \\<Longrightarrow> False", "apply (fastforce dest: div_le_mono[of _ _ k])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_cut_ge: \"\n  0 < k \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> t =\n    (if t mod k = 0 then (I \\<down>\\<ge> (t div k)) else I \\<down>\\<ge> Suc (t div k)) \\<otimes> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<otimes> k) \\<down>\\<ge> t =\n    (if t mod k = 0 then I \\<down>\\<ge> (t div k)\n     else I \\<down>\\<ge> Suc (t div k)) \\<otimes>\n    k", "apply (case_tac \"t mod k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; t mod k = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> t =\n                      (if t mod k = 0 then I \\<down>\\<ge> (t div k)\n                       else I \\<down>\\<ge> Suc (t div k)) \\<otimes>\n                      k\n 2. \\<lbrakk>0 < k; t mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> t =\n                      (if t mod k = 0 then I \\<down>\\<ge> (t div k)\n                       else I \\<down>\\<ge> Suc (t div k)) \\<otimes>\n                      k", "apply (clarsimp simp add: mult.commute[of k] iT_Mult_cut_ge2 elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; t mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<down>\\<ge> t =\n                      (if t mod k = 0 then I \\<down>\\<ge> (t div k)\n                       else I \\<down>\\<ge> Suc (t div k)) \\<otimes>\n                      k", "apply (clarsimp simp: set_eq_iff iT_Mult_mem_iff cut_ge_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k\\<rbrakk>\n       \\<Longrightarrow> (x mod k = 0 \\<and>\n                          x div k \\<in> I \\<and> t \\<le> x) =\n                         (x mod k = 0 \\<and>\n                          x div k \\<in> I \\<and>\n                          Suc (t div k) \\<le> x div k)", "apply (rule conj_cong, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (t \\<le> x) = (Suc (t div k) \\<le> x div k)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> Suc (t div k) \\<le> x div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        Suc (t div k) \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> t \\<le> x", "apply (rule Suc_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> t div k < x div k\n 2. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        Suc (t div k) \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> t \\<le> x", "apply (simp add: le_mod_greater_imp_div_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        Suc (t div k) \\<le> x div k\\<rbrakk>\n       \\<Longrightarrow> t \\<le> x", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        Suc (t div k) \\<le> x div k; \\<not> t \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule Suc_le_lessD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I;\n        \\<not> t \\<le> x; t div k < x div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < k; 0 < t mod k; x mod k = 0; x div k \\<in> I; x < t;\n        t div k < x div k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (fastforce dest: div_le_mono[OF order_less_imp_le, of _ t k])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_cut_le2: \"k \\<le> t \\<Longrightarrow> (I \\<oplus>- k) \\<down>\\<le> (t - k) = (I \\<down>\\<le> t) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>\\<le> (t - k) = I \\<down>\\<le> t \\<oplus>- k", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>\\<le> (t - k) =\n    (\\<lambda>n. n - k) ` I \\<down>\\<le> t \\<down>\\<ge> k", "apply (simp add: i_cut_commute_disj[of \"(\\<down>\\<le>)\" \"(\\<down>\\<ge>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>\\<le> (t - k) =\n    (\\<lambda>x. x - k) ` I \\<down>\\<ge> k \\<down>\\<le> t", "apply (rule i_cut_image[OF sub_left_strict_mono_on])"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<le> t \\<Longrightarrow> I \\<down>\\<ge> k \\<subseteq> {k..}\n 2. k \\<le> t \\<Longrightarrow> t \\<in> {k..}", "apply (simp add: cut_ge_Int_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_cut_less2: \"(I \\<oplus>- k) \\<down>< (t - k) = (I \\<down>< t) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (case_tac \"t \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (simp add: cut_less_0_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> k \\<Longrightarrow> {} = I \\<down>< t \\<oplus>- k\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (case_tac \"I \\<down>< t = {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>t \\<le> k; I \\<down>< t = {}\\<rbrakk>\n    \\<Longrightarrow> {} = I \\<down>< t \\<oplus>- k\n 2. \\<lbrakk>t \\<le> k; I \\<down>< t \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {} = I \\<down>< t \\<oplus>- k\n 3. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (simp add: iT_Plus_neg_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<le> k; I \\<down>< t \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {} = I \\<down>< t \\<oplus>- k\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (rule sym, rule iT_Plus_neg_Max_less_empty[OF nat_cut_less_finite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<le> k; I \\<down>< t \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max (I \\<down>< t) < k\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (rule order_less_le_trans[OF cut_less_Max_less[OF nat_cut_less_finite]], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>< (t - k) = I \\<down>< t \\<oplus>- k", "apply (simp add: linorder_not_le iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>< (t - k) =\n    (\\<lambda>n. n - k) ` I \\<down>< t \\<down>\\<ge> k", "apply (simp add: i_cut_commute_disj[of \"(\\<down><)\" \"(\\<down>\\<ge>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>< (t - k) =\n    (\\<lambda>x. x - k) ` I \\<down>\\<ge> k \\<down>< t", "apply (rule i_cut_image[OF sub_left_strict_mono_on])"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < t \\<Longrightarrow> I \\<down>\\<ge> k \\<subseteq> {k..}\n 2. k < t \\<Longrightarrow> t \\<in> {k..}", "apply (simp add: cut_ge_Int_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_cut_ge2: \"(I \\<oplus>- k) \\<down>\\<ge> (t - k) = (I \\<down>\\<ge> t) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k) \\<down>\\<ge> (t - k) = I \\<down>\\<ge> t \\<oplus>- k", "apply (case_tac \"t \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>\\<ge> (t - k) = I \\<down>\\<ge> t \\<oplus>- k\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>\\<ge> (t - k) = I \\<down>\\<ge> t \\<oplus>- k", "apply (simp add: cut_ge_0_all iT_Plus_neg_cut_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> k \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>\\<ge> (t - k) = I \\<down>\\<ge> t \\<oplus>- k", "apply (simp add: linorder_not_le iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>\\<ge> (t - k) =\n    (\\<lambda>n. n - k) ` I \\<down>\\<ge> t \\<down>\\<ge> k", "apply (simp add: i_cut_commute_disj[of \"(\\<down>\\<ge>)\" \"(\\<down>\\<ge>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>\\<ge> (t - k) =\n    (\\<lambda>x. x - k) ` I \\<down>\\<ge> k \\<down>\\<ge> t", "apply (rule i_cut_image[OF sub_left_strict_mono_on])"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < t \\<Longrightarrow> I \\<down>\\<ge> k \\<subseteq> {k..}\n 2. k < t \\<Longrightarrow> t \\<in> {k..}", "apply (simp add: cut_ge_Int_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_cut_greater2: \"k \\<le> t \\<Longrightarrow> (I \\<oplus>- k) \\<down>> (t - k) = (I \\<down>> t) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow>\n    (I \\<oplus>- k) \\<down>> (t - k) = I \\<down>> t \\<oplus>- k", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>> (t - k) =\n    (\\<lambda>n. n - k) ` I \\<down>> t \\<down>\\<ge> k", "apply (simp add: i_cut_commute_disj[of \"(\\<down>>)\" \"(\\<down>\\<ge>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> t \\<Longrightarrow>\n    ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) \\<down>> (t - k) =\n    (\\<lambda>x. x - k) ` I \\<down>\\<ge> k \\<down>> t", "apply (rule i_cut_image[OF sub_left_strict_mono_on])"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<le> t \\<Longrightarrow> I \\<down>\\<ge> k \\<subseteq> {k..}\n 2. k \\<le> t \\<Longrightarrow> t \\<in> {k..}", "apply (simp add: cut_ge_Int_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_cut_le: \"(I \\<oplus>- k) \\<down>\\<le> t = I \\<down>\\<le> (t + k) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k) \\<down>\\<le> t = I \\<down>\\<le> (t + k) \\<oplus>- k", "by (insert iT_Plus_neg_cut_le2[of k \"t + k\" I, OF le_add2], simp)"], ["", "lemma iT_Plus_neg_cut_less: \"(I \\<oplus>- k) \\<down>< t = I \\<down>< (t + k) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k) \\<down>< t = I \\<down>< (t + k) \\<oplus>- k", "by (insert iT_Plus_neg_cut_less2[of I k \"t + k\"], simp)"], ["", "lemma iT_Plus_neg_cut_ge: \"(I \\<oplus>- k) \\<down>\\<ge> t = I \\<down>\\<ge> (t + k) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k) \\<down>\\<ge> t = I \\<down>\\<ge> (t + k) \\<oplus>- k", "by (insert iT_Plus_neg_cut_ge2[of I k \"t + k\"], simp)"], ["", "lemma iT_Plus_neg_cut_greater: \"(I \\<oplus>- k) \\<down>> t = I \\<down>> (t + k) \\<oplus>- k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<oplus>- k) \\<down>> t = I \\<down>> (t + k) \\<oplus>- k", "by (insert iT_Plus_neg_cut_greater2[of k \"t + k\" I], simp)"], ["", "lemma iT_Minus_cut_le2: \"t \\<le> k \\<Longrightarrow> (k \\<ominus> I) \\<down>\\<le> (k - t) = k \\<ominus> (I \\<down>\\<ge> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>\\<le> (k - t) = k \\<ominus> I \\<down>\\<ge> t", "by (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_cut_less2: \"(k \\<ominus> I) \\<down>< (k - t) = k \\<ominus> (I \\<down>> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I) \\<down>< (k - t) = k \\<ominus> I \\<down>> t", "by (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_cut_ge2: \"(k \\<ominus> I) \\<down>\\<ge> (k - t) = k \\<ominus> (I \\<down>\\<le> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I) \\<down>\\<ge> (k - t) = k \\<ominus> I \\<down>\\<le> t", "by (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_cut_greater2: \"t \\<le> k \\<Longrightarrow> (k \\<ominus> I) \\<down>> (k - t) = k \\<ominus> (I \\<down>< t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>> (k - t) = k \\<ominus> I \\<down>< t", "by (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_cut_le: \"(k \\<ominus> I) \\<down>\\<le> t = k \\<ominus> (I \\<down>\\<ge> (k - t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I) \\<down>\\<le> t = k \\<ominus> I \\<down>\\<ge> (k - t)", "by (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["", "lemma iT_Minus_cut_less: \"\n  (k \\<ominus> I) \\<down>< t = (if t \\<le> k then k \\<ominus> (I \\<down>> (k - t)) else k \\<ominus> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I) \\<down>< t =\n    (if t \\<le> k then k \\<ominus> I \\<down>> (k - t) else k \\<ominus> I)", "apply (case_tac \"t \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>< t =\n    (if t \\<le> k then k \\<ominus> I \\<down>> (k - t) else k \\<ominus> I)\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>< t =\n    (if t \\<le> k then k \\<ominus> I \\<down>> (k - t) else k \\<ominus> I)", "apply (cut_tac iT_Minus_cut_less2[of k I \"k - t\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>< t =\n    (if t \\<le> k then k \\<ominus> I \\<down>> (k - t) else k \\<ominus> I)", "apply (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_cut_ge: \"\n  (k \\<ominus> I) \\<down>\\<ge> t = (if t \\<le> k then k \\<ominus> (I \\<down>\\<le> (k - t)) else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I) \\<down>\\<ge> t =\n    (if t \\<le> k then k \\<ominus> I \\<down>\\<le> (k - t) else {})", "apply (case_tac \"t \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>\\<ge> t =\n    (if t \\<le> k then k \\<ominus> I \\<down>\\<le> (k - t) else {})\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>\\<ge> t =\n    (if t \\<le> k then k \\<ominus> I \\<down>\\<le> (k - t) else {})", "apply (cut_tac iT_Minus_cut_ge2[of k I \"k - t\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>\\<ge> t =\n    (if t \\<le> k then k \\<ominus> I \\<down>\\<le> (k - t) else {})", "apply (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_cut_greater: \"(k \\<ominus> I) \\<down>> t = k \\<ominus> (I \\<down>< (k - t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<ominus> I) \\<down>> t = k \\<ominus> I \\<down>< (k - t)", "apply (case_tac \"t \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>> t = k \\<ominus> I \\<down>< (k - t)\n 2. \\<not> t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>> t = k \\<ominus> I \\<down>< (k - t)", "apply (cut_tac iT_Minus_cut_greater2[of \"k - t\" k I], simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> k \\<Longrightarrow>\n    (k \\<ominus> I) \\<down>> t = k \\<ominus> I \\<down>< 0", "apply (fastforce simp: i_cut_mem_iff iT_Minus_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_cut_le: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<le> t = I \\<down>\\<le> (t * k + (k - Suc 0)) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>\\<le> t =\n    I \\<down>\\<le> (t * k + (k - Suc 0)) \\<oslash> k", "apply (simp add: set_eq_iff i_cut_mem_iff iT_Div_mem_iff Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    \\<forall>x.\n       ((\\<exists>xa. xa \\<in> I \\<and> xa div k = x) \\<and> x \\<le> t) =\n       (\\<exists>xa.\n           xa \\<in> I \\<and> xa \\<le> t * k + k - Suc 0 \\<and> xa div k = x)", "apply (fastforce simp: div_le_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_cut_less: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>< t = I \\<down>< (t * k) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>< t = I \\<down>< (t * k) \\<oslash> k", "apply (case_tac \"t = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; t = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<down>< t =\n                      I \\<down>< (t * k) \\<oslash> k\n 2. \\<lbrakk>0 < k; t \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<down>< t =\n                      I \\<down>< (t * k) \\<oslash> k", "apply (simp add: cut_less_0_empty iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; t \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<down>< t =\n                      I \\<down>< (t * k) \\<oslash> k", "apply (simp add: nat_cut_less_le_conv iT_Div_cut_le diff_mult_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_cut_ge: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t * k) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>\\<ge> t = I \\<down>\\<ge> (t * k) \\<oslash> k", "apply (simp add: set_eq_iff i_cut_mem_iff iT_Div_mem_iff Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    \\<forall>x.\n       ((\\<exists>xa. xa \\<in> I \\<and> xa div k = x) \\<and> t \\<le> x) =\n       (\\<exists>xa. xa \\<in> I \\<and> t * k \\<le> xa \\<and> xa div k = x)", "apply (fastforce simp: le_div_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_cut_greater: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>> t = I \\<down>> (t * k + (k - Suc 0)) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>> t =\n    I \\<down>> (t * k + (k - Suc 0)) \\<oslash> k", "by (simp add: nat_cut_ge_greater_conv[symmetric] iT_Div_cut_ge add.commute[of k])"], ["", "lemma iT_Div_cut_le2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<le> (t div k) = I \\<down>\\<le> (t - t mod k + (k - Suc 0)) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>\\<le> (t div k) =\n    I \\<down>\\<le> (t - t mod k + (k - Suc 0)) \\<oslash> k", "by (frule iT_Div_cut_le[of k I \"t div k\"], simp add: div_mult_cancel)"], ["", "lemma iT_Div_cut_less2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>< (t div k) = I \\<down>< (t - t mod k) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>< (t div k) =\n    I \\<down>< (t - t mod k) \\<oslash> k", "by (frule iT_Div_cut_less[of k I \"t div k\"], simp add: div_mult_cancel)"], ["", "lemma iT_Div_cut_ge2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>\\<ge> (t div k) = I \\<down>\\<ge> (t - t mod k) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>\\<ge> (t div k) =\n    I \\<down>\\<ge> (t - t mod k) \\<oslash> k", "by (frule iT_Div_cut_ge[of k I \"t div k\"], simp add: div_mult_cancel)"], ["", "lemma iT_Div_cut_greater2: \"\n  0 < k \\<Longrightarrow> (I \\<oslash> k) \\<down>> (t div k) = I \\<down>> (t - t mod k + (k - Suc 0)) \\<oslash> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (I \\<oslash> k) \\<down>> (t div k) =\n    I \\<down>> (t - t mod k + (k - Suc 0)) \\<oslash> k", "by (frule iT_Div_cut_greater[of k I \"t div k\"], simp add: div_mult_cancel)"], ["", "subsection \\<open>\\<open>inext\\<close> and \\<open>iprev\\<close> with interval operators\\<close>"], ["", "lemma iT_Plus_inext: \"inext (n + k) (I \\<oplus> k) = (inext n I) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext (n + k) (I \\<oplus> k) = inext n I + k", "by (unfold iT_Plus_def, rule inext_image2[OF add_right_strict_mono])"], ["", "lemma iT_Plus_iprev: \"iprev (n + k) (I \\<oplus> k) = (iprev n I) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev (n + k) (I \\<oplus> k) = iprev n I + k", "by (unfold iT_Plus_def, rule iprev_image2[OF add_right_strict_mono])"], ["", "lemma iT_Plus_inext2: \"k \\<le> n \\<Longrightarrow> inext n (I \\<oplus> k) = (inext (n - k) I) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow> inext n (I \\<oplus> k) = inext (n - k) I + k", "by (insert iT_Plus_inext[of \"n - k\" k I], simp)"], ["", "lemma iT_Plus_prev2: \"k \\<le> n \\<Longrightarrow> iprev n (I \\<oplus> k) = (iprev (n - k) I) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow> iprev n (I \\<oplus> k) = iprev (n - k) I + k", "by (insert iT_Plus_iprev[of \"n - k\" k I], simp)"], ["", "lemma iT_Mult_inext: \"inext (n * k) (I \\<otimes> k) = (inext n I) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext (n * k) (I \\<otimes> k) = inext n I * k", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow> inext (n * k) (I \\<otimes> k) = inext n I * k\n 2. I \\<noteq> {} \\<Longrightarrow>\n    inext (n * k) (I \\<otimes> k) = inext n I * k", "apply (simp add: iT_Mult_empty inext_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    inext (n * k) (I \\<otimes> k) = inext n I * k", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k = 0\\<rbrakk>\n    \\<Longrightarrow> inext (n * k) (I \\<otimes> k) = inext n I * k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> inext (n * k) (I \\<otimes> k) = inext n I * k", "apply (simp add: iT_Mult_0 iTILL_0 inext_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> inext (n * k) (I \\<otimes> k) = inext n I * k", "apply (simp add: iT_Mult_def inext_image2[OF mult_right_strict_mono])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_iprev: \"iprev (n * k) (I \\<otimes> k) = (iprev n I) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev (n * k) (I \\<otimes> k) = iprev n I * k", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow> iprev (n * k) (I \\<otimes> k) = iprev n I * k\n 2. I \\<noteq> {} \\<Longrightarrow>\n    iprev (n * k) (I \\<otimes> k) = iprev n I * k", "apply (simp add: iT_Mult_empty iprev_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    iprev (n * k) (I \\<otimes> k) = iprev n I * k", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k = 0\\<rbrakk>\n    \\<Longrightarrow> iprev (n * k) (I \\<otimes> k) = iprev n I * k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev (n * k) (I \\<otimes> k) = iprev n I * k", "apply (simp add: iT_Mult_0 iTILL_0 iprev_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev (n * k) (I \\<otimes> k) = iprev n I * k", "apply (simp add: iT_Mult_def iprev_image2[OF mult_right_strict_mono])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_inext2_if: \"\n  inext n (I \\<otimes> k) = (if n mod k = 0 then (inext (n div k) I) * k else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext n (I \\<otimes> k) =\n    (if n mod k = 0 then inext (n div k) I * k else n)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    inext n (I \\<otimes> k) =\n    (if n mod k = 0 then inext (n div k) I * k else n)\n 2. I \\<noteq> {} \\<Longrightarrow>\n    inext n (I \\<otimes> k) =\n    (if n mod k = 0 then inext (n div k) I * k else n)", "apply (simp add: iT_Mult_empty inext_empty div_mult_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    inext n (I \\<otimes> k) =\n    (if n mod k = 0 then inext (n div k) I * k else n)", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k = 0\\<rbrakk>\n    \\<Longrightarrow> inext n (I \\<otimes> k) =\n                      (if n mod k = 0 then inext (n div k) I * k else n)\n 2. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> inext n (I \\<otimes> k) =\n                      (if n mod k = 0 then inext (n div k) I * k else n)", "apply (simp add: iT_Mult_0 iTILL_0 inext_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> inext n (I \\<otimes> k) =\n                      (if n mod k = 0 then inext (n div k) I * k else n)", "apply (case_tac \"n mod k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0; n mod k = 0\\<rbrakk>\n    \\<Longrightarrow> inext n (I \\<otimes> k) =\n                      (if n mod k = 0 then inext (n div k) I * k else n)\n 2. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0; n mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> inext n (I \\<otimes> k) =\n                      (if n mod k = 0 then inext (n div k) I * k else n)", "apply (clarsimp simp: mult.commute[of k] iT_Mult_inext elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0; n mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> inext n (I \\<otimes> k) =\n                      (if n mod k = 0 then inext (n div k) I * k else n)", "apply (simp add: not_in_inext_fix iT_Mult_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_iprev2_if: \"\n  iprev n (I \\<otimes> k) = (if n mod k = 0 then (iprev (n div k) I) * k else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev n (I \\<otimes> k) =\n    (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    iprev n (I \\<otimes> k) =\n    (if n mod k = 0 then iprev (n div k) I * k else n)\n 2. I \\<noteq> {} \\<Longrightarrow>\n    iprev n (I \\<otimes> k) =\n    (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (simp add: iT_Mult_empty iprev_empty div_mult_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    iprev n (I \\<otimes> k) =\n    (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k = 0\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<otimes> k) =\n                      (if n mod k = 0 then iprev (n div k) I * k else n)\n 2. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<otimes> k) =\n                      (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (simp add: iT_Mult_0 iTILL_0 iprev_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<otimes> k) =\n                      (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (case_tac \"n mod k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0; n mod k = 0\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<otimes> k) =\n                      (if n mod k = 0 then iprev (n div k) I * k else n)\n 2. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0; n mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<otimes> k) =\n                      (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (clarsimp simp: mult.commute[of k] iT_Mult_iprev elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<noteq> 0; n mod k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<otimes> k) =\n                      (if n mod k = 0 then iprev (n div k) I * k else n)", "apply (simp add: not_in_iprev_fix iT_Mult_mem_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Mult_inext2: \"\n  n mod k = 0 \\<Longrightarrow> inext n (I \\<otimes> k) = (inext (n div k) I) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod k = 0 \\<Longrightarrow>\n    inext n (I \\<otimes> k) = inext (n div k) I * k", "by (simp add: iT_Mult_inext2_if)"], ["", "corollary iT_Mult_iprev2: \"\n  n mod k = 0 \\<Longrightarrow> iprev n (I \\<otimes> k) = (iprev (n div k) I) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod k = 0 \\<Longrightarrow>\n    iprev n (I \\<otimes> k) = iprev (n div k) I * k", "by (simp add: iT_Mult_iprev2_if)"], ["", "lemma iT_Plus_neg_inext: \"\n  k \\<le> n \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n \\<Longrightarrow>\n    inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I = {}\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (simp add: iT_Plus_neg_empty inext_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (case_tac \"n \\<in> I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k)\n                       ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) =\n                      inext n I - k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (rule subst[OF inext_cut_ge_conv, of k], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k)\n                       ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) =\n                      inext n (I \\<down>\\<ge> k) - k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (rule inext_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> n \\<in> I \\<down>\\<ge> k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k)\n                       (I \\<down>\\<ge> k)\n 3. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (simp add: cut_ge_mem_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k)\n                       (I \\<down>\\<ge> k)\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (subst cut_ge_Int_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k)\n                       (I \\<inter> {k..})\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (rule strict_mono_on_subset[OF _ Int_lower2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k) {k..}\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (rule sub_left_strict_mono_on)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (subgoal_tac \"n - k \\<notin> I \\<oplus>- k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I;\n     n - k \\<notin> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> n - k \\<notin> I \\<oplus>- k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> n - k \\<notin> I \\<oplus>- k\n 2. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I;\n     n - k \\<notin> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (simp add: iT_Plus_neg_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> n; I \\<noteq> {}; n \\<notin> I;\n     n - k \\<notin> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> inext (n - k) (I \\<oplus>- k) = inext n I - k", "apply (simp add: not_in_inext_fix)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_iprev: \"\n  iprev (n - k) (I \\<oplus>- k) = iprev n (I \\<down>\\<ge> k) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev (n - k) (I \\<oplus>- k) = iprev n (I \\<down>\\<ge> k) - k", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. I = {} \\<Longrightarrow>\n    iprev (n - k) (I \\<oplus>- k) = iprev n (I \\<down>\\<ge> k) - k\n 2. I \\<noteq> {} \\<Longrightarrow>\n    iprev (n - k) (I \\<oplus>- k) = iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: iT_Plus_neg_empty i_cut_empty iprev_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    iprev (n - k) (I \\<oplus>- k) = iprev n (I \\<down>\\<ge> k) - k", "apply (case_tac \"n < k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; n < k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k\n 2. \\<lbrakk>I \\<noteq> {}; \\<not> n < k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: iprev_le_iMin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; n < k\\<rbrakk>\n    \\<Longrightarrow> iprev n (I \\<down>\\<ge> k) \\<le> k\n 2. \\<lbrakk>I \\<noteq> {}; \\<not> n < k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: order_trans[OF iprev_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; \\<not> n < k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (case_tac \"n \\<in> I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (frule iT_Plus_neg_mem_iff2[THEN iffD2, of _ _ I], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> (\\<lambda>n. n - k) ` I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k)\n                       ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) =\n                      iprev n (I \\<down>\\<ge> k) - k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (rule iprev_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> (\\<lambda>n. n - k) ` I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> n \\<in> I \\<down>\\<ge> k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> (\\<lambda>n. n - k) ` I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k)\n                       (I \\<down>\\<ge> k)\n 3. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: cut_ge_mem_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> (\\<lambda>n. n - k) ` I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k)\n                       (I \\<down>\\<ge> k)\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (subst cut_ge_Int_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> (\\<lambda>n. n - k) ` I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k)\n                       (I \\<inter> {k..})\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (rule strict_mono_on_subset[OF _ Int_lower2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<in> I;\n     n - k \\<in> (\\<lambda>n. n - k) ` I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> SetInterval2.strict_mono_on (\\<lambda>n. n - k) {k..}\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (rule sub_left_strict_mono_on)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (frule cut_ge_not_in_imp[of _ _ k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I;\n     n \\<notin> I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (subgoal_tac \"n - k \\<notin> I \\<oplus>- k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I;\n     n \\<notin> I \\<down>\\<ge> k; n - k \\<notin> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I;\n     n \\<notin> I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> n - k \\<notin> I \\<oplus>- k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I;\n     n \\<notin> I \\<down>\\<ge> k\\<rbrakk>\n    \\<Longrightarrow> n - k \\<notin> I \\<oplus>- k\n 2. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I;\n     n \\<notin> I \\<down>\\<ge> k; n - k \\<notin> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: iT_Plus_neg_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; k \\<le> n; n \\<notin> I;\n     n \\<notin> I \\<down>\\<ge> k; n - k \\<notin> I \\<oplus>- k\\<rbrakk>\n    \\<Longrightarrow> iprev (n - k) (I \\<oplus>- k) =\n                      iprev n (I \\<down>\\<ge> k) - k", "apply (simp add: not_in_iprev_fix)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Plus_neg_inext2: \"inext n (I \\<oplus>- k) = inext (n + k) I - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inext n (I \\<oplus>- k) = inext (n + k) I - k", "by (insert iT_Plus_neg_inext[of k \"n + k\" I, OF le_add2], simp)"], ["", "corollary iT_Plus_neg_iprev2: \"iprev n (I \\<oplus>- k) = iprev (n + k) (I \\<down>\\<ge> k) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprev n (I \\<oplus>- k) = iprev (n + k) (I \\<down>\\<ge> k) - k", "by (insert iT_Plus_neg_iprev[of \"n + k\" k I], simp)"], ["", "lemma iT_Minus_inext: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (subgoal_tac \"iMin I \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> iMin I \\<le> k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> iMin I \\<le> k\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: iT_Minus_empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (subgoal_tac \"I \\<down>\\<le> k \\<noteq> {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<le> k \\<noteq> {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<le> k \\<noteq> {}\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: iT_Minus_empty_iff cut_le_Min_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (case_tac \"n \\<in> I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: iT_Minus_imirror_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n     n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n                        iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: iT_Plus_neg_inext2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n     n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k)) - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (subgoal_tac \"n \\<le> iMin I + Max (I \\<down>\\<le> k)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k)) - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n     n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> n \\<le> iMin I + Max (I \\<down>\\<le> k)\n 3. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n     n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> n \\<le> iMin I + Max (I \\<down>\\<le> k)\n 2. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k)) - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 3. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (rule trans_le_add2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n     n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> n \\<le> Max (I \\<down>\\<le> k)\n 2. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k)) - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 3. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (rule Max_ge[OF nat_cut_le_finite])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {};\n     n \\<in> I\\<rbrakk>\n    \\<Longrightarrow> n \\<in> I \\<down>\\<le> k\n 2. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k)) - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 3. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: cut_le_mem_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k)) - n)\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: diff_add_assoc del: add_diff_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (k + (iMin I + Max (I \\<down>\\<le> k) - n))\n                       (imirror (I \\<down>\\<le> k) \\<oplus> k) -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (subst add.commute[of k], subst iT_Plus_inext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin I + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin I \\<le> k; I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin I + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext (iMin I + Max (I \\<down>\\<le> k) - n)\n                       (imirror (I \\<down>\\<le> k)) +\n                      k -\n                      (iMin I + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: cut_le_Min_eq[of I, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin (I \\<down>\\<le> k) \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> inext\n                       (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) -\n                        n)\n                       (imirror (I \\<down>\\<le> k)) +\n                      k -\n                      (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (fold nat_mirror_def mirror_elem_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin (I \\<down>\\<le> k) \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> nat_mirror\n                       (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k))\n                       (inext (mirror_elem n (I \\<down>\\<le> k))\n                         (imirror (I \\<down>\\<le> k)))\n                       k =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: inext_imirror_iprev_conv[OF nat_cut_le_finite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin (I \\<down>\\<le> k) \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> nat_mirror\n                       (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k))\n                       (mirror_elem (iprev n (I \\<down>\\<le> k))\n                         (I \\<down>\\<le> k))\n                       k =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: iprev_cut_le_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin (I \\<down>\\<le> k) \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> nat_mirror\n                       (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k))\n                       (mirror_elem (iprev n I) (I \\<down>\\<le> k)) k =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: mirror_elem_def nat_mirror_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin (I \\<down>\\<le> k) \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) -\n                      iprev n I +\n                      k -\n                      (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (frule iprev_mono[THEN order_trans, of n \"iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\" I])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>imirror (I \\<down>\\<le> k) \\<oplus> k \\<oplus>-\n             iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) \\<noteq>\n             {};\n     n \\<le> k; iMin (I \\<down>\\<le> k) \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<in> I;\n     n \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k);\n     iprev n I\n     \\<le> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k) -\n                      iprev n I +\n                      k -\n                      (iMin (I \\<down>\\<le> k) + Max (I \\<down>\\<le> k)) =\n                      k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (subgoal_tac \"k - n \\<notin> k \\<ominus> I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I;\n     k - n \\<notin> k \\<ominus> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> k - n \\<notin> k \\<ominus> I", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> k - n \\<notin> k \\<ominus> I\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I;\n     k - n \\<notin> k \\<ominus> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: iT_Minus_mem_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k; iMin I \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}; n \\<notin> I;\n     k - n \\<notin> k \\<ominus> I\\<rbrakk>\n    \\<Longrightarrow> inext (k - n) (k \\<ominus> I) = k - iprev n I", "apply (simp add: not_in_inext_fix not_in_iprev_fix)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Minus_inext2: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> inext n (k \\<ominus> I) = k - iprev (k - n) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> inext n (k \\<ominus> I) = k - iprev (k - n) I", "by (insert iT_Minus_inext[of k I \"k - n\"], simp)"], ["", "lemma iT_Minus_iprev: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> iprev (k - n) (k \\<ominus> I) = k - inext n (I \\<down>\\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I) =\n                      k - inext n (I \\<down>\\<le> k)", "apply (subgoal_tac \"I \\<down>\\<le> k \\<noteq> {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I) =\n                      k - inext n (I \\<down>\\<le> k)\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<le> k \\<noteq> {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<le> k \\<noteq> {}\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I) =\n                      k - inext n (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_empty_iff cut_le_Min_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I) =\n                      k - inext n (I \\<down>\\<le> k)", "apply (subst iT_Minus_cut_eq[OF le_refl, of _ I, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I \\<down>\\<le> k) =\n                      k - inext n (I \\<down>\\<le> k)", "apply (insert iT_Minus_inext2[of k \"k \\<ominus> (I \\<down>\\<le> k)\" n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {};\n     \\<lbrakk>k \\<ominus> (k \\<ominus> I \\<down>\\<le> k) \\<noteq> {};\n      n \\<le> k\\<rbrakk>\n     \\<Longrightarrow> inext n\n                        (k \\<ominus> (k \\<ominus> I \\<down>\\<le> k)) =\n                       k -\n                       iprev (k - n) (k \\<ominus> I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I \\<down>\\<le> k) =\n                      k - inext n (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_Minus_cut_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {};\n     inext n (I \\<down>\\<le> k) =\n     k - iprev (k - n) (k \\<ominus> I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I \\<down>\\<le> k) =\n                      k - (k - iprev (k - n) (k \\<ominus> I \\<down>\\<le> k))", "apply (rule diff_diff_cancel[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {};\n     inext n (I \\<down>\\<le> k) =\n     k - iprev (k - n) (k \\<ominus> I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> iprev (k - n) (k \\<ominus> I \\<down>\\<le> k) \\<le> k", "apply (rule order_trans[OF iprev_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k;\n     I \\<down>\\<le> k \\<noteq> {};\n     inext n (I \\<down>\\<le> k) =\n     k - iprev (k - n) (k \\<ominus> I \\<down>\\<le> k)\\<rbrakk>\n    \\<Longrightarrow> k - n \\<le> k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_iprev2: \"\n  \\<lbrakk> k \\<ominus> I \\<noteq> {}; n \\<le> k \\<rbrakk> \\<Longrightarrow> iprev n (k \\<ominus> I) = k - inext (k - n) (I \\<down>\\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> iprev n (k \\<ominus> I) =\n                      k - inext (k - n) (I \\<down>\\<le> k)", "by (insert iT_Minus_iprev[of k I \"k - n\"], simp)"], ["", "lemma iT_Plus_inext_nth: \"I \\<noteq> {} \\<Longrightarrow> (I \\<oplus> k) \\<rightarrow> n = (I \\<rightarrow> n) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<oplus> k) \\<rightarrow> n = (I \\<rightarrow> n) + k", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<oplus> k) \\<rightarrow> 0 = (I \\<rightarrow> 0) + k\n 2. \\<And>n.\n       \\<lbrakk>I \\<noteq> {} \\<Longrightarrow>\n                (I \\<oplus> k) \\<rightarrow> n = (I \\<rightarrow> n) + k;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus> k) \\<rightarrow> Suc n =\n                         (I \\<rightarrow> Suc n) + k", "apply (simp add: iT_Plus_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>I \\<noteq> {} \\<Longrightarrow>\n                (I \\<oplus> k) \\<rightarrow> n = (I \\<rightarrow> n) + k;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus> k) \\<rightarrow> Suc n =\n                         (I \\<rightarrow> Suc n) + k", "apply (simp add: iT_Plus_inext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_iprev_nth: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> n = (I \\<leftarrow> n) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> n = (I \\<leftarrow> n) + k", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> 0 = (I \\<leftarrow> 0) + k\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> n =\n                                  (I \\<leftarrow> n) + k;\n        finite I; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> Suc n =\n                         (I \\<leftarrow> Suc n) + k", "apply (simp add: iT_Plus_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> n =\n                                  (I \\<leftarrow> n) + k;\n        finite I; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus> k) \\<leftarrow> Suc n =\n                         (I \\<leftarrow> Suc n) + k", "apply (simp add: iT_Plus_iprev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_inext_nth: \"I \\<noteq> {} \\<Longrightarrow> (I \\<otimes> k) \\<rightarrow> n = (I \\<rightarrow> n) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<otimes> k) \\<rightarrow> n = (I \\<rightarrow> n) * k", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    (I \\<otimes> k) \\<rightarrow> 0 = (I \\<rightarrow> 0) * k\n 2. \\<And>n.\n       \\<lbrakk>I \\<noteq> {} \\<Longrightarrow>\n                (I \\<otimes> k) \\<rightarrow> n = (I \\<rightarrow> n) * k;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<otimes> k) \\<rightarrow> Suc n =\n                         (I \\<rightarrow> Suc n) * k", "apply (simp add: iT_Mult_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>I \\<noteq> {} \\<Longrightarrow>\n                (I \\<otimes> k) \\<rightarrow> n = (I \\<rightarrow> n) * k;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<otimes> k) \\<rightarrow> Suc n =\n                         (I \\<rightarrow> Suc n) * k", "apply (simp add: iT_Mult_inext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_iprev_nth: \"\\<lbrakk> finite I; I \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> n = (I \\<leftarrow> n) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) * k", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> 0 =\n                      (I \\<leftarrow> 0) * k\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> n =\n                                  (I \\<leftarrow> n) * k;\n        finite I; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> Suc n =\n                         (I \\<leftarrow> Suc n) * k", "apply (simp add: iT_Mult_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>finite I; I \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> n =\n                                  (I \\<leftarrow> n) * k;\n        finite I; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<otimes> k) \\<leftarrow> Suc n =\n                         (I \\<leftarrow> Suc n) * k", "apply (simp add: iT_Mult_iprev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_inext_nth: \"\n  I \\<oplus>- k \\<noteq> {} \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n = (I \\<down>\\<ge> k \\<rightarrow> n) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<oplus>- k \\<noteq> {} \\<Longrightarrow>\n    (I \\<oplus>- k) \\<rightarrow> n = (I \\<down>\\<ge> k \\<rightarrow> n) - k", "apply (subgoal_tac \"I \\<down>\\<ge> k \\<noteq> {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n =\n                      (I \\<down>\\<ge> k \\<rightarrow> n) - k\n 2. I \\<oplus>- k \\<noteq> {} \\<Longrightarrow> I \\<down>\\<ge> k \\<noteq> {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. I \\<oplus>- k \\<noteq> {} \\<Longrightarrow> I \\<down>\\<ge> k \\<noteq> {}\n 2. \\<lbrakk>I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n =\n                      (I \\<down>\\<ge> k \\<rightarrow> n) - k", "apply (simp add: cut_ge_not_empty_iff iT_Plus_neg_not_empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n =\n                      (I \\<down>\\<ge> k \\<rightarrow> n) - k", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> 0 =\n                      (I \\<down>\\<ge> k \\<rightarrow> 0) - k\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>I \\<oplus>- k \\<noteq> {};\n                 I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n =\n                                  (I \\<down>\\<ge> k \\<rightarrow> n) - k;\n        I \\<oplus>- k \\<noteq> {}; I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> Suc n =\n                         (I \\<down>\\<ge> k \\<rightarrow> Suc n) - k", "apply (simp add: iT_Plus_neg_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>I \\<oplus>- k \\<noteq> {};\n                 I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> n =\n                                  (I \\<down>\\<ge> k \\<rightarrow> n) - k;\n        I \\<oplus>- k \\<noteq> {}; I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus>- k) \\<rightarrow> Suc n =\n                         (I \\<down>\\<ge> k \\<rightarrow> Suc n) - k", "apply (simp add: iT_Plus_neg_cut_eq[of k k I, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(I \\<down>\\<ge> k \\<oplus>- k) \\<rightarrow> n =\n                (I \\<down>\\<ge> k \\<rightarrow> n) - k;\n        I \\<down>\\<ge> k \\<oplus>- k \\<noteq> {};\n        I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> inext ((I \\<down>\\<ge> k \\<rightarrow> n) - k)\n                          (I \\<down>\\<ge> k \\<oplus>- k) =\n                         inext (I \\<down>\\<ge> k \\<rightarrow> n)\n                          (I \\<down>\\<ge> k) -\n                         k", "apply (rule iT_Plus_neg_inext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(I \\<down>\\<ge> k \\<oplus>- k) \\<rightarrow> n =\n                (I \\<down>\\<ge> k \\<rightarrow> n) - k;\n        I \\<down>\\<ge> k \\<oplus>- k \\<noteq> {};\n        I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> k \\<le> I \\<down>\\<ge> k \\<rightarrow> n", "apply (rule cut_ge_bound[of _ I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(I \\<down>\\<ge> k \\<oplus>- k) \\<rightarrow> n =\n                (I \\<down>\\<ge> k \\<rightarrow> n) - k;\n        I \\<down>\\<ge> k \\<oplus>- k \\<noteq> {};\n        I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<ge> k \\<rightarrow> n\n                         \\<in> I \\<down>\\<ge> k", "apply (simp add: inext_nth_closed)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_iprev_nth: \"\n  \\<lbrakk> finite I; I \\<oplus>- k \\<noteq> {} \\<rbrakk> \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n = (I \\<down>\\<ge> k \\<leftarrow> n) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n =\n                      (I \\<down>\\<ge> k \\<leftarrow> n) - k", "apply (subgoal_tac \"I \\<down>\\<ge> k \\<noteq> {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n =\n                      (I \\<down>\\<ge> k \\<leftarrow> n) - k\n 2. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<ge> k \\<noteq> {}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<down>\\<ge> k \\<noteq> {}\n 2. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n =\n                      (I \\<down>\\<ge> k \\<leftarrow> n) - k", "apply (simp add: cut_ge_not_empty_iff iT_Plus_neg_not_empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n =\n                      (I \\<down>\\<ge> k \\<leftarrow> n) - k", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {};\n     I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> 0 =\n                      (I \\<down>\\<ge> k \\<leftarrow> 0) - k\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {};\n                 I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n =\n                                  (I \\<down>\\<ge> k \\<leftarrow> n) - k;\n        finite I; I \\<oplus>- k \\<noteq> {};\n        I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> Suc n =\n                         (I \\<down>\\<ge> k \\<leftarrow> Suc n) - k", "apply (simp add: iT_Plus_neg_Max cut_ge_Max_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>finite I; I \\<oplus>- k \\<noteq> {};\n                 I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> n =\n                                  (I \\<down>\\<ge> k \\<leftarrow> n) - k;\n        finite I; I \\<oplus>- k \\<noteq> {};\n        I \\<down>\\<ge> k \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<oplus>- k) \\<leftarrow> Suc n =\n                         (I \\<down>\\<ge> k \\<leftarrow> Suc n) - k", "apply (simp add: iT_Plus_neg_iprev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_inext_nth: \"\n  k \\<ominus> I \\<noteq> {} \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n = k - ((I \\<down>\\<le> k) \\<leftarrow> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> I \\<noteq> {} \\<Longrightarrow>\n    (k \\<ominus> I) \\<rightarrow> n = k - (I \\<down>\\<le> k \\<leftarrow> n)", "apply (subgoal_tac \"I \\<down>\\<le> k \\<noteq> {} \\<and> I \\<noteq> {} \\<and> iMin I \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {};\n     I \\<down>\\<le> k \\<noteq> {} \\<and>\n     I \\<noteq> {} \\<and> iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n =\n                      k - (I \\<down>\\<le> k \\<leftarrow> n)\n 2. k \\<ominus> I \\<noteq> {} \\<Longrightarrow>\n    I \\<down>\\<le> k \\<noteq> {} \\<and> I \\<noteq> {} \\<and> iMin I \\<le> k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<ominus> I \\<noteq> {} \\<Longrightarrow>\n    I \\<down>\\<le> k \\<noteq> {} \\<and> I \\<noteq> {} \\<and> iMin I \\<le> k\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {};\n     I \\<down>\\<le> k \\<noteq> {} \\<and>\n     I \\<noteq> {} \\<and> iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n =\n                      k - (I \\<down>\\<le> k \\<leftarrow> n)", "apply (simp add: iT_Minus_empty_iff cut_le_Min_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {};\n     I \\<down>\\<le> k \\<noteq> {} \\<and>\n     I \\<noteq> {} \\<and> iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n =\n                      k - (I \\<down>\\<le> k \\<leftarrow> n)", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n     I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n =\n                      k - (I \\<down>\\<le> k \\<leftarrow> n)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n     I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> 0 =\n                      k - (I \\<down>\\<le> k \\<leftarrow> 0)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>k \\<ominus> I \\<noteq> {};\n                 I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {};\n                 iMin I \\<le> k\\<rbrakk>\n                \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n =\n                                  k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> Suc n =\n                         k - (I \\<down>\\<le> k \\<leftarrow> Suc n)", "apply(simp add: iT_Minus_Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>k \\<ominus> I \\<noteq> {};\n                 I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {};\n                 iMin I \\<le> k\\<rbrakk>\n                \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> n =\n                                  k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (k \\<ominus> I) \\<rightarrow> Suc n =\n                         k - (I \\<down>\\<le> k \\<leftarrow> Suc n)", "apply (simp add: iT_Minus_cut_eq[OF order_refl, of _ I, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I \\<down>\\<le> k) \\<rightarrow> n =\n                k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<down>\\<le> k \\<noteq> {};\n        I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> inext (k - (I \\<down>\\<le> k \\<leftarrow> n))\n                          (k \\<ominus> I \\<down>\\<le> k) =\n                         k -\n                         iprev (I \\<down>\\<le> k \\<leftarrow> n)\n                          (I \\<down>\\<le> k)", "apply (rule iT_Minus_inext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I \\<down>\\<le> k) \\<rightarrow> n =\n                k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<down>\\<le> k \\<noteq> {};\n        I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> k \\<ominus> I \\<down>\\<le> k \\<noteq> {}\n 2. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I \\<down>\\<le> k) \\<rightarrow> n =\n                k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<down>\\<le> k \\<noteq> {};\n        I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<le> k \\<leftarrow> n \\<le> k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I \\<down>\\<le> k) \\<rightarrow> n =\n                k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<down>\\<le> k \\<noteq> {};\n        I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<le> k \\<leftarrow> n \\<le> k", "apply (rule cut_le_bound, rule iprev_nth_closed[OF nat_cut_le_finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I \\<down>\\<le> k) \\<rightarrow> n =\n                k - (I \\<down>\\<le> k \\<leftarrow> n);\n        k \\<ominus> I \\<down>\\<le> k \\<noteq> {};\n        I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<le> k \\<noteq> {}", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_iprev_nth: \"\n  k \\<ominus> I \\<noteq> {} \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n = k - ((I \\<down>\\<le> k) \\<rightarrow> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<ominus> I \\<noteq> {} \\<Longrightarrow>\n    (k \\<ominus> I) \\<leftarrow> n = k - (I \\<down>\\<le> k \\<rightarrow> n)", "apply (subgoal_tac \"I \\<down>\\<le> k \\<noteq> {} \\<and> I \\<noteq> {} \\<and> iMin I \\<le> k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {};\n     I \\<down>\\<le> k \\<noteq> {} \\<and>\n     I \\<noteq> {} \\<and> iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n =\n                      k - (I \\<down>\\<le> k \\<rightarrow> n)\n 2. k \\<ominus> I \\<noteq> {} \\<Longrightarrow>\n    I \\<down>\\<le> k \\<noteq> {} \\<and> I \\<noteq> {} \\<and> iMin I \\<le> k", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<ominus> I \\<noteq> {} \\<Longrightarrow>\n    I \\<down>\\<le> k \\<noteq> {} \\<and> I \\<noteq> {} \\<and> iMin I \\<le> k\n 2. \\<lbrakk>k \\<ominus> I \\<noteq> {};\n     I \\<down>\\<le> k \\<noteq> {} \\<and>\n     I \\<noteq> {} \\<and> iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n =\n                      k - (I \\<down>\\<le> k \\<rightarrow> n)", "apply (simp add: iT_Minus_empty_iff cut_le_Min_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {};\n     I \\<down>\\<le> k \\<noteq> {} \\<and>\n     I \\<noteq> {} \\<and> iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n =\n                      k - (I \\<down>\\<le> k \\<rightarrow> n)", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n     I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n =\n                      k - (I \\<down>\\<le> k \\<rightarrow> n)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n     I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> 0 =\n                      k - (I \\<down>\\<le> k \\<rightarrow> 0)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>k \\<ominus> I \\<noteq> {};\n                 I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {};\n                 iMin I \\<le> k\\<rbrakk>\n                \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n =\n                                  k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> Suc n =\n                         k - (I \\<down>\\<le> k \\<rightarrow> Suc n)", "apply(simp add: iT_Minus_Max cut_le_Min_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>k \\<ominus> I \\<noteq> {};\n                 I \\<down>\\<le> k \\<noteq> {}; I \\<noteq> {};\n                 iMin I \\<le> k\\<rbrakk>\n                \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> n =\n                                  k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> (k \\<ominus> I) \\<leftarrow> Suc n =\n                         k - (I \\<down>\\<le> k \\<rightarrow> Suc n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I) \\<leftarrow> n =\n                k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> iprev (k - (I \\<down>\\<le> k \\<rightarrow> n))\n                          (k \\<ominus> I) =\n                         k -\n                         inext (I \\<down>\\<le> k \\<rightarrow> n)\n                          (I \\<down>\\<le> k)", "apply (rule iT_Minus_iprev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I) \\<leftarrow> n =\n                k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> k \\<ominus> I \\<noteq> {}\n 2. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I) \\<leftarrow> n =\n                k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<le> k \\<rightarrow> n \\<le> k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I) \\<leftarrow> n =\n                k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<le> k \\<rightarrow> n \\<le> k", "apply (rule cut_le_bound, rule inext_nth_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(k \\<ominus> I) \\<leftarrow> n =\n                k - (I \\<down>\\<le> k \\<rightarrow> n);\n        k \\<ominus> I \\<noteq> {}; I \\<down>\\<le> k \\<noteq> {};\n        I \\<noteq> {}; iMin I \\<le> k\\<rbrakk>\n       \\<Longrightarrow> I \\<down>\\<le> k \\<noteq> {}", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_ge_inext_nth: \"\n  \\<lbrakk> I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<rightarrow> n = (I \\<rightarrow> n) div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k\n 2. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "apply (simp add: iT_Div_0 iTILL_0 inext_nth_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "apply (simp add: iT_Div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     0 < k\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>n. n div k) ` I) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "by (rule inext_nth_image[OF _ div_right_strict_mono_on])"], ["", "lemma iT_Div_mod_inext_nth: \"\n  \\<lbrakk> I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<rightarrow> n = (I \\<rightarrow> n) div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k; k = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k\n 2. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "apply (simp add: iT_Div_0 iTILL_0 inext_nth_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "apply (simp add: iT_Div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k; 0 < k\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>n. n div k) ` I) \\<rightarrow> n =\n                      (I \\<rightarrow> n) div k", "by (rule inext_nth_image[OF _ mod_eq_div_right_strict_mono_on])"], ["", "lemma iT_Div_ge_iprev_nth: \"\n  \\<lbrakk> finite I; I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<leftarrow> n = (I \\<leftarrow> n) div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k\n 2. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "apply (simp add: iT_Div_0 iTILL_0 iprev_nth_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "apply (simp add: iT_Div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I.\n        \\<forall>y\\<in>I. x < y \\<longrightarrow> x + k \\<le> y;\n     0 < k\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>n. n div k) ` I) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "by (rule iprev_nth_image[OF _ _ div_right_strict_mono_on])"], ["", "lemma iT_Div_mod_iprev_nth: \"\n  \\<lbrakk> finite I; I \\<noteq> {}; \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k \\<rbrakk> \\<Longrightarrow>\n  (I \\<oslash> k) \\<leftarrow> n = (I \\<leftarrow> n) div k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k; k = 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k\n 2. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "apply (simp add: iT_Div_0 iTILL_0 iprev_nth_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k;\n     k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (I \\<oslash> k) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "apply (simp add: iT_Div_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; I \\<noteq> {};\n     \\<forall>x\\<in>I. \\<forall>y\\<in>I. x mod k = y mod k; 0 < k\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>n. n div k) ` I) \\<leftarrow> n =\n                      (I \\<leftarrow> n) div k", "by (rule iprev_nth_image[OF _ _ mod_eq_div_right_strict_mono_on])"], ["", "subsection \\<open>Cardinality of intervals with interval operators\\<close>"], ["", "lemma iT_Plus_card: \"card (I \\<oplus> k) = card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (I \\<oplus> k) = card I", "apply (unfold iT_Plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>n. n + k) ` I) = card I", "apply (rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. n + k) I", "apply (rule inj_imp_inj_on)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>n. n + k)", "apply (rule add_right_inj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Mult_card: \"0 < k \\<Longrightarrow> card (I \\<otimes> k) = card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> card (I \\<otimes> k) = card I", "apply (unfold iT_Mult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> card ((\\<lambda>n. n * k) ` I) = card I", "apply (rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> inj_on (\\<lambda>n. n * k) I", "apply (rule inj_imp_inj_on)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> inj (\\<lambda>n. n * k)", "apply (rule mult_right_inj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> 0 < k", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_card: \"card (I \\<oplus>- k) = card (I \\<down>\\<ge> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (I \\<oplus>- k) = card (I \\<down>\\<ge> k)", "apply (simp add: iT_Plus_neg_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>n. n - k) ` I \\<down>\\<ge> k) = card (I \\<down>\\<ge> k)", "apply (rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. n - k) (I \\<down>\\<ge> k)", "apply (subst cut_ge_Int_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. n - k) (I \\<inter> {k..})", "apply (rule subset_inj_on[OF _ Int_lower2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. n - k) {k..}", "apply (rule sub_left_inj_on)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_card_le: \"card (I \\<oplus>- k) \\<le> card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (I \\<oplus>- k) \\<le> card I", "apply (simp add: iT_Plus_neg_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (I \\<down>\\<ge> k) \\<le> card I", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow> card (I \\<down>\\<ge> k) \\<le> card I\n 2. infinite I \\<Longrightarrow> card (I \\<down>\\<ge> k) \\<le> card I", "apply (rule cut_ge_card, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow> card (I \\<down>\\<ge> k) \\<le> card I", "apply (simp add: nat_cut_ge_finite_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_card: \"card (k \\<ominus> I) = card (I \\<down>\\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (k \\<ominus> I) = card (I \\<down>\\<le> k)", "apply (simp add: iT_Minus_image_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((-) k ` I \\<down>\\<le> k) = card (I \\<down>\\<le> k)", "apply (rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) k) (I \\<down>\\<le> k)", "apply (subst cut_le_Int_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) k) (I \\<inter> {..k})", "apply (rule subset_inj_on[OF _ Int_lower2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) k) {..k}", "apply (rule sub_right_inj_on)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_card_le: \"finite I \\<Longrightarrow> card (k \\<ominus> I) \\<le> card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> card (k \\<ominus> I) \\<le> card I", "by (subst iT_Minus_card, rule cut_le_card)"], ["", "lemma iT_Div_0_card_if: \"\n  card (I \\<oslash> 0) = (if I ={} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (I \\<oslash> 0) = (if I = {} then 0 else Suc 0)", "by (fastforce simp: iT_Div_empty iT_Div_0 iTILL_0)"], ["", "lemma Int_empty_sum:\"\n  (\\<Sum>k\\<le>(n::nat). if {} \\<inter> (I k) = {} then 0 else Suc 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n. if {} \\<inter> I k = {} then 0 else Suc 0) = 0", "apply (rule sum_eq_0_iff[THEN iffD2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {..n}\n 2. \\<forall>a\\<in>{..n}. (if {} \\<inter> I a = {} then 0 else Suc 0) = 0", "apply (rule finite_atMost)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{..n}. (if {} \\<inter> I a = {} then 0 else Suc 0) = 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_mod_partition_card:\"\n  card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n  (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (case_tac \"d = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (simp add: iIN_0 iTILL_0 iT_Div_0_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow>\n    card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (split if_split, rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d \\<noteq> 0 \\<Longrightarrow>\n    I \\<inter> [n * d\\<dots>,d - Suc 0] = {} \\<longrightarrow>\n    card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) = 0\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {} \\<longrightarrow>\n    card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) = Suc 0", "apply (simp add: iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow>\n    I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {} \\<longrightarrow>\n    card (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) = Suc 0", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> card\n                       (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n                      Suc 0", "apply (subgoal_tac \"I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d = {n}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d = {n}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < d;\n        I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> I \\<inter>\n                                  [n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d) =\n                         (x \\<in> {n})", "apply (simp add: iT_Div_mem_iff Bex_def iIN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < d;\n        I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xa.\n                             xa \\<in> I \\<and>\n                             n * d \\<le> xa \\<and>\n                             xa \\<le> n * d + d - Suc 0 \\<and>\n                             xa div d = x) =\n                         (x = n)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        \\<exists>xa.\n           xa \\<in> I \\<and>\n           n * d \\<le> xa \\<and>\n           xa \\<le> n * d + d - Suc 0 \\<and> xa div d = x\\<rbrakk>\n       \\<Longrightarrow> x = n\n 2. \\<And>x.\n       \\<lbrakk>0 < d; I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        x = n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and>\n                            n * d \\<le> xa \\<and>\n                            xa \\<le> n * d + d - Suc 0 \\<and> xa div d = x", "apply (clarsimp simp: le_less_imp_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; I \\<inter> [n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        x = n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            xa \\<in> I \\<and>\n                            n * d \\<le> xa \\<and>\n                            xa \\<le> n * d + d - Suc 0 \\<and> xa div d = x", "apply (drule ex_in_conv[THEN iffD2], clarsimp simp: iIN_iff, rename_tac x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>0 < d; x' \\<in> I; n * d \\<le> x';\n        x' \\<le> n * d + d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> I \\<and>\n                            n * d \\<le> x \\<and>\n                            x \\<le> n * d + d - Suc 0 \\<and> x div d = n", "apply (rule_tac x=x' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>0 < d; x' \\<in> I; n * d \\<le> x';\n        x' \\<le> n * d + d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x' \\<in> I \\<and>\n                         n * d \\<le> x' \\<and>\n                         x' \\<le> n * d + d - Suc 0 \\<and> x' div d = n", "apply (simp add: le_less_imp_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_conv_count: \"\n  0 < d \\<Longrightarrow> I \\<oslash> d = {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    I \\<oslash> d = {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d; I = {}\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d =\n                      {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\n 2. \\<lbrakk>0 < d; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d =\n                      {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}", "apply (simp add: iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d =\n                      {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> I \\<oslash> d) =\n                         (x \\<in> {k. I \\<inter>\n[k * d\\<dots>,d - Suc 0] \\<noteq>\n{}})", "apply (simp add: iT_Div_mem_iff_Int)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_conv_count2: \"\n  \\<lbrakk> 0 < d; finite I; Max I div d \\<le> n \\<rbrakk> \\<Longrightarrow>\n  I \\<oslash> d = {k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d =\n                      {k. k \\<le> n \\<and>\n                          I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}", "apply (simp add: iT_Div_conv_count)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n    \\<Longrightarrow> {k. I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                      {k. k \\<le> n \\<and>\n                          I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}", "apply (rule set_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n                         (x \\<le> n \\<and>\n                          I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n \\<and>\n                         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> x \\<le> n\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {};\n        \\<not> x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply (drule ex_in_conv[THEN iffD2], clarify, rename_tac x')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n; \\<not> x \\<le> n;\n        x' \\<in> I; x' \\<in> [x * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply (clarsimp simp: linorder_not_le iIN_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n; n < x; x' \\<in> I;\n        x * d \\<le> x'; x' \\<le> x * d + d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply (drule order_le_less_trans, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>0 < d; finite I; n < x; x' \\<in> I; x * d \\<le> x';\n        x' \\<le> x * d + d - Suc 0; Max I div d < x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply (drule div_less_conv[THEN iffD1, of _ \"Max I\"], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>finite I; n < x; x' \\<in> I; x * d \\<le> x';\n        x' \\<le> x * d + d - Suc 0; Max I div d < x; Max I < x * d\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply (drule_tac x=x' in Max_ge, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>n < x; x' \\<in> I; x * d \\<le> x';\n        x' \\<le> x * d + d - Suc 0; Max I div d < x; Max I < x * d;\n        x' \\<le> Max I\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n        x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_partition_count_Suc: \"\n  {k. k \\<le> Suc n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n  {k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} \\<union>\n    (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {} then {Suc n} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k. k \\<le> Suc n \\<and>\n        I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n    {k. k \\<le> n \\<and>\n        I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} \\<union>\n    (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {} then {Suc n}\n     else {})", "apply (rule set_eqI, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {k. k \\<le> Suc n \\<and>\n                    I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}) =\n       (x \\<in> {k. k \\<le> n \\<and>\n                    I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                    {}} \\<union>\n                (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\n                 then {Suc n} else {}))", "apply (simp add: le_less[of _ \"Suc n\"] less_Suc_eq_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq>\n        {} \\<longrightarrow>\n        ((x \\<le> n \\<or> x = Suc n) \\<and>\n         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n        (x \\<le> n \\<and>\n         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n         x = Suc n)) \\<and>\n       (I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} \\<longrightarrow>\n        ((x \\<le> n \\<or> x = Suc n) \\<and>\n         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n        (x \\<le> n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}))", "apply (simp add: conj_disj_distribR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq>\n        {} \\<longrightarrow>\n        (x \\<le> n \\<and>\n         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n         x = Suc n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n        (x \\<le> n \\<and>\n         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n         x = Suc n)) \\<and>\n       (I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} \\<longrightarrow>\n        (x \\<le> n \\<and>\n         I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n         x = Suc n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n        (x \\<le> n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {} \\<Longrightarrow>\n       (x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n        x = Suc n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n       (x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n        x = Suc n)\n 2. \\<And>x.\n       I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} \\<Longrightarrow>\n       (x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n        x = Suc n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n       (x \\<le> n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {})", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} \\<Longrightarrow>\n       (x \\<le> n \\<and>\n        I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {} \\<or>\n        x = Suc n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {}) =\n       (x \\<le> n \\<and> I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {})", "apply (rule iffI, clarsimp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_card: \"\n  \\<And>I.\\<lbrakk> 0 < d; finite I; Max I div d \\<le> n\\<rbrakk> \\<Longrightarrow>\n  card (I \\<oslash> d) = (\\<Sum>k\\<le>n.\n    if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card (I \\<oslash> d) =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n; I = {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<oslash> d) =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<oslash> d) =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<oslash> d) =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: iT_Div_conv_count2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> 0; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> 0 \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>0.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: div_eq_0_conv iIN_0_iTILL_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>d - Suc 0] =\n                          {} \\<longrightarrow>\n                          (\\<forall>x.\n                              0 < x \\<or>\n                              I \\<inter> [x * d\\<dots>,d - Suc 0] =\n                              {})) \\<and>\n                         (I \\<inter> [\\<dots>d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card\n                           {k. k = 0 \\<and>\n                               I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subgoal_tac \"I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d; I \\<noteq> {};\n        I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>d - Suc 0] =\n                          {} \\<longrightarrow>\n                          (\\<forall>x.\n                              0 < x \\<or>\n                              I \\<inter> [x * d\\<dots>,d - Suc 0] =\n                              {})) \\<and>\n                         (I \\<inter> [\\<dots>d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card\n                           {k. k = 0 \\<and>\n                               I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          Suc 0)\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d;\n        I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d; I \\<noteq> {};\n        I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>d - Suc 0] =\n                          {} \\<longrightarrow>\n                          (\\<forall>x.\n                              0 < x \\<or>\n                              I \\<inter> [x * d\\<dots>,d - Suc 0] =\n                              {})) \\<and>\n                         (I \\<inter> [\\<dots>d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card\n                           {k. k = 0 \\<and>\n                               I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          Suc 0)\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: ex_in_conv[symmetric], fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d; I \\<noteq> {};\n        I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>d - Suc 0] =\n                          {} \\<longrightarrow>\n                          (\\<forall>x.\n                              0 < x \\<or>\n                              I \\<inter> [x * d\\<dots>,d - Suc 0] =\n                              {})) \\<and>\n                         (I \\<inter> [\\<dots>d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card\n                           {k. k = 0 \\<and>\n                               I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: card_1_singleton_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d; I \\<noteq> {};\n        I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            {k. k = 0 \\<and>\n                                I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                                {}} =\n                            {a}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d; I \\<noteq> {};\n        I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> {k. k = 0 \\<and>\n                             I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                             {}} =\n                         {0}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (rule set_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I x.\n       \\<lbrakk>0 < d; finite I; \\<forall>a\\<in>I. a < d; I \\<noteq> {};\n        I \\<inter> [\\<dots>d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> {k. k = 0 \\<and>\nI \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}) =\n                         (x \\<in> {0})\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: ex_in_conv[symmetric], fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> Suc n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [d + n * d\\<dots>,d - Suc 0] =\n                          {} \\<longrightarrow>\n                          card\n                           {k. k \\<le> Suc n \\<and>\n                               I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                              then 0 else Suc 0)) \\<and>\n                         (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card\n                           {k. k \\<le> Suc n \\<and>\n                               I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          Suc (\\<Sum>k\\<le>n.\n                                  if I \\<inter> [k * d\\<dots>,d - Suc 0] =\n                                     {}\n                                  then 0 else Suc 0))", "apply (simp add: mod_partition_count_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n;\n                    I \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> card\n{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} =\n                                     (\\<Sum>k\\<le>n.\n   if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (drule_tac x=\"I \\<inter> [\\<dots>n * d + d - Suc 0]\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>finite (I \\<inter> [\\<dots>n * d + d - Suc 0]);\n         Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0)\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (case_tac \"I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subgoal_tac \"{k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}} = {}\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\\<rbrakk>\n       \\<Longrightarrow> {k. k \\<le> n \\<and>\n                             I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                             {}} =\n                         {}\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (clarsimp, rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}; x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0] = {}\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subgoal_tac \"I \\<inter> [x * d\\<dots>,d - Suc 0] \\<subseteq> I \\<inter> [\\<dots>n * d + d - Suc 0]\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}; x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [x * d\\<dots>,d - Suc 0]\n                         \\<subseteq> I \\<inter> [\\<dots>n * d + d - Suc 0]\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (rule Int_mono[OF order_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}; x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> [x * d\\<dots>,d - Suc 0]\n                         \\<subseteq> [\\<dots>n * d + d - Suc 0]\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: iIN_iTILL_subset_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}; x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> x * d + d - Suc 0 \\<le> n * d + d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: diff_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subgoal_tac \"Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d\n                         \\<le> n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d\n                         \\<le> n\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: div_le_conv add.commute[of d] iTILL_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subgoal_tac \"\\<And>k. k \\<le> n \\<Longrightarrow> [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] = [k * d\\<dots>,d - Suc 0]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>n I k.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n * d + d - Suc 0] \\<inter>\n                         [k * d\\<dots>,d - Suc 0] =\n                         [k * d\\<dots>,d - Suc 0]", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I k.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n * d + d - Suc 0] \\<inter>\n                         [k * d\\<dots>,d - Suc 0] =\n                         [k * d\\<dots>,d - Suc 0]\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subst Int_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I k.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> [k * d\\<dots>,d - Suc 0] \\<inter>\n                         [\\<dots>n * d + d - Suc 0] =\n                         [k * d\\<dots>,d - Suc 0]\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: iTILL_def cut_le_Int_conv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I k.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<down>\\<le> (n * d + d - Suc 0) \\<inter>\n             [k * d\\<dots>,d - Suc 0] \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<down>\\<le> (n * d + d - Suc 0) \\<inter>\n               [k * d\\<dots>,d - Suc 0] =\n               {}\n            then 0 else Suc 0);\n        I \\<down>\\<le> (n * d + d - Suc 0) \\<noteq> {};\n        Max (I \\<down>\\<le> (n * d + d - Suc 0)) div d \\<le> n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> [k * d\\<dots>,d - Suc 0] \\<down>\\<le>\n                         (n * d + d - Suc 0) =\n                         [k * d\\<dots>,d - Suc 0]\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (rule cut_le_Max_all[OF iIN_finite])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I k.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<down>\\<le> (n * d + d - Suc 0) \\<inter>\n             [k * d\\<dots>,d - Suc 0] \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<down>\\<le> (n * d + d - Suc 0) \\<inter>\n               [k * d\\<dots>,d - Suc 0] =\n               {}\n            then 0 else Suc 0);\n        I \\<down>\\<le> (n * d + d - Suc 0) \\<noteq> {};\n        Max (I \\<down>\\<le> (n * d + d - Suc 0)) div d \\<le> n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Max [k * d\\<dots>,d - Suc 0]\n                         \\<le> n * d + d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: iIN_Max diff_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        \\<lbrakk>Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n         I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card\n                           {k. k \\<le> n \\<and>\n                               I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<inter>\n                               [k * d\\<dots>,d - Suc 0] \\<noteq>\n                               {}} =\n                          (\\<Sum>k\\<le>n.\n                              if I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<inter>\n                                 [k * d\\<dots>,d - Suc 0] =\n                                 {}\n                              then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (simp add: Int_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (subgoal_tac \"\n  {k. k \\<le> n \\<and> I \\<inter> ([\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0]) \\<noteq> {}} =\n  {k. k \\<le> n \\<and> I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        {k. k \\<le> n \\<and>\n            I \\<inter>\n            ([\\<dots>n * d + d - Suc 0] \\<inter>\n             [k * d\\<dots>,d - Suc 0]) \\<noteq>\n            {}} =\n        {k. k \\<le> n \\<and>\n            I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> {k. k \\<le> n \\<and>\n                             I \\<inter>\n                             ([\\<dots>n * d + d - Suc 0] \\<inter>\n                              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n                             {}} =\n                         {k. k \\<le> n \\<and>\n                             I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                             {}}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> {k. k \\<le> n \\<and>\n                             I \\<inter>\n                             ([\\<dots>n * d + d - Suc 0] \\<inter>\n                              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n                             {}} =\n                         {k. k \\<le> n \\<and>\n                             I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                             {}}\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        {k. k \\<le> n \\<and>\n            I \\<inter>\n            ([\\<dots>n * d + d - Suc 0] \\<inter>\n             [k * d\\<dots>,d - Suc 0]) \\<noteq>\n            {}} =\n        {k. k \\<le> n \\<and>\n            I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (rule set_eqI, rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> {k. k \\<le> n \\<and>\nI \\<inter>\n([\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0]) \\<noteq>\n{}}) =\n                         (x \\<in> {k. k \\<le> n \\<and>\nI \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}})\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        {k. k \\<le> n \\<and>\n            I \\<inter>\n            ([\\<dots>n * d + d - Suc 0] \\<inter>\n             [k * d\\<dots>,d - Suc 0]) \\<noteq>\n            {}} =\n        {k. k \\<le> n \\<and>\n            I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> n \\<and>\n                          I \\<inter>\n                          ([\\<dots>n * d + d - Suc 0] \\<inter>\n                           [x * d\\<dots>,d - Suc 0]) \\<noteq>\n                          {}) =\n                         (x \\<le> n \\<and>\n                          I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {})\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        {k. k \\<le> n \\<and>\n            I \\<inter>\n            ([\\<dots>n * d + d - Suc 0] \\<inter>\n             [k * d\\<dots>,d - Suc 0]) \\<noteq>\n            {}} =\n        {k. k \\<le> n \\<and>\n            I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply (rule conj_cong, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter>\n                          ([\\<dots>n * d + d - Suc 0] \\<inter>\n                           [x * d\\<dots>,d - Suc 0]) \\<noteq>\n                          {}) =\n                         (I \\<inter> [x * d\\<dots>,d - Suc 0] \\<noteq> {})\n 2. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        {k. k \\<le> n \\<and>\n            I \\<inter>\n            ([\\<dots>n * d + d - Suc 0] \\<inter>\n             [k * d\\<dots>,d - Suc 0]) \\<noteq>\n            {}} =\n        {k. k \\<le> n \\<and>\n            I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> Suc n; I \\<noteq> {};\n        card\n         {k. k \\<le> n \\<and>\n             I \\<inter>\n             ([\\<dots>n * d + d - Suc 0] \\<inter>\n              [k * d\\<dots>,d - Suc 0]) \\<noteq>\n             {}} =\n        (\\<Sum>k\\<le>n.\n            if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        \\<And>k.\n           k \\<le> n \\<Longrightarrow>\n           [\\<dots>n * d + d - Suc 0] \\<inter> [k * d\\<dots>,d - Suc 0] =\n           [k * d\\<dots>,d - Suc 0];\n        {k. k \\<le> n \\<and>\n            I \\<inter>\n            ([\\<dots>n * d + d - Suc 0] \\<inter>\n             [k * d\\<dots>,d - Suc 0]) \\<noteq>\n            {}} =\n        {k. k \\<le> n \\<and>\n            I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {k. k \\<le> n \\<and>\n                              I \\<inter> [k * d\\<dots>,d - Suc 0] \\<noteq>\n                              {}} =\n                         (\\<Sum>k\\<le>n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Div_card_Suc: \"\n  \\<And>I.\\<lbrakk> 0 < d; finite I; Max I div d \\<le> n\\<rbrakk> \\<Longrightarrow>\n  card (I \\<oslash> d) = (\\<Sum>k<Suc n.\n    if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card (I \\<oslash> d) =\n                         (\\<Sum>k<Suc n.\n                             if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                             then 0 else Suc 0)", "by (simp add: lessThan_Suc_atMost iT_Div_card)"], ["", "corollary iT_Div_Max_card: \"\\<lbrakk> 0 < d; finite I \\<rbrakk> \\<Longrightarrow>\n  card (I \\<oslash> d) = (\\<Sum>k\\<le>Max I div d.\n    if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I\\<rbrakk>\n    \\<Longrightarrow> card (I \\<oslash> d) =\n                      (\\<Sum>k\\<le>Max I div d.\n                          if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0\n                          else Suc 0)", "by (simp add: iT_Div_card)"], ["", "lemma iT_Div_card_le: \"0 < k \\<Longrightarrow> card (I \\<oslash> k) \\<le> card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> card (I \\<oslash> k) \\<le> card I", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; finite I\\<rbrakk>\n    \\<Longrightarrow> card (I \\<oslash> k) \\<le> card I\n 2. \\<lbrakk>0 < k; infinite I\\<rbrakk>\n    \\<Longrightarrow> card (I \\<oslash> k) \\<le> card I", "apply (simp add: iT_Div_def card_image_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; infinite I\\<rbrakk>\n    \\<Longrightarrow> card (I \\<oslash> k) \\<le> card I", "apply (simp add: iT_Div_finite_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_card_inj_on: \"\n  inj_on (\\<lambda>n. n div k) I \\<Longrightarrow> card (I \\<oslash> k) = card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. n div k) I \\<Longrightarrow>\n    card (I \\<oslash> k) = card I", "by (unfold iT_Div_def, rule card_image)"], ["", "(*\nlemma \"let I=[\\<dots>19] in\n  d \\<in> {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21} \\<longrightarrow>\n  card I div d \\<le> card (I \\<oslash> d)\"\napply (simp add: Let_def iTILL_card iTILL_div)\ndone\nlemma \"let I=[\\<dots>19] in\n  d \\<in> {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21} \\<longrightarrow>\n  card I div d + (if card I mod d \\<noteq> 0 then 1 else 0) \\<le> card (I \\<oslash> d)\"\napply (simp add: Let_def iTILL_card iTILL_div)\ndone\nlemma \"let I=[5\\<dots>,19] in\n  d \\<in> {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21} \\<longrightarrow>\n  card I div d + (if card I mod d \\<noteq> 0 then 1 else 0) \\<le> card (I \\<oslash> d)\"\napply (simp add: Let_def iIN_card iIN_div)\ndone\n*)\n\n\n(* ToDo: to be moved to Util_Div *)"], ["", "lemma mod_Suc': \"\n  0 < n \\<Longrightarrow> Suc m mod n = (if m mod n < n - Suc 0 then Suc (m mod n) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    Suc m mod n = (if m mod n < n - Suc 0 then Suc (m mod n) else 0)", "apply (simp add: mod_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    (Suc (m mod n) = n \\<longrightarrow> \\<not> m mod n < n - Suc 0) \\<and>\n    (Suc (m mod n) \\<noteq> n \\<longrightarrow> m mod n < n - Suc 0)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; Suc (m mod n) = n\\<rbrakk>\n    \\<Longrightarrow> \\<not> m mod n < n - Suc 0\n 2. \\<lbrakk>0 < n; Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> m mod n < n - Suc 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> m mod n < n - Suc 0", "apply (insert le_neq_trans[OF mod_less_divisor[THEN Suc_leI, of n m]], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma div_Suc: \"\n  0 < n \\<Longrightarrow> Suc m div n = (if Suc (m mod n) = n then Suc (m div n) else m div n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    Suc m div n = (if Suc (m mod n) = n then Suc (m div n) else m div n)", "apply (drule Suc_leI, drule le_imp_less_or_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < n \\<or> Suc 0 = n \\<Longrightarrow>\n    Suc m div n = (if Suc (m mod n) = n then Suc (m div n) else m div n)", "apply (case_tac \"n = Suc 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < n \\<or> Suc 0 = n; n \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> Suc m div n =\n                      (if Suc (m mod n) = n then Suc (m div n) else m div n)", "apply (split if_split, intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 < n \\<or> Suc 0 = n; n \\<noteq> Suc 0;\n     Suc (m mod n) = n\\<rbrakk>\n    \\<Longrightarrow> Suc m div n = Suc (m div n)\n 2. \\<lbrakk>Suc 0 < n \\<or> Suc 0 = n; n \\<noteq> Suc 0;\n     Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Suc m div n = m div n", "apply (rule_tac t=\"Suc m\" and s=\"m + 1\" in subst, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 < n \\<or> Suc 0 = n; n \\<noteq> Suc 0;\n     Suc (m mod n) = n\\<rbrakk>\n    \\<Longrightarrow> (m + 1) div n = Suc (m div n)\n 2. \\<lbrakk>Suc 0 < n \\<or> Suc 0 = n; n \\<noteq> Suc 0;\n     Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Suc m div n = m div n", "apply (subst div_add1_eq2, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < n; Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Suc m div n = m div n", "apply (insert le_neq_trans[OF mod_less_divisor[THEN Suc_leI, of n m]], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m mod n) < n \\<Longrightarrow> Suc m div n = m div n", "apply (rule_tac t=\"Suc m\" and s=\"m + 1\" in subst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m mod n) < n \\<Longrightarrow> (m + 1) div n = m div n", "apply (subst div_add1_eq1, simp+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma div_Suc': \"\n  0 < n \\<Longrightarrow> Suc m div n = (if m mod n < n - Suc 0 then m div n else Suc (m div n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    Suc m div n = (if m mod n < n - Suc 0 then m div n else Suc (m div n))", "apply (simp add: div_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    (Suc (m mod n) = n \\<longrightarrow> \\<not> m mod n < n - Suc 0) \\<and>\n    (Suc (m mod n) \\<noteq> n \\<longrightarrow> m mod n < n - Suc 0)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; Suc (m mod n) = n\\<rbrakk>\n    \\<Longrightarrow> \\<not> m mod n < n - Suc 0\n 2. \\<lbrakk>0 < n; Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> m mod n < n - Suc 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; Suc (m mod n) \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> m mod n < n - Suc 0", "apply (insert le_neq_trans[OF mod_less_divisor[THEN Suc_leI, of n m]], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_card_ge_aux: \"\n  \\<And>I. \\<lbrakk> 0 < d; finite I; Max I div d \\<le> n \\<rbrakk> \\<Longrightarrow>\n  card I div d + (if card I mod d = 0 then 0 else Suc 0) \\<le> card (I \\<oslash> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (case_tac \"I = {}\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> 0; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (frule_tac m=d and n=\"Max I\" and k=0 in div_le_conv[THEN iffD1, rule_format], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d \\<le> 0; I \\<noteq> {};\n        Max I \\<le> Suc 0 * d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (simp del: Max_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (subgoal_tac \"I \\<oslash> d = {0}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> I \\<oslash> d = {0}\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> I \\<oslash> d = {0}\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (rule set_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I x.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> I \\<oslash> d) = (x \\<in> {0})\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (simp add: iT_Div_mem_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I x.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        \\<forall>a\\<in>I. a \\<le> d - Suc 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y\\<in>I. y div d = x) = (x = 0)\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (rule iffI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>I x.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        \\<forall>a\\<in>I. a \\<le> d - Suc 0;\n        \\<exists>y\\<in>I. y div d = x\\<rbrakk>\n       \\<Longrightarrow> x = 0\n 2. \\<And>I x.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        \\<forall>a\\<in>I. a \\<le> d - Suc 0; x = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>I. y div d = x\n 3. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 4. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (fastforce simp: div_eq_0_conv')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I x.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        \\<forall>a\\<in>I. a \\<le> d - Suc 0; x = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>I. y div d = x\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> card (I \\<oslash> d)) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          Suc (card I div d) \\<le> card (I \\<oslash> d))\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (simp add: iT_Div_singleton card_singleton del: Max_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        Max I \\<le> d - Suc 0; I \\<oslash> d = {0}\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> Suc 0) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          card I div d = 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (drule Suc_le_mono[THEN iffD2, of _ \"d - Suc 0\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; Suc (Max I) \\<le> Suc (d - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> Suc 0) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          card I div d = 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (drule order_trans[OF nat_card_le_Max])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I \\<le> Suc (d - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                          card I div d \\<le> Suc 0) \\<and>\n                         (0 < card I mod d \\<longrightarrow>\n                          card I div d = 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (simp, intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I \\<le> d; card I mod d = 0\\<rbrakk>\n       \\<Longrightarrow> card I div d \\<le> Suc 0\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I \\<le> d; 0 < card I mod d\\<rbrakk>\n       \\<Longrightarrow> card I div d = 0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (drule div_le_mono[of _ d d])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I mod d = 0;\n        card I div d \\<le> d div d\\<rbrakk>\n       \\<Longrightarrow> card I div d \\<le> Suc 0\n 2. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I \\<le> d; 0 < card I mod d\\<rbrakk>\n       \\<Longrightarrow> card I div d = 0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I \\<le> d; 0 < card I mod d\\<rbrakk>\n       \\<Longrightarrow> card I div d = 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (subgoal_tac \"card I \\<noteq> d\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < d; finite I; Max I div d = 0; I \\<noteq> {};\n        I \\<oslash> d = {0}; card I \\<le> d; 0 < card I mod d\\<rbrakk>\n       \\<Longrightarrow> card I \\<noteq> d\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (drule order_le_less[THEN iffD1], erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d < Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> card (I \\<oslash> d)", "apply (rule_tac t=I and s=\"I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union> I \\<inter> [Suc n * d\\<dots>,d - Suc 0]\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                         I \\<inter> [Suc n * d\\<dots>,d - Suc 0] =\n                         I\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: Int_Un_distrib[symmetric] add.commute[of d])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter>\n                         ([\\<dots>n * d + d - Suc 0] \\<union>\n                          [n * d + d\\<dots>,d - Suc 0]) =\n                         I\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (subst iIN_0_iTILL_conv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter>\n                         ([0\\<dots>,n * d + d - Suc 0] \\<union>\n                          [n * d + d\\<dots>,d - Suc 0]) =\n                         I\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iIN_union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [0\\<dots>,n * d + d + d - Suc 0] = I\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (rule Int_absorb2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq> [0\\<dots>,n * d + d + d - Suc 0]\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iIN_0_iTILL_conv iTILL_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq> {..n * d + d + d - Suc 0}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (case_tac \"I = {}\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n; I \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> I \\<subseteq> {..n * d + d + d - Suc 0}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: subset_atMost_Max_le_conv le_less_div_conv[symmetric] less_eq_le_pred[symmetric] add.commute[of d])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (cut_tac A=\"I \\<inter> [\\<dots>n * d + d - Suc 0]\" and B=\"I \\<inter> [Suc n * d\\<dots>,d - Suc 0]\" in card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (I \\<inter> [\\<dots>n * d + d - Suc 0])\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [\\<dots>n * d + d - Suc 0] \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n                         {}\n 4. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> finite (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [\\<dots>n * d + d - Suc 0] \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n                         {}\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n\\<rbrakk>\n       \\<Longrightarrow> I \\<inter> [\\<dots>n * d + d - Suc 0] \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n                         {}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (clarsimp simp: disjoint_iff_in_not_in1 iT_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (case_tac \"I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iT_Div_mod_partition_card del: mult_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                          d =\n                          0 \\<longrightarrow>\n                          I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                          d\n                          \\<le> Suc 0) \\<and>\n                         (0 < card\n                               (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                              d \\<longrightarrow>\n                          I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                          d =\n                          0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d = 0;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d\n                         \\<le> Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (rule div_le_conv[THEN iffD2], assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d = 0;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\n                         \\<le> Suc (Suc 0) * d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) mod d = 0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])\n                         \\<le> d + d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (rule order_trans[OF Int_card2[OF iIN_finite]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) mod d = 0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card [d + n * d\\<dots>,d - Suc 0]\n                         \\<le> d + d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iIN_card)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (cut_tac A=I and n=\"Suc n * d\" and d=\"d - Suc 0\" in Int_card2[OF iIN_finite, rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\n        \\<le> card [Suc n * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iIN_card)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (drule order_le_less[THEN iffD1], erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) < d\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) = d\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        I \\<inter> [\\<dots>n * d + d - Suc 0] = {};\n        0 < card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) mod d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) = d\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) div\n                         d =\n                         0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (subgoal_tac \"Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d\n                         \\<le> n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d\n                         \\<le> n\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (rule div_le_conv[THEN iffD2], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max (I \\<inter> [\\<dots>n * d + d - Suc 0])\n                         \\<le> Suc n * d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (rule order_trans[OF Max_Int_le2[OF _ iTILL_finite]], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Max [\\<dots>n * d + d - Suc 0]\n                         \\<le> Suc n * d - Suc 0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iTILL_Max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>0 < d; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n                           I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) div\n                         d +\n                         (if card\n                              (I \\<inter>\n                               [\\<dots>n * d + d - Suc 0] \\<union>\n                               I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<union>\n                                 I \\<inter>\n                                 [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                 d)", "apply (simp only: iT_Div_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (cut_tac A=\"I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d\" and B=\"I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d\" in card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash>\n                           d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                           d)\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash>\n                          d) \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                          d) =\n                         {}\n 4. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (simp add: iT_Div_finite_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                           d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash>\n                          d) \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                          d) =\n                         {}\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (simp add: iT_Div_finite_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash>\n                          d) \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                          d) =\n                         {}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (subst iIN_0_iTILL_conv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [0\\<dots>,n * d + d - Suc 0] \\<oslash>\n                          d) \\<inter>\n                         (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                          d) =\n                         {}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (subst mod_partition_iT_Div_Int_one_segment, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (I \\<inter> [0\\<dots>,n * d + d - Suc 0] \\<oslash>\n                          d) \\<inter>\n                         ((I \\<oslash> d) \\<inter>\n                          ([Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n                         {}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (cut_tac n=0 and d=\"n * d+d\" and k=d and A=I in mod_partition_iT_Div_Int2, simp+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        I \\<inter> [0\\<dots>,n * d + d - Suc 0] \\<oslash> d =\n        (I \\<oslash> d) \\<inter>\n        ([0\\<dots>,n * d + d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (I \\<oslash> d) \\<inter>\n                         ([0\\<dots>,n * d + d - Suc 0] \\<oslash> d) \\<inter>\n                         ((I \\<oslash> d) \\<inter>\n                          ([d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n                         {}\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (rule disjoint_iff_in_not_in1[THEN iffD2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        I \\<inter> [0\\<dots>,n * d + d - Suc 0] \\<oslash> d =\n        (I \\<oslash> d) \\<inter>\n        ([0\\<dots>,n * d + d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>(I \\<oslash> d) \\<inter>\n  ([0\\<dots>,n * d + d - Suc 0] \\<oslash> d).\n                            x \\<notin> (I \\<oslash> d) \\<inter>\n ([d + n * d\\<dots>,d - Suc 0] \\<oslash> d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        I \\<inter> [0\\<dots>,n * d + d - Suc 0] \\<oslash> d =\n        (I \\<oslash> d) \\<inter> ([0\\<dots>,n * d + d - Suc 0] \\<oslash> d);\n        x \\<in> I \\<oslash> d;\n        x \\<in> [0\\<dots>,n * d + d - Suc 0] \\<oslash> d;\n        x \\<in> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (simp add: iIN_div_mod_eq_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I x.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        I \\<inter> [0\\<dots>,n * d + d - Suc 0] \\<oslash> d =\n        (I \\<oslash> d) \\<inter> [0\\<dots>,(n * d + d - Suc 0) div d];\n        x \\<in> I \\<oslash> d; x \\<in> [0\\<dots>,(n * d + d - Suc 0) div d];\n        x \\<in> [Suc n\\<dots>,0]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (simp add: mod_0_imp_sub_1_div_conv iIN_0_iTILL_conv iIN_0 iTILL_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                ((I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d) \\<union>\n                                 (I \\<inter>\n                                  [Suc n * d\\<dots>,d - Suc 0] \\<oslash>\n                                  d))", "apply (simp only: iT_Div_mod_partition_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] = {} then 0\n         else Suc 0)\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d) +\n                               (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] =\n                                   {}\n                                then 0 else Suc 0)", "apply (subgoal_tac \"finite (I \\<inter> [\\<dots>n * d + d - Suc 0])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        finite (I \\<inter> [\\<dots>n * d + d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d) +\n                               (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] =\n                                   {}\n                                then 0 else Suc 0)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] = {} then 0\n         else Suc 0)\\<rbrakk>\n       \\<Longrightarrow> finite (I \\<inter> [\\<dots>n * d + d - Suc 0])", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] = {} then 0\n         else Suc 0)\\<rbrakk>\n       \\<Longrightarrow> finite (I \\<inter> [\\<dots>n * d + d - Suc 0])\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        finite (I \\<inter> [\\<dots>n * d + d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d) +\n                               (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] =\n                                   {}\n                                then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>True; finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        finite (I \\<inter> [\\<dots>n * d + d - Suc 0])\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])) div\n                         d +\n                         (if (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                              card\n                               (I \\<inter>\n                                [Suc n * d\\<dots>,d - Suc 0])) mod\n                             d =\n                             0\n                          then 0 else Suc 0)\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d) +\n                               (if I \\<inter> [Suc n * d\\<dots>,d - Suc 0] =\n                                   {}\n                                then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0\n         else Suc 0)\\<rbrakk>\n       \\<Longrightarrow> ((card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                           card\n                            (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n                          d =\n                          0 \\<longrightarrow>\n                          I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                           card\n                            (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                          d\n                          \\<le> Suc (card\n(I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d))) \\<and>\n                         (0 < (card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                               card\n                                (I \\<inter>\n                                 [d + n * d\\<dots>,d - Suc 0])) mod\n                              d \\<longrightarrow>\n                          I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq>\n                          {} \\<longrightarrow>\n                          (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                           card\n                            (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                          d\n                          \\<le> card\n                                 (I \\<inter>\n                                  [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                  d))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n         card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n        d =\n        0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> Suc (card\n                                     (I \\<inter>\n[\\<dots>n * d + d - Suc 0] \\<oslash>\nd))\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (rule add_le_divisor_imp_le_Suc_div)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n         card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n        d =\n        0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n         card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n        d =\n        0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])\n                         \\<le> d\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (rule add_leD1, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n         card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n        d =\n        0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])\n                         \\<le> d\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (rule Int_card2[OF iIN_finite, THEN le_trans])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n         card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n        d =\n        0;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card [d + n * d\\<dots>,d - Suc 0] \\<le> d\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iIN_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (cut_tac A=I and n=\"Suc n * d\" and d=\"d - Suc 0\" in Int_card2[OF iIN_finite, rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) +\n        (if I \\<inter> [d + n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0);\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0])\n        \\<le> card [Suc n * d\\<dots>,d - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (simp add: iIN_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "apply (rule_tac y=\"let I=I \\<inter> [\\<dots>n * d + d - Suc 0] in\n  card I div d + (if card I mod d = 0 then 0 else Suc 0)\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> (let I =\nI \\<inter> [\\<dots>n * d + d - Suc 0]\n                                in card I div d +\n                                   (if card I mod d = 0 then 0 else Suc 0))\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (let I = I \\<inter> [\\<dots>n * d + d - Suc 0]\n                          in card I div d +\n                             (if card I mod d = 0 then 0 else Suc 0))\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (let I = I \\<inter> [\\<dots>n * d + d - Suc 0]\n                          in card I div d +\n                             (if card I mod d = 0 then 0 else Suc 0))\n                         \\<le> card\n                                (I \\<inter>\n                                 [\\<dots>n * d + d - Suc 0] \\<oslash>\n                                 d)\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> (let I =\nI \\<inter> [\\<dots>n * d + d - Suc 0]\n                                in card I div d +\n                                   (if card I mod d = 0 then 0 else Suc 0))", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> (let I =\nI \\<inter> [\\<dots>n * d + d - Suc 0]\n                                in card I div d +\n                                   (if card I mod d = 0 then 0 else Suc 0))", "apply (unfold Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               (if card\n                                    (I \\<inter>\n                                     [\\<dots>n * d + d - Suc 0]) mod\n                                   d =\n                                   0\n                                then 0 else Suc 0)", "apply (split if_split, intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d = 0\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               Suc 0", "apply (subgoal_tac \"card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) \\<noteq> d\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d = 0;\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d = 0\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) \\<noteq>\n                         d\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               Suc 0", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d = 0\\<rbrakk>\n       \\<Longrightarrow> card\n                          (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) \\<noteq>\n                         d\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d = 0;\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               0\n 3. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               Suc 0", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d = 0;\n        card (I \\<inter> [Suc n * d\\<dots>,d - Suc 0]) \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               0\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               Suc 0", "apply (simp add: div_add1_eq1_mod_0_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   \\<lbrakk>finite I; Max I div d \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> card I div d +\n                                     (if card I mod d = 0 then 0 else Suc 0)\n                                     \\<le> card (I \\<oslash> d);\n        0 < d; finite I; Max I div d = Suc n;\n        card\n         (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<union>\n          I \\<inter> [d + n * d\\<dots>,d - Suc 0]) =\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]);\n        I \\<inter> [\\<dots>n * d + d - Suc 0] \\<noteq> {};\n        Max (I \\<inter> [\\<dots>n * d + d - Suc 0]) div d \\<le> n;\n        card\n         ((I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d) \\<union>\n          (I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<oslash> d)) =\n        Suc (card (I \\<inter> [\\<dots>n * d + d - Suc 0] \\<oslash> d));\n        0 < (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n             card (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) mod\n            d;\n        I \\<inter> [d + n * d\\<dots>,d - Suc 0] \\<noteq> {};\n        card (I \\<inter> [d + n * d\\<dots>,d - Suc 0]) \\<le> d;\n        card (I \\<inter> [\\<dots>n * d + d - Suc 0]) mod d \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> (card (I \\<inter> [\\<dots>n * d + d - Suc 0]) +\n                          card\n                           (I \\<inter> [d + n * d\\<dots>,d - Suc 0])) div\n                         d\n                         \\<le> card\n                                (I \\<inter> [\\<dots>n * d + d - Suc 0]) div\n                               d +\n                               Suc 0", "apply (simp add: add_le_divisor_imp_le_Suc_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_card_ge: \"\n  card I div d + (if card I mod d = 0 then 0 else Suc 0) \\<le> card (I \\<oslash> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card I div d + (if card I mod d = 0 then 0 else Suc 0)\n    \\<le> card (I \\<oslash> d)", "apply (case_tac \"I = {}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> {} \\<Longrightarrow>\n    card I div d + (if card I mod d = 0 then 0 else Suc 0)\n    \\<le> card (I \\<oslash> d)", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; finite I\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)\n 2. \\<lbrakk>I \\<noteq> {}; infinite I\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; infinite I\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)\n 2. \\<lbrakk>I \\<noteq> {}; finite I\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)", "apply (case_tac \"d = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; finite I; d = 0\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)\n 2. \\<lbrakk>I \\<noteq> {}; finite I; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)", "apply (simp add: iT_Div_0 iTILL_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> card (I \\<oslash> d)", "apply (simp add: iT_Div_card_ge_aux[OF _ _ order_refl])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Div_card_ge_div: \"card I div d \\<le> card (I \\<oslash> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card I div d \\<le> card (I \\<oslash> d)", "by (rule iT_Div_card_ge[THEN add_leD1])"], ["", "text \\<open>\n  There is no better lower bound function @{term f} for @{term \"(i \\<oslash> d)\"}\n  with @{term \"card i\"} and @{term d} as arguments.\\<close>"], ["", "lemma iT_Div_card_ge__is_maximal_lower_bound: \"\n  \\<forall>I d. card I div d + (if card I mod d = 0 then 0 else Suc 0) \\<le> f (card I) d \\<and>\n        f (card I) d \\<le> card (I \\<oslash> d) \\<Longrightarrow>\n  f (card (I::nat set)) d = card I div d + (if card I mod d = 0 then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I d.\n       card I div d + (if card I mod d = 0 then 0 else Suc 0)\n       \\<le> f (card I) d \\<and>\n       f (card I) d \\<le> card (I \\<oslash> d) \\<Longrightarrow>\n    f (card I) d = card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (case_tac \"I = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I = {}\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (erule_tac x=I in allE, erule_tac x=d in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I = {};\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d \\<and>\n     f (card I) d \\<le> card (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (simp add: iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (case_tac \"d = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d = 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (frule_tac x=\"{}\" in spec, erule_tac x=I in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; d = 0;\n     \\<forall>d.\n        card {} div d + (if card {} mod d = 0 then 0 else Suc 0)\n        \\<le> f (card {}) d \\<and>\n        f (card {}) d \\<le> card ({} \\<oslash> d);\n     \\<forall>d.\n        card I div d + (if card I mod d = 0 then 0 else Suc 0)\n        \\<le> f (card I) d \\<and>\n        f (card I) d \\<le> card (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (erule_tac x=d in allE, erule_tac x=d in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; d = 0;\n     card {} div d + (if card {} mod d = 0 then 0 else Suc 0)\n     \\<le> f (card {}) d \\<and>\n     f (card {}) d \\<le> card ({} \\<oslash> d);\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d \\<and>\n     f (card I) d \\<le> card (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (clarsimp simp: iT_Div_0 iTILL_card iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d =\n                      card I div d + (if card I mod d = 0 then 0 else Suc 0)", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> f (card I) d", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                      \\<le> f (card I) d\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0; infinite I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0; infinite I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply (erule_tac x=I in allE, erule_tac x=d in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; d \\<noteq> 0; infinite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d \\<and>\n     f (card I) d \\<le> card (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply (simp add: iT_Div_finite_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                card I div d + (if card I mod d = 0 then 0 else Suc 0)\n                \\<le> f (card I) d \\<and>\n                f (card I) d \\<le> card (I \\<oslash> d);\n     I \\<noteq> {}; d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply (erule_tac x=\"[\\<dots>card I - Suc 0]\" in allE, erule_tac x=d in allE, elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; d \\<noteq> 0; finite I;\n     card [\\<dots>card I - Suc 0] div d +\n     (if card [\\<dots>card I - Suc 0] mod d = 0 then 0 else Suc 0)\n     \\<le> f (card [\\<dots>card I - Suc 0]) d;\n     f (card [\\<dots>card I - Suc 0]) d\n     \\<le> card ([\\<dots>card I - Suc 0] \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply (frule not_empty_card_gr0_conv[THEN iffD1], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; d \\<noteq> 0; finite I;\n     card [\\<dots>card I - Suc 0] div d +\n     (if card [\\<dots>card I - Suc 0] mod d = 0 then 0 else Suc 0)\n     \\<le> f (card [\\<dots>card I - Suc 0]) d;\n     f (card [\\<dots>card I - Suc 0]) d\n     \\<le> card ([\\<dots>card I - Suc 0] \\<oslash> d);\n     0 < card I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d\n                      \\<le> card I div d +\n                            (if card I mod d = 0 then 0 else Suc 0)", "apply (simp add: iTILL_card iTILL_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I\\<rbrakk>\n    \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                       f (card I) d = card I div d) \\<and>\n                      (0 < card I mod d \\<longrightarrow>\n                       f (card I) d = Suc (card I div d))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     card I mod d = 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = card I div d\n 2. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply (simp add: mod_0_imp_sub_1_div_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = card I div d\n 2. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply (subgoal_tac \"d \\<le> card I\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0; d \\<le> card I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = card I div d\n 2. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0\\<rbrakk>\n    \\<Longrightarrow> d \\<le> card I\n 3. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0\\<rbrakk>\n    \\<Longrightarrow> d \\<le> card I\n 2. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0; d \\<le> card I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = card I div d\n 3. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply (clarsimp elim!: dvdE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0; d \\<le> card I\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = card I div d\n 2. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply (drule div_le_mono[of d _ d])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d \\<le> f (card I) d;\n     f (card I) d \\<le> Suc (card I div d - Suc 0); 0 < card I;\n     card I mod d = 0; d div d \\<le> card I div d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = card I div d\n 2. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply (case_tac \"d = Suc 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; 0 < d; finite I;\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\n     \\<le> f (card I) d;\n     f (card I) d \\<le> Suc ((card I - Suc 0) div d); 0 < card I;\n     0 < card I mod d; d \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> f (card I) d = Suc (card I div d)", "apply (simp add: div_diff1_eq1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_icard: \"icard (I \\<oplus> k) = icard I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (I \\<oplus> k) = icard I", "by (simp add: iT_Plus_def icard_image)"], ["", "lemma iT_Mult_icard: \"0 < k \\<Longrightarrow> icard (I \\<otimes> k) = icard I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> icard (I \\<otimes> k) = icard I", "apply (unfold iT_Mult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> icard ((\\<lambda>n. n * k) ` I) = icard I", "apply (rule icard_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> inj_on (\\<lambda>n. n * k) I", "apply (rule inj_imp_inj_on)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> inj (\\<lambda>n. n * k)", "apply (simp add: mult_right_inj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_icard: \"icard (I \\<oplus>- k) = icard (I \\<down>\\<ge> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (I \\<oplus>- k) = icard (I \\<down>\\<ge> k)", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    icard (I \\<oplus>- k) = icard (I \\<down>\\<ge> k)\n 2. infinite I \\<Longrightarrow>\n    icard (I \\<oplus>- k) = icard (I \\<down>\\<ge> k)", "apply (simp add: iT_Plus_neg_finite_iff cut_ge_finite icard_finite iT_Plus_neg_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    icard (I \\<oplus>- k) = icard (I \\<down>\\<ge> k)", "apply (simp add: iT_Plus_neg_finite_iff nat_cut_ge_finite_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Plus_neg_icard_le: \"icard (I \\<oplus>- k) \\<le> icard I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (I \\<oplus>- k) \\<le> icard I", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow> icard (I \\<oplus>- k) \\<le> icard I\n 2. infinite I \\<Longrightarrow> icard (I \\<oplus>- k) \\<le> icard I", "apply (simp add: iT_Plus_neg_finite_iff icard_finite iT_Plus_neg_card_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow> icard (I \\<oplus>- k) \\<le> icard I", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Minus_icard: \"icard (k \\<ominus> I) = icard (I \\<down>\\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (k \\<ominus> I) = icard (I \\<down>\\<le> k)", "by (simp add: icard_finite iT_Minus_finite nat_cut_le_finite iT_Minus_card)"], ["", "lemma iT_Minus_icard_le: \"icard (k \\<ominus> I) \\<le> icard I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (k \\<ominus> I) \\<le> icard I", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow> icard (k \\<ominus> I) \\<le> icard I\n 2. infinite I \\<Longrightarrow> icard (k \\<ominus> I) \\<le> icard I", "apply (simp add: icard_finite iT_Minus_finite iT_Minus_card_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow> icard (k \\<ominus> I) \\<le> icard I", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_0_icard_if: \"icard (I \\<oslash> 0) = enat (if I = {} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (I \\<oslash> 0) = enat (if I = {} then 0 else Suc 0)", "by (simp add: icard_finite iT_Div_0_finite iT_Div_0_card_if)"], ["", "lemma iT_Div_mod_partition_icard: \"\n  icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n  enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (subgoal_tac \"finite (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) \\<Longrightarrow>\n    icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)\n 2. finite (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d)\n 2. finite\n     (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) \\<Longrightarrow>\n    icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (case_tac \"d = 0\", simp add: iT_Div_0_finite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d \\<noteq> 0 \\<Longrightarrow>\n    finite (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d)\n 2. finite\n     (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) \\<Longrightarrow>\n    icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (simp add: iT_Div_finite_iff iIN_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) \\<Longrightarrow>\n    icard (I \\<inter> [n * d\\<dots>,d - Suc 0] \\<oslash> d) =\n    enat (if I \\<inter> [n * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0)", "apply (simp add: icard_finite iT_Div_mod_partition_card)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_icard: \"\n  \\<lbrakk> 0 < d; finite I \\<Longrightarrow> Max I div d \\<le> n\\<rbrakk> \\<Longrightarrow>\n  icard (I \\<oslash> d) =\n  (if finite I then enat (\\<Sum>k\\<le>n. if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0) else \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I \\<Longrightarrow> Max I div d \\<le> n\\<rbrakk>\n    \\<Longrightarrow> icard (I \\<oslash> d) =\n                      (if finite I\n                       then enat\n                             (\\<Sum>k\\<le>n.\n                                 if I \\<inter> [k * d\\<dots>,d - Suc 0] = {}\n                                 then 0 else Suc 0)\n                       else \\<infinity>)", "by (simp add: icard_finite iT_Div_finite_iff iT_Div_card)"], ["", "corollary iT_Div_Max_icard: \"0 < d \\<Longrightarrow>\n  icard (I \\<oslash> d) = (if finite I\n    then enat (\\<Sum>k\\<le>Max I div d. if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0 else Suc 0) else \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    icard (I \\<oslash> d) =\n    (if finite I\n     then enat\n           (\\<Sum>k\\<le>Max I div d.\n               if I \\<inter> [k * d\\<dots>,d - Suc 0] = {} then 0\n               else Suc 0)\n     else \\<infinity>)", "by (simp add: iT_Div_icard)"], ["", "lemma iT_Div_icard_le: \"0 < k \\<Longrightarrow> icard (I \\<oslash> k) \\<le> icard I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> icard (I \\<oslash> k) \\<le> icard I", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; finite I\\<rbrakk>\n    \\<Longrightarrow> icard (I \\<oslash> k) \\<le> icard I\n 2. \\<lbrakk>0 < k; infinite I\\<rbrakk>\n    \\<Longrightarrow> icard (I \\<oslash> k) \\<le> icard I", "apply (simp add: iT_Div_finite_iff icard_finite iT_Div_card_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; infinite I\\<rbrakk>\n    \\<Longrightarrow> icard (I \\<oslash> k) \\<le> icard I", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iT_Div_icard_inj_on: \"inj_on (\\<lambda>n. n div k) I \\<Longrightarrow> icard (I \\<oslash> k) = icard I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>n. n div k) I \\<Longrightarrow>\n    icard (I \\<oslash> k) = icard I", "by (simp add: iT_Div_def icard_image)"], ["", "lemma iT_Div_icard_ge: \"icard I div (enat d) + enat (if icard I mod (enat d) = 0 then 0 else Suc 0) \\<le> icard (I \\<oslash> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)", "apply (case_tac \"d = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)", "apply (simp add: icard_finite iT_Div_0_finite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow>\n    enat 0 < icard I \\<longrightarrow> Suc 0 \\<le> card (I \\<oslash> 0)\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)", "apply (case_tac \"icard I\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>d = 0; icard I = enat nat\\<rbrakk>\n       \\<Longrightarrow> enat 0 < icard I \\<longrightarrow>\n                         Suc 0 \\<le> card (I \\<oslash> 0)\n 2. \\<lbrakk>d = 0; icard I = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> enat 0 < icard I \\<longrightarrow>\n                      Suc 0 \\<le> card (I \\<oslash> 0)\n 3. d \\<noteq> 0 \\<Longrightarrow>\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)", "apply (fastforce simp: iT_Div_0_card_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d = 0; icard I = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> enat 0 < icard I \\<longrightarrow>\n                      Suc 0 \\<le> card (I \\<oslash> 0)\n 2. d \\<noteq> 0 \\<Longrightarrow>\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)", "apply (simp add: iT_Div_0_card_if icard_infinite_conv infinite_imp_nonempty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow>\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n    \\<le> icard (I \\<oslash> d)", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                      \\<le> icard (I \\<oslash> d)\n 2. \\<lbrakk>d \\<noteq> 0; infinite I\\<rbrakk>\n    \\<Longrightarrow> icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                      \\<le> icard (I \\<oslash> d)", "apply (simp add: iT_Div_finite_iff icard_finite iT_Div_card_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d \\<noteq> 0; infinite I\\<rbrakk>\n    \\<Longrightarrow> icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                      \\<le> icard (I \\<oslash> d)", "apply (simp add: iT_Div_finite_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary iT_Div_icard_ge_div: \"icard I div (enat d) \\<le> icard (I \\<oslash> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icard I div enat d \\<le> icard (I \\<oslash> d)", "by (rule iT_Div_icard_ge[THEN iadd_ileD1])"], ["", "lemma iT_Div_icard_ge__is_maximal_lower_bound: \"\n  \\<forall>I d. icard I div (enat d) + enat (if icard I mod (enat d) = 0 then 0 else Suc 0)\n        \\<le> f (icard I) d \\<and>\n        f (icard I) d \\<le> icard (I \\<oslash> d) \\<Longrightarrow>\n  f (icard (I::nat set)) d =\n  icard I div (enat d) + enat (if icard I mod (enat d) = 0 then 0 else Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I d.\n       icard I div enat d +\n       enat (if icard I mod enat d = 0 then 0 else Suc 0)\n       \\<le> f (icard I) d \\<and>\n       f (icard I) d \\<le> icard (I \\<oslash> d) \\<Longrightarrow>\n    f (icard I) d =\n    icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply (case_tac \"d = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d = 0\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply (drule_tac x=I in spec, drule_tac x=d in spec, erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d = 0;\n     icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n     \\<le> f (icard I) d;\n     f (icard I) d \\<le> icard (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply (simp add: iT_Div_0_icard_if icard_0_eq[unfolded zero_enat_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0; infinite I\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0; infinite I\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply (drule_tac x=I in spec, drule_tac x=d in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d \\<noteq> 0; infinite I;\n     icard I div enat d + enat (if icard I mod enat d = 0 then 0 else Suc 0)\n     \\<le> f (icard I) d \\<and>\n     f (icard I) d \\<le> icard (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     d \\<noteq> 0; finite I\\<rbrakk>\n    \\<Longrightarrow> f (icard I) d =\n                      icard I div enat d +\n                      enat (if icard I mod enat d = 0 then 0 else Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (frule_tac iT_Div_finite_iff[THEN iffD2], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (cut_tac f=\"\\<lambda>c d. the_enat (f (enat c) d)\" and I=I and d=d in iT_Div_card_ge__is_maximal_lower_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>I d.\n                         card I div d +\n                         (if card I mod d = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I)) d) \\<and>\n                         the_enat (f (enat (card I)) d)\n                         \\<le> card (I \\<oslash> d)\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (intro allI, rename_tac I' d')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (subgoal_tac \"\\<And>k. f 0 k = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 2. \\<And>I' d' k.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> f 0 k = 0\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d' k.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d)\\<rbrakk>\n       \\<Longrightarrow> f 0 k = 0\n 2. \\<And>I' d'.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (drule_tac x=\"{}\" in spec, drule_tac x=k in spec, erule conjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d' k.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        icard {} div enat k +\n        enat (if icard {} mod enat k = enat 0 then 0 else Suc 0)\n        \\<le> f (icard {}) k;\n        f (icard {}) k \\<le> icard ({} \\<oslash> k)\\<rbrakk>\n       \\<Longrightarrow> f 0 k = 0\n 2. \\<And>I' d'.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (simp add: iT_Div_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>\\<forall>I d.\n                   icard I div enat d +\n                   enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                   \\<le> f (icard I) d \\<and>\n                   f (icard I) d \\<le> icard (I \\<oslash> d);\n        0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (drule_tac x=I' in spec, drule_tac x=d' in spec, erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (case_tac \"d' = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); d' = 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d');\n        d' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (simp add: idiv_by_0 imod_by_0 iT_Div_0_card_if iT_Div_0_icard_if)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (if icard I' = enat 0 then 0 else Suc 0) \\<le> f (icard I') 0;\n        f (icard I') 0 \\<le> enat (if I' = {} then 0 else Suc 0);\n        d' = 0\\<rbrakk>\n       \\<Longrightarrow> 0 < card I' \\<longrightarrow>\n                         I' \\<noteq> {} \\<longrightarrow>\n                         Suc 0 \\<le> the_enat (f (enat (card I')) 0) \\<and>\n                         the_enat (f (enat (card I')) 0) \\<le> Suc 0\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d');\n        d' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (case_tac \"I' = {}\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (if icard I' = enat 0 then 0 else Suc 0) \\<le> f (icard I') 0;\n        f (icard I') 0 \\<le> enat (if I' = {} then 0 else Suc 0); d' = 0;\n        I' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> 0 < card I' \\<longrightarrow>\n                         I' \\<noteq> {} \\<longrightarrow>\n                         Suc 0 \\<le> the_enat (f (enat (card I')) 0) \\<and>\n                         the_enat (f (enat (card I')) 0) \\<le> Suc 0\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d');\n        d' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (case_tac \"finite I'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (if icard I' = enat 0 then 0 else Suc 0) \\<le> f (icard I') 0;\n        f (icard I') 0 \\<le> enat (if I' = {} then 0 else Suc 0); d' = 0;\n        I' \\<noteq> {}; finite I'\\<rbrakk>\n       \\<Longrightarrow> 0 < card I' \\<longrightarrow>\n                         I' \\<noteq> {} \\<longrightarrow>\n                         Suc 0 \\<le> the_enat (f (enat (card I')) 0) \\<and>\n                         the_enat (f (enat (card I')) 0) \\<le> Suc 0\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (if icard I' = enat 0 then 0 else Suc 0) \\<le> f (icard I') 0;\n        f (icard I') 0 \\<le> enat (if I' = {} then 0 else Suc 0); d' = 0;\n        I' \\<noteq> {}; infinite I'\\<rbrakk>\n       \\<Longrightarrow> 0 < card I' \\<longrightarrow>\n                         I' \\<noteq> {} \\<longrightarrow>\n                         Suc 0 \\<le> the_enat (f (enat (card I')) 0) \\<and>\n                         the_enat (f (enat (card I')) 0) \\<le> Suc 0\n 3. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d');\n        d' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 4. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (if icard I' = enat 0 then 0 else Suc 0) \\<le> f (icard I') 0;\n        f (icard I') 0 \\<le> enat (if I' = {} then 0 else Suc 0); d' = 0;\n        I' \\<noteq> {}; infinite I'\\<rbrakk>\n       \\<Longrightarrow> 0 < card I' \\<longrightarrow>\n                         I' \\<noteq> {} \\<longrightarrow>\n                         Suc 0 \\<le> the_enat (f (enat (card I')) 0) \\<and>\n                         the_enat (f (enat (card I')) 0) \\<le> Suc 0\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d');\n        d' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d); \\<And>k. f 0 k = 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d');\n        d' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card I' div d' +\n                         (if card I' mod d' = 0 then 0 else Suc 0)\n                         \\<le> the_enat (f (enat (card I')) d') \\<and>\n                         the_enat (f (enat (card I')) d')\n                         \\<le> card (I' \\<oslash> d')\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (case_tac \"finite I'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        finite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (frule_tac I=I' and k=d' in iT_Div_finite_iff[THEN iffD2, rule_format], assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d'; finite I';\n        finite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (card I' div d' + (if card I' mod d' = 0 then 0 else Suc 0))\n        \\<le> f (enat (card I')) d';\n        f (enat (card I')) d' \\<le> enat (card (I' \\<oslash> d')); 0 < d';\n        finite I'; finite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (subgoal_tac \"\\<exists>n. f (enat (card I')) d' = enat n\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (card I' div d' + (if card I' mod d' = 0 then 0 else Suc 0))\n        \\<le> f (enat (card I')) d';\n        f (enat (card I')) d' \\<le> enat (card (I' \\<oslash> d')); 0 < d';\n        finite I'; finite (I' \\<oslash> d');\n        \\<exists>n. f (enat (card I')) d' = enat n\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (card I' div d' + (if card I' mod d' = 0 then 0 else Suc 0))\n        \\<le> f (enat (card I')) d';\n        f (enat (card I')) d' \\<le> enat (card (I' \\<oslash> d')); 0 < d';\n        finite I'; finite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. f (enat (card I')) d' = enat n\n 3. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 4. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (card I' div d' + (if card I' mod d' = 0 then 0 else Suc 0))\n        \\<le> f (enat (card I')) d';\n        f (enat (card I')) d' \\<le> enat (card (I' \\<oslash> d')); 0 < d';\n        finite I'; finite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. f (enat (card I')) d' = enat n\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (card I' div d' + (if card I' mod d' = 0 then 0 else Suc 0))\n        \\<le> f (enat (card I')) d';\n        f (enat (card I')) d' \\<le> enat (card (I' \\<oslash> d')); 0 < d';\n        finite I'; finite (I' \\<oslash> d');\n        \\<exists>n. f (enat (card I')) d' = enat n\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 3. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 4. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (rule enat_ile, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        enat (card I' div d' + (if card I' mod d' = 0 then 0 else Suc 0))\n        \\<le> f (enat (card I')) d';\n        f (enat (card I')) d' \\<le> enat (card (I' \\<oslash> d')); 0 < d';\n        finite I'; finite (I' \\<oslash> d');\n        \\<exists>n. f (enat (card I')) d' = enat n\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (subgoal_tac \"infinite (I' \\<oslash> d')\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d'; infinite I';\n        infinite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> infinite (I' \\<oslash> d')\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d';\n        infinite I'\\<rbrakk>\n       \\<Longrightarrow> infinite (I' \\<oslash> d')\n 2. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d'; infinite I';\n        infinite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 3. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (simp add: iT_Div_finite_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I' d'.\n       \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n        \\<And>k. f (enat 0) k = enat 0;\n        icard I' div enat d' +\n        enat (if icard I' mod enat d' = enat 0 then 0 else Suc 0)\n        \\<le> f (icard I') d';\n        f (icard I') d' \\<le> icard (I' \\<oslash> d'); 0 < d'; infinite I';\n        infinite (I' \\<oslash> d')\\<rbrakk>\n       \\<Longrightarrow> (card I' mod d' = 0 \\<longrightarrow>\n                          card I' div d'\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d')) \\<and>\n                         (0 < card I' mod d' \\<longrightarrow>\n                          Suc (card I' div d')\n                          \\<le> the_enat (f (enat (card I')) d') \\<and>\n                          the_enat (f (enat (card I')) d')\n                          \\<le> card (I' \\<oslash> d'))\n 2. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>I d.\n                icard I div enat d +\n                enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n                \\<le> f (icard I) d \\<and>\n                f (icard I) d \\<le> icard (I \\<oslash> d);\n     0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (drule_tac x=I in spec, drule_tac x=d in spec, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     icard I div enat d +\n     enat (if icard I mod enat d = enat 0 then 0 else Suc 0)\n     \\<le> f (icard I) d;\n     f (icard I) d \\<le> icard (I \\<oslash> d)\\<rbrakk>\n    \\<Longrightarrow> (icard I mod enat d = enat 0 \\<longrightarrow>\n                       f (icard I) d = icard I div enat d) \\<and>\n                      (enat 0 < icard I mod enat d \\<longrightarrow>\n                       f (icard I) d = icard I div enat d + enat (Suc 0))", "apply (simp add: icard_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     enat (card I div d + (if card I mod d = 0 then 0 else Suc 0))\n     \\<le> f (enat (card I)) d;\n     f (enat (card I)) d \\<le> enat (card (I \\<oslash> d))\\<rbrakk>\n    \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                       f (enat (card I)) d = enat (card I div d)) \\<and>\n                      (0 < card I mod d \\<longrightarrow>\n                       f (enat (card I)) d = enat (Suc (card I div d)))", "apply (subgoal_tac \"\\<exists>n. f (enat (card I)) d = enat n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     enat (card I div d + (if card I mod d = 0 then 0 else Suc 0))\n     \\<le> f (enat (card I)) d;\n     f (enat (card I)) d \\<le> enat (card (I \\<oslash> d));\n     \\<exists>n. f (enat (card I)) d = enat n\\<rbrakk>\n    \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                       f (enat (card I)) d = enat (card I div d)) \\<and>\n                      (0 < card I mod d \\<longrightarrow>\n                       f (enat (card I)) d = enat (Suc (card I div d)))\n 2. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     enat (card I div d + (if card I mod d = 0 then 0 else Suc 0))\n     \\<le> f (enat (card I)) d;\n     f (enat (card I)) d \\<le> enat (card (I \\<oslash> d))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. f (enat (card I)) d = enat n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     enat (card I div d + (if card I mod d = 0 then 0 else Suc 0))\n     \\<le> f (enat (card I)) d;\n     f (enat (card I)) d \\<le> enat (card (I \\<oslash> d))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. f (enat (card I)) d = enat n\n 2. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     enat (card I div d + (if card I mod d = 0 then 0 else Suc 0))\n     \\<le> f (enat (card I)) d;\n     f (enat (card I)) d \\<le> enat (card (I \\<oslash> d));\n     \\<exists>n. f (enat (card I)) d = enat n\\<rbrakk>\n    \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                       f (enat (card I)) d = enat (card I div d)) \\<and>\n                      (0 < card I mod d \\<longrightarrow>\n                       f (enat (card I)) d = enat (Suc (card I div d)))", "apply (rule enat_ile, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; finite I; finite (I \\<oslash> d);\n     the_enat (f (enat (card I)) d) =\n     card I div d + (if card I mod d = 0 then 0 else Suc 0);\n     enat (card I div d + (if card I mod d = 0 then 0 else Suc 0))\n     \\<le> f (enat (card I)) d;\n     f (enat (card I)) d \\<le> enat (card (I \\<oslash> d));\n     \\<exists>n. f (enat (card I)) d = enat n\\<rbrakk>\n    \\<Longrightarrow> (card I mod d = 0 \\<longrightarrow>\n                       f (enat (card I)) d = enat (card I div d)) \\<and>\n                      (0 < card I mod d \\<longrightarrow>\n                       f (enat (card I)) d = enat (Suc (card I div d)))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Results about sets of intervals\\<close>"], ["", "subsubsection \\<open>Set of intervals without and with empty interval\\<close>"], ["", "definition iFROM_UN_set :: \"(nat set) set\"\n  where \"iFROM_UN_set \\<equiv> \\<Union>n. {[n\\<dots>]}\""], ["", "definition iTILL_UN_set :: \"(nat set) set\"\n  where \"iTILL_UN_set \\<equiv> \\<Union>n. {[\\<dots>n]}\""], ["", "definition iIN_UN_set   :: \"(nat set) set\"\n  where \"iIN_UN_set   \\<equiv> \\<Union>n d. {[n\\<dots>,d]}\""], ["", "definition iMOD_UN_set  :: \"(nat set) set\"\n  where \"iMOD_UN_set  \\<equiv> \\<Union>r m. {[r, mod m]}\""], ["", "definition iMODb_UN_set :: \"(nat set) set\"\n  where \"iMODb_UN_set \\<equiv> \\<Union>r m c. {[r, mod m, c]}\""], ["", "definition iFROM_set :: \"(nat set) set\"\n  where \"iFROM_set \\<equiv> {[n\\<dots>] |n. True}\""], ["", "definition iTILL_set :: \"(nat set) set\"\n  where \"iTILL_set \\<equiv> {[\\<dots>n] |n. True}\""], ["", "definition iIN_set   :: \"(nat set) set\"\n  where \"iIN_set   \\<equiv> {[n\\<dots>,d] |n d. True}\""], ["", "definition iMOD_set  :: \"(nat set) set\"\n  where \"iMOD_set  \\<equiv> {[r, mod m] |r m. True}\""], ["", "definition iMODb_set :: \"(nat set) set\"\n  where \"iMODb_set \\<equiv> {[r, mod m, c] |r m c. True}\""], ["", "definition iMOD2_set  :: \"(nat set) set\"\n  where \"iMOD2_set  \\<equiv> {[r, mod m] |r m. 2 \\<le> m}\""], ["", "definition iMODb2_set :: \"(nat set) set\"\n  where \"iMODb2_set \\<equiv> {[r, mod m, c] |r m c. 2 \\<le> m \\<and> 1 \\<le> c}\""], ["", "definition iMOD2_UN_set  :: \"(nat set) set\"\n  where \"iMOD2_UN_set  \\<equiv> \\<Union>r. \\<Union>m\\<in>{2..}. {[r, mod m]}\""], ["", "definition iMODb2_UN_set :: \"(nat set) set\"\n  where \"iMODb2_UN_set \\<equiv> \\<Union>r. \\<Union>m\\<in>{2..}. \\<Union>c\\<in>{1..}. {[r, mod m, c]}\""], ["", "lemmas i_set_defs =\n  iFROM_set_def iTILL_set_def iIN_set_def\n  iMOD_set_def iMODb_set_def\n  iMOD2_set_def iMODb2_set_def"], ["", "lemmas i_UN_set_defs =\n  iFROM_UN_set_def iTILL_UN_set_def iIN_UN_set_def\n  iMOD_UN_set_def iMODb_UN_set_def\n  iMOD2_UN_set_def iMODb2_UN_set_def"], ["", "lemma iFROM_set_UN_set_eq: \"iFROM_set = iFROM_UN_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iFROM_set = iFROM_UN_set", "by (fastforce simp: iFROM_set_def iFROM_UN_set_def)"], ["", "lemma\n  iTILL_set_UN_set_eq: \"iTILL_set = iTILL_UN_set\" and\n  iIN_set_UN_set_eq:   \"iIN_set = iIN_UN_set\" and\n  iMOD_set_UN_set_eq:  \"iMOD_set = iMOD_UN_set\" and\n  iMODb_set_UN_set_eq: \"iMODb_set = iMODb_UN_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iTILL_set = iTILL_UN_set &&& iIN_set = iIN_UN_set) &&&\n    iMOD_set = iMOD_UN_set &&& iMODb_set = iMODb_UN_set", "by (fastforce simp: i_set_defs i_UN_set_defs)+"], ["", "lemma iMOD2_set_UN_set_eq: \"iMOD2_set = iMOD2_UN_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMOD2_set = iMOD2_UN_set", "by (fastforce simp: i_set_defs i_UN_set_defs)"], ["", "lemma iMODb2_set_UN_set_eq: \"iMODb2_set = iMODb2_UN_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMODb2_set = iMODb2_UN_set", "by (fastforce simp: i_set_defs i_UN_set_defs)"], ["", "lemmas i_set_i_UN_set_sets_eq =\n  iFROM_set_UN_set_eq\n  iTILL_set_UN_set_eq\n  iIN_set_UN_set_eq\n  iMOD_set_UN_set_eq\n  iMODb_set_UN_set_eq\n  iMOD2_set_UN_set_eq\n  iMODb2_set_UN_set_eq"], ["", "lemma iMOD2_set_iMOD_set_subset: \"iMOD2_set \\<subseteq> iMOD_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMOD2_set \\<subseteq> iMOD_set", "by (fastforce simp: i_set_defs)"], ["", "lemma iMODb2_set_iMODb_set_subset: \"iMODb2_set \\<subseteq> iMODb_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iMODb2_set \\<subseteq> iMODb_set", "by (fastforce simp: i_set_defs)"], ["", "definition i_set :: \"(nat set) set\"\n  where \"i_set \\<equiv> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union> iMOD_set \\<union> iMODb_set\""], ["", "definition i_UN_set :: \"(nat set) set\"\n  where \"i_UN_set \\<equiv> iFROM_UN_set \\<union> iTILL_UN_set \\<union> iIN_UN_set \\<union> iMOD_UN_set \\<union> iMODb_UN_set\""], ["", "text \\<open>Minimal definitions for @{term i_set} and @{term i_set}\\<close>"], ["", "definition i_set_min :: \"(nat set) set\"\n  where \"i_set_min \\<equiv> iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\""], ["", "definition i_UN_set_min :: \"(nat set) set\"\n  where \"i_UN_set_min \\<equiv> iFROM_UN_set \\<union> iIN_UN_set \\<union> iMOD2_UN_set \\<union> iMODb2_UN_set\""], ["", "definition i_set0 :: \"(nat set) set\"\n  where \"i_set0 \\<equiv> insert {} i_set\""], ["", "lemma i_set_i_UN_set_eq: \"i_set = i_UN_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set = i_UN_set", "by (simp add: i_set_def i_UN_set_def i_set_i_UN_set_sets_eq)"], ["", "lemma i_set_min_i_UN_set_min_eq: \"i_set_min = i_UN_set_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_min = i_UN_set_min", "by (simp add: i_set_min_def i_UN_set_min_def i_set_i_UN_set_sets_eq)"], ["", "lemma i_set_min_eq: \"i_set = i_set_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set = i_set_min", "apply (unfold i_set_def i_set_min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union> iMOD_set \\<union>\n    iMODb_set =\n    iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union> iMOD_set \\<union>\n    iMODb_set\n    \\<subseteq> iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union>\n                iMODb2_set\n 2. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n               iMOD_set \\<union>\n               iMODb_set \\<Longrightarrow>\n       x \\<in> iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union>\n               iMODb2_set\n 2. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (simp add: i_set_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n. x = [\\<dots>n]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ]) \\<or>\n       (\\<exists>r m c. x = [ r, mod m, c ]) \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (elim disjE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<exists>n. x = [n\\<dots>] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>n. x = [\\<dots>n] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. \\<And>x.\n       \\<exists>n d. x = [n\\<dots>,d] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 4. \\<And>x.\n       \\<exists>r m. x = [ r, mod m ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 5. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 6. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<exists>n. x = [\\<dots>n] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>n d. x = [n\\<dots>,d] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. \\<And>x.\n       \\<exists>r m. x = [ r, mod m ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 4. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 5. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (fastforce simp: iIN_0_iTILL_conv[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<exists>n d. x = [n\\<dots>,d] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>r m. x = [ r, mod m ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 4. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<exists>r m. x = [ r, mod m ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (elim exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x r m.\n       x = [ r, mod m ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (case_tac \"2 \\<le> m\", blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x r m.\n       \\<lbrakk>x = [ r, mod m ]; \\<not> 2 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (simp add: nat_ge2_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x r m.\n       \\<lbrakk>x = [ r, mod m ]; m = 0 \\<or> m = Suc 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. [ r, mod m ] = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. [ r, mod m ] = [n\\<dots>,d]) \\<or>\n                         (\\<exists>ra ma.\n                             [ r, mod m ] = [ ra, mod ma ] \\<and>\n                             0 < ma \\<and> ma \\<noteq> Suc 0) \\<or>\n                         (\\<exists>ra ma c.\n                             [ r, mod m ] = [ ra, mod ma, c ] \\<and>\n                             0 < ma \\<and>\n                             ma \\<noteq> Suc 0 \\<and> Suc 0 \\<le> c)\n 2. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (fastforce simp: iMOD_0 iMOD_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>r m c. x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (elim exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r m c.\n       x = [ r, mod m, c ] \\<Longrightarrow>\n       (\\<exists>n. x = [n\\<dots>]) \\<or>\n       (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n       (\\<exists>r m. x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n       (\\<exists>r m c.\n           x = [ r, mod m, c ] \\<and> 2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (case_tac \"1 \\<le> c\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; 1 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; \\<not> 1 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (case_tac \"2 \\<le> m\", fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; 1 \\<le> c; \\<not> 2 \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; \\<not> 1 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (simp add: nat_ge2_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; Suc 0 \\<le> c;\n        m = 0 \\<or> m = Suc 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. [ r, mod m, c ] = [n\\<dots>]) \\<or>\n                         (\\<exists>n d.\n                             [ r, mod m, c ] = [n\\<dots>,d]) \\<or>\n                         (\\<exists>ra ma.\n                             [ r, mod m, c ] = [ ra, mod ma ] \\<and>\n                             0 < ma \\<and> ma \\<noteq> Suc 0) \\<or>\n                         (\\<exists>ra ma ca.\n                             [ r, mod m, c ] = [ ra, mod ma, ca ] \\<and>\n                             0 < ma \\<and>\n                             ma \\<noteq> Suc 0 \\<and> Suc 0 \\<le> ca)\n 2. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; \\<not> 1 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 3. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (fastforce simp: iMODb_mod_0 iMODb_mod_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r m c.\n       \\<lbrakk>x = [ r, mod m, c ]; \\<not> 1 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n. x = [n\\<dots>]) \\<or>\n                         (\\<exists>n d. x = [n\\<dots>,d]) \\<or>\n                         (\\<exists>r m.\n                             x = [ r, mod m ] \\<and> 2 \\<le> m) \\<or>\n                         (\\<exists>r m c.\n                             x = [ r, mod m, c ] \\<and>\n                             2 \\<le> m \\<and> Suc 0 \\<le> c)\n 2. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (fastforce simp: linorder_not_le less_Suc_eq_le iMODb_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iFROM_set \\<union> iIN_set \\<union> iMOD2_set \\<union> iMODb2_set\n    \\<subseteq> iFROM_set \\<union> iTILL_set \\<union> iIN_set \\<union>\n                iMOD_set \\<union>\n                iMODb_set", "apply (rule Un_mono)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. iFROM_set \\<subseteq> iFROM_set \\<union> iTILL_set\n 2. iIN_set \\<subseteq> iIN_set\n 3. iMOD2_set \\<subseteq> iMOD_set\n 4. iMODb2_set \\<subseteq> iMODb_set", "apply (simp_all add: iMOD2_set_iMOD_set_subset iMODb2_set_iMODb_set_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary i_UN_set_i_UN_min_set_eq: \"i_UN_set = i_UN_set_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_UN_set = i_UN_set_min", "by (simp add: i_set_min_eq i_set_i_UN_set_eq[symmetric] i_set_min_i_UN_set_min_eq[symmetric])"], ["", "lemma i_set_min_is_minimal_let: \"\n  let s1 = iFROM_set; s2= iIN_set; s3= iMOD2_set; s4= iMODb2_set in\n  s1 \\<inter> s2 = {} \\<and> s1 \\<inter> s3 = {} \\<and> s1 \\<inter> s4 = {} \\<and>\n  s2 \\<inter> s3 = {} \\<and> s2 \\<inter> s4 = {} \\<and> s3 \\<inter> s4 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let s1 = iFROM_set; s2 = iIN_set; s3 = iMOD2_set; s4 = iMODb2_set\n    in s1 \\<inter> s2 = {} \\<and>\n       s1 \\<inter> s3 = {} \\<and>\n       s1 \\<inter> s4 = {} \\<and>\n       s2 \\<inter> s3 = {} \\<and>\n       s2 \\<inter> s4 = {} \\<and> s3 \\<inter> s4 = {}", "apply (unfold Let_def i_set_defs, intro conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. {[n\\<dots>] |n. True} \\<inter> {[n\\<dots>,d] |n d. True} = {}\n 2. {[n\\<dots>] |n. True} \\<inter> {[ r, mod m ] |r m. 2 \\<le> m} = {}\n 3. {[n\\<dots>] |n. True} \\<inter>\n    {[ r, mod m, c ] |r m c. 2 \\<le> m \\<and> 1 \\<le> c} =\n    {}\n 4. {[n\\<dots>,d] |n d. True} \\<inter> {[ r, mod m ] |r m. 2 \\<le> m} = {}\n 5. {[n\\<dots>,d] |n d. True} \\<inter>\n    {[ r, mod m, c ] |r m c. 2 \\<le> m \\<and> 1 \\<le> c} =\n    {}\n 6. {[ r, mod m ] |r m. 2 \\<le> m} \\<inter>\n    {[ r, mod m, c ] |r m c. 2 \\<le> m \\<and> 1 \\<le> c} =\n    {}", "apply (rule disjoint_iff_in_not_in1[THEN iffD2], clarsimp simp: iT_neq)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas i_set_min_is_minimal = i_set_min_is_minimal_let[simplified]"], ["", "inductive_set i_set_ind:: \"(nat set) set\"\nwhere\n  i_set_ind_FROM[intro!]:  \"[n\\<dots>] \\<in> i_set_ind\"\n| i_set_ind_TILL[intro!]:  \"[\\<dots>n] \\<in> i_set_ind\"\n| i_set_ind_IN[intro!]:    \"[n\\<dots>,d] \\<in> i_set_ind\"\n| i_set_ind_MOD[intro!]:   \"[r, mod m] \\<in> i_set_ind\"\n| i_set_ind_MODb[intro!]:  \"[r, mod m, c] \\<in> i_set_ind\""], ["", "inductive_set i_set0_ind :: \"(nat set) set\"\nwhere\n  i_set0_ind_empty[intro!] : \"{} \\<in> i_set0_ind\"\n| i_set0_ind_i_set[intro]:  \"I \\<in> i_set_ind \\<Longrightarrow> I \\<in> i_set0_ind\""], ["", "text \\<open>\n  The introduction rule \\<open>i_set0_ind_i_set\\<close> is not declared a safe introduction rule,\n  because it would disturb the correct usage of the \\<open>safe\\<close> method.\\<close>"], ["", "lemma i_set_ind_subset_i_set0_ind: \"i_set_ind \\<subseteq> i_set0_ind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_ind \\<subseteq> i_set0_ind", "by (rule subsetI, rule i_set0_ind_i_set)"], ["", "lemma\n  i_set0_ind_FROM[intro!] : \"[n\\<dots>] \\<in> i_set0_ind\" and\n  i_set0_ind_TILL[intro!] : \"[\\<dots>n] \\<in> i_set0_ind\" and\n  i_set0_ind_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set0_ind\" and\n  i_set0_ind_MOD[intro!]  : \"[r, mod m] \\<in> i_set0_ind\" and\n  i_set0_ind_MODb[intro!] : \"[r, mod m, c] \\<in> i_set0_ind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>] \\<in> i_set0_ind &&& [\\<dots>n] \\<in> i_set0_ind) &&&\n    [n\\<dots>,d] \\<in> i_set0_ind &&&\n    [ r, mod m ] \\<in> i_set0_ind &&& [ r, mod m, c ] \\<in> i_set0_ind", "by (rule subsetD[OF i_set_ind_subset_i_set0_ind], rule i_set_ind.intros)+"], ["", "lemmas i_set0_ind_intros2 =\n  i_set0_ind_empty\n  i_set0_ind_FROM\n  i_set0_ind_TILL\n  i_set0_ind_IN\n  i_set0_ind_MOD\n  i_set0_ind_MODb"], ["", "lemma i_set_i_set_ind_eq: \"i_set = i_set_ind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set = i_set_ind", "apply (rule set_eqI, unfold i_set_def i_set_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {[n\\<dots>] |n. True} \\<union>\n                {[\\<dots>n] |n. True} \\<union>\n                {[n\\<dots>,d] |n d. True} \\<union>\n                {[ r, mod m ] |r m. True} \\<union>\n                {[ r, mod m, c ] |r m c. True}) =\n       (x \\<in> i_set_ind)", "apply (rule iffI, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       x \\<in> {[n\\<dots>] |n. True} \\<union> {[\\<dots>n] |n. True} \\<union>\n               {[n\\<dots>,d] |n d. True} \\<union>\n               {[ r, mod m ] |r m. True} \\<union>\n               {[ r, mod m, c ] |r m c. True}", "apply (induct_tac x rule: i_set_ind.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<in> i_set_ind \\<Longrightarrow> x \\<in> i_set_ind\n 2. \\<And>x n.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [n\\<dots>]\n       \\<in> {[n\\<dots>] |n. True} \\<union> {[\\<dots>n] |n. True} \\<union>\n             {[n\\<dots>,d] |n d. True} \\<union>\n             {[ r, mod m ] |r m. True} \\<union>\n             {[ r, mod m, c ] |r m c. True}\n 3. \\<And>x n.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [\\<dots>n]\n       \\<in> {[n\\<dots>] |n. True} \\<union> {[\\<dots>n] |n. True} \\<union>\n             {[n\\<dots>,d] |n d. True} \\<union>\n             {[ r, mod m ] |r m. True} \\<union>\n             {[ r, mod m, c ] |r m c. True}\n 4. \\<And>x n d.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [n\\<dots>,d]\n       \\<in> {[n\\<dots>] |n. True} \\<union> {[\\<dots>n] |n. True} \\<union>\n             {[n\\<dots>,d] |n d. True} \\<union>\n             {[ r, mod m ] |r m. True} \\<union>\n             {[ r, mod m, c ] |r m c. True}\n 5. \\<And>x r m.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m ]\n       \\<in> {[n\\<dots>] |n. True} \\<union> {[\\<dots>n] |n. True} \\<union>\n             {[n\\<dots>,d] |n d. True} \\<union>\n             {[ r, mod m ] |r m. True} \\<union>\n             {[ r, mod m, c ] |r m c. True}\n 6. \\<And>x r m c.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m, c ]\n       \\<in> {[n\\<dots>] |n. True} \\<union> {[\\<dots>n] |n. True} \\<union>\n             {[n\\<dots>,d] |n d. True} \\<union>\n             {[ r, mod m ] |r m. True} \\<union>\n             {[ r, mod m, c ] |r m c. True}", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_i_set0_ind_eq: \"i_set0 = i_set0_ind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set0 = i_set0_ind", "apply (rule set_eqI, unfold i_set0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> insert {} i_set) = (x \\<in> i_set0_ind)", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x = {} \\<or> x \\<in> i_set_ind) = (x \\<in> i_set0_ind)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = {} \\<or> x \\<in> i_set_ind \\<Longrightarrow> x \\<in> i_set0_ind\n 2. \\<And>x.\n       x \\<in> i_set0_ind \\<Longrightarrow> x = {} \\<or> x \\<in> i_set_ind", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> i_set0_ind \\<Longrightarrow> x = {} \\<or> x \\<in> i_set_ind", "apply (rule_tac a=x in i_set0_ind.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> i_set0_ind \\<Longrightarrow> x \\<in> i_set0_ind\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> i_set0_ind; x = {}\\<rbrakk>\n       \\<Longrightarrow> x = {} \\<or> x \\<in> i_set_ind\n 3. \\<And>x I.\n       \\<lbrakk>x \\<in> i_set0_ind; x = I; I \\<in> i_set_ind\\<rbrakk>\n       \\<Longrightarrow> x = {} \\<or> x \\<in> i_set_ind", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_imp_not_empty: \"I \\<in> i_set \\<Longrightarrow> I \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set \\<Longrightarrow> I \\<noteq> {}", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set_ind \\<Longrightarrow> I \\<noteq> {}", "apply (induct I rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n. [n\\<dots>] \\<noteq> {}\n 2. \\<And>n. [\\<dots>n] \\<noteq> {}\n 3. \\<And>n d. [n\\<dots>,d] \\<noteq> {}\n 4. \\<And>r m. [ r, mod m ] \\<noteq> {}\n 5. \\<And>r m c. [ r, mod m, c ] \\<noteq> {}", "apply (rule iT_not_empty)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_i_set_mem_conv: \"(I \\<in> i_set0) = (I \\<in> i_set \\<or> I = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<in> i_set0) = (I \\<in> i_set \\<or> I = {})", "apply (simp add: i_set_i_set_ind_eq i_set0_i_set0_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<in> i_set0_ind) = (I \\<in> i_set_ind \\<or> I = {})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. I \\<in> i_set0_ind \\<Longrightarrow> I \\<in> i_set_ind \\<or> I = {}\n 2. I \\<in> i_set_ind \\<or> I = {} \\<Longrightarrow> I \\<in> i_set0_ind", "apply (rule i_set0_ind.cases[of I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I \\<in> i_set0_ind \\<Longrightarrow> I \\<in> i_set0_ind\n 2. \\<lbrakk>I \\<in> i_set0_ind; I = {}\\<rbrakk>\n    \\<Longrightarrow> I \\<in> i_set_ind \\<or> I = {}\n 3. \\<And>Ia.\n       \\<lbrakk>I \\<in> i_set0_ind; I = Ia; Ia \\<in> i_set_ind\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set_ind \\<or> I = {}\n 4. I \\<in> i_set_ind \\<or> I = {} \\<Longrightarrow> I \\<in> i_set0_ind", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_i_set0_mem_conv: \"(I \\<in> i_set) = (I \\<in> i_set0 \\<and> I \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<in> i_set) = (I \\<in> i_set0 \\<and> I \\<noteq> {})", "apply (insert i_set_imp_not_empty[of I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<in> i_set \\<Longrightarrow> I \\<noteq> {}) \\<Longrightarrow>\n    (I \\<in> i_set) = (I \\<in> i_set0 \\<and> I \\<noteq> {})", "apply (fastforce simp: i_set0_i_set_mem_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_i_set_conv: \"i_set0 - {{}} = i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set0 - {{}} = i_set", "by (fastforce simp: i_set_i_set0_mem_conv)"], ["", "corollary i_set_subset_i_set0: \"i_set \\<subseteq> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set \\<subseteq> i_set0", "by (simp add: i_set0_i_set_conv[symmetric])"], ["", "lemma i_set_singleton: \"{a} \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<in> i_set", "by (fastforce simp: i_set_def iIN_set_def iIN_0[symmetric])"], ["", "lemma i_set0_singleton: \"{a} \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<in> i_set0", "apply (rule subsetD[OF i_set_subset_i_set0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<in> i_set", "apply (simp add: iIN_0[symmetric] i_set_i_set_ind_eq i_set_ind.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary\n  i_set_FROM[intro!] : \"[n\\<dots>] \\<in> i_set\" and\n  i_set_TILL[intro!] : \"[\\<dots>n] \\<in> i_set\" and\n  i_set_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set\" and\n  i_set_MOD[intro!]  : \"[r, mod m] \\<in> i_set\" and\n  i_set_MODb[intro!] : \"[r, mod m, c] \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([n\\<dots>] \\<in> i_set &&& [\\<dots>n] \\<in> i_set) &&&\n    [n\\<dots>,d] \\<in> i_set &&&\n    [ r, mod m ] \\<in> i_set &&& [ r, mod m, c ] \\<in> i_set", "by (rule ssubst[OF i_set_i_set_ind_eq], rule i_set_ind.intros)+"], ["", "lemmas i_set_intros =\n  i_set_FROM\n  i_set_TILL\n  i_set_IN\n  i_set_MOD\n  i_set_MODb"], ["", "lemma\n  i_set0_empty[intro!]: \"{} \\<in> i_set0\" and\n  i_set0_FROM[intro!] : \"[n\\<dots>] \\<in> i_set0\" and\n  i_set0_TILL[intro!] : \"[\\<dots>n] \\<in> i_set0\" and\n  i_set0_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set0\" and\n  i_set0_MOD[intro!]  : \"[r, mod m] \\<in> i_set0\" and\n  i_set0_MODb[intro!] : \"[r, mod m, c] \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} \\<in> i_set0 &&&\n     [n\\<dots>] \\<in> i_set0 &&& [\\<dots>n] \\<in> i_set0) &&&\n    [n\\<dots>,d] \\<in> i_set0 &&&\n    [ r, mod m ] \\<in> i_set0 &&& [ r, mod m, c ] \\<in> i_set0", "by (rule ssubst[OF i_set0_i_set0_ind_eq], rule i_set0_ind_intros2)+"], ["", "lemmas i_set0_intros =\n  i_set0_empty\n  i_set0_FROM\n  i_set0_TILL\n  i_set0_IN\n  i_set0_MOD\n  i_set0_MODb"], ["", "lemma i_set_infinite_as_iMOD:\"\n  \\<lbrakk> I \\<in> i_set; infinite I \\<rbrakk> \\<Longrightarrow> \\<exists>r m. I = [r, mod m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; infinite I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r m. I = [ r, mod m ]", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_ind; infinite I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r m. I = [ r, mod m ]", "apply (induct I rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       infinite [n\\<dots>] \\<Longrightarrow>\n       \\<exists>r m. [n\\<dots>] = [ r, mod m ]\n 2. \\<And>n.\n       infinite [\\<dots>n] \\<Longrightarrow>\n       \\<exists>r m. [\\<dots>n] = [ r, mod m ]\n 3. \\<And>n d.\n       infinite [n\\<dots>,d] \\<Longrightarrow>\n       \\<exists>r m. [n\\<dots>,d] = [ r, mod m ]\n 4. \\<And>r m.\n       infinite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma. [ r, mod m ] = [ ra, mod ma ]\n 5. \\<And>r m c.\n       infinite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma. [ r, mod m, c ] = [ ra, mod ma ]", "apply (simp_all add: iT_finite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       infinite [n\\<dots>] \\<Longrightarrow>\n       \\<exists>r m. [n\\<dots>] = [ r, mod m ]\n 2. \\<And>r m.\n       infinite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma. [ r, mod m ] = [ ra, mod ma ]", "apply (rule_tac x=n in exI, rule_tac x=\"Suc 0\" in exI, simp add: iMOD_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r m.\n       infinite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma. [ r, mod m ] = [ ra, mod ma ]", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_finite_as_iMODb:\"\n  \\<lbrakk> I \\<in> i_set; finite I \\<rbrakk> \\<Longrightarrow> \\<exists>r m c. I = [r, mod m, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; finite I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r m c. I = [ r, mod m, c ]", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_ind; finite I\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r m c. I = [ r, mod m, c ]", "apply (induct I rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       finite [n\\<dots>] \\<Longrightarrow>\n       \\<exists>r m c. [n\\<dots>] = [ r, mod m, c ]\n 2. \\<And>n.\n       finite [\\<dots>n] \\<Longrightarrow>\n       \\<exists>r m c. [\\<dots>n] = [ r, mod m, c ]\n 3. \\<And>n d.\n       finite [n\\<dots>,d] \\<Longrightarrow>\n       \\<exists>r m c. [n\\<dots>,d] = [ r, mod m, c ]\n 4. \\<And>r m.\n       finite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 5. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (simp add: iT_infinite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       finite [\\<dots>n] \\<Longrightarrow>\n       \\<exists>r m c. [\\<dots>n] = [ r, mod m, c ]\n 2. \\<And>n d.\n       finite [n\\<dots>,d] \\<Longrightarrow>\n       \\<exists>r m c. [n\\<dots>,d] = [ r, mod m, c ]\n 3. \\<And>r m.\n       finite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 4. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (rule_tac x=0 in exI, rule_tac x=\"Suc 0\" in exI, rule_tac x=n in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       finite [\\<dots>n] \\<Longrightarrow> [\\<dots>n] = [ 0, mod Suc 0, n ]\n 2. \\<And>n d.\n       finite [n\\<dots>,d] \\<Longrightarrow>\n       \\<exists>r m c. [n\\<dots>,d] = [ r, mod m, c ]\n 3. \\<And>r m.\n       finite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 4. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (simp add: iMODb_mod_1 iIN_0_iTILL_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n d.\n       finite [n\\<dots>,d] \\<Longrightarrow>\n       \\<exists>r m c. [n\\<dots>,d] = [ r, mod m, c ]\n 2. \\<And>r m.\n       finite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 3. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (rule_tac x=n in exI, rule_tac x=\"Suc 0\" in exI, rule_tac x=d in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n d.\n       finite [n\\<dots>,d] \\<Longrightarrow>\n       [n\\<dots>,d] = [ n, mod Suc 0, d ]\n 2. \\<And>r m.\n       finite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 3. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (simp add: iMODb_mod_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r m.\n       finite [ r, mod m ] \\<Longrightarrow>\n       \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 2. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r m.\n       \\<lbrakk>finite [ r, mod m ]; m = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 2. \\<And>r m.\n       \\<lbrakk>finite [ r, mod m ]; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 3. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (rule_tac x=r in exI, rule_tac x=\"Suc 0\" in exI, rule_tac x=0 in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r m.\n       \\<lbrakk>finite [ r, mod m ]; m = 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m ] = [ r, mod Suc 0, 0 ]\n 2. \\<And>r m.\n       \\<lbrakk>finite [ r, mod m ]; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 3. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (simp add: iMOD_0 iIN_0 iMODb_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r m.\n       \\<lbrakk>finite [ r, mod m ]; m \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ra ma c. [ r, mod m ] = [ ra, mod ma, c ]\n 2. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply (simp add: iT_infinite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r m c.\n       finite [ r, mod m, c ] \\<Longrightarrow>\n       \\<exists>ra ma ca. [ r, mod m, c ] = [ ra, mod ma, ca ]", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_as_iMOD_iMODb: \"\n  I \\<in> i_set \\<Longrightarrow> (\\<exists>r m. I = [r, mod m]) \\<or> (\\<exists>r m c. I = [r, mod m, c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set \\<Longrightarrow>\n    (\\<exists>r m. I = [ r, mod m ]) \\<or>\n    (\\<exists>r m c. I = [ r, mod m, c ])", "by (blast intro: i_set_finite_as_iMODb i_set_infinite_as_iMOD)"], ["", "subsubsection \\<open>Interval sets are closed under cutting\\<close>"], ["", "lemma i_set_cut_le_ge_closed_disj: \"\n  \\<lbrakk> I \\<in> i_set; t \\<in> I; cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>) \\<rbrakk> \\<Longrightarrow>\n  cut_op I t \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; t \\<in> I;\n     cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n    \\<Longrightarrow> cut_op I t \\<in> i_set", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_ind; t \\<in> I;\n     cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n    \\<Longrightarrow> cut_op I t \\<in> i_set_ind", "apply (induct rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>t \\<in> [n\\<dots>];\n        cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [n\\<dots>] t \\<in> i_set_ind\n 2. \\<And>n.\n       \\<lbrakk>t \\<in> [\\<dots>n];\n        cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [\\<dots>n] t \\<in> i_set_ind\n 3. \\<And>n d.\n       \\<lbrakk>t \\<in> [n\\<dots>,d];\n        cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [n\\<dots>,d] t \\<in> i_set_ind\n 4. \\<And>r m.\n       \\<lbrakk>t \\<in> [ r, mod m ];\n        cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [ r, mod m ] t \\<in> i_set_ind\n 5. \\<And>r m c.\n       \\<lbrakk>t \\<in> [ r, mod m, c ];\n        cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [ r, mod m, c ] t \\<in> i_set_ind", "apply safe"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>t \\<in> [n\\<dots>]; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<down>\\<le> t \\<in> i_set_ind\n 2. \\<And>n.\n       \\<lbrakk>t \\<in> [n\\<dots>]; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<down>\\<ge> t \\<in> i_set_ind\n 3. \\<And>n.\n       \\<lbrakk>t \\<in> [\\<dots>n]; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<down>\\<le> t \\<in> i_set_ind\n 4. \\<And>n.\n       \\<lbrakk>t \\<in> [\\<dots>n]; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<down>\\<ge> t \\<in> i_set_ind\n 5. \\<And>n d.\n       \\<lbrakk>t \\<in> [n\\<dots>,d]; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>,d] \\<down>\\<le> t \\<in> i_set_ind\n 6. \\<And>n d.\n       \\<lbrakk>t \\<in> [n\\<dots>,d]; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>,d] \\<down>\\<ge> t \\<in> i_set_ind\n 7. \\<And>r m.\n       \\<lbrakk>t \\<in> [ r, mod m ]; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m ] \\<down>\\<le> t \\<in> i_set_ind\n 8. \\<And>r m.\n       \\<lbrakk>t \\<in> [ r, mod m ]; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m ] \\<down>\\<ge> t \\<in> i_set_ind\n 9. \\<And>r m c.\n       \\<lbrakk>t \\<in> [ r, mod m, c ]; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<le> t \\<in> i_set_ind\n 10. \\<And>r m c.\n        \\<lbrakk>t \\<in> [ r, mod m, c ]; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n        \\<Longrightarrow> [ r, mod m, c ] \\<down>\\<ge> t \\<in> i_set_ind", "apply (simp_all add: iT_cut_le1 iT_cut_ge1 i_set_ind.intros iMODb_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary\n  i_set_cut_le_closed: \"\\<lbrakk> I \\<in> i_set; t \\<in> I \\<rbrakk> \\<Longrightarrow> I \\<down>\\<le> t \\<in> i_set\" and\n  i_set_cut_ge_closed: \"\\<lbrakk> I \\<in> i_set; t \\<in> I \\<rbrakk> \\<Longrightarrow> I \\<down>\\<ge> t \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>I \\<in> i_set; t \\<in> I\\<rbrakk>\n     \\<Longrightarrow> I \\<down>\\<le> t \\<in> i_set) &&&\n    (\\<lbrakk>I \\<in> i_set; t \\<in> I\\<rbrakk>\n     \\<Longrightarrow> I \\<down>\\<ge> t \\<in> i_set)", "by (simp_all add: i_set_cut_le_ge_closed_disj)"], ["", "lemmas i_set_cut_le_ge_closed = i_set_cut_le_closed i_set_cut_ge_closed"], ["", "lemma i_set0_cut_closed_disj: \"\n  \\<lbrakk> I \\<in> i_set0;\n    cut_op = (\\<down>\\<le>) \\<or> cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<rbrakk> \\<Longrightarrow>\n  cut_op I t \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set0;\n     cut_op = (\\<down>\\<le>) \\<or>\n     cut_op = (\\<down>\\<ge>) \\<or>\n     cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n    \\<Longrightarrow> cut_op I t \\<in> i_set0", "apply (simp add: i_set0_i_set0_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set0_ind;\n     cut_op = (\\<down>\\<le>) \\<or>\n     cut_op = (\\<down>\\<ge>) \\<or>\n     cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n    \\<Longrightarrow> cut_op I t \\<in> i_set0_ind", "apply (induct rule: i_set0_ind.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cut_op = (\\<down>\\<le>) \\<or>\n    cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<Longrightarrow>\n    cut_op {} t \\<in> i_set0_ind\n 2. \\<And>I.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op I t \\<in> i_set0_ind", "apply (rule ssubst[OF set_restriction_empty, where P=\"\\<lambda>x. x \\<in> i_set0_ind\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. cut_op = (\\<down>\\<le>) \\<or>\n    cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<Longrightarrow>\n    set_restriction (\\<lambda>a. cut_op a t)\n 2. cut_op = (\\<down>\\<le>) \\<or>\n    cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<Longrightarrow>\n    {} \\<in> i_set0_ind\n 3. \\<And>I.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op I t \\<in> i_set0_ind", "apply (rule i_cut_set_restriction_disj[of cut_op], blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cut_op = (\\<down>\\<le>) \\<or>\n    cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<Longrightarrow>\n    (\\<lambda>a. cut_op a t) = (\\<lambda>I. cut_op I ?t6)\n 2. cut_op = (\\<down>\\<le>) \\<or>\n    cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<Longrightarrow>\n    {} \\<in> i_set0_ind\n 3. \\<And>I.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op I t \\<in> i_set0_ind", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. cut_op = (\\<down>\\<le>) \\<or>\n    cut_op = (\\<down>\\<ge>) \\<or>\n    cut_op = (\\<down><) \\<or> cut_op = (\\<down>>) \\<Longrightarrow>\n    {} \\<in> i_set0_ind\n 2. \\<And>I.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op I t \\<in> i_set0_ind", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op I t \\<in> i_set0_ind", "apply (induct_tac I rule: i_set_ind.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set_ind\n 2. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [n\\<dots>] t \\<in> i_set0_ind\n 3. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [\\<dots>n] t \\<in> i_set0_ind\n 4. \\<And>I n d.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [n\\<dots>,d] t \\<in> i_set0_ind\n 5. \\<And>I r m.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [ r, mod m ] t \\<in> i_set0_ind\n 6. \\<And>I r m c.\n       \\<lbrakk>I \\<in> i_set_ind;\n        cut_op = (\\<down>\\<le>) \\<or>\n        cut_op = (\\<down>\\<ge>) \\<or>\n        cut_op = (\\<down><) \\<or> cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> cut_op [ r, mod m, c ] t \\<in> i_set0_ind", "apply safe"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<down>\\<le> t \\<in> i_set0_ind\n 2. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<down>\\<ge> t \\<in> i_set0_ind\n 3. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down><)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<down>< t \\<in> i_set0_ind\n 4. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<down>> t \\<in> i_set0_ind\n 5. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<down>\\<le> t \\<in> i_set0_ind\n 6. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<down>\\<ge> t \\<in> i_set0_ind\n 7. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down><)\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<down>< t \\<in> i_set0_ind\n 8. \\<And>I n.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>>)\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<down>> t \\<in> i_set0_ind\n 9. \\<And>I n d.\n       \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>\\<le>)\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>,d] \\<down>\\<le> t \\<in> i_set0_ind\n 10. \\<And>I n d.\n        \\<lbrakk>I \\<in> i_set_ind; cut_op = (\\<down>\\<ge>)\\<rbrakk>\n        \\<Longrightarrow> [n\\<dots>,d] \\<down>\\<ge> t \\<in> i_set0_ind\nA total of 20 subgoals...", "apply (simp_all add: iT_cut_le iT_cut_ge iT_cut_less iT_cut_greater i_set0_ind_intros2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary\n  i_set0_cut_le_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<down>\\<le> t \\<in> i_set0\" and\n  i_set0_cut_less_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<down>< t \\<in> i_set0\" and\n  i_set0_cut_ge_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<down>\\<ge> t \\<in> i_set0\" and\n  i_set0_cut_greater_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<down>> t \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((I \\<in> i_set0 \\<Longrightarrow> I \\<down>\\<le> t \\<in> i_set0) &&&\n     (I \\<in> i_set0 \\<Longrightarrow> I \\<down>< t \\<in> i_set0)) &&&\n    (I \\<in> i_set0 \\<Longrightarrow> I \\<down>\\<ge> t \\<in> i_set0) &&&\n    (I \\<in> i_set0 \\<Longrightarrow> I \\<down>> t \\<in> i_set0)", "by (simp_all add: i_set0_cut_closed_disj)"], ["", "lemmas i_set0_cut_closed =\n  i_set0_cut_le_closed\n  i_set0_cut_less_closed\n  i_set0_cut_ge_closed\n  i_set0_cut_greater_closed"], ["", "subsubsection \\<open>Interval sets are closed under addition and multiplication\\<close>"], ["", "lemma i_set_Plus_closed: \"I \\<in> i_set \\<Longrightarrow> I \\<oplus> k \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set \\<Longrightarrow> I \\<oplus> k \\<in> i_set", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set_ind \\<Longrightarrow> I \\<oplus> k \\<in> i_set_ind", "apply (induct rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n. [n\\<dots>] \\<oplus> k \\<in> i_set_ind\n 2. \\<And>n. [\\<dots>n] \\<oplus> k \\<in> i_set_ind\n 3. \\<And>n d. [n\\<dots>,d] \\<oplus> k \\<in> i_set_ind\n 4. \\<And>r m. [ r, mod m ] \\<oplus> k \\<in> i_set_ind\n 5. \\<And>r m c. [ r, mod m, c ] \\<oplus> k \\<in> i_set_ind", "apply (simp_all add: iT_add i_set_ind.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_Mult_closed: \"I \\<in> i_set \\<Longrightarrow> I \\<otimes> k \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set \\<Longrightarrow> I \\<otimes> k \\<in> i_set", "apply (case_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<in> i_set; k = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> k \\<in> i_set\n 2. \\<lbrakk>I \\<in> i_set; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> k \\<in> i_set", "apply (simp add: i_set_imp_not_empty iT_Mult_0_if i_set_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> k \\<in> i_set", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_ind; 0 < k\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> k \\<in> i_set_ind", "apply (induct rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n. 0 < k \\<Longrightarrow> [n\\<dots>] \\<otimes> k \\<in> i_set_ind\n 2. \\<And>n. 0 < k \\<Longrightarrow> [\\<dots>n] \\<otimes> k \\<in> i_set_ind\n 3. \\<And>n d.\n       0 < k \\<Longrightarrow> [n\\<dots>,d] \\<otimes> k \\<in> i_set_ind\n 4. \\<And>r m.\n       0 < k \\<Longrightarrow> [ r, mod m ] \\<otimes> k \\<in> i_set_ind\n 5. \\<And>r m c.\n       0 < k \\<Longrightarrow> [ r, mod m, c ] \\<otimes> k \\<in> i_set_ind", "apply (simp_all add: iT_mult i_set_ind.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_Plus_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<oplus> k \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0 \\<Longrightarrow> I \\<oplus> k \\<in> i_set0", "apply (simp add: i_set0_i_set0_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0_ind \\<Longrightarrow> I \\<oplus> k \\<in> i_set0_ind", "apply (induct I rule: i_set0_ind.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} \\<oplus> k \\<in> i_set0_ind\n 2. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<oplus> k \\<in> i_set0_ind", "apply (simp add: iT_Plus_empty i_set0_ind_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<oplus> k \\<in> i_set0_ind", "apply (rule subsetD[OF i_set_ind_subset_i_set0_ind])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<oplus> k \\<in> i_set_ind", "apply (simp add: i_set_i_set_ind_eq[symmetric] i_set_Plus_closed)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_Mult_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<otimes> k \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0 \\<Longrightarrow> I \\<otimes> k \\<in> i_set0", "apply (simp add: i_set0_i_set0_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0_ind \\<Longrightarrow> I \\<otimes> k \\<in> i_set0_ind", "apply (induct I rule: i_set0_ind.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} \\<otimes> k \\<in> i_set0_ind\n 2. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<otimes> k \\<in> i_set0_ind", "apply (simp add: iT_Mult_empty i_set0_ind_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<otimes> k \\<in> i_set0_ind", "apply (rule subsetD[OF i_set_ind_subset_i_set0_ind])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<otimes> k \\<in> i_set_ind", "apply (simp add: i_set_i_set_ind_eq[symmetric] i_set_Mult_closed)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Interval sets are closed with certain conditions under subtraction\\<close>"], ["", "lemma i_set_Plus_neg_closed: \"\n  \\<lbrakk> I \\<in> i_set; \\<exists>x\\<in>I. k \\<le> x \\<rbrakk> \\<Longrightarrow> I \\<oplus>- k \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; \\<exists>x\\<in>I. k \\<le> x\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus>- k \\<in> i_set", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_ind; \\<exists>x\\<in>I. k \\<le> x\\<rbrakk>\n    \\<Longrightarrow> I \\<oplus>- k \\<in> i_set_ind", "apply (induct rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       Bex [n\\<dots>] ((\\<le>) k) \\<Longrightarrow>\n       [n\\<dots>] \\<oplus>- k \\<in> i_set_ind\n 2. \\<And>n.\n       Bex [\\<dots>n] ((\\<le>) k) \\<Longrightarrow>\n       [\\<dots>n] \\<oplus>- k \\<in> i_set_ind\n 3. \\<And>n d.\n       Bex [n\\<dots>,d] ((\\<le>) k) \\<Longrightarrow>\n       [n\\<dots>,d] \\<oplus>- k \\<in> i_set_ind\n 4. \\<And>r m.\n       Bex [ r, mod m ] ((\\<le>) k) \\<Longrightarrow>\n       [ r, mod m ] \\<oplus>- k \\<in> i_set_ind\n 5. \\<And>r m c.\n       Bex [ r, mod m, c ] ((\\<le>) k) \\<Longrightarrow>\n       [ r, mod m, c ] \\<oplus>- k \\<in> i_set_ind", "apply (fastforce simp: iT_iff iT_add_neg)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_Minus_closed: \"\n  \\<lbrakk> I \\<in> i_set; iMin I \\<le> k \\<rbrakk> \\<Longrightarrow> k \\<ominus> I \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I \\<in> i_set", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_ind; iMin I \\<le> k\\<rbrakk>\n    \\<Longrightarrow> k \\<ominus> I \\<in> i_set_ind", "apply (induct rule: i_set_ind.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       iMin [n\\<dots>] \\<le> k \\<Longrightarrow>\n       k \\<ominus> [n\\<dots>] \\<in> i_set_ind\n 2. \\<And>n.\n       iMin [\\<dots>n] \\<le> k \\<Longrightarrow>\n       k \\<ominus> [\\<dots>n] \\<in> i_set_ind\n 3. \\<And>n d.\n       iMin [n\\<dots>,d] \\<le> k \\<Longrightarrow>\n       k \\<ominus> [n\\<dots>,d] \\<in> i_set_ind\n 4. \\<And>r m.\n       iMin [ r, mod m ] \\<le> k \\<Longrightarrow>\n       k \\<ominus> [ r, mod m ] \\<in> i_set_ind\n 5. \\<And>r m c.\n       iMin [ r, mod m, c ] \\<le> k \\<Longrightarrow>\n       k \\<ominus> [ r, mod m, c ] \\<in> i_set_ind", "apply (fastforce simp: iT_Min iT_sub)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_Plus_neg_closed: \"I \\<in> i_set0 \\<Longrightarrow> I \\<oplus>- k \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0 \\<Longrightarrow> I \\<oplus>- k \\<in> i_set0", "apply (simp add: i_set0_i_set0_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0_ind \\<Longrightarrow> I \\<oplus>- k \\<in> i_set0_ind", "apply (induct rule: i_set0_ind.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} \\<oplus>- k \\<in> i_set0_ind\n 2. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<oplus>- k \\<in> i_set0_ind", "apply (fastforce simp: iT_Plus_neg_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> I \\<oplus>- k \\<in> i_set0_ind", "apply (induct_tac I rule: i_set_ind.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>I. I \\<in> i_set_ind \\<Longrightarrow> I \\<in> i_set_ind\n 2. \\<And>I n.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       [n\\<dots>] \\<oplus>- k \\<in> i_set0_ind\n 3. \\<And>I n.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       [\\<dots>n] \\<oplus>- k \\<in> i_set0_ind\n 4. \\<And>I n d.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       [n\\<dots>,d] \\<oplus>- k \\<in> i_set0_ind\n 5. \\<And>I r m.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m ] \\<oplus>- k \\<in> i_set0_ind\n 6. \\<And>I r m c.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m, c ] \\<oplus>- k \\<in> i_set0_ind", "apply (fastforce simp: iT_add_neg)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_Minus_closed: \"I \\<in> i_set0 \\<Longrightarrow> k \\<ominus> I \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0 \\<Longrightarrow> k \\<ominus> I \\<in> i_set0", "apply (simp add: i_set0_i_set0_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0_ind \\<Longrightarrow> k \\<ominus> I \\<in> i_set0_ind", "apply (induct rule: i_set0_ind.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<ominus> {} \\<in> i_set0_ind\n 2. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> k \\<ominus> I \\<in> i_set0_ind", "apply (simp add: iT_Minus_empty i_set0_ind_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<in> i_set_ind \\<Longrightarrow> k \\<ominus> I \\<in> i_set0_ind", "apply (induct_tac I rule: i_set_ind.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>I. I \\<in> i_set_ind \\<Longrightarrow> I \\<in> i_set_ind\n 2. \\<And>I n.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       k \\<ominus> [n\\<dots>] \\<in> i_set0_ind\n 3. \\<And>I n.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       k \\<ominus> [\\<dots>n] \\<in> i_set0_ind\n 4. \\<And>I n d.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       k \\<ominus> [n\\<dots>,d] \\<in> i_set0_ind\n 5. \\<And>I r m.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       k \\<ominus> [ r, mod m ] \\<in> i_set0_ind\n 6. \\<And>I r m c.\n       I \\<in> i_set_ind \\<Longrightarrow>\n       k \\<ominus> [ r, mod m, c ] \\<in> i_set0_ind", "apply (fastforce simp: iT_sub)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas i_set_IntOp_closed =\n  i_set_Plus_closed\n  i_set_Mult_closed\n  i_set_Plus_neg_closed\n  i_set_Minus_closed"], ["", "lemmas i_set0_IntOp_closed =\n  i_set0_Plus_closed\n  i_set0_Mult_closed\n  i_set0_Plus_neg_closed\n  i_set0_Minus_closed"], ["", "subsubsection \\<open>Interval sets are not closed under division\\<close>"], ["", "lemma iMOD_div_mod_gr0_not_in_i_set: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k \\<rbrakk> \\<Longrightarrow> [r, mod m] \\<oslash> k \\<notin> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<oslash> k \\<notin> i_set", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k;\n     [ r, mod m ] \\<oslash> k \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule i_set_infinite_as_iMOD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k\\<rbrakk>\n    \\<Longrightarrow> infinite ([ r, mod m ] \\<oslash> k)\n 2. \\<lbrakk>0 < k; k < m; 0 < m mod k;\n     \\<exists>ra ma. [ r, mod m ] \\<oslash> k = [ ra, mod ma ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: iT_Div_finite_iff iMOD_infinite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k;\n     \\<exists>ra ma. [ r, mod m ] \\<oslash> k = [ ra, mod ma ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim exE, rename_tac r' m')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k;\n        [ r, mod m ] \\<oslash> k = [ r', mod m' ]\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule iMOD_div_mod_gr0_not_ex[of k m r], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k;\n        [ r, mod m ] \\<oslash> k = [ r', mod m' ];\n        \\<nexists>r' m'. [ r', mod m' ] = [ r, mod m ] \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iMODb_div_mod_gr0_not_in_i_set: \"\n  \\<lbrakk> 0 < k; k < m; 0 < m mod k; k \\<le> c \\<rbrakk> \\<Longrightarrow> [r, mod m, c] \\<oslash> k \\<notin> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m, c ] \\<oslash> k \\<notin> i_set", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n     [ r, mod m, c ] \\<oslash> k \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule i_set_finite_as_iMODb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c\\<rbrakk>\n    \\<Longrightarrow> finite ([ r, mod m, c ] \\<oslash> k)\n 2. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n     \\<exists>ra ma ca.\n        [ r, mod m, c ] \\<oslash> k = [ ra, mod ma, ca ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: iT_Div_finite_iff iMODb_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n     \\<exists>ra ma ca.\n        [ r, mod m, c ] \\<oslash> k = [ ra, mod ma, ca ]\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim exE, rename_tac r' m' c')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m' c'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n        [ r, mod m, c ] \\<oslash> k = [ r', mod m', c' ]\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule iMODb_div_mod_gr0_not_ex[of k m c r], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' m' c'.\n       \\<lbrakk>0 < k; k < m; 0 < m mod k; k \\<le> c;\n        [ r, mod m, c ] \\<oslash> k = [ r', mod m', c' ];\n        \\<nexists>r' m' c'.\n           [ r', mod m', c' ] = [ r, mod m, c ] \\<oslash> k\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"[0, mod 3] \\<oslash> 2 \\<notin> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ 0, mod 3 ] \\<oslash> 2 \\<notin> i_set", "by (rule iMOD_div_mod_gr0_not_in_i_set, simp+)"], ["", "lemma i_set_Div_not_closed: \"Suc 0 < k \\<Longrightarrow> \\<exists>I\\<in>i_set. I \\<oslash> k \\<notin> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < k \\<Longrightarrow>\n    \\<exists>I\\<in>i_set. I \\<oslash> k \\<notin> i_set", "apply (rule_tac x=\"[0, mod (Suc k)]\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc 0 < k \\<Longrightarrow> [ 0, mod Suc k ] \\<oslash> k \\<notin> i_set\n 2. Suc 0 < k \\<Longrightarrow> [ 0, mod Suc k ] \\<in> i_set", "apply (rule iMOD_div_mod_gr0_not_in_i_set)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Suc 0 < k \\<Longrightarrow> 0 < k\n 2. Suc 0 < k \\<Longrightarrow> k < Suc k\n 3. Suc 0 < k \\<Longrightarrow> 0 < Suc k mod k\n 4. Suc 0 < k \\<Longrightarrow> [ 0, mod Suc k ] \\<in> i_set", "apply (simp_all add: mod_Suc i_set_MOD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_Div_not_closed: \"Suc 0 < k \\<Longrightarrow> \\<exists>I\\<in>i_set0. I \\<oslash> k \\<notin> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < k \\<Longrightarrow>\n    \\<exists>I\\<in>i_set0. I \\<oslash> k \\<notin> i_set0", "apply (frule i_set_Div_not_closed, erule bexE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>Suc 0 < k; I \\<in> i_set;\n        I \\<oslash> k \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>I\\<in>i_set0.\n                            I \\<oslash> k \\<notin> i_set0", "apply (rule_tac x=I in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>Suc 0 < k; I \\<in> i_set;\n        I \\<oslash> k \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> I \\<oslash> k \\<notin> i_set0\n 2. \\<And>I.\n       \\<lbrakk>Suc 0 < k; I \\<in> i_set;\n        I \\<oslash> k \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set0", "apply (simp add: i_set0_def iT_Div_not_empty i_set_imp_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>Suc 0 < k; I \\<in> i_set;\n        I \\<oslash> k \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set0", "apply (rule subsetD[OF i_set_subset_i_set0], assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Sets of intervals closed under division\\<close>"], ["", "inductive_set NatMultiples :: \"nat set \\<Rightarrow> nat set\"\n  for F :: \"nat set\"\nwhere\n  NatMultiples_Factor: \"k \\<in> F \\<Longrightarrow> k \\<in> NatMultiples F\"\n| NatMultiples_Product: \"\\<lbrakk> k \\<in> F; m \\<in> NatMultiples F \\<rbrakk> \\<Longrightarrow> k * m \\<in> NatMultiples F\""], ["", "lemma NatMultiples_ex_divisor: \"m \\<in> NatMultiples F \\<Longrightarrow> \\<exists>k\\<in>F. m mod k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> NatMultiples F \\<Longrightarrow> \\<exists>k\\<in>F. m mod k = 0", "apply (induct m rule: NatMultiples.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k. k \\<in> F \\<Longrightarrow> \\<exists>ka\\<in>F. k mod ka = 0\n 2. \\<And>k m.\n       \\<lbrakk>k \\<in> F; m \\<in> NatMultiples F;\n        \\<exists>k\\<in>F. m mod k = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ka\\<in>F. k * m mod ka = 0", "apply (rule_tac x=k in bexI, simp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NatMultiples_product_factor: \"\\<lbrakk> a \\<in> F; b \\<in> F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> F; b \\<in> F\\<rbrakk>\n    \\<Longrightarrow> a * b \\<in> NatMultiples F", "by (drule NatMultiples_Factor[of b], rule NatMultiples_Product)"], ["", "lemma NatMultiples_product_factor_multiple: \"\n  \\<lbrakk> a \\<in> F; b \\<in> NatMultiples F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> F; b \\<in> NatMultiples F\\<rbrakk>\n    \\<Longrightarrow> a * b \\<in> NatMultiples F", "by (rule NatMultiples_Product)"], ["", "lemma NatMultiples_product_multiple_factor: \"\n  \\<lbrakk> a \\<in> NatMultiples F; b \\<in> F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> NatMultiples F; b \\<in> F\\<rbrakk>\n    \\<Longrightarrow> a * b \\<in> NatMultiples F", "by (simp add: mult.commute[of a] NatMultiples_Product)"], ["", "lemma NatMultiples_product_multiple: \"\n  \\<lbrakk> a \\<in> NatMultiples F; b \\<in> NatMultiples F \\<rbrakk> \\<Longrightarrow> a * b \\<in> NatMultiples F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> NatMultiples F; b \\<in> NatMultiples F\\<rbrakk>\n    \\<Longrightarrow> a * b \\<in> NatMultiples F", "apply (induct a rule: NatMultiples.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k \\<in> F; b \\<in> NatMultiples F\\<rbrakk>\n       \\<Longrightarrow> k * b \\<in> NatMultiples F\n 2. \\<And>k m.\n       \\<lbrakk>k \\<in> F; m \\<in> NatMultiples F;\n        b \\<in> NatMultiples F \\<Longrightarrow> m * b \\<in> NatMultiples F;\n        b \\<in> NatMultiples F\\<rbrakk>\n       \\<Longrightarrow> k * m * b \\<in> NatMultiples F", "apply (simp add: NatMultiples_Product)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k m.\n       \\<lbrakk>k \\<in> F; m \\<in> NatMultiples F;\n        b \\<in> NatMultiples F \\<Longrightarrow> m * b \\<in> NatMultiples F;\n        b \\<in> NatMultiples F\\<rbrakk>\n       \\<Longrightarrow> k * m * b \\<in> NatMultiples F", "apply (simp add: mult.assoc[of _ _ b] NatMultiples_Product)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Subset of @{term i_set} containing only continuous intervals, i. e., without @{term iMOD} and @{term iMODb}.\\<close>"], ["", "inductive_set i_set_cont :: \"(nat set) set\"\nwhere\n    i_set_cont_FROM[intro]: \"[n\\<dots>] \\<in> i_set_cont\"\n  | i_set_cont_TILL[intro]: \"[\\<dots>n] \\<in> i_set_cont\"\n  | i_set_cont_IN[intro]:   \"[n\\<dots>,d] \\<in> i_set_cont\""], ["", "definition i_set0_cont :: \"(nat set) set\"\n  where \"i_set0_cont \\<equiv> insert {} i_set_cont\""], ["", "lemma i_set_cont_subset_i_set: \"i_set_cont \\<subseteq> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_cont \\<subseteq> i_set", "apply (unfold subset_eq, rule ballI, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set", "apply (rule_tac a=x in i_set_cont.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_cont\n 2. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont; x = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set\n 3. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont; x = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set\n 4. \\<And>x n d.\n       \\<lbrakk>x \\<in> i_set_cont; x = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_cont_subset_i_set0: \"i_set0_cont \\<subseteq> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set0_cont \\<subseteq> i_set0", "apply (unfold i_set0_cont_def i_set0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert {} i_set_cont \\<subseteq> insert {} i_set", "apply (rule insert_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_cont \\<subseteq> i_set", "apply (rule i_set_cont_subset_i_set)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Minimal definition of @{term i_set_cont}\\<close>"], ["", "inductive_set i_set_cont_min :: \"(nat set) set\"\nwhere\n  i_set_cont_FROM[intro]: \"[n\\<dots>] \\<in> i_set_cont_min\"\n| i_set_cont_IN[intro]:   \"[n\\<dots>,d] \\<in> i_set_cont_min\""], ["", "definition i_set0_cont_min :: \"(nat set) set\"\n  where \"i_set0_cont_min \\<equiv> insert {} i_set_cont_min\""], ["", "lemma i_set_cont_min_eq: \"i_set_cont = i_set_cont_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_cont = i_set_cont_min", "apply (rule set_eqI, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_cont_min\n 2. \\<And>x. x \\<in> i_set_cont_min \\<Longrightarrow> x \\<in> i_set_cont", "apply (rename_tac x, rule_tac a=x in i_set_cont.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_cont\n 2. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont; x = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont_min\n 3. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont; x = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont_min\n 4. \\<And>x n d.\n       \\<lbrakk>x \\<in> i_set_cont; x = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont_min\n 5. \\<And>x. x \\<in> i_set_cont_min \\<Longrightarrow> x \\<in> i_set_cont", "apply (fastforce simp: iIN_0_iTILL_conv[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> i_set_cont_min \\<Longrightarrow> x \\<in> i_set_cont", "apply (rename_tac x, rule_tac a=x in i_set_cont_min.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> i_set_cont_min \\<Longrightarrow> x \\<in> i_set_cont_min\n 2. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont_min; x = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont\n 3. \\<And>x n d.\n       \\<lbrakk>x \\<in> i_set_cont_min; x = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\\<open>inext\\<close> and \\<open>iprev\\<close> with continuous intervals\\<close>"], ["", "lemma i_set_cont_inext: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; finite I \\<Longrightarrow> n < Max I \\<rbrakk> \\<Longrightarrow> inext n I = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I;\n     finite I \\<Longrightarrow> n < Max I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n", "apply (simp add: i_set_cont_min_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont_min; n \\<in> I;\n     finite I \\<Longrightarrow> n < Max I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n", "apply (rule i_set_cont_min.cases, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>I \\<in> i_set_cont_min; n \\<in> I;\n        finite I \\<Longrightarrow> n < Max I; I = [na\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> inext n I = Suc n\n 2. \\<And>na d.\n       \\<lbrakk>I \\<in> i_set_cont_min; n \\<in> I;\n        finite I \\<Longrightarrow> n < Max I; I = [na\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> inext n I = Suc n", "apply (simp_all add: iT_finite iT_Max iT_inext_if iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_cont_iprev: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; iMin I < n \\<rbrakk> \\<Longrightarrow> iprev n I = n - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; iMin I < n\\<rbrakk>\n    \\<Longrightarrow> iprev n I = n - Suc 0", "apply (simp add: i_set_cont_min_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont_min; n \\<in> I; iMin I < n\\<rbrakk>\n    \\<Longrightarrow> iprev n I = n - Suc 0", "apply (rule i_set_cont_min.cases, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>I \\<in> i_set_cont_min; n \\<in> I; iMin I < n;\n        I = [na\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> iprev n I = n - Suc 0\n 2. \\<And>na d.\n       \\<lbrakk>I \\<in> i_set_cont_min; n \\<in> I; iMin I < n;\n        I = [na\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> iprev n I = n - Suc 0", "apply (simp_all add: iT_iprev_if iT_Min iT_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_cont_inext__less: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I \\<rbrakk> \\<Longrightarrow> inext n I = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n", "apply (case_tac \"finite I\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n     finite I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n\n 2. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n     infinite I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n", "apply (rule i_set_cont_inext, assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I; finite I;\n     finite I\\<rbrakk>\n    \\<Longrightarrow> n < Max I\n 2. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n     infinite I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n", "apply (rule order_less_le_trans[OF _ Max_ge], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n     infinite I\\<rbrakk>\n    \\<Longrightarrow> inext n I = Suc n", "apply (rule i_set_cont.cases, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n        infinite I; I = [na\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> inext n I = Suc n\n 2. \\<And>na.\n       \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n        infinite I; I = [\\<dots>na]\\<rbrakk>\n       \\<Longrightarrow> inext n I = Suc n\n 3. \\<And>na d.\n       \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n < n0; n0 \\<in> I;\n        infinite I; I = [na\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> inext n I = Suc n", "apply (simp_all add: iT_finite iT_inext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_cont_iprev__greater: \"\n  \\<lbrakk> I \\<in> i_set_cont; n \\<in> I; n0 < n; n0 \\<in> I \\<rbrakk> \\<Longrightarrow> iprev n I = n - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n0 < n; n0 \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iprev n I = n - Suc 0", "apply (rule i_set_cont_iprev, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_cont; n \\<in> I; n0 < n; n0 \\<in> I\\<rbrakk>\n    \\<Longrightarrow> iMin I < n", "apply (rule order_le_less_trans[OF iMin_le, of n0], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Sets of modulo intervals\\<close>"], ["", "inductive_set i_set_mult :: \"nat \\<Rightarrow> (nat set) set\"\n  for k :: nat\nwhere\n  i_set_mult_FROM[intro!]: \"[n\\<dots>] \\<in> i_set_mult k\"\n| i_set_mult_TILL[intro!]: \"[\\<dots>n] \\<in> i_set_mult k\"\n| i_set_mult_IN[intro!]:   \"[n\\<dots>,d] \\<in> i_set_mult k\"\n| i_set_mult_MOD[intro!]:  \"[r, mod m * k] \\<in> i_set_mult k\"\n| i_set_mult_MODb[intro!]: \"[r, mod m * k, c] \\<in> i_set_mult k\""], ["", "definition i_set0_mult :: \"nat \\<Rightarrow> (nat set) set\"\n  where \"i_set0_mult k \\<equiv> insert {} (i_set_mult k)\""], ["", "lemma\n  i_set0_mult_empty[intro!]: \"{} \\<in> i_set0_mult k\" and\n  i_set0_mult_FROM[intro!] : \"[n\\<dots>] \\<in> i_set0_mult k\" and\n  i_set0_mult_TILL[intro!] : \"[\\<dots>n] \\<in> i_set0_mult k\" and\n  i_set0_mult_IN[intro!]   : \"[n\\<dots>,d] \\<in> i_set0_mult k\" and\n  i_set0_mult_MOD[intro!]  : \"[r, mod m * k] \\<in> i_set0_mult k\" and\n  i_set0_mult_MODb[intro!] : \"[r, mod m * k, c] \\<in> i_set0_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} \\<in> i_set0_mult k &&&\n     [n\\<dots>] \\<in> i_set0_mult k &&& [\\<dots>n] \\<in> i_set0_mult k) &&&\n    [n\\<dots>,d] \\<in> i_set0_mult k &&&\n    [ r, mod m * k ] \\<in> i_set0_mult k &&&\n    [ r, mod m * k, c ] \\<in> i_set0_mult k", "by (simp_all add: i_set0_mult_def i_set_mult.intros)"], ["", "lemmas i_set0_mult_intros =\n  i_set0_mult_empty\n  i_set0_mult_FROM\n  i_set0_mult_TILL\n  i_set0_mult_IN\n  i_set0_mult_MOD\n  i_set0_mult_MODb"], ["", "lemma i_set_mult_subset_i_set0_mult: \"i_set_mult k \\<subseteq> i_set0_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_mult k \\<subseteq> i_set0_mult k", "by (unfold i_set0_mult_def, rule subset_insertI)"], ["", "lemma i_set_mult_subset_i_set: \"i_set_mult k \\<subseteq> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_mult k \\<subseteq> i_set", "apply (clarsimp simp: subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> i_set_mult k \\<Longrightarrow> t \\<in> i_set", "apply (rule_tac a=t in i_set_mult.cases[of _ k])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>t. t \\<in> i_set_mult k \\<Longrightarrow> t \\<in> i_set_mult k\n 2. \\<And>t n.\n       \\<lbrakk>t \\<in> i_set_mult k; t = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> t \\<in> i_set\n 3. \\<And>t n.\n       \\<lbrakk>t \\<in> i_set_mult k; t = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> t \\<in> i_set\n 4. \\<And>t n d.\n       \\<lbrakk>t \\<in> i_set_mult k; t = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> t \\<in> i_set\n 5. \\<And>t r m.\n       \\<lbrakk>t \\<in> i_set_mult k; t = [ r, mod m * k ]\\<rbrakk>\n       \\<Longrightarrow> t \\<in> i_set\n 6. \\<And>t r m c.\n       \\<lbrakk>t \\<in> i_set_mult k; t = [ r, mod m * k, c ]\\<rbrakk>\n       \\<Longrightarrow> t \\<in> i_set", "apply (simp_all add: i_set_intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_mult_subset_i_set0: \"i_set0_mult k \\<subseteq> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set0_mult k \\<subseteq> i_set0", "apply (simp add: i_set0_mult_def i_set0_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_mult k \\<subseteq> i_set0", "apply (rule order_trans[OF _ i_set_subset_i_set0, OF i_set_mult_subset_i_set])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_mult_0_eq_i_set_cont: \"i_set_mult 0 = i_set_cont\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_mult 0 = i_set_cont", "apply (rule set_eqI, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> i_set_mult 0 \\<Longrightarrow> x \\<in> i_set_cont\n 2. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_mult 0", "apply (rename_tac x, rule_tac a=x in i_set_mult.cases[of _ 0])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x. x \\<in> i_set_mult 0 \\<Longrightarrow> x \\<in> i_set_mult 0\n 2. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_mult 0; x = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont\n 3. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_mult 0; x = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont\n 4. \\<And>x n d.\n       \\<lbrakk>x \\<in> i_set_mult 0; x = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont\n 5. \\<And>x r m.\n       \\<lbrakk>x \\<in> i_set_mult 0; x = [ r, mod m * 0 ]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont\n 6. \\<And>x r m c.\n       \\<lbrakk>x \\<in> i_set_mult 0; x = [ r, mod m * 0, c ]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_cont\n 7. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_mult 0", "apply (simp_all add: i_set_cont.intros iMOD_0 iMODb_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_mult 0", "apply (rename_tac x, rule_tac a=x in i_set_cont.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> i_set_cont \\<Longrightarrow> x \\<in> i_set_cont\n 2. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont; x = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult 0\n 3. \\<And>x n.\n       \\<lbrakk>x \\<in> i_set_cont; x = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult 0\n 4. \\<And>x n d.\n       \\<lbrakk>x \\<in> i_set_cont; x = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult 0", "apply (simp_all add: i_set_mult.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_mult_0_eq_i_set0_cont: \"i_set0_mult 0 = i_set0_cont\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set0_mult 0 = i_set0_cont", "by (simp add: i_set0_mult_def i_set0_cont_def i_set_mult_0_eq_i_set_cont)"], ["", "lemma i_set_mult_1_eq_i_set: \"i_set_mult (Suc 0) = i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set_mult (Suc 0) = i_set", "apply (rule set_eqI, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> i_set_mult (Suc 0) \\<Longrightarrow> x \\<in> i_set\n 2. \\<And>x. x \\<in> i_set \\<Longrightarrow> x \\<in> i_set_mult (Suc 0)", "apply (rename_tac x, induct_tac x rule: i_set_mult.induct[of _ 1])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       x \\<in> i_set_mult (Suc 0) \\<Longrightarrow> x \\<in> i_set_mult 1\n 2. \\<And>x n.\n       x \\<in> i_set_mult (Suc 0) \\<Longrightarrow> [n\\<dots>] \\<in> i_set\n 3. \\<And>x n.\n       x \\<in> i_set_mult (Suc 0) \\<Longrightarrow> [\\<dots>n] \\<in> i_set\n 4. \\<And>x n d.\n       x \\<in> i_set_mult (Suc 0) \\<Longrightarrow> [n\\<dots>,d] \\<in> i_set\n 5. \\<And>x r m.\n       x \\<in> i_set_mult (Suc 0) \\<Longrightarrow>\n       [ r, mod m * 1 ] \\<in> i_set\n 6. \\<And>x r m c.\n       x \\<in> i_set_mult (Suc 0) \\<Longrightarrow>\n       [ r, mod m * 1, c ] \\<in> i_set\n 7. \\<And>x. x \\<in> i_set \\<Longrightarrow> x \\<in> i_set_mult (Suc 0)", "apply (simp_all add: i_set_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> i_set \\<Longrightarrow> x \\<in> i_set_mult (Suc 0)", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> i_set_ind \\<Longrightarrow> x \\<in> i_set_mult (Suc 0)", "apply (rename_tac x, induct_tac x rule: i_set_ind.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<in> i_set_ind \\<Longrightarrow> x \\<in> i_set_ind\n 2. \\<And>x n.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [n\\<dots>] \\<in> i_set_mult (Suc 0)\n 3. \\<And>x n.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [\\<dots>n] \\<in> i_set_mult (Suc 0)\n 4. \\<And>x n d.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [n\\<dots>,d] \\<in> i_set_mult (Suc 0)\n 5. \\<And>x r m.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m ] \\<in> i_set_mult (Suc 0)\n 6. \\<And>x r m c.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m, c ] \\<in> i_set_mult (Suc 0)", "apply (simp_all add: i_set_mult.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r m.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m ] \\<in> i_set_mult (Suc 0)\n 2. \\<And>x r m c.\n       x \\<in> i_set_ind \\<Longrightarrow>\n       [ r, mod m, c ] \\<in> i_set_mult (Suc 0)", "apply (rule_tac t=m and s=\"m * Suc 0\" in subst, simp, rule i_set_mult.intros)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_mult_1_eq_i_set0: \"i_set0_mult (Suc 0) = i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i_set0_mult (Suc 0) = i_set0", "by (simp add: i_set0_mult_def i_set0_def i_set_mult_1_eq_i_set)"], ["", "lemma i_set_mult_imp_not_empty: \"I \\<in> i_set_mult k \\<Longrightarrow> I \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set_mult k \\<Longrightarrow> I \\<noteq> {}", "by (induct I rule: i_set_mult.induct, simp_all add: iT_not_empty)"], ["", "lemma iMOD_in_i_set_mult_imp_divisor_mod_0: \"\n  \\<lbrakk> m \\<noteq> Suc 0; [r, mod m] \\<in> i_set_mult k \\<rbrakk> \\<Longrightarrow> m mod k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k\\<rbrakk>\n    \\<Longrightarrow> m mod k = 0", "apply (case_tac \"m = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> m mod k = 0", "apply (rule i_set_mult.cases[of \"[r, mod m]\" k], assumption)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 2. \\<And>n.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 3. \\<And>n d.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 4. \\<And>ra ma.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 5. \\<And>ra ma c.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k, c ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0", "apply (blast dest: iFROM_iMOD_neq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 2. \\<And>n d.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 3. \\<And>ra ma.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 4. \\<And>ra ma c.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k, c ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0", "apply (blast dest: iTILL_iMOD_neq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n d.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 2. \\<And>ra ma.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 3. \\<And>ra ma c.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k, c ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0", "apply (blast dest: iIN_iMOD_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ra ma.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0\n 2. \\<And>ra ma c.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k, c ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0", "apply (simp add: iMOD_eq_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ra ma c.\n       \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k;\n        m \\<noteq> 0; [ r, mod m ] = [ ra, mod ma * k, c ]\\<rbrakk>\n       \\<Longrightarrow> m mod k = 0", "apply (blast dest: iMOD_iMODb_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  divisor_mod_0_imp_iMOD_in_i_set_mult: \"m mod k = 0 \\<Longrightarrow> [r, mod m] \\<in> i_set_mult k\" and\n  divisor_mod_0_imp_iMODb_in_i_set_mult: \"m mod k = 0 \\<Longrightarrow> [r, mod m, c] \\<in> i_set_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m mod k = 0 \\<Longrightarrow> [ r, mod m ] \\<in> i_set_mult k) &&&\n    (m mod k = 0 \\<Longrightarrow> [ r, mod m, c ] \\<in> i_set_mult k)", "by (auto simp add: ac_simps)"], ["", "lemma iMOD_in_i_set_mult__divisor_mod_0_conv: \"\n  m \\<noteq> Suc 0 \\<Longrightarrow> ([r, mod m] \\<in> i_set_mult k) = (m mod k = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> Suc 0 \\<Longrightarrow>\n    ([ r, mod m ] \\<in> i_set_mult k) = (m mod k = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<noteq> Suc 0; [ r, mod m ] \\<in> i_set_mult k\\<rbrakk>\n    \\<Longrightarrow> m mod k = 0\n 2. \\<lbrakk>m \\<noteq> Suc 0; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<in> i_set_mult k", "apply (simp add: iMOD_in_i_set_mult_imp_divisor_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> Suc 0; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> [ r, mod m ] \\<in> i_set_mult k", "apply (simp add: divisor_mod_0_imp_iMOD_in_i_set_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_mult_neq1_subset_i_set: \"k \\<noteq> Suc 0 \\<Longrightarrow> i_set_mult k \\<subset> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> Suc 0 \\<Longrightarrow> i_set_mult k \\<subset> i_set", "apply (rule psubsetI, rule i_set_mult_subset_i_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> Suc 0 \\<Longrightarrow> i_set_mult k \\<noteq> i_set", "apply (simp add: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> Suc 0 \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (drule neq_iff[THEN iffD1], erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < Suc 0 \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (simp add: i_set_mult_0_eq_i_set_cont)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_cont) = (x \\<notin> i_set)\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (thin_tac \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x. (x \\<in> i_set_cont) = (x \\<notin> i_set)\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (rule_tac x=\"[0, mod 2]\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([ 0, mod 2 ] \\<in> i_set_cont) = ([ 0, mod 2 ] \\<notin> i_set)\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([ 0, mod 2 ] \\<in> i_set_cont) \\<noteq>\n    ([ 0, mod 2 ] \\<notin> i_set) \\<Longrightarrow>\n    False\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (simp add: i_set_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [ 0, mod 2 ] \\<in> i_set_cont \\<Longrightarrow> False\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (drule i_set_cont.cases[where P=False])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n. [ 0, mod 2 ] = [n\\<dots>] \\<Longrightarrow> False\n 2. \\<And>n. [ 0, mod 2 ] = [\\<dots>n] \\<Longrightarrow> False\n 3. \\<And>n d. [ 0, mod 2 ] = [n\\<dots>,d] \\<Longrightarrow> False\n 4. False \\<Longrightarrow> False\n 5. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (drule sym, simp add: iT_neq)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. False \\<Longrightarrow> False\n 2. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < k \\<Longrightarrow>\n    \\<exists>x. (x \\<in> i_set_mult k) = (x \\<notin> i_set)", "apply (rule_tac x=\"[0, mod Suc k]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < k \\<Longrightarrow>\n    ([ 0, mod Suc k ] \\<in> i_set_mult k) =\n    ([ 0, mod Suc k ] \\<notin> i_set)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < k;\n     ([ 0, mod Suc k ] \\<in> i_set_mult k) \\<noteq>\n     ([ 0, mod Suc k ] \\<notin> i_set)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: i_set_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < k; [ 0, mod Suc k ] \\<in> i_set_mult k\\<rbrakk>\n    \\<Longrightarrow> False", "apply (insert iMOD_in_i_set_mult_imp_divisor_mod_0[of \"Suc k\" 0 k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < k; [ 0, mod Suc k ] \\<in> i_set_mult k;\n     \\<lbrakk>Suc k \\<noteq> Suc 0;\n      [ 0, mod Suc k ] \\<in> i_set_mult k\\<rbrakk>\n     \\<Longrightarrow> Suc k mod k = 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: mod_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_0_imp_i_set_mult_subset: \"\n  a mod b = 0 \\<Longrightarrow> i_set_mult a \\<subseteq> i_set_mult b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod b = 0 \\<Longrightarrow> i_set_mult a \\<subseteq> i_set_mult b", "apply (auto simp add: ac_simps elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult b", "apply (rule_tac a=x and k=\"k * b\" in i_set_mult.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult (k * b)\n 2. \\<And>k x n.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b);\n        x = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult b\n 3. \\<And>k x n.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b);\n        x = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult b\n 4. \\<And>k x n d.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b);\n        x = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult b\n 5. \\<And>k x r m.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b);\n        x = [ r, mod m * (k * b) ]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult b\n 6. \\<And>k x r m c.\n       \\<lbrakk>a = k * b; x \\<in> i_set_mult (k * b);\n        x = [ r, mod m * (k * b), c ]\\<rbrakk>\n       \\<Longrightarrow> x \\<in> i_set_mult b", "apply (simp_all add: i_set_mult.intros mult.assoc[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_mult_subset_imp_mod_0: \"\n  \\<lbrakk> a \\<noteq> Suc 0; (i_set_mult a \\<subseteq> i_set_mult b) \\<rbrakk> \\<Longrightarrow> a mod b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> Suc 0;\n     i_set_mult a \\<subseteq> i_set_mult b\\<rbrakk>\n    \\<Longrightarrow> a mod b = 0", "apply (simp add: subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> Suc 0;\n     \\<forall>t.\n        t \\<in> i_set_mult a \\<longrightarrow> t \\<in> i_set_mult b\\<rbrakk>\n    \\<Longrightarrow> a mod b = 0", "apply (erule_tac x=\"[0, mod a]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> Suc 0;\n     [ 0, mod a ] \\<in> i_set_mult a \\<longrightarrow>\n     [ 0, mod a ] \\<in> i_set_mult b\\<rbrakk>\n    \\<Longrightarrow> a mod b = 0", "apply (simp add: divisor_mod_0_imp_iMOD_in_i_set_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> Suc 0; [ 0, mod a ] \\<in> i_set_mult b\\<rbrakk>\n    \\<Longrightarrow> a mod b = 0", "apply (simp add: iMOD_in_i_set_mult_imp_divisor_mod_0[of _ 0 b])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_mult_subset_conv: \"\n  a \\<noteq> Suc 0 \\<Longrightarrow> (i_set_mult a \\<subseteq> i_set_mult b) = (a mod b = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> Suc 0 \\<Longrightarrow>\n    (i_set_mult a \\<subseteq> i_set_mult b) = (a mod b = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> Suc 0;\n     i_set_mult a \\<subseteq> i_set_mult b\\<rbrakk>\n    \\<Longrightarrow> a mod b = 0\n 2. \\<lbrakk>a \\<noteq> Suc 0; a mod b = 0\\<rbrakk>\n    \\<Longrightarrow> i_set_mult a \\<subseteq> i_set_mult b", "apply (simp add: i_set_mult_subset_imp_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> Suc 0; a mod b = 0\\<rbrakk>\n    \\<Longrightarrow> i_set_mult a \\<subseteq> i_set_mult b", "apply (simp add: mod_0_imp_i_set_mult_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_mult_mod_0_div: \"\n  \\<lbrakk> I \\<in> i_set_mult k; k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<oslash> d \\<in> i_set_mult (k div d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_mult k; k mod d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set_mult (k div d)", "apply (case_tac \"d = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<in> i_set_mult k; k mod d = 0; d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set_mult (k div d)\n 2. \\<lbrakk>I \\<in> i_set_mult k; k mod d = 0; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set_mult (k div d)", "apply (simp add: iT_Div_0[OF i_set_mult_imp_not_empty] i_set_mult.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_mult k; k mod d = 0; d \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set_mult (k div d)", "apply (induct I rule: i_set_mult.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>k mod d = 0; d \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>] \\<oslash> d \\<in> i_set_mult (k div d)\n 2. \\<And>n.\n       \\<lbrakk>k mod d = 0; d \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [\\<dots>n] \\<oslash> d \\<in> i_set_mult (k div d)\n 3. \\<And>n da.\n       \\<lbrakk>k mod d = 0; d \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [n\\<dots>,da] \\<oslash> d\n                         \\<in> i_set_mult (k div d)\n 4. \\<And>r m.\n       \\<lbrakk>k mod d = 0; d \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m * k ] \\<oslash> d\n                         \\<in> i_set_mult (k div d)\n 5. \\<And>r m c.\n       \\<lbrakk>k mod d = 0; d \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m * k, c ] \\<oslash> d\n                         \\<in> i_set_mult (k div d)", "apply (simp_all add: iT_div i_set_mult.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r m.\n       \\<lbrakk>k mod d = 0; 0 < d\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m * k ] \\<oslash> d\n                         \\<in> i_set_mult (k div d)\n 2. \\<And>r m c.\n       \\<lbrakk>k mod d = 0; 0 < d\\<rbrakk>\n       \\<Longrightarrow> [ r, mod m * k, c ] \\<oslash> d\n                         \\<in> i_set_mult (k div d)", "apply (simp_all add: iMOD_div iMODb_div mod_0_imp_mod_mult_left_0 mod_0_imp_div_mult_left_eq i_set_mult.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Intervals from @{term \"i_set_mult k\"} remain in @{term i_set} after division by @{term d} a divisor of @{term k}.\\<close>"], ["", "corollary i_set_mult_mod_0_div_i_set: \"\n  \\<lbrakk> I \\<in> i_set_mult k; k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<oslash> d \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set_mult k; k mod d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set", "by (rule subsetD[OF i_set_mult_subset_i_set[of \"k div d\"]], rule i_set_mult_mod_0_div)"], ["", "corollary i_set_mult_div_self_i_set: \"\n  I \\<in> i_set_mult k \\<Longrightarrow> I \\<oslash> k \\<in> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set_mult k \\<Longrightarrow> I \\<oslash> k \\<in> i_set", "by (simp add: i_set_mult_mod_0_div_i_set)"], ["", "lemma i_set_mod_0_mult_in_i_set_mult: \"\n  \\<lbrakk> I \\<in> i_set; m mod k = 0 \\<rbrakk> \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k", "apply (case_tac \"m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<in> i_set; m mod k = 0; m = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k\n 2. \\<lbrakk>I \\<in> i_set; m mod k = 0; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k", "apply (simp add: iT_Mult_0 i_set_imp_not_empty i_set_mult.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set; m mod k = 0; m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k", "apply (clarsimp simp: mult.commute[of k] elim!: dvdE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>I \\<in> i_set; m = ka * k; 0 < ka; 0 < k\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k", "apply (simp add: i_set_i_set_ind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k", "apply (rule_tac a=I in i_set_ind.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set_ind\n 2. \\<And>ka n.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k;\n        I = [n\\<dots>]\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k\n 3. \\<And>ka n.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k;\n        I = [\\<dots>n]\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k\n 4. \\<And>ka n d.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k;\n        I = [n\\<dots>,d]\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k\n 5. \\<And>ka r ma.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k;\n        I = [ r, mod ma ]\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k\n 6. \\<And>ka r ma c.\n       \\<lbrakk>I \\<in> i_set_ind; m = ka * k; 0 < ka; 0 < k;\n        I = [ r, mod ma, c ]\\<rbrakk>\n       \\<Longrightarrow> I \\<otimes> ka * k \\<in> i_set_mult k", "apply (simp_all add: iT_mult mult.assoc[symmetric] i_set_mult.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set_self_mult_in_i_set_mult: \"\n  I \\<in> i_set \\<Longrightarrow> I \\<otimes> k \\<in> i_set_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set \\<Longrightarrow> I \\<otimes> k \\<in> i_set_mult k", "by (rule i_set_mod_0_mult_in_i_set_mult[OF _ mod_self])"], ["", "lemma i_set_mult_mod_gr0_div_not_in_i_set:\"\n  \\<lbrakk> 0 < k; 0 < d; 0 < k mod d \\<rbrakk> \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k. I \\<oslash> d \\<notin> i_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k.\n                         I \\<oslash> d \\<notin> i_set", "apply (case_tac \"d = Suc 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k.\n                         I \\<oslash> d \\<notin> i_set", "apply (frule iMOD_div_mod_gr0_not_ex[of d \"Suc d * k\" 0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> d < Suc d * k\n 2. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> 0 < Suc d * k mod d\n 3. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k.\n                         I \\<oslash> d \\<notin> i_set", "apply (rule Suc_le_lessD, rule gr0_imp_self_le_mult1, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> 0 < Suc d * k mod d\n 2. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k.\n                         I \\<oslash> d \\<notin> i_set", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set_mult k.\n                         I \\<oslash> d \\<notin> i_set", "apply (rule_tac x=\"[0, mod Suc d * k]\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> [ 0, mod Suc d * k ] \\<oslash> d \\<notin> i_set\n 2. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> [ 0, mod Suc d * k ] \\<in> i_set_mult k", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<forall>r' m'.\n        [ r', mod m' ] \\<noteq> [ 0, mod k + d * k ] \\<oslash> d;\n     [ 0, mod k + d * k ] \\<oslash> d \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> [ 0, mod Suc d * k ] \\<in> i_set_mult k", "apply (frule i_set_infinite_as_iMOD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<forall>r' m'.\n        [ r', mod m' ] \\<noteq> [ 0, mod k + d * k ] \\<oslash> d;\n     [ 0, mod k + d * k ] \\<oslash> d \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> infinite ([ 0, mod k + d * k ] \\<oslash> d)\n 2. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<forall>r' m'.\n        [ r', mod m' ] \\<noteq> [ 0, mod k + d * k ] \\<oslash> d;\n     [ 0, mod k + d * k ] \\<oslash> d \\<in> i_set;\n     \\<exists>r m. [ 0, mod k + d * k ] \\<oslash> d = [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> [ 0, mod Suc d * k ] \\<in> i_set_mult k", "apply (simp add: iT_Div_finite_iff iMOD_infinite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<forall>r' m'.\n        [ r', mod m' ] \\<noteq> [ 0, mod k + d * k ] \\<oslash> d;\n     [ 0, mod k + d * k ] \\<oslash> d \\<in> i_set;\n     \\<exists>r m. [ 0, mod k + d * k ] \\<oslash> d = [ r, mod m ]\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> [ 0, mod Suc d * k ] \\<in> i_set_mult k", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d; d \\<noteq> Suc 0;\n     \\<nexists>r' m'.\n        [ r', mod m' ] = [ 0, mod Suc d * k ] \\<oslash> d\\<rbrakk>\n    \\<Longrightarrow> [ 0, mod Suc d * k ] \\<in> i_set_mult k", "apply (simp add: i_set_mult.intros del: mult_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_mult_mod_0_div: \"\n  \\<lbrakk> I \\<in> i_set0_mult k; k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<oslash> d \\<in> i_set0_mult (k div d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set0_mult k; k mod d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set0_mult (k div d)", "apply (simp add: i_set0_mult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I = {} \\<or> I \\<in> i_set_mult k; k mod d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d = {} \\<or>\n                      I \\<oslash> d \\<in> i_set_mult (k div d)", "apply (elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k mod d = 0; I = {}\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d = {} \\<or>\n                      I \\<oslash> d \\<in> i_set_mult (k div d)\n 2. \\<lbrakk>k mod d = 0; I \\<in> i_set_mult k\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d = {} \\<or>\n                      I \\<oslash> d \\<in> i_set_mult (k div d)", "apply (simp add: iT_Div_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k mod d = 0; I \\<in> i_set_mult k\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d = {} \\<or>\n                      I \\<oslash> d \\<in> i_set_mult (k div d)", "apply (simp add: i_set_mult_mod_0_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary i_set0_mult_mod_0_div_i_set0: \"\n  \\<lbrakk> I \\<in> i_set0_mult k; k mod d = 0 \\<rbrakk> \\<Longrightarrow> I \\<oslash> d \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set0_mult k; k mod d = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<oslash> d \\<in> i_set0", "by (rule subsetD[OF i_set0_mult_subset_i_set0[of \"k div d\"]], rule i_set0_mult_mod_0_div)"], ["", "corollary i_set0_mult_div_self_i_set0: \"\n  I \\<in> i_set0_mult k \\<Longrightarrow> I \\<oslash> k \\<in> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0_mult k \\<Longrightarrow> I \\<oslash> k \\<in> i_set0", "by (simp add: i_set0_mult_mod_0_div_i_set0)"], ["", "lemma i_set0_mod_0_mult_in_i_set0_mult: \"\n  \\<lbrakk> I \\<in> i_set0; m mod k = 0 \\<rbrakk> \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<in> i_set0; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k", "apply (simp add: i_set0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I = {} \\<or> I \\<in> i_set; m mod k = 0\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m mod k = 0; I = {}\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k\n 2. \\<lbrakk>m mod k = 0; I \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k", "apply (simp add: iT_Mult_empty i_set0_mult_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m mod k = 0; I \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set0_mult k", "apply (rule subsetD[OF i_set_mult_subset_i_set0_mult])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m mod k = 0; I \\<in> i_set\\<rbrakk>\n    \\<Longrightarrow> I \\<otimes> m \\<in> i_set_mult k", "apply (simp add: i_set_mod_0_mult_in_i_set_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma i_set0_self_mult_in_i_set0_mult: \"\n  I \\<in> i_set0 \\<Longrightarrow> I \\<otimes> k \\<in> i_set0_mult k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> i_set0 \\<Longrightarrow> I \\<otimes> k \\<in> i_set0_mult k", "by (simp add: i_set0_mod_0_mult_in_i_set0_mult)"], ["", "lemma i_set0_mult_mod_gr0_div_not_in_i_set0:\"\n  \\<lbrakk> 0 < k; 0 < d; 0 < k mod d \\<rbrakk> \\<Longrightarrow> \\<exists>I\\<in>i_set0_mult k. I \\<oslash> d \\<notin> i_set0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set0_mult k.\n                         I \\<oslash> d \\<notin> i_set0", "apply (frule i_set_mult_mod_gr0_div_not_in_i_set[of k d], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; 0 < d; 0 < k mod d;\n     \\<exists>I\\<in>i_set_mult k. I \\<oslash> d \\<notin> i_set\\<rbrakk>\n    \\<Longrightarrow> \\<exists>I\\<in>i_set0_mult k.\n                         I \\<oslash> d \\<notin> i_set0", "apply (erule bexE, rename_tac I, rule_tac x=I in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I.\n       \\<lbrakk>0 < k; 0 < d; 0 < k mod d; I \\<in> i_set_mult k;\n        I \\<oslash> d \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> I \\<oslash> d \\<notin> i_set0\n 2. \\<And>I.\n       \\<lbrakk>0 < k; 0 < d; 0 < k mod d; I \\<in> i_set_mult k;\n        I \\<oslash> d \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set0_mult k", "apply (simp add: i_set0_def iT_Div_not_empty i_set_mult_imp_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I.\n       \\<lbrakk>0 < k; 0 < d; 0 < k mod d; I \\<in> i_set_mult k;\n        I \\<oslash> d \\<notin> i_set\\<rbrakk>\n       \\<Longrightarrow> I \\<in> i_set0_mult k", "apply (simp add: subsetD[OF i_set_mult_subset_i_set0_mult])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}