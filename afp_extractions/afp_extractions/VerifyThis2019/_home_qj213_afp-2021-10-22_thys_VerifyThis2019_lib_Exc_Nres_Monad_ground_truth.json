{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019/lib/Exc_Nres_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019", "problem_names": ["lemma EASSUME_simps[simp]: \n  \"EASSUME True = ERETURN ()\"\n  \"EASSUME False = SUCCEED\"", "lemma EASSERT_simps[simp]: \n  \"EASSERT True = ERETURN ()\"\n  \"EASSERT False = FAIL\"", "lemma CHECK_simps[simp]: \n  \"CHECK True e = ERETURN ()\" \n  \"CHECK False e = THROW e\"", "lemma pw_ESPEC[simp, refine_pw_simps]:\n  \"nofail (ESPEC \\<Phi> \\<Psi>)\"\n  \"inres (ESPEC \\<Phi> \\<Psi>) (Inl e) \\<longleftrightarrow> \\<Phi> e\"\n  \"inres (ESPEC \\<Phi> \\<Psi>) (Inr x) \\<longleftrightarrow> \\<Psi> x\"", "lemma pw_ERETURN[simp, refine_pw_simps]:\n  \"nofail (ERETURN x)\"\n  \"\\<not>inres (ERETURN x) (Inl e)\"\n  \"inres (ERETURN x) (Inr y) \\<longleftrightarrow> x=y\"", "lemma pw_ebind[refine_pw_simps]:\n  \"nofail (ebind m f) \\<longleftrightarrow> nofail m \\<and> (\\<forall>x. inres m (Inr x) \\<longrightarrow> nofail (f x))\"\n  \"inres (ebind m f) (Inl e) \\<longleftrightarrow> inres m (Inl e) \\<or> (\\<exists>x. inres m (Inr x) \\<and> inres (f x) (Inl e))\"\n  \"inres (ebind m f) (Inr x) \\<longleftrightarrow> nofail m \\<longrightarrow> (\\<exists>y. inres m (Inr y) \\<and> inres (f y) (Inr x))\"", "lemma pw_THROW[simp,refine_pw_simps]:\n  \"nofail (THROW e)\"\n  \"inres (THROW e) (Inl f) \\<longleftrightarrow> f=e\"\n  \"\\<not>inres (THROW e) (Inr x)\"", "lemma pw_CHECK[simp, refine_pw_simps]:\n  \"nofail (CHECK \\<Phi> e)\"\n  \"inres (CHECK \\<Phi> e) (Inl f) \\<longleftrightarrow> \\<not>\\<Phi> \\<and> f=e\"\n  \"inres (CHECK \\<Phi> e) (Inr u) \\<longleftrightarrow> \\<Phi>\"", "lemma pw_EASSUME[simp, refine_pw_simps]:\n  \"nofail (EASSUME \\<Phi>)\"\n  \"\\<not>inres (EASSUME \\<Phi>) (Inl e)\"\n  \"inres (EASSUME \\<Phi>) (Inr u) \\<longleftrightarrow> \\<Phi>\"", "lemma pw_EASSERT[simp, refine_pw_simps]:\n  \"nofail (EASSERT \\<Phi>) \\<longleftrightarrow> \\<Phi>\"\n  \"inres (EASSERT \\<Phi>) (Inr u)\"\n  \"inres (EASSERT \\<Phi>) (Inl e) \\<longleftrightarrow> \\<not>\\<Phi>\"", "lemma pw_CATCH[refine_pw_simps]:\n  \"nofail (CATCH m h) \\<longleftrightarrow> (nofail m \\<and> (\\<forall>x. inres m (Inl x) \\<longrightarrow> nofail (h x)))\"\n  \"inres (CATCH m h) (Inl e) \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<exists>e'. inres m (Inl e') \\<and> inres (h e') (Inl e)))\"\n  \"inres (CATCH m h) (Inr x) \\<longleftrightarrow> inres m (Inr x) \\<or> (\\<exists>e. inres m (Inl e) \\<and> inres (h e) (Inr x))\"", "lemma pw_ele_iff: \"m \\<le> n \\<longleftrightarrow> (nofail n \\<longrightarrow> \n    nofail m \n  \\<and> (\\<forall>e. inres m (Inl e) \\<longrightarrow> inres n (Inl e))\n  \\<and> (\\<forall>x. inres m (Inr x) \\<longrightarrow> inres n (Inr x))\n  )\"", "lemma pw_eeq_iff: \"m = n \\<longleftrightarrow> \n    (nofail m \\<longleftrightarrow> nofail n) \n  \\<and> (\\<forall>e. inres m (Inl e) \\<longleftrightarrow> inres n (Inl e))\n  \\<and> (\\<forall>x. inres m (Inr x) \\<longleftrightarrow> inres n (Inr x))\"", "lemma enres_monad_laws[simp]:\n  \"ebind (ERETURN x) f = f x\"\n  \"ebind m (ERETURN) = m\"\n  \"ebind (ebind m f) g = ebind m (\\<lambda>x. ebind (f x) g)\"", "lemma enres_additional_laws[simp]:\n  \"ebind (THROW e) f = THROW e\"\n  \n  \"CATCH (THROW e) h = h e\"\n  \"CATCH (ERETURN x) h = ERETURN x\"\n  \"CATCH m THROW = m\"", "lemmas ESPEC_trans = order_trans[where z=\"ESPEC Error_Postcond Normal_Postcond\" for Error_Postcond Normal_Postcond, zero_var_indexes]", "lemma ESPEC_cons: \n  assumes \"m \\<le> ESPEC E Q\"\n  assumes \"\\<And>e. E e \\<Longrightarrow> E' e\"\n  assumes \"\\<And>x. Q x \\<Longrightarrow> Q' x\"\n  shows \"m \\<le> ESPEC E' Q'\"", "lemma ebind_rule_iff: \"doE { x\\<leftarrow>m; f x } \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> m \\<le> ESPEC \\<Phi> (\\<lambda>x. f x \\<le> ESPEC \\<Phi> \\<Psi>)\"", "lemmas ebind_rule[refine_vcg] = ebind_rule_iff[THEN iffD2]", "lemma ERETURN_rule_iff[simp]: \"ERETURN x \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> \\<Psi> x\"", "lemmas ERETURN_rule[refine_vcg] = ERETURN_rule_iff[THEN iffD2]", "lemma ESPEC_rule_iff: \"ESPEC \\<Phi> \\<Psi> \\<le> ESPEC \\<Phi>' \\<Psi>' \\<longleftrightarrow> (\\<forall>e. \\<Phi> e \\<longrightarrow> \\<Phi>' e) \\<and> (\\<forall>x. \\<Psi> x \\<longrightarrow> \\<Psi>' x)\"", "lemmas ESPEC_rule[refine_vcg] = ESPEC_rule_iff[THEN iffD2]", "lemma THROW_rule_iff: \"THROW e \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> \\<Phi> e\"", "lemmas THROW_rule[refine_vcg] = THROW_rule_iff[THEN iffD2]", "lemma CATCH_rule_iff: \"CATCH m h \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> m \\<le> ESPEC (\\<lambda>e. h e \\<le> ESPEC \\<Phi> \\<Psi>) \\<Psi>\"", "lemmas CATCH_rule[refine_vcg] = CATCH_rule_iff[THEN iffD2]", "lemma CHECK_rule_iff: \"CHECK c e \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> (c \\<longrightarrow> \\<Psi> ()) \\<and> (\\<not>c \\<longrightarrow> \\<Phi> e)\"", "lemma CHECK_rule[refine_vcg]:\n  assumes \"c \\<Longrightarrow> \\<Psi> ()\"\n  assumes \"\\<not>c \\<Longrightarrow> \\<Phi> e\"\n  shows \"CHECK c e \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma EASSUME_rule[refine_vcg]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> EASSUME \\<Phi> \\<le> ESPEC E \\<Psi>\"", "lemma EASSERT_rule[refine_vcg]: \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> EASSERT \\<Phi> \\<le> ESPEC E \\<Psi>\"", "lemma eprod_rule[refine_vcg]: \n  \"\\<lbrakk>\\<And>a b. p=(a,b) \\<Longrightarrow> S a b \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk> \\<Longrightarrow> (case p of (a,b) \\<Rightarrow> S a b) \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma eprod2_rule[refine_vcg]:\n  assumes \"\\<And>a b c d. \\<lbrakk>ab=(a,b); cd=(c,d)\\<rbrakk> \\<Longrightarrow> f a b c d \\<le> ESPEC \\<Phi> \\<Psi>\"\n  shows \"(\\<lambda>(a,b) (c,d). f a b c d) ab cd \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma eif_rule[refine_vcg]: \n  \"\\<lbrakk> b \\<Longrightarrow> S1 \\<le> ESPEC \\<Phi> \\<Psi>; \\<not>b \\<Longrightarrow> S2 \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk> \n  \\<Longrightarrow> (if b then S1 else S2) \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma eoption_rule[refine_vcg]: \n  \"\\<lbrakk> v=None \\<Longrightarrow> S1 \\<le> ESPEC \\<Phi> \\<Psi>; \\<And>x. v=Some x \\<Longrightarrow> f2 x \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk> \n  \\<Longrightarrow> case_option S1 f2 v \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma eLet_rule[refine_vcg]: \"f v \\<le> ESPEC \\<Phi> \\<Psi> \\<Longrightarrow> (let x=v in f x) \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma eLet_rule':\n  assumes \"\\<And>x. x=v \\<Longrightarrow> f x \\<le> ESPEC \\<Phi> \\<Psi>\"\n  shows \"Let v (\\<lambda>x. f x) \\<le> ESPEC \\<Phi> \\<Psi>\"", "lemma EWHILEIT_rule[refine_vcg]:\n  assumes WF: \"wf R\"\n    and I0: \"I s\\<^sub>0\"\n    and IS: \"\\<And>s. \\<lbrakk>I s; b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> f s \\<le> ESPEC E (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\"\n    and IMP: \"\\<And>s. \\<lbrakk>I s; \\<not> b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"EWHILEIT I b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>\"", "lemma EWHILET_rule:\n  assumes WF: \"wf R\"\n    and I0: \"I s\\<^sub>0\"\n    and IS: \"\\<And>s. \\<lbrakk>I s; b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> f s \\<le> ESPEC E (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\"\n    and IMP: \"\\<And>s. \\<lbrakk>I s; \\<not> b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"EWHILET b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>\"", "lemma EWHILEIT_weaken:\n  assumes \"\\<And>x. I x \\<Longrightarrow> I' x\"\n  shows \"EWHILEIT I' b f x \\<le> EWHILEIT I b f x\"", "lemma EWHILEIT_expinv_rule:\n  assumes WF: \"wf R\"\n    and I0: \"I s\\<^sub>0\"\n    and IS: \"\\<And>s. \\<lbrakk>I s; b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> f s \\<le> ESPEC E (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\"\n    and IMP: \"\\<And>s. \\<lbrakk>I s; \\<not> b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n    and INVIMP: \"\\<And>s. I s \\<Longrightarrow> I' s\"\n  shows \"EWHILEIT I' b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>\"", "lemma enfoldli_simps[simp]:\n  \"enfoldli [] c f s = ERETURN s\"\n  \"enfoldli (x#ls) c f s = \n    (if c s then doE { s\\<leftarrow>f x s; enfoldli ls c f s} else ERETURN s)\"", "lemma enfoldli_rule:\n  assumes I0: \"I [] l0 \\<sigma>0\"\n  assumes IS: \"\\<And>x l1 l2 \\<sigma>. \\<lbrakk> l0=l1@x#l2; I l1 (x#l2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> ESPEC E (I (l1@[x]) l2)\"\n  assumes FNC: \"\\<And>l1 l2 \\<sigma>. \\<lbrakk> l0=l1@l2; I l1 l2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I l0 [] \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"enfoldli l0 c f \\<sigma>0 \\<le> ESPEC E P\"", "lemma sum_rel_conv:\n  \"(Inl l, s') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>l'. s'=Inl l' \\<and> (l,l')\\<in>L)\"\n  \"(Inr r, s') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>r'. s'=Inr r' \\<and> (r,r')\\<in>R)\"\n  \"(s, Inl l') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>l. s=Inl l \\<and> (l,l')\\<in>L)\"\n  \"(s, Inr r') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>r. s=Inr r \\<and> (r,r')\\<in>R)\"\n  \"(\\<forall>l. s \\<noteq> Inl l) \\<longleftrightarrow> (\\<exists>r. s=Inr r)\"\n  \"(\\<forall>r. s \\<noteq> Inr r) \\<longleftrightarrow> (\\<exists>l. s=Inl l)\"", "lemma RELATES_pat_erefine[refine_dref_pattern]: \"\\<lbrakk>RELATES R; mi \\<le>\\<Down>\\<^sub>E E R m \\<rbrakk> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"", "lemma pw_econc_iff[refine_pw_simps]:\n  \"inres (\\<Down>\\<^sub>E E R m) (Inl ei) \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<exists>e. inres m (Inl e) \\<and> (ei,e)\\<in>E))\"\n  \"inres (\\<Down>\\<^sub>E E R m) (Inr xi) \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<exists>x. inres m (Inr x) \\<and> (xi,x)\\<in>R))\"\n  \"nofail (\\<Down>\\<^sub>E E R m) \\<longleftrightarrow> nofail m\"", "lemma econc_fun_id[simp]: \"\\<Down>\\<^sub>E Id Id = (\\<lambda>x. x)\"", "lemma econc_fun_ESPEC: \"\\<Down>\\<^sub>E E R (ESPEC \\<Phi> \\<Psi>) = ESPEC (\\<lambda>ei. \\<exists>e. (ei,e)\\<in>E \\<and> \\<Phi> e) (\\<lambda>ri. \\<exists>r. (ri,r)\\<in>R \\<and> \\<Psi> r)\"", "lemma econc_fun_ERETURN: \"\\<Down>\\<^sub>E E R (ERETURN x) = ESPEC (\\<lambda>_. False) (\\<lambda>xi. (xi,x)\\<in>R)\"", "lemma econc_fun_univ_id[simp]: \"\\<Down>\\<^sub>E UNIV Id (ESPEC \\<Phi> \\<Psi>) = ESPEC (\\<lambda>_. Ex \\<Phi>) \\<Psi>\"", "lemma erefine_same_sup_Id[simp]: \"\\<lbrakk> Id\\<subseteq>E; Id\\<subseteq>R \\<rbrakk> \\<Longrightarrow> m \\<le>\\<Down>\\<^sub>E E R m\"", "lemma econc_mono3: \"m\\<le>m' \\<Longrightarrow> \\<Down>\\<^sub>E E R m \\<le> \\<Down>\\<^sub>E E R m'\"", "lemma econc_x_trans[trans]: \n  \"x \\<le> \\<Down>\\<^sub>E E R y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> \\<Down>\\<^sub>E E R z\"", "lemma econc_econc_trans[trans]: \n  \"x \\<le>\\<Down>\\<^sub>E E1 R1 y \\<Longrightarrow> y \\<le> \\<Down>\\<^sub>E E2 R2 z \\<Longrightarrow> x \\<le> \\<Down>\\<^sub>E (E1 O E2) (R1 O R2) z\"", "lemma ERETURN_refine[refine]: \n  assumes \"(xi,x)\\<in>R\"\n  shows \"ERETURN xi \\<le> \\<Down>\\<^sub>EE R (ERETURN x)\"", "lemma EASSERT_bind_refine_right:\n  assumes \"\\<Phi> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"mi \\<le>\\<Down>\\<^sub>E E R (doE {EASSERT \\<Phi>; m})\"", "lemma EASSERT_bind_refine_left:\n  assumes \"\\<Phi>\"\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"(doE {EASSERT \\<Phi>; mi}) \\<le>\\<Down>\\<^sub>E E R m\"", "lemma EASSUME_bind_refine_right:\n  assumes \"\\<Phi>\"\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"mi \\<le>\\<Down>\\<^sub>E E R (doE {EASSUME \\<Phi>; m})\"", "lemma EASSUME_bind_refine_left:\n  assumes \"\\<Phi> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"(doE {EASSUME \\<Phi>; mi}) \\<le>\\<Down>\\<^sub>E E R m\"", "lemma ebind_refine:\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R' m\"\n  assumes \"\\<And>xi x. (xi,x)\\<in>R' \\<Longrightarrow> fi xi \\<le>\\<Down>\\<^sub>E E R (f x)\"\n  shows \"doE { xi \\<leftarrow> mi; fi xi } \\<le> \\<Down>\\<^sub>E E R (doE { x \\<leftarrow> m; f x })\"", "lemmas [refine] = \n  ebind_refine\n  EASSERT_bind_refine_left EASSUME_bind_refine_right\n  EASSUME_bind_refine_left EASSERT_bind_refine_right", "lemma ebind_refine':\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R' m\"\n  assumes \"\\<And>xi x. \\<lbrakk>(xi,x)\\<in>R'; inres mi (Inr xi); inres m (Inr x); nofail mi; nofail m\\<rbrakk> \\<Longrightarrow> fi xi \\<le>\\<Down>\\<^sub>E E R (f x)\"\n  shows \"doE { xi \\<leftarrow> mi; fi xi } \\<le> \\<Down>\\<^sub>E E R (doE { x \\<leftarrow> m; f x })\"", "lemma THROW_refine[refine]: \"(ei,e)\\<in>E \\<Longrightarrow> THROW ei \\<le>\\<Down>\\<^sub>E E R (THROW e)\"", "lemma CATCH_refine':\n  assumes \"mi \\<le> \\<Down>\\<^sub>E E' R m\"\n  assumes \"\\<And>ei e. \\<lbrakk> (ei,e)\\<in>E'; inres mi (Inl ei); inres m (Inl e); nofail mi; nofail m \\<rbrakk> \\<Longrightarrow> hi ei \\<le>\\<Down>\\<^sub>E E R (h e)\"\n  shows \"CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)\"", "lemma CATCH_refine[refine]:\n  assumes \"mi \\<le> \\<Down>\\<^sub>E E' R m\"\n  assumes \"\\<And>ei e. \\<lbrakk> (ei,e)\\<in>E' \\<rbrakk> \\<Longrightarrow> hi ei \\<le>\\<Down>\\<^sub>E E R (h e)\"\n  shows \"CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)\"", "lemma CHECK_refine[refine]: \n  assumes \"\\<Phi>i \\<longleftrightarrow> \\<Phi>\"\n  assumes \"\\<not>\\<Phi> \\<Longrightarrow> (msgi,msg)\\<in>E\"\n  shows \"CHECK \\<Phi>i msgi \\<le>\\<Down>\\<^sub>E E Id (CHECK \\<Phi> msg)\"", "lemma CHECK_bind_refine[refine]: \n  assumes \"\\<Phi>i \\<longleftrightarrow> \\<Phi>\"\n  assumes \"\\<not>\\<Phi> \\<Longrightarrow> (msgi,msg)\\<in>E\"\n  assumes \"\\<Phi> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"doE {CHECK \\<Phi>i msgi;mi} \\<le>\\<Down>\\<^sub>E E R (doE {CHECK \\<Phi> msg; m})\"", "lemma Let_unfold_refine[refine]:\n  assumes \"f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>\\<^sub>E E R (Let x' f')\"", "lemma Let_refine:\n  assumes \"(m,m')\\<in>R'\"\n  assumes \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"Let m (\\<lambda>x. f x) \\<le>\\<Down>\\<^sub>E E R (Let m' (\\<lambda>x'. f' x'))\"", "lemma eif_refine[refine]:\n  assumes \"(b,b')\\<in>bool_rel\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> S1 \\<le> \\<Down>\\<^sub>E E R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> S2 \\<le> \\<Down>\\<^sub>E E R S2'\"\n  shows \"(if b then S1 else S2) \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')\"", "lemma enfoldli_refine[refine]:\n  assumes \"(li, l) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and \"(si, s) \\<in> R\"\n    and CR: \"(ci, c) \\<in> R \\<rightarrow> bool_rel\"\n    and FR: \"\\<And>xi x si s. \\<lbrakk> (xi,x)\\<in>S; (si,s)\\<in>R; c s \\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>\\<^sub>E E R (f x s)\"\n  shows \"enfoldli li ci fi si \\<le> \\<Down>\\<^sub>E E R (enfoldli l c f s)\"", "lemma EWHILET_refine[refine]:\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"EWHILET b f x \\<le>\\<Down>\\<^sub>E E R (EWHILET b' f' x')\"", "lemma EWHILEIT_refine[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes I_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> I x\"  \n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"EWHILEIT I b f x \\<le>\\<Down>\\<^sub>E E R (EWHILEIT I' b' f' x')\"", "lemma remove_eLet_refine:\n  assumes \"M \\<le> \\<Down>\\<^sub>E E R (f x)\"\n  shows \"M \\<le> \\<Down>\\<^sub>E E R (Let x f)\"", "lemma intro_eLet_refine:\n  assumes \"f x \\<le> \\<Down>\\<^sub>E E R M'\"\n  shows \"Let x f \\<le> \\<Down>\\<^sub>E E R M'\"", "lemma ebind2let_refine[refine2]:\n  assumes \"ERETURN x \\<le> \\<Down>\\<^sub>E E R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>\\<^sub>E E R (ebind M' (\\<lambda>x'. f' x'))\"", "lemma ebind_Let_refine2[refine2]: \"\\<lbrakk> \n    m' \\<le>\\<Down>\\<^sub>E E R' (ERETURN x);\n    \\<And>x'. \\<lbrakk>inres m' (Inr x'); (x',x)\\<in>R'\\<rbrakk> \\<Longrightarrow> f' x' \\<le> \\<Down>\\<^sub>E E R (f x) \n  \\<rbrakk> \\<Longrightarrow> ebind m' (\\<lambda>x'. f' x') \\<le> \\<Down>\\<^sub>E E R (Let x (\\<lambda>x. f x))\"", "lemma ebind2letRETURN_refine[refine2]:\n  assumes \"ERETURN x \\<le> \\<Down>\\<^sub>E E R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> ERETURN (f x) \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"ERETURN (Let x f) \\<le> \\<Down>\\<^sub>E E R (ebind M' (\\<lambda>x'. f' x'))\"", "lemma ERETURN_as_SPEC_refine[refine2]:\n  assumes \"RELATES R\"\n  assumes \"M \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>c. (c,a)\\<in>R)\"\n  shows \"M \\<le> \\<Down>\\<^sub>E E R (ERETURN a)\"", "lemma if_ERETURN_refine[refine2]:\n  assumes \"b \\<longleftrightarrow> b'\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> ERETURN S1 \\<le> \\<Down>\\<^sub>E E R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> ERETURN S2 \\<le> \\<Down>\\<^sub>E E R S2'\"\n  shows \"ERETURN (if b then S1 else S2) \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')\"", "lemma enres_lift_rule[refine_vcg]: \"m\\<le>SPEC \\<Phi> \\<Longrightarrow> enres_lift m \\<le> ESPEC E \\<Phi>\"", "lemma [enres_breakdown]:\n  \"ERETURN x = enres_lift (RETURN x)\"  \n  \"EASSERT \\<Phi> = enres_lift (ASSERT \\<Phi>)\"\n  \"doE { x \\<leftarrow> enres_lift m; ef x } = do { x \\<leftarrow> m; ef x }\"", "lemma [enres_breakdown]: \n  \"do { x \\<leftarrow> m; enres_lift (f x) } = enres_lift (do { x \\<leftarrow> m; f x })\"\n  \"do { let x = v; enres_lift (f x) } = enres_lift (do { let x=v; f x })\"", "lemma [enres_breakdown]:\n  \"CATCH (enres_lift m) h = enres_lift m\"", "lemma enres_lift_fail[simp]:  \"enres_lift FAIL = FAIL\"", "lemma [enres_breakdown]: \"EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s = enres_lift (WHILEIT I c f s)\"\n  (is \"?lhs = ?rhs\")", "lemma [enres_breakdown]: \"EWHILET c (\\<lambda>s. enres_lift (f s)) s = enres_lift (WHILET c f s)\"", "lemma [enres_breakdown]: \"enfoldli l c (\\<lambda>x s. enres_lift (f x s)) s = enres_lift (nfoldli l c f s)\"", "lemma [enres_breakdown]: \n  \"(\\<lambda>(a,b). enres_lift (f a b)) = (\\<lambda>x. enres_lift (case x of (a,b) \\<Rightarrow> f a b))\"", "lemmas [enres_breakdown] = nres_monad_laws nres_bind_let_law", "lemma [enres_breakdown]:\n  \"doE { CHECK \\<Phi> e; m } = (if \\<Phi> then m else THROW e)\"", "lemma [enres_breakdown]: \"(if b then enres_lift m else enres_lift n) = enres_lift (if b then m else n)\"", "lemma option_case_enbd[enres_breakdown]:\n  \"case_option (enres_lift fn) (\\<lambda>v. enres_lift (fs v)) = (\\<lambda>x. enres_lift (case_option fn fs x))\"", "lemma CHECK_monadic_rule_iff:\n    \"(CHECK_monadic c e \\<le> ESPEC E P) \\<longleftrightarrow> (c \\<le> ESPEC E (\\<lambda>r. (r \\<longrightarrow> P ()) \\<and> (\\<not>r \\<longrightarrow> E e)))\"", "lemma CHECK_monadic_pw[refine_pw_simps]:\n    \"nofail (CHECK_monadic c e) \\<longleftrightarrow> nofail c\"\n    \"inres (CHECK_monadic c e) (Inl ee) \\<longleftrightarrow> (inres c (Inl ee) \\<or> inres c (Inr False) \\<and> ee=e)\"\n    \"inres (CHECK_monadic c e) (Inr x) \\<longleftrightarrow> (inres c (Inr True))\"", "lemma CHECK_monadic_rule[refine_vcg]:\n    assumes \"c \\<le> ESPEC E (\\<lambda>r. (r \\<longrightarrow> P ()) \\<and> (\\<not>r \\<longrightarrow> E e))\"\n    shows \"CHECK_monadic c e \\<le> ESPEC E P\"", "lemma CHECK_monadic_refine[refine]:\n    assumes \"ci \\<le> \\<Down>\\<^sub>E ER bool_rel c\"\n    assumes \"(ei,e)\\<in>ER\"  \n    shows \"CHECK_monadic ci ei \\<le>\\<Down>\\<^sub>E ER unit_rel (CHECK_monadic c e)\"", "lemma CHECK_monadic_CHECK_refine[refine]:\n    assumes \"ci \\<le> ESPEC (\\<lambda>e'. (e',e)\\<in>ER \\<and> \\<not>c) (\\<lambda>r. r \\<longleftrightarrow> c)\"\n    assumes \"(ei,e)\\<in>ER\"\n    shows \"CHECK_monadic ci ei \\<le>\\<Down>\\<^sub>E ER unit_rel (CHECK c e)\"", "lemma CHECK_monadic_endb[enres_breakdown]: \"CHECK_monadic (enres_lift c) e = \n    do {b \\<leftarrow> c; CHECK b e}\""], "translations": [["", "lemma EASSUME_simps[simp]: \n  \"EASSUME True = ERETURN ()\"\n  \"EASSUME False = SUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EASSUME True = ERETURN () &&& EASSUME False = SUCCEED", "unfolding EASSUME_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True then ERETURN () else SUCCEED) = ERETURN () &&&\n    (if False then ERETURN () else SUCCEED) = SUCCEED", "by auto"], ["", "lemma EASSERT_simps[simp]: \n  \"EASSERT True = ERETURN ()\"\n  \"EASSERT False = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EASSERT True = ERETURN () &&& EASSERT False = FAIL", "unfolding EASSERT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True then ERETURN () else FAIL) = ERETURN () &&&\n    (if False then ERETURN () else FAIL) = FAIL", "by auto"], ["", "lemma CHECK_simps[simp]: \n  \"CHECK True e = ERETURN ()\" \n  \"CHECK False e = THROW e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK True e = ERETURN () &&& CHECK False e = THROW e", "unfolding CHECK_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True then ERETURN () else THROW e) = ERETURN () &&&\n    (if False then ERETURN () else THROW e) = THROW e", "by auto"], ["", "lemma pw_ESPEC[simp, refine_pw_simps]:\n  \"nofail (ESPEC \\<Phi> \\<Psi>)\"\n  \"inres (ESPEC \\<Phi> \\<Psi>) (Inl e) \\<longleftrightarrow> \\<Phi> e\"\n  \"inres (ESPEC \\<Phi> \\<Psi>) (Inr x) \\<longleftrightarrow> \\<Psi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ESPEC \\<Phi> \\<Psi>) &&&\n    inres (ESPEC \\<Phi> \\<Psi>) (Inl e) = \\<Phi> e &&&\n    inres (ESPEC \\<Phi> \\<Psi>) (Inr x) = \\<Psi> x", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (SPEC\n       (\\<lambda>x.\n           case x of Inl e \\<Rightarrow> \\<Phi> e\n           | Inr r \\<Rightarrow> \\<Psi> r)) &&&\n    inres\n     (SPEC\n       (\\<lambda>x.\n           case x of Inl e \\<Rightarrow> \\<Phi> e\n           | Inr r \\<Rightarrow> \\<Psi> r))\n     (Inl e) =\n    \\<Phi> e &&&\n    inres\n     (SPEC\n       (\\<lambda>x.\n           case x of Inl e \\<Rightarrow> \\<Phi> e\n           | Inr r \\<Rightarrow> \\<Psi> r))\n     (Inr x) =\n    \\<Psi> x", "by auto"], ["", "lemma pw_ERETURN[simp, refine_pw_simps]:\n  \"nofail (ERETURN x)\"\n  \"\\<not>inres (ERETURN x) (Inl e)\"\n  \"inres (ERETURN x) (Inr y) \\<longleftrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ERETURN x) &&&\n    \\<not> inres (ERETURN x) (Inl e) &&& inres (ERETURN x) (Inr y) = (x = y)", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN (Inr x)) &&&\n    \\<not> inres (RETURN (Inr x)) (Inl e) &&&\n    inres (RETURN (Inr x)) (Inr y) = (x = y)", "by auto"], ["", "lemma pw_ebind[refine_pw_simps]:\n  \"nofail (ebind m f) \\<longleftrightarrow> nofail m \\<and> (\\<forall>x. inres m (Inr x) \\<longrightarrow> nofail (f x))\"\n  \"inres (ebind m f) (Inl e) \\<longleftrightarrow> inres m (Inl e) \\<or> (\\<exists>x. inres m (Inr x) \\<and> inres (f x) (Inl e))\"\n  \"inres (ebind m f) (Inr x) \\<longleftrightarrow> nofail m \\<longrightarrow> (\\<exists>y. inres m (Inr y) \\<and> inres (f y) (Inr x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ebind m f) =\n    (nofail m \\<and>\n     (\\<forall>x. inres m (Inr x) \\<longrightarrow> nofail (f x))) &&&\n    inres (ebind m f) (Inl e) =\n    (inres m (Inl e) \\<or>\n     (\\<exists>x. inres m (Inr x) \\<and> inres (f x) (Inl e))) &&&\n    inres (ebind m f) (Inr x) =\n    (nofail m \\<longrightarrow>\n     (\\<exists>y. inres m (Inr y) \\<and> inres (f y) (Inr x)))", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (m \\<bind>\n      (\\<lambda>x.\n          case x of Inl e \\<Rightarrow> RETURN (Inl e)\n          | Inr x \\<Rightarrow> f x)) =\n    (nofail m \\<and>\n     (\\<forall>x. inres m (Inr x) \\<longrightarrow> nofail (f x))) &&&\n    inres\n     (m \\<bind>\n      (\\<lambda>x.\n          case x of Inl e \\<Rightarrow> RETURN (Inl e)\n          | Inr x \\<Rightarrow> f x))\n     (Inl e) =\n    (inres m (Inl e) \\<or>\n     (\\<exists>x. inres m (Inr x) \\<and> inres (f x) (Inl e))) &&&\n    inres\n     (m \\<bind>\n      (\\<lambda>x.\n          case x of Inl e \\<Rightarrow> RETURN (Inl e)\n          | Inr x \\<Rightarrow> f x))\n     (Inr x) =\n    (nofail m \\<longrightarrow>\n     (\\<exists>y. inres m (Inr y) \\<and> inres (f y) (Inr x)))", "apply (auto simp: refine_pw_simps split: sum.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>x.\n                   inres m (Inr x) \\<longrightarrow>\n                   \\<not> inres (f x) (Inl e);\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow> inres m (Inl x1) \\<and> x1 = e;\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> inres (f x2) (Inl e)\\<rbrakk>\n       \\<Longrightarrow> inres m (Inl e)\n 2. \\<And>y.\n       \\<lbrakk>nofail m; \\<forall>x1. y \\<noteq> Inl x1;\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> inres (f x2) (Inr x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            inres m (Inr y) \\<and> inres (f y) (Inr x)", "using sum.exhaust_sel"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>x.\n                   inres m (Inr x) \\<longrightarrow>\n                   \\<not> inres (f x) (Inl e);\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow> inres m (Inl x1) \\<and> x1 = e;\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> inres (f x2) (Inl e)\\<rbrakk>\n       \\<Longrightarrow> inres m (Inl e)\n 2. \\<And>y.\n       \\<lbrakk>nofail m; \\<forall>x1. y \\<noteq> Inl x1;\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> inres (f x2) (Inr x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            inres m (Inr y) \\<and> inres (f y) (Inr x)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>nofail m; \\<forall>x1. y \\<noteq> Inl x1;\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> inres (f x2) (Inr x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            inres m (Inr y) \\<and> inres (f y) (Inr x)", "using sum.exhaust_sel"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>nofail m; \\<forall>x1. y \\<noteq> Inl x1;\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> inres (f x2) (Inr x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            inres m (Inr y) \\<and> inres (f y) (Inr x)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_THROW[simp,refine_pw_simps]:\n  \"nofail (THROW e)\"\n  \"inres (THROW e) (Inl f) \\<longleftrightarrow> f=e\"\n  \"\\<not>inres (THROW e) (Inr x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (THROW e) &&&\n    inres (THROW e) (Inl f) = (f = e) &&& \\<not> inres (THROW e) (Inr x)", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN (Inl e)) &&&\n    inres (RETURN (Inl e)) (Inl f) = (f = e) &&&\n    \\<not> inres (RETURN (Inl e)) (Inr x)", "by (auto simp: refine_pw_simps)"], ["", "lemma pw_CHECK[simp, refine_pw_simps]:\n  \"nofail (CHECK \\<Phi> e)\"\n  \"inres (CHECK \\<Phi> e) (Inl f) \\<longleftrightarrow> \\<not>\\<Phi> \\<and> f=e\"\n  \"inres (CHECK \\<Phi> e) (Inr u) \\<longleftrightarrow> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (CHECK \\<Phi> e) &&&\n    inres (CHECK \\<Phi> e) (Inl f) = (\\<not> \\<Phi> \\<and> f = e) &&&\n    inres (CHECK \\<Phi> e) (Inr u) = \\<Phi>", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (if \\<Phi> then RETURN (Inr ()) else RETURN (Inl e)) &&&\n    inres (if \\<Phi> then RETURN (Inr ()) else RETURN (Inl e)) (Inl f) =\n    (\\<not> \\<Phi> \\<and> f = e) &&&\n    inres (if \\<Phi> then RETURN (Inr ()) else RETURN (Inl e)) (Inr u) =\n    \\<Phi>", "by (auto simp: refine_pw_simps)"], ["", "lemma pw_EASSUME[simp, refine_pw_simps]:\n  \"nofail (EASSUME \\<Phi>)\"\n  \"\\<not>inres (EASSUME \\<Phi>) (Inl e)\"\n  \"inres (EASSUME \\<Phi>) (Inr u) \\<longleftrightarrow> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (EASSUME \\<Phi>) &&&\n    \\<not> inres (EASSUME \\<Phi>) (Inl e) &&&\n    inres (EASSUME \\<Phi>) (Inr u) = \\<Phi>", "unfolding EASSUME_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (if \\<Phi> then ERETURN () else SUCCEED) &&&\n    \\<not> inres (if \\<Phi> then ERETURN () else SUCCEED) (Inl e) &&&\n    inres (if \\<Phi> then ERETURN () else SUCCEED) (Inr u) = \\<Phi>", "by (auto simp: refine_pw_simps)"], ["", "lemma pw_EASSERT[simp, refine_pw_simps]:\n  \"nofail (EASSERT \\<Phi>) \\<longleftrightarrow> \\<Phi>\"\n  \"inres (EASSERT \\<Phi>) (Inr u)\"\n  \"inres (EASSERT \\<Phi>) (Inl e) \\<longleftrightarrow> \\<not>\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (EASSERT \\<Phi>) = \\<Phi> &&&\n    inres (EASSERT \\<Phi>) (Inr u) &&&\n    inres (EASSERT \\<Phi>) (Inl e) = (\\<not> \\<Phi>)", "unfolding EASSERT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (if \\<Phi> then ERETURN () else FAIL) = \\<Phi> &&&\n    inres (if \\<Phi> then ERETURN () else FAIL) (Inr u) &&&\n    inres (if \\<Phi> then ERETURN () else FAIL) (Inl e) = (\\<not> \\<Phi>)", "by (auto simp: refine_pw_simps)"], ["", "lemma pw_CATCH[refine_pw_simps]:\n  \"nofail (CATCH m h) \\<longleftrightarrow> (nofail m \\<and> (\\<forall>x. inres m (Inl x) \\<longrightarrow> nofail (h x)))\"\n  \"inres (CATCH m h) (Inl e) \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<exists>e'. inres m (Inl e') \\<and> inres (h e') (Inl e)))\"\n  \"inres (CATCH m h) (Inr x) \\<longleftrightarrow> inres m (Inr x) \\<or> (\\<exists>e. inres m (Inl e) \\<and> inres (h e) (Inr x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (CATCH m h) =\n    (nofail m \\<and>\n     (\\<forall>x. inres m (Inl x) \\<longrightarrow> nofail (h x))) &&&\n    inres (CATCH m h) (Inl e) =\n    (nofail m \\<longrightarrow>\n     (\\<exists>e'. inres m (Inl e') \\<and> inres (h e') (Inl e))) &&&\n    inres (CATCH m h) (Inr x) =\n    (inres m (Inr x) \\<or>\n     (\\<exists>e. inres m (Inl e) \\<and> inres (h e) (Inr x)))", "unfolding CATCH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (m \\<bind>\n      (\\<lambda>r.\n          case r of Inl e \\<Rightarrow> h e\n          | Inr r \\<Rightarrow> RETURN (Inr r))) =\n    (nofail m \\<and>\n     (\\<forall>x. inres m (Inl x) \\<longrightarrow> nofail (h x))) &&&\n    inres\n     (m \\<bind>\n      (\\<lambda>r.\n          case r of Inl e \\<Rightarrow> h e\n          | Inr r \\<Rightarrow> RETURN (Inr r)))\n     (Inl e) =\n    (nofail m \\<longrightarrow>\n     (\\<exists>e'. inres m (Inl e') \\<and> inres (h e') (Inl e))) &&&\n    inres\n     (m \\<bind>\n      (\\<lambda>r.\n          case r of Inl e \\<Rightarrow> h e\n          | Inr r \\<Rightarrow> RETURN (Inr r)))\n     (Inr x) =\n    (inres m (Inr x) \\<or>\n     (\\<exists>e. inres m (Inl e) \\<and> inres (h e) (Inr x)))", "apply (auto simp add: refine_pw_simps split: sum.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>nofail m;\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow>\n           inres m (Inl x1) \\<and> inres (h x1) (Inl e);\n        \\<forall>x2. y \\<noteq> Inr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            inres m (Inl e') \\<and> inres (h e') (Inl e)\n 2. \\<And>y.\n       \\<lbrakk>\\<forall>e.\n                   inres m (Inl e) \\<longrightarrow>\n                   \\<not> inres (h e) (Inr x);\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow>\n           inres m (Inl x1) \\<and> inres (h x1) (Inr x);\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> x2 = x\\<rbrakk>\n       \\<Longrightarrow> inres m (Inr x)", "using sum.exhaust_sel"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>nofail m;\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow>\n           inres m (Inl x1) \\<and> inres (h x1) (Inl e);\n        \\<forall>x2. y \\<noteq> Inr x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'.\n                            inres m (Inl e') \\<and> inres (h e') (Inl e)\n 2. \\<And>y.\n       \\<lbrakk>\\<forall>e.\n                   inres m (Inl e) \\<longrightarrow>\n                   \\<not> inres (h e) (Inr x);\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow>\n           inres m (Inl x1) \\<and> inres (h x1) (Inr x);\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> x2 = x\\<rbrakk>\n       \\<Longrightarrow> inres m (Inr x)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>e.\n                   inres m (Inl e) \\<longrightarrow>\n                   \\<not> inres (h e) (Inr x);\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow>\n           inres m (Inl x1) \\<and> inres (h x1) (Inr x);\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> x2 = x\\<rbrakk>\n       \\<Longrightarrow> inres m (Inr x)", "using sum.exhaust_sel"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sum = Inl (projl ?sum) \\<Longrightarrow> ?P;\n   ?sum = Inr (projr ?sum) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>e.\n                   inres m (Inl e) \\<longrightarrow>\n                   \\<not> inres (h e) (Inr x);\n        \\<forall>x1.\n           y = Inl x1 \\<longrightarrow>\n           inres m (Inl x1) \\<and> inres (h x1) (Inr x);\n        \\<forall>x2.\n           y = Inr x2 \\<longrightarrow>\n           inres m (Inr x2) \\<and> x2 = x\\<rbrakk>\n       \\<Longrightarrow> inres m (Inr x)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pw_ele_iff: \"m \\<le> n \\<longleftrightarrow> (nofail n \\<longrightarrow> \n    nofail m \n  \\<and> (\\<forall>e. inres m (Inl e) \\<longrightarrow> inres n (Inl e))\n  \\<and> (\\<forall>x. inres m (Inr x) \\<longrightarrow> inres n (Inr x))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<le> n) =\n    (nofail n \\<longrightarrow>\n     nofail m \\<and>\n     (\\<forall>e. inres m (Inl e) \\<longrightarrow> inres n (Inl e)) \\<and>\n     (\\<forall>x. inres m (Inr x) \\<longrightarrow> inres n (Inr x)))", "apply (auto simp: pw_le_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail n; nofail m;\n        \\<forall>e. inres m (Inl e) \\<longrightarrow> inres n (Inl e);\n        \\<forall>x. inres m (Inr x) \\<longrightarrow> inres n (Inr x);\n        inres m x\\<rbrakk>\n       \\<Longrightarrow> inres n x", "by (metis sum.exhaust_sel)"], ["", "lemma pw_eeq_iff: \"m = n \\<longleftrightarrow> \n    (nofail m \\<longleftrightarrow> nofail n) \n  \\<and> (\\<forall>e. inres m (Inl e) \\<longleftrightarrow> inres n (Inl e))\n  \\<and> (\\<forall>x. inres m (Inr x) \\<longleftrightarrow> inres n (Inr x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = n) =\n    (nofail m = nofail n \\<and>\n     (\\<forall>e. inres m (Inl e) = inres n (Inl e)) \\<and>\n     (\\<forall>x. inres m (Inr x) = inres n (Inr x)))", "apply (auto simp: pw_eq_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>e. inres m (Inl e) = inres n (Inl e);\n        \\<forall>x. inres m (Inr x) = inres n (Inr x); nofail m; nofail n;\n        inres m x\\<rbrakk>\n       \\<Longrightarrow> inres n x\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>e. inres m (Inl e) = inres n (Inl e);\n        \\<forall>x. inres m (Inr x) = inres n (Inr x); nofail m; nofail n;\n        inres n x\\<rbrakk>\n       \\<Longrightarrow> inres m x", "by (metis sum.exhaust_sel)+"], ["", "lemma enres_monad_laws[simp]:\n  \"ebind (ERETURN x) f = f x\"\n  \"ebind m (ERETURN) = m\"\n  \"ebind (ebind m f) g = ebind m (\\<lambda>x. ebind (f x) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (ERETURN x) f = f x &&&\n    ebind m ERETURN = m &&&\n    ebind (ebind m f) g = ebind m (\\<lambda>x. ebind (f x) g)", "by (auto simp: pw_eeq_iff refine_pw_simps)"], ["", "lemma enres_additional_laws[simp]:\n  \"ebind (THROW e) f = THROW e\"\n  \n  \"CATCH (THROW e) h = h e\"\n  \"CATCH (ERETURN x) h = ERETURN x\"\n  \"CATCH m THROW = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ebind (THROW e) f = THROW e &&& CATCH (THROW e) h = h e) &&&\n    CATCH (ERETURN x) h = ERETURN x &&& CATCH m THROW = m", "apply (auto simp: pw_eeq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas ESPEC_trans = order_trans[where z=\"ESPEC Error_Postcond Normal_Postcond\" for Error_Postcond Normal_Postcond, zero_var_indexes]"], ["", "lemma ESPEC_cons: \n  assumes \"m \\<le> ESPEC E Q\"\n  assumes \"\\<And>e. E e \\<Longrightarrow> E' e\"\n  assumes \"\\<And>x. Q x \\<Longrightarrow> Q' x\"\n  shows \"m \\<le> ESPEC E' Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> ESPEC E' Q'", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> ESPEC E Q\n  E ?e \\<Longrightarrow> E' ?e\n  Q ?x \\<Longrightarrow> Q' ?x\n\ngoal (1 subgoal):\n 1. m \\<le> ESPEC E' Q'", "by (auto simp: pw_ele_iff)"], ["", "lemma ebind_rule_iff: \"doE { x\\<leftarrow>m; f x } \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> m \\<le> ESPEC \\<Phi> (\\<lambda>x. f x \\<le> ESPEC \\<Phi> \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ebind m f \\<le> ESPEC \\<Phi> \\<Psi>) =\n    (m \\<le> ESPEC \\<Phi> (\\<lambda>x. f x \\<le> ESPEC \\<Phi> \\<Psi>))", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemmas ebind_rule[refine_vcg] = ebind_rule_iff[THEN iffD2]"], ["", "lemma ERETURN_rule_iff[simp]: \"ERETURN x \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> \\<Psi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ERETURN x \\<le> ESPEC \\<Phi> \\<Psi>) = \\<Psi> x", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemmas ERETURN_rule[refine_vcg] = ERETURN_rule_iff[THEN iffD2]"], ["", "lemma ESPEC_rule_iff: \"ESPEC \\<Phi> \\<Psi> \\<le> ESPEC \\<Phi>' \\<Psi>' \\<longleftrightarrow> (\\<forall>e. \\<Phi> e \\<longrightarrow> \\<Phi>' e) \\<and> (\\<forall>x. \\<Psi> x \\<longrightarrow> \\<Psi>' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ESPEC \\<Phi> \\<Psi> \\<le> ESPEC \\<Phi>' \\<Psi>') =\n    ((\\<forall>e. \\<Phi> e \\<longrightarrow> \\<Phi>' e) \\<and>\n     (\\<forall>x. \\<Psi> x \\<longrightarrow> \\<Psi>' x))", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemmas ESPEC_rule[refine_vcg] = ESPEC_rule_iff[THEN iffD2]"], ["", "lemma THROW_rule_iff: \"THROW e \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> \\<Phi> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THROW e \\<le> ESPEC \\<Phi> \\<Psi>) = \\<Phi> e", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemmas THROW_rule[refine_vcg] = THROW_rule_iff[THEN iffD2]"], ["", "lemma CATCH_rule_iff: \"CATCH m h \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> m \\<le> ESPEC (\\<lambda>e. h e \\<le> ESPEC \\<Phi> \\<Psi>) \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CATCH m h \\<le> ESPEC \\<Phi> \\<Psi>) =\n    (m \\<le> ESPEC (\\<lambda>e. h e \\<le> ESPEC \\<Phi> \\<Psi>) \\<Psi>)", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemmas CATCH_rule[refine_vcg] = CATCH_rule_iff[THEN iffD2]"], ["", "lemma CHECK_rule_iff: \"CHECK c e \\<le> ESPEC \\<Phi> \\<Psi> \\<longleftrightarrow> (c \\<longrightarrow> \\<Psi> ()) \\<and> (\\<not>c \\<longrightarrow> \\<Phi> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CHECK c e \\<le> ESPEC \\<Phi> \\<Psi>) =\n    ((c \\<longrightarrow> \\<Psi> ()) \\<and>\n     (\\<not> c \\<longrightarrow> \\<Phi> e))", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma CHECK_rule[refine_vcg]:\n  assumes \"c \\<Longrightarrow> \\<Psi> ()\"\n  assumes \"\\<not>c \\<Longrightarrow> \\<Phi> e\"\n  shows \"CHECK c e \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK c e \\<le> ESPEC \\<Phi> \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  c \\<Longrightarrow> \\<Psi> ()\n  \\<not> c \\<Longrightarrow> \\<Phi> e\n\ngoal (1 subgoal):\n 1. CHECK c e \\<le> ESPEC \\<Phi> \\<Psi>", "by (simp add: CHECK_rule_iff)"], ["", "lemma EASSUME_rule[refine_vcg]: \"\\<lbrakk>\\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> EASSUME \\<Phi> \\<le> ESPEC E \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> \\<Longrightarrow> \\<Psi> ()) \\<Longrightarrow>\n    EASSUME \\<Phi> \\<le> ESPEC E \\<Psi>", "by (cases \\<Phi>) auto"], ["", "lemma EASSERT_rule[refine_vcg]: \"\\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk> \\<Longrightarrow> EASSERT \\<Phi> \\<le> ESPEC E \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi>; \\<Phi> \\<Longrightarrow> \\<Psi> ()\\<rbrakk>\n    \\<Longrightarrow> EASSERT \\<Phi> \\<le> ESPEC E \\<Psi>", "by auto"], ["", "lemma eprod_rule[refine_vcg]: \n  \"\\<lbrakk>\\<And>a b. p=(a,b) \\<Longrightarrow> S a b \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk> \\<Longrightarrow> (case p of (a,b) \\<Rightarrow> S a b) \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        p = (a, b) \\<Longrightarrow>\n        S a b \\<le> ESPEC \\<Phi> \\<Psi>) \\<Longrightarrow>\n    (case p of (a, b) \\<Rightarrow> S a b) \\<le> ESPEC \\<Phi> \\<Psi>", "by (auto split: prod.split)"], ["", "(* TODO: Add a simplifier setup that normalizes nested case-expressions to\n  the vcg! *)"], ["", "lemma eprod2_rule[refine_vcg]:\n  assumes \"\\<And>a b c d. \\<lbrakk>ab=(a,b); cd=(c,d)\\<rbrakk> \\<Longrightarrow> f a b c d \\<le> ESPEC \\<Phi> \\<Psi>\"\n  shows \"(\\<lambda>(a,b) (c,d). f a b c d) ab cd \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ab of (a, b) \\<Rightarrow> \\<lambda>(c, d). f a b c d) cd\n    \\<le> ESPEC \\<Phi> \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ab = (?a, ?b); cd = (?c, ?d)\\<rbrakk>\n  \\<Longrightarrow> f ?a ?b ?c ?d \\<le> ESPEC \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. (case ab of (a, b) \\<Rightarrow> \\<lambda>(c, d). f a b c d) cd\n    \\<le> ESPEC \\<Phi> \\<Psi>", "by (auto split: prod.split)"], ["", "lemma eif_rule[refine_vcg]: \n  \"\\<lbrakk> b \\<Longrightarrow> S1 \\<le> ESPEC \\<Phi> \\<Psi>; \\<not>b \\<Longrightarrow> S2 \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk> \n  \\<Longrightarrow> (if b then S1 else S2) \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<Longrightarrow> S1 \\<le> ESPEC \\<Phi> \\<Psi>;\n     \\<not> b \\<Longrightarrow> S2 \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> (if b then S1 else S2) \\<le> ESPEC \\<Phi> \\<Psi>", "by (auto)"], ["", "lemma eoption_rule[refine_vcg]: \n  \"\\<lbrakk> v=None \\<Longrightarrow> S1 \\<le> ESPEC \\<Phi> \\<Psi>; \\<And>x. v=Some x \\<Longrightarrow> f2 x \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk> \n  \\<Longrightarrow> case_option S1 f2 v \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = None \\<Longrightarrow> S1 \\<le> ESPEC \\<Phi> \\<Psi>;\n     \\<And>x.\n        v = Some x \\<Longrightarrow> f2 x \\<le> ESPEC \\<Phi> \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> (case v of None \\<Rightarrow> S1\n                       | Some x \\<Rightarrow> f2 x)\n                      \\<le> ESPEC \\<Phi> \\<Psi>", "by (auto split: option.split)"], ["", "lemma eLet_rule[refine_vcg]: \"f v \\<le> ESPEC \\<Phi> \\<Psi> \\<Longrightarrow> (let x=v in f x) \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v \\<le> ESPEC \\<Phi> \\<Psi> \\<Longrightarrow>\n    Let v f \\<le> ESPEC \\<Phi> \\<Psi>", "by simp"], ["", "lemma eLet_rule':\n  assumes \"\\<And>x. x=v \\<Longrightarrow> f x \\<le> ESPEC \\<Phi> \\<Psi>\"\n  shows \"Let v (\\<lambda>x. f x) \\<le> ESPEC \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let v f \\<le> ESPEC \\<Phi> \\<Psi>", "using assms"], ["proof (prove)\nusing this:\n  ?x = v \\<Longrightarrow> f ?x \\<le> ESPEC \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. Let v f \\<le> ESPEC \\<Phi> \\<Psi>", "by simp"], ["", "definition [enres_unfolds]: \"EWHILEIT I c f s \\<equiv> WHILEIT \n  (\\<lambda>Inl _ \\<Rightarrow> True | Inr s \\<Rightarrow> I s) \n  (\\<lambda>Inl _ \\<Rightarrow> False | Inr s \\<Rightarrow> c s)\n  (\\<lambda>s. ASSERT (\\<not>isl s) \\<then> (let s = projr s in f s))\n  (Inr s)\""], ["", "definition [enres_unfolds]: \"EWHILET \\<equiv> EWHILEIT (\\<lambda>_. True)\""], ["", "lemma EWHILEIT_rule[refine_vcg]:\n  assumes WF: \"wf R\"\n    and I0: \"I s\\<^sub>0\"\n    and IS: \"\\<And>s. \\<lbrakk>I s; b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> f s \\<le> ESPEC E (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\"\n    and IMP: \"\\<And>s. \\<lbrakk>I s; \\<not> b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"EWHILEIT I b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>", "unfolding EWHILEIT_def ESPEC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl x \\<Rightarrow> True\n                            | Inr s \\<Rightarrow> I s\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr s\\<^sub>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e\n               | Inr r \\<Rightarrow> \\<Phi> r)", "apply (rule order_trans[OF WHILEIT_weaken[where I=\"\\<lambda>Inl e \\<Rightarrow> E e | Inr s \\<Rightarrow> I s \\<and> (s,s\\<^sub>0)\\<in>R\\<^sup>*\"]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       case x of Inl e \\<Rightarrow> E e\n       | Inr s \\<Rightarrow>\n           I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>* \\<Longrightarrow>\n       case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s\n 2. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl e \\<Rightarrow> E e\n                            | Inr s \\<Rightarrow>\n                                I s \\<and>\n                                (s, s\\<^sub>0) \\<in> R\\<^sup>*\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr s\\<^sub>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e\n               | Inr r \\<Rightarrow> \\<Phi> r)", "apply (auto split: sum.splits) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl e \\<Rightarrow> E e\n                            | Inr s \\<Rightarrow>\n                                I s \\<and>\n                                (s, s\\<^sub>0) \\<in> R\\<^sup>*\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr s\\<^sub>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e\n               | Inr r \\<Rightarrow> \\<Phi> r)", "apply (rule WHILEIT_rule[where R=\"inv_image (less_than <*lex*> R) (\\<lambda>Inl e \\<Rightarrow> (0,undefined) | Inr s \\<Rightarrow> (1,s))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image (less_than <*lex*> R)\n         (\\<lambda>x.\n             case x of Inl e \\<Rightarrow> (0, undefined)\n             | Inr s \\<Rightarrow> (1, s)))\n 2. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*\n 3. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        case s of Inl x \\<Rightarrow> False\n        | Inr s \\<Rightarrow> b s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl s) \\<bind>\n                         (\\<lambda>_. Let (projr s) f)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of Inl e \\<Rightarrow> E e\n                                     | Inr s \\<Rightarrow>\n   I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                    (s', s)\n                                    \\<in> inv_image (less_than <*lex*> R)\n     (\\<lambda>x.\n         case x of Inl e \\<Rightarrow> (0, undefined)\n         | Inr s \\<Rightarrow> (1, s)))\n 4. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (less_than <*lex*> R)\n         (\\<lambda>x.\n             case x of Inl e \\<Rightarrow> (0, undefined)\n             | Inr s \\<Rightarrow> (1, s)))", "using WF"], ["proof (prove)\nusing this:\n  wf R\n\ngoal (1 subgoal):\n 1. wf (inv_image (less_than <*lex*> R)\n         (\\<lambda>x.\n             case x of Inl e \\<Rightarrow> (0, undefined)\n             | Inr s \\<Rightarrow> (1, s)))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*\n 2. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        case s of Inl x \\<Rightarrow> False\n        | Inr s \\<Rightarrow> b s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl s) \\<bind>\n                         (\\<lambda>_. Let (projr s) f)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of Inl e \\<Rightarrow> E e\n                                     | Inr s \\<Rightarrow>\n   I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                    (s', s)\n                                    \\<in> inv_image (less_than <*lex*> R)\n     (\\<lambda>x.\n         case x of Inl e \\<Rightarrow> (0, undefined)\n         | Inr s \\<Rightarrow> (1, s)))\n 3. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*", "using I0"], ["proof (prove)\nusing this:\n  I s\\<^sub>0\n\ngoal (1 subgoal):\n 1. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        case s of Inl x \\<Rightarrow> False\n        | Inr s \\<Rightarrow> b s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl s) \\<bind>\n                         (\\<lambda>_. Let (projr s) f)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of Inl e \\<Rightarrow> E e\n                                     | Inr s \\<Rightarrow>\n   I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                    (s', s)\n                                    \\<in> inv_image (less_than <*lex*> R)\n     (\\<lambda>x.\n         case x of Inl e \\<Rightarrow> (0, undefined)\n         | Inr s \\<Rightarrow> (1, s)))\n 2. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of Inl e \\<Rightarrow> E e\n             | Inr s \\<Rightarrow>\n                 I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n     case s_ of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s\\<rbrakk>\n    \\<Longrightarrow> ASSERT (\\<not> isl s_) \\<bind>\n                      (\\<lambda>_. Let (projr s_) f)\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 (case s' of Inl e \\<Rightarrow> E e\n                                  | Inr s \\<Rightarrow>\nI s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                 (s', s_)\n                                 \\<in> inv_image (less_than <*lex*> R)\n  (\\<lambda>x.\n      case x of Inl e \\<Rightarrow> (0, undefined)\n      | Inr s \\<Rightarrow> (1, s)))", "apply (clarsimp split: sum.splits simp: ESPEC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> f x2\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (\\<forall>x1.\n  s' = Inl x1 \\<longrightarrow> E x1) \\<and>\n                                    (\\<forall>x2a.\n  s' = Inr x2a \\<longrightarrow>\n  I x2a \\<and> (x2a, s\\<^sub>0) \\<in> R\\<^sup>* \\<and> (x2a, x2) \\<in> R))", "apply (rule order_trans[OF IS])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> I x2\n 2. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> b x2\n 3. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x2, s\\<^sub>0) \\<in> R\\<^sup>*\n 4. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> ESPEC E (\\<lambda>s'. I s' \\<and> (s', x2) \\<in> R)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (\\<forall>x1.\n  s' = Inl x1 \\<longrightarrow> E x1) \\<and>\n                                    (\\<forall>x2a.\n  s' = Inr x2a \\<longrightarrow>\n  I x2a \\<and> (x2a, s\\<^sub>0) \\<in> R\\<^sup>* \\<and> (x2a, x2) \\<in> R))", "apply (auto simp: ESPEC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of Inl e \\<Rightarrow> E e\n             | Inr s \\<Rightarrow>\n                 I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n     \\<not> (case s_ of Inl x \\<Rightarrow> False\n             | Inr s \\<Rightarrow> b s)\\<rbrakk>\n    \\<Longrightarrow> case s_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> \\<Phi> r", "using IMP"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?s; \\<not> b ?s; (?s, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of Inl e \\<Rightarrow> E e\n             | Inr s \\<Rightarrow>\n                 I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n     \\<not> (case s_ of Inl x \\<Rightarrow> False\n             | Inr s \\<Rightarrow> b s)\\<rbrakk>\n    \\<Longrightarrow> case s_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> \\<Phi> r", "by (auto split: sum.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma EWHILET_rule:\n  assumes WF: \"wf R\"\n    and I0: \"I s\\<^sub>0\"\n    and IS: \"\\<And>s. \\<lbrakk>I s; b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> f s \\<le> ESPEC E (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\"\n    and IMP: \"\\<And>s. \\<lbrakk>I s; \\<not> b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n  shows \"EWHILET b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILET b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>", "unfolding EWHILET_def EWHILEIT_def ESPEC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl x \\<Rightarrow> True\n                            | _ \\<Rightarrow> True\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr s\\<^sub>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e\n               | Inr r \\<Rightarrow> \\<Phi> r)", "apply (rule order_trans[OF WHILEIT_weaken[where I=\"\\<lambda>Inl e \\<Rightarrow> E e | Inr s \\<Rightarrow> I s \\<and> (s,s\\<^sub>0)\\<in>R\\<^sup>*\"]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       case x of Inl e \\<Rightarrow> E e\n       | Inr s \\<Rightarrow>\n           I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>* \\<Longrightarrow>\n       case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True\n 2. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl e \\<Rightarrow> E e\n                            | Inr s \\<Rightarrow>\n                                I s \\<and>\n                                (s, s\\<^sub>0) \\<in> R\\<^sup>*\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr s\\<^sub>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e\n               | Inr r \\<Rightarrow> \\<Phi> r)", "apply (auto split: sum.splits) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl e \\<Rightarrow> E e\n                            | Inr s \\<Rightarrow>\n                                I s \\<and>\n                                (s, s\\<^sub>0) \\<in> R\\<^sup>*\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr s\\<^sub>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e\n               | Inr r \\<Rightarrow> \\<Phi> r)", "apply (rule WHILEIT_rule[where R=\"inv_image (less_than <*lex*> R) (\\<lambda>Inl e \\<Rightarrow> (0,undefined) | Inr s \\<Rightarrow> (1,s))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image (less_than <*lex*> R)\n         (\\<lambda>x.\n             case x of Inl e \\<Rightarrow> (0, undefined)\n             | Inr s \\<Rightarrow> (1, s)))\n 2. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*\n 3. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        case s of Inl x \\<Rightarrow> False\n        | Inr s \\<Rightarrow> b s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl s) \\<bind>\n                         (\\<lambda>_. Let (projr s) f)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of Inl e \\<Rightarrow> E e\n                                     | Inr s \\<Rightarrow>\n   I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                    (s', s)\n                                    \\<in> inv_image (less_than <*lex*> R)\n     (\\<lambda>x.\n         case x of Inl e \\<Rightarrow> (0, undefined)\n         | Inr s \\<Rightarrow> (1, s)))\n 4. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (less_than <*lex*> R)\n         (\\<lambda>x.\n             case x of Inl e \\<Rightarrow> (0, undefined)\n             | Inr s \\<Rightarrow> (1, s)))", "using WF"], ["proof (prove)\nusing this:\n  wf R\n\ngoal (1 subgoal):\n 1. wf (inv_image (less_than <*lex*> R)\n         (\\<lambda>x.\n             case x of Inl e \\<Rightarrow> (0, undefined)\n             | Inr s \\<Rightarrow> (1, s)))", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*\n 2. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        case s of Inl x \\<Rightarrow> False\n        | Inr s \\<Rightarrow> b s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl s) \\<bind>\n                         (\\<lambda>_. Let (projr s) f)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of Inl e \\<Rightarrow> E e\n                                     | Inr s \\<Rightarrow>\n   I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                    (s', s)\n                                    \\<in> inv_image (less_than <*lex*> R)\n     (\\<lambda>x.\n         case x of Inl e \\<Rightarrow> (0, undefined)\n         | Inr s \\<Rightarrow> (1, s)))\n 3. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*", "using I0"], ["proof (prove)\nusing this:\n  I s\\<^sub>0\n\ngoal (1 subgoal):\n 1. case Inr s\\<^sub>0 of Inl e \\<Rightarrow> E e\n    | Inr s \\<Rightarrow> I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        case s of Inl x \\<Rightarrow> False\n        | Inr s \\<Rightarrow> b s\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl s) \\<bind>\n                         (\\<lambda>_. Let (projr s) f)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (case s' of Inl e \\<Rightarrow> E e\n                                     | Inr s \\<Rightarrow>\n   I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                    (s', s)\n                                    \\<in> inv_image (less_than <*lex*> R)\n     (\\<lambda>x.\n         case x of Inl e \\<Rightarrow> (0, undefined)\n         | Inr s \\<Rightarrow> (1, s)))\n 2. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of Inl e \\<Rightarrow> E e\n             | Inr s \\<Rightarrow>\n                 I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n     case s_ of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s\\<rbrakk>\n    \\<Longrightarrow> ASSERT (\\<not> isl s_) \\<bind>\n                      (\\<lambda>_. Let (projr s_) f)\n                      \\<le> SPEC\n                             (\\<lambda>s'.\n                                 (case s' of Inl e \\<Rightarrow> E e\n                                  | Inr s \\<Rightarrow>\nI s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*) \\<and>\n                                 (s', s_)\n                                 \\<in> inv_image (less_than <*lex*> R)\n  (\\<lambda>x.\n      case x of Inl e \\<Rightarrow> (0, undefined)\n      | Inr s \\<Rightarrow> (1, s)))", "apply (clarsimp split: sum.splits simp: ESPEC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> f x2\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (\\<forall>x1.\n  s' = Inl x1 \\<longrightarrow> E x1) \\<and>\n                                    (\\<forall>x2a.\n  s' = Inr x2a \\<longrightarrow>\n  I x2a \\<and> (x2a, s\\<^sub>0) \\<in> R\\<^sup>* \\<and> (x2a, x2) \\<in> R))", "apply (rule order_trans[OF IS])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> I x2\n 2. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> b x2\n 3. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x2, s\\<^sub>0) \\<in> R\\<^sup>*\n 4. \\<And>x2.\n       \\<lbrakk>b x2; s_ = Inr x2; I x2;\n        (x2, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> ESPEC E (\\<lambda>s'. I s' \\<and> (s', x2) \\<in> R)\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    (\\<forall>x1.\n  s' = Inl x1 \\<longrightarrow> E x1) \\<and>\n                                    (\\<forall>x2a.\n  s' = Inr x2a \\<longrightarrow>\n  I x2a \\<and> (x2a, s\\<^sub>0) \\<in> R\\<^sup>* \\<and> (x2a, x2) \\<in> R))", "apply (auto simp: ESPEC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>case s of Inl e \\<Rightarrow> E e\n                | Inr s \\<Rightarrow>\n                    I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n        \\<not> (case s of Inl x \\<Rightarrow> False\n                | Inr s \\<Rightarrow> b s)\\<rbrakk>\n       \\<Longrightarrow> case s of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> \\<Phi> r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of Inl e \\<Rightarrow> E e\n             | Inr s \\<Rightarrow>\n                 I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n     \\<not> (case s_ of Inl x \\<Rightarrow> False\n             | Inr s \\<Rightarrow> b s)\\<rbrakk>\n    \\<Longrightarrow> case s_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> \\<Phi> r", "using IMP"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?s; \\<not> b ?s; (?s, s\\<^sub>0) \\<in> R\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case s_ of Inl e \\<Rightarrow> E e\n             | Inr s \\<Rightarrow>\n                 I s \\<and> (s, s\\<^sub>0) \\<in> R\\<^sup>*;\n     \\<not> (case s_ of Inl x \\<Rightarrow> False\n             | Inr s \\<Rightarrow> b s)\\<rbrakk>\n    \\<Longrightarrow> case s_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> \\<Phi> r", "by (auto split: sum.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma EWHILEIT_weaken:\n  assumes \"\\<And>x. I x \\<Longrightarrow> I' x\"\n  shows \"EWHILEIT I' b f x \\<le> EWHILEIT I b f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I' b f x \\<le> EWHILEIT I b f x", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl x \\<Rightarrow> True\n                            | Inr s \\<Rightarrow> I' s\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr x)\n    \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                                  case x of Inl x \\<Rightarrow> True\n                                  | Inr s \\<Rightarrow> I s\\<^esup>\n           (\\<lambda>x.\n               case x of Inl x \\<Rightarrow> False\n               | Inr s \\<Rightarrow> b s)\n           (\\<lambda>s.\n               ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n           (Inr x)", "apply (rule WHILEIT_weaken)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of Inl x \\<Rightarrow> True\n       | Inr s \\<Rightarrow> I s \\<Longrightarrow>\n       case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I' s", "using assms"], ["proof (prove)\nusing this:\n  I ?x \\<Longrightarrow> I' ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of Inl x \\<Rightarrow> True\n       | Inr s \\<Rightarrow> I s \\<Longrightarrow>\n       case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I' s", "by (auto split: sum.split)"], ["", "text \\<open>Explicitly specify a different invariant. \\<close>"], ["", "lemma EWHILEIT_expinv_rule:\n  assumes WF: \"wf R\"\n    and I0: \"I s\\<^sub>0\"\n    and IS: \"\\<And>s. \\<lbrakk>I s; b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> f s \\<le> ESPEC E (\\<lambda>s'. I s' \\<and> (s', s) \\<in> R)\"\n    and IMP: \"\\<And>s. \\<lbrakk>I s; \\<not> b s; (s,s\\<^sub>0)\\<in>R\\<^sup>*\\<rbrakk> \\<Longrightarrow> \\<Phi> s\"\n    and INVIMP: \"\\<And>s. I s \\<Longrightarrow> I' s\"\n  shows \"EWHILEIT I' b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I' b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>", "apply (rule order_trans[OF EWHILEIT_weaken])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. ?I1 x \\<Longrightarrow> I' x\n 2. EWHILEIT ?I1 b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>", "using INVIMP"], ["proof (prove)\nusing this:\n  I ?s \\<Longrightarrow> I' ?s\n\ngoal (2 subgoals):\n 1. \\<And>x. ?I1 x \\<Longrightarrow> I' x\n 2. EWHILEIT ?I1 b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I b f s\\<^sub>0 \\<le> ESPEC E \\<Phi>", "apply (rule EWHILEIT_rule; fact+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition [enres_unfolds]: \"enfoldli l c f s \\<equiv> \n  nfoldli l (\\<lambda>Inl e\\<Rightarrow>False | Inr x \\<Rightarrow> c x) (\\<lambda>x s. do {ASSERT (\\<not>isl s); let s=projr s; f x s}) (Inr s)\""], ["", "lemma enfoldli_simps[simp]:\n  \"enfoldli [] c f s = ERETURN s\"\n  \"enfoldli (x#ls) c f s = \n    (if c s then doE { s\\<leftarrow>f x s; enfoldli ls c f s} else ERETURN s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enfoldli [] c f s = ERETURN s &&&\n    enfoldli (x # ls) c f s =\n    (if c s then ebind (f x s) (enfoldli ls c f) else ERETURN s)", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli []\n     (\\<lambda>xa.\n         case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n     (\\<lambda>x s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) (f x)))\n     (Inr s) =\n    RETURN (Inr s) &&&\n    nfoldli (x # ls)\n     (\\<lambda>xa.\n         case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n     (\\<lambda>x s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) (f x)))\n     (Inr s) =\n    (if c s\n     then f x s \\<bind>\n          (\\<lambda>x.\n              case x of Inl e \\<Rightarrow> RETURN (Inl e)\n              | Inr x \\<Rightarrow>\n                  nfoldli ls (case_sum (\\<lambda>e. False) c)\n                   (\\<lambda>x s.\n                       ASSERT (\\<not> isl s) \\<bind>\n                       (\\<lambda>_. Let (projr s) (f x)))\n                   (Inr x))\n     else RETURN (Inr s))", "by (auto split: sum.split intro!: arg_cong[where f = \"Refine_Basic.bind _\"] ext)"], ["", "lemma enfoldli_rule:\n  assumes I0: \"I [] l0 \\<sigma>0\"\n  assumes IS: \"\\<And>x l1 l2 \\<sigma>. \\<lbrakk> l0=l1@x#l2; I l1 (x#l2) \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f x \\<sigma> \\<le> ESPEC E (I (l1@[x]) l2)\"\n  assumes FNC: \"\\<And>l1 l2 \\<sigma>. \\<lbrakk> l0=l1@l2; I l1 l2 \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I l0 [] \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"enfoldli l0 c f \\<sigma>0 \\<le> ESPEC E P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enfoldli l0 c f \\<sigma>0 \\<le> ESPEC E P", "unfolding enfoldli_def ESPEC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l0\n     (\\<lambda>xa.\n         case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n     (\\<lambda>x s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) (f x)))\n     (Inr \\<sigma>0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               case x of Inl e \\<Rightarrow> E e | Inr r \\<Rightarrow> P r)", "apply (rule nfoldli_rule[where I=\"\\<lambda>l1 l2. \\<lambda>Inl e \\<Rightarrow> E e | Inr \\<sigma> \\<Rightarrow> I l1 l2 \\<sigma>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. case Inr \\<sigma>0 of Inl e \\<Rightarrow> E e\n    | Inr \\<sigma> \\<Rightarrow> I [] l0 \\<sigma>\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ x # l2;\n        case \\<sigma> of Inl e \\<Rightarrow> E e\n        | Inr \\<sigma> \\<Rightarrow> I l1 (x # l2) \\<sigma>;\n        case \\<sigma> of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl \\<sigma>) \\<bind>\n                         (\\<lambda>_. Let (projr \\<sigma>) (f x))\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    case xa of Inl e \\<Rightarrow> E e\n                                    | Inr \\<sigma> \\<Rightarrow>\n  I (l1 @ [x]) l2 \\<sigma>)\n 3. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ l2;\n        case \\<sigma> of Inl e \\<Rightarrow> E e\n        | Inr \\<sigma> \\<Rightarrow> I l1 l2 \\<sigma>;\n        \\<not> (case \\<sigma> of Inl e \\<Rightarrow> False\n                | Inr x \\<Rightarrow> c x)\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>case \\<sigma> of Inl e \\<Rightarrow> E e\n                | Inr \\<sigma> \\<Rightarrow> I l0 [] \\<sigma>;\n        case \\<sigma> of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. case Inr \\<sigma>0 of Inl e \\<Rightarrow> E e\n    | Inr \\<sigma> \\<Rightarrow> I [] l0 \\<sigma>", "by (auto simp: I0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ x # l2;\n        case \\<sigma> of Inl e \\<Rightarrow> E e\n        | Inr \\<sigma> \\<Rightarrow> I l1 (x # l2) \\<sigma>;\n        case \\<sigma> of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl \\<sigma>) \\<bind>\n                         (\\<lambda>_. Let (projr \\<sigma>) (f x))\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    case xa of Inl e \\<Rightarrow> E e\n                                    | Inr \\<sigma> \\<Rightarrow>\n  I (l1 @ [x]) l2 \\<sigma>)\n 2. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ l2;\n        case \\<sigma> of Inl e \\<Rightarrow> E e\n        | Inr \\<sigma> \\<Rightarrow> I l1 l2 \\<sigma>;\n        \\<not> (case \\<sigma> of Inl e \\<Rightarrow> False\n                | Inr x \\<Rightarrow> c x)\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>case \\<sigma> of Inl e \\<Rightarrow> E e\n                | Inr \\<sigma> \\<Rightarrow> I l0 [] \\<sigma>;\n        case \\<sigma> of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l0 = l1_ @ x_ # l2_;\n     case \\<sigma>_ of Inl e \\<Rightarrow> E e\n     | Inr \\<sigma> \\<Rightarrow> I l1_ (x_ # l2_) \\<sigma>;\n     case \\<sigma>_ of Inl e \\<Rightarrow> False\n     | Inr x \\<Rightarrow> c x\\<rbrakk>\n    \\<Longrightarrow> ASSERT (\\<not> isl \\<sigma>_) \\<bind>\n                      (\\<lambda>_. Let (projr \\<sigma>_) (f x_))\n                      \\<le> SPEC\n                             (\\<lambda>xa.\n                                 case xa of Inl e \\<Rightarrow> E e\n                                 | Inr \\<sigma> \\<Rightarrow>\n                                     I (l1_ @ [x_]) l2_ \\<sigma>)", "apply (simp split: sum.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>c x2; l0 = l1_ @ x_ # l2_; \\<sigma>_ = Inr x2;\n        I l1_ (x_ # l2_) x2\\<rbrakk>\n       \\<Longrightarrow> f x_ x2\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    (\\<forall>x1.\n  xa = Inl x1 \\<longrightarrow> E x1) \\<and>\n                                    (\\<forall>x2.\n  xa = Inr x2 \\<longrightarrow> I (l1_ @ [x_]) l2_ x2))", "apply (erule (2) order_trans[OF IS])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>c x2; \\<sigma>_ = Inr x2; I l1_ (x_ # l2_) x2\\<rbrakk>\n       \\<Longrightarrow> ESPEC E (I (l1_ @ [x_]) l2_)\n                         \\<le> SPEC\n                                (\\<lambda>xa.\n                                    (\\<forall>x1.\n  xa = Inl x1 \\<longrightarrow> E x1) \\<and>\n                                    (\\<forall>x2.\n  xa = Inr x2 \\<longrightarrow> I (l1_ @ [x_]) l2_ x2))", "apply (auto simp: ESPEC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>l0 = l1 @ l2;\n        case \\<sigma> of Inl e \\<Rightarrow> E e\n        | Inr \\<sigma> \\<Rightarrow> I l1 l2 \\<sigma>;\n        \\<not> (case \\<sigma> of Inl e \\<Rightarrow> False\n                | Inr x \\<Rightarrow> c x)\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>case \\<sigma> of Inl e \\<Rightarrow> E e\n                | Inr \\<sigma> \\<Rightarrow> I l0 [] \\<sigma>;\n        case \\<sigma> of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l0 = l1_ @ l2_;\n     case \\<sigma>_ of Inl e \\<Rightarrow> E e\n     | Inr \\<sigma> \\<Rightarrow> I l1_ l2_ \\<sigma>;\n     \\<not> (case \\<sigma>_ of Inl e \\<Rightarrow> False\n             | Inr x \\<Rightarrow> c x)\\<rbrakk>\n    \\<Longrightarrow> case \\<sigma>_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> P r", "using FNC"], ["proof (prove)\nusing this:\n  \\<lbrakk>l0 = ?l1.0 @ ?l2.0; I ?l1.0 ?l2.0 ?\\<sigma>;\n   \\<not> c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l0 = l1_ @ l2_;\n     case \\<sigma>_ of Inl e \\<Rightarrow> E e\n     | Inr \\<sigma> \\<Rightarrow> I l1_ l2_ \\<sigma>;\n     \\<not> (case \\<sigma>_ of Inl e \\<Rightarrow> False\n             | Inr x \\<Rightarrow> c x)\\<rbrakk>\n    \\<Longrightarrow> case \\<sigma>_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> P r", "by (auto split: sum.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>case \\<sigma> of Inl e \\<Rightarrow> E e\n                | Inr \\<sigma> \\<Rightarrow> I l0 [] \\<sigma>;\n        case \\<sigma> of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of Inl e \\<Rightarrow> E e\n                         | Inr r \\<Rightarrow> P r", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case \\<sigma>_ of Inl e \\<Rightarrow> E e\n             | Inr \\<sigma> \\<Rightarrow> I l0 [] \\<sigma>;\n     case \\<sigma>_ of Inl e \\<Rightarrow> False\n     | Inr x \\<Rightarrow> c x\\<rbrakk>\n    \\<Longrightarrow> case \\<sigma>_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> P r", "using FC"], ["proof (prove)\nusing this:\n  \\<lbrakk>I l0 [] ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case \\<sigma>_ of Inl e \\<Rightarrow> E e\n             | Inr \\<sigma> \\<Rightarrow> I l0 [] \\<sigma>;\n     case \\<sigma>_ of Inl e \\<Rightarrow> False\n     | Inr x \\<Rightarrow> c x\\<rbrakk>\n    \\<Longrightarrow> case \\<sigma>_ of Inl e \\<Rightarrow> E e\n                      | Inr r \\<Rightarrow> P r", "by (auto split: sum.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Data Refinement\\<close>"], ["", "lemma sum_rel_conv:\n  \"(Inl l, s') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>l'. s'=Inl l' \\<and> (l,l')\\<in>L)\"\n  \"(Inr r, s') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>r'. s'=Inr r' \\<and> (r,r')\\<in>R)\"\n  \"(s, Inl l') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>l. s=Inl l \\<and> (l,l')\\<in>L)\"\n  \"(s, Inr r') \\<in> \\<langle>L,R\\<rangle>sum_rel \\<longleftrightarrow> (\\<exists>r. s=Inr r \\<and> (r,r')\\<in>R)\"\n  \"(\\<forall>l. s \\<noteq> Inl l) \\<longleftrightarrow> (\\<exists>r. s=Inr r)\"\n  \"(\\<forall>r. s \\<noteq> Inr r) \\<longleftrightarrow> (\\<exists>l. s=Inl l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((Inl l, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n     (\\<exists>l'. s' = Inl l' \\<and> (l, l') \\<in> L) &&&\n     ((Inr r, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n     (\\<exists>r'. s' = Inr r' \\<and> (r, r') \\<in> R) &&&\n     ((s, Inl l') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n     (\\<exists>l. s = Inl l \\<and> (l, l') \\<in> L)) &&&\n    ((s, Inr r') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r. s = Inr r \\<and> (r, r') \\<in> R) &&&\n    (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r) &&&\n    (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "apply -"], ["proof (prove)\ngoal (6 subgoals):\n 1. ((Inl l, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>l'. s' = Inl l' \\<and> (l, l') \\<in> L)\n 2. ((Inr r, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r'. s' = Inr r' \\<and> (r, r') \\<in> R)\n 3. ((s, Inl l') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>l. s = Inl l \\<and> (l, l') \\<in> L)\n 4. ((s, Inr r') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r. s = Inr r \\<and> (r, r') \\<in> R)\n 5. (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r)\n 6. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Inl l, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>l'. s' = Inl l' \\<and> (l, l') \\<in> L)", "by (cases s'; auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ((Inr r, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r'. s' = Inr r' \\<and> (r, r') \\<in> R)\n 2. ((s, Inl l') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>l. s = Inl l \\<and> (l, l') \\<in> L)\n 3. ((s, Inr r') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r. s = Inr r \\<and> (r, r') \\<in> R)\n 4. (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r)\n 5. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Inr r, s') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r'. s' = Inr r' \\<and> (r, r') \\<in> R)", "by (cases s'; auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((s, Inl l') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>l. s = Inl l \\<and> (l, l') \\<in> L)\n 2. ((s, Inr r') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r. s = Inr r \\<and> (r, r') \\<in> R)\n 3. (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r)\n 4. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, Inl l') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>l. s = Inl l \\<and> (l, l') \\<in> L)", "by (cases s; auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((s, Inr r') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r. s = Inr r \\<and> (r, r') \\<in> R)\n 2. (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r)\n 3. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, Inr r') \\<in> \\<langle>L, R\\<rangle>sum_rel) =\n    (\\<exists>r. s = Inr r \\<and> (r, r') \\<in> R)", "by (cases s; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r)\n 2. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l. s \\<noteq> Inl l) = (\\<exists>r. s = Inr r)", "by (cases s; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r. s \\<noteq> Inr r) = (\\<exists>l. s = Inl l)", "by (cases s; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition econc_fun (\"\\<Down>\\<^sub>E\") where [enres_unfolds]: \"econc_fun E R \\<equiv> \\<Down>(\\<langle>E,R\\<rangle>sum_rel)\""], ["", "lemma RELATES_pat_erefine[refine_dref_pattern]: \"\\<lbrakk>RELATES R; mi \\<le>\\<Down>\\<^sub>E E R m \\<rbrakk> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RELATES R; mi \\<le> \\<Down>\\<^sub>E E R m\\<rbrakk>\n    \\<Longrightarrow> mi \\<le> \\<Down>\\<^sub>E E R m", "."], ["", "lemma pw_econc_iff[refine_pw_simps]:\n  \"inres (\\<Down>\\<^sub>E E R m) (Inl ei) \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<exists>e. inres m (Inl e) \\<and> (ei,e)\\<in>E))\"\n  \"inres (\\<Down>\\<^sub>E E R m) (Inr xi) \\<longleftrightarrow> (nofail m \\<longrightarrow> (\\<exists>x. inres m (Inr x) \\<and> (xi,x)\\<in>R))\"\n  \"nofail (\\<Down>\\<^sub>E E R m) \\<longleftrightarrow> nofail m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inres (\\<Down>\\<^sub>E E R m) (Inl ei) =\n    (nofail m \\<longrightarrow>\n     (\\<exists>e. inres m (Inl e) \\<and> (ei, e) \\<in> E)) &&&\n    inres (\\<Down>\\<^sub>E E R m) (Inr xi) =\n    (nofail m \\<longrightarrow>\n     (\\<exists>x. inres m (Inr x) \\<and> (xi, x) \\<in> R)) &&&\n    nofail (\\<Down>\\<^sub>E E R m) = nofail m", "by (auto simp: refine_pw_simps econc_fun_def sum_rel_conv)"], ["", "lemma econc_fun_id[simp]: \"\\<Down>\\<^sub>E Id Id = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down>\\<^sub>E Id Id = (\\<lambda>x. x)", "by (auto simp: pw_eeq_iff refine_pw_simps intro!: ext)"], ["", "lemma econc_fun_ESPEC: \"\\<Down>\\<^sub>E E R (ESPEC \\<Phi> \\<Psi>) = ESPEC (\\<lambda>ei. \\<exists>e. (ei,e)\\<in>E \\<and> \\<Phi> e) (\\<lambda>ri. \\<exists>r. (ri,r)\\<in>R \\<and> \\<Psi> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down>\\<^sub>E E R (ESPEC \\<Phi> \\<Psi>) =\n    ESPEC (\\<lambda>ei. \\<exists>e. (ei, e) \\<in> E \\<and> \\<Phi> e)\n     (\\<lambda>ri. \\<exists>r. (ri, r) \\<in> R \\<and> \\<Psi> r)", "by (auto simp: pw_eeq_iff refine_pw_simps)"], ["", "lemma econc_fun_ERETURN: \"\\<Down>\\<^sub>E E R (ERETURN x) = ESPEC (\\<lambda>_. False) (\\<lambda>xi. (xi,x)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down>\\<^sub>E E R (ERETURN x) =\n    ESPEC (\\<lambda>_. False) (\\<lambda>xi. (xi, x) \\<in> R)", "by (auto simp: pw_eeq_iff refine_pw_simps)"], ["", "lemma econc_fun_univ_id[simp]: \"\\<Down>\\<^sub>E UNIV Id (ESPEC \\<Phi> \\<Psi>) = ESPEC (\\<lambda>_. Ex \\<Phi>) \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down>\\<^sub>E UNIV Id (ESPEC \\<Phi> \\<Psi>) =\n    ESPEC (\\<lambda>_. Ex \\<Phi>) \\<Psi>", "by (auto simp: pw_eeq_iff refine_pw_simps)"], ["", "lemma erefine_same_sup_Id[simp]: \"\\<lbrakk> Id\\<subseteq>E; Id\\<subseteq>R \\<rbrakk> \\<Longrightarrow> m \\<le>\\<Down>\\<^sub>E E R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Id \\<subseteq> E; Id \\<subseteq> R\\<rbrakk>\n    \\<Longrightarrow> m \\<le> \\<Down>\\<^sub>E E R m", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma econc_mono3: \"m\\<le>m' \\<Longrightarrow> \\<Down>\\<^sub>E E R m \\<le> \\<Down>\\<^sub>E E R m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m' \\<Longrightarrow>\n    \\<Down>\\<^sub>E E R m \\<le> \\<Down>\\<^sub>E E R m'", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "(* Order of these two is important! *)"], ["", "lemma econc_x_trans[trans]: \n  \"x \\<le> \\<Down>\\<^sub>E E R y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> \\<Down>\\<^sub>E E R z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> \\<Down>\\<^sub>E E R y; y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> \\<Down>\\<^sub>E E R z", "by (force simp: pw_ele_iff refine_pw_simps)"], ["", "lemma econc_econc_trans[trans]: \n  \"x \\<le>\\<Down>\\<^sub>E E1 R1 y \\<Longrightarrow> y \\<le> \\<Down>\\<^sub>E E2 R2 z \\<Longrightarrow> x \\<le> \\<Down>\\<^sub>E (E1 O E2) (R1 O R2) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> \\<Down>\\<^sub>E E1 R1 y;\n     y \\<le> \\<Down>\\<^sub>E E2 R2 z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> \\<Down>\\<^sub>E (E1 O E2) (R1 O R2) z", "by (force simp: pw_ele_iff refine_pw_simps)"], ["", "lemma ERETURN_refine[refine]: \n  assumes \"(xi,x)\\<in>R\"\n  shows \"ERETURN xi \\<le> \\<Down>\\<^sub>EE R (ERETURN x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ERETURN xi \\<le> \\<Down>\\<^sub>E E R (ERETURN x)", "using assms"], ["proof (prove)\nusing this:\n  (xi, x) \\<in> R\n\ngoal (1 subgoal):\n 1. ERETURN xi \\<le> \\<Down>\\<^sub>E E R (ERETURN x)", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma EASSERT_bind_refine_right:\n  assumes \"\\<Phi> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"mi \\<le>\\<Down>\\<^sub>E E R (doE {EASSERT \\<Phi>; m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mi \\<le> \\<Down>\\<^sub>E E R (ebind (EASSERT \\<Phi>) (\\<lambda>_. m))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> mi \\<le> \\<Down>\\<^sub>E E R m\n\ngoal (1 subgoal):\n 1. mi \\<le> \\<Down>\\<^sub>E E R (ebind (EASSERT \\<Phi>) (\\<lambda>_. m))", "by (simp add: pw_ele_iff refine_pw_simps)"], ["", "lemma EASSERT_bind_refine_left:\n  assumes \"\\<Phi>\"\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"(doE {EASSERT \\<Phi>; mi}) \\<le>\\<Down>\\<^sub>E E R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (EASSERT \\<Phi>) (\\<lambda>_. mi) \\<le> \\<Down>\\<^sub>E E R m", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>\n  mi \\<le> \\<Down>\\<^sub>E E R m\n\ngoal (1 subgoal):\n 1. ebind (EASSERT \\<Phi>) (\\<lambda>_. mi) \\<le> \\<Down>\\<^sub>E E R m", "by simp"], ["", "lemma EASSUME_bind_refine_right:\n  assumes \"\\<Phi>\"\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"mi \\<le>\\<Down>\\<^sub>E E R (doE {EASSUME \\<Phi>; m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mi \\<le> \\<Down>\\<^sub>E E R (ebind (EASSUME \\<Phi>) (\\<lambda>_. m))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>\n  mi \\<le> \\<Down>\\<^sub>E E R m\n\ngoal (1 subgoal):\n 1. mi \\<le> \\<Down>\\<^sub>E E R (ebind (EASSUME \\<Phi>) (\\<lambda>_. m))", "by (simp)"], ["", "lemma EASSUME_bind_refine_left:\n  assumes \"\\<Phi> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"(doE {EASSUME \\<Phi>; mi}) \\<le>\\<Down>\\<^sub>E E R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (EASSUME \\<Phi>) (\\<lambda>_. mi) \\<le> \\<Down>\\<^sub>E E R m", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> mi \\<le> \\<Down>\\<^sub>E E R m\n\ngoal (1 subgoal):\n 1. ebind (EASSUME \\<Phi>) (\\<lambda>_. mi) \\<le> \\<Down>\\<^sub>E E R m", "by (simp add: pw_ele_iff refine_pw_simps)"], ["", "lemma ebind_refine:\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R' m\"\n  assumes \"\\<And>xi x. (xi,x)\\<in>R' \\<Longrightarrow> fi xi \\<le>\\<Down>\\<^sub>E E R (f x)\"\n  shows \"doE { xi \\<leftarrow> mi; fi xi } \\<le> \\<Down>\\<^sub>E E R (doE { x \\<leftarrow> m; f x })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind mi fi \\<le> \\<Down>\\<^sub>E E R (ebind m f)", "using assms"], ["proof (prove)\nusing this:\n  mi \\<le> \\<Down>\\<^sub>E E R' m\n  (?xi, ?x) \\<in> R' \\<Longrightarrow>\n  fi ?xi \\<le> \\<Down>\\<^sub>E E R (f ?x)\n\ngoal (1 subgoal):\n 1. ebind mi fi \\<le> \\<Down>\\<^sub>E E R (ebind m f)", "by (simp add: pw_ele_iff refine_pw_simps) blast"], ["", "text \\<open>Order of this lemmas matters!\\<close>"], ["", "lemmas [refine] = \n  ebind_refine\n  EASSERT_bind_refine_left EASSUME_bind_refine_right\n  EASSUME_bind_refine_left EASSERT_bind_refine_right"], ["", "thm refine(1-10)"], ["", "lemma ebind_refine':\n  assumes \"mi \\<le>\\<Down>\\<^sub>E E R' m\"\n  assumes \"\\<And>xi x. \\<lbrakk>(xi,x)\\<in>R'; inres mi (Inr xi); inres m (Inr x); nofail mi; nofail m\\<rbrakk> \\<Longrightarrow> fi xi \\<le>\\<Down>\\<^sub>E E R (f x)\"\n  shows \"doE { xi \\<leftarrow> mi; fi xi } \\<le> \\<Down>\\<^sub>E E R (doE { x \\<leftarrow> m; f x })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind mi fi \\<le> \\<Down>\\<^sub>E E R (ebind m f)", "using assms"], ["proof (prove)\nusing this:\n  mi \\<le> \\<Down>\\<^sub>E E R' m\n  \\<lbrakk>(?xi, ?x) \\<in> R'; inres mi (Inr ?xi); inres m (Inr ?x);\n   nofail mi; nofail m\\<rbrakk>\n  \\<Longrightarrow> fi ?xi \\<le> \\<Down>\\<^sub>E E R (f ?x)\n\ngoal (1 subgoal):\n 1. ebind mi fi \\<le> \\<Down>\\<^sub>E E R (ebind m f)", "by (simp add: pw_ele_iff refine_pw_simps) blast"], ["", "lemma THROW_refine[refine]: \"(ei,e)\\<in>E \\<Longrightarrow> THROW ei \\<le>\\<Down>\\<^sub>E E R (THROW e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ei, e) \\<in> E \\<Longrightarrow>\n    THROW ei \\<le> \\<Down>\\<^sub>E E R (THROW e)", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma CATCH_refine':\n  assumes \"mi \\<le> \\<Down>\\<^sub>E E' R m\"\n  assumes \"\\<And>ei e. \\<lbrakk> (ei,e)\\<in>E'; inres mi (Inl ei); inres m (Inl e); nofail mi; nofail m \\<rbrakk> \\<Longrightarrow> hi ei \\<le>\\<Down>\\<^sub>E E R (h e)\"\n  shows \"CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)", "using assms"], ["proof (prove)\nusing this:\n  mi \\<le> \\<Down>\\<^sub>E E' R m\n  \\<lbrakk>(?ei, ?e) \\<in> E'; inres mi (Inl ?ei); inres m (Inl ?e);\n   nofail mi; nofail m\\<rbrakk>\n  \\<Longrightarrow> hi ?ei \\<le> \\<Down>\\<^sub>E E R (h ?e)\n\ngoal (1 subgoal):\n 1. CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)", "by (simp add: pw_ele_iff refine_pw_simps) blast"], ["", "lemma CATCH_refine[refine]:\n  assumes \"mi \\<le> \\<Down>\\<^sub>E E' R m\"\n  assumes \"\\<And>ei e. \\<lbrakk> (ei,e)\\<in>E' \\<rbrakk> \\<Longrightarrow> hi ei \\<le>\\<Down>\\<^sub>E E R (h e)\"\n  shows \"CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)", "using assms CATCH_refine'"], ["proof (prove)\nusing this:\n  mi \\<le> \\<Down>\\<^sub>E E' R m\n  (?ei, ?e) \\<in> E' \\<Longrightarrow>\n  hi ?ei \\<le> \\<Down>\\<^sub>E E R (h ?e)\n  \\<lbrakk>?mi \\<le> \\<Down>\\<^sub>E ?E' ?R ?m;\n   \\<And>ei e.\n      \\<lbrakk>(ei, e) \\<in> ?E'; inres ?mi (Inl ei); inres ?m (Inl e);\n       nofail ?mi; nofail ?m\\<rbrakk>\n      \\<Longrightarrow> ?hi ei \\<le> \\<Down>\\<^sub>E ?E ?R (?h e)\\<rbrakk>\n  \\<Longrightarrow> CATCH ?mi ?hi \\<le> \\<Down>\\<^sub>E ?E ?R (CATCH ?m ?h)\n\ngoal (1 subgoal):\n 1. CATCH mi hi \\<le> \\<Down>\\<^sub>E E R (CATCH m h)", "by metis"], ["", "lemma CHECK_refine[refine]: \n  assumes \"\\<Phi>i \\<longleftrightarrow> \\<Phi>\"\n  assumes \"\\<not>\\<Phi> \\<Longrightarrow> (msgi,msg)\\<in>E\"\n  shows \"CHECK \\<Phi>i msgi \\<le>\\<Down>\\<^sub>E E Id (CHECK \\<Phi> msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK \\<Phi>i msgi \\<le> \\<Down>\\<^sub>E E unit_rel (CHECK \\<Phi> msg)", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>i = \\<Phi>\n  \\<not> \\<Phi> \\<Longrightarrow> (msgi, msg) \\<in> E\n\ngoal (1 subgoal):\n 1. CHECK \\<Phi>i msgi \\<le> \\<Down>\\<^sub>E E unit_rel (CHECK \\<Phi> msg)", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "text \\<open>This must be declared after @{thm CHECK_refine}!\\<close>"], ["", "lemma CHECK_bind_refine[refine]: \n  assumes \"\\<Phi>i \\<longleftrightarrow> \\<Phi>\"\n  assumes \"\\<not>\\<Phi> \\<Longrightarrow> (msgi,msg)\\<in>E\"\n  assumes \"\\<Phi> \\<Longrightarrow> mi \\<le>\\<Down>\\<^sub>E E R m\"\n  shows \"doE {CHECK \\<Phi>i msgi;mi} \\<le>\\<Down>\\<^sub>E E R (doE {CHECK \\<Phi> msg; m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (CHECK \\<Phi>i msgi) (\\<lambda>_. mi)\n    \\<le> \\<Down>\\<^sub>E E R (ebind (CHECK \\<Phi> msg) (\\<lambda>_. m))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi>i = \\<Phi>\n  \\<not> \\<Phi> \\<Longrightarrow> (msgi, msg) \\<in> E\n  \\<Phi> \\<Longrightarrow> mi \\<le> \\<Down>\\<^sub>E E R m\n\ngoal (1 subgoal):\n 1. ebind (CHECK \\<Phi>i msgi) (\\<lambda>_. mi)\n    \\<le> \\<Down>\\<^sub>E E R (ebind (CHECK \\<Phi> msg) (\\<lambda>_. m))", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma Let_unfold_refine[refine]:\n  assumes \"f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>\\<^sub>E E R (Let x' f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down>\\<^sub>E E R (Let x' f')", "using assms"], ["proof (prove)\nusing this:\n  f x \\<le> \\<Down>\\<^sub>E E R (f' x')\n\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down>\\<^sub>E E R (Let x' f')", "by auto"], ["", "lemma Let_refine:\n  assumes \"(m,m')\\<in>R'\"\n  assumes \"\\<And>x x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"Let m (\\<lambda>x. f x) \\<le>\\<Down>\\<^sub>E E R (Let m' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let m f \\<le> \\<Down>\\<^sub>E E R (Let m' f')", "using assms"], ["proof (prove)\nusing this:\n  (m, m') \\<in> R'\n  (?x, ?x') \\<in> R' \\<Longrightarrow>\n  f ?x \\<le> \\<Down>\\<^sub>E E R (f' ?x')\n\ngoal (1 subgoal):\n 1. Let m f \\<le> \\<Down>\\<^sub>E E R (Let m' f')", "by auto"], ["", "lemma eif_refine[refine]:\n  assumes \"(b,b')\\<in>bool_rel\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> S1 \\<le> \\<Down>\\<^sub>E E R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> S2 \\<le> \\<Down>\\<^sub>E E R S2'\"\n  shows \"(if b then S1 else S2) \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then S1 else S2)\n    \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')", "using assms"], ["proof (prove)\nusing this:\n  (b, b') \\<in> bool_rel\n  \\<lbrakk>b; b'\\<rbrakk> \\<Longrightarrow> S1 \\<le> \\<Down>\\<^sub>E E R S1'\n  \\<lbrakk>\\<not> b; \\<not> b'\\<rbrakk>\n  \\<Longrightarrow> S2 \\<le> \\<Down>\\<^sub>E E R S2'\n\ngoal (1 subgoal):\n 1. (if b then S1 else S2)\n    \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')", "by auto"], ["", "(* TODO: Also add enfoldli_invar_refine *)"], ["", "lemma enfoldli_refine[refine]:\n  assumes \"(li, l) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and \"(si, s) \\<in> R\"\n    and CR: \"(ci, c) \\<in> R \\<rightarrow> bool_rel\"\n    and FR: \"\\<And>xi x si s. \\<lbrakk> (xi,x)\\<in>S; (si,s)\\<in>R; c s \\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>\\<^sub>E E R (f x s)\"\n  shows \"enfoldli li ci fi si \\<le> \\<Down>\\<^sub>E E R (enfoldli l c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enfoldli li ci fi si \\<le> \\<Down>\\<^sub>E E R (enfoldli l c f s)", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli li\n     (\\<lambda>xa.\n         case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> ci x)\n     (\\<lambda>x s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) (fi x)))\n     (Inr si)\n    \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n           (nfoldli l\n             (\\<lambda>xa.\n                 case xa of Inl e \\<Rightarrow> False\n                 | Inr x \\<Rightarrow> c x)\n             (\\<lambda>x s.\n                 ASSERT (\\<not> isl s) \\<bind>\n                 (\\<lambda>_. Let (projr s) (f x)))\n             (Inr s))", "apply (rule nfoldli_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (li, l) \\<in> \\<langle>?S\\<rangle>list_rel\n 2. (Inr si, Inr s) \\<in> \\<langle>E, R\\<rangle>sum_rel\n 3. (\\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> ci x,\n     \\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n    \\<in> \\<langle>E, R\\<rangle>sum_rel \\<rightarrow> bool_rel\n 4. \\<And>xi x si s.\n       \\<lbrakk>(xi, x) \\<in> ?S;\n        (si, s) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case s of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl si) \\<bind>\n                         (\\<lambda>_. Let (projr si) (fi xi))\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (ASSERT (\\<not> isl s) \\<bind>\n                                 (\\<lambda>_. Let (projr s) (f x)))", "apply (rule assms(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. (Inr si, Inr s) \\<in> \\<langle>E, R\\<rangle>sum_rel\n 2. (\\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> ci x,\n     \\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n    \\<in> \\<langle>E, R\\<rangle>sum_rel \\<rightarrow> bool_rel\n 3. \\<And>xi x si s.\n       \\<lbrakk>(xi, x) \\<in> S;\n        (si, s) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case s of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl si) \\<bind>\n                         (\\<lambda>_. Let (projr si) (fi xi))\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (ASSERT (\\<not> isl s) \\<bind>\n                                 (\\<lambda>_. Let (projr s) (f x)))", "apply (simp add: assms(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> ci x,\n     \\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n    \\<in> \\<langle>E, R\\<rangle>sum_rel \\<rightarrow> bool_rel\n 2. \\<And>xi x si s.\n       \\<lbrakk>(xi, x) \\<in> S;\n        (si, s) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case s of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl si) \\<bind>\n                         (\\<lambda>_. Let (projr si) (fi xi))\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (ASSERT (\\<not> isl s) \\<bind>\n                                 (\\<lambda>_. Let (projr s) (f x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> ci x,\n     \\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n    \\<in> \\<langle>E, R\\<rangle>sum_rel \\<rightarrow> bool_rel", "using CR[param_fo]"], ["proof (prove)\nusing this:\n  (?x, ?x') \\<in> R \\<Longrightarrow> (ci ?x, c ?x') \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (\\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> ci x,\n     \\<lambda>xa.\n        case xa of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x)\n    \\<in> \\<langle>E, R\\<rangle>sum_rel \\<rightarrow> bool_rel", "by (auto split: sum.split simp: sum_rel_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xi x si s.\n       \\<lbrakk>(xi, x) \\<in> S;\n        (si, s) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case s of Inl e \\<Rightarrow> False\n        | Inr x \\<Rightarrow> c x\\<rbrakk>\n       \\<Longrightarrow> ASSERT (\\<not> isl si) \\<bind>\n                         (\\<lambda>_. Let (projr si) (fi xi))\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (ASSERT (\\<not> isl s) \\<bind>\n                                 (\\<lambda>_. Let (projr s) (f x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x\\<rbrakk>\n    \\<Longrightarrow> ASSERT (\\<not> isl si_) \\<bind>\n                      (\\<lambda>_. Let (projr si_) (fi xi_))\n                      \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                             (ASSERT (\\<not> isl s_) \\<bind>\n                              (\\<lambda>_. Let (projr s_) (f x_)))", "apply refine_rcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x;\n     \\<not> isl s_\\<rbrakk>\n    \\<Longrightarrow> \\<not> isl si_\n 2. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x;\n     \\<not> isl s_; \\<not> isl si_\\<rbrakk>\n    \\<Longrightarrow> fi xi_ (projr si_)\n                      \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                             (f x_ (projr s_))", "applyS (auto split: sum.splits simp: sum_rel_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x;\n     \\<not> isl s_; \\<not> isl si_\\<rbrakk>\n    \\<Longrightarrow> fi xi_ (projr si_)\n                      \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                             (f x_ (projr s_))", "apply (rule FR[unfolded enres_unfolds])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x;\n     \\<not> isl s_; \\<not> isl si_\\<rbrakk>\n    \\<Longrightarrow> (xi_, x_) \\<in> S\n 2. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x;\n     \\<not> isl s_; \\<not> isl si_\\<rbrakk>\n    \\<Longrightarrow> (projr si_, projr s_) \\<in> R\n 3. \\<lbrakk>(xi_, x_) \\<in> S;\n     (si_, s_) \\<in> \\<langle>E, R\\<rangle>sum_rel;\n     case s_ of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> c x;\n     \\<not> isl s_; \\<not> isl si_\\<rbrakk>\n    \\<Longrightarrow> c (projr s_)", "by (auto split: sum.splits simp: sum_rel_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma EWHILET_refine[refine]:\n  assumes R0: \"(x,x')\\<in>R\"\n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"EWHILET b f x \\<le>\\<Down>\\<^sub>E E R (EWHILET b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILET b f x \\<le> \\<Down>\\<^sub>E E R (EWHILET b' f' x')", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl x \\<Rightarrow> True\n                            | _ \\<Rightarrow> True\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr x)\n    \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n           (WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                                    case x of Inl x \\<Rightarrow> True\n                                    | _ \\<Rightarrow> True\\<^esup>\n             (\\<lambda>x.\n                 case x of Inl x \\<Rightarrow> False\n                 | Inr s \\<Rightarrow> b' s)\n             (\\<lambda>s.\n                 ASSERT (\\<not> isl s) \\<bind>\n                 (\\<lambda>_. Let (projr s) f'))\n             (Inr x'))", "apply refine_rcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. case Inr x' of Inl x \\<Rightarrow> True\n    | _ \\<Rightarrow> True \\<Longrightarrow>\n    (Inr x, Inr x') \\<in> \\<langle>E, R\\<rangle>sum_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True\\<rbrakk>\n       \\<Longrightarrow> case x of Inl x \\<Rightarrow> True\n                         | _ \\<Rightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True\\<rbrakk>\n       \\<Longrightarrow> (case x of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b s) =\n                         (case x' of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b' s)\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        \\<not> isl x'\\<rbrakk>\n       \\<Longrightarrow> \\<not> isl x\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        \\<not> isl x'; \\<not> isl x\\<rbrakk>\n       \\<Longrightarrow> f (projr x)\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (f' (projr x'))", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> R\n  (?x, ?x') \\<in> R \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down>\\<^sub>E E R (f' ?x')\n\ngoal (5 subgoals):\n 1. case Inr x' of Inl x \\<Rightarrow> True\n    | _ \\<Rightarrow> True \\<Longrightarrow>\n    (Inr x, Inr x') \\<in> \\<langle>E, R\\<rangle>sum_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True\\<rbrakk>\n       \\<Longrightarrow> case x of Inl x \\<Rightarrow> True\n                         | _ \\<Rightarrow> True\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True\\<rbrakk>\n       \\<Longrightarrow> (case x of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b s) =\n                         (case x' of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b' s)\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        \\<not> isl x'\\<rbrakk>\n       \\<Longrightarrow> \\<not> isl x\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        case x' of Inl x \\<Rightarrow> True | _ \\<Rightarrow> True;\n        \\<not> isl x'; \\<not> isl x\\<rbrakk>\n       \\<Longrightarrow> f (projr x)\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (f' (projr x'))", "by (auto split: sum.splits simp: econc_fun_def)"], ["", "thm WHILEIT_refine"], ["", "lemma EWHILEIT_refine[refine]:\n  assumes R0: \"I' x' \\<Longrightarrow> (x,x')\\<in>R\"\n  assumes I_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I' x' \\<rbrakk> \\<Longrightarrow> I x\"  \n  assumes COND_REF: \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; I x; I' x' \\<rbrakk> \\<Longrightarrow> b x = b' x'\"\n  assumes STEP_REF: \n    \"\\<And>x x'. \\<lbrakk> (x,x')\\<in>R; b x; b' x'; I x; I' x' \\<rbrakk> \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"EWHILEIT I b f x \\<le>\\<Down>\\<^sub>E E R (EWHILEIT I' b' f' x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I b f x \\<le> \\<Down>\\<^sub>E E R (EWHILEIT I' b' f' x')", "unfolding enres_unfolds"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                            case x of Inl x \\<Rightarrow> True\n                            | Inr s \\<Rightarrow> I s\\<^esup>\n     (\\<lambda>x.\n         case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s)\n     (\\<lambda>s.\n         ASSERT (\\<not> isl s) \\<bind> (\\<lambda>_. Let (projr s) f))\n     (Inr x)\n    \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n           (WHILE\\<^sub>T\\<^bsup>\\<lambda>x.\n                                    case x of Inl x \\<Rightarrow> True\n                                    | Inr s \\<Rightarrow> I' s\\<^esup>\n             (\\<lambda>x.\n                 case x of Inl x \\<Rightarrow> False\n                 | Inr s \\<Rightarrow> b' s)\n             (\\<lambda>s.\n                 ASSERT (\\<not> isl s) \\<bind>\n                 (\\<lambda>_. Let (projr s) f'))\n             (Inr x'))", "apply refine_rcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. case Inr x' of Inl x \\<Rightarrow> True\n    | Inr s \\<Rightarrow> I' s \\<Longrightarrow>\n    (Inr x, Inr x') \\<in> \\<langle>E, R\\<rangle>sum_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x' of Inl x \\<Rightarrow> True\n        | Inr s \\<Rightarrow> I' s\\<rbrakk>\n       \\<Longrightarrow> case x of Inl x \\<Rightarrow> True\n                         | Inr s \\<Rightarrow> I s\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s;\n        case x' of Inl x \\<Rightarrow> True\n        | Inr s \\<Rightarrow> I' s\\<rbrakk>\n       \\<Longrightarrow> (case x of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b s) =\n                         (case x' of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b' s)\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s;\n        case x' of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I' s;\n        \\<not> isl x'\\<rbrakk>\n       \\<Longrightarrow> \\<not> isl x\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s;\n        case x' of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I' s;\n        \\<not> isl x'; \\<not> isl x\\<rbrakk>\n       \\<Longrightarrow> f (projr x)\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (f' (projr x'))", "using assms"], ["proof (prove)\nusing this:\n  I' x' \\<Longrightarrow> (x, x') \\<in> R\n  \\<lbrakk>(?x, ?x') \\<in> R; I' ?x'\\<rbrakk> \\<Longrightarrow> I ?x\n  \\<lbrakk>(?x, ?x') \\<in> R; I ?x; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> b ?x = b' ?x'\n  \\<lbrakk>(?x, ?x') \\<in> R; b ?x; b' ?x'; I ?x; I' ?x'\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> \\<Down>\\<^sub>E E R (f' ?x')\n\ngoal (5 subgoals):\n 1. case Inr x' of Inl x \\<Rightarrow> True\n    | Inr s \\<Rightarrow> I' s \\<Longrightarrow>\n    (Inr x, Inr x') \\<in> \\<langle>E, R\\<rangle>sum_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x' of Inl x \\<Rightarrow> True\n        | Inr s \\<Rightarrow> I' s\\<rbrakk>\n       \\<Longrightarrow> case x of Inl x \\<Rightarrow> True\n                         | Inr s \\<Rightarrow> I s\n 3. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s;\n        case x' of Inl x \\<Rightarrow> True\n        | Inr s \\<Rightarrow> I' s\\<rbrakk>\n       \\<Longrightarrow> (case x of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b s) =\n                         (case x' of Inl x \\<Rightarrow> False\n                          | Inr s \\<Rightarrow> b' s)\n 4. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s;\n        case x' of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I' s;\n        \\<not> isl x'\\<rbrakk>\n       \\<Longrightarrow> \\<not> isl x\n 5. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> \\<langle>E, R\\<rangle>sum_rel;\n        case x of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b s;\n        case x' of Inl x \\<Rightarrow> False | Inr s \\<Rightarrow> b' s;\n        case x of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I s;\n        case x' of Inl x \\<Rightarrow> True | Inr s \\<Rightarrow> I' s;\n        \\<not> isl x'; \\<not> isl x\\<rbrakk>\n       \\<Longrightarrow> f (projr x)\n                         \\<le> \\<Down> (\\<langle>E, R\\<rangle>sum_rel)\n                                (f' (projr x'))", "by (auto split: sum.splits simp: econc_fun_def)"], ["", "subsubsection \\<open>Refine2- heuristics\\<close>"], ["", "lemma remove_eLet_refine:\n  assumes \"M \\<le> \\<Down>\\<^sub>E E R (f x)\"\n  shows \"M \\<le> \\<Down>\\<^sub>E E R (Let x f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down>\\<^sub>E E R (Let x f)", "using assms"], ["proof (prove)\nusing this:\n  M \\<le> \\<Down>\\<^sub>E E R (f x)\n\ngoal (1 subgoal):\n 1. M \\<le> \\<Down>\\<^sub>E E R (Let x f)", "by auto"], ["", "lemma intro_eLet_refine:\n  assumes \"f x \\<le> \\<Down>\\<^sub>E E R M'\"\n  shows \"Let x f \\<le> \\<Down>\\<^sub>E E R M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down>\\<^sub>E E R M'", "using assms"], ["proof (prove)\nusing this:\n  f x \\<le> \\<Down>\\<^sub>E E R M'\n\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down>\\<^sub>E E R M'", "by auto"], ["", "lemma ebind2let_refine[refine2]:\n  assumes \"ERETURN x \\<le> \\<Down>\\<^sub>E E R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"Let x f \\<le> \\<Down>\\<^sub>E E R (ebind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down>\\<^sub>E E R (ebind M' f')", "using assms"], ["proof (prove)\nusing this:\n  ERETURN x \\<le> \\<Down>\\<^sub>E E R' M'\n  (x, ?x') \\<in> R' \\<Longrightarrow> f x \\<le> \\<Down>\\<^sub>E E R (f' ?x')\n\ngoal (1 subgoal):\n 1. Let x f \\<le> \\<Down>\\<^sub>E E R (ebind M' f')", "apply (simp add: pw_ele_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail M' \\<longrightarrow>\n             (\\<exists>xa. inres M' (Inr xa) \\<and> (x, xa) \\<in> R');\n     \\<And>x'.\n        (x, x') \\<in> R' \\<Longrightarrow>\n        nofail (f' x') \\<longrightarrow>\n        nofail (f x) \\<and>\n        (\\<forall>e.\n            inres (f x) (Inl e) \\<longrightarrow>\n            (\\<exists>ea.\n                inres (f' x') (Inl ea) \\<and> (e, ea) \\<in> E)) \\<and>\n        (\\<forall>xa.\n            inres (f x) (Inr xa) \\<longrightarrow>\n            (\\<exists>x.\n                inres (f' x') (Inr x) \\<and> (xa, x) \\<in> R))\\<rbrakk>\n    \\<Longrightarrow> nofail M' \\<and>\n                      (\\<forall>x.\n                          inres M' (Inr x) \\<longrightarrow>\n                          nofail (f' x)) \\<longrightarrow>\n                      nofail (f x) \\<and>\n                      (\\<forall>e.\n                          inres (f x) (Inl e) \\<longrightarrow>\n                          (\\<exists>ea.\n                              (inres M' (Inl ea) \\<or>\n                               (\\<exists>x.\n                                   inres M' (Inr x) \\<and>\n                                   inres (f' x) (Inl ea))) \\<and>\n                              (e, ea) \\<in> E)) \\<and>\n                      (\\<forall>xa.\n                          inres (f x) (Inr xa) \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>y.\n                                  inres M' (Inr y) \\<and>\n                                  inres (f' y) (Inr x)) \\<and>\n                              (xa, x) \\<in> R))", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ebind_Let_refine2[refine2]: \"\\<lbrakk> \n    m' \\<le>\\<Down>\\<^sub>E E R' (ERETURN x);\n    \\<And>x'. \\<lbrakk>inres m' (Inr x'); (x',x)\\<in>R'\\<rbrakk> \\<Longrightarrow> f' x' \\<le> \\<Down>\\<^sub>E E R (f x) \n  \\<rbrakk> \\<Longrightarrow> ebind m' (\\<lambda>x'. f' x') \\<le> \\<Down>\\<^sub>E E R (Let x (\\<lambda>x. f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<le> \\<Down>\\<^sub>E E R' (ERETURN x);\n     \\<And>x'.\n        \\<lbrakk>inres m' (Inr x'); (x', x) \\<in> R'\\<rbrakk>\n        \\<Longrightarrow> f' x' \\<le> \\<Down>\\<^sub>E E R (f x)\\<rbrakk>\n    \\<Longrightarrow> ebind m' f' \\<le> \\<Down>\\<^sub>E E R (Let x f)", "apply (simp add: pw_ele_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m' \\<and>\n             (\\<forall>e. \\<not> inres m' (Inl e)) \\<and>\n             (\\<forall>xa.\n                 inres m' (Inr xa) \\<longrightarrow> (xa, x) \\<in> R');\n     \\<And>x'.\n        inres m' (Inr x') \\<Longrightarrow>\n        nofail (f x) \\<longrightarrow>\n        nofail (f' x') \\<and>\n        (\\<forall>e.\n            inres (f' x') (Inl e) \\<longrightarrow>\n            (\\<exists>ea.\n                inres (f x) (Inl ea) \\<and> (e, ea) \\<in> E)) \\<and>\n        (\\<forall>xa.\n            inres (f' x') (Inr xa) \\<longrightarrow>\n            (\\<exists>xb.\n                inres (f x) (Inr xb) \\<and> (xa, xb) \\<in> R))\\<rbrakk>\n    \\<Longrightarrow> nofail (f x) \\<longrightarrow>\n                      (\\<forall>e.\n                          (\\<exists>x.\n                              inres m' (Inr x) \\<and>\n                              inres (f' x) (Inl e)) \\<longrightarrow>\n                          (\\<exists>ea.\n                              inres (f x) (Inl ea) \\<and>\n                              (e, ea) \\<in> E)) \\<and>\n                      (\\<forall>xa.\n                          (\\<exists>y.\n                              inres m' (Inr y) \\<and>\n                              inres (f' y) (Inr xa)) \\<longrightarrow>\n                          (\\<exists>xb.\n                              inres (f x) (Inr xb) \\<and> (xa, xb) \\<in> R))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ebind2letRETURN_refine[refine2]:\n  assumes \"ERETURN x \\<le> \\<Down>\\<^sub>E E R' M'\"\n  assumes \"\\<And>x'. (x,x')\\<in>R' \\<Longrightarrow> ERETURN (f x) \\<le> \\<Down>\\<^sub>E E R (f' x')\"\n  shows \"ERETURN (Let x f) \\<le> \\<Down>\\<^sub>E E R (ebind M' (\\<lambda>x'. f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ERETURN (Let x f) \\<le> \\<Down>\\<^sub>E E R (ebind M' f')", "using assms"], ["proof (prove)\nusing this:\n  ERETURN x \\<le> \\<Down>\\<^sub>E E R' M'\n  (x, ?x') \\<in> R' \\<Longrightarrow>\n  ERETURN (f x) \\<le> \\<Down>\\<^sub>E E R (f' ?x')\n\ngoal (1 subgoal):\n 1. ERETURN (Let x f) \\<le> \\<Down>\\<^sub>E E R (ebind M' f')", "apply (simp add: pw_ele_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail M' \\<longrightarrow>\n             (\\<exists>xa. inres M' (Inr xa) \\<and> (x, xa) \\<in> R');\n     \\<And>x'.\n        (x, x') \\<in> R' \\<Longrightarrow>\n        nofail (f' x') \\<longrightarrow>\n        (\\<exists>xa.\n            inres (f' x') (Inr xa) \\<and> (f x, xa) \\<in> R)\\<rbrakk>\n    \\<Longrightarrow> nofail M' \\<and>\n                      (\\<forall>x.\n                          inres M' (Inr x) \\<longrightarrow>\n                          nofail (f' x)) \\<longrightarrow>\n                      (\\<exists>xa.\n                          (\\<exists>y.\n                              inres M' (Inr y) \\<and>\n                              inres (f' y) (Inr xa)) \\<and>\n                          (f x, xa) \\<in> R)", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ERETURN_as_SPEC_refine[refine2]:\n  assumes \"RELATES R\"\n  assumes \"M \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>c. (c,a)\\<in>R)\"\n  shows \"M \\<le> \\<Down>\\<^sub>E E R (ERETURN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> \\<Down>\\<^sub>E E R (ERETURN a)", "using assms"], ["proof (prove)\nusing this:\n  RELATES R\n  M \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>c. (c, a) \\<in> R)\n\ngoal (1 subgoal):\n 1. M \\<le> \\<Down>\\<^sub>E E R (ERETURN a)", "by (simp add: pw_ele_iff refine_pw_simps)"], ["", "lemma if_ERETURN_refine[refine2]:\n  assumes \"b \\<longleftrightarrow> b'\"\n  assumes \"\\<lbrakk>b;b'\\<rbrakk> \\<Longrightarrow> ERETURN S1 \\<le> \\<Down>\\<^sub>E E R S1'\"\n  assumes \"\\<lbrakk>\\<not>b;\\<not>b'\\<rbrakk> \\<Longrightarrow> ERETURN S2 \\<le> \\<Down>\\<^sub>E E R S2'\"\n  shows \"ERETURN (if b then S1 else S2) \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ERETURN (if b then S1 else S2)\n    \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')", "(* this is nice to have for small functions, hence keep it in refine2 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ERETURN (if b then S1 else S2)\n    \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')", "using assms"], ["proof (prove)\nusing this:\n  b = b'\n  \\<lbrakk>b; b'\\<rbrakk>\n  \\<Longrightarrow> ERETURN S1 \\<le> \\<Down>\\<^sub>E E R S1'\n  \\<lbrakk>\\<not> b; \\<not> b'\\<rbrakk>\n  \\<Longrightarrow> ERETURN S2 \\<le> \\<Down>\\<^sub>E E R S2'\n\ngoal (1 subgoal):\n 1. ERETURN (if b then S1 else S2)\n    \\<le> \\<Down>\\<^sub>E E R (if b' then S1' else S2')", "by (simp add: pw_le_iff refine_pw_simps)"], ["", "text \\<open>Breaking down enres-monad \\<close>"], ["", "definition enres_lift :: \"'a nres \\<Rightarrow> (_,'a) enres\" where \n  \"enres_lift m \\<equiv> do { x \\<leftarrow> m; RETURN (Inr x) }\""], ["", "lemma enres_lift_rule[refine_vcg]: \"m\\<le>SPEC \\<Phi> \\<Longrightarrow> enres_lift m \\<le> ESPEC E \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> SPEC \\<Phi> \\<Longrightarrow> enres_lift m \\<le> ESPEC E \\<Phi>", "by (auto simp: pw_ele_iff pw_le_iff refine_pw_simps enres_lift_def)"], ["", "named_theorems_rev enres_breakdown"], ["", "lemma [enres_breakdown]:\n  \"ERETURN x = enres_lift (RETURN x)\"  \n  \"EASSERT \\<Phi> = enres_lift (ASSERT \\<Phi>)\"\n  \"doE { x \\<leftarrow> enres_lift m; ef x } = do { x \\<leftarrow> m; ef x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ERETURN x = enres_lift (RETURN x) &&&\n    EASSERT \\<Phi> = enres_lift (ASSERT \\<Phi>) &&&\n    ebind (enres_lift m) ef = m \\<bind> ef", "(*\"NO_MATCH (enres_lift m) em \\<Longrightarrow> doE { x \\<leftarrow> em; ef x } = do { ex \\<leftarrow> em; case ex of Inl e \\<Rightarrow> RETURN (Inl e) | Inr x \\<Rightarrow> ef x }\"*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ERETURN x = enres_lift (RETURN x) &&&\n    EASSERT \\<Phi> = enres_lift (ASSERT \\<Phi>) &&&\n    ebind (enres_lift m) ef = m \\<bind> ef", "unfolding enres_unfolds enres_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (Inr x) = RETURN x \\<bind> (\\<lambda>x. RETURN (Inr x)) &&&\n    (if \\<Phi> then RETURN (Inr ()) else FAIL) =\n    ASSERT \\<Phi> \\<bind> (\\<lambda>x. RETURN (Inr x)) &&&\n    m \\<bind> (\\<lambda>x. RETURN (Inr x)) \\<bind>\n    (\\<lambda>x.\n        case x of Inl e \\<Rightarrow> RETURN (Inl e)\n        | Inr x \\<Rightarrow> ef x) =\n    m \\<bind> ef", "apply (auto split: sum.splits simp: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [enres_breakdown]: \n  \"do { x \\<leftarrow> m; enres_lift (f x) } = enres_lift (do { x \\<leftarrow> m; f x })\"\n  \"do { let x = v; enres_lift (f x) } = enres_lift (do { let x=v; f x })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>x. enres_lift (f x)) = enres_lift (m \\<bind> f) &&&\n    (let x = v in enres_lift (f x)) = enres_lift (Let v f)", "unfolding enres_unfolds enres_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>x. f x \\<bind> (\\<lambda>x. RETURN (Inr x))) =\n    m \\<bind> f \\<bind> (\\<lambda>x. RETURN (Inr x)) &&&\n    (let x = v in f x \\<bind> (\\<lambda>x. RETURN (Inr x))) =\n    Let v f \\<bind> (\\<lambda>x. RETURN (Inr x))", "apply (auto split: sum.splits simp: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [enres_breakdown]:\n  \"CATCH (enres_lift m) h = enres_lift m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CATCH (enres_lift m) h = enres_lift m", "unfolding enres_unfolds enres_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>x. RETURN (Inr x)) \\<bind>\n    (\\<lambda>r.\n        case r of Inl e \\<Rightarrow> h e\n        | Inr r \\<Rightarrow> RETURN (Inr r)) =\n    m \\<bind> (\\<lambda>x. RETURN (Inr x))", "apply (auto split: sum.splits simp: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enres_lift_fail[simp]:  \"enres_lift FAIL = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enres_lift FAIL = FAIL", "unfolding enres_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<bind> (\\<lambda>x. RETURN (Inr x)) = FAIL", "by auto"], ["", "(* TODO: Also do breakdown-thm for RECT. It's exactly the same approach! *)"], ["", "lemma [enres_breakdown]: \"EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s = enres_lift (WHILEIT I c f s)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s =\n    enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s\n    \\<le> enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)\n 2. enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)\n    \\<le> EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s\n    \\<le> enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)", "unfolding enres_unfolds WHILEIT_def WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (WHILEI_body (\\<bind>) RETURN (case_sum (\\<lambda>x. True) I)\n       (case_sum (\\<lambda>x. False) c)\n       (\\<lambda>s.\n           ASSERT (\\<not> isl s) \\<bind>\n           (\\<lambda>_. let s = projr s in enres_lift (f s))))\n     (Inr s)\n    \\<le> enres_lift (REC\\<^sub>T (WHILEI_body (\\<bind>) RETURN I c f) s)", "apply (rule RECT_transfer_rel'[where P=\"\\<lambda>c a. c = Inr a\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. trimono\n     (WHILEI_body (\\<bind>) RETURN (case_sum (\\<lambda>x. True) I)\n       (case_sum (\\<lambda>x. False) c)\n       (\\<lambda>s.\n           ASSERT (\\<not> isl s) \\<bind>\n           (\\<lambda>_. let s = projr s in enres_lift (f s))))\n 2. trimono (WHILEI_body (\\<bind>) RETURN I c f)\n 3. \\<And>x. x \\<le> enres_lift FAIL\n 4. Inr s = Inr s\n 5. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = Inr x' \\<Longrightarrow>\n                   D x \\<le> enres_lift (D' x');\n        x = Inr x'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN\n                          (case_sum (\\<lambda>x. True) I)\n                          (case_sum (\\<lambda>x. False) c)\n                          (\\<lambda>s.\n                              ASSERT (\\<not> isl s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = projr s in enres_lift (f s)))\n                          D x\n                         \\<le> enres_lift\n                                (WHILEI_body (\\<bind>) RETURN I c f D' x')", "apply (simp add: while.WHILEI_body_trimono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. trimono (WHILEI_body (\\<bind>) RETURN I c f)\n 2. \\<And>x. x \\<le> enres_lift FAIL\n 3. Inr s = Inr s\n 4. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = Inr x' \\<Longrightarrow>\n                   D x \\<le> enres_lift (D' x');\n        x = Inr x'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN\n                          (case_sum (\\<lambda>x. True) I)\n                          (case_sum (\\<lambda>x. False) c)\n                          (\\<lambda>s.\n                              ASSERT (\\<not> isl s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = projr s in enres_lift (f s)))\n                          D x\n                         \\<le> enres_lift\n                                (WHILEI_body (\\<bind>) RETURN I c f D' x')", "apply (simp add: while.WHILEI_body_trimono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> enres_lift FAIL\n 2. Inr s = Inr s\n 3. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = Inr x' \\<Longrightarrow>\n                   D x \\<le> enres_lift (D' x');\n        x = Inr x'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN\n                          (case_sum (\\<lambda>x. True) I)\n                          (case_sum (\\<lambda>x. False) c)\n                          (\\<lambda>s.\n                              ASSERT (\\<not> isl s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = projr s in enres_lift (f s)))\n                          D x\n                         \\<le> enres_lift\n                                (WHILEI_body (\\<bind>) RETURN I c f D' x')", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. Inr s = Inr s\n 2. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = Inr x' \\<Longrightarrow>\n                   D x \\<le> enres_lift (D' x');\n        x = Inr x'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN\n                          (case_sum (\\<lambda>x. True) I)\n                          (case_sum (\\<lambda>x. False) c)\n                          (\\<lambda>s.\n                              ASSERT (\\<not> isl s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = projr s in enres_lift (f s)))\n                          D x\n                         \\<le> enres_lift\n                                (WHILEI_body (\\<bind>) RETURN I c f D' x')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x = Inr x' \\<Longrightarrow>\n                   D x \\<le> enres_lift (D' x');\n        x = Inr x'\\<rbrakk>\n       \\<Longrightarrow> WHILEI_body (\\<bind>) RETURN\n                          (case_sum (\\<lambda>x. True) I)\n                          (case_sum (\\<lambda>x. False) c)\n                          (\\<lambda>s.\n                              ASSERT (\\<not> isl s) \\<bind>\n                              (\\<lambda>_.\n                                  let s = projr s in enres_lift (f s)))\n                          D x\n                         \\<le> enres_lift\n                                (WHILEI_body (\\<bind>) RETURN I c f D' x')", "by (auto simp: WHILEI_body_def enres_lift_def pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s\n  \\<le> enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)\n\ngoal (1 subgoal):\n 1. enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)\n    \\<le> EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)\n    \\<le> EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s", "unfolding enres_unfolds WHILEIT_def WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enres_lift (REC\\<^sub>T (WHILEI_body (\\<bind>) RETURN I c f) s)\n    \\<le> REC\\<^sub>T\n           (WHILEI_body (\\<bind>) RETURN (case_sum (\\<lambda>x. True) I)\n             (case_sum (\\<lambda>x. False) c)\n             (\\<lambda>s.\n                 ASSERT (\\<not> isl s) \\<bind>\n                 (\\<lambda>_. let s = projr s in enres_lift (f s))))\n           (Inr s)", "apply (rule RECT_transfer_rel'[where P=\"\\<lambda>a c. c = Inr a\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. trimono (WHILEI_body (\\<bind>) RETURN I c f)\n 2. trimono\n     (WHILEI_body (\\<bind>) RETURN (case_sum (\\<lambda>x. True) I)\n       (case_sum (\\<lambda>x. False) c)\n       (\\<lambda>s.\n           ASSERT (\\<not> isl s) \\<bind>\n           (\\<lambda>_. let s = projr s in enres_lift (f s))))\n 3. \\<And>x. enres_lift x \\<le> FAIL\n 4. Inr s = Inr s\n 5. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x' = Inr x \\<Longrightarrow>\n                   enres_lift (D x) \\<le> D' x';\n        x' = Inr x\\<rbrakk>\n       \\<Longrightarrow> enres_lift (WHILEI_body (\\<bind>) RETURN I c f D x)\n                         \\<le> WHILEI_body (\\<bind>) RETURN\n                                (case_sum (\\<lambda>x. True) I)\n                                (case_sum (\\<lambda>x. False) c)\n                                (\\<lambda>s.\n                                    ASSERT (\\<not> isl s) \\<bind>\n                                    (\\<lambda>_.\n  let s = projr s in enres_lift (f s)))\n                                D' x'", "apply (simp add: while.WHILEI_body_trimono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. trimono\n     (WHILEI_body (\\<bind>) RETURN (case_sum (\\<lambda>x. True) I)\n       (case_sum (\\<lambda>x. False) c)\n       (\\<lambda>s.\n           ASSERT (\\<not> isl s) \\<bind>\n           (\\<lambda>_. let s = projr s in enres_lift (f s))))\n 2. \\<And>x. enres_lift x \\<le> FAIL\n 3. Inr s = Inr s\n 4. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x' = Inr x \\<Longrightarrow>\n                   enres_lift (D x) \\<le> D' x';\n        x' = Inr x\\<rbrakk>\n       \\<Longrightarrow> enres_lift (WHILEI_body (\\<bind>) RETURN I c f D x)\n                         \\<le> WHILEI_body (\\<bind>) RETURN\n                                (case_sum (\\<lambda>x. True) I)\n                                (case_sum (\\<lambda>x. False) c)\n                                (\\<lambda>s.\n                                    ASSERT (\\<not> isl s) \\<bind>\n                                    (\\<lambda>_.\n  let s = projr s in enres_lift (f s)))\n                                D' x'", "apply (simp add: while.WHILEI_body_trimono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. enres_lift x \\<le> FAIL\n 2. Inr s = Inr s\n 3. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x' = Inr x \\<Longrightarrow>\n                   enres_lift (D x) \\<le> D' x';\n        x' = Inr x\\<rbrakk>\n       \\<Longrightarrow> enres_lift (WHILEI_body (\\<bind>) RETURN I c f D x)\n                         \\<le> WHILEI_body (\\<bind>) RETURN\n                                (case_sum (\\<lambda>x. True) I)\n                                (case_sum (\\<lambda>x. False) c)\n                                (\\<lambda>s.\n                                    ASSERT (\\<not> isl s) \\<bind>\n                                    (\\<lambda>_.\n  let s = projr s in enres_lift (f s)))\n                                D' x'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. Inr s = Inr s\n 2. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x' = Inr x \\<Longrightarrow>\n                   enres_lift (D x) \\<le> D' x';\n        x' = Inr x\\<rbrakk>\n       \\<Longrightarrow> enres_lift (WHILEI_body (\\<bind>) RETURN I c f D x)\n                         \\<le> WHILEI_body (\\<bind>) RETURN\n                                (case_sum (\\<lambda>x. True) I)\n                                (case_sum (\\<lambda>x. False) c)\n                                (\\<lambda>s.\n                                    ASSERT (\\<not> isl s) \\<bind>\n                                    (\\<lambda>_.\n  let s = projr s in enres_lift (f s)))\n                                D' x'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D D' x x'.\n       \\<lbrakk>\\<And>x x'.\n                   x' = Inr x \\<Longrightarrow>\n                   enres_lift (D x) \\<le> D' x';\n        x' = Inr x\\<rbrakk>\n       \\<Longrightarrow> enres_lift (WHILEI_body (\\<bind>) RETURN I c f D x)\n                         \\<le> WHILEI_body (\\<bind>) RETURN\n                                (case_sum (\\<lambda>x. True) I)\n                                (case_sum (\\<lambda>x. False) c)\n                                (\\<lambda>s.\n                                    ASSERT (\\<not> isl s) \\<bind>\n                                    (\\<lambda>_.\n  let s = projr s in enres_lift (f s)))\n                                D' x'", "by (auto simp: WHILEI_body_def enres_lift_def pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  enres_lift (WHILE\\<^sub>T\\<^bsup>I\\<^esup> c f s)\n  \\<le> EWHILEIT I c (\\<lambda>s. enres_lift (f s)) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [enres_breakdown]: \"EWHILET c (\\<lambda>s. enres_lift (f s)) s = enres_lift (WHILET c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EWHILET c (\\<lambda>s. enres_lift (f s)) s =\n    enres_lift (WHILE\\<^sub>T c f s)", "unfolding EWHILET_def WHILET_def enres_breakdown"], ["proof (prove)\ngoal (1 subgoal):\n 1. enres_lift (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f s) =\n    enres_lift (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> c f s)", ".."], ["", "lemma [enres_breakdown]: \"enfoldli l c (\\<lambda>x s. enres_lift (f x s)) s = enres_lift (nfoldli l c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enfoldli l c (\\<lambda>x s. enres_lift (f x s)) s =\n    enres_lift (nfoldli l c f s)", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       enfoldli [] c (\\<lambda>x s. enres_lift (f x s)) s =\n       enres_lift (nfoldli [] c f s)\n 2. \\<And>a l s.\n       (\\<And>s.\n           enfoldli l c (\\<lambda>x s. enres_lift (f x s)) s =\n           enres_lift (nfoldli l c f s)) \\<Longrightarrow>\n       enfoldli (a # l) c (\\<lambda>x s. enres_lift (f x s)) s =\n       enres_lift (nfoldli (a # l) c f s)", "by (auto simp: enres_breakdown)"], ["", "lemma [enres_breakdown]: \n  \"(\\<lambda>(a,b). enres_lift (f a b)) = (\\<lambda>x. enres_lift (case x of (a,b) \\<Rightarrow> f a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). enres_lift (f a b)) =\n    (\\<lambda>x. enres_lift (case x of (a, b) \\<Rightarrow> f a b))", "by auto"], ["", "lemmas [enres_breakdown] = nres_monad_laws nres_bind_let_law"], ["", "lemma [enres_breakdown]:\n  \"doE { CHECK \\<Phi> e; m } = (if \\<Phi> then m else THROW e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (CHECK \\<Phi> e) (\\<lambda>_. m) = (if \\<Phi> then m else THROW e)", "by (auto simp: enres_unfolds)"], ["", "lemma [enres_breakdown]: \"(if b then enres_lift m else enres_lift n) = enres_lift (if b then m else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then enres_lift m else enres_lift n) =\n    enres_lift (if b then m else n)", "by simp"], ["", "lemma option_case_enbd[enres_breakdown]:\n  \"case_option (enres_lift fn) (\\<lambda>v. enres_lift (fs v)) = (\\<lambda>x. enres_lift (case_option fn fs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_option (enres_lift fn) (\\<lambda>v. enres_lift (fs v)) =\n    (\\<lambda>x.\n        enres_lift\n         (case x of None \\<Rightarrow> fn | Some x \\<Rightarrow> fs x))", "by (auto split: option.split)"], ["", "named_theorems enres_inline"], ["", "method opt_enres_unfold = ((unfold enres_inline)?; (unfold enres_monad_laws)?; (unfold enres_breakdown)?; (rule refl)?; (unfold enres_unfolds enres_lift_def nres_monad_laws)?; (rule refl)?)"], ["", "subsection \\<open>More Combinators\\<close>"], ["", "subsubsection \\<open>CHECK-Monadic\\<close>"], ["", "definition [enres_unfolds]: \"CHECK_monadic c e \\<equiv> doE { b \\<leftarrow> c; CHECK b e }\""], ["", "lemma CHECK_monadic_rule_iff:\n    \"(CHECK_monadic c e \\<le> ESPEC E P) \\<longleftrightarrow> (c \\<le> ESPEC E (\\<lambda>r. (r \\<longrightarrow> P ()) \\<and> (\\<not>r \\<longrightarrow> E e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CHECK_monadic c e \\<le> ESPEC E P) =\n    (c \\<le> ESPEC E\n              (\\<lambda>r.\n                  (r \\<longrightarrow> P ()) \\<and>\n                  (\\<not> r \\<longrightarrow> E e)))", "by (auto simp: pw_ele_iff CHECK_monadic_def refine_pw_simps)"], ["", "lemma CHECK_monadic_pw[refine_pw_simps]:\n    \"nofail (CHECK_monadic c e) \\<longleftrightarrow> nofail c\"\n    \"inres (CHECK_monadic c e) (Inl ee) \\<longleftrightarrow> (inres c (Inl ee) \\<or> inres c (Inr False) \\<and> ee=e)\"\n    \"inres (CHECK_monadic c e) (Inr x) \\<longleftrightarrow> (inres c (Inr True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (CHECK_monadic c e) = nofail c &&&\n    inres (CHECK_monadic c e) (Inl ee) =\n    (inres c (Inl ee) \\<or> inres c (Inr False) \\<and> ee = e) &&&\n    inres (CHECK_monadic c e) (Inr x) = inres c (Inr True)", "unfolding CHECK_monadic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (ebind c (\\<lambda>b. CHECK b e)) = nofail c &&&\n    inres (ebind c (\\<lambda>b. CHECK b e)) (Inl ee) =\n    (inres c (Inl ee) \\<or> inres c (Inr False) \\<and> ee = e) &&&\n    inres (ebind c (\\<lambda>b. CHECK b e)) (Inr x) = inres c (Inr True)", "by (auto simp: refine_pw_simps)"], ["", "lemma CHECK_monadic_rule[refine_vcg]:\n    assumes \"c \\<le> ESPEC E (\\<lambda>r. (r \\<longrightarrow> P ()) \\<and> (\\<not>r \\<longrightarrow> E e))\"\n    shows \"CHECK_monadic c e \\<le> ESPEC E P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK_monadic c e \\<le> ESPEC E P", "using assms"], ["proof (prove)\nusing this:\n  c \\<le> ESPEC E\n           (\\<lambda>r.\n               (r \\<longrightarrow> P ()) \\<and>\n               (\\<not> r \\<longrightarrow> E e))\n\ngoal (1 subgoal):\n 1. CHECK_monadic c e \\<le> ESPEC E P", "by (simp add: CHECK_monadic_rule_iff)"], ["", "lemma CHECK_monadic_refine[refine]:\n    assumes \"ci \\<le> \\<Down>\\<^sub>E ER bool_rel c\"\n    assumes \"(ei,e)\\<in>ER\"  \n    shows \"CHECK_monadic ci ei \\<le>\\<Down>\\<^sub>E ER unit_rel (CHECK_monadic c e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK_monadic ci ei\n    \\<le> \\<Down>\\<^sub>E ER unit_rel (CHECK_monadic c e)", "using assms"], ["proof (prove)\nusing this:\n  ci \\<le> \\<Down>\\<^sub>E ER bool_rel c\n  (ei, e) \\<in> ER\n\ngoal (1 subgoal):\n 1. CHECK_monadic ci ei\n    \\<le> \\<Down>\\<^sub>E ER unit_rel (CHECK_monadic c e)", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma CHECK_monadic_CHECK_refine[refine]:\n    assumes \"ci \\<le> ESPEC (\\<lambda>e'. (e',e)\\<in>ER \\<and> \\<not>c) (\\<lambda>r. r \\<longleftrightarrow> c)\"\n    assumes \"(ei,e)\\<in>ER\"\n    shows \"CHECK_monadic ci ei \\<le>\\<Down>\\<^sub>E ER unit_rel (CHECK c e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK_monadic ci ei \\<le> \\<Down>\\<^sub>E ER unit_rel (CHECK c e)", "using assms"], ["proof (prove)\nusing this:\n  ci \\<le> ESPEC (\\<lambda>e'. (e', e) \\<in> ER \\<and> \\<not> c)\n            (\\<lambda>r. r = c)\n  (ei, e) \\<in> ER\n\ngoal (1 subgoal):\n 1. CHECK_monadic ci ei \\<le> \\<Down>\\<^sub>E ER unit_rel (CHECK c e)", "by (auto simp: pw_ele_iff refine_pw_simps)"], ["", "lemma CHECK_monadic_endb[enres_breakdown]: \"CHECK_monadic (enres_lift c) e = \n    do {b \\<leftarrow> c; CHECK b e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHECK_monadic (enres_lift c) e = c \\<bind> (\\<lambda>b. CHECK b e)", "by (auto simp: enres_unfolds enres_lift_def)"], ["", "end"]]}