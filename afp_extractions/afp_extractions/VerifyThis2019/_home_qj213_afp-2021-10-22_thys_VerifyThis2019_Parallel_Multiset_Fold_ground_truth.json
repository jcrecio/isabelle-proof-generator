{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019/Parallel_Multiset_Fold.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019", "problem_names": ["lemma (in comp_fun_commute) fold_mset_rewr: \"fold_mset f a (mset l) = fold f l a\"", "lemma finite_set_of_finite_maps:\n  fixes A :: \"'a set\"\n    and B :: \"'b set\"\n  assumes \"finite A\"\n    and \"finite B\"\n  shows \"finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\"", "lemma wf_rtranclp_ev_induct[consumes 1, case_names step]:\n  assumes \"wf {(x, y). R y x}\" and step: \"\\<And> x. R\\<^sup>*\\<^sup>* a x \\<Longrightarrow> P x \\<or> (\\<exists> y. R x y)\"\n  shows \"\\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x\"", "lemma no_deadlock:\n  assumes \"\\<not> final cfg\"\n  shows \"\\<exists>cfg'. step cfg cfg'\"", "lemma wf_step:\n  \"wf {((ts', ws', r'), (ts, ws, r)).\n    step (ts, ws, r) (ts', ws', r') \\<and> set ts' \\<subseteq> S \\<and> dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}\"\n  if \"finite S\"", "lemma reachable0[simp]: \"reachable s\\<^sub>0\"", "lemma is_invarI[intro?]: \n  \"\\<lbrakk> I s\\<^sub>0; \\<And>s s'. \\<lbrakk> reachable s; I s; step s s'\\<rbrakk> \\<Longrightarrow> I s' \\<rbrakk> \\<Longrightarrow> is_invar I\"", "lemma invar_reachable: \"is_invar I \\<Longrightarrow> reachable s \\<Longrightarrow> I s\"", "lemma invariant:\n  \"is_invar invar\"", "lemma final_state_correct1:\n  assumes \"invar (ts', ms, r)\" \"final (ts', ms, r)\"\n  shows \"r = fold_mset f start (mset ts)\"", "lemma final_state_correct2:\n  assumes \"reachable (ts', ms, r)\" \"final (ts', ms, r)\"\n  shows \"r = fold_mset f start (mset ts)\"", "theorem final_state_correct:\n  assumes \"reachable (ts', ms, r)\" \"final (ts', ms, r)\"\n  shows \"r = fold f ts start\"", "theorem \"termination\":\n  assumes \"reachable s\"\n  shows \"\\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'\""], "translations": [["", "lemma (in comp_fun_commute) fold_mset_rewr: \"fold_mset f a (mset l) = fold f l a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold_mset f a (mset l) = fold f l a", "by (induction l arbitrary: a; clarsimp; metis fold_mset_fun_left_comm)"], ["", "lemma finite_set_of_finite_maps:\n  fixes A :: \"'a set\"\n    and B :: \"'b set\"\n  assumes \"finite A\"\n    and \"finite B\"\n  shows \"finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}", "have \"{m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B} \\<subseteq> (\\<Union> S \\<in> {S. S \\<subseteq> A}. {m. dom m = S \\<and> ran m \\<subseteq> B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\n    \\<subseteq> (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n                    {m. dom m = S \\<and> ran m \\<subseteq> B})", "by auto"], ["proof (state)\nthis:\n  {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\n  \\<subseteq> (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n                  {m. dom m = S \\<and> ran m \\<subseteq> B})\n\ngoal (1 subgoal):\n 1. finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}", "moreover"], ["proof (state)\nthis:\n  {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\n  \\<subseteq> (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n                  {m. dom m = S \\<and> ran m \\<subseteq> B})\n\ngoal (1 subgoal):\n 1. finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n         {m. dom m = S \\<and> ran m \\<subseteq> B})", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n         {m. dom m = S \\<and> ran m \\<subseteq> B})", "by (auto intro!: finite_set_of_finite_maps intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n       {m. dom m = S \\<and> ran m \\<subseteq> B})\n\ngoal (1 subgoal):\n 1. finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}", "ultimately"], ["proof (chain)\npicking this:\n  {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\n  \\<subseteq> (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n                  {m. dom m = S \\<and> ran m \\<subseteq> B})\n  finite\n   (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n       {m. dom m = S \\<and> ran m \\<subseteq> B})", "show ?thesis"], ["proof (prove)\nusing this:\n  {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\n  \\<subseteq> (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n                  {m. dom m = S \\<and> ran m \\<subseteq> B})\n  finite\n   (\\<Union>S\\<in>{S. S \\<subseteq> A}.\n       {m. dom m = S \\<and> ran m \\<subseteq> B})\n\ngoal (1 subgoal):\n 1. finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {m. dom m \\<subseteq> A \\<and> ran m \\<subseteq> B}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_rtranclp_ev_induct[consumes 1, case_names step]:\n  assumes \"wf {(x, y). R y x}\" and step: \"\\<And> x. R\\<^sup>*\\<^sup>* a x \\<Longrightarrow> P x \\<or> (\\<exists> y. R x y)\"\n  shows \"\\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x", "have \"\\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y\" if \"R\\<^sup>*\\<^sup>* a x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "using assms(1) that"], ["proof (prove)\nusing this:\n  wf {(x, y). R y x}\n  R\\<^sup>*\\<^sup>* a x\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "proof induction"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> {(x, y). R y x};\n                    R\\<^sup>*\\<^sup>* a y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ya.\n  P ya \\<and> R\\<^sup>*\\<^sup>* y ya;\n        R\\<^sup>*\\<^sup>* a x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "case (less x)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, x) \\<in> {(x, y). R y x}; R\\<^sup>*\\<^sup>* a ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* ?y y\n  R\\<^sup>*\\<^sup>* a x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> {(x, y). R y x};\n                    R\\<^sup>*\\<^sup>* a y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ya.\n  P ya \\<and> R\\<^sup>*\\<^sup>* y ya;\n        R\\<^sup>*\\<^sup>* a x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "from step[OF \\<open>R\\<^sup>*\\<^sup>* a x\\<close>]"], ["proof (chain)\npicking this:\n  P x \\<or> (\\<exists>y. R x y)", "have \"P x \\<or> (\\<exists>y. R x y)\""], ["proof (prove)\nusing this:\n  P x \\<or> (\\<exists>y. R x y)\n\ngoal (1 subgoal):\n 1. P x \\<or> (\\<exists>y. R x y)", "."], ["proof (state)\nthis:\n  P x \\<or> (\\<exists>y. R x y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> {(x, y). R y x};\n                    R\\<^sup>*\\<^sup>* a y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ya.\n  P ya \\<and> R\\<^sup>*\\<^sup>* y ya;\n        R\\<^sup>*\\<^sup>* a x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "then"], ["proof (chain)\npicking this:\n  P x \\<or> (\\<exists>y. R x y)", "show ?case"], ["proof (prove)\nusing this:\n  P x \\<or> (\\<exists>y. R x y)\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y\n 2. \\<exists>y. R x y \\<Longrightarrow>\n    \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "assume \"P x\""], ["proof (state)\nthis:\n  P x\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y\n 2. \\<exists>y. R x y \\<Longrightarrow>\n    \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "then"], ["proof (chain)\npicking this:\n  P x", "show ?case"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "by auto"], ["proof (state)\nthis:\n  \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y\n\ngoal (1 subgoal):\n 1. \\<exists>y. R x y \\<Longrightarrow>\n    \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. R x y \\<Longrightarrow>\n    \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "assume \"\\<exists>y. R x y\""], ["proof (state)\nthis:\n  \\<exists>y. R x y\n\ngoal (1 subgoal):\n 1. \\<exists>y. R x y \\<Longrightarrow>\n    \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. R x y", "obtain y where \"R x y\""], ["proof (prove)\nusing this:\n  \\<exists>y. R x y\n\ngoal (1 subgoal):\n 1. (\\<And>y. R x y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  R x y\n\ngoal (1 subgoal):\n 1. \\<exists>y. R x y \\<Longrightarrow>\n    \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "with less(1)[of y] less(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>(y, x) \\<in> {(x, y). R y x}; R\\<^sup>*\\<^sup>* a y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ya. P ya \\<and> R\\<^sup>*\\<^sup>* y ya\n  R\\<^sup>*\\<^sup>* a x\n  R x y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(y, x) \\<in> {(x, y). R y x}; R\\<^sup>*\\<^sup>* a y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ya. P ya \\<and> R\\<^sup>*\\<^sup>* y ya\n  R\\<^sup>*\\<^sup>* a x\n  R x y\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y", "by simp (meson converse_rtranclp_into_rtranclp rtranclp.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R\\<^sup>*\\<^sup>* a ?x \\<Longrightarrow>\n  \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* ?x y\n\ngoal (1 subgoal):\n 1. \\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x", "then"], ["proof (chain)\npicking this:\n  R\\<^sup>*\\<^sup>* a ?x \\<Longrightarrow>\n  \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* ?x y", "show ?thesis"], ["proof (prove)\nusing this:\n  R\\<^sup>*\\<^sup>* a ?x \\<Longrightarrow>\n  \\<exists>y. P y \\<and> R\\<^sup>*\\<^sup>* ?x y\n\ngoal (1 subgoal):\n 1. \\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. P x \\<and> R\\<^sup>*\\<^sup>* a x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Concurrent System\\<close>"], ["", "text \\<open>\n  A state of our concurrent systems consists of a list of tasks,\n  a partial map from threads to the task they are currently working on,\n  and the current computation result.\\<close>"], ["", "type_synonym ('a, 's) state = \"'a list \\<times> (nat \\<rightharpoonup> 'a) \\<times> 's\""], ["", "context comp_fun_commute\nbegin"], ["", "context\n  fixes n :: nat \\<comment> \\<open>The number of threads.\\<close>\n  assumes n_gt_0[simp, intro]: \"n > 0\"\nbegin"], ["", "text \\<open>\n  A state is \\<^emph>\\<open>final\\<close> if there are no remaining tasks and if all workers have finished their work.\\<close>"], ["", "definition\n  \"final \\<equiv> \\<lambda>(ts, ws, r). ts = [] \\<and> dom ws \\<inter> {0..<n} = {}\""], ["", "text \\<open>At any point a thread can:\n  \\<^item> pick a new task from the queue if it is currently not busy\n  \\<^item> or execute its current task.\\<close>"], ["", "inductive step :: \"('a, 'b) state \\<Rightarrow> ('a, 'b) state \\<Rightarrow> bool\" where\n  pick: \"step (t # ts, ws, s) (ts, ws(i := Some t), s)\"   if \"ws i = None\"   and \"i < n\"\n| exec: \"step (ts, ws, s)     (ts, ws(i := None), f a s)\" if \"ws i = Some a\" and \"i < n\""], ["", "lemma no_deadlock:\n  assumes \"\\<not> final cfg\"\n  shows \"\\<exists>cfg'. step cfg cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg'. step cfg cfg'", "using assms"], ["proof (prove)\nusing this:\n  \\<not> final cfg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'. step cfg cfg'", "apply (cases cfg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> final cfg; cfg = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'. step cfg cfg'", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> final (a, b, c); cfg = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'. step (a, b, c) cfg'", "subgoal for ts ws s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> final (ts, ws, s); cfg = (ts, ws, s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>cfg'. step (ts, ws, s) cfg'", "by (cases ts; cases \"ws 0\") (auto 4 5 simp: final_def intro: step.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_step:\n  \"wf {((ts', ws', r'), (ts, ws, r)).\n    step (ts, ws, r) (ts', ws', r') \\<and> set ts' \\<subseteq> S \\<and> dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}\"\n  if \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "let ?R1 = \"{(x, y). dom x \\<subset> dom y \\<and> ran x \\<subseteq> S \\<and> dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "have \"?R1 \\<subseteq> {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S} \\<times> {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     dom x \\<subset> dom y \\<and>\n     ran x \\<subseteq> S \\<and>\n     dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n    \\<subseteq> {y. dom y \\<subseteq> {0..<n} \\<and>\n                    ran y \\<subseteq> S} \\<times>\n                {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   dom x \\<subset> dom y \\<and>\n   ran x \\<subseteq> S \\<and>\n   dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n  \\<subseteq> {y. dom y \\<subseteq> {0..<n} \\<and>\n                  ran y \\<subseteq> S} \\<times>\n              {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "then"], ["proof (chain)\npicking this:\n  {(x, y).\n   dom x \\<subset> dom y \\<and>\n   ran x \\<subseteq> S \\<and>\n   dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n  \\<subseteq> {y. dom y \\<subseteq> {0..<n} \\<and>\n                  ran y \\<subseteq> S} \\<times>\n              {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}", "have \"finite ?R1\""], ["proof (prove)\nusing this:\n  {(x, y).\n   dom x \\<subset> dom y \\<and>\n   ran x \\<subseteq> S \\<and>\n   dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n  \\<subseteq> {y. dom y \\<subseteq> {0..<n} \\<and>\n                  ran y \\<subseteq> S} \\<times>\n              {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. finite\n     {(x, y).\n      dom x \\<subset> dom y \\<and>\n      ran x \\<subseteq> S \\<and>\n      dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}", "using \\<open>finite S\\<close>"], ["proof (prove)\nusing this:\n  {(x, y).\n   dom x \\<subset> dom y \\<and>\n   ran x \\<subseteq> S \\<and>\n   dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n  \\<subseteq> {y. dom y \\<subseteq> {0..<n} \\<and>\n                  ran y \\<subseteq> S} \\<times>\n              {y. dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     {(x, y).\n      dom x \\<subset> dom y \\<and>\n      ran x \\<subseteq> S \\<and>\n      dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}", "by - (erule finite_subset, auto intro: finite_set_of_finite_maps)"], ["proof (state)\nthis:\n  finite\n   {(x, y).\n    dom x \\<subset> dom y \\<and>\n    ran x \\<subseteq> S \\<and>\n    dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "then"], ["proof (chain)\npicking this:\n  finite\n   {(x, y).\n    dom x \\<subset> dom y \\<and>\n    ran x \\<subseteq> S \\<and>\n    dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}", "have [intro]: \"wf ?R1\""], ["proof (prove)\nusing this:\n  finite\n   {(x, y).\n    dom x \\<subset> dom y \\<and>\n    ran x \\<subseteq> S \\<and>\n    dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. wf {(x, y).\n        dom x \\<subset> dom y \\<and>\n        ran x \\<subseteq> S \\<and>\n        dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}", "apply (rule finite_acyclic_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclicP\n     (\\<lambda>x y.\n         dom x \\<subset> dom y \\<and>\n         ran x \\<subseteq> S \\<and>\n         dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S)", "apply (rule preorder_class.acyclicI_order[where f = \"\\<lambda>x. n - card (dom x)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> {(x, y).\n              dom x \\<subset> dom y \\<and>\n              ran x \\<subseteq> S \\<and>\n              dom y \\<subseteq> {0..<n} \\<and>\n              ran y \\<subseteq> S} \\<Longrightarrow>\n       n - card (dom b) < n - card (dom a)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>dom a \\<subseteq> dom b;\n        \\<not> n - card (dom b) < n - card (dom a); b x = Some y;\n        ran a \\<subseteq> S; dom b \\<subseteq> {0..<n};\n        ran b \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a x = Some y", "by (metis (full_types) \n        cancel_ab_semigroup_add_class.diff_right_commute diff_diff_cancel domD domI\n        psubsetI psubset_card_mono subset_eq_atLeast0_lessThan_card\n        subset_eq_atLeast0_lessThan_finite zero_less_diff)"], ["proof (state)\nthis:\n  wf {(x, y).\n      dom x \\<subset> dom y \\<and>\n      ran x \\<subseteq> S \\<and>\n      dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "let ?R = \"measure length <*lex*> ?R1 <*lex*> {}\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "have \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure length <*lex*>\n        {(x, y).\n         dom x \\<subset> dom y \\<and>\n         ran x \\<subseteq> S \\<and>\n         dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S} <*lex*>\n        {})", "by auto"], ["proof (state)\nthis:\n  wf (measure length <*lex*>\n      {(x, y).\n       dom x \\<subset> dom y \\<and>\n       ran x \\<subseteq> S \\<and>\n       dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S} <*lex*>\n      {})\n\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "then"], ["proof (chain)\npicking this:\n  wf (measure length <*lex*>\n      {(x, y).\n       dom x \\<subset> dom y \\<and>\n       ran x \\<subseteq> S \\<and>\n       dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S} <*lex*>\n      {})", "show ?thesis"], ["proof (prove)\nusing this:\n  wf (measure length <*lex*>\n      {(x, y).\n       dom x \\<subset> dom y \\<and>\n       ran x \\<subseteq> S \\<and>\n       dom y \\<subseteq> {0..<n} \\<and> ran y \\<subseteq> S} <*lex*>\n      {})\n\ngoal (1 subgoal):\n 1. wf {((ts', ws', r'), ts, ws, r).\n        step (ts, ws, r) (ts', ws', r') \\<and>\n        set ts' \\<subseteq> S \\<and>\n        dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}", "apply (rule wf_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((ts', ws', r'), ts, ws, r).\n     step (ts, ws, r) (ts', ws', r') \\<and>\n     set ts' \\<subseteq> S \\<and>\n     dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}\n    \\<subseteq> measure length <*lex*>\n                {(x, y).\n                 dom x \\<subset> dom y \\<and>\n                 ran x \\<subseteq> S \\<and>\n                 dom y \\<subseteq> {0..<n} \\<and>\n                 ran y \\<subseteq> S} <*lex*>\n                {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>step (ab, ac, ba) (a, aa, b); set a \\<subseteq> S;\n        dom ac \\<subseteq> {0..<n}; ran ac \\<subseteq> S;\n        dom aa \\<subset> dom ac \\<longrightarrow>\n        a = ab \\<longrightarrow> \\<not> ran aa \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> length a < length ab", "apply (erule step.cases; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ws i ad.\n       \\<lbrakk>set a \\<subseteq> S; dom ws \\<subseteq> {0..<n};\n        ran ws \\<subseteq> S;\n        dom ws - {i} \\<subset> dom ws \\<longrightarrow>\n        \\<not> ran (ws(i := None)) \\<subseteq> S;\n        ws i = Some ad; i < n\\<rbrakk>\n       \\<Longrightarrow> False", "by (smt\n        Diff_iff domIff fun_upd_apply mem_Collect_eq option.simps(3) psubsetI ran_def\n        singletonI subset_iff)"], ["proof (state)\nthis:\n  wf {((ts', ws', r'), ts, ws, r).\n      step (ts, ws, r) (ts', ws', r') \\<and>\n      set ts' \\<subseteq> S \\<and>\n      dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> S}\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes ts :: \"'a list\" and start :: \"'b\"\nbegin"], ["", "definition\n  \"s\\<^sub>0 = (ts, \\<lambda>_. None, start)\""], ["", "definition \"reachable \\<equiv> (step\\<^sup>*\\<^sup>*) s\\<^sub>0\""], ["", "lemma reachable0[simp]: \"reachable s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable s\\<^sub>0", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. step\\<^sup>*\\<^sup>* s\\<^sub>0 s\\<^sub>0", "by auto"], ["", "definition \"is_invar I \\<equiv> I s\\<^sub>0 \\<and> (\\<forall>s s'. reachable s \\<and> I s \\<and> step s s' \\<longrightarrow> I s')\""], ["", "lemma is_invarI[intro?]: \n  \"\\<lbrakk> I s\\<^sub>0; \\<And>s s'. \\<lbrakk> reachable s; I s; step s s'\\<rbrakk> \\<Longrightarrow> I s' \\<rbrakk> \\<Longrightarrow> is_invar I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I s\\<^sub>0;\n     \\<And>s s'.\n        \\<lbrakk>reachable s; I s; step s s'\\<rbrakk>\n        \\<Longrightarrow> I s'\\<rbrakk>\n    \\<Longrightarrow> is_invar I", "by (auto simp: is_invar_def)"], ["", "lemma invar_reachable: \"is_invar I \\<Longrightarrow> reachable s \\<Longrightarrow> I s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_invar I; reachable s\\<rbrakk> \\<Longrightarrow> I s", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_invar I; step\\<^sup>*\\<^sup>* s\\<^sub>0 s\\<rbrakk>\n    \\<Longrightarrow> I s", "by rotate_tac (induction rule: rtranclp_induct, auto simp: is_invar_def reachable_def)"], ["", "definition\n  \"invar \\<equiv> \\<lambda>(ts2, ws, r).\n    (\\<exists>ts1.\n      mset ts = ts1 + {# the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n}) #} + mset ts2\n    \\<and> r = fold_mset f start ts1\n    \\<and> set ts2 \\<subseteq> set ts \\<and> ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n})\""], ["", "lemma invariant:\n  \"is_invar invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_invar invar", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar s\\<^sub>0\n 2. \\<And>s s'.\n       \\<lbrakk>reachable s; invar s; step s s'\\<rbrakk>\n       \\<Longrightarrow> invar s'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s\\<^sub>0", "unfolding s\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (ts, Map.empty, start)", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (ts, Map.empty, start) of\n    (ts2, ws, r) \\<Rightarrow>\n      \\<exists>ts1.\n         mset ts =\n         ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n         mset ts2 \\<and>\n         r = fold_mset f start ts1 \\<and>\n         set ts2 \\<subseteq> set ts \\<and>\n         ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n}", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>reachable s; invar s; step s s'\\<rbrakk>\n       \\<Longrightarrow> invar s'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s_; invar s_; step s_ s'_\\<rbrakk>\n    \\<Longrightarrow> invar s'_", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable s_;\n     case s_ of\n     (ts2, ws, r) \\<Rightarrow>\n       \\<exists>ts1.\n          mset ts =\n          ts1 +\n          {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n          mset ts2 \\<and>\n          r = fold_mset f start ts1 \\<and>\n          set ts2 \\<subseteq> set ts \\<and>\n          ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n};\n     step s_ s'_\\<rbrakk>\n    \\<Longrightarrow> case s'_ of\n                      (ts2, ws, r) \\<Rightarrow>\n                        \\<exists>ts1.\n                           mset ts =\n                           ts1 +\n                           {#the (ws i)\n                           . i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n                           mset ts2 \\<and>\n                           r = fold_mset f start ts1 \\<and>\n                           set ts2 \\<subseteq> set ts \\<and>\n                           ran ws \\<subseteq> set ts \\<and>\n                           dom ws \\<subseteq> {0..<n}", "apply (elim step.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ws i t tsa sa.\n       \\<lbrakk>reachable s_;\n        case s_ of\n        (ts2, ws, r) \\<Rightarrow>\n          \\<exists>ts1.\n             mset ts =\n             ts1 +\n             {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n             mset ts2 \\<and>\n             r = fold_mset f start ts1 \\<and>\n             set ts2 \\<subseteq> set ts \\<and>\n             ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n};\n        s_ = (t # tsa, ws, sa); s'_ = (tsa, ws(i \\<mapsto> t), sa);\n        ws i = None; i < n\\<rbrakk>\n       \\<Longrightarrow> case s'_ of\n                         (ts2, ws, r) \\<Rightarrow>\n                           \\<exists>ts1.\n                              mset ts =\n                              ts1 +\n                              {#the (ws i)\n                              . i \\<in># mset_set\n    (dom ws \\<inter> {0..<n})#} +\n                              mset ts2 \\<and>\n                              r = fold_mset f start ts1 \\<and>\n                              set ts2 \\<subseteq> set ts \\<and>\n                              ran ws \\<subseteq> set ts \\<and>\n                              dom ws \\<subseteq> {0..<n}\n 2. \\<And>ws i a tsa sa.\n       \\<lbrakk>reachable s_;\n        case s_ of\n        (ts2, ws, r) \\<Rightarrow>\n          \\<exists>ts1.\n             mset ts =\n             ts1 +\n             {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n             mset ts2 \\<and>\n             r = fold_mset f start ts1 \\<and>\n             set ts2 \\<subseteq> set ts \\<and>\n             ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n};\n        s_ = (tsa, ws, sa); s'_ = (tsa, ws(i := None), f a sa);\n        ws i = Some a; i < n\\<rbrakk>\n       \\<Longrightarrow> case s'_ of\n                         (ts2, ws, r) \\<Rightarrow>\n                           \\<exists>ts1.\n                              mset ts =\n                              ts1 +\n                              {#the (ws i)\n                              . i \\<in># mset_set\n    (dom ws \\<inter> {0..<n})#} +\n                              mset ts2 \\<and>\n                              r = fold_mset f start ts1 \\<and>\n                              set ts2 \\<subseteq> set ts \\<and>\n                              ran ws \\<subseteq> set ts \\<and>\n                              dom ws \\<subseteq> {0..<n}", "apply (clarsimp split: option.split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ws i t tsa ts1.\n       \\<lbrakk>reachable (t # tsa, ws, fold_mset f start ts1);\n        s_ = (t # tsa, ws, fold_mset f start ts1);\n        s'_ = (tsa, ws(i \\<mapsto> t), fold_mset f start ts1); ws i = None;\n        i < n;\n        mset ts =\n        add_mset t\n         (ts1 +\n          {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n          mset tsa);\n        t \\<in> set ts; set tsa \\<subseteq> set ts;\n        ran ws \\<subseteq> set ts; dom ws \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts1a.\n                            add_mset t\n                             (ts1 +\n                              {#the (ws i)\n                              . i \\<in># mset_set\n    (dom ws \\<inter> {0..<n})#}) =\n                            ts1a +\n                            {#the (if ia = i then Some t else ws ia)\n                            . ia \\<in># mset_set\n   (insert i (dom ws \\<inter> {0..<n}))#} \\<and>\n                            fold_mset f start ts1 = fold_mset f start ts1a\n 2. \\<And>ws i a tsa sa.\n       \\<lbrakk>reachable s_;\n        case s_ of\n        (ts2, ws, r) \\<Rightarrow>\n          \\<exists>ts1.\n             mset ts =\n             ts1 +\n             {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n             mset ts2 \\<and>\n             r = fold_mset f start ts1 \\<and>\n             set ts2 \\<subseteq> set ts \\<and>\n             ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n};\n        s_ = (tsa, ws, sa); s'_ = (tsa, ws(i := None), f a sa);\n        ws i = Some a; i < n\\<rbrakk>\n       \\<Longrightarrow> case s'_ of\n                         (ts2, ws, r) \\<Rightarrow>\n                           \\<exists>ts1.\n                              mset ts =\n                              ts1 +\n                              {#the (ws i)\n                              . i \\<in># mset_set\n    (dom ws \\<inter> {0..<n})#} +\n                              mset ts2 \\<and>\n                              r = fold_mset f start ts1 \\<and>\n                              set ts2 \\<subseteq> set ts \\<and>\n                              ran ws \\<subseteq> set ts \\<and>\n                              dom ws \\<subseteq> {0..<n}", "subgoal for ws i t ts ts1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable (t # ts, ws, fold_mset f start ts1);\n     s_ = (t # ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i \\<mapsto> t), fold_mset f start ts1); ws i = None;\n     i < n;\n     mset ts =\n     add_mset t\n      (ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n       mset ts);\n     t \\<in> set ts; set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts1a.\n                         add_mset t\n                          (ts1 +\n                           {#the (ws i)\n                           . i \\<in># mset_set\n (dom ws \\<inter> {0..<n})#}) =\n                         ts1a +\n                         {#the (if ia = i then Some t else ws ia)\n                         . ia \\<in># mset_set\n(insert i (dom ws \\<inter> {0..<n}))#} \\<and>\n                         fold_mset f start ts1 = fold_mset f start ts1a", "apply (rule exI[where x = ts1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable (t # ts, ws, fold_mset f start ts1);\n     s_ = (t # ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i \\<mapsto> t), fold_mset f start ts1); ws i = None;\n     i < n;\n     mset ts =\n     add_mset t\n      (ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n       mset ts);\n     t \\<in> set ts; set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> add_mset t\n                       (ts1 +\n                        {#the (ws i)\n                        . i \\<in># mset_set (dom ws \\<inter> {0..<n})#}) =\n                      ts1 +\n                      {#the (if ia = i then Some t else ws ia)\n                      . ia \\<in># mset_set\n                                   (insert i\n                                     (dom ws \\<inter> {0..<n}))#} \\<and>\n                      fold_mset f start ts1 = fold_mset f start ts1", "apply (subst mset_set.insert)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>reachable (t # ts, ws, fold_mset f start ts1);\n     s_ = (t # ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i \\<mapsto> t), fold_mset f start ts1); ws i = None;\n     i < n;\n     mset ts =\n     add_mset t\n      (ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n       mset ts);\n     t \\<in> set ts; set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> finite (dom ws \\<inter> {0..<n})\n 2. \\<lbrakk>reachable (t # ts, ws, fold_mset f start ts1);\n     s_ = (t # ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i \\<mapsto> t), fold_mset f start ts1); ws i = None;\n     i < n;\n     mset ts =\n     add_mset t\n      (ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n       mset ts);\n     t \\<in> set ts; set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> i \\<notin> dom ws \\<inter> {0..<n}\n 3. \\<lbrakk>reachable (t # ts, ws, fold_mset f start ts1);\n     s_ = (t # ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i \\<mapsto> t), fold_mset f start ts1); ws i = None;\n     i < n;\n     mset ts =\n     add_mset t\n      (ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n       mset ts);\n     t \\<in> set ts; set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> add_mset t\n                       (ts1 +\n                        {#the (ws i)\n                        . i \\<in># mset_set (dom ws \\<inter> {0..<n})#}) =\n                      ts1 +\n                      {#the (if ia = i then Some t else ws ia)\n                      . ia \\<in># add_mset i\n                                   (mset_set\n                                     (dom ws \\<inter> {0..<n}))#} \\<and>\n                      fold_mset f start ts1 = fold_mset f start ts1", "apply (auto intro!: multiset.map_cong0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ws i a tsa sa.\n       \\<lbrakk>reachable s_;\n        case s_ of\n        (ts2, ws, r) \\<Rightarrow>\n          \\<exists>ts1.\n             mset ts =\n             ts1 +\n             {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n             mset ts2 \\<and>\n             r = fold_mset f start ts1 \\<and>\n             set ts2 \\<subseteq> set ts \\<and>\n             ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n};\n        s_ = (tsa, ws, sa); s'_ = (tsa, ws(i := None), f a sa);\n        ws i = Some a; i < n\\<rbrakk>\n       \\<Longrightarrow> case s'_ of\n                         (ts2, ws, r) \\<Rightarrow>\n                           \\<exists>ts1.\n                              mset ts =\n                              ts1 +\n                              {#the (ws i)\n                              . i \\<in># mset_set\n    (dom ws \\<inter> {0..<n})#} +\n                              mset ts2 \\<and>\n                              r = fold_mset f start ts1 \\<and>\n                              set ts2 \\<subseteq> set ts \\<and>\n                              ran ws \\<subseteq> set ts \\<and>\n                              dom ws \\<subseteq> {0..<n}", "apply (clarsimp split!: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ws i a tsa ts1.\n       \\<lbrakk>reachable (tsa, ws, fold_mset f start ts1);\n        s_ = (tsa, ws, fold_mset f start ts1);\n        s'_ = (tsa, ws(i := None), f a (fold_mset f start ts1));\n        ws i = Some a; i < n;\n        mset ts =\n        ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n        mset tsa;\n        set tsa \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n        dom ws \\<subseteq> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts1a.\n                            ts1 +\n                            {#the (ws i)\n                            . i \\<in># mset_set\n  (dom ws \\<inter> {0..<n})#} =\n                            ts1a +\n                            {#the (if ia = i then None else ws ia)\n                            . ia \\<in># mset_set\n   ((dom ws - {i}) \\<inter> {0..<n})#} \\<and>\n                            f a (fold_mset f start ts1) =\n                            fold_mset f start ts1a \\<and>\n                            ran (ws(i := None)) \\<subseteq> set ts \\<and>\n                            dom ws - {i} \\<subseteq> {0..<n}", "subgoal for ws i a ts ts1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable (ts, ws, fold_mset f start ts1);\n     s_ = (ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i := None), f a (fold_mset f start ts1)); ws i = Some a;\n     i < n;\n     mset ts =\n     ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n     mset ts;\n     set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts1a.\n                         ts1 +\n                         {#the (ws i)\n                         . i \\<in># mset_set (dom ws \\<inter> {0..<n})#} =\n                         ts1a +\n                         {#the (if ia = i then None else ws ia)\n                         . ia \\<in># mset_set\n((dom ws - {i}) \\<inter> {0..<n})#} \\<and>\n                         f a (fold_mset f start ts1) =\n                         fold_mset f start ts1a \\<and>\n                         ran (ws(i := None)) \\<subseteq> set ts \\<and>\n                         dom ws - {i} \\<subseteq> {0..<n}", "apply (rule exI[where x = \"add_mset a ts1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable (ts, ws, fold_mset f start ts1);\n     s_ = (ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i := None), f a (fold_mset f start ts1)); ws i = Some a;\n     i < n;\n     mset ts =\n     ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n     mset ts;\n     set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> ts1 +\n                      {#the (ws i)\n                      . i \\<in># mset_set (dom ws \\<inter> {0..<n})#} =\n                      add_mset a ts1 +\n                      {#the (if ia = i then None else ws ia)\n                      . ia \\<in># mset_set\n                                   ((dom ws - {i}) \\<inter>\n                                    {0..<n})#} \\<and>\n                      f a (fold_mset f start ts1) =\n                      fold_mset f start (add_mset a ts1) \\<and>\n                      ran (ws(i := None)) \\<subseteq> set ts \\<and>\n                      dom ws - {i} \\<subseteq> {0..<n}", "apply (subst Diff_Int_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable (ts, ws, fold_mset f start ts1);\n     s_ = (ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i := None), f a (fold_mset f start ts1)); ws i = Some a;\n     i < n;\n     mset ts =\n     ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n     mset ts;\n     set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> ts1 +\n                      {#the (ws i)\n                      . i \\<in># mset_set (dom ws \\<inter> {0..<n})#} =\n                      add_mset a ts1 +\n                      {#the (if ia = i then None else ws ia)\n                      . ia \\<in># mset_set\n                                   (dom ws \\<inter> {0..<n} -\n                                    {i} \\<inter> {0..<n})#} \\<and>\n                      f a (fold_mset f start ts1) =\n                      fold_mset f start (add_mset a ts1) \\<and>\n                      ran (ws(i := None)) \\<subseteq> set ts \\<and>\n                      dom ws - {i} \\<subseteq> {0..<n}", "apply (subst mset_set.remove)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>reachable (ts, ws, fold_mset f start ts1);\n     s_ = (ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i := None), f a (fold_mset f start ts1)); ws i = Some a;\n     i < n;\n     mset ts =\n     ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n     mset ts;\n     set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> finite (dom ws \\<inter> {0..<n})\n 2. \\<lbrakk>reachable (ts, ws, fold_mset f start ts1);\n     s_ = (ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i := None), f a (fold_mset f start ts1)); ws i = Some a;\n     i < n;\n     mset ts =\n     ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n     mset ts;\n     set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> ?x2 \\<in> dom ws \\<inter> {0..<n}\n 3. \\<lbrakk>reachable (ts, ws, fold_mset f start ts1);\n     s_ = (ts, ws, fold_mset f start ts1);\n     s'_ = (ts, ws(i := None), f a (fold_mset f start ts1)); ws i = Some a;\n     i < n;\n     mset ts =\n     ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n     mset ts;\n     set ts \\<subseteq> set ts; ran ws \\<subseteq> set ts;\n     dom ws \\<subseteq> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> ts1 +\n                      {#the (ws i)\n                      . i \\<in># add_mset ?x2\n                                  (mset_set\n                                    (dom ws \\<inter> {0..<n} - {?x2}))#} =\n                      add_mset a ts1 +\n                      {#the (if ia = i then None else ws ia)\n                      . ia \\<in># mset_set\n                                   (dom ws \\<inter> {0..<n} -\n                                    {i} \\<inter> {0..<n})#} \\<and>\n                      f a (fold_mset f start ts1) =\n                      fold_mset f start (add_mset a ts1) \\<and>\n                      ran (ws(i := None)) \\<subseteq> set ts \\<and>\n                      dom ws - {i} \\<subseteq> {0..<n}", "apply (auto intro!: multiset.map_cong0 split: if_split_asm simp: ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma final_state_correct1:\n  assumes \"invar (ts', ms, r)\" \"final (ts', ms, r)\"\n  shows \"r = fold_mset f start (mset ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = fold_mset f start (mset ts)", "using assms"], ["proof (prove)\nusing this:\n  invar (ts', ms, r)\n  final (ts', ms, r)\n\ngoal (1 subgoal):\n 1. r = fold_mset f start (mset ts)", "unfolding invar_def final_def"], ["proof (prove)\nusing this:\n  case (ts', ms, r) of\n  (ts2, ws, r) \\<Rightarrow>\n    \\<exists>ts1.\n       mset ts =\n       ts1 + {#the (ws i). i \\<in># mset_set (dom ws \\<inter> {0..<n})#} +\n       mset ts2 \\<and>\n       r = fold_mset f start ts1 \\<and>\n       set ts2 \\<subseteq> set ts \\<and>\n       ran ws \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n}\n  case (ts', ms, r) of\n  (ts, ws, r) \\<Rightarrow> ts = [] \\<and> dom ws \\<inter> {0..<n} = {}\n\ngoal (1 subgoal):\n 1. r = fold_mset f start (mset ts)", "by auto"], ["", "lemma final_state_correct2:\n  assumes \"reachable (ts', ms, r)\" \"final (ts', ms, r)\"\n  shows \"r = fold_mset f start (mset ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = fold_mset f start (mset ts)", "using assms"], ["proof (prove)\nusing this:\n  reachable (ts', ms, r)\n  final (ts', ms, r)\n\ngoal (1 subgoal):\n 1. r = fold_mset f start (mset ts)", "by - (rule final_state_correct1, rule invar_reachable[OF invariant])"], ["", "text \\<open>Soundness: whenever we reach a final state, the computation result is correct.\\<close>"], ["", "theorem final_state_correct:\n  assumes \"reachable (ts', ms, r)\" \"final (ts', ms, r)\"\n  shows \"r = fold f ts start\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = fold f ts start", "using final_state_correct2[OF assms]"], ["proof (prove)\nusing this:\n  r = fold_mset f start (mset ts)\n\ngoal (1 subgoal):\n 1. r = fold f ts start", "by (simp add: fold_mset_rewr)"], ["", "text \\<open>Termination: at any point during the program execution, we can continue to a final state.\nThat is, the computation always terminates.\n\\<close>"], ["", "theorem \"termination\":\n  assumes \"reachable s\"\n  shows \"\\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "have \"{(s', s). step s s' \\<and> reachable s} \\<subseteq> {(s', s). step s s' \\<and> reachable s \\<and> reachable s'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s). step s s' \\<and> reachable s}\n    \\<subseteq> {(s', s). step s s' \\<and> reachable s \\<and> reachable s'}", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s). step s s' \\<and> step\\<^sup>*\\<^sup>* s\\<^sub>0 s}\n    \\<subseteq> {(s', s).\n                 step s s' \\<and>\n                 step\\<^sup>*\\<^sup>* s\\<^sub>0 s \\<and>\n                 step\\<^sup>*\\<^sup>* s\\<^sub>0 s'}", "by auto"], ["proof (state)\nthis:\n  {(s', s). step s s' \\<and> reachable s}\n  \\<subseteq> {(s', s). step s s' \\<and> reachable s \\<and> reachable s'}\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "also"], ["proof (state)\nthis:\n  {(s', s). step s s' \\<and> reachable s}\n  \\<subseteq> {(s', s). step s s' \\<and> reachable s \\<and> reachable s'}\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "have \"\\<dots> \\<subseteq> {((ts', ws', r'), (ts1, ws, r)).\n    step (ts1, ws, r) (ts', ws', r') \\<and> set ts' \\<subseteq> set ts \\<and> dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> set ts}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s). step s s' \\<and> reachable s \\<and> reachable s'}\n    \\<subseteq> {((ts', ws', r'), ts1, ws, r).\n                 step (ts1, ws, r) (ts', ws', r') \\<and>\n                 set ts' \\<subseteq> set ts \\<and>\n                 dom ws \\<subseteq> {0..<n} \\<and>\n                 ran ws \\<subseteq> set ts}", "by (force dest!: invar_reachable[OF invariant] simp: invar_def)"], ["proof (state)\nthis:\n  {(s', s). step s s' \\<and> reachable s \\<and> reachable s'}\n  \\<subseteq> {((ts', ws', r'), ts1, ws, r).\n               step (ts1, ws, r) (ts', ws', r') \\<and>\n               set ts' \\<subseteq> set ts \\<and>\n               dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> set ts}\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "finally"], ["proof (chain)\npicking this:\n  {(s', s). step s s' \\<and> reachable s}\n  \\<subseteq> {((ts', ws', r'), ts1, ws, r).\n               step (ts1, ws, r) (ts', ws', r') \\<and>\n               set ts' \\<subseteq> set ts \\<and>\n               dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> set ts}", "have \"wf {(s', s). step s s' \\<and> reachable s}\""], ["proof (prove)\nusing this:\n  {(s', s). step s s' \\<and> reachable s}\n  \\<subseteq> {((ts', ws', r'), ts1, ws, r).\n               step (ts1, ws, r) (ts', ws', r') \\<and>\n               set ts' \\<subseteq> set ts \\<and>\n               dom ws \\<subseteq> {0..<n} \\<and> ran ws \\<subseteq> set ts}\n\ngoal (1 subgoal):\n 1. wf {(s', s). step s s' \\<and> reachable s}", "by (elim wf_subset[OF wf_step, rotated]) simp"], ["proof (state)\nthis:\n  wf {(s', s). step s s' \\<and> reachable s}\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "then"], ["proof (chain)\npicking this:\n  wf {(s', s). step s s' \\<and> reachable s}", "have \"\\<exists>s'. final s' \\<and> (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s s'\""], ["proof (prove)\nusing this:\n  wf {(s', s). step s s' \\<and> reachable s}\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       final s' \\<and>\n       (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s s'", "proof (induction rule: wf_rtranclp_ev_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n        s' \\<Longrightarrow>\n       final s' \\<or> (\\<exists>y. step s' y \\<and> reachable s')", "case (step x)"], ["proof (state)\nthis:\n  (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s x\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n        s' \\<Longrightarrow>\n       final s' \\<or> (\\<exists>y. step s' y \\<and> reachable s')", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s x", "have \"(\\<lambda>s s'. step s s')\\<^sup>*\\<^sup>* s x\""], ["proof (prove)\nusing this:\n  (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s x\n\ngoal (1 subgoal):\n 1. step\\<^sup>*\\<^sup>* s x", "by (elim mono_rtranclp[rule_format, rotated] conjE)"], ["proof (state)\nthis:\n  step\\<^sup>*\\<^sup>* s x\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n        s' \\<Longrightarrow>\n       final s' \\<or> (\\<exists>y. step s' y \\<and> reachable s')", "with \\<open>reachable s\\<close>"], ["proof (chain)\npicking this:\n  reachable s\n  step\\<^sup>*\\<^sup>* s x", "have \"reachable x\""], ["proof (prove)\nusing this:\n  reachable s\n  step\\<^sup>*\\<^sup>* s x\n\ngoal (1 subgoal):\n 1. reachable x", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  step\\<^sup>*\\<^sup>* s\\<^sub>0 s\n  step\\<^sup>*\\<^sup>* s x\n\ngoal (1 subgoal):\n 1. step\\<^sup>*\\<^sup>* s\\<^sub>0 x", "by auto"], ["proof (state)\nthis:\n  reachable x\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n        s' \\<Longrightarrow>\n       final s' \\<or> (\\<exists>y. step s' y \\<and> reachable s')", "then"], ["proof (chain)\npicking this:\n  reachable x", "show ?case"], ["proof (prove)\nusing this:\n  reachable x\n\ngoal (1 subgoal):\n 1. final x \\<or> (\\<exists>y. step x y \\<and> reachable x)", "using no_deadlock[of x]"], ["proof (prove)\nusing this:\n  reachable x\n  \\<not> final x \\<Longrightarrow> \\<exists>cfg'. step x cfg'\n\ngoal (1 subgoal):\n 1. final x \\<or> (\\<exists>y. step x y \\<and> reachable x)", "by auto"], ["proof (state)\nthis:\n  final x \\<or> (\\<exists>y. step x y \\<and> reachable x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s'.\n     final s' \\<and>\n     (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s s'\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "then"], ["proof (chain)\npicking this:\n  \\<exists>s'.\n     final s' \\<and>\n     (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s s'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s'.\n     final s' \\<and>\n     (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s s'\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>final (a, aa, b);\n        (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n         (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            final (a, aa, b) \\<and>\n                            step\\<^sup>*\\<^sup>* s (a, aa, b)", "apply (intro exI conjI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>final (a, aa, b);\n        (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n         (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> step\\<^sup>*\\<^sup>* s (a, aa, b)", "apply (rule mono_rtranclp[rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b ab ba.\n       \\<lbrakk>final (a, aa, b);\n        (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n         (a, aa, b);\n        ?x9 a aa b ab ba\\<rbrakk>\n       \\<Longrightarrow> step ab ba\n 2. \\<And>a aa b.\n       \\<lbrakk>final (a, aa, b);\n        (\\<lambda>s s'. step s s' \\<and> reachable s)\\<^sup>*\\<^sup>* s\n         (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> (?x9 a aa b)\\<^sup>*\\<^sup>* s (a, aa, b)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s'. final s' \\<and> step\\<^sup>*\\<^sup>* s s'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Fixed task list *)"], ["", "end"], ["", "(* Fixed number of workers *)"], ["", "end"], ["", "(* Commutative function *)"], ["", "text \\<open>The main theorems outside the locale:\\<close>"], ["", "thm comp_fun_commute.final_state_correct comp_fun_commute.termination"], ["", "end"], ["", "(* End of theory *)"]]}