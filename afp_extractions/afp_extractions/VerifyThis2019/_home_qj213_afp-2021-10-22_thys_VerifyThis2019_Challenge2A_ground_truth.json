{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019/Challenge2A.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019", "problem_names": ["lemma left_alt: \"left_spec j = (if has_left j then Some (the_left j) else None)\"", "lemma the_leftI: \"has_left j \\<Longrightarrow> the_left j < j \\<and> xs!the_left j < xs!j\"", "lemma the_left_decr[simp]: \"has_left i \\<Longrightarrow> the_left i < i\"", "lemma le_the_leftI:\n  assumes \"i\\<le>j\" \"xs!i < xs!j\"\n  shows \"i \\<le> the_left j\"", "lemma the_left_leI:  \n  assumes \"\\<forall>k. j<k \\<and> k<i \\<longrightarrow> \\<not>xs!k<xs!i\"\n  assumes \"has_left i\"\n  shows \"the_left i \\<le> j\"", "lemma set_der_stack_lt: \"k \\<in> set (der_stack i\\<^sub>0) \\<Longrightarrow> k<i\\<^sub>0\"", "lemma pop_Nil[simp]: \"pop [] v = []\"", "lemma pop_cons: \"pop (j#js) v = (if xs!j \\<ge> v then pop js v else j#js)\"", "theorem find_left_rl:\n  assumes \"i\\<^sub>0 < length xs\"\n  assumes \"i<i\\<^sub>0\"\n  assumes \"left_spec i\\<^sub>0 \\<le> Some i\"\n  shows \"if xs!i < xs!i\\<^sub>0 then left_spec i\\<^sub>0 = Some i\n         else left_spec i\\<^sub>0 \\<le> left_spec i\"", "lemma pop_aux: \"\\<lbrakk> k<i\\<^sub>0; i\\<^sub>0<length xs; left_spec i\\<^sub>0 \\<le> Some k \\<rbrakk> \\<Longrightarrow> pop (k # der_stack k) (xs!i\\<^sub>0) = der_stack i\\<^sub>0\"", "lemma swap_adhoc[simp]: \n  \"None = left i \\<longleftrightarrow> left i = None\"\n  \"Some j = left i \\<longleftrightarrow> left i = Some j\"", "lemma left_spec_None_iff[simp]: \"left_spec i = None \\<longleftrightarrow> \\<not>has_left i\"", "lemma [simp]: \"left_spec 0 = None\"", "lemma [simp]: \"has_left 0 = False\"", "lemma [simp]: \"der_stack 0 = []\"", "lemma algo_correct: \"all_left \\<le> SPEC all_left_spec\"", "lemma pop2_refine_aux: \"set stk \\<subseteq> {0..<length xs} \\<Longrightarrow> pop2 stk v \\<le> RETURN (pop stk v)\"", "lemma pop2_refine: \"(uncurry2 pop2, uncurry2 (RETURN ooo pop)) \\<in> [\\<lambda>((xs,stk),v). set stk \\<subseteq> {0..<length xs}]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas [sepref_fr_rules] = pop2_impl.refine[FCOMP pop2_refine]", "lemma algo_correct': \"(all_left, SPEC o all_left_spec) \n  \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>list_rel\\<rangle>nres_rel\"", "theorem algo_impl_correct:\n    \"(all_left_impl, SPEC o all_left_spec)\n    \\<in> (array_assn int_assn, array_assn int_assn) \\<rightarrow>\\<^sub>a array_assn (option_assn nat_assn)\"", "theorem algo_impl_correct': \"\n  <array_assn int_assn xs xsi> \n    all_left_impl xsi \n  <\\<lambda>lfi. \\<exists>\\<^sub>Alf. array_assn int_assn xs xsi \n        * array_assn (option_assn id_assn) lf lfi \n        * \\<up>(all_left_spec xs lf)>\\<^sub>t\""], "translations": [["", "lemma left_alt: \"left_spec j = (if has_left j then Some (the_left j) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.left_spec j =\n    (if local.has_left j then Some (local.the_left j) else None)", "by (auto simp: left_spec_def has_left_def the_left_def)"], ["", "lemma the_leftI: \"has_left j \\<Longrightarrow> the_left j < j \\<and> xs!the_left j < xs!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_left j \\<Longrightarrow>\n    local.the_left j < j \\<and> xs ! local.the_left j < xs ! j", "apply (clarsimp simp: has_left_def the_left_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < j; xs ! i < xs ! j\\<rbrakk>\n       \\<Longrightarrow> (GREATEST i. i < j \\<and> xs ! i < xs ! j)\n                         < j \\<and>\n                         xs ! (GREATEST i. i < j \\<and> xs ! i < xs ! j)\n                         < xs ! j", "by (metis (no_types, lifting) GreatestI_nat less_le_not_le nat_le_linear pinf(5))"], ["", "lemma the_left_decr[simp]: \"has_left i \\<Longrightarrow> the_left i < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_left i \\<Longrightarrow> local.the_left i < i", "by (simp add: the_leftI)"], ["", "lemma le_the_leftI:\n  assumes \"i\\<le>j\" \"xs!i < xs!j\"\n  shows \"i \\<le> the_left j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> local.the_left j", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> j\n  xs ! i < xs ! j\n\ngoal (1 subgoal):\n 1. i \\<le> local.the_left j", "unfolding the_left_def"], ["proof (prove)\nusing this:\n  i \\<le> j\n  xs ! i < xs ! j\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST i. i < j \\<and> xs ! i < xs ! j)", "by (metis (no_types, lifting)\n      Greatest_le_nat le_less_linear less_imp_not_less less_irrefl\n      order.not_eq_order_implies_strict)"], ["", "lemma the_left_leI:  \n  assumes \"\\<forall>k. j<k \\<and> k<i \\<longrightarrow> \\<not>xs!k<xs!i\"\n  assumes \"has_left i\"\n  shows \"the_left i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.the_left i \\<le> j", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>k. j < k \\<and> k < i \\<longrightarrow> \\<not> xs ! k < xs ! i\n  local.has_left i\n\ngoal (1 subgoal):\n 1. local.the_left i \\<le> j", "unfolding the_left_def has_left_def"], ["proof (prove)\nusing this:\n  \\<forall>k. j < k \\<and> k < i \\<longrightarrow> \\<not> xs ! k < xs ! i\n  \\<exists>ia<i. xs ! ia < xs ! i\n\ngoal (1 subgoal):\n 1. (GREATEST ia. ia < i \\<and> xs ! ia < xs ! i) \\<le> j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>k.\n                   j < k \\<and> k < i \\<longrightarrow>\n                   \\<not> xs ! k < xs ! i;\n        ia < i; xs ! ia < xs ! i\\<rbrakk>\n       \\<Longrightarrow> (GREATEST ia. ia < i \\<and> xs ! ia < xs ! i)\n                         \\<le> j", "by (metis (full_types) the_leftI assms(2) not_le the_left_def)"], ["", "subsubsection \\<open>Derived Stack\\<close>"], ["", "text \\<open>We note that the stack in the algorithm doesn't contain any \n  extra information. It can be derived from the left neighbours that have been \n  computed so far:\n  The first element of the stack is the current index - 1, and each next element is\n  the nearest left smaller value of the previous element:\n\\<close>"], ["", "fun der_stack where\n  \"der_stack i = (if has_left i then the_left i # der_stack (the_left i) else [])\""], ["", "declare der_stack.simps[simp del]"], ["", "text \\<open>\n  Although the refinement framework would allow us to phrase the \n  algorithm without a stack first, and then introduce the stack in a subsequent \n  refinement step (or omit it altogether), for simplicity of presentation, we decided\n  to model the algorithm with a stack in first place. However, the invariant will account for\n  the stack being derived.\n\\<close>"], ["", "lemma set_der_stack_lt: \"k \\<in> set (der_stack i\\<^sub>0) \\<Longrightarrow> k<i\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set (local.der_stack i\\<^sub>0) \\<Longrightarrow> k < i\\<^sub>0", "apply (induction i\\<^sub>0 rule: der_stack.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>local.has_left i;\n                 k \\<in> set (local.der_stack (local.the_left i))\\<rbrakk>\n                \\<Longrightarrow> k < local.the_left i;\n        k \\<in> set (local.der_stack i)\\<rbrakk>\n       \\<Longrightarrow> k < i", "apply (subst (asm) der_stack.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>local.has_left i;\n                 k \\<in> set (local.der_stack (local.the_left i))\\<rbrakk>\n                \\<Longrightarrow> k < local.the_left i;\n        k \\<in> set (if local.has_left i\n                     then local.the_left i #\n                          local.der_stack (local.the_left i)\n                     else [])\\<rbrakk>\n       \\<Longrightarrow> k < i", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>k < local.the_left i; local.has_left i;\n        k \\<in> set (local.der_stack (local.the_left i))\\<rbrakk>\n       \\<Longrightarrow> k < i", "using less_trans the_leftI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  local.has_left ?j \\<Longrightarrow>\n  local.the_left ?j < ?j \\<and> xs ! local.the_left ?j < xs ! ?j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>k < local.the_left i; local.has_left i;\n        k \\<in> set (local.der_stack (local.the_left i))\\<rbrakk>\n       \\<Longrightarrow> k < i", "by blast"], ["", "subsection \\<open>Abstract Implementation\\<close>"], ["", "text \\<open>We first implement the algorithm on lists. \n  The assertions that we annotated into the algorithm ensure\n  that all list index accesses are in bounds.\n\\<close>"], ["", "definition \"pop stk v \\<equiv> dropWhile (\\<lambda>j. xs!j\\<ge>v) stk\""], ["", "lemma pop_Nil[simp]: \"pop [] v = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.pop [] v = []", "by (auto simp: pop_def)"], ["", "lemma pop_cons: \"pop (j#js) v = (if xs!j \\<ge> v then pop js v else j#js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.pop (j # js) v =\n    (if v \\<le> xs ! j then local.pop js v else j # js)", "by (simp add: pop_def)"], ["", "definition \"all_left \\<equiv> doN {\n  (_,lf) \\<leftarrow> nfoldli [0..<length xs] (\\<lambda>_. True) (\\<lambda>i (stk,lf). doN {\n    ASSERT (set stk \\<subseteq> {0..<length xs} );\n    let stk = pop stk (xs!i);\n    ASSERT (stk = der_stack i);\n    ASSERT (i<length lf);\n    if (stk = []) then doN {\n      let lf = lf[i:=None];\n      RETURN (i#stk,lf)\n    } else doN {\n      let lf = lf[i:= Some (hd stk)];\n      RETURN (i#stk,lf)\n    }\n  }) ([],replicate (length xs) None);\n  RETURN lf\n}\""], ["", "subsection \\<open>Correctness Proof\\<close>"], ["", "subsubsection \\<open>Popping From the Stack\\<close>"], ["", "text \\<open>We show that the abstract algorithm implements its specification.\n  The main idea here is the popping of the stack.\n  Top obtain a left smaller value, it is enough to follow the left-values of\n  the left-neighbour, until we have found the value or there are no more left-values.\n  \n  The following theorem formalizes this idea:\n\\<close>"], ["", "theorem find_left_rl:\n  assumes \"i\\<^sub>0 < length xs\"\n  assumes \"i<i\\<^sub>0\"\n  assumes \"left_spec i\\<^sub>0 \\<le> Some i\"\n  shows \"if xs!i < xs!i\\<^sub>0 then left_spec i\\<^sub>0 = Some i\n         else left_spec i\\<^sub>0 \\<le> left_spec i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if xs ! i < xs ! i\\<^sub>0 then local.left_spec i\\<^sub>0 = Some i\n    else local.left_spec i\\<^sub>0 \\<le> local.left_spec i", "using assms"], ["proof (prove)\nusing this:\n  i\\<^sub>0 < length xs\n  i < i\\<^sub>0\n  local.left_spec i\\<^sub>0 \\<le> Some i\n\ngoal (1 subgoal):\n 1. if xs ! i < xs ! i\\<^sub>0 then local.left_spec i\\<^sub>0 = Some i\n    else local.left_spec i\\<^sub>0 \\<le> local.left_spec i", "apply (simp; intro impI conjI; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs; i < i\\<^sub>0;\n     local.left_spec i\\<^sub>0 \\<le> Some i\\<rbrakk>\n    \\<Longrightarrow> local.left_spec i\\<^sub>0 = Some i\n 2. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.left_spec i\\<^sub>0 \\<le> Some i\\<rbrakk>\n    \\<Longrightarrow> local.left_spec i\\<^sub>0 \\<le> local.left_spec i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs; i < i\\<^sub>0;\n     local.left_spec i\\<^sub>0 \\<le> Some i\\<rbrakk>\n    \\<Longrightarrow> local.left_spec i\\<^sub>0 = Some i", "apply (auto simp: left_alt split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs; i < i\\<^sub>0;\n     local.has_left i\\<^sub>0; local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.the_left i\\<^sub>0 = i\n 2. \\<lbrakk>xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs; i < i\\<^sub>0;\n     \\<not> local.has_left i\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: le_antisym le_the_leftI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs; i < i\\<^sub>0;\n     \\<not> local.has_left i\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp: has_left_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.left_spec i\\<^sub>0 \\<le> Some i\\<rbrakk>\n    \\<Longrightarrow> local.left_spec i\\<^sub>0 \\<le> local.left_spec i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.left_spec i\\<^sub>0 \\<le> Some i\\<rbrakk>\n    \\<Longrightarrow> local.left_spec i\\<^sub>0 \\<le> local.left_spec i", "apply (auto simp: left_alt split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.has_left i\\<^sub>0;\n     local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.has_left i\n 2. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.has_left i\\<^sub>0;\n     local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.the_left i\\<^sub>0 \\<le> local.the_left i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.has_left i\\<^sub>0;\n     local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.has_left i", "apply (drule the_leftI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.the_left i\\<^sub>0 \\<le> i;\n     local.the_left i\\<^sub>0 < i\\<^sub>0 \\<and>\n     xs ! local.the_left i\\<^sub>0 < xs ! i\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> local.has_left i", "using nat_less_le"], ["proof (prove)\nusing this:\n  (?m < ?n) = (?m \\<le> ?n \\<and> ?m \\<noteq> ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.the_left i\\<^sub>0 \\<le> i;\n     local.the_left i\\<^sub>0 < i\\<^sub>0 \\<and>\n     xs ! local.the_left i\\<^sub>0 < xs ! i\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> local.has_left i", "by (auto simp: has_left_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.has_left i\\<^sub>0;\n     local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.the_left i\\<^sub>0 \\<le> local.the_left i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.has_left i\\<^sub>0;\n     local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.the_left i\\<^sub>0 \\<le> local.the_left i", "using le_the_leftI the_leftI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; xs ! ?i < xs ! ?j\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> local.the_left ?j\n  local.has_left ?j \\<Longrightarrow>\n  local.the_left ?j < ?j \\<and> xs ! local.the_left ?j < xs ! ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> xs ! i < xs ! i\\<^sub>0; i\\<^sub>0 < length xs;\n     i < i\\<^sub>0; local.has_left i\\<^sub>0;\n     local.the_left i\\<^sub>0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> local.the_left i\\<^sub>0 \\<le> local.the_left i", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Using this lemma, we can show that the stack popping procedure preserves the form of the stack.\\<close>"], ["", "lemma pop_aux: \"\\<lbrakk> k<i\\<^sub>0; i\\<^sub>0<length xs; left_spec i\\<^sub>0 \\<le> Some k \\<rbrakk> \\<Longrightarrow> pop (k # der_stack k) (xs!i\\<^sub>0) = der_stack i\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i\\<^sub>0; i\\<^sub>0 < length xs;\n     local.left_spec i\\<^sub>0 \\<le> Some k\\<rbrakk>\n    \\<Longrightarrow> local.pop (k # local.der_stack k) (xs ! i\\<^sub>0) =\n                      local.der_stack i\\<^sub>0", "apply (induction k rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m < i\\<^sub>0 \\<longrightarrow>\n                   i\\<^sub>0 < length xs \\<longrightarrow>\n                   local.left_spec i\\<^sub>0 \\<le> Some m \\<longrightarrow>\n                   local.pop (m # local.der_stack m) (xs ! i\\<^sub>0) =\n                   local.der_stack i\\<^sub>0;\n        n < i\\<^sub>0; i\\<^sub>0 < length xs;\n        local.left_spec i\\<^sub>0 \\<le> Some n\\<rbrakk>\n       \\<Longrightarrow> local.pop (n # local.der_stack n)\n                          (xs ! i\\<^sub>0) =\n                         local.der_stack i\\<^sub>0", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   local.left_spec i\\<^sub>0 \\<le> Some m \\<longrightarrow>\n                   local.pop (m # local.der_stack m) (xs ! i\\<^sub>0) =\n                   local.der_stack i\\<^sub>0;\n        n < i\\<^sub>0; i\\<^sub>0 < length xs;\n        local.left_spec i\\<^sub>0 \\<le> Some n\\<rbrakk>\n       \\<Longrightarrow> local.pop (n # local.der_stack n)\n                          (xs ! i\\<^sub>0) =\n                         local.der_stack i\\<^sub>0", "by (smt der_stack.simps left_alt pop_def the_leftI dropWhile.simps(1) find_left_rl leD less_option_None_Some option.inject pop_cons)"], ["", "subsubsection \\<open>Main Algorithm\\<close>"], ["", "text \\<open>Ad-Hoc lemmas\\<close>"], ["", "lemma swap_adhoc[simp]: \n  \"None = left i \\<longleftrightarrow> left i = None\"\n  \"Some j = left i \\<longleftrightarrow> left i = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None = left i) = (left i = None) &&&\n    (Some j = left i) = (left i = Some j)", "by auto"], ["", "lemma left_spec_None_iff[simp]: \"left_spec i = None \\<longleftrightarrow> \\<not>has_left i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.left_spec i = None) = (\\<not> local.has_left i)", "by (auto simp: left_alt)"], ["", "lemma [simp]: \"left_spec 0 = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.left_spec 0 = None", "by (auto simp: left_spec_def)"], ["", "lemma [simp]: \"has_left 0 = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.has_left 0 = False", "by (simp add: has_left_def)"], ["", "lemma [simp]: \"der_stack 0 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.der_stack 0 = []", "by (subst der_stack.simps) auto"], ["", "lemma algo_correct: \"all_left \\<le> SPEC all_left_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.all_left \\<le> SPEC local.all_left_spec", "unfolding all_left_def all_left_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<length xs] (\\<lambda>_. True)\n     (\\<lambda>i (stk, lf).\n         ASSERT (set stk \\<subseteq> {0..<length xs}) \\<bind>\n         (\\<lambda>_.\n             let stk = local.pop stk (xs ! i)\n             in ASSERT (stk = local.der_stack i) \\<bind>\n                (\\<lambda>_.\n                    ASSERT (i < length lf) \\<bind>\n                    (\\<lambda>_.\n                        if stk = []\n                        then let lf = lf[i := None] in RETURN (i # stk, lf)\n                        else let lf = lf[i := Some (hd stk)]\n                             in RETURN (i # stk, lf)))))\n     ([], replicate (length xs) None) \\<bind>\n    (\\<lambda>(uu_, lf). RETURN lf)\n    \\<le> SPEC\n           (\\<lambda>lf.\n               length lf = length xs \\<and>\n               (\\<forall>i<length xs. lf ! i = local.left_spec i))", "apply (refine_vcg nfoldli_upt_rule[where I=\"\n    \\<lambda>k (stk,lf). \n      (length lf = length xs)\n    \\<and> (\\<forall>i<k. lf!i = left_spec i)\n    \\<and> (case k of Suc kk \\<Rightarrow> stk = kk#der_stack kk | _ \\<Rightarrow>  stk=[])  \n      \"])"], ["proof (prove)\ngoal (17 subgoals):\n 1. 0 \\<le> length xs\n 2. \\<And>x1 x2.\n       ([], replicate (length xs) None) = (x1, x2) \\<Longrightarrow>\n       length x2 = length xs\n 3. \\<And>x1 x2 i.\n       \\<lbrakk>([], replicate (length xs) None) = (x1, x2); i < 0\\<rbrakk>\n       \\<Longrightarrow> x2 ! i = local.left_spec i\n 4. \\<And>x1 x2.\n       ([], replicate (length xs) None) = (x1, x2) \\<Longrightarrow>\n       case 0 of 0 \\<Rightarrow> x1 = []\n       | Suc kk \\<Rightarrow> x1 = kk # local.der_stack kk\n 5. \\<And>i \\<sigma> a b.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        case \\<sigma> of\n        (stk, lf) \\<Rightarrow>\n          length lf = length xs \\<and>\n          (\\<forall>ia<i. lf ! ia = local.left_spec ia) \\<and>\n          (case i of 0 \\<Rightarrow> stk = []\n           | Suc kk \\<Rightarrow> stk = kk # local.der_stack kk);\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> set a \\<subseteq> {0..<length xs}\n 6. \\<And>i \\<sigma> a b.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        case \\<sigma> of\n        (stk, lf) \\<Rightarrow>\n          length lf = length xs \\<and>\n          (\\<forall>ia<i. lf ! ia = local.left_spec ia) \\<and>\n          (case i of 0 \\<Rightarrow> stk = []\n           | Suc kk \\<Rightarrow> stk = kk # local.der_stack kk);\n        True; \\<sigma> = (a, b); set a \\<subseteq> {0..<length xs}\\<rbrakk>\n       \\<Longrightarrow> local.pop a (xs ! i) = local.der_stack i\n 7. \\<And>i \\<sigma> a b.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        case \\<sigma> of\n        (stk, lf) \\<Rightarrow>\n          length lf = length xs \\<and>\n          (\\<forall>ia<i. lf ! ia = local.left_spec ia) \\<and>\n          (case i of 0 \\<Rightarrow> stk = []\n           | Suc kk \\<Rightarrow> stk = kk # local.der_stack kk);\n        True; \\<sigma> = (a, b); set a \\<subseteq> {0..<length xs};\n        local.pop a (xs ! i) = local.der_stack i\\<rbrakk>\n       \\<Longrightarrow> i < length b\n 8. \\<And>i \\<sigma> a b x1 x2.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        case \\<sigma> of\n        (stk, lf) \\<Rightarrow>\n          length lf = length xs \\<and>\n          (\\<forall>ia<i. lf ! ia = local.left_spec ia) \\<and>\n          (case i of 0 \\<Rightarrow> stk = []\n           | Suc kk \\<Rightarrow> stk = kk # local.der_stack kk);\n        True; \\<sigma> = (a, b); set a \\<subseteq> {0..<length xs};\n        local.pop a (xs ! i) = local.der_stack i; i < length b;\n        local.pop a (xs ! i) = [];\n        (i # local.pop a (xs ! i), b[i := None]) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> length x2 = length xs\n 9. \\<And>i \\<sigma> a b x1 x2 ia.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        case \\<sigma> of\n        (stk, lf) \\<Rightarrow>\n          length lf = length xs \\<and>\n          (\\<forall>ia<i. lf ! ia = local.left_spec ia) \\<and>\n          (case i of 0 \\<Rightarrow> stk = []\n           | Suc kk \\<Rightarrow> stk = kk # local.der_stack kk);\n        True; \\<sigma> = (a, b); set a \\<subseteq> {0..<length xs};\n        local.pop a (xs ! i) = local.der_stack i; i < length b;\n        local.pop a (xs ! i) = [];\n        (i # local.pop a (xs ! i), b[i := None]) = (x1, x2);\n        ia < i + 1\\<rbrakk>\n       \\<Longrightarrow> x2 ! ia = local.left_spec ia\n 10. \\<And>i \\<sigma> a b x1 x2.\n        \\<lbrakk>0 \\<le> i; i < length xs;\n         case \\<sigma> of\n         (stk, lf) \\<Rightarrow>\n           length lf = length xs \\<and>\n           (\\<forall>ia<i. lf ! ia = local.left_spec ia) \\<and>\n           (case i of 0 \\<Rightarrow> stk = []\n            | Suc kk \\<Rightarrow> stk = kk # local.der_stack kk);\n         True; \\<sigma> = (a, b); set a \\<subseteq> {0..<length xs};\n         local.pop a (xs ! i) = local.der_stack i; i < length b;\n         local.pop a (xs ! i) = [];\n         (i # local.pop a (xs ! i), b[i := None]) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> case i + 1 of 0 \\<Rightarrow> x1 = []\n                          | Suc kk \\<Rightarrow>\n                              x1 = kk # local.der_stack kk\nA total of 17 subgoals...", "apply (vc_solve split: nat.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ba x2 x.\n       \\<lbrakk>Suc x2 < length xs; x \\<in> set (local.der_stack x2);\n        length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 2. \\<And>ba x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> local.pop (x2 # local.der_stack x2) (xs ! Suc x2) =\n                         local.der_stack (Suc x2)\n 3. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        [] = local.der_stack (Suc x2);\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) = [];\n        ia < Suc (Suc x2); Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 := None] ! ia = local.left_spec ia\n 4. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) =\n        local.der_stack (Suc x2);\n        local.der_stack (Suc x2) \\<noteq> []; ia < Suc (Suc x2);\n        Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 :=\n                              Some (hd (local.der_stack (Suc x2)))] !\n                         ia =\n                         local.left_spec ia", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc x2_ < length xs; x_ \\<in> set (local.der_stack x2_);\n     length ba_ = length xs;\n     \\<forall>i<Suc x2_. ba_ ! i = local.left_spec i\\<rbrakk>\n    \\<Longrightarrow> x_ < length xs", "using set_der_stack_lt"], ["proof (prove)\nusing this:\n  ?k \\<in> set (local.der_stack ?i\\<^sub>0) \\<Longrightarrow>\n  ?k < ?i\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc x2_ < length xs; x_ \\<in> set (local.der_stack x2_);\n     length ba_ = length xs;\n     \\<forall>i<Suc x2_. ba_ ! i = local.left_spec i\\<rbrakk>\n    \\<Longrightarrow> x_ < length xs", "by fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ba x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> local.pop (x2 # local.der_stack x2) (xs ! Suc x2) =\n                         local.der_stack (Suc x2)\n 2. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        [] = local.der_stack (Suc x2);\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) = [];\n        ia < Suc (Suc x2); Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 := None] ! ia = local.left_spec ia\n 3. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) =\n        local.der_stack (Suc x2);\n        local.der_stack (Suc x2) \\<noteq> []; ia < Suc (Suc x2);\n        Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 :=\n                              Some (hd (local.der_stack (Suc x2)))] !\n                         ia =\n                         local.left_spec ia", "subgoal for lf k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (local.der_stack k) \\<subseteq> {0..<length xs};\n     Suc k < length xs; length lf = length xs;\n     \\<forall>i<Suc k. lf ! i = local.left_spec i\\<rbrakk>\n    \\<Longrightarrow> local.pop (k # local.der_stack k) (xs ! Suc k) =\n                      local.der_stack (Suc k)", "by (metis left_alt less_Suc_eq_le less_eq_option_None less_eq_option_Some nat_in_between_eq(2) pop_aux the_leftI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        [] = local.der_stack (Suc x2);\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) = [];\n        ia < Suc (Suc x2); Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 := None] ! ia = local.left_spec ia\n 2. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) =\n        local.der_stack (Suc x2);\n        local.der_stack (Suc x2) \\<noteq> []; ia < Suc (Suc x2);\n        Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 :=\n                              Some (hd (local.der_stack (Suc x2)))] !\n                         ia =\n                         local.left_spec ia", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (local.der_stack x2_) \\<subseteq> {0..<length xs};\n     [] = local.der_stack (Suc x2_);\n     local.pop (x2_ # local.der_stack x2_) (xs ! Suc x2_) = [];\n     ia_ < Suc (Suc x2_); Suc x2_ < length xs; length ba_ = length xs;\n     \\<forall>i<Suc x2_. ba_ ! i = local.left_spec i\\<rbrakk>\n    \\<Longrightarrow> ba_[Suc x2_ := None] ! ia_ = local.left_spec ia_", "by (metis der_stack.simps left_alt less_Suc_eq list.distinct(1) nth_list_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba ia x2.\n       \\<lbrakk>set (local.der_stack x2) \\<subseteq> {0..<length xs};\n        local.pop (x2 # local.der_stack x2) (xs ! Suc x2) =\n        local.der_stack (Suc x2);\n        local.der_stack (Suc x2) \\<noteq> []; ia < Suc (Suc x2);\n        Suc x2 < length xs; length ba = length xs;\n        \\<forall>i<Suc x2. ba ! i = local.left_spec i\\<rbrakk>\n       \\<Longrightarrow> ba[Suc x2 :=\n                              Some (hd (local.der_stack (Suc x2)))] !\n                         ia =\n                         local.left_spec ia", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (local.der_stack x2_) \\<subseteq> {0..<length xs};\n     local.pop (x2_ # local.der_stack x2_) (xs ! Suc x2_) =\n     local.der_stack (Suc x2_);\n     local.der_stack (Suc x2_) \\<noteq> []; ia_ < Suc (Suc x2_);\n     Suc x2_ < length xs; length ba_ = length xs;\n     \\<forall>i<Suc x2_. ba_ ! i = local.left_spec i\\<rbrakk>\n    \\<Longrightarrow> ba_[Suc x2_ :=\n                            Some (hd (local.der_stack (Suc x2_)))] !\n                      ia_ =\n                      local.left_spec ia_", "by (metis der_stack.simps left_alt less_Suc_eq list.sel(1) nth_list_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Implementation With Arrays\\<close>"], ["", "text \\<open>We refine the algorithm to use actual arrays for the input and output. \n  The stack remains a list, as pushing and popping from a (functional) list is efficient.\n\\<close>"], ["", "subsubsection \\<open>Implementation of Pop\\<close>"], ["", "text \\<open>In a first step, we refine the pop function to an explicit loop.\\<close>"], ["", "definition \"pop2 stk v \\<equiv> \n  monadic_WHILEIT \n    (\\<lambda>_. set stk \\<subseteq> {0..<length xs}) \n    (\\<lambda>[] \\<Rightarrow> RETURN False | k#stk \\<Rightarrow> doN { ASSERT (k<length xs); RETURN (v \\<le> xs!k) })\n    (\\<lambda>stk. mop_list_tl stk)\n    stk\""], ["", "lemma pop2_refine_aux: \"set stk \\<subseteq> {0..<length xs} \\<Longrightarrow> pop2 stk v \\<le> RETURN (pop stk v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set stk \\<subseteq> {0..<length xs} \\<Longrightarrow>\n    local.pop2 stk v \\<le> RETURN (local.pop stk v)", "apply (induction stk)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> {0..<length xs} \\<Longrightarrow>\n    local.pop2 [] v \\<le> RETURN (local.pop [] v)\n 2. \\<And>a stk.\n       \\<lbrakk>set stk \\<subseteq> {0..<length xs} \\<Longrightarrow>\n                local.pop2 stk v \\<le> RETURN (local.pop stk v);\n        set (a # stk) \\<subseteq> {0..<length xs}\\<rbrakk>\n       \\<Longrightarrow> local.pop2 (a # stk) v\n                         \\<le> RETURN (local.pop (a # stk) v)", "unfolding pop_def pop2_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> {0..<length xs} \\<Longrightarrow>\n    monadic_WHILEIT (\\<lambda>_. set [] \\<subseteq> {0..<length xs})\n     (\\<lambda>x.\n         case x of [] \\<Rightarrow> RETURN False\n         | k # stk \\<Rightarrow>\n             ASSERT (k < length xs) \\<bind>\n             (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n     mop_list_tl []\n    \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) [])\n 2. \\<And>a stk.\n       \\<lbrakk>set stk \\<subseteq> {0..<length xs} \\<Longrightarrow>\n                monadic_WHILEIT\n                 (\\<lambda>_. set stk \\<subseteq> {0..<length xs})\n                 (\\<lambda>x.\n                     case x of [] \\<Rightarrow> RETURN False\n                     | k # stk \\<Rightarrow>\n                         ASSERT (k < length xs) \\<bind>\n                         (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n                 mop_list_tl stk\n                \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) stk);\n        set (a # stk) \\<subseteq> {0..<length xs}\\<rbrakk>\n       \\<Longrightarrow> monadic_WHILEIT\n                          (\\<lambda>_.\n                              set (a # stk) \\<subseteq> {0..<length xs})\n                          (\\<lambda>x.\n                              case x of [] \\<Rightarrow> RETURN False\n                              | k # stk \\<Rightarrow>\n                                  ASSERT (k < length xs) \\<bind>\n                                  (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n                          mop_list_tl (a # stk)\n                         \\<le> RETURN\n                                (dropWhile (\\<lambda>j. v \\<le> xs ! j)\n                                  (a # stk))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<subseteq> {0..<length xs} \\<Longrightarrow>\n    monadic_WHILEIT (\\<lambda>_. set [] \\<subseteq> {0..<length xs})\n     (\\<lambda>x.\n         case x of [] \\<Rightarrow> RETURN False\n         | k # stk \\<Rightarrow>\n             ASSERT (k < length xs) \\<bind>\n             (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n     mop_list_tl []\n    \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) [])", "apply (subst monadic_WHILEIT_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<subseteq> {0..<length xs} \\<Longrightarrow>\n    ASSERT (set [] \\<subseteq> {0..<length xs}) \\<bind>\n    (\\<lambda>_.\n        (case [] of [] \\<Rightarrow> RETURN False\n         | k # stk \\<Rightarrow>\n             ASSERT (k < length xs) \\<bind>\n             (\\<lambda>_. RETURN (v \\<le> xs ! k))) \\<bind>\n        (\\<lambda>bb.\n            if bb\n            then mop_list_tl [] \\<bind>\n                 monadic_WHILEIT\n                  (\\<lambda>_. set [] \\<subseteq> {0..<length xs})\n                  (case_list (RETURN False)\n                    (\\<lambda>k stk.\n                        ASSERT (k < length xs) \\<bind>\n                        (\\<lambda>_. RETURN (v \\<le> xs ! k))))\n                  mop_list_tl\n            else RETURN []))\n    \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) [])", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a stk.\n       \\<lbrakk>set stk \\<subseteq> {0..<length xs} \\<Longrightarrow>\n                monadic_WHILEIT\n                 (\\<lambda>_. set stk \\<subseteq> {0..<length xs})\n                 (\\<lambda>x.\n                     case x of [] \\<Rightarrow> RETURN False\n                     | k # stk \\<Rightarrow>\n                         ASSERT (k < length xs) \\<bind>\n                         (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n                 mop_list_tl stk\n                \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) stk);\n        set (a # stk) \\<subseteq> {0..<length xs}\\<rbrakk>\n       \\<Longrightarrow> monadic_WHILEIT\n                          (\\<lambda>_.\n                              set (a # stk) \\<subseteq> {0..<length xs})\n                          (\\<lambda>x.\n                              case x of [] \\<Rightarrow> RETURN False\n                              | k # stk \\<Rightarrow>\n                                  ASSERT (k < length xs) \\<bind>\n                                  (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n                          mop_list_tl (a # stk)\n                         \\<le> RETURN\n                                (dropWhile (\\<lambda>j. v \\<le> xs ! j)\n                                  (a # stk))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set stk_ \\<subseteq> {0..<length xs} \\<Longrightarrow>\n             monadic_WHILEIT\n              (\\<lambda>_. set stk_ \\<subseteq> {0..<length xs})\n              (\\<lambda>x.\n                  case x of [] \\<Rightarrow> RETURN False\n                  | k # stk \\<Rightarrow>\n                      ASSERT (k < length xs) \\<bind>\n                      (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n              mop_list_tl stk_\n             \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) stk_);\n     set (a_ # stk_) \\<subseteq> {0..<length xs}\\<rbrakk>\n    \\<Longrightarrow> monadic_WHILEIT\n                       (\\<lambda>_.\n                           set (a_ # stk_) \\<subseteq> {0..<length xs})\n                       (\\<lambda>x.\n                           case x of [] \\<Rightarrow> RETURN False\n                           | k # stk \\<Rightarrow>\n                               ASSERT (k < length xs) \\<bind>\n                               (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n                       mop_list_tl (a_ # stk_)\n                      \\<le> RETURN\n                             (dropWhile (\\<lambda>j. v \\<le> xs ! j)\n                               (a_ # stk_))", "apply (subst monadic_WHILEIT_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set stk_ \\<subseteq> {0..<length xs} \\<Longrightarrow>\n             monadic_WHILEIT\n              (\\<lambda>_. set stk_ \\<subseteq> {0..<length xs})\n              (\\<lambda>x.\n                  case x of [] \\<Rightarrow> RETURN False\n                  | k # stk \\<Rightarrow>\n                      ASSERT (k < length xs) \\<bind>\n                      (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n              mop_list_tl stk_\n             \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) stk_);\n     set (a_ # stk_) \\<subseteq> {0..<length xs}\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (set (a_ # stk_) \\<subseteq> {0..<length xs}) \\<bind>\n                      (\\<lambda>_.\n                          (case a_ # stk_ of [] \\<Rightarrow> RETURN False\n                           | k # stk \\<Rightarrow>\n                               ASSERT (k < length xs) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN (v \\<le> xs ! k))) \\<bind>\n                          (\\<lambda>bb.\n                              if bb\n                              then mop_list_tl (a_ # stk_) \\<bind>\n                                   monadic_WHILEIT\n                                    (\\<lambda>_.\n  set (a_ # stk_) \\<subseteq> {0..<length xs})\n                                    (case_list (RETURN False)\n(\\<lambda>k stk.\n    ASSERT (k < length xs) \\<bind> (\\<lambda>_. RETURN (v \\<le> xs ! k))))\n                                    mop_list_tl\n                              else RETURN (a_ # stk_)))\n                      \\<le> RETURN\n                             (dropWhile (\\<lambda>j. v \\<le> xs ! j)\n                               (a_ # stk_))", "unfolding mop_list_tl_def op_list_tl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set stk_ \\<subseteq> {0..<length xs} \\<Longrightarrow>\n             monadic_WHILEIT\n              (\\<lambda>_. set stk_ \\<subseteq> {0..<length xs})\n              (\\<lambda>x.\n                  case x of [] \\<Rightarrow> RETURN False\n                  | k # stk \\<Rightarrow>\n                      ASSERT (k < length xs) \\<bind>\n                      (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n              (mop pre_list_tl (RETURN \\<circ> tl)) stk_\n             \\<le> RETURN (dropWhile (\\<lambda>j. v \\<le> xs ! j) stk_);\n     set (a_ # stk_) \\<subseteq> {0..<length xs}\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (set (a_ # stk_) \\<subseteq> {0..<length xs}) \\<bind>\n                      (\\<lambda>_.\n                          (case a_ # stk_ of [] \\<Rightarrow> RETURN False\n                           | k # stk \\<Rightarrow>\n                               ASSERT (k < length xs) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN (v \\<le> xs ! k))) \\<bind>\n                          (\\<lambda>bb.\n                              if bb\n                              then mop pre_list_tl (RETURN \\<circ> tl)\n                                    (a_ # stk_) \\<bind>\n                                   monadic_WHILEIT\n                                    (\\<lambda>_.\n  set (a_ # stk_) \\<subseteq> {0..<length xs})\n                                    (case_list (RETURN False)\n(\\<lambda>k stk.\n    ASSERT (k < length xs) \\<bind> (\\<lambda>_. RETURN (v \\<le> xs ! k))))\n                                    (mop pre_list_tl (RETURN \\<circ> tl))\n                              else RETURN (a_ # stk_)))\n                      \\<le> RETURN\n                             (dropWhile (\\<lambda>j. v \\<le> xs ! j)\n                               (a_ # stk_))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Context fixing the input \\<open>xs\\<close>.\\<close>"], ["", "text \\<open>The refinement lemma written in higher-order form.\\<close>"], ["", "lemma pop2_refine: \"(uncurry2 pop2, uncurry2 (RETURN ooo pop)) \\<in> [\\<lambda>((xs,stk),v). set stk \\<subseteq> {0..<length xs}]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 pop2, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> pop))\n    \\<in> [\\<lambda>((xs, stk), v).\n              set stk\n              \\<subseteq> {0..<length\n                                xs}]\\<^sub>f (Id \\<times>\\<^sub>r\n        Id) \\<times>\\<^sub>r\n       int_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "using pop2_refine_aux"], ["proof (prove)\nusing this:\n  set ?stk \\<subseteq> {0..<length ?xs} \\<Longrightarrow>\n  pop2 ?xs ?stk ?v \\<le> RETURN (pop ?xs ?stk ?v)\n\ngoal (1 subgoal):\n 1. (uncurry2 pop2, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> pop))\n    \\<in> [\\<lambda>((xs, stk), v).\n              set stk\n              \\<subseteq> {0..<length\n                                xs}]\\<^sub>f (Id \\<times>\\<^sub>r\n        Id) \\<times>\\<^sub>r\n       int_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: frefI nres_relI)"], ["", "text \\<open>Next, we use the Sepref tool to synthesize an implementation on arrays.\\<close>"], ["", "sepref_definition pop2_impl is \"uncurry2 pop2\" :: \"(array_assn id_assn)\\<^sup>k *\\<^sub>a (list_assn id_assn)\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 pop2)\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (list_assn nat_assn)\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "unfolding pop2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>xs stk v.\n          monadic_WHILEIT (\\<lambda>_. set stk \\<subseteq> {0..<length xs})\n           (\\<lambda>x.\n               case x of [] \\<Rightarrow> RETURN False\n               | k # stk \\<Rightarrow>\n                   ASSERT (k < length xs) \\<bind>\n                   (\\<lambda>_. RETURN (v \\<le> xs ! k)))\n           mop_list_tl stk))\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (list_assn nat_assn)\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = pop2_impl.refine[FCOMP pop2_refine]"], ["", "subsubsection \\<open>Implementation of Main Algorithm\\<close>"], ["", "sepref_definition all_left_impl is all_left :: \"(array_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn (option_assn id_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, all_left)\n    \\<in> (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn\n               (option_assn nat_assn)", "unfolding all_left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i (stk, lf).\n             ASSERT (set stk \\<subseteq> {0..<length xs}) \\<bind>\n             (\\<lambda>_.\n                 let stk = pop xs stk (xs ! i)\n                 in ASSERT (stk = der_stack xs i) \\<bind>\n                    (\\<lambda>_.\n                        ASSERT (i < length lf) \\<bind>\n                        (\\<lambda>_.\n                            if stk = []\n                            then let lf = lf[i := None]\n                                 in RETURN (i # stk, lf)\n                            else let lf = lf[i := Some (hd stk)]\n                                 in RETURN (i # stk, lf)))))\n         ([], replicate (length xs) None) \\<bind>\n        (\\<lambda>(uu_, lf). RETURN lf))\n    \\<in> (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn\n               (option_assn nat_assn)", "apply (rewrite at \"nfoldli _ _ _ (\\<hole>,_)\" HOL_list.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i (stk, lf).\n             ASSERT (set stk \\<subseteq> {0..<length xs}) \\<bind>\n             (\\<lambda>_.\n                 let stk = pop xs stk (xs ! i)\n                 in ASSERT (stk = der_stack xs i) \\<bind>\n                    (\\<lambda>_.\n                        ASSERT (i < length lf) \\<bind>\n                        (\\<lambda>_.\n                            if stk = []\n                            then let lf = lf[i := None]\n                                 in RETURN (i # stk, lf)\n                            else let lf = lf[i := Some (hd stk)]\n                                 in RETURN (i # stk, lf)))))\n         (op_HOL_list_empty, replicate (length xs) None) \\<bind>\n        (\\<lambda>(uu_, lf). RETURN lf))\n    \\<in> (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn\n               (option_assn nat_assn)", "apply (rewrite in \"nfoldli _ _ _ (_,\\<hole>)\" array_fold_custom_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i (stk, lf).\n             ASSERT (set stk \\<subseteq> {0..<length xs}) \\<bind>\n             (\\<lambda>_.\n                 let stk = pop xs stk (xs ! i)\n                 in ASSERT (stk = der_stack xs i) \\<bind>\n                    (\\<lambda>_.\n                        ASSERT (i < length lf) \\<bind>\n                        (\\<lambda>_.\n                            if stk = []\n                            then let lf = lf[i := None]\n                                 in RETURN (i # stk, lf)\n                            else let lf = lf[i := Some (hd stk)]\n                                 in RETURN (i # stk, lf)))))\n         (op_HOL_list_empty, op_array_replicate (length xs) None) \\<bind>\n        (\\<lambda>(uu_, lf). RETURN lf))\n    \\<in> (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn\n               (option_assn nat_assn)", "by sepref"], ["", "subsubsection \\<open>Correctness Theorem for Concrete Algorithm\\<close>"], ["", "text \\<open>We compose the correctness theorem and the refinement theorem, to get a correctness\n  theorem for the final implementation.\\<close>"], ["", "text \\<open>Abstract correctness theorem in higher-order form.\\<close>"], ["", "lemma algo_correct': \"(all_left, SPEC o all_left_spec) \n  \\<in> \\<langle>Id\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (all_left, SPEC \\<circ> all_left_spec)\n    \\<in> \\<langle>int_rel\\<rangle>list_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>option_rel\\<rangle>list_rel\\<rangle>nres_rel", "using algo_correct"], ["proof (prove)\nusing this:\n  all_left ?xs \\<le> SPEC (all_left_spec ?xs)\n\ngoal (1 subgoal):\n 1. (all_left, SPEC \\<circ> all_left_spec)\n    \\<in> \\<langle>int_rel\\<rangle>list_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>option_rel\\<rangle>list_rel\\<rangle>nres_rel", "by (auto simp: nres_relI)"], ["", "text \\<open>Main correctness theorem in higher-order form.\\<close>"], ["", "theorem algo_impl_correct:\n    \"(all_left_impl, SPEC o all_left_spec)\n    \\<in> (array_assn int_assn, array_assn int_assn) \\<rightarrow>\\<^sub>a array_assn (option_assn nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (all_left_impl, SPEC \\<circ> all_left_spec)\n    \\<in> (array_assn int_assn,\n           array_assn\n            int_assn) \\<rightarrow>\\<^sub>a array_assn\n       (option_assn nat_assn)", "using all_left_impl.refine[FCOMP algo_correct', simplified]"], ["proof (prove)\nusing this:\n  (all_left_impl, SPEC \\<circ> all_left_spec)\n  \\<in> (array_assn int_assn,\n         array_assn\n          int_assn) \\<rightarrow>\\<^sub>a array_assn (option_assn nat_assn)\n\ngoal (1 subgoal):\n 1. (all_left_impl, SPEC \\<circ> all_left_spec)\n    \\<in> (array_assn int_assn,\n           array_assn\n            int_assn) \\<rightarrow>\\<^sub>a array_assn\n       (option_assn nat_assn)", "."], ["", "text \\<open>Main correctness theorem as Hoare-Triple\\<close>"], ["", "theorem algo_impl_correct': \"\n  <array_assn int_assn xs xsi> \n    all_left_impl xsi \n  <\\<lambda>lfi. \\<exists>\\<^sub>Alf. array_assn int_assn xs xsi \n        * array_assn (option_assn id_assn) lf lfi \n        * \\<up>(all_left_spec xs lf)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <array_assn int_assn xs\n      xsi> all_left_impl\n            xsi <\\<lambda>r.\n                    \\<exists>\\<^sub>Alf.\n                       array_assn int_assn xs xsi *\n                       array_assn (option_assn nat_assn) lf r *\n                       \\<up> (all_left_spec xs lf)>\\<^sub>t", "apply (rule cons_rule[OF _ _ algo_impl_correct[to_hnr, THEN hn_refineD, unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. array_assn int_assn xs xsi \\<Longrightarrow>\\<^sub>A\n    hn_ctxt (fst (array_assn int_assn, array_assn int_assn)) ?x2 xsi\n 2. \\<And>x.\n       hn_ctxt (snd (array_assn int_assn, array_assn int_assn)) ?x2 xsi *\n       (\\<exists>\\<^sub>Axa.\n           array_assn (option_assn nat_assn) xa x *\n           \\<up> (RETURN xa \\<le> (SPEC \\<circ> all_left_spec) ?x2)) *\n       true \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Alf.\n           array_assn int_assn xs xsi *\n           array_assn (option_assn nat_assn) lf x *\n           \\<up> (all_left_spec xs lf)) *\n       true\n 3. nofail ((SPEC \\<circ> all_left_spec) ?x2)", "apply (simp add: hn_ctxt_def, rule ent_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       hn_ctxt (snd (array_assn int_assn, array_assn int_assn)) xs xsi *\n       (\\<exists>\\<^sub>Axa.\n           array_assn (option_assn nat_assn) xa x *\n           \\<up> (RETURN xa \\<le> (SPEC \\<circ> all_left_spec) xs)) *\n       true \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Alf.\n           array_assn int_assn xs xsi *\n           array_assn (option_assn nat_assn) lf x *\n           \\<up> (all_left_spec xs lf)) *\n       true\n 2. nofail ((SPEC \\<circ> all_left_spec) xs)", "by (auto simp: hn_ctxt_def)"], ["", "subsection \\<open>Code Generation\\<close>"], ["", "export_code all_left_impl checking SML Scala Haskell? OCaml?"], ["", "text \\<open>The example from the problem description, in ML using the verified algorithm\\<close>"], ["", "ML_val \\<open>\n  (* Convert from option to 1-based indexes *)\n  fun cnv NONE = 0\n    | cnv (SOME i) = @{code integer_of_nat} i + 1\n\n  (* The verified algorithm, boxing the input list into an array, \n    and unboxing the output to a list, and converting it from option to 1-based *)\n  fun all_left xs = \n       @{code all_left_impl} (Array.fromList (map @{code int_of_integer} xs)) ()\n    |> Array.foldr (op ::) []\n    |> map cnv\n\n  val test = all_left [ 4, 7, 8, 1, 2, 3, 9, 5, 6 ]  \n\\<close>"], ["", "end"]]}