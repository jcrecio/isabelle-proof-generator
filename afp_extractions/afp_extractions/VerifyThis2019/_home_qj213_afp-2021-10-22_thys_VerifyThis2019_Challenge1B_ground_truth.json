{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019/Challenge1B.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019", "problem_names": ["lemma mset_concat:\n  \"mset (concat xs) = fold (+) (map mset xs) {#}\"", "lemma merge_correct:\n  assumes \"sorted l1\"\n  assumes \"sorted l2\"\n  shows \"\n    sorted (merge l1 l2)\n  \\<and> mset (merge l1 l2) = mset l1 + mset l2\n  \\<and> set (merge l1 l2) = set l1 \\<union> set l2\"", "lemma merge_list_correct:\nassumes \"\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l\"\nassumes \"\\<And>l. l \\<in> set as \\<Longrightarrow> sorted l\"\nshows \"\n  sorted (merge_list as ls)\n\\<and> mset (merge_list as ls) = mset (concat (as @ ls))\n\\<and> set (merge_list as ls) = set (concat (as @ ls))\"", "lemma decr_sorted:\n  assumes \"decr xs\"\n  shows \"sorted (rev xs)\"", "lemma incr_sorted:\n  assumes \"incr xs\"\n  shows \"sorted xs\"", "lemma reverse_phase_sorted:\n  \"\\<forall>ys \\<in> set (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)). sorted ys\"", "lemma reverse_phase_elements:\n  \"set (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) = set xs\"", "lemma reverse_phase_permutation:\n  \"mset (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) = mset xs\"", "theorem sorted_ghc_sort:\n  \"sorted (ghc_sort xs)\"", "theorem permutation_ghc_sort:\n  \"mset (ghc_sort xs) = mset xs\""], "translations": [["", "lemma mset_concat:\n  \"mset (concat xs) = fold (+) (map mset xs) {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat xs) = fold (+) (map mset xs) {#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset (concat xs) = fold (+) (map mset xs) {#}", "have \"mset (concat xs) + a = fold (+) (map mset xs) a\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat xs) + a = fold (+) (map mset xs) a", "proof (induction xs arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. mset (concat []) + a = fold (+) (map mset []) a\n 2. \\<And>a xs aa.\n       (\\<And>a.\n           mset (concat xs) + a =\n           fold (+) (map mset xs) a) \\<Longrightarrow>\n       mset (concat (a # xs)) + aa = fold (+) (map mset (a # xs)) aa", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. mset (concat []) + a = fold (+) (map mset []) a\n 2. \\<And>a xs aa.\n       (\\<And>a.\n           mset (concat xs) + a =\n           fold (+) (map mset xs) a) \\<Longrightarrow>\n       mset (concat (a # xs)) + aa = fold (+) (map mset (a # xs)) aa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat []) + a = fold (+) (map mset []) a", "by auto"], ["proof (state)\nthis:\n  mset (concat []) + a = fold (+) (map mset []) a\n\ngoal (1 subgoal):\n 1. \\<And>a xs aa.\n       (\\<And>a.\n           mset (concat xs) + a =\n           fold (+) (map mset xs) a) \\<Longrightarrow>\n       mset (concat (a # xs)) + aa = fold (+) (map mset (a # xs)) aa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs aa.\n       (\\<And>a.\n           mset (concat xs) + a =\n           fold (+) (map mset xs) a) \\<Longrightarrow>\n       mset (concat (a # xs)) + aa = fold (+) (map mset (a # xs)) aa", "case (Cons x xs)"], ["proof (state)\nthis:\n  mset (concat xs) + ?a = fold (+) (map mset xs) ?a\n\ngoal (1 subgoal):\n 1. \\<And>a xs aa.\n       (\\<And>a.\n           mset (concat xs) + a =\n           fold (+) (map mset xs) a) \\<Longrightarrow>\n       mset (concat (a # xs)) + aa = fold (+) (map mset (a # xs)) aa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat (x # xs)) + a = fold (+) (map mset (x # xs)) a", "using Cons.IH[of \"mset x + a\", symmetric]"], ["proof (prove)\nusing this:\n  fold (+) (map mset xs) (mset x + a) = mset (concat xs) + (mset x + a)\n\ngoal (1 subgoal):\n 1. mset (concat (x # xs)) + a = fold (+) (map mset (x # xs)) a", "by simp"], ["proof (state)\nthis:\n  mset (concat (x # xs)) + a = fold (+) (map mset (x # xs)) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (concat xs) + ?a = fold (+) (map mset xs) ?a\n\ngoal (1 subgoal):\n 1. mset (concat xs) = fold (+) (map mset xs) {#}", "from this[of \"{#}\"]"], ["proof (chain)\npicking this:\n  mset (concat xs) + {#} = fold (+) (map mset xs) {#}", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (concat xs) + {#} = fold (+) (map mset xs) {#}\n\ngoal (1 subgoal):\n 1. mset (concat xs) = fold (+) (map mset xs) {#}", "by auto"], ["proof (state)\nthis:\n  mset (concat xs) = fold (+) (map mset xs) {#}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Merging Two Segments\\<close>"], ["", "fun merge :: \"'a::{linorder} list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n   \"merge [] l2 = l2\"\n | \"merge l1 [] = l1\"\n | \"merge (x1 # l1) (x2 # l2) =\n    (if (x1 < x2) then x1 # (merge l1 (x2 # l2)) else x2 # (merge (x1 # l1) l2))\""], ["", "lemma merge_correct:\n  assumes \"sorted l1\"\n  assumes \"sorted l2\"\n  shows \"\n    sorted (merge l1 l2)\n  \\<and> mset (merge l1 l2) = mset l1 + mset l2\n  \\<and> set (merge l1 l2) = set l1 \\<union> set l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (merge l1 l2) \\<and>\n    mset (merge l1 l2) = mset l1 + mset l2 \\<and>\n    set (merge l1 l2) = set l1 \\<union> set l2", "using assms"], ["proof (prove)\nusing this:\n  sorted l1\n  sorted l2\n\ngoal (1 subgoal):\n 1. sorted (merge l1 l2) \\<and>\n    mset (merge l1 l2) = mset l1 + mset l2 \\<and>\n    set (merge l1 l2) = set l1 \\<union> set l2", "proof (induction l1 arbitrary: l2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l2.\n       \\<lbrakk>sorted []; sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge [] l2) \\<and>\n                         mset (merge [] l2) = mset [] + mset l2 \\<and>\n                         set (merge [] l2) = set [] \\<union> set l2\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n                   \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                                     mset (merge l1 l2) =\n                                     mset l1 + mset l2 \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        sorted (a # l1); sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (a # l1) l2) \\<and>\n                         mset (merge (a # l1) l2) =\n                         mset (a # l1) + mset l2 \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "case Nil"], ["proof (state)\nthis:\n  sorted []\n  sorted l2\n\ngoal (2 subgoals):\n 1. \\<And>l2.\n       \\<lbrakk>sorted []; sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge [] l2) \\<and>\n                         mset (merge [] l2) = mset [] + mset l2 \\<and>\n                         set (merge [] l2) = set [] \\<union> set l2\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n                   \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                                     mset (merge l1 l2) =\n                                     mset l1 + mset l2 \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        sorted (a # l1); sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (a # l1) l2) \\<and>\n                         mset (merge (a # l1) l2) =\n                         mset (a # l1) + mset l2 \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "thus ?case"], ["proof (prove)\nusing this:\n  sorted []\n  sorted l2\n\ngoal (1 subgoal):\n 1. sorted (merge [] l2) \\<and>\n    mset (merge [] l2) = mset [] + mset l2 \\<and>\n    set (merge [] l2) = set [] \\<union> set l2", "by simp"], ["proof (state)\nthis:\n  sorted (merge [] l2) \\<and>\n  mset (merge [] l2) = mset [] + mset l2 \\<and>\n  set (merge [] l2) = set [] \\<union> set l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n                   \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                                     mset (merge l1 l2) =\n                                     mset l1 + mset l2 \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        sorted (a # l1); sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (a # l1) l2) \\<and>\n                         mset (merge (a # l1) l2) =\n                         mset (a # l1) + mset l2 \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n                   \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                                     mset (merge l1 l2) =\n                                     mset l1 + mset l2 \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        sorted (a # l1); sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (a # l1) l2) \\<and>\n                         mset (merge (a # l1) l2) =\n                         mset (a # l1) + mset l2 \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "case (Cons x1 l1 l2)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted l1; sorted ?l2.0\\<rbrakk>\n  \\<Longrightarrow> sorted (merge l1 ?l2.0) \\<and>\n                    mset (merge l1 ?l2.0) = mset l1 + mset ?l2.0 \\<and>\n                    set (merge l1 ?l2.0) = set l1 \\<union> set ?l2.0\n  sorted (x1 # l1)\n  sorted l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n                   \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                                     mset (merge l1 l2) =\n                                     mset l1 + mset l2 \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        sorted (a # l1); sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (a # l1) l2) \\<and>\n                         mset (merge (a # l1) l2) =\n                         mset (a # l1) + mset l2 \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "note IH = Cons.IH"], ["proof (state)\nthis:\n  \\<lbrakk>sorted l1; sorted ?l2.0\\<rbrakk>\n  \\<Longrightarrow> sorted (merge l1 ?l2.0) \\<and>\n                    mset (merge l1 ?l2.0) = mset l1 + mset ?l2.0 \\<and>\n                    set (merge l1 ?l2.0) = set l1 \\<union> set ?l2.0\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n                   \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                                     mset (merge l1 l2) =\n                                     mset l1 + mset l2 \\<and>\n                                     set (merge l1 l2) =\n                                     set l1 \\<union> set l2;\n        sorted (a # l1); sorted l2\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (a # l1) l2) \\<and>\n                         mset (merge (a # l1) l2) =\n                         mset (a # l1) + mset l2 \\<and>\n                         set (merge (a # l1) l2) =\n                         set (a # l1) \\<union> set l2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (merge (x1 # l1) l2) \\<and>\n    mset (merge (x1 # l1) l2) = mset (x1 # l1) + mset l2 \\<and>\n    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2", "using Cons.prems"], ["proof (prove)\nusing this:\n  sorted (x1 # l1)\n  sorted l2\n\ngoal (1 subgoal):\n 1. sorted (merge (x1 # l1) l2) \\<and>\n    mset (merge (x1 # l1) l2) = mset (x1 # l1) + mset l2 \\<and>\n    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2", "proof (induction l2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (x1 # l1); sorted []\\<rbrakk>\n    \\<Longrightarrow> sorted (merge (x1 # l1) []) \\<and>\n                      mset (merge (x1 # l1) []) =\n                      mset (x1 # l1) + mset [] \\<and>\n                      set (merge (x1 # l1) []) =\n                      set (x1 # l1) \\<union> set []\n 2. \\<And>a l2.\n       \\<lbrakk>\\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n                \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                                  mset (merge (x1 # l1) l2) =\n                                  mset (x1 # l1) + mset l2 \\<and>\n                                  set (merge (x1 # l1) l2) =\n                                  set (x1 # l1) \\<union> set l2;\n        sorted (x1 # l1); sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         mset (merge (x1 # l1) (a # l2)) =\n                         mset (x1 # l1) + mset (a # l2) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "case Nil"], ["proof (state)\nthis:\n  sorted (x1 # l1)\n  sorted []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (x1 # l1); sorted []\\<rbrakk>\n    \\<Longrightarrow> sorted (merge (x1 # l1) []) \\<and>\n                      mset (merge (x1 # l1) []) =\n                      mset (x1 # l1) + mset [] \\<and>\n                      set (merge (x1 # l1) []) =\n                      set (x1 # l1) \\<union> set []\n 2. \\<And>a l2.\n       \\<lbrakk>\\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n                \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                                  mset (merge (x1 # l1) l2) =\n                                  mset (x1 # l1) + mset l2 \\<and>\n                                  set (merge (x1 # l1) l2) =\n                                  set (x1 # l1) \\<union> set l2;\n        sorted (x1 # l1); sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         mset (merge (x1 # l1) (a # l2)) =\n                         mset (x1 # l1) + mset (a # l2) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "then"], ["proof (chain)\npicking this:\n  sorted (x1 # l1)\n  sorted []", "show ?case"], ["proof (prove)\nusing this:\n  sorted (x1 # l1)\n  sorted []\n\ngoal (1 subgoal):\n 1. sorted (merge (x1 # l1) []) \\<and>\n    mset (merge (x1 # l1) []) = mset (x1 # l1) + mset [] \\<and>\n    set (merge (x1 # l1) []) = set (x1 # l1) \\<union> set []", "by simp"], ["proof (state)\nthis:\n  sorted (merge (x1 # l1) []) \\<and>\n  mset (merge (x1 # l1) []) = mset (x1 # l1) + mset [] \\<and>\n  set (merge (x1 # l1) []) = set (x1 # l1) \\<union> set []\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>\\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n                \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                                  mset (merge (x1 # l1) l2) =\n                                  mset (x1 # l1) + mset l2 \\<and>\n                                  set (merge (x1 # l1) l2) =\n                                  set (x1 # l1) \\<union> set l2;\n        sorted (x1 # l1); sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         mset (merge (x1 # l1) (a # l2)) =\n                         mset (x1 # l1) + mset (a # l2) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>\\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n                \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                                  mset (merge (x1 # l1) l2) =\n                                  mset (x1 # l1) + mset l2 \\<and>\n                                  set (merge (x1 # l1) l2) =\n                                  set (x1 # l1) \\<union> set l2;\n        sorted (x1 # l1); sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         mset (merge (x1 # l1) (a # l2)) =\n                         mset (x1 # l1) + mset (a # l2) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "case (Cons x2 l2)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n  \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                    mset (merge (x1 # l1) l2) =\n                    mset (x1 # l1) + mset l2 \\<and>\n                    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  sorted (x1 # l1)\n  sorted (x2 # l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l2.\n       \\<lbrakk>\\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n                \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                                  mset (merge (x1 # l1) l2) =\n                                  mset (x1 # l1) + mset l2 \\<and>\n                                  set (merge (x1 # l1) l2) =\n                                  set (x1 # l1) \\<union> set l2;\n        sorted (x1 # l1); sorted (a # l2)\\<rbrakk>\n       \\<Longrightarrow> sorted (merge (x1 # l1) (a # l2)) \\<and>\n                         mset (merge (x1 # l1) (a # l2)) =\n                         mset (x1 # l1) + mset (a # l2) \\<and>\n                         set (merge (x1 # l1) (a # l2)) =\n                         set (x1 # l1) \\<union> set (a # l2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n  \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                    mset (merge (x1 # l1) l2) =\n                    mset (x1 # l1) + mset l2 \\<and>\n                    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  sorted (x1 # l1)\n  sorted (x2 # l2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n  \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                    mset (merge (x1 # l1) l2) =\n                    mset (x1 # l1) + mset l2 \\<and>\n                    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  sorted (x1 # l1)\n  sorted (x2 # l2)\n\ngoal (1 subgoal):\n 1. sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    mset (merge (x1 # l1) (x2 # l2)) =\n    mset (x1 # l1) + mset (x2 # l2) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (x1 # l1); sorted l2\\<rbrakk>\n  \\<Longrightarrow> sorted (merge (x1 # l1) l2) \\<and>\n                    mset (merge (x1 # l1) l2) =\n                    mset (x1 # l1) + mset l2 \\<and>\n                    set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n  sorted (x1 # l1)\n  sorted (x2 # l2)\n  \\<lbrakk>sorted l1; sorted ?l2.0\\<rbrakk>\n  \\<Longrightarrow> sorted (merge l1 ?l2.0) \\<and>\n                    mset (merge l1 ?l2.0) = mset l1 + mset ?l2.0 \\<and>\n                    set (merge l1 ?l2.0) = set l1 \\<union> set ?l2.0\n\ngoal (1 subgoal):\n 1. sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n    mset (merge (x1 # l1) (x2 # l2)) =\n    mset (x1 # l1) + mset (x2 # l2) \\<and>\n    set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)", "by (force split: if_split_asm)"], ["proof (state)\nthis:\n  sorted (merge (x1 # l1) (x2 # l2)) \\<and>\n  mset (merge (x1 # l1) (x2 # l2)) = mset (x1 # l1) + mset (x2 # l2) \\<and>\n  set (merge (x1 # l1) (x2 # l2)) = set (x1 # l1) \\<union> set (x2 # l2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (merge (x1 # l1) l2) \\<and>\n  mset (merge (x1 # l1) l2) = mset (x1 # l1) + mset l2 \\<and>\n  set (merge (x1 # l1) l2) = set (x1 # l1) \\<union> set l2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Merging a List of Segments\\<close>"], ["", "function merge_list :: \"'a::{linorder} list list \\<Rightarrow> 'a list list \\<Rightarrow> 'a list\" where\n   \"merge_list [] [] = []\"\n | \"merge_list [] [l] = l\"\n | \"merge_list (la # acc2) [] = merge_list [] (la # acc2)\"\n | \"merge_list (la # acc2) [l] = merge_list [] (l # la # acc2)\"\n | \"merge_list acc2 (l1 # l2 # ls) =\n    merge_list ((merge l1 l2) # acc2) ls\""], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = ([], []) \\<Longrightarrow> P;\n        \\<And>l. x = ([], [l]) \\<Longrightarrow> P;\n        \\<And>la acc2. x = (la # acc2, []) \\<Longrightarrow> P;\n        \\<And>la acc2 l. x = (la # acc2, [l]) \\<Longrightarrow> P;\n        \\<And>acc2 l1 l2 ls.\n           x = (acc2, l1 # l2 # ls) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. ([], []) = ([], []) \\<Longrightarrow> [] = []\n 3. \\<And>l. ([], []) = ([], [l]) \\<Longrightarrow> [] = l\n 4. \\<And>la acc2.\n       ([], []) = (la # acc2, []) \\<Longrightarrow>\n       [] = merge_list_sumC ([], la # acc2)\n 5. \\<And>la acc2 l.\n       ([], []) = (la # acc2, [l]) \\<Longrightarrow>\n       [] = merge_list_sumC ([], l # la # acc2)\n 6. \\<And>acc2 l1 l2 ls.\n       ([], []) = (acc2, l1 # l2 # ls) \\<Longrightarrow>\n       [] = merge_list_sumC (merge l1 l2 # acc2, ls)\n 7. \\<And>l la. ([], [l]) = ([], [la]) \\<Longrightarrow> l = la\n 8. \\<And>l la acc2.\n       ([], [l]) = (la # acc2, []) \\<Longrightarrow>\n       l = merge_list_sumC ([], la # acc2)\n 9. \\<And>l la acc2 lb.\n       ([], [l]) = (la # acc2, [lb]) \\<Longrightarrow>\n       l = merge_list_sumC ([], lb # la # acc2)\n 10. \\<And>l acc2 l1 l2 ls.\n        ([], [l]) = (acc2, l1 # l2 # ls) \\<Longrightarrow>\n        l = merge_list_sumC (merge l1 l2 # acc2, ls)\nA total of 16 subgoals...", "by pat_completeness simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All merge_list_dom", "by (relation \"measure (\\<lambda>(acc, ls). 3 * length acc + 2 * length ls)\"; simp)"], ["", "lemma merge_list_correct:\nassumes \"\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l\"\nassumes \"\\<And>l. l \\<in> set as \\<Longrightarrow> sorted l\"\nshows \"\n  sorted (merge_list as ls)\n\\<and> mset (merge_list as ls) = mset (concat (as @ ls))\n\\<and> set (merge_list as ls) = set (concat (as @ ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (merge_list as ls) \\<and>\n    mset (merge_list as ls) = mset (concat (as @ ls)) \\<and>\n    set (merge_list as ls) = set (concat (as @ ls))", "using assms"], ["proof (prove)\nusing this:\n  ?l \\<in> set ls \\<Longrightarrow> sorted ?l\n  ?l \\<in> set as \\<Longrightarrow> sorted ?l\n\ngoal (1 subgoal):\n 1. sorted (merge_list as ls) \\<and>\n    mset (merge_list as ls) = mset (concat (as @ ls)) \\<and>\n    set (merge_list as ls) = set (concat (as @ ls))", "proof (induction as ls rule: merge_list.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            sorted lb;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  mset (merge_list [] (l # la # acc2)) =\n                                  mset (concat ([] @ l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) [l]) \\<and>\n                         mset (merge_list (la # acc2) [l]) =\n                         mset (concat ((la # acc2) @ [l])) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            sorted lb;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  mset (merge_list [] (l # la # acc2)) =\n                                  mset (concat ([] @ l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) [l]) \\<and>\n                         mset (merge_list (la # acc2) [l]) =\n                         mset (concat ((la # acc2) @ [l])) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case (4 la acc2 l)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>lb.\n              lb \\<in> set (l # la # acc2) \\<Longrightarrow> sorted lb;\n   \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n  \\<Longrightarrow> sorted (merge_list [] (l # la # acc2)) \\<and>\n                    mset (merge_list [] (l # la # acc2)) =\n                    mset (concat ([] @ l # la # acc2)) \\<and>\n                    set (merge_list [] (l # la # acc2)) =\n                    set (concat ([] @ l # la # acc2))\n  ?l \\<in> set [l] \\<Longrightarrow> sorted ?l\n  ?l \\<in> set (la # acc2) \\<Longrightarrow> sorted ?l\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       \\<lbrakk>\\<lbrakk>\\<And>lb.\n                            lb \\<in> set (l # la # acc2) \\<Longrightarrow>\n                            sorted lb;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list [] (l # la # acc2)) \\<and>\n                                  mset (merge_list [] (l # la # acc2)) =\n                                  mset (concat ([] @ l # la # acc2)) \\<and>\n                                  set (merge_list [] (l # la # acc2)) =\n                                  set (concat ([] @ l # la # acc2));\n        \\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) [l]) \\<and>\n                         mset (merge_list (la # acc2) [l]) =\n                         mset (concat ((la # acc2) @ [l])) \\<and>\n                         set (merge_list (la # acc2) [l]) =\n                         set (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>lb.\n              lb \\<in> set (l # la # acc2) \\<Longrightarrow> sorted lb;\n   \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n  \\<Longrightarrow> sorted (merge_list [] (l # la # acc2)) \\<and>\n                    mset (merge_list [] (l # la # acc2)) =\n                    mset (concat ([] @ l # la # acc2)) \\<and>\n                    set (merge_list [] (l # la # acc2)) =\n                    set (concat ([] @ l # la # acc2))\n  ?l \\<in> set [l] \\<Longrightarrow> sorted ?l\n  ?l \\<in> set (la # acc2) \\<Longrightarrow> sorted ?l", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>lb.\n              lb \\<in> set (l # la # acc2) \\<Longrightarrow> sorted lb;\n   \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n  \\<Longrightarrow> sorted (merge_list [] (l # la # acc2)) \\<and>\n                    mset (merge_list [] (l # la # acc2)) =\n                    mset (concat ([] @ l # la # acc2)) \\<and>\n                    set (merge_list [] (l # la # acc2)) =\n                    set (concat ([] @ l # la # acc2))\n  ?l \\<in> set [l] \\<Longrightarrow> sorted ?l\n  ?l \\<in> set (la # acc2) \\<Longrightarrow> sorted ?l\n\ngoal (1 subgoal):\n 1. sorted (merge_list (la # acc2) [l]) \\<and>\n    mset (merge_list (la # acc2) [l]) =\n    mset (concat ((la # acc2) @ [l])) \\<and>\n    set (merge_list (la # acc2) [l]) = set (concat ((la # acc2) @ [l]))", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  sorted (merge_list (la # acc2) [l]) \\<and>\n  mset (merge_list (la # acc2) [l]) =\n  mset (concat ((la # acc2) @ [l])) \\<and>\n  set (merge_list (la # acc2) [l]) = set (concat ((la # acc2) @ [l]))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "case (5 acc2 l1 l2 ls)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n   \\<And>l.\n      l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n  \\<Longrightarrow> sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n                    mset (merge_list (merge l1 l2 # acc2) ls) =\n                    mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n                    set (merge_list (merge l1 l2 # acc2) ls) =\n                    set (concat ((merge l1 l2 # acc2) @ ls))\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted ?l\n  ?l \\<in> set acc2 \\<Longrightarrow> sorted ?l\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "have \"sorted (merge_list (merge l1 l2 # acc2) ls)\n    \\<and> mset (merge_list (merge l1 l2 # acc2) ls) = mset (concat ((merge l1 l2 # acc2) @ ls))\n    \\<and> set (merge_list (merge l1 l2 # acc2) ls) = set (concat ((merge l1 l2 # acc2) @ ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n    mset (merge_list (merge l1 l2 # acc2) ls) =\n    mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n    set (merge_list (merge l1 l2 # acc2) ls) =\n    set (concat ((merge l1 l2 # acc2) @ ls))", "using 5(2-) merge_correct[of l1 l2]"], ["proof (prove)\nusing this:\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted ?l\n  ?l \\<in> set acc2 \\<Longrightarrow> sorted ?l\n  \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n  \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                    mset (merge l1 l2) = mset l1 + mset l2 \\<and>\n                    set (merge l1 l2) = set l1 \\<union> set l2\n\ngoal (1 subgoal):\n 1. sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n    mset (merge_list (merge l1 l2 # acc2) ls) =\n    mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n    set (merge_list (merge l1 l2 # acc2) ls) =\n    set (concat ((merge l1 l2 # acc2) @ ls))", "by (intro 5(1)) auto"], ["proof (state)\nthis:\n  sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n  mset (merge_list (merge l1 l2 # acc2) ls) =\n  mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n  set (merge_list (merge l1 l2 # acc2) ls) =\n  set (concat ((merge l1 l2 # acc2) @ ls))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))\n 4. \\<And>acc2 l1 l2 ls.\n       \\<lbrakk>\\<lbrakk>\\<And>l. l \\<in> set ls \\<Longrightarrow> sorted l;\n                 \\<And>l.\n                    l \\<in> set (merge l1 l2 # acc2) \\<Longrightarrow>\n                    sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (merge_list (merge l1 l2 # acc2)\n                                     ls) \\<and>\n                                  mset\n                                   (merge_list (merge l1 l2 # acc2) ls) =\n                                  mset\n                                   (concat\n                                     ((merge l1 l2 # acc2) @ ls)) \\<and>\n                                  set (merge_list (merge l1 l2 # acc2) ls) =\n                                  set (concat ((merge l1 l2 # acc2) @ ls));\n        \\<And>l. l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set acc2 \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n                         mset (merge_list acc2 (l1 # l2 # ls)) =\n                         mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n                         set (merge_list acc2 (l1 # l2 # ls)) =\n                         set (concat (acc2 @ l1 # l2 # ls))", "then"], ["proof (chain)\npicking this:\n  sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n  mset (merge_list (merge l1 l2 # acc2) ls) =\n  mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n  set (merge_list (merge l1 l2 # acc2) ls) =\n  set (concat ((merge l1 l2 # acc2) @ ls))", "show ?case"], ["proof (prove)\nusing this:\n  sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n  mset (merge_list (merge l1 l2 # acc2) ls) =\n  mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n  set (merge_list (merge l1 l2 # acc2) ls) =\n  set (concat ((merge l1 l2 # acc2) @ ls))\n\ngoal (1 subgoal):\n 1. sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n    mset (merge_list acc2 (l1 # l2 # ls)) =\n    mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n    set (merge_list acc2 (l1 # l2 # ls)) =\n    set (concat (acc2 @ l1 # l2 # ls))", "using merge_correct[of l1 l2] 5(2-)"], ["proof (prove)\nusing this:\n  sorted (merge_list (merge l1 l2 # acc2) ls) \\<and>\n  mset (merge_list (merge l1 l2 # acc2) ls) =\n  mset (concat ((merge l1 l2 # acc2) @ ls)) \\<and>\n  set (merge_list (merge l1 l2 # acc2) ls) =\n  set (concat ((merge l1 l2 # acc2) @ ls))\n  \\<lbrakk>sorted l1; sorted l2\\<rbrakk>\n  \\<Longrightarrow> sorted (merge l1 l2) \\<and>\n                    mset (merge l1 l2) = mset l1 + mset l2 \\<and>\n                    set (merge l1 l2) = set l1 \\<union> set l2\n  ?l \\<in> set (l1 # l2 # ls) \\<Longrightarrow> sorted ?l\n  ?l \\<in> set acc2 \\<Longrightarrow> sorted ?l\n\ngoal (1 subgoal):\n 1. sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n    mset (merge_list acc2 (l1 # l2 # ls)) =\n    mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n    set (merge_list acc2 (l1 # l2 # ls)) =\n    set (concat (acc2 @ l1 # l2 # ls))", "by auto"], ["proof (state)\nthis:\n  sorted (merge_list acc2 (l1 # l2 # ls)) \\<and>\n  mset (merge_list acc2 (l1 # l2 # ls)) =\n  mset (concat (acc2 @ l1 # l2 # ls)) \\<and>\n  set (merge_list acc2 (l1 # l2 # ls)) = set (concat (acc2 @ l1 # l2 # ls))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n     \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_list [] []) \\<and>\n                      mset (merge_list [] []) =\n                      mset (concat ([] @ [])) \\<and>\n                      set (merge_list [] []) = set (concat ([] @ []))\n 2. \\<And>l.\n       \\<lbrakk>\\<And>la. la \\<in> set [l] \\<Longrightarrow> sorted la;\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list [] [l]) \\<and>\n                         mset (merge_list [] [l]) =\n                         mset (concat ([] @ [l])) \\<and>\n                         set (merge_list [] [l]) = set (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       \\<lbrakk>\\<lbrakk>\\<And>l.\n                            l \\<in> set (la # acc2) \\<Longrightarrow>\n                            sorted l;\n                 \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\\<rbrakk>\n                \\<Longrightarrow> sorted (merge_list [] (la # acc2)) \\<and>\n                                  mset (merge_list [] (la # acc2)) =\n                                  mset (concat ([] @ la # acc2)) \\<and>\n                                  set (merge_list [] (la # acc2)) =\n                                  set (concat ([] @ la # acc2));\n        \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l;\n        \\<And>l. l \\<in> set (la # acc2) \\<Longrightarrow> sorted l\\<rbrakk>\n       \\<Longrightarrow> sorted (merge_list (la # acc2) []) \\<and>\n                         mset (merge_list (la # acc2) []) =\n                         mset (concat ((la # acc2) @ [])) \\<and>\n                         set (merge_list (la # acc2) []) =\n                         set (concat ((la # acc2) @ []))", "qed simp+"], ["", "subsection \\<open>GHC-Sort\\<close>"], ["", "definition\n  \"ghc_sort xs = merge_list [] (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))\""], ["", "lemma decr_sorted:\n  assumes \"decr xs\"\n  shows \"sorted (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (rev xs)", "using assms"], ["proof (prove)\nusing this:\n  decr xs\n\ngoal (1 subgoal):\n 1. sorted (rev xs)", "by (induction xs rule: decr.induct) (auto simp: sorted_append)"], ["", "lemma incr_sorted:\n  assumes \"incr xs\"\n  shows \"sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs", "using assms"], ["proof (prove)\nusing this:\n  incr xs\n\ngoal (1 subgoal):\n 1. sorted xs", "by (induction xs rule: incr.induct) auto"], ["", "lemma reverse_phase_sorted:\n  \"\\<forall>ys \\<in> set (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)). sorted ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys\\<in>set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                          (cuts xs)).\n       sorted ys", "using cuts_incr_decr"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set (cuts ?xs). incr c \\<or> decr c\n\ngoal (1 subgoal):\n 1. \\<forall>ys\\<in>set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                          (cuts xs)).\n       sorted ys", "by (auto intro: decr_sorted incr_sorted)"], ["", "lemma reverse_phase_elements:\n  \"set (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set xs", "have \"set (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)))\n    = set (concat (cuts xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set (concat (cuts xs))", "by auto"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  set (concat (cuts xs))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set xs", "also"], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  set (concat (cuts xs))\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set xs", "have \"\\<dots> = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat (cuts xs)) = set xs", "by (simp add: concat_cuts)"], ["proof (state)\nthis:\n  set (concat (cuts xs)) = set xs\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set xs", "finally"], ["proof (chain)\npicking this:\n  set (concat\n        (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  set xs\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    set xs", "."], ["proof (state)\nthis:\n  set (concat\n        (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reverse_phase_permutation:\n  \"mset (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "have \"mset (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)))\n    = mset (concat (cuts xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset (concat (cuts xs))", "unfolding mset_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (+)\n     (map mset\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)))\n     {#} =\n    fold (+) (map mset (cuts xs)) {#}", "by (auto simp: comp_def intro!: arg_cong2[where f = \"fold (+)\"])"], ["proof (state)\nthis:\n  mset\n   (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  mset (concat (cuts xs))\n\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "also"], ["proof (state)\nthis:\n  mset\n   (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  mset (concat (cuts xs))\n\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "have \"\\<dots> = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat (cuts xs)) = mset xs", "by (simp add: concat_cuts)"], ["proof (state)\nthis:\n  mset (concat (cuts xs)) = mset xs\n\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "finally"], ["proof (chain)\npicking this:\n  mset\n   (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  mset xs", "show ?thesis"], ["proof (prove)\nusing this:\n  mset\n   (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  mset xs\n\ngoal (1 subgoal):\n 1. mset\n     (concat\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "."], ["proof (state)\nthis:\n  mset\n   (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n  mset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness Lemmas\\<close>"], ["", "text \\<open>The result is sorted and a permutation of the original elements.\\<close>"], ["", "theorem sorted_ghc_sort:\n  \"sorted (ghc_sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (ghc_sort xs)", "unfolding ghc_sort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted\n     (merge_list []\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)))", "using reverse_phase_sorted"], ["proof (prove)\nusing this:\n  \\<forall>ys\\<in>set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                        (cuts ?xs)).\n     sorted ys\n\ngoal (1 subgoal):\n 1. sorted\n     (merge_list []\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)))", "by (intro merge_list_correct[THEN conjunct1]) auto"], ["", "theorem permutation_ghc_sort:\n  \"mset (ghc_sort xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (ghc_sort xs) = mset xs", "unfolding ghc_sort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (merge_list []\n       (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "apply (subst merge_list_correct[THEN conjunct2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l.\n       l \\<in> set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                     (cuts xs)) \\<Longrightarrow>\n       sorted l\n 2. \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\n 3. mset\n     (concat\n       ([] @ map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_ \\<in> set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                   (cuts xs)) \\<Longrightarrow>\n    sorted l_", "using reverse_phase_sorted"], ["proof (prove)\nusing this:\n  \\<forall>ys\\<in>set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                        (cuts ?xs)).\n     sorted ys\n\ngoal (1 subgoal):\n 1. l_ \\<in> set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                   (cuts xs)) \\<Longrightarrow>\n    sorted l_", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l. l \\<in> set [] \\<Longrightarrow> sorted l\n 2. mset\n     (concat\n       ([] @ map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_ \\<in> set [] \\<Longrightarrow> sorted l_", "using reverse_phase_sorted"], ["proof (prove)\nusing this:\n  \\<forall>ys\\<in>set (map (\\<lambda>ys. if decr ys then rev ys else ys)\n                        (cuts ?xs)).\n     sorted ys\n\ngoal (1 subgoal):\n 1. l_ \\<in> set [] \\<Longrightarrow> sorted l_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (concat\n       ([] @ map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset xs", "apply (subst (2) reverse_phase_permutation[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (concat\n       ([] @ map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs))) =\n    mset\n     (concat (map (\\<lambda>ys. if decr ys then rev ys else ys) (cuts xs)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary elements_ghc_sort: \"set (ghc_sort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ghc_sort xs) = set xs", "using permutation_ghc_sort"], ["proof (prove)\nusing this:\n  mset (ghc_sort ?xs) = mset ?xs\n\ngoal (1 subgoal):\n 1. set (ghc_sort xs) = set xs", "by (metis set_mset_mset)"], ["", "subsection \\<open>Executable Code\\<close>"], ["", "export_code ghc_sort checking SML Scala OCaml? Haskell?"], ["", "value [code] \"ghc_sort [1,2,7,3,5,6,9,8,4]\""], ["", "end"]]}