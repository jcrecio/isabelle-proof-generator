{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019/Challenge3.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019", "problem_names": ["lemma aux: \n    \"\n    distinct (map fst (ts1@ts2)) \\<Longrightarrow>\n    the_default (0::val) (case map_of ts1 (k, i) of None \\<Rightarrow> map_of ts2 (k, i) | Some x \\<Rightarrow> Some x)\n    \n    = the_default 0 (map_of ts1 (k, i)) + the_default 0 (map_of ts2 (k, i))\n    \"", "lemma 1[simp]: \"distinct (map fst (ts1@ts2)) \\<Longrightarrow> \n    pr (\\<alpha> (ts1@ts2)) x i = pr (\\<alpha> ts1) x i + pr (\\<alpha> ts2) x i\"", "lemmas 2 = 1[of \"[((r,c),v)]\" \"ts\", simplified] for r c v ts", "lemma [simp]: \"\\<alpha> [] = (\\<lambda>_. 0)\"", "lemma [simp]: \"pr (\\<lambda>_. 0::val) x = (\\<lambda>_. 0)\"", "lemma aux3: \"the_default 0 (if b then Some x else None) = (if b then x else 0)\"", "lemma correct_aux: \"\\<lbrakk>distinct (map fst ts); \\<forall>((r,c),_)\\<in>set ts. r<n\\<rbrakk> \n    \\<Longrightarrow> \\<forall>i. fold (\\<lambda>((r,c),v) y. y(c:=y c + x r * v)) ts m i = m i + pr (\\<alpha> ts) x i\"", "lemma correct_fold: \n    assumes \"distinct (map fst ts)\"\n    assumes \"\\<forall>((r,c),_)\\<in>set ts. r<n\"\n    shows \"fold (\\<lambda>((r,c),v) y. y(c:=y c + x r * v)) ts (\\<lambda>_. 0) = pr (\\<alpha> ts) x\"", "lemma alg_by_fold: \"alg ts x = fold (\\<lambda>((r,c),v) y. y(c:=y c + x r * v)) ts (\\<lambda>_. 0)\"", "theorem correct: \n    assumes \"distinct (map fst ts)\"\n    assumes \"\\<forall>((r,c),_)\\<in>set ts. r<n\"\n    shows \"alg ts x = pr (\\<alpha> ts) x\"", "theorem parallel_correct:\n    assumes \"distinct (map fst ts)\" \"\\<forall>((r,c),_)\\<in>set ts. r<n\"\n        and \"0 < n\" \\<comment> \\<open>At least on thread\\<close>\n        \\<comment>\\<open>We have reached a final state.\\<close>\n        and \"reachable x n ts (\\<lambda>_. 0) (ts', ms, r)\" \"final n (ts', ms, r)\"\n      shows \"r = pr (\\<alpha> ts) x\"", "theorem parallel_termination:\n    assumes \"0 < n\"\n      and \"reachable x n ts (\\<lambda>_. 0) s\"\n    shows \"\\<exists>s'. final n s' \\<and> (step x n)\\<^sup>*\\<^sup>* s s'\""], "translations": [["", "lemma aux: \n    \"\n    distinct (map fst (ts1@ts2)) \\<Longrightarrow>\n    the_default (0::val) (case map_of ts1 (k, i) of None \\<Rightarrow> map_of ts2 (k, i) | Some x \\<Rightarrow> Some x)\n    \n    = the_default 0 (map_of ts1 (k, i)) + the_default 0 (map_of ts2 (k, i))\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (ts1 @ ts2)) \\<Longrightarrow>\n    the_default 0\n     (case map_of ts1 (k, i) of None \\<Rightarrow> map_of ts2 (k, i)\n      | Some x \\<Rightarrow> Some x) =\n    the_default 0 (map_of ts1 (k, i)) + the_default 0 (map_of ts2 (k, i))", "apply (auto split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>distinct (map fst ts1); distinct (map fst ts2);\n        fst ` set ts1 \\<inter> fst ` set ts2 = {};\n        ((k, i), x2) \\<in> set ts1\\<rbrakk>\n       \\<Longrightarrow> the_default 0 (map_of ts2 (k, i)) = 0", "by (metis disjoint_iff_not_equal img_fst map_of_eq_None_iff the_default.simps(2))"], ["", "lemma 1[simp]: \"distinct (map fst (ts1@ts2)) \\<Longrightarrow> \n    pr (\\<alpha> (ts1@ts2)) x i = pr (\\<alpha> ts1) x i + pr (\\<alpha> ts2) x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (ts1 @ ts2)) \\<Longrightarrow>\n    local.pr (\\<alpha> (ts1 @ ts2)) x i =\n    local.pr (\\<alpha> ts1) x i + local.pr (\\<alpha> ts2) x i", "apply (auto simp: pr_def \\<alpha>_def map_add_def aux split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ts1); distinct (map fst ts2);\n     fst ` set ts1 \\<inter> fst ` set ts2 = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>k = 0..<n.\n                          x k *\n                          (the_default 0 (map_of ts1 (k, i)) +\n                           the_default 0 (map_of ts2 (k, i)))) =\n                      (\\<Sum>k = 0..<n.\n                          x k * the_default 0 (map_of ts1 (k, i))) +\n                      (\\<Sum>k = 0..<n.\n                          x k * the_default 0 (map_of ts2 (k, i)))", "apply (auto simp: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ts1); distinct (map fst ts2);\n     fst ` set ts1 \\<inter> fst ` set ts2 = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>k = 0..<n.\n                          x k * the_default 0 (map_of ts1 (k, i)) +\n                          x k * the_default 0 (map_of ts2 (k, i))) =\n                      (\\<Sum>k = 0..<n.\n                          x k * the_default 0 (map_of ts1 (k, i))) +\n                      (\\<Sum>k = 0..<n.\n                          x k * the_default 0 (map_of ts2 (k, i)))", "by (simp add: sum.distrib)"], ["", "lemmas 2 = 1[of \"[((r,c),v)]\" \"ts\", simplified] for r c v ts"], ["", "lemma [simp]: \"\\<alpha> [] = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> [] = (\\<lambda>_. 0)", "by (auto simp: \\<alpha>_def)"], ["", "lemma [simp]: \"pr (\\<lambda>_. 0::val) x = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.pr (\\<lambda>_. 0) x = (\\<lambda>_. 0)", "by (auto simp: pr_def[abs_def])"], ["", "lemma aux3: \"the_default 0 (if b then Some x else None) = (if b then x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_default (0::'a) (if b then Some x else None) =\n    (if b then x else (0::'a))", "by auto"], ["", "lemma correct_aux: \"\\<lbrakk>distinct (map fst ts); \\<forall>((r,c),_)\\<in>set ts. r<n\\<rbrakk> \n    \\<Longrightarrow> \\<forall>i. fold (\\<lambda>((r,c),v) y. y(c:=y c + x r * v)) ts m i = m i + pr (\\<alpha> ts) x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ts);\n     \\<forall>((r, c), uu_)\\<in>set ts. r < n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         fold\n                          (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts\n                          m i =\n                         m i + local.pr (\\<alpha> ts) x i", "apply (induction ts arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>distinct (map fst []);\n        \\<forall>((r, c), uu_)\\<in>set []. r < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i.\n                            fold\n                             (\\<lambda>((r, c), v) y. y(c := y c + x r * v))\n                             [] m i =\n                            m i + local.pr (\\<alpha> []) x i\n 2. \\<And>a ts m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distinct (map fst ts);\n                    \\<forall>((r, c), uu_)\\<in>set ts. r < n\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i.\n  fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts m i =\n  m i + local.pr (\\<alpha> ts) x i;\n        distinct (map fst (a # ts));\n        \\<forall>((r, c), uu_)\\<in>set (a # ts). r < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i.\n                            fold\n                             (\\<lambda>((r, c), v) y. y(c := y c + x r * v))\n                             (a # ts) m i =\n                            m i + local.pr (\\<alpha> (a # ts)) x i", "apply (auto simp: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba ts.\n       \\<lbrakk>\\<And>m.\n                   \\<forall>i.\n                      fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v))\n                       ts m i =\n                      m i + local.pr (\\<alpha> ts) x i;\n        (a, b) \\<notin> fst ` set ts; distinct (map fst ts); a < n;\n        \\<forall>x\\<in>set ts.\n           case x of\n           (x, xa) \\<Rightarrow>\n             (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n       \\<Longrightarrow> x a * ba + local.pr (\\<alpha> ts) x b =\n                         local.pr (\\<alpha> (((a, b), ba) # ts)) x b\n 2. \\<And>a b ba ts i.\n       \\<lbrakk>\\<And>m.\n                   \\<forall>i.\n                      fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v))\n                       ts m i =\n                      m i + local.pr (\\<alpha> ts) x i;\n        (a, b) \\<notin> fst ` set ts; distinct (map fst ts); a < n;\n        \\<forall>x\\<in>set ts.\n           case x of\n           (x, xa) \\<Rightarrow>\n             (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n        i \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> local.pr (\\<alpha> ts) x i =\n                         local.pr (\\<alpha> (((a, b), ba) # ts)) x i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n    \\<Longrightarrow> x a_ * ba_ + local.pr (\\<alpha> ts_) x b_ =\n                      local.pr (\\<alpha> (((a_, b_), ba_) # ts_)) x b_", "apply (subst 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n    \\<Longrightarrow> (a_, b_) \\<notin> fst ` set ts_ \\<and>\n                      distinct (map fst ts_)\n 2. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n    \\<Longrightarrow> x a_ * ba_ + local.pr (\\<alpha> ts_) x b_ =\n                      local.pr (\\<alpha> [((a_, b_), ba_)]) x b_ +\n                      local.pr (\\<alpha> ts_) x b_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n    \\<Longrightarrow> x a_ * ba_ =\n                      local.pr (\\<alpha> [((a_, b_), ba_)]) x b_", "unfolding pr_def \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i +\n                   (\\<Sum>k = 0..<n.\n                       x k *\n                       (the_default 0 \\<circ>\\<circ> map_of) ts_ (k, i));\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n    \\<Longrightarrow> x a_ * ba_ =\n                      (\\<Sum>k = 0..<n.\n                          x k *\n                          (the_default 0 \\<circ>\\<circ> map_of)\n                           [((a_, b_), ba_)] (k, b_))", "apply (auto split: if_splits cong: sum.cong simp: aux3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i +\n                   (\\<Sum>xa = 0..<n.\n                       x xa * the_default 0 (map_of ts_ (xa, i)));\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa\\<rbrakk>\n    \\<Longrightarrow> x a_ * ba_ =\n                      (\\<Sum>xa = 0..<n.\n                          x xa * (if xa = a_ then ba_ else 0))", "apply (auto simp: if_distrib[where f=\"\\<lambda>x. _*x\"] cong: sum.cong if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba ts i.\n       \\<lbrakk>\\<And>m.\n                   \\<forall>i.\n                      fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v))\n                       ts m i =\n                      m i + local.pr (\\<alpha> ts) x i;\n        (a, b) \\<notin> fst ` set ts; distinct (map fst ts); a < n;\n        \\<forall>x\\<in>set ts.\n           case x of\n           (x, xa) \\<Rightarrow>\n             (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n        i \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> local.pr (\\<alpha> ts) x i =\n                         local.pr (\\<alpha> (((a, b), ba) # ts)) x i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n     i_ \\<noteq> b_\\<rbrakk>\n    \\<Longrightarrow> local.pr (\\<alpha> ts_) x i_ =\n                      local.pr (\\<alpha> (((a_, b_), ba_) # ts_)) x i_", "apply (subst 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n     i_ \\<noteq> b_\\<rbrakk>\n    \\<Longrightarrow> (a_, b_) \\<notin> fst ` set ts_ \\<and>\n                      distinct (map fst ts_)\n 2. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n     i_ \\<noteq> b_\\<rbrakk>\n    \\<Longrightarrow> local.pr (\\<alpha> ts_) x i_ =\n                      local.pr (\\<alpha> [((a_, b_), ba_)]) x i_ +\n                      local.pr (\\<alpha> ts_) x i_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i + local.pr (\\<alpha> ts_) x i;\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n     i_ \\<noteq> b_\\<rbrakk>\n    \\<Longrightarrow> local.pr (\\<alpha> [((a_, b_), ba_)]) x i_ = 0", "unfolding pr_def \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m.\n                \\<forall>i.\n                   fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts_\n                    m i =\n                   m i +\n                   (\\<Sum>k = 0..<n.\n                       x k *\n                       (the_default 0 \\<circ>\\<circ> map_of) ts_ (k, i));\n     (a_, b_) \\<notin> fst ` set ts_; distinct (map fst ts_); a_ < n;\n     \\<forall>x\\<in>set ts_.\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of (r, c) \\<Rightarrow> \\<lambda>_. r < n) xa;\n     i_ \\<noteq> b_\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>k = 0..<n.\n                          x k *\n                          (the_default 0 \\<circ>\\<circ> map_of)\n                           [((a_, b_), ba_)] (k, i_)) =\n                      0", "apply (auto split: if_splits cong: sum.cong simp: aux3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma correct_fold: \n    assumes \"distinct (map fst ts)\"\n    assumes \"\\<forall>((r,c),_)\\<in>set ts. r<n\"\n    shows \"fold (\\<lambda>((r,c),v) y. y(c:=y c + x r * v)) ts (\\<lambda>_. 0) = pr (\\<alpha> ts) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts\n     (\\<lambda>_. 0) =\n    local.pr (\\<alpha> ts) x", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts\n        (\\<lambda>_. 0) xa =\n       local.pr (\\<alpha> ts) x xa", "using correct_aux[OF assms, rule_format, where m = \"\\<lambda>_. 0\", simplified]"], ["proof (prove)\nusing this:\n  fold (\\<lambda>((r, c), v) y. y(c := y c + ?x r * v)) ts (\\<lambda>_. 0)\n   ?i =\n  local.pr (\\<alpha> ts) ?x ?i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts\n        (\\<lambda>_. 0) xa =\n       local.pr (\\<alpha> ts) x xa", "by simp"], ["", "lemma alg_by_fold: \"alg ts x = fold (\\<lambda>((r,c),v) y. y(c:=y c + x r * v)) ts (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alg ts x =\n    fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts (\\<lambda>_. 0)", "unfolding alg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold_mset (\\<lambda>((r, c), v) y. y(c := y c + x r * v))\n     (\\<lambda>_. 0) (mset ts) =\n    fold (\\<lambda>((r, c), v) y. y(c := y c + x r * v)) ts (\\<lambda>_. 0)", "by (simp add: fold_mset_rewr)"], ["", "theorem correct: \n    assumes \"distinct (map fst ts)\"\n    assumes \"\\<forall>((r,c),_)\\<in>set ts. r<n\"\n    shows \"alg ts x = pr (\\<alpha> ts) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alg ts x = local.pr (\\<alpha> ts) x", "using alg_by_fold correct_fold[OF assms]"], ["proof (prove)\nusing this:\n  alg ?ts ?x =\n  fold (\\<lambda>((r, c), v) y. y(c := y c + ?x r * v)) ?ts (\\<lambda>_. 0)\n  fold (\\<lambda>((r, c), v) y. y(c := y c + ?x r * v)) ts (\\<lambda>_. 0) =\n  local.pr (\\<alpha> ts) ?x\n\ngoal (1 subgoal):\n 1. alg ts x = local.pr (\\<alpha> ts) x", "by simp"], ["", "subsection \\<open>Multi-Threaded Implementation\\<close>"], ["", "text \\<open>Correctness of the parallel implementation:\\<close>"], ["", "theorem parallel_correct:\n    assumes \"distinct (map fst ts)\" \"\\<forall>((r,c),_)\\<in>set ts. r<n\"\n        and \"0 < n\" \\<comment> \\<open>At least on thread\\<close>\n        \\<comment>\\<open>We have reached a final state.\\<close>\n        and \"reachable x n ts (\\<lambda>_. 0) (ts', ms, r)\" \"final n (ts', ms, r)\"\n      shows \"r = pr (\\<alpha> ts) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = local.pr (\\<alpha> ts) x", "unfolding final_state_correct[OF assms(3-)] correct[OF assms(1,2)] alg_by_fold[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.pr (\\<alpha> ts) x = local.pr (\\<alpha> ts) x", ".."], ["", "text \\<open>We also know that the computation will always terminate.\\<close>"], ["", "theorem parallel_termination:\n    assumes \"0 < n\"\n      and \"reachable x n ts (\\<lambda>_. 0) s\"\n    shows \"\\<exists>s'. final n s' \\<and> (step x n)\\<^sup>*\\<^sup>* s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. final n s' \\<and> (step x n)\\<^sup>*\\<^sup>* s s'", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  reachable x n ts (\\<lambda>_. 0) s\n\ngoal (1 subgoal):\n 1. \\<exists>s'. final n s' \\<and> (step x n)\\<^sup>*\\<^sup>* s s'", "by (rule \"termination\")"], ["", "end \\<comment> \\<open>Context for fixed \\<open>n\\<close>.\\<close>"], ["", "end"]]}