{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019/Challenge1A.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2019", "problem_names": ["lemma take_non_empty:\n    \"take xs \\<noteq> []\" if \"xs \\<noteq> []\"", "lemma tdconc: \"\\<exists>ys. xs = take_decr xs @ ys\"", "lemma ticonc: \"\\<exists>ys. xs = take_incr xs @ ys\"", "lemma take_conc: \"\\<exists>ys. xs = take xs@ys\"", "theorem concat_cuts: \"concat (cuts xs) = xs\"", "lemma tki: \"incr (take_incr xs)\"", "lemma tkd: \"decr (take_decr xs)\"", "lemma icod: \"incr (take xs) \\<or> decr (take xs)\"", "theorem cuts_incr_decr: \"\\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c\"", "lemma maxi_imp_non_empty: \"maxi xs \\<Longrightarrow> []\\<notin>set xs\"", "lemma tdconc': \"xs\\<noteq>[] \\<Longrightarrow> \n    \\<exists>ys. xs = take_decr xs @ ys \\<and> (ys\\<noteq>[] \n      \\<longrightarrow> \\<not>(last (take_decr xs) \\<ge> hd ys))\"", "lemma ticonc': \"xs\\<noteq>[] \\<Longrightarrow> \\<exists>ys. xs = take_incr xs @ ys \\<and> (ys\\<noteq>[] \\<longrightarrow> \\<not>(last (take_incr xs) < hd ys))\"", "lemma take_conc': \"xs\\<noteq>[] \\<Longrightarrow> \\<exists>ys. xs = take xs@ys \\<and> (ys\\<noteq>[] \\<longrightarrow> (\n    take xs=take_incr xs \\<and> \\<not>(last (take_incr xs) < hd ys)\n  \\<or> take xs=take_decr xs \\<and> \\<not>(last (take_decr xs) \\<ge> hd ys)  \n  ))\"", "lemma take_decr_non_empty:\n    \"take_decr xs \\<noteq> []\" if \"xs \\<noteq> []\"", "lemma take_incr_non_empty:\n    \"take_incr xs \\<noteq> []\" if \"xs \\<noteq> []\"", "lemma take_conc'': \"xs\\<noteq>[] \\<Longrightarrow> \\<exists>ys. xs = take xs@ys \\<and> (ys\\<noteq>[] \\<longrightarrow> (\n    incr (take xs) \\<and> \\<not>(last (take xs) < hd ys)\n  \\<or> decr (take xs) \\<and> \\<not>(last (take xs) \\<ge> hd ys)  \n  ))\"", "lemma [simp]: \"cuts [] = []\"", "lemma [simp]: \"cuts xs \\<noteq> [] \\<longleftrightarrow> xs \\<noteq> []\"", "lemma inv_cuts: \"cuts xs = c#cs \\<Longrightarrow> \\<exists>ys. c=take xs \\<and> xs=c@ys \\<and> cs = cuts ys\"", "theorem maximal_cuts: \"maxi (cuts xs)\"", "lemma idx_spec: \"fP xs \\<longleftrightarrow> (\\<forall>i<length xs - 1. P (xs!i) (xs!Suc i))\"", "lemma idx_spec: \"fP xs \\<longleftrightarrow> (\\<forall>i<length xs. P' (xs!i)) \\<and> (\\<forall>i<length xs - 1. P (xs!i) (xs!Suc i))\"", "lemma incr_by_idx: \"incr xs = (\\<forall>i<length xs - 1. xs ! i < xs ! Suc i)\"", "lemma decr_by_idx: \"decr xs = (\\<forall>i<length xs - 1. xs ! i \\<ge> xs ! Suc i)\"", "lemma maxi_by_idx: \"maxi xs \\<longleftrightarrow>\n    (\\<forall>i<length xs. xs ! i \\<noteq> []) \\<and>\n    (\\<forall>i<length xs - 1. \n         incr (xs ! i) \\<and> \\<not> last (xs ! i) < hd (xs ! Suc i) \n       \\<or> decr (xs ! i) \\<and> \\<not> hd (xs ! Suc i) \\<le> last (xs ! i)\n    )\"", "theorem all_correct:  \n    \"concat (cuts xs) = xs\"\n    \"\\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c\"\n    \"maxi (cuts xs)\"\n    \"[] \\<notin> set (cuts xs)\""], "translations": [["", "lemma take_non_empty:\n    \"take xs \\<noteq> []\" if \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Challenge1A.take xs \\<noteq> []", "using that"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Challenge1A.take xs \\<noteq> []", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; xs = []\\<rbrakk>\n    \\<Longrightarrow> Challenge1A.take xs \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>xs \\<noteq> []; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> Challenge1A.take xs \\<noteq> []", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs \\<noteq> []; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> Challenge1A.take xs \\<noteq> []", "subgoal for x ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; xs = x # ys\\<rbrakk>\n    \\<Longrightarrow> Challenge1A.take xs \\<noteq> []", "apply (cases ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; xs = x # ys; ys = []\\<rbrakk>\n    \\<Longrightarrow> Challenge1A.take xs \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>xs \\<noteq> []; xs = x # ys; ys = a # list\\<rbrakk>\n       \\<Longrightarrow> Challenge1A.take xs \\<noteq> []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All cuts_dom", "apply (relation \"measure length\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>xs x xa y.\n       \\<lbrakk>xs \\<noteq> []; x = take2 xs; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> (y, xs) \\<in> measure length", "apply (auto simp: take2_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<noteq> [] \\<Longrightarrow>\n       length xs - length (Challenge1A.take xs) < length xs", "using take_non_empty"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> Challenge1A.take ?xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<noteq> [] \\<Longrightarrow>\n       length xs - length (Challenge1A.take xs) < length xs", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare cuts.simps[simp del]"], ["", "subsection \\<open>Correctness\\<close>"], ["", "subsubsection \\<open>Property 1: The Exact Sequence is Covered\\<close>"], ["", "lemma tdconc: \"\\<exists>ys. xs = take_decr xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. xs = take_decr xs @ ys", "apply (induction xs rule: take_decr.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>ys. [] = take_decr [] @ ys\n 2. \\<And>x. \\<exists>ys. [x] = take_decr [x] @ ys\n 3. \\<And>x y xs.\n       (y \\<le> x \\<Longrightarrow>\n        \\<exists>ys. y # xs = take_decr (y # xs) @ ys) \\<Longrightarrow>\n       \\<exists>ys. x # y # xs = take_decr (x # y # xs) @ ys", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ticonc: \"\\<exists>ys. xs = take_incr xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. xs = take_incr xs @ ys", "apply (induction xs rule: take_incr.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>ys. [] = take_incr [] @ ys\n 2. \\<And>x. \\<exists>ys. [x] = take_incr [x] @ ys\n 3. \\<And>x y xs.\n       (x < y \\<Longrightarrow>\n        \\<exists>ys. y # xs = take_incr (y # xs) @ ys) \\<Longrightarrow>\n       \\<exists>ys. x # y # xs = take_incr (x # y # xs) @ ys", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_conc: \"\\<exists>ys. xs = take xs@ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. xs = Challenge1A.take xs @ ys", "using tdconc ticonc"], ["proof (prove)\nusing this:\n  \\<exists>ys. ?xs = take_decr ?xs @ ys\n  \\<exists>ys. ?xs = take_incr ?xs @ ys\n\ngoal (1 subgoal):\n 1. \\<exists>ys. xs = Challenge1A.take xs @ ys", "apply (cases xs rule: take.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>xs. \\<exists>ys. xs = take_decr xs @ ys;\n     \\<And>xs. \\<exists>ys. xs = take_incr xs @ ys; xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys. xs = Challenge1A.take xs @ ys\n 2. \\<And>x.\n       \\<lbrakk>\\<And>xs. \\<exists>ys. xs = take_decr xs @ ys;\n        \\<And>xs. \\<exists>ys. xs = take_incr xs @ ys; xs = [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys. xs = Challenge1A.take xs @ ys\n 3. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs. \\<exists>ys. xs = take_decr xs @ ys;\n        \\<And>xs. \\<exists>ys. xs = take_incr xs @ ys;\n        xs = x # y # xsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys. xs = Challenge1A.take xs @ ys", "by auto"], ["", "theorem concat_cuts: \"concat (cuts xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (cuts xs) = xs", "apply (induction xs rule: cuts.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>x xa y.\n           \\<lbrakk>xs \\<noteq> []; x = take2 xs; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> concat (cuts y) = y) \\<Longrightarrow>\n       concat (cuts xs) = xs", "apply (subst cuts.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>x xa y.\n           \\<lbrakk>xs \\<noteq> []; x = take2 xs; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> concat (cuts y) = y) \\<Longrightarrow>\n       concat\n        (if xs = [] then [] else let (c, xs) = take2 xs in c # cuts xs) =\n       xs", "apply (auto simp: take2_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>a xa.\n                   \\<lbrakk>a = Challenge1A.take xs;\n                    xa = Challenge1A.take xs\\<rbrakk>\n                   \\<Longrightarrow> concat\n(cuts (drop (length (Challenge1A.take xs)) xs)) =\n                                     drop (length (Challenge1A.take xs)) xs;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Challenge1A.take xs @\n                         drop (length (Challenge1A.take xs)) xs =\n                         xs", "by (metis append_eq_conv_conj take_conc)"], ["", "subsubsection \\<open>Property 2: Monotonicity\\<close>"], ["", "text \\<open>We define constants to specify increasing/decreasing sequences.\\<close>"], ["", "fun incr where\n    \"incr [] \\<longleftrightarrow> True\"\n  | \"incr [_] \\<longleftrightarrow> True\"\n  | \"incr (x#y#xs) \\<longleftrightarrow> x<y \\<and> incr (y#xs)\""], ["", "fun decr where\n    \"decr [] \\<longleftrightarrow> True\"\n  | \"decr [_] \\<longleftrightarrow> True\"\n  | \"decr (x#y#xs) \\<longleftrightarrow> x\\<ge>y \\<and> decr (y#xs)\""], ["", "lemma tki: \"incr (take_incr xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incr (take_incr xs)", "apply (induction xs rule: take_incr.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. incr (take_incr [])\n 2. \\<And>x. incr (take_incr [x])\n 3. \\<And>x y xs.\n       (x < y \\<Longrightarrow> incr (take_incr (y # xs))) \\<Longrightarrow>\n       incr (take_incr (x # y # xs))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>incr (take_incr (y # xs)); x < y\\<rbrakk>\n       \\<Longrightarrow> incr (x # take_incr (y # xs))", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>incr (take_incr (y # xs)); x < y; xs = []\\<rbrakk>\n       \\<Longrightarrow> incr (x # take_incr (y # xs))\n 2. \\<And>x y xs a list.\n       \\<lbrakk>incr (take_incr (y # xs)); x < y; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> incr (x # take_incr (y # xs))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tkd: \"decr (take_decr xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decr (take_decr xs)", "apply (induction xs rule: take_decr.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. decr (take_decr [])\n 2. \\<And>x. decr (take_decr [x])\n 3. \\<And>x y xs.\n       (y \\<le> x \\<Longrightarrow>\n        decr (take_decr (y # xs))) \\<Longrightarrow>\n       decr (take_decr (x # y # xs))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>decr (take_decr (y # xs)); y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> decr (x # take_decr (y # xs))", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>decr (take_decr (y # xs)); y \\<le> x; xs = []\\<rbrakk>\n       \\<Longrightarrow> decr (x # take_decr (y # xs))\n 2. \\<And>x y xs a list.\n       \\<lbrakk>decr (take_decr (y # xs)); y \\<le> x; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> decr (x # take_decr (y # xs))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma icod: \"incr (take xs) \\<or> decr (take xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incr (Challenge1A.take xs) \\<or> decr (Challenge1A.take xs)", "apply (cases xs rule: take.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    incr (Challenge1A.take xs) \\<or> decr (Challenge1A.take xs)\n 2. \\<And>x.\n       xs = [x] \\<Longrightarrow>\n       incr (Challenge1A.take xs) \\<or> decr (Challenge1A.take xs)\n 3. \\<And>x y xsa.\n       xs = x # y # xsa \\<Longrightarrow>\n       incr (Challenge1A.take xs) \\<or> decr (Challenge1A.take xs)", "apply (auto simp: tki tkd simp del: take_incr.simps take_decr.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem cuts_incr_decr: \"\\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c", "apply (induction xs rule: cuts.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>x xa y.\n           \\<lbrakk>xs \\<noteq> []; x = take2 xs; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> \\<forall>c\\<in>set (cuts y).\n                                incr c \\<or> decr c) \\<Longrightarrow>\n       \\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c", "apply (subst cuts.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>x xa y.\n           \\<lbrakk>xs \\<noteq> []; x = take2 xs; (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> \\<forall>c\\<in>set (cuts y).\n                                incr c \\<or> decr c) \\<Longrightarrow>\n       \\<forall>c\\<in>set (if xs = [] then []\n                           else let (c, xs) = take2 xs in c # cuts xs).\n          incr c \\<or> decr c", "apply (auto simp: take2_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>a xa.\n                   \\<lbrakk>a = Challenge1A.take xs;\n                    xa = Challenge1A.take xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>c\n        \\<in>set (cuts (drop (length (Challenge1A.take xs)) xs)).\n  incr c \\<or> decr c;\n        xs \\<noteq> []; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "using icod"], ["proof (prove)\nusing this:\n  incr (Challenge1A.take ?xs) \\<or> decr (Challenge1A.take ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>a xa.\n                   \\<lbrakk>a = Challenge1A.take xs;\n                    xa = Challenge1A.take xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>c\n        \\<in>set (cuts (drop (length (Challenge1A.take xs)) xs)).\n  incr c \\<or> decr c;\n        xs \\<noteq> []; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "by blast"], ["", "subsubsection \\<open>Property 3: Maximality\\<close>"], ["", "text \\<open>Specification of a cut that consists of maximal segments:\n    The segements are non-empty, and for every two neighbouring segments,\n    the first value of the last segment cannot be used to continue the first segment:\n  \\<close>"], ["", "fun maxi where\n     \"maxi [] \\<longleftrightarrow> True\"\n   | \"maxi [c] \\<longleftrightarrow> c\\<noteq>[]\"\n   | \"maxi (c1#c2#cs) \\<longleftrightarrow> (c1\\<noteq>[] \\<and> c2\\<noteq>[] \\<and> maxi (c2#cs) \\<and> ( \n        incr c1 \\<and> \\<not>(last c1 < hd c2) \n      \\<or> decr c1 \\<and> \\<not>(last c1 \\<ge> hd c2)        \n        ))\""], ["", "text \\<open>Obviously, our specification implies that there are no \n    empty segments\\<close>"], ["", "lemma maxi_imp_non_empty: \"maxi xs \\<Longrightarrow> []\\<notin>set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxi xs \\<Longrightarrow> [] \\<notin> set xs", "by (induction xs rule: maxi.induct) auto"], ["", "lemma tdconc': \"xs\\<noteq>[] \\<Longrightarrow> \n    \\<exists>ys. xs = take_decr xs @ ys \\<and> (ys\\<noteq>[] \n      \\<longrightarrow> \\<not>(last (take_decr xs) \\<ge> hd ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       xs = take_decr xs @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow>\n        \\<not> hd ys \\<le> last (take_decr xs))", "apply (induction xs rule: take_decr.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       [] = take_decr [] @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow>\n        \\<not> hd ys \\<le> last (take_decr []))\n 2. \\<And>x.\n       [x] \\<noteq> [] \\<Longrightarrow>\n       \\<exists>ys.\n          [x] = take_decr [x] @ ys \\<and>\n          (ys \\<noteq> [] \\<longrightarrow>\n           \\<not> hd ys \\<le> last (take_decr [x]))\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>y \\<le> x; y # xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>ys.\n                                     y # xs = take_decr (y # xs) @ ys \\<and>\n                                     (ys \\<noteq> [] \\<longrightarrow>\n\\<not> hd ys \\<le> last (take_decr (y # xs)));\n        x # y # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            x # y # xs = take_decr (x # y # xs) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             \\<not> hd ys\n                                    \\<le> last (take_decr (x # y # xs)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>\\<not> y \\<le> last []; take_decr (y # xs) = [];\n        y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>\\<not> y \\<le> last []; take_decr (y # xs) = []; y \\<le> x;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y xs a list.\n       \\<lbrakk>\\<not> y \\<le> last []; take_decr (y # xs) = []; y \\<le> x;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ticonc': \"xs\\<noteq>[] \\<Longrightarrow> \\<exists>ys. xs = take_incr xs @ ys \\<and> (ys\\<noteq>[] \\<longrightarrow> \\<not>(last (take_incr xs) < hd ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       xs = take_incr xs @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow> \\<not> last (take_incr xs) < hd ys)", "apply (induction xs rule: take_incr.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       [] = take_incr [] @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow> \\<not> last (take_incr []) < hd ys)\n 2. \\<And>x.\n       [x] \\<noteq> [] \\<Longrightarrow>\n       \\<exists>ys.\n          [x] = take_incr [x] @ ys \\<and>\n          (ys \\<noteq> [] \\<longrightarrow>\n           \\<not> last (take_incr [x]) < hd ys)\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>x < y; y # xs \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> \\<exists>ys.\n                                     y # xs = take_incr (y # xs) @ ys \\<and>\n                                     (ys \\<noteq> [] \\<longrightarrow>\n\\<not> last (take_incr (y # xs)) < hd ys);\n        x # y # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            x # y # xs = take_incr (x # y # xs) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             \\<not> last (take_incr (x # y # xs)) < hd ys)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>\\<not> last [] < y; take_incr (y # xs) = []; x < y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>\\<not> last [] < y; take_incr (y # xs) = []; x < y;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y xs a list.\n       \\<lbrakk>\\<not> last [] < y; take_incr (y # xs) = []; x < y;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_conc': \"xs\\<noteq>[] \\<Longrightarrow> \\<exists>ys. xs = take xs@ys \\<and> (ys\\<noteq>[] \\<longrightarrow> (\n    take xs=take_incr xs \\<and> \\<not>(last (take_incr xs) < hd ys)\n  \\<or> take xs=take_decr xs \\<and> \\<not>(last (take_decr xs) \\<ge> hd ys)  \n  ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       xs = Challenge1A.take xs @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow>\n        Challenge1A.take xs = take_incr xs \\<and>\n        \\<not> last (take_incr xs) < hd ys \\<or>\n        Challenge1A.take xs = take_decr xs \\<and>\n        \\<not> hd ys \\<le> last (take_decr xs))", "using tdconc' ticonc'"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ys.\n     ?xs = take_decr ?xs @ ys \\<and>\n     (ys \\<noteq> [] \\<longrightarrow>\n      \\<not> hd ys \\<le> last (take_decr ?xs))\n  ?xs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ys.\n     ?xs = take_incr ?xs @ ys \\<and>\n     (ys \\<noteq> [] \\<longrightarrow> \\<not> last (take_incr ?xs) < hd ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       xs = Challenge1A.take xs @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow>\n        Challenge1A.take xs = take_incr xs \\<and>\n        \\<not> last (take_incr xs) < hd ys \\<or>\n        Challenge1A.take xs = take_decr xs \\<and>\n        \\<not> hd ys \\<le> last (take_decr xs))", "apply (cases xs rule: take.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<noteq> [];\n     \\<And>xs.\n        xs \\<noteq> [] \\<Longrightarrow>\n        \\<exists>ys.\n           xs = take_decr xs @ ys \\<and>\n           (ys \\<noteq> [] \\<longrightarrow>\n            \\<not> hd ys \\<le> last (take_decr xs));\n     \\<And>xs.\n        xs \\<noteq> [] \\<Longrightarrow>\n        \\<exists>ys.\n           xs = take_incr xs @ ys \\<and>\n           (ys \\<noteq> [] \\<longrightarrow>\n            \\<not> last (take_incr xs) < hd ys);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         xs = Challenge1A.take xs @ ys \\<and>\n                         (ys \\<noteq> [] \\<longrightarrow>\n                          Challenge1A.take xs = take_incr xs \\<and>\n                          \\<not> last (take_incr xs) < hd ys \\<or>\n                          Challenge1A.take xs = take_decr xs \\<and>\n                          \\<not> hd ys \\<le> last (take_decr xs))\n 2. \\<And>x.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_decr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        xs = [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs = Challenge1A.take xs @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             Challenge1A.take xs = take_incr xs \\<and>\n                             \\<not> last (take_incr xs) < hd ys \\<or>\n                             Challenge1A.take xs = take_decr xs \\<and>\n                             \\<not> hd ys \\<le> last (take_decr xs))\n 3. \\<And>x y xsa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_decr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        xs = x # y # xsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs = Challenge1A.take xs @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             Challenge1A.take xs = take_incr xs \\<and>\n                             \\<not> last (take_incr xs) < hd ys \\<or>\n                             Challenge1A.take xs = take_decr xs \\<and>\n                             \\<not> hd ys \\<le> last (take_decr xs))", "by auto"], ["", "lemma take_decr_non_empty:\n    \"take_decr xs \\<noteq> []\" if \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_decr xs \\<noteq> []", "using that"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. take_decr xs \\<noteq> []", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; xs = []\\<rbrakk>\n    \\<Longrightarrow> take_decr xs \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>xs \\<noteq> []; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> take_decr xs \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = a # list; take_decr (a # list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for x ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = x # ys; take_decr (x # ys) = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x # ys; take_decr (x # ys) = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a list.\n       \\<lbrakk>xs = x # ys; take_decr (x # ys) = []; ys = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_incr_non_empty:\n    \"take_incr xs \\<noteq> []\" if \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_incr xs \\<noteq> []", "using that"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. take_incr xs \\<noteq> []", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; xs = []\\<rbrakk>\n    \\<Longrightarrow> take_incr xs \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>xs \\<noteq> []; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> take_incr xs \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = a # list; take_incr (a # list) = []\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for x ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = x # ys; take_incr (x # ys) = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = x # ys; take_incr (x # ys) = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a list.\n       \\<lbrakk>xs = x # ys; take_incr (x # ys) = []; ys = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_conc'': \"xs\\<noteq>[] \\<Longrightarrow> \\<exists>ys. xs = take xs@ys \\<and> (ys\\<noteq>[] \\<longrightarrow> (\n    incr (take xs) \\<and> \\<not>(last (take xs) < hd ys)\n  \\<or> decr (take xs) \\<and> \\<not>(last (take xs) \\<ge> hd ys)  \n  ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       xs = Challenge1A.take xs @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow>\n        incr (Challenge1A.take xs) \\<and>\n        \\<not> last (Challenge1A.take xs) < hd ys \\<or>\n        decr (Challenge1A.take xs) \\<and>\n        \\<not> hd ys \\<le> last (Challenge1A.take xs))", "using tdconc' ticonc' tki tkd"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ys.\n     ?xs = take_decr ?xs @ ys \\<and>\n     (ys \\<noteq> [] \\<longrightarrow>\n      \\<not> hd ys \\<le> last (take_decr ?xs))\n  ?xs \\<noteq> [] \\<Longrightarrow>\n  \\<exists>ys.\n     ?xs = take_incr ?xs @ ys \\<and>\n     (ys \\<noteq> [] \\<longrightarrow> \\<not> last (take_incr ?xs) < hd ys)\n  incr (take_incr ?xs)\n  decr (take_decr ?xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>ys.\n       xs = Challenge1A.take xs @ ys \\<and>\n       (ys \\<noteq> [] \\<longrightarrow>\n        incr (Challenge1A.take xs) \\<and>\n        \\<not> last (Challenge1A.take xs) < hd ys \\<or>\n        decr (Challenge1A.take xs) \\<and>\n        \\<not> hd ys \\<le> last (Challenge1A.take xs))", "apply (cases xs rule: take.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<noteq> [];\n     \\<And>xs.\n        xs \\<noteq> [] \\<Longrightarrow>\n        \\<exists>ys.\n           xs = take_decr xs @ ys \\<and>\n           (ys \\<noteq> [] \\<longrightarrow>\n            \\<not> hd ys \\<le> last (take_decr xs));\n     \\<And>xs.\n        xs \\<noteq> [] \\<Longrightarrow>\n        \\<exists>ys.\n           xs = take_incr xs @ ys \\<and>\n           (ys \\<noteq> [] \\<longrightarrow>\n            \\<not> last (take_incr xs) < hd ys);\n     \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         xs = Challenge1A.take xs @ ys \\<and>\n                         (ys \\<noteq> [] \\<longrightarrow>\n                          incr (Challenge1A.take xs) \\<and>\n                          \\<not> last (Challenge1A.take xs) < hd ys \\<or>\n                          decr (Challenge1A.take xs) \\<and>\n                          \\<not> hd ys \\<le> last (Challenge1A.take xs))\n 2. \\<And>x.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_decr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs = Challenge1A.take xs @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (Challenge1A.take xs) \\<and>\n                             \\<not> last (Challenge1A.take xs) < hd ys \\<or>\n                             decr (Challenge1A.take xs) \\<and>\n                             \\<not> hd ys \\<le> last (Challenge1A.take xs))\n 3. \\<And>x y xsa.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_decr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs = Challenge1A.take xs @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (Challenge1A.take xs) \\<and>\n                             \\<not> last (Challenge1A.take xs) < hd ys \\<or>\n                             decr (Challenge1A.take xs) \\<and>\n                             \\<not> hd ys \\<le> last (Challenge1A.take xs))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_incr (y # xsa) = [];\n        take_decr (y # xsa) \\<noteq> []; \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_decr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> last (take_decr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_decr (y # xsa)))\n 2. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_incr (y # xsa) \\<noteq> [];\n        take_decr (y # xsa) = []; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_incr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> last (take_incr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_incr (y # xsa)))\n 3. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_incr (y # xsa) \\<noteq> [];\n        take_decr (y # xsa) \\<noteq> []; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_incr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> last (take_incr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_incr (y # xsa)))\n 4. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_incr (y # xsa) \\<noteq> [];\n        take_decr (y # xsa) \\<noteq> []; \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_decr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> last (take_decr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_decr (y # xsa)))", "apply (auto simp add: take_incr_non_empty)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_decr (y # xsa) = []; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_incr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> last (take_incr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_incr (y # xsa)))\n 2. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_decr (y # xsa) \\<noteq> []; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_incr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> last (take_incr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_incr (y # xsa)))\n 3. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_decr (y # xsa) \\<noteq> [];\n        \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_decr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> last (take_decr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_decr (y # xsa)))", "apply (simp add: take_decr_non_empty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_decr (y # xsa) \\<noteq> []; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_incr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> last (take_incr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_incr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_incr (y # xsa)))\n 2. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_decr (y # xsa) \\<noteq> [];\n        \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_decr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> last (take_decr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_decr (y # xsa)))", "apply (metis list.distinct(1) take_incr.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<noteq> [] \\<Longrightarrow>\n                   \\<exists>ys.\n                      xs = take_decr xs @ ys \\<and>\n                      (ys \\<noteq> [] \\<longrightarrow>\n                       \\<not> hd ys \\<le> last (take_decr xs));\n        \\<And>xs.\n           xs \\<noteq> [] \\<Longrightarrow>\n           \\<exists>ys.\n              xs = take_incr xs @ ys \\<and>\n              (ys \\<noteq> [] \\<longrightarrow>\n               \\<not> last (take_incr xs) < hd ys);\n        \\<And>xs. incr (take_incr xs); \\<And>xs. decr (take_decr xs);\n        xs = x # y # xsa; take_decr (y # xsa) \\<noteq> [];\n        \\<not> x < y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            y # xsa = take_decr (y # xsa) @ ys \\<and>\n                            (ys \\<noteq> [] \\<longrightarrow>\n                             incr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> last (take_decr (y # xsa)) < hd ys \\<or>\n                             decr (x # take_decr (y # xsa)) \\<and>\n                             \\<not> hd ys \\<le> last (take_decr (y # xsa)))", "by (smt list.simps(3) take_decr.simps(3))"], ["", "lemma [simp]: \"cuts [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cuts [] = []", "apply (subst cuts.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [] = [] then [] else let (c, xs) = take2 [] in c # cuts xs) = []", "by auto"], ["", "lemma [simp]: \"cuts xs \\<noteq> [] \\<longleftrightarrow> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cuts xs \\<noteq> []) = (xs \\<noteq> [])", "apply (subst cuts.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if xs = [] then []\n      else let (c, xs) = take2 xs in c # cuts xs) \\<noteq>\n     []) =\n    (xs \\<noteq> [])", "apply (auto simp: take2_def Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_cuts: \"cuts xs = c#cs \\<Longrightarrow> \\<exists>ys. c=take xs \\<and> xs=c@ys \\<and> cs = cuts ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cuts xs = c # cs \\<Longrightarrow>\n    \\<exists>ys.\n       c = Challenge1A.take xs \\<and> xs = c @ ys \\<and> cs = cuts ys", "apply (subst (asm) cuts.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xs = [] then [] else let (c, xs) = take2 xs in c # cuts xs) =\n    c # cs \\<Longrightarrow>\n    \\<exists>ys.\n       c = Challenge1A.take xs \\<and> xs = c @ ys \\<and> cs = cuts ys", "apply (cases xs rule: cuts.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       \\<lbrakk>(if xs = [] then []\n                 else let (c, xs) = take2 xs in c # cuts xs) =\n                c # cs;\n        xs = xsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            c = Challenge1A.take xs \\<and>\n                            xs = c @ ys \\<and> cs = cuts ys", "apply (auto split: if_splits simp: take2_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; c = Challenge1A.take xs;\n     cs = cuts (drop (length (Challenge1A.take xs)) xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys.\n                         xs = Challenge1A.take xs @ ys \\<and>\n                         cuts (drop (length (Challenge1A.take xs)) xs) =\n                         cuts ys", "by (metis append_eq_conv_conj take_conc)"], ["", "theorem maximal_cuts: \"maxi (cuts xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxi (cuts xs)", "apply (induction \"cuts xs\" arbitrary: xs rule: maxi.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs. [] = cuts xs \\<Longrightarrow> maxi (cuts xs)\n 2. \\<And>c xs. [c] = cuts xs \\<Longrightarrow> maxi (cuts xs)\n 3. \\<And>c1 c2 cs xs.\n       \\<lbrakk>\\<And>xs.\n                   c2 # cs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 # c2 # cs = cuts xs\\<rbrakk>\n       \\<Longrightarrow> maxi (cuts xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = cuts xs_ \\<Longrightarrow> maxi (cuts xs_)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c xs. [c] = cuts xs \\<Longrightarrow> maxi (cuts xs)\n 2. \\<And>c1 c2 cs xs.\n       \\<lbrakk>\\<And>xs.\n                   c2 # cs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 # c2 # cs = cuts xs\\<rbrakk>\n       \\<Longrightarrow> maxi (cuts xs)", "subgoal for c xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. [c] = cuts xs \\<Longrightarrow> maxi (cuts xs)", "apply (drule sym; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cuts xs = [c] \\<Longrightarrow> c \\<noteq> []", "apply (subst (asm) cuts.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if xs = [] then [] else let (c, xs) = take2 xs in c # cuts xs) =\n    [c] \\<Longrightarrow>\n    c \\<noteq> []", "apply (auto split: if_splits prod.splits simp: take2_def Let_def take_non_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2 cs xs.\n       \\<lbrakk>\\<And>xs.\n                   c2 # cs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 # c2 # cs = cuts xs\\<rbrakk>\n       \\<Longrightarrow> maxi (cuts xs)", "subgoal for c1 c2 cs xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. c2 # cs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 # c2 # cs = cuts xs\\<rbrakk>\n    \\<Longrightarrow> maxi (cuts xs)", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. c2 # cs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     cuts xs = c1 # c2 # cs\\<rbrakk>\n    \\<Longrightarrow> maxi (cuts xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. c2 # cs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     cuts xs = c1 # c2 # cs\\<rbrakk>\n    \\<Longrightarrow> c1 \\<noteq> [] \\<and>\n                      c2 \\<noteq> [] \\<and>\n                      maxi (c2 # cs) \\<and>\n                      (incr c1 \\<and> \\<not> last c1 < hd c2 \\<or>\n                       decr c1 \\<and> \\<not> hd c2 \\<le> last c1)", "apply (drule inv_cuts; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys\\<rbrakk>\n       \\<Longrightarrow> Challenge1A.take xs \\<noteq> [] \\<and>\n                         c2 \\<noteq> [] \\<and>\n                         (incr (Challenge1A.take xs) \\<and>\n                          \\<not> last (Challenge1A.take xs) < hd c2 \\<or>\n                          decr (Challenge1A.take xs) \\<and>\n                          \\<not> hd c2 \\<le> last (Challenge1A.take xs))", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>xs. cuts xs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = []; c2 # cs = cuts xs; Challenge1A.take xs = []\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        [] # cs = cuts ys; c2 = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)\n 4. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs);\n        last (Challenge1A.take xs) < hd c2\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; hd c2 \\<le> last (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. cuts xs = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = []; c2 # cs = cuts xs; Challenge1A.take xs = []\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis cuts.simps list.distinct(1) take_non_empty)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        [] # cs = cuts ys; c2 = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)\n 3. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs);\n        last (Challenge1A.take xs) < hd c2\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; hd c2 \\<le> last (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. cuts ys_ = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys_;\n     [] # cs = cuts ys_; c2 = []\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis append.left_neutral inv_cuts not_Cons_self)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)\n 2. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs);\n        last (Challenge1A.take xs) < hd c2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; hd c2 \\<le> last (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. cuts ys_ = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys_;\n     c2 # cs = cuts ys_; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n    \\<Longrightarrow> incr (Challenge1A.take xs)", "using icod"], ["proof (prove)\nusing this:\n  incr (Challenge1A.take ?xs) \\<or> decr (Challenge1A.take ?xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. cuts ys_ = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys_;\n     c2 # cs = cuts ys_; \\<not> decr (Challenge1A.take xs)\\<rbrakk>\n    \\<Longrightarrow> incr (Challenge1A.take xs)", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; \\<not> decr (Challenge1A.take xs);\n        last (Challenge1A.take xs) < hd c2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; hd c2 \\<le> last (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. cuts ys_ = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys_;\n     c2 # cs = cuts ys_; \\<not> decr (Challenge1A.take xs);\n     last (Challenge1A.take xs) < hd c2\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis\n            Nil_is_append_conv cuts.simps hd_append2 inv_cuts list.distinct(1)\n            same_append_eq take_conc'' take_non_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>xs.\n                   cuts ys = cuts xs \\<Longrightarrow> maxi (cuts xs);\n        c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys;\n        c2 # cs = cuts ys; hd c2 \\<le> last (Challenge1A.take xs)\\<rbrakk>\n       \\<Longrightarrow> incr (Challenge1A.take xs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs. cuts ys_ = cuts xs \\<Longrightarrow> maxi (cuts xs);\n     c1 = Challenge1A.take xs; xs = Challenge1A.take xs @ ys_;\n     c2 # cs = cuts ys_; hd c2 \\<le> last (Challenge1A.take xs)\\<rbrakk>\n    \\<Longrightarrow> incr (Challenge1A.take xs)", "by (metis\n            append_is_Nil_conv cuts.simps hd_append2 inv_cuts list.distinct(1)\n            same_append_eq take_conc'' take_non_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Equivalent Formulation Over Indexes\\<close>"], ["", "text \\<open>After the competition, we got the comment that a specification of \n    monotonic sequences via indexes might be more readable.\n  \n    We show that our functional specification is equivalent to a \n    specification over indexes.\\<close>"], ["", "fun ii_induction where\n    \"ii_induction [] = ()\"\n  | \"ii_induction [_] = ()\"\n  | \"ii_induction (_#y#xs) = ii_induction (y#xs)\""], ["", "locale cnvSpec =\n    fixes fP P\n    assumes [simp]: \"fP [] \\<longleftrightarrow> True\"\n    assumes [simp]: \"fP [x] \\<longleftrightarrow> True\"\n    assumes [simp]: \"fP (a#b#xs) \\<longleftrightarrow> P a b \\<and> fP (b#xs)\"\n  begin"], ["", "lemma idx_spec: \"fP xs \\<longleftrightarrow> (\\<forall>i<length xs - 1. P (xs!i) (xs!Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fP xs = (\\<forall>i<length xs - 1. P (xs ! i) (xs ! Suc i))", "apply (induction xs rule: ii_induction.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fP [] = (\\<forall>i<length [] - 1. P ([] ! i) ([] ! Suc i))\n 2. \\<And>uu_.\n       fP [uu_] =\n       (\\<forall>i<length [uu_] - 1. P ([uu_] ! i) ([uu_] ! Suc i))\n 3. \\<And>uv_ y xs.\n       fP (y # xs) =\n       (\\<forall>i<length (y # xs) - 1.\n           P ((y # xs) ! i) ((y # xs) ! Suc i)) \\<Longrightarrow>\n       fP (uv_ # y # xs) =\n       (\\<forall>i<length (uv_ # y # xs) - 1.\n           P ((uv_ # y # xs) ! i) ((uv_ # y # xs) ! Suc i))", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (3 subgoals):\n 1. fP [] = (\\<forall>i<length [] - 1. P ([] ! i) ([] ! Suc i))\n 2. \\<And>uu_.\n       fP [uu_] =\n       (\\<forall>i<length [uu_] - 1. P ([uu_] ! i) ([uu_] ! Suc i))\n 3. \\<And>uv_ y xs.\n       fP (y # xs) =\n       (\\<forall>i<length (y # xs) - 1.\n           P ((y # xs) ! i) ((y # xs) ! Suc i)) \\<Longrightarrow>\n       fP (uv_ # y # xs) =\n       (\\<forall>i<length (uv_ # y # xs) - 1.\n           P ((uv_ # y # xs) ! i) ((uv_ # y # xs) ! Suc i))", "by auto"], ["", "end"], ["", "locale cnvSpec' =\n    fixes fP P P'\n    assumes [simp]: \"fP [] \\<longleftrightarrow> True\"\n    assumes [simp]: \"fP [x] \\<longleftrightarrow> P' x\"\n    assumes [simp]: \"fP (a#b#xs) \\<longleftrightarrow> P' a \\<and> P' b \\<and> P a b \\<and> fP (b#xs)\"\n  begin"], ["", "lemma idx_spec: \"fP xs \\<longleftrightarrow> (\\<forall>i<length xs. P' (xs!i)) \\<and> (\\<forall>i<length xs - 1. P (xs!i) (xs!Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fP xs =\n    ((\\<forall>i<length xs. P' (xs ! i)) \\<and>\n     (\\<forall>i<length xs - 1. P (xs ! i) (xs ! Suc i)))", "apply (induction xs rule: ii_induction.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fP [] =\n    ((\\<forall>i<length []. P' ([] ! i)) \\<and>\n     (\\<forall>i<length [] - 1. P ([] ! i) ([] ! Suc i)))\n 2. \\<And>uu_.\n       fP [uu_] =\n       ((\\<forall>i<length [uu_]. P' ([uu_] ! i)) \\<and>\n        (\\<forall>i<length [uu_] - 1. P ([uu_] ! i) ([uu_] ! Suc i)))\n 3. \\<And>uv_ y xs.\n       fP (y # xs) =\n       ((\\<forall>i<length (y # xs). P' ((y # xs) ! i)) \\<and>\n        (\\<forall>i<length (y # xs) - 1.\n            P ((y # xs) ! i) ((y # xs) ! Suc i))) \\<Longrightarrow>\n       fP (uv_ # y # xs) =\n       ((\\<forall>i<length (uv_ # y # xs). P' ((uv_ # y # xs) ! i)) \\<and>\n        (\\<forall>i<length (uv_ # y # xs) - 1.\n            P ((uv_ # y # xs) ! i) ((uv_ # y # xs) ! Suc i)))", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       fP [uu_] =\n       ((\\<forall>i<length [uu_]. P' ([uu_] ! i)) \\<and>\n        (\\<forall>i<length [uu_] - 1. P ([uu_] ! i) ([uu_] ! Suc i)))\n 2. \\<And>uv_ y xs.\n       fP (y # xs) =\n       ((\\<forall>i<length (y # xs). P' ((y # xs) ! i)) \\<and>\n        (\\<forall>i<length (y # xs) - 1.\n            P ((y # xs) ! i) ((y # xs) ! Suc i))) \\<Longrightarrow>\n       fP (uv_ # y # xs) =\n       ((\\<forall>i<length (uv_ # y # xs). P' ((uv_ # y # xs) ! i)) \\<and>\n        (\\<forall>i<length (uv_ # y # xs) - 1.\n            P ((uv_ # y # xs) ! i) ((uv_ # y # xs) ! Suc i)))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uv_ y xs.\n       fP (y # xs) =\n       ((\\<forall>i<length (y # xs). P' ((y # xs) ! i)) \\<and>\n        (\\<forall>i<length (y # xs) - 1.\n            P ((y # xs) ! i) ((y # xs) ! Suc i))) \\<Longrightarrow>\n       fP (uv_ # y # xs) =\n       ((\\<forall>i<length (uv_ # y # xs). P' ((uv_ # y # xs) ! i)) \\<and>\n        (\\<forall>i<length (uv_ # y # xs) - 1.\n            P ((uv_ # y # xs) ! i) ((uv_ # y # xs) ! Suc i)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uv_ y xs.\n       fP (y # xs) =\n       ((\\<forall>i<Suc (length xs). P' ((y # xs) ! i)) \\<and>\n        (\\<forall>i<length xs. P ((y # xs) ! i) (xs ! i))) \\<Longrightarrow>\n       (P' uv_ \\<and>\n        P' y \\<and>\n        P uv_ y \\<and>\n        (\\<forall>i<Suc (length xs). P' ((y # xs) ! i)) \\<and>\n        (\\<forall>i<length xs. P ((y # xs) ! i) (xs ! i))) =\n       ((\\<forall>i<Suc (Suc (length xs)). P' ((uv_ # y # xs) ! i)) \\<and>\n        (\\<forall>i<Suc (length xs). P ((uv_ # y # xs) ! i) ((y # xs) ! i)))", "by (smt less_Suc_eq_0_disj nth_Cons_0 nth_Cons_Suc)"], ["", "end"], ["", "interpretation INCR: cnvSpec incr \"(<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnvSpec incr (<)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. incr [] = True\n 2. \\<And>x. incr [x] = True\n 3. \\<And>a b xs. incr (a # b # xs) = (a < b \\<and> incr (b # xs))", "by auto"], ["", "interpretation DECR: cnvSpec decr \"(\\<ge>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnvSpec decr (\\<lambda>x y. y \\<le> x)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. decr [] = True\n 2. \\<And>x. decr [x] = True\n 3. \\<And>a b xs. decr (a # b # xs) = (b \\<le> a \\<and> decr (b # xs))", "by auto"], ["", "interpretation MAXI: cnvSpec' maxi \"\\<lambda>c1 c2. ( ( \n        incr c1 \\<and> \\<not>(last c1 < hd c2) \n      \\<or> decr c1 \\<and> \\<not>(last c1 \\<ge> hd c2)        \n        ))\"\n      \"\\<lambda>x. x \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnvSpec' maxi\n     (\\<lambda>c1 c2.\n         incr c1 \\<and> \\<not> last c1 < hd c2 \\<or>\n         decr c1 \\<and> \\<not> hd c2 \\<le> last c1)\n     (\\<lambda>x. x \\<noteq> [])", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. maxi [] = True\n 2. \\<And>x. maxi [x] = (x \\<noteq> [])\n 3. \\<And>a b xs.\n       maxi (a # b # xs) =\n       (a \\<noteq> [] \\<and>\n        b \\<noteq> [] \\<and>\n        (incr a \\<and> \\<not> last a < hd b \\<or>\n         decr a \\<and> \\<not> hd b \\<le> last a) \\<and>\n        maxi (b # xs))", "by auto"], ["", "lemma incr_by_idx: \"incr xs = (\\<forall>i<length xs - 1. xs ! i < xs ! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incr xs = (\\<forall>i<length xs - 1. xs ! i < xs ! Suc i)", "by (rule INCR.idx_spec)"], ["", "lemma decr_by_idx: \"decr xs = (\\<forall>i<length xs - 1. xs ! i \\<ge> xs ! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decr xs = (\\<forall>i<length xs - 1. xs ! Suc i \\<le> xs ! i)", "by (rule DECR.idx_spec)"], ["", "lemma maxi_by_idx: \"maxi xs \\<longleftrightarrow>\n    (\\<forall>i<length xs. xs ! i \\<noteq> []) \\<and>\n    (\\<forall>i<length xs - 1. \n         incr (xs ! i) \\<and> \\<not> last (xs ! i) < hd (xs ! Suc i) \n       \\<or> decr (xs ! i) \\<and> \\<not> hd (xs ! Suc i) \\<le> last (xs ! i)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxi xs =\n    ((\\<forall>i<length xs. xs ! i \\<noteq> []) \\<and>\n     (\\<forall>i<length xs - 1.\n         incr (xs ! i) \\<and> \\<not> last (xs ! i) < hd (xs ! Suc i) \\<or>\n         decr (xs ! i) \\<and> \\<not> hd (xs ! Suc i) \\<le> last (xs ! i)))", "by (rule MAXI.idx_spec)"], ["", "theorem all_correct:  \n    \"concat (cuts xs) = xs\"\n    \"\\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c\"\n    \"maxi (cuts xs)\"\n    \"[] \\<notin> set (cuts xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat (cuts xs) = xs &&&\n     \\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c) &&&\n    maxi (cuts xs) &&& [] \\<notin> set (cuts xs)", "using cuts_incr_decr concat_cuts maximal_cuts \n          maxi_imp_non_empty[OF maximal_cuts]"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set (cuts ?xs). incr c \\<or> decr c\n  concat (cuts ?xs) = ?xs\n  maxi (cuts ?xs)\n  [] \\<notin> set (cuts ?xs1)\n\ngoal (1 subgoal):\n 1. (concat (cuts xs) = xs &&&\n     \\<forall>c\\<in>set (cuts xs). incr c \\<or> decr c) &&&\n    maxi (cuts xs) &&& [] \\<notin> set (cuts xs)", "by auto"], ["", "end"]]}