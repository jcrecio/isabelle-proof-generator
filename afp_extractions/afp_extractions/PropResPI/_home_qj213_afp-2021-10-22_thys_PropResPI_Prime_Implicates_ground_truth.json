{"file_name": "/home/qj213/afp-2021-10-22/thys/PropResPI/Prime_Implicates.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PropResPI", "problem_names": ["lemma partial_evaluation_is_saturated : \n  assumes \"saturated_binary_rule resolvent S\"\n  shows \"saturated_binary_rule ordered_resolvent (partial_evaluation S C)\"", "lemma evaluation_wrt_implicate_is_unsat : \n  assumes \"entails S C\"\n  assumes \"\\<not>tautology C\"\n  shows \"\\<not>satisfiable (partial_evaluation S C)\"", "lemma entailment_and_implicates:\n  assumes \"entails_formula S1 S2\"\n  shows \"implicates S2 \\<subseteq> implicates S1\"", "lemma equivalence_and_implicates:\n  assumes \"equivalent S1 S2\"\n  shows \"implicates S1 = implicates S2\"", "lemma equivalence_and_prime_implicates:\n  assumes \"equivalent S1 S2\"\n  shows \"prime_implicates S1 = prime_implicates S2\"", "lemma unrestricted_resolution_is_deductive_complete : \n  assumes \"saturated_binary_rule resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"C \\<in> implicates S\"\n  shows \"redundant C S\"", "lemma prime_implicates_generation_correct :\n  assumes \"saturated_binary_rule resolvent S\"\n  assumes \"non_redundant S\"\n  assumes \"all_fulfill finite S\"\n  shows \"S \\<subseteq> prime_implicates S\"", "theorem prime_implicates_of_saturated_sets: \n  assumes \"saturated_binary_rule resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"non_redundant S\"\n  shows \"S = prime_implicates S\"", "lemma resolvent_upon_correct:\n  assumes \"P1 \\<in> S\"\n  assumes \"P2 \\<in> S\"\n  assumes \"C = resolvent_upon P1 P2 A\"\n  shows \"entails S C\"", "lemma all_resolvents_upon_is_finite:\n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (S \\<union> (all_resolvents_upon S A))\"", "lemma atoms_formula_resolvents:\n  shows \"atoms_formula (all_resolvents_upon S A) \\<subseteq>  atoms_formula S\"", "lemma resolvent_upon_and_partial_saturation :\n  assumes \"redundant P1 S\"\n  assumes \"redundant P2 S\"\n  assumes \"partial_saturation S A (S \\<union> R)\"\n  assumes \"C = resolvent_upon P1 P2 A\"\n  shows \"redundant C (S \\<union> R)\"", "lemma every_clause_is_a_resolvent:\n  assumes \"all_fulfill (in_all_resolvents_upon S A) R\"\n  assumes \"all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\"\n  assumes \"P1 \\<in> S \\<union> R\"\n  shows \"in_all_resolvents_upon S A P1\"", "lemma partial_saturation_is_preserved :\n  assumes \"partial_saturation S E1 S\"\n  assumes \"partial_saturation S E2 (S \\<union> R)\"\n  assumes \"all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\"\n  assumes \"all_fulfill (in_all_resolvents_upon S E2) R\"\n  shows \"partial_saturation (S \\<union> R) E1 (S \\<union> R)\"", "lemma resolvents_do_not_contain_atom :\n  assumes \"\\<not> tautology P1\"\n  assumes \"\\<not> tautology P2\"\n  assumes \"C = resolvent_upon P1 P2 E2\"\n  assumes \"\\<not> subsumes P1 C\"\n  assumes \"\\<not> subsumes P2 C\"\n  shows \"(Neg E2) \\<notin> C \\<and> (Pos E2) \\<notin> C\"", "lemma ensures_partial_saturation :\n  assumes \"partial_saturation S E2 (S \\<union> R)\"\n  assumes \"all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\"\n  assumes \"all_fulfill (in_all_resolvents_upon S E2) R\"\n  assumes \"all_fulfill (\\<lambda>x. (\\<not>redundant x S)) R\"\n  shows \"partial_saturation (S \\<union> R) E2 (S \\<union> R)\"", "lemma resolvents_preserve_equivalence:\n  shows \"equivalent S (S \\<union> (all_resolvents_upon S A))\"", "lemma redundancy_implies_partial_saturation:\n  assumes \"partial_saturation S1 A S1\"\n  assumes \"S2 \\<subseteq> S1\"\n  assumes \"all_fulfill (\\<lambda>x. redundant x S2) S1\"\n  shows \"partial_saturation S2 A S2\"", "theorem incremental_prime_implication_generation:\n  assumes \"atoms_formula S = { X. \\<exists>I::nat. I < N \\<and> X = (A I) }\"\n  assumes \"all_fulfill finite S\"\n  shows \"(prime_implicates S) = (resolvents_sequence A S N)\""], "translations": [["", "lemma partial_evaluation_is_saturated : \n  assumes \"saturated_binary_rule resolvent S\"\n  shows \"saturated_binary_rule ordered_resolvent (partial_evaluation S C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (partial_evaluation S C)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "let ?peval = \"partial_evaluation S C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "assume \"\\<not>saturated_binary_rule ordered_resolvent ?peval\""], ["proof (state)\nthis:\n  \\<not> saturated_binary_rule ordered_resolvent (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> saturated_binary_rule ordered_resolvent (partial_evaluation S C)", "obtain P1 and P2 and R where \"P1 \\<in> ?peval\" and \"P2 \\<in> ?peval\"\n      and \"ordered_resolvent P1 P2 R\"  and \"\\<not>(tautology R)\" \n      and not_subsumed: \"\\<not>(\\<exists>D. ((D \\<in> (partial_evaluation S C)) \\<and> (subsumes D R)))\""], ["proof (prove)\nusing this:\n  \\<not> saturated_binary_rule ordered_resolvent (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 R.\n        \\<lbrakk>P1 \\<in> partial_evaluation S C;\n         P2 \\<in> partial_evaluation S C; ordered_resolvent P1 P2 R;\n         \\<not> tautology R;\n         \\<nexists>D.\n            D \\<in> partial_evaluation S C \\<and> subsumes D R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding saturated_binary_rule_def and redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 Ca.\n             P1 \\<in> partial_evaluation S C \\<and>\n             P2 \\<in> partial_evaluation S C \\<and>\n             ordered_resolvent P1 P2 Ca \\<longrightarrow>\n             tautology Ca \\<or>\n             (\\<exists>D.\n                 D \\<in> partial_evaluation S C \\<and> subsumes D Ca))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 R.\n        \\<lbrakk>P1 \\<in> partial_evaluation S C;\n         P2 \\<in> partial_evaluation S C; ordered_resolvent P1 P2 R;\n         \\<not> tautology R;\n         \\<nexists>D.\n            D \\<in> partial_evaluation S C \\<and> subsumes D R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> partial_evaluation S C\n  P2 \\<in> partial_evaluation S C\n  ordered_resolvent P1 P2 R\n  \\<not> tautology R\n  \\<nexists>D. D \\<in> partial_evaluation S C \\<and> subsumes D R\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> ?peval\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> partial_evaluation S C", "obtain PP1 where \"PP1 \\<in> S\" and \"P1 = PP1 - C\" \n      and i: \"\\<not>(\\<exists>L. (L \\<in> C) \\<and> (complement L) \\<in> PP1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. (\\<And>PP1.\n        \\<lbrakk>PP1 \\<in> S; P1 = PP1 - C;\n         \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  PP1 \\<in> S\n  P1 = PP1 - C\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> ?peval\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> partial_evaluation S C", "obtain PP2 where \"PP2 \\<in> S\" and \"P2 = PP2 - C\" \n      and  ii: \"\\<not>(\\<exists>L. (L \\<in> C) \\<and> (complement L) \\<in> PP2)\""], ["proof (prove)\nusing this:\n  P2 \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. (\\<And>PP2.\n        \\<lbrakk>PP2 \\<in> S; P2 = PP2 - C;\n         \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  PP2 \\<in> S\n  P2 = PP2 - C\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from \\<open>(ordered_resolvent P1 P2 R)\\<close>"], ["proof (chain)\npicking this:\n  ordered_resolvent P1 P2 R", "obtain A where \n      r_def: \"R = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\" and \"(Pos A) \\<in> P1\" and \"(Neg A) \\<in> P2\""], ["proof (prove)\nusing this:\n  ordered_resolvent P1 P2 R\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>R = P1 - {Pos A} \\<union> (P2 - {Neg A}); Pos A \\<in> P1;\n         Neg A \\<in> P2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ordered_resolvent_def strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     R = P1 - {Pos A} \\<union> (P2 - {Neg A}) \\<and>\n     (Pos A \\<in> P1 \\<and>\n      (\\<forall>B.\n          B \\<in> P1 \\<and> Pos A \\<noteq> B \\<longrightarrow>\n          literal_ordering B (Pos A))) \\<and>\n     Neg A \\<in> P2 \\<and>\n     (\\<forall>B.\n         B \\<in> P2 \\<and> Neg A \\<noteq> B \\<longrightarrow>\n         literal_ordering B (Neg A))\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>R = P1 - {Pos A} \\<union> (P2 - {Neg A}); Pos A \\<in> P1;\n         Neg A \\<in> P2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  Pos A \\<in> P1\n  Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "let ?RR = \"(PP1 - { Pos A }) \\<union> (PP2 - { Neg A })\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from \\<open>P1 = PP1 - C\\<close> and \\<open>(Pos A) \\<in> P1\\<close>"], ["proof (chain)\npicking this:\n  P1 = PP1 - C\n  Pos A \\<in> P1", "have \"(Pos A) \\<in> PP1\""], ["proof (prove)\nusing this:\n  P1 = PP1 - C\n  Pos A \\<in> P1\n\ngoal (1 subgoal):\n 1. Pos A \\<in> PP1", "by auto"], ["proof (state)\nthis:\n  Pos A \\<in> PP1\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from \\<open>P2 = PP2 - C\\<close> and \\<open>(Neg A) \\<in> P2\\<close>"], ["proof (chain)\npicking this:\n  P2 = PP2 - C\n  Neg A \\<in> P2", "have \"(Neg A) \\<in> PP2\""], ["proof (prove)\nusing this:\n  P2 = PP2 - C\n  Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. Neg A \\<in> PP2", "by auto"], ["proof (state)\nthis:\n  Neg A \\<in> PP2\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from r_def and \\<open>P1 = PP1 - C\\<close> and \\<open>P2 = PP2 - C\\<close>"], ["proof (chain)\npicking this:\n  R = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  P1 = PP1 - C\n  P2 = PP2 - C", "have \"R =  ?RR - C\""], ["proof (prove)\nusing this:\n  R = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  P1 = PP1 - C\n  P2 = PP2 - C\n\ngoal (1 subgoal):\n 1. R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C", "by auto"], ["proof (state)\nthis:\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "from \\<open>(Pos A) \\<in> PP1\\<close> and \\<open>(Neg A) \\<in> PP2\\<close>"], ["proof (chain)\npicking this:\n  Pos A \\<in> PP1\n  Neg A \\<in> PP2", "have \"resolvent PP1 PP2 ?RR\""], ["proof (prove)\nusing this:\n  Pos A \\<in> PP1\n  Neg A \\<in> PP2\n\ngoal (1 subgoal):\n 1. resolvent PP1 PP2 (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  Pos A \\<in> PP1\n  Neg A \\<in> PP2\n\ngoal (1 subgoal):\n 1. \\<exists>Aa.\n       Pos Aa \\<in> PP1 \\<and>\n       Neg Aa \\<in> PP2 \\<and>\n       PP1 - {Pos A} \\<union> (PP2 - {Neg A}) =\n       PP1 - {Pos Aa} \\<union> (PP2 - {Neg Aa})", "by auto"], ["proof (state)\nthis:\n  resolvent PP1 PP2 (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "with \\<open>PP1 \\<in> S\\<close> and \\<open>PP2 \\<in> S\\<close> and \\<open>saturated_binary_rule resolvent S\\<close>"], ["proof (chain)\npicking this:\n  PP1 \\<in> S\n  PP2 \\<in> S\n  saturated_binary_rule resolvent S\n  resolvent PP1 PP2 (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))", "have \"tautology ?RR \\<or> (\\<exists>D. (D \\<in> S \\<and> (subsumes D ?RR)))\""], ["proof (prove)\nusing this:\n  PP1 \\<in> S\n  PP2 \\<in> S\n  saturated_binary_rule resolvent S\n  resolvent PP1 PP2 (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<or>\n    (\\<exists>D.\n        D \\<in> S \\<and>\n        subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})))", "unfolding saturated_binary_rule_def redundant_def"], ["proof (prove)\nusing this:\n  PP1 \\<in> S\n  PP2 \\<in> S\n  \\<forall>P1 P2 C.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> resolvent P1 P2 C \\<longrightarrow>\n     tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n  resolvent PP1 PP2 (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<or>\n    (\\<exists>D.\n        D \\<in> S \\<and>\n        subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})))", "by auto"], ["proof (state)\nthis:\n  tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<or>\n  (\\<exists>D.\n      D \\<in> S \\<and> subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})))\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule ordered_resolvent\n            (partial_evaluation S C) \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<or>\n  (\\<exists>D.\n      D \\<in> S \\<and> subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})))\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False\n 2. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "assume \"tautology ?RR\""], ["proof (state)\nthis:\n  tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (2 subgoals):\n 1. tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False\n 2. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "with \\<open>R = ?RR - C\\<close> and \\<open>\\<not>tautology R\\<close>"], ["proof (chain)\npicking this:\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C\n  \\<not> tautology R\n  tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))", "obtain X where \"X \\<in> C\" and \"complement X \\<in> PP1 \\<union> PP2\""], ["proof (prove)\nusing this:\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C\n  \\<not> tautology R\n  tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> C; complement X \\<in> PP1 \\<union> PP2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C\n  \\<nexists>A. Pos A \\<in> R \\<and> Neg A \\<in> R\n  \\<exists>Aa.\n     Pos Aa \\<in> PP1 - {Pos A} \\<union> (PP2 - {Neg A}) \\<and>\n     Neg Aa \\<in> PP1 - {Pos A} \\<union> (PP2 - {Neg A})\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> C; complement X \\<in> PP1 \\<union> PP2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X \\<in> C\n  complement X \\<in> PP1 \\<union> PP2\n\ngoal (2 subgoals):\n 1. tautology (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False\n 2. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "from \\<open>X \\<in> C\\<close> and \\<open>complement X \\<in> PP1 \\<union> PP2\\<close> and i and ii"], ["proof (chain)\npicking this:\n  X \\<in> C\n  complement X \\<in> PP1 \\<union> PP2\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2", "show \"False\""], ["proof (prove)\nusing this:\n  X \\<in> C\n  complement X \\<in> PP1 \\<union> PP2\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "assume \"\\<exists>D. ((D \\<in> S) \\<and> (subsumes D ?RR))\""], ["proof (state)\nthis:\n  \\<exists>D.\n     D \\<in> S \\<and> subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>D.\n     D \\<in> S \\<and> subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))", "obtain D where \"D \\<in> S\" and \"subsumes D ?RR\""], ["proof (prove)\nusing this:\n  \\<exists>D.\n     D \\<in> S \\<and> subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S;\n         subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<in> S\n  subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "from \\<open>subsumes D ?RR\\<close> and \\<open>R = ?RR - C\\<close>"], ["proof (chain)\npicking this:\n  subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C", "have \"subsumes (D - C) R\""], ["proof (prove)\nusing this:\n  subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C\n\ngoal (1 subgoal):\n 1. subsumes (D - C) R", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  D \\<subseteq> PP1 - {Pos A} \\<union> (PP2 - {Neg A})\n  R = PP1 - {Pos A} \\<union> (PP2 - {Neg A}) - C\n\ngoal (1 subgoal):\n 1. D - C \\<subseteq> R", "by auto"], ["proof (state)\nthis:\n  subsumes (D - C) R\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "from \\<open>D \\<in> S\\<close> and ii and i and \\<open>(subsumes D ?RR)\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> S\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\n  subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))", "have \"D - C \\<in> ?peval\""], ["proof (prove)\nusing this:\n  D \\<in> S\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\n  subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A}))\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  D \\<in> S\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP2\n  \\<nexists>L. L \\<in> C \\<and> complement L \\<in> PP1\n  D \\<subseteq> PP1 - {Pos A} \\<union> (PP2 - {Neg A})\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C", "by auto"], ["proof (state)\nthis:\n  D - C \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> S \\<and>\n       subsumes D (PP1 - {Pos A} \\<union> (PP2 - {Neg A})) \\<Longrightarrow>\n    False", "with \\<open>subsumes (D - C) R\\<close> and not_subsumed"], ["proof (chain)\npicking this:\n  subsumes (D - C) R\n  \\<nexists>D. D \\<in> partial_evaluation S C \\<and> subsumes D R\n  D - C \\<in> partial_evaluation S C", "show \"False\""], ["proof (prove)\nusing this:\n  subsumes (D - C) R\n  \\<nexists>D. D \\<in> partial_evaluation S C \\<and> subsumes D R\n  D - C \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma evaluation_wrt_implicate_is_unsat : \n  assumes \"entails S C\"\n  assumes \"\\<not>tautology C\"\n  shows \"\\<not>satisfiable (partial_evaluation S C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable (partial_evaluation S C)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "let ?peval = \"partial_evaluation S C\""], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "assume \"satisfiable ?peval\""], ["proof (state)\nthis:\n  satisfiable (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  satisfiable (partial_evaluation S C)", "obtain I where \"validate_formula I ?peval\""], ["proof (prove)\nusing this:\n  satisfiable (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        I \\<Turnstile> partial_evaluation S C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  \\<exists>I. I \\<Turnstile> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        I \\<Turnstile> partial_evaluation S C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "let ?J = \"(I - { X. (Pos X) \\<in> C }) \\<union> { Y. (Neg Y) \\<in> C }\""], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "have \"\\<not>validate_clause ?J C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n           C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n    C \\<Longrightarrow>\n    False", "assume \"validate_clause ?J C\""], ["proof (state)\nthis:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n    C \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C", "obtain L where \"L \\<in> C\" and \"validate_literal ?J L\""], ["proof (prove)\nusing this:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> C;\n         (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n         L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n    C \\<Longrightarrow>\n    False", "obtain X where \"L = (Pos X) \\<or> L = (Neg X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        L = Pos X \\<or> L = Neg X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        L = Pos X \\<or> L = Neg X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos X \\<or> L = Neg X\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n    C \\<Longrightarrow>\n    False", "from \\<open>L = (Pos X) \\<or> L = (Neg X)\\<close> and \\<open>L \\<in> C\\<close> and \\<open>\\<not>tautology C\\<close> and \\<open>validate_literal ?J L\\<close>"], ["proof (chain)\npicking this:\n  L = Pos X \\<or> L = Neg X\n  L \\<in> C\n  \\<not> tautology C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L", "show \"False\""], ["proof (prove)\nusing this:\n  L = Pos X \\<or> L = Neg X\n  L \\<in> C\n  \\<not> tautology C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. False", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  L = Pos X \\<or> L = Neg X\n  L \\<in> C\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "have \"validate_formula ?J S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "assume \"\\<not> (validate_formula ?J S)\""], ["proof (state)\nthis:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S", "obtain D where \"D \\<in> S\" and \"\\<not>(validate_clause ?J D)\""], ["proof (prove)\nusing this:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S;\n         \\<not> (I - {X. Pos X \\<in> C} \\<union>\n                 {Y. Neg Y \\<in> C}) \\<Turnstile>\n                D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<in> S\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> D\n\ngoal (1 subgoal):\n 1. \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "from \\<open>D \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> S", "have \"D-C \\<in> ?peval \\<or>  (\\<exists>L. (L \\<in> C) \\<and> (complement L) \\<in> D)\""], ["proof (prove)\nusing this:\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<or>\n    (\\<exists>L. L \\<in> C \\<and> complement L \\<in> D)", "by auto"], ["proof (state)\nthis:\n  D - C \\<in> partial_evaluation S C \\<or>\n  (\\<exists>L. L \\<in> C \\<and> complement L \\<in> D)\n\ngoal (1 subgoal):\n 1. \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n           S \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  D - C \\<in> partial_evaluation S C \\<or>\n  (\\<exists>L. L \\<in> C \\<and> complement L \\<in> D)\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False\n 2. \\<exists>L. L \\<in> C \\<and> complement L \\<in> D \\<Longrightarrow>\n    False", "assume \"\\<exists>L. (L \\<in> C) \\<and> (complement L) \\<in> D\""], ["proof (state)\nthis:\n  \\<exists>L. L \\<in> C \\<and> complement L \\<in> D\n\ngoal (2 subgoals):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False\n 2. \\<exists>L. L \\<in> C \\<and> complement L \\<in> D \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>L. L \\<in> C \\<and> complement L \\<in> D", "obtain L where \"L \\<in> C\" and \"complement L \\<in> D\""], ["proof (prove)\nusing this:\n  \\<exists>L. L \\<in> C \\<and> complement L \\<in> D\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> C; complement L \\<in> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> C\n  complement L \\<in> D\n\ngoal (2 subgoals):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False\n 2. \\<exists>L. L \\<in> C \\<and> complement L \\<in> D \\<Longrightarrow>\n    False", "obtain X where \"L = (Pos X) \\<or> L = (Neg X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        L = Pos X \\<or> L = Neg X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        L = Pos X \\<or> L = Neg X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos X \\<or> L = Neg X\n\ngoal (2 subgoals):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False\n 2. \\<exists>L. L \\<in> C \\<and> complement L \\<in> D \\<Longrightarrow>\n    False", "from this  and \\<open>L \\<in> C\\<close> and \\<open>\\<not>(tautology C)\\<close>"], ["proof (chain)\npicking this:\n  L = Pos X \\<or> L = Neg X\n  L \\<in> C\n  \\<not> tautology C", "have \"validate_literal ?J (complement L)\""], ["proof (prove)\nusing this:\n  L = Pos X \\<or> L = Neg X\n  L \\<in> C\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n    complement L", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  L = Pos X \\<or> L = Neg X\n  L \\<in> C\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n    complement L", "by auto"], ["proof (state)\nthis:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n  complement L\n\ngoal (2 subgoals):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False\n 2. \\<exists>L. L \\<in> C \\<and> complement L \\<in> D \\<Longrightarrow>\n    False", "from \\<open>(validate_literal ?J (complement L))\\<close> and \\<open>(complement L) \\<in> D\\<close> \n          and \\<open>\\<not>(validate_clause ?J D)\\<close>"], ["proof (chain)\npicking this:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n  complement L\n  complement L \\<in> D\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> D", "show \"False\""], ["proof (prove)\nusing this:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile>\n  complement L\n  complement L \\<in> D\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> D\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "assume \"D-C \\<in> ?peval\""], ["proof (state)\nthis:\n  D - C \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "from \\<open>D-C \\<in> ?peval\\<close> and \\<open>(validate_formula I ?peval)\\<close>"], ["proof (chain)\npicking this:\n  D - C \\<in> partial_evaluation S C\n  I \\<Turnstile> partial_evaluation S C", "have \"validate_clause I (D-C)\""], ["proof (prove)\nusing this:\n  D - C \\<in> partial_evaluation S C\n  I \\<Turnstile> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> (D - C)", "using validate_formula.simps"], ["proof (prove)\nusing this:\n  D - C \\<in> partial_evaluation S C\n  I \\<Turnstile> partial_evaluation S C\n  ?I \\<Turnstile> ?S =\n  (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?I \\<Turnstile> C)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> (D - C)", "by blast"], ["proof (state)\nthis:\n  I \\<Turnstile> (D - C)\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  I \\<Turnstile> (D - C)", "obtain L where \"L \\<in> D\" and \"L \\<notin> C\" and \"validate_literal I L\""], ["proof (prove)\nusing this:\n  I \\<Turnstile> (D - C)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> D; L \\<notin> C; I \\<Turnstile> L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> D\n  L \\<notin> C\n  I \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "obtain X where \"L = (Pos X) \\<or> L = (Neg X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        L = Pos X \\<or> L = Neg X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Literal.exhaust [of L]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. L = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. L = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        L = Pos X \\<or> L = Neg X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L = Pos X \\<or> L = Neg X\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "from \\<open>L = (Pos X) \\<or> L = (Neg X)\\<close> and \\<open>validate_literal I L\\<close> and \\<open>L \\<notin> C\\<close>"], ["proof (chain)\npicking this:\n  L = Pos X \\<or> L = Neg X\n  I \\<Turnstile> L\n  L \\<notin> C", "have \"validate_literal ?J L\""], ["proof (prove)\nusing this:\n  L = Pos X \\<or> L = Neg X\n  I \\<Turnstile> L\n  L \\<notin> C\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  L = Pos X \\<or> L = Neg X\n  I \\<Turnstile> L\n  L \\<notin> C\n\ngoal (1 subgoal):\n 1. (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L", "by auto"], ["proof (state)\nthis:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L\n\ngoal (1 subgoal):\n 1. D - C \\<in> partial_evaluation S C \\<Longrightarrow> False", "from \\<open>validate_literal ?J L\\<close> and \\<open>L \\<in> D\\<close> and \\<open>\\<not>(validate_clause ?J D)\\<close>"], ["proof (chain)\npicking this:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L\n  L \\<in> D\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> D", "show \"False\""], ["proof (prove)\nusing this:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> L\n  L \\<in> D\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> D\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. satisfiable (partial_evaluation S C) \\<Longrightarrow> False", "from \\<open>\\<not>validate_clause ?J C\\<close> and \\<open>validate_formula ?J S\\<close> and \\<open>entails S C\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S\n  entails S C", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S\n  entails S C\n\ngoal (1 subgoal):\n 1. False", "unfolding entails_def"], ["proof (prove)\nusing this:\n  \\<not> (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> C\n  (I - {X. Pos X \\<in> C} \\<union> {Y. Neg Y \\<in> C}) \\<Turnstile> S\n  \\<forall>I. I \\<Turnstile> S \\<longrightarrow> I \\<Turnstile> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma entailment_and_implicates:\n  assumes \"entails_formula S1 S2\"\n  shows \"implicates S2 \\<subseteq> implicates S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implicates S2 \\<subseteq> implicates S1", "using assms entailed_formula_entails_implicates implicates_def"], ["proof (prove)\nusing this:\n  entails_formula S1 S2\n  \\<lbrakk>entails_formula ?S1.0 ?S2.0; entails ?S2.0 ?C\\<rbrakk>\n  \\<Longrightarrow> entails ?S1.0 ?C\n  implicates ?S = {C. entails ?S C}\n\ngoal (1 subgoal):\n 1. implicates S2 \\<subseteq> implicates S1", "by auto"], ["", "lemma equivalence_and_implicates:\n  assumes \"equivalent S1 S2\"\n  shows \"implicates S1 = implicates S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implicates S1 = implicates S2", "using assms entailment_and_implicates equivalent_def"], ["proof (prove)\nusing this:\n  equivalent S1 S2\n  entails_formula ?S1.0 ?S2.0 \\<Longrightarrow>\n  implicates ?S2.0 \\<subseteq> implicates ?S1.0\n  equivalent ?S1.0 ?S2.0 =\n  (entails_formula ?S1.0 ?S2.0 \\<and> entails_formula ?S2.0 ?S1.0)\n\ngoal (1 subgoal):\n 1. implicates S1 = implicates S2", "by blast"], ["", "lemma equivalence_and_prime_implicates:\n  assumes \"equivalent S1 S2\"\n  shows \"prime_implicates S1 = prime_implicates S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_implicates S1 = prime_implicates S2", "using assms equivalence_and_implicates prime_implicates_def"], ["proof (prove)\nusing this:\n  equivalent S1 S2\n  equivalent ?S1.0 ?S2.0 \\<Longrightarrow>\n  implicates ?S1.0 = implicates ?S2.0\n  prime_implicates ?S = simplify (implicates ?S)\n\ngoal (1 subgoal):\n 1. prime_implicates S1 = prime_implicates S2", "by auto"], ["", "lemma unrestricted_resolution_is_deductive_complete : \n  assumes \"saturated_binary_rule resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"C \\<in> implicates S\"\n  shows \"redundant C S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C S", "proof ((cases \"tautology C\"),(simp add: redundant_def))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C S", "assume \"\\<not> tautology C\""], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C S", "have \"\\<exists>D. (D \\<in> S) \\<and> (subsumes D C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "let ?peval = \"partial_evaluation S C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "from \\<open>saturated_binary_rule resolvent S\\<close>"], ["proof (chain)\npicking this:\n  saturated_binary_rule resolvent S", "have \"saturated_binary_rule ordered_resolvent ?peval\""], ["proof (prove)\nusing this:\n  saturated_binary_rule resolvent S\n\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (partial_evaluation S C)", "using partial_evaluation_is_saturated"], ["proof (prove)\nusing this:\n  saturated_binary_rule resolvent S\n  saturated_binary_rule resolvent ?S \\<Longrightarrow>\n  saturated_binary_rule ordered_resolvent (partial_evaluation ?S ?C)\n\ngoal (1 subgoal):\n 1. saturated_binary_rule ordered_resolvent (partial_evaluation S C)", "by auto"], ["proof (state)\nthis:\n  saturated_binary_rule ordered_resolvent (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "from \\<open>C \\<in> implicates S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> implicates S", "have \"entails S C\""], ["proof (prove)\nusing this:\n  C \\<in> implicates S\n\ngoal (1 subgoal):\n 1. entails S C", "unfolding implicates_def"], ["proof (prove)\nusing this:\n  C \\<in> Collect (entails S)\n\ngoal (1 subgoal):\n 1. entails S C", "by auto"], ["proof (state)\nthis:\n  entails S C\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "from \\<open>entails S C\\<close> and \\<open>\\<not>tautology C\\<close>"], ["proof (chain)\npicking this:\n  entails S C\n  \\<not> tautology C", "have \"\\<not>satisfiable ?peval\""], ["proof (prove)\nusing this:\n  entails S C\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (partial_evaluation S C)", "using evaluation_wrt_implicate_is_unsat"], ["proof (prove)\nusing this:\n  entails S C\n  \\<not> tautology C\n  \\<lbrakk>entails ?S ?C; \\<not> tautology ?C\\<rbrakk>\n  \\<Longrightarrow> \\<not> satisfiable (partial_evaluation ?S ?C)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable (partial_evaluation S C)", "by auto"], ["proof (state)\nthis:\n  \\<not> satisfiable (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "from \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S", "have \"all_fulfill finite ?peval\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (partial_evaluation S C)", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. \\<forall>Ca. Ca \\<in> partial_evaluation S C \\<longrightarrow> finite Ca", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "from \\<open>\\<not>satisfiable ?peval\\<close> and \\<open>saturated_binary_rule ordered_resolvent ?peval\\<close> \n      and \\<open>all_fulfill finite ?peval\\<close>"], ["proof (chain)\npicking this:\n  \\<not> satisfiable (partial_evaluation S C)\n  saturated_binary_rule ordered_resolvent (partial_evaluation S C)\n  all_fulfill finite (partial_evaluation S C)", "have \"{} \\<in> ?peval\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable (partial_evaluation S C)\n  saturated_binary_rule ordered_resolvent (partial_evaluation S C)\n  all_fulfill finite (partial_evaluation S C)\n\ngoal (1 subgoal):\n 1. {} \\<in> partial_evaluation S C", "using Complete_def ordered_resolution_is_complete"], ["proof (prove)\nusing this:\n  \\<not> satisfiable (partial_evaluation S C)\n  saturated_binary_rule ordered_resolvent (partial_evaluation S C)\n  all_fulfill finite (partial_evaluation S C)\n  Complete ?Rule =\n  (\\<forall>S.\n      saturated_binary_rule ?Rule S \\<longrightarrow>\n      all_fulfill finite S \\<longrightarrow>\n      {} \\<notin> S \\<longrightarrow> satisfiable S)\n  Complete ordered_resolvent\n\ngoal (1 subgoal):\n 1. {} \\<in> partial_evaluation S C", "by blast"], ["proof (state)\nthis:\n  {} \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "then"], ["proof (chain)\npicking this:\n  {} \\<in> partial_evaluation S C", "show ?thesis"], ["proof (prove)\nusing this:\n  {} \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> subsumes D C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  {} \\<in> partial_evaluation S C\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> S \\<and> D \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  \\<exists>D. D \\<in> S \\<and> subsumes D C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>D. D \\<in> S \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. \\<not> tautology C \\<Longrightarrow> redundant C S", "then"], ["proof (chain)\npicking this:\n  \\<exists>D. D \\<in> S \\<and> subsumes D C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>D. D \\<in> S \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. redundant C S", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<exists>D. D \\<in> S \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)", "by auto"], ["proof (state)\nthis:\n  redundant C S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_implicates_generation_correct :\n  assumes \"saturated_binary_rule resolvent S\"\n  assumes \"non_redundant S\"\n  assumes \"all_fulfill finite S\"\n  shows \"S \\<subseteq> prime_implicates S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> prime_implicates S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> prime_implicates S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> prime_implicates S", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> prime_implicates S", "show \"x \\<in> prime_implicates S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> prime_implicates S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "assume \"\\<not> x \\<in> prime_implicates S\""], ["proof (state)\nthis:\n  x \\<notin> prime_implicates S\n\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "from \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S", "have \"entails S x\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. entails S x", "unfolding entails_def implicates_def"], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>I. I \\<Turnstile> S \\<longrightarrow> I \\<Turnstile> x", "by auto"], ["proof (state)\nthis:\n  entails S x\n\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  entails S x", "have \"x \\<in> implicates S\""], ["proof (prove)\nusing this:\n  entails S x\n\ngoal (1 subgoal):\n 1. x \\<in> implicates S", "unfolding implicates_def"], ["proof (prove)\nusing this:\n  entails S x\n\ngoal (1 subgoal):\n 1. x \\<in> Collect (entails S)", "by auto"], ["proof (state)\nthis:\n  x \\<in> implicates S\n\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "with \\<open>\\<not> x \\<in> (prime_implicates S)\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> prime_implicates S\n  x \\<in> implicates S", "have \"strictly_redundant x (implicates S)\""], ["proof (prove)\nusing this:\n  x \\<notin> prime_implicates S\n  x \\<in> implicates S\n\ngoal (1 subgoal):\n 1. strictly_redundant x (implicates S)", "unfolding prime_implicates_def simplify_def"], ["proof (prove)\nusing this:\n  x \\<notin> {C \\<in> implicates S.\n              \\<not> strictly_redundant C (implicates S)}\n  x \\<in> implicates S\n\ngoal (1 subgoal):\n 1. strictly_redundant x (implicates S)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant x (implicates S)\n\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  strictly_redundant x (implicates S)", "have \"tautology x \\<or> (\\<exists>y. (y \\<in> (implicates S)) \\<and> (y \\<subset> x))\""], ["proof (prove)\nusing this:\n  strictly_redundant x (implicates S)\n\ngoal (1 subgoal):\n 1. tautology x \\<or>\n    (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  tautology x \\<or> (\\<exists>D. D \\<in> implicates S \\<and> D \\<subset> x)\n\ngoal (1 subgoal):\n 1. tautology x \\<or>\n    (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)", "by auto"], ["proof (state)\nthis:\n  tautology x \\<or> (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)\n\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tautology x \\<or> (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)", "have \"strictly_redundant x S\""], ["proof (prove)\nusing this:\n  tautology x \\<or> (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)\n\ngoal (1 subgoal):\n 1. strictly_redundant x S", "proof ((cases \"tautology x\"),(simp add: strictly_redundant_def))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "assume \"\\<not>tautology x\""], ["proof (state)\nthis:\n  \\<not> tautology x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "with \\<open>tautology x \\<or> (\\<exists>y. (y \\<in> (implicates S)) \\<and> (y \\<subset> x))\\<close>"], ["proof (chain)\npicking this:\n  tautology x \\<or> (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)\n  \\<not> tautology x", "obtain y where \"y \\<in> implicates S\" and \"y \\<subset> x\""], ["proof (prove)\nusing this:\n  tautology x \\<or> (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x)\n  \\<not> tautology x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> implicates S; y \\<subset> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> implicates S\n  y \\<subset> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "from \\<open>y \\<in> implicates S\\<close> and \\<open>saturated_binary_rule resolvent S\\<close> and \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> implicates S\n  saturated_binary_rule resolvent S\n  all_fulfill finite S", "have \"redundant y S\""], ["proof (prove)\nusing this:\n  y \\<in> implicates S\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. redundant y S", "using unrestricted_resolution_is_deductive_complete"], ["proof (prove)\nusing this:\n  y \\<in> implicates S\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  \\<lbrakk>saturated_binary_rule resolvent ?S; all_fulfill finite ?S;\n   ?C \\<in> implicates ?S\\<rbrakk>\n  \\<Longrightarrow> redundant ?C ?S\n\ngoal (1 subgoal):\n 1. redundant y S", "by auto"], ["proof (state)\nthis:\n  redundant y S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "from \\<open>y \\<subset> x\\<close> and \\<open>\\<not>tautology x\\<close>"], ["proof (chain)\npicking this:\n  y \\<subset> x\n  \\<not> tautology x", "have \"\\<not>tautology y\""], ["proof (prove)\nusing this:\n  y \\<subset> x\n  \\<not> tautology x\n\ngoal (1 subgoal):\n 1. \\<not> tautology y", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  y \\<subset> x\n  \\<nexists>A. Pos A \\<in> x \\<and> Neg A \\<in> x\n\ngoal (1 subgoal):\n 1. \\<nexists>A. Pos A \\<in> y \\<and> Neg A \\<in> y", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "with \\<open>redundant y S\\<close>"], ["proof (chain)\npicking this:\n  redundant y S\n  \\<not> tautology y", "obtain z where \"z \\<in> S\" and \"z \\<subseteq> y\""], ["proof (prove)\nusing this:\n  redundant y S\n  \\<not> tautology y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> S; z \\<subseteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  tautology y \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subseteq> y)\n  \\<not> tautology y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> S; z \\<subseteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> S\n  z \\<subseteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "with \\<open>y \\<subset> x\\<close>"], ["proof (chain)\npicking this:\n  y \\<subset> x\n  z \\<in> S\n  z \\<subseteq> y", "have \"z \\<subset> x\""], ["proof (prove)\nusing this:\n  y \\<subset> x\n  z \\<in> S\n  z \\<subseteq> y\n\ngoal (1 subgoal):\n 1. z \\<subset> x", "by auto"], ["proof (state)\nthis:\n  z \\<subset> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tautology x \\<or>\n             (\\<exists>y. y \\<in> implicates S \\<and> y \\<subset> x);\n     \\<not> tautology x\\<rbrakk>\n    \\<Longrightarrow> strictly_redundant x S", "with \\<open>z \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> S\n  z \\<subset> x", "show \"strictly_redundant x S\""], ["proof (prove)\nusing this:\n  z \\<in> S\n  z \\<subset> x\n\ngoal (1 subgoal):\n 1. strictly_redundant x S", "using strictly_redundant_def"], ["proof (prove)\nusing this:\n  z \\<in> S\n  z \\<subset> x\n  strictly_redundant ?C ?S =\n  (tautology ?C \\<or> (\\<exists>D. D \\<in> ?S \\<and> D \\<subset> ?C))\n\ngoal (1 subgoal):\n 1. strictly_redundant x S", "by auto"], ["proof (state)\nthis:\n  strictly_redundant x S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strictly_redundant x S\n\ngoal (1 subgoal):\n 1. x \\<notin> prime_implicates S \\<Longrightarrow> False", "with \\<open>non_redundant S\\<close> and \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  non_redundant S\n  x \\<in> S\n  strictly_redundant x S", "show \"False\""], ["proof (prove)\nusing this:\n  non_redundant S\n  x \\<in> S\n  strictly_redundant x S\n\ngoal (1 subgoal):\n 1. False", "unfolding non_redundant_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> \\<not> strictly_redundant C S\n  x \\<in> S\n  strictly_redundant x S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> prime_implicates S\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem prime_implicates_of_saturated_sets: \n  assumes \"saturated_binary_rule resolvent S\"\n  assumes \"all_fulfill finite S\"\n  assumes \"non_redundant S\"\n  shows \"S = prime_implicates S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = prime_implicates S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<subseteq> prime_implicates S\n 2. prime_implicates S \\<subseteq> S", "from assms"], ["proof (chain)\npicking this:\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  non_redundant S", "show \"S \\<subseteq> prime_implicates S\""], ["proof (prove)\nusing this:\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  non_redundant S\n\ngoal (1 subgoal):\n 1. S \\<subseteq> prime_implicates S", "using prime_implicates_generation_correct"], ["proof (prove)\nusing this:\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  non_redundant S\n  \\<lbrakk>saturated_binary_rule resolvent ?S; non_redundant ?S;\n   all_fulfill finite ?S\\<rbrakk>\n  \\<Longrightarrow> ?S \\<subseteq> prime_implicates ?S\n\ngoal (1 subgoal):\n 1. S \\<subseteq> prime_implicates S", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> prime_implicates S\n\ngoal (1 subgoal):\n 1. prime_implicates S \\<subseteq> S", "show \"prime_implicates S \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_implicates S \\<subseteq> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prime_implicates S \\<Longrightarrow> x \\<in> S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prime_implicates S \\<Longrightarrow> x \\<in> S", "assume \"x \\<in> prime_implicates S\""], ["proof (state)\nthis:\n  x \\<in> prime_implicates S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prime_implicates S \\<Longrightarrow> x \\<in> S", "from this"], ["proof (chain)\npicking this:\n  x \\<in> prime_implicates S", "have \"x \\<in> implicates S\""], ["proof (prove)\nusing this:\n  x \\<in> prime_implicates S\n\ngoal (1 subgoal):\n 1. x \\<in> implicates S", "unfolding prime_implicates_def simplify_def"], ["proof (prove)\nusing this:\n  x \\<in> {C \\<in> implicates S. \\<not> strictly_redundant C (implicates S)}\n\ngoal (1 subgoal):\n 1. x \\<in> implicates S", "by auto"], ["proof (state)\nthis:\n  x \\<in> implicates S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prime_implicates S \\<Longrightarrow> x \\<in> S", "with assms"], ["proof (chain)\npicking this:\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  non_redundant S\n  x \\<in> implicates S", "have \"redundant x S\""], ["proof (prove)\nusing this:\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  non_redundant S\n  x \\<in> implicates S\n\ngoal (1 subgoal):\n 1. redundant x S", "using unrestricted_resolution_is_deductive_complete"], ["proof (prove)\nusing this:\n  saturated_binary_rule resolvent S\n  all_fulfill finite S\n  non_redundant S\n  x \\<in> implicates S\n  \\<lbrakk>saturated_binary_rule resolvent ?S; all_fulfill finite ?S;\n   ?C \\<in> implicates ?S\\<rbrakk>\n  \\<Longrightarrow> redundant ?C ?S\n\ngoal (1 subgoal):\n 1. redundant x S", "by auto"], ["proof (state)\nthis:\n  redundant x S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prime_implicates S \\<Longrightarrow> x \\<in> S", "show \"x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "assume \"x \\<notin> S\""], ["proof (state)\nthis:\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "with \\<open>redundant x S\\<close>"], ["proof (chain)\npicking this:\n  redundant x S\n  x \\<notin> S", "have \"strictly_redundant x S\""], ["proof (prove)\nusing this:\n  redundant x S\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. strictly_redundant x S", "unfolding redundant_def strictly_redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  tautology x \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subseteq> x)\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. tautology x \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> x)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant x S\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "with \\<open>S \\<subseteq> prime_implicates S\\<close>"], ["proof (chain)\npicking this:\n  S \\<subseteq> prime_implicates S\n  strictly_redundant x S", "have \"strictly_redundant x (prime_implicates S)\""], ["proof (prove)\nusing this:\n  S \\<subseteq> prime_implicates S\n  strictly_redundant x S\n\ngoal (1 subgoal):\n 1. strictly_redundant x (prime_implicates S)", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  S \\<subseteq> prime_implicates S\n  tautology x \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subset> x)\n\ngoal (1 subgoal):\n 1. tautology x \\<or>\n    (\\<exists>D. D \\<in> prime_implicates S \\<and> D \\<subset> x)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant x (prime_implicates S)\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  strictly_redundant x (prime_implicates S)", "have \"strictly_redundant x (implicates S)\""], ["proof (prove)\nusing this:\n  strictly_redundant x (prime_implicates S)\n\ngoal (1 subgoal):\n 1. strictly_redundant x (implicates S)", "unfolding strictly_redundant_def prime_implicates_def simplify_def"], ["proof (prove)\nusing this:\n  tautology x \\<or>\n  (\\<exists>D.\n      D \\<in> {C \\<in> implicates S.\n               \\<not> (tautology C \\<or>\n                       (\\<exists>D.\n                           D \\<in> implicates S \\<and>\n                           D \\<subset> C))} \\<and>\n      D \\<subset> x)\n\ngoal (1 subgoal):\n 1. tautology x \\<or>\n    (\\<exists>D. D \\<in> implicates S \\<and> D \\<subset> x)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant x (implicates S)\n\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> False", "with \\<open>x \\<in> prime_implicates S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> prime_implicates S\n  strictly_redundant x (implicates S)", "show \"False\""], ["proof (prove)\nusing this:\n  x \\<in> prime_implicates S\n  strictly_redundant x (implicates S)\n\ngoal (1 subgoal):\n 1. False", "unfolding prime_implicates_def simplify_def"], ["proof (prove)\nusing this:\n  x \\<in> {C \\<in> implicates S. \\<not> strictly_redundant C (implicates S)}\n  strictly_redundant x (implicates S)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_implicates S \\<subseteq> S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Incremental Prime Implicates Computation\\<close>"], ["", "text \\<open>We show that it is possible to compute the set of prime implicates incrementally\ni.e., to fix an ordering among atoms, and to compute the set of resolvents upon each atom\none by one, without backtracking (in the sense that if the resolvents upon a given atom are \ngenerated at some step @{ term i } then no resolvents upon the same atom are generated at \nstep @{ term \"j>i\" }. \nThis feature is critical in practice for the efficiency of prime implicates \ngeneration algorithms.\\<close>"], ["", "text \\<open>We first introduce a function computing all resolvents upon a given atom.\\<close>"], ["", "definition all_resolvents_upon :: \"'at Formula \\<Rightarrow> 'at \\<Rightarrow> 'at Formula\"\n where  \"(all_resolvents_upon S A) = { C. \\<exists>P1 P2. P1 \\<in> S \\<and> P2 \\<in> S \\<and> C = (resolvent_upon P1 P2 A) }\""], ["", "lemma resolvent_upon_correct:\n  assumes \"P1 \\<in> S\"\n  assumes \"P2 \\<in> S\"\n  assumes \"C = resolvent_upon P1 P2 A\"\n  shows \"entails S C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails S C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> entails S C\n 2. \\<not> ?P \\<Longrightarrow> entails S C", "assume \"Pos A \\<in> P1 \\<and> Neg A \\<in> P2\""], ["proof (state)\nthis:\n  Pos A \\<in> P1 \\<and> Neg A \\<in> P2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> entails S C\n 2. \\<not> ?P \\<Longrightarrow> entails S C", "with \\<open>C = resolvent_upon P1 P2 A\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 A\n  Pos A \\<in> P1 \\<and> Neg A \\<in> P2", "have \"resolvent P1 P2 C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 A\n  Pos A \\<in> P1 \\<and> Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. resolvent P1 P2 C", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 A\n  Pos A \\<in> P1 \\<and> Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       Pos A \\<in> P1 \\<and>\n       Neg A \\<in> P2 \\<and> C = P1 - {Pos A} \\<union> (P2 - {Neg A})", "by auto"], ["proof (state)\nthis:\n  resolvent P1 P2 C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> entails S C\n 2. \\<not> ?P \\<Longrightarrow> entails S C", "with \\<open>P1 \\<in> S\\<close> and \\<open>P2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S\n  P2 \\<in> S\n  resolvent P1 P2 C", "show ?thesis"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P2 \\<in> S\n  resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. entails S C", "using soundness_and_entailment resolution_is_correct"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P2 \\<in> S\n  resolvent P1 P2 C\n  \\<lbrakk>Sound ?Rule; ?Rule ?P1.0 ?P2.0 ?C; ?P1.0 \\<in> ?S;\n   ?P2.0 \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> entails ?S ?C\n  Sound resolvent\n\ngoal (1 subgoal):\n 1. entails S C", "by auto"], ["proof (state)\nthis:\n  entails S C\n\ngoal (1 subgoal):\n 1. \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2) \\<Longrightarrow>\n    entails S C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2) \\<Longrightarrow>\n    entails S C", "assume \"\\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2)\""], ["proof (state)\nthis:\n  \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2)\n\ngoal (1 subgoal):\n 1. \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2) \\<Longrightarrow>\n    entails S C", "with \\<open>C = resolvent_upon P1 P2 A\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 A\n  \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2)", "have \"P1 \\<subseteq> C \\<or> P2 \\<subseteq> C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 A\n  \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2)\n\ngoal (1 subgoal):\n 1. P1 \\<subseteq> C \\<or> P2 \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  P1 \\<subseteq> C \\<or> P2 \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2) \\<Longrightarrow>\n    entails S C", "with \\<open>P1 \\<in> S\\<close> and \\<open>P2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S\n  P2 \\<in> S\n  P1 \\<subseteq> C \\<or> P2 \\<subseteq> C", "have \"redundant C S\""], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P2 \\<in> S\n  P1 \\<subseteq> C \\<or> P2 \\<subseteq> C\n\ngoal (1 subgoal):\n 1. redundant C S", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P2 \\<in> S\n  P1 \\<subseteq> C \\<or> P2 \\<subseteq> C\n\ngoal (1 subgoal):\n 1. tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> D \\<subseteq> C)", "by auto"], ["proof (state)\nthis:\n  redundant C S\n\ngoal (1 subgoal):\n 1. \\<not> (Pos A \\<in> P1 \\<and> Neg A \\<in> P2) \\<Longrightarrow>\n    entails S C", "then"], ["proof (chain)\npicking this:\n  redundant C S", "show ?thesis"], ["proof (prove)\nusing this:\n  redundant C S\n\ngoal (1 subgoal):\n 1. entails S C", "using redundancy_implies_entailment"], ["proof (prove)\nusing this:\n  redundant C S\n  redundant ?C ?S \\<Longrightarrow> entails ?S ?C\n\ngoal (1 subgoal):\n 1. entails S C", "by auto"], ["proof (state)\nthis:\n  entails S C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_resolvents_upon_is_finite:\n  assumes \"all_fulfill finite S\"\n  shows \"all_fulfill finite (S \\<union> (all_resolvents_upon S A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill finite (S \\<union> all_resolvents_upon S A)", "using assms"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (S \\<union> all_resolvents_upon S A)", "unfolding all_fulfill_def all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> finite C\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       C \\<in> S \\<union>\n               {C. \\<exists>P1 P2.\n                      P1 \\<in> S \\<and>\n                      P2 \\<in> S \\<and>\n                      C = resolvent_upon P1 P2 A} \\<longrightarrow>\n       finite C", "by auto"], ["", "lemma atoms_formula_resolvents:\n  shows \"atoms_formula (all_resolvents_upon S A) \\<subseteq>  atoms_formula S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_formula (all_resolvents_upon S A) \\<subseteq> atoms_formula S", "unfolding all_resolvents_upon_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_formula\n     {C. \\<exists>P1 P2.\n            P1 \\<in> S \\<and> P2 \\<in> S \\<and> C = resolvent_upon P1 P2 A}\n    \\<subseteq> atoms_formula S", "by auto"], ["", "text \\<open>We define a partial saturation predicate that is restricted to a specific atom.\\<close>"], ["", "definition partial_saturation :: \"'at Formula \\<Rightarrow> 'at \\<Rightarrow> 'at Formula \\<Rightarrow> bool\"\nwhere\n  \"(partial_saturation S A R) = (\\<forall>P1 P2. (P1 \\<in> S \\<longrightarrow> P2 \\<in> S  \n    \\<longrightarrow>(redundant (resolvent_upon P1 P2 A) R)))\""], ["", "text \\<open>We show that the resolvent of two redundant clauses in a partially saturated set \nis itself redundant.\\<close>"], ["", "lemma resolvent_upon_and_partial_saturation :\n  assumes \"redundant P1 S\"\n  assumes \"redundant P2 S\"\n  assumes \"partial_saturation S A (S \\<union> R)\"\n  assumes \"C = resolvent_upon P1 P2 A\"\n  shows \"redundant C (S \\<union> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant C (S \\<union> R)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "assume \"\\<not>redundant C  (S \\<union> R)\""], ["proof (state)\nthis:\n  \\<not> redundant C (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "from \\<open>C = resolvent_upon P1 P2 A\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 A", "have \"C = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 A\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos A} \\<union> (P2 - {Neg A})", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "from \\<open>\\<not>redundant C  (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)", "have \"\\<not>tautology C\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> tautology C", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n\ngoal (1 subgoal):\n 1. \\<not> tautology C", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "have \"\\<not> (tautology P1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tautology P1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. tautology P1 \\<Longrightarrow> False", "assume \"tautology P1\""], ["proof (state)\nthis:\n  tautology P1\n\ngoal (1 subgoal):\n 1. tautology P1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tautology P1", "obtain B where \"Pos B \\<in> P1\" and \"Neg B \\<in> P1\""], ["proof (prove)\nusing this:\n  tautology P1\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>Pos B \\<in> P1; Neg B \\<in> P1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<exists>A. Pos A \\<in> P1 \\<and> Neg A \\<in> P1\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>Pos B \\<in> P1; Neg B \\<in> P1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Pos B \\<in> P1\n  Neg B \\<in> P1\n\ngoal (1 subgoal):\n 1. tautology P1 \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"A = B\""], ["proof (state)\nthis:\n  A = B\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>Neg B \\<in> P1\\<close> and \\<open>C = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\\<close>"], ["proof (chain)\npicking this:\n  Neg B \\<in> P1\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B", "have \"subsumes P2 C\""], ["proof (prove)\nusing this:\n  Neg B \\<in> P1\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B\n\ngoal (1 subgoal):\n 1. subsumes P2 C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  Neg B \\<in> P1\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B\n\ngoal (1 subgoal):\n 1. P2 \\<subseteq> C", "using Literal.distinct"], ["proof (prove)\nusing this:\n  Neg B \\<in> P1\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B\n  Pos ?x1.0 \\<noteq> Neg ?x2.0\n  Neg ?x2.0 \\<noteq> Pos ?x1.0\n\ngoal (1 subgoal):\n 1. P2 \\<subseteq> C", "by blast"], ["proof (state)\nthis:\n  subsumes P2 C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>redundant P2 S\\<close>"], ["proof (chain)\npicking this:\n  redundant P2 S\n  subsumes P2 C", "have \"redundant C S\""], ["proof (prove)\nusing this:\n  redundant P2 S\n  subsumes P2 C\n\ngoal (1 subgoal):\n 1. redundant C S", "using subsumption_preserves_redundancy"], ["proof (prove)\nusing this:\n  redundant P2 S\n  subsumes P2 C\n  \\<lbrakk>redundant ?C ?S; subsumes ?C ?D\\<rbrakk>\n  \\<Longrightarrow> redundant ?D ?S\n\ngoal (1 subgoal):\n 1. redundant C S", "by auto"], ["proof (state)\nthis:\n  redundant C S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>\\<not>redundant C (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)\n  redundant C S", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n  redundant C S\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "assume \"A \\<noteq> B\""], ["proof (state)\nthis:\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "with \\<open>C = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\\<close> and \\<open>Pos B \\<in> P1\\<close> and \\<open>Neg B \\<in> P1\\<close>"], ["proof (chain)\npicking this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  Pos B \\<in> P1\n  Neg B \\<in> P1\n  A \\<noteq> B", "have \"Pos B \\<in> C\" and \"Neg B \\<in> C\""], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  Pos B \\<in> P1\n  Neg B \\<in> P1\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. Pos B \\<in> C &&& Neg B \\<in> C", "by auto"], ["proof (state)\nthis:\n  Pos B \\<in> C\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "with \\<open>\\<not>redundant C  (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)\n  Pos B \\<in> C\n  Neg B \\<in> C", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n  Pos B \\<in> C\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. False", "unfolding tautology_def redundant_def"], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>A. Pos A \\<in> C \\<and> Neg A \\<in> C) \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n  Pos B \\<in> C\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> tautology P1\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "with \\<open>redundant P1 S\\<close>"], ["proof (chain)\npicking this:\n  redundant P1 S\n  \\<not> tautology P1", "obtain Q1 where \"Q1 \\<in> S\" and \"subsumes Q1 P1\""], ["proof (prove)\nusing this:\n  redundant P1 S\n  \\<not> tautology P1\n\ngoal (1 subgoal):\n 1. (\\<And>Q1.\n        \\<lbrakk>Q1 \\<in> S; subsumes Q1 P1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology P1 \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D P1)\n  \\<not> tautology P1\n\ngoal (1 subgoal):\n 1. (\\<And>Q1.\n        \\<lbrakk>Q1 \\<in> S; subsumes Q1 P1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Q1 \\<in> S\n  subsumes Q1 P1\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "have \"\\<not> (tautology P2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tautology P2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. tautology P2 \\<Longrightarrow> False", "assume \"tautology P2\""], ["proof (state)\nthis:\n  tautology P2\n\ngoal (1 subgoal):\n 1. tautology P2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tautology P2", "obtain B where \"Pos B \\<in> P2\" and \"Neg B \\<in> P2\""], ["proof (prove)\nusing this:\n  tautology P2\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>Pos B \\<in> P2; Neg B \\<in> P2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<exists>A. Pos A \\<in> P2 \\<and> Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>Pos B \\<in> P2; Neg B \\<in> P2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Pos B \\<in> P2\n  Neg B \\<in> P2\n\ngoal (1 subgoal):\n 1. tautology P2 \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"A = B\""], ["proof (state)\nthis:\n  A = B\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>Pos B \\<in> P2\\<close> and \\<open>C = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\\<close>"], ["proof (chain)\npicking this:\n  Pos B \\<in> P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B", "have \"subsumes P1 C\""], ["proof (prove)\nusing this:\n  Pos B \\<in> P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B\n\ngoal (1 subgoal):\n 1. subsumes P1 C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  Pos B \\<in> P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B\n\ngoal (1 subgoal):\n 1. P1 \\<subseteq> C", "using Literal.distinct"], ["proof (prove)\nusing this:\n  Pos B \\<in> P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  A = B\n  Pos ?x1.0 \\<noteq> Neg ?x2.0\n  Neg ?x2.0 \\<noteq> Pos ?x1.0\n\ngoal (1 subgoal):\n 1. P1 \\<subseteq> C", "by blast"], ["proof (state)\nthis:\n  subsumes P1 C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>redundant P1 S\\<close>"], ["proof (chain)\npicking this:\n  redundant P1 S\n  subsumes P1 C", "have \"redundant C S\""], ["proof (prove)\nusing this:\n  redundant P1 S\n  subsumes P1 C\n\ngoal (1 subgoal):\n 1. redundant C S", "using subsumption_preserves_redundancy"], ["proof (prove)\nusing this:\n  redundant P1 S\n  subsumes P1 C\n  \\<lbrakk>redundant ?C ?S; subsumes ?C ?D\\<rbrakk>\n  \\<Longrightarrow> redundant ?D ?S\n\ngoal (1 subgoal):\n 1. redundant C S", "by auto"], ["proof (state)\nthis:\n  redundant C S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>\\<not>redundant C  (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)\n  redundant C S", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n  redundant C S\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n  tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "assume \"A \\<noteq> B\""], ["proof (state)\nthis:\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "with \\<open>C = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\\<close> and \\<open>Pos B \\<in> P2\\<close> and \\<open>Neg B \\<in> P2\\<close>"], ["proof (chain)\npicking this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  Pos B \\<in> P2\n  Neg B \\<in> P2\n  A \\<noteq> B", "have \"Pos B \\<in> C\" and \"Neg B \\<in> C\""], ["proof (prove)\nusing this:\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n  Pos B \\<in> P2\n  Neg B \\<in> P2\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. Pos B \\<in> C &&& Neg B \\<in> C", "by auto"], ["proof (state)\nthis:\n  Pos B \\<in> C\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. A \\<noteq> B \\<Longrightarrow> False", "with \\<open>\\<not>redundant C  (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)\n  Pos B \\<in> C\n  Neg B \\<in> C", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n  Pos B \\<in> C\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. False", "unfolding tautology_def redundant_def"], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>A. Pos A \\<in> C \\<and> Neg A \\<in> C) \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n  Pos B \\<in> C\n  Neg B \\<in> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> tautology P2\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "with \\<open>redundant P2 S\\<close>"], ["proof (chain)\npicking this:\n  redundant P2 S\n  \\<not> tautology P2", "obtain Q2 where \"Q2 \\<in> S\" and \"subsumes Q2 P2\""], ["proof (prove)\nusing this:\n  redundant P2 S\n  \\<not> tautology P2\n\ngoal (1 subgoal):\n 1. (\\<And>Q2.\n        \\<lbrakk>Q2 \\<in> S; subsumes Q2 P2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  tautology P2 \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D P2)\n  \\<not> tautology P2\n\ngoal (1 subgoal):\n 1. (\\<And>Q2.\n        \\<lbrakk>Q2 \\<in> S; subsumes Q2 P2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Q2 \\<in> S\n  subsumes Q2 P2\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "let ?res = \"(Q1 - { Pos A }) \\<union> (Q2 - { Neg A })\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "have \"?res = resolvent_upon Q1 Q2 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q1 - {Pos A} \\<union> (Q2 - {Neg A}) = resolvent_upon Q1 Q2 A", "by auto"], ["proof (state)\nthis:\n  Q1 - {Pos A} \\<union> (Q2 - {Neg A}) = resolvent_upon Q1 Q2 A\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "from this  and \\<open>partial_saturation S A  (S \\<union> R)\\<close> and \\<open>Q1 \\<in> S\\<close> and  \\<open>Q2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  Q1 - {Pos A} \\<union> (Q2 - {Neg A}) = resolvent_upon Q1 Q2 A\n  partial_saturation S A (S \\<union> R)\n  Q1 \\<in> S\n  Q2 \\<in> S", "have \"redundant ?res  (S \\<union> R)\""], ["proof (prove)\nusing this:\n  Q1 - {Pos A} \\<union> (Q2 - {Neg A}) = resolvent_upon Q1 Q2 A\n  partial_saturation S A (S \\<union> R)\n  Q1 \\<in> S\n  Q2 \\<in> S\n\ngoal (1 subgoal):\n 1. redundant (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) (S \\<union> R)", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  Q1 - {Pos A} \\<union> (Q2 - {Neg A}) = resolvent_upon Q1 Q2 A\n  \\<forall>P1 P2.\n     P1 \\<in> S \\<longrightarrow>\n     P2 \\<in> S \\<longrightarrow>\n     redundant (resolvent_upon P1 P2 A) (S \\<union> R)\n  Q1 \\<in> S\n  Q2 \\<in> S\n\ngoal (1 subgoal):\n 1. redundant (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) (S \\<union> R)", "by auto"], ["proof (state)\nthis:\n  redundant (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "from \\<open>subsumes Q1 P1\\<close> and \\<open>subsumes Q2 P2\\<close> and \\<open>C = (P1 - { Pos A }) \\<union> (P2 - { Neg A })\\<close>"], ["proof (chain)\npicking this:\n  subsumes Q1 P1\n  subsumes Q2 P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})", "have \"subsumes ?res C\""], ["proof (prove)\nusing this:\n  subsumes Q1 P1\n  subsumes Q2 P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. subsumes (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  Q1 \\<subseteq> P1\n  Q2 \\<subseteq> P2\n  C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. Q1 - {Pos A} \\<union> (Q2 - {Neg A}) \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  subsumes (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) C\n\ngoal (1 subgoal):\n 1. \\<not> redundant C (S \\<union> R) \\<Longrightarrow> False", "with \\<open>redundant ?res  (S \\<union> R)\\<close> and \\<open>\\<not>redundant C  (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  redundant (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) (S \\<union> R)\n  \\<not> redundant C (S \\<union> R)\n  subsumes (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) C", "show False"], ["proof (prove)\nusing this:\n  redundant (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) (S \\<union> R)\n  \\<not> redundant C (S \\<union> R)\n  subsumes (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) C\n\ngoal (1 subgoal):\n 1. False", "using subsumption_preserves_redundancy"], ["proof (prove)\nusing this:\n  redundant (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) (S \\<union> R)\n  \\<not> redundant C (S \\<union> R)\n  subsumes (Q1 - {Pos A} \\<union> (Q2 - {Neg A})) C\n  \\<lbrakk>redundant ?C ?S; subsumes ?C ?D\\<rbrakk>\n  \\<Longrightarrow> redundant ?D ?S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We show that if @{term R} is a set of resolvents of a set of clauses @{term S} then the \nsame holds for @{ term \"S \\<union> R\"}. For the clauses in @{term S}, the premises are identical to \nthe resolvent and the inference is thus redundant (this trick is useful to simplify proofs).\\<close>"], ["", "definition in_all_resolvents_upon:: \"'at Formula \\<Rightarrow> 'at \\<Rightarrow> 'at Clause \\<Rightarrow> bool\"\nwhere \n  \"in_all_resolvents_upon S A C = (\\<exists> P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> C = resolvent_upon P1 P2 A))\""], ["", "lemma every_clause_is_a_resolvent:\n  assumes \"all_fulfill (in_all_resolvents_upon S A) R\"\n  assumes \"all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\"\n  assumes \"P1 \\<in> S \\<union> R\"\n  shows \"in_all_resolvents_upon S A P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S A P1", "proof ((cases \"P1 \\<in> R\"),(metis all_fulfill_def assms(1)))"], ["proof (state)\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "assume \"P1 \\<notin> R\""], ["proof (state)\nthis:\n  P1 \\<notin> R\n\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "with \\<open>P1 \\<in> S \\<union> R\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S \\<union> R\n  P1 \\<notin> R", "have \"P1 \\<in> S\""], ["proof (prove)\nusing this:\n  P1 \\<in> S \\<union> R\n  P1 \\<notin> R\n\ngoal (1 subgoal):\n 1. P1 \\<in> S", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "with \\<open>(all_fulfill (\\<lambda>x. \\<not>(tautology x)) S )\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  P1 \\<in> S", "have \"\\<not> tautology P1\""], ["proof (prove)\nusing this:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology P1", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> \\<not> tautology C\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology P1", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology P1\n\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "from \\<open>\\<not> tautology P1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology P1", "have \"Neg A \\<notin> P1 \\<or> Pos A \\<notin> P1\""], ["proof (prove)\nusing this:\n  \\<not> tautology P1\n\ngoal (1 subgoal):\n 1. Neg A \\<notin> P1 \\<or> Pos A \\<notin> P1", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<nexists>A. Pos A \\<in> P1 \\<and> Neg A \\<in> P1\n\ngoal (1 subgoal):\n 1. Neg A \\<notin> P1 \\<or> Pos A \\<notin> P1", "by auto"], ["proof (state)\nthis:\n  Neg A \\<notin> P1 \\<or> Pos A \\<notin> P1\n\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "from this"], ["proof (chain)\npicking this:\n  Neg A \\<notin> P1 \\<or> Pos A \\<notin> P1", "have \"P1 = (P1 - { Pos A }) \\<union> (P1 - { Neg A })\""], ["proof (prove)\nusing this:\n  Neg A \\<notin> P1 \\<or> Pos A \\<notin> P1\n\ngoal (1 subgoal):\n 1. P1 = P1 - {Pos A} \\<union> (P1 - {Neg A})", "by auto"], ["proof (state)\nthis:\n  P1 = P1 - {Pos A} \\<union> (P1 - {Neg A})\n\ngoal (1 subgoal):\n 1. P1 \\<notin> R \\<Longrightarrow> in_all_resolvents_upon S A P1", "with \\<open>P1 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S\n  P1 = P1 - {Pos A} \\<union> (P1 - {Neg A})", "show ?thesis"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P1 = P1 - {Pos A} \\<union> (P1 - {Neg A})\n\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S A P1", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P1 = P1 - {Pos A} \\<union> (P1 - {Neg A})\n\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S A P1", "unfolding in_all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P1 = P1 - {Pos A} \\<union> (P1 - {Neg A})\n\ngoal (1 subgoal):\n 1. \\<exists>P1a P2.\n       P1a \\<in> S \\<and> P2 \\<in> S \\<and> P1 = resolvent_upon P1a P2 A", "by auto"], ["proof (state)\nthis:\n  in_all_resolvents_upon S A P1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We show that if a formula is partially saturated then it stays so when new resolvents \nare added in the set.\\<close>"], ["", "lemma partial_saturation_is_preserved :\n  assumes \"partial_saturation S E1 S\"\n  assumes \"partial_saturation S E2 (S \\<union> R)\"\n  assumes \"all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\"\n  assumes \"all_fulfill (in_all_resolvents_upon S E2) R\"\n  shows \"partial_saturation (S \\<union> R) E1 (S \\<union> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_saturation (S \\<union> R) E1 (S \\<union> R)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "assume \"\\<not> partial_saturation (S \\<union> R) E1 (S \\<union> R)\""], ["proof (state)\nthis:\n  \\<not> partial_saturation (S \\<union> R) E1 (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> partial_saturation (S \\<union> R) E1 (S \\<union> R)", "obtain P1 P2 C where \"P1 \\<in> S \\<union> R\" and \"P2 \\<in> S \\<union> R\" and \"C = resolvent_upon P1 P2 E1\" \n    and \"\\<not> redundant C (S \\<union> R)\""], ["proof (prove)\nusing this:\n  \\<not> partial_saturation (S \\<union> R) E1 (S \\<union> R)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> S \\<union> R; P2 \\<in> S \\<union> R;\n         C = resolvent_upon P1 P2 E1;\n         \\<not> redundant C (S \\<union> R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2.\n             P1 \\<in> S \\<union> R \\<longrightarrow>\n             P2 \\<in> S \\<union> R \\<longrightarrow>\n             redundant (resolvent_upon P1 P2 E1) (S \\<union> R))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> S \\<union> R; P2 \\<in> S \\<union> R;\n         C = resolvent_upon P1 P2 E1;\n         \\<not> redundant C (S \\<union> R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S \\<union> R\n  P2 \\<in> S \\<union> R\n  C = resolvent_upon P1 P2 E1\n  \\<not> redundant C (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>C = resolvent_upon P1 P2 E1\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E1", "have \"C = (P1 - { Pos E1 }) \\<union> (P2 - { Neg E1 })\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E1\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos E1} \\<union> (P2 - {Neg E1})", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos E1} \\<union> (P2 - {Neg E1})\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> S \\<union> R\\<close> and assms(4) and \\<open>(all_fulfill (\\<lambda>x. \\<not>(tautology x)) S )\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S \\<union> R\n  all_fulfill (in_all_resolvents_upon S E2) R\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S", "have \"in_all_resolvents_upon S E2 P1\""], ["proof (prove)\nusing this:\n  P1 \\<in> S \\<union> R\n  all_fulfill (in_all_resolvents_upon S E2) R\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S E2 P1", "using every_clause_is_a_resolvent"], ["proof (prove)\nusing this:\n  P1 \\<in> S \\<union> R\n  all_fulfill (in_all_resolvents_upon S E2) R\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  \\<lbrakk>all_fulfill (in_all_resolvents_upon ?S ?A) ?R;\n   all_fulfill (\\<lambda>x. \\<not> tautology x) ?S;\n   ?P1.0 \\<in> ?S \\<union> ?R\\<rbrakk>\n  \\<Longrightarrow> in_all_resolvents_upon ?S ?A ?P1.0\n\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S E2 P1", "by auto"], ["proof (state)\nthis:\n  in_all_resolvents_upon S E2 P1\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  in_all_resolvents_upon S E2 P1", "obtain P1_1 P1_2 where \"P1_1 \\<in> S\" and \"P1_2 \\<in> S\" and \"P1 = resolvent_upon P1_1 P1_2 E2\""], ["proof (prove)\nusing this:\n  in_all_resolvents_upon S E2 P1\n\ngoal (1 subgoal):\n 1. (\\<And>P1_1 P1_2.\n        \\<lbrakk>P1_1 \\<in> S; P1_2 \\<in> S;\n         P1 = resolvent_upon P1_1 P1_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using every_clause_is_a_resolvent"], ["proof (prove)\nusing this:\n  in_all_resolvents_upon S E2 P1\n  \\<lbrakk>all_fulfill (in_all_resolvents_upon ?S ?A) ?R;\n   all_fulfill (\\<lambda>x. \\<not> tautology x) ?S;\n   ?P1.0 \\<in> ?S \\<union> ?R\\<rbrakk>\n  \\<Longrightarrow> in_all_resolvents_upon ?S ?A ?P1.0\n\ngoal (1 subgoal):\n 1. (\\<And>P1_1 P1_2.\n        \\<lbrakk>P1_1 \\<in> S; P1_2 \\<in> S;\n         P1 = resolvent_upon P1_1 P1_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  \\<exists>P1a P2.\n     P1a \\<in> S \\<and> P2 \\<in> S \\<and> P1 = resolvent_upon P1a P2 E2\n  \\<lbrakk>all_fulfill\n            (\\<lambda>C.\n                \\<exists>P1 P2.\n                   P1 \\<in> ?S \\<and>\n                   P2 \\<in> ?S \\<and> C = resolvent_upon P1 P2 ?A)\n            ?R;\n   all_fulfill (\\<lambda>x. \\<not> tautology x) ?S;\n   ?P1.0 \\<in> ?S \\<union> ?R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P1 P2.\n                       P1 \\<in> ?S \\<and>\n                       P2 \\<in> ?S \\<and> ?P1.0 = resolvent_upon P1 P2 ?A\n\ngoal (1 subgoal):\n 1. (\\<And>P1_1 P1_2.\n        \\<lbrakk>P1_1 \\<in> S; P1_2 \\<in> S;\n         P1 = resolvent_upon P1_1 P1_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P1_1 \\<in> S\n  P1_2 \\<in> S\n  P1 = resolvent_upon P1_1 P1_2 E2\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> S \\<union> R\\<close> and assms(4) and \\<open>(all_fulfill (\\<lambda>x. \\<not>(tautology x)) S )\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> S \\<union> R\n  all_fulfill (in_all_resolvents_upon S E2) R\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S", "have \"in_all_resolvents_upon S E2 P2\""], ["proof (prove)\nusing this:\n  P2 \\<in> S \\<union> R\n  all_fulfill (in_all_resolvents_upon S E2) R\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S E2 P2", "using every_clause_is_a_resolvent"], ["proof (prove)\nusing this:\n  P2 \\<in> S \\<union> R\n  all_fulfill (in_all_resolvents_upon S E2) R\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  \\<lbrakk>all_fulfill (in_all_resolvents_upon ?S ?A) ?R;\n   all_fulfill (\\<lambda>x. \\<not> tautology x) ?S;\n   ?P1.0 \\<in> ?S \\<union> ?R\\<rbrakk>\n  \\<Longrightarrow> in_all_resolvents_upon ?S ?A ?P1.0\n\ngoal (1 subgoal):\n 1. in_all_resolvents_upon S E2 P2", "by auto"], ["proof (state)\nthis:\n  in_all_resolvents_upon S E2 P2\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  in_all_resolvents_upon S E2 P2", "obtain P2_1 P2_2 where \"P2_1 \\<in> S\" and \"P2_2 \\<in> S\" and  \"P2 = resolvent_upon P2_1 P2_2 E2\""], ["proof (prove)\nusing this:\n  in_all_resolvents_upon S E2 P2\n\ngoal (1 subgoal):\n 1. (\\<And>P2_1 P2_2.\n        \\<lbrakk>P2_1 \\<in> S; P2_2 \\<in> S;\n         P2 = resolvent_upon P2_1 P2_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using every_clause_is_a_resolvent"], ["proof (prove)\nusing this:\n  in_all_resolvents_upon S E2 P2\n  \\<lbrakk>all_fulfill (in_all_resolvents_upon ?S ?A) ?R;\n   all_fulfill (\\<lambda>x. \\<not> tautology x) ?S;\n   ?P1.0 \\<in> ?S \\<union> ?R\\<rbrakk>\n  \\<Longrightarrow> in_all_resolvents_upon ?S ?A ?P1.0\n\ngoal (1 subgoal):\n 1. (\\<And>P2_1 P2_2.\n        \\<lbrakk>P2_1 \\<in> S; P2_2 \\<in> S;\n         P2 = resolvent_upon P2_1 P2_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  \\<exists>P1 P2a.\n     P1 \\<in> S \\<and> P2a \\<in> S \\<and> P2 = resolvent_upon P1 P2a E2\n  \\<lbrakk>all_fulfill\n            (\\<lambda>C.\n                \\<exists>P1 P2.\n                   P1 \\<in> ?S \\<and>\n                   P2 \\<in> ?S \\<and> C = resolvent_upon P1 P2 ?A)\n            ?R;\n   all_fulfill (\\<lambda>x. \\<not> tautology x) ?S;\n   ?P1.0 \\<in> ?S \\<union> ?R\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P1 P2.\n                       P1 \\<in> ?S \\<and>\n                       P2 \\<in> ?S \\<and> ?P1.0 = resolvent_upon P1 P2 ?A\n\ngoal (1 subgoal):\n 1. (\\<And>P2_1 P2_2.\n        \\<lbrakk>P2_1 \\<in> S; P2_2 \\<in> S;\n         P2 = resolvent_upon P2_1 P2_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P2_1 \\<in> S\n  P2_2 \\<in> S\n  P2 = resolvent_upon P2_1 P2_2 E2\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "let ?R1 = \"resolvent_upon P1_1 P2_1 E1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>partial_saturation S E1 S\\<close> and \\<open>P1_1 \\<in> S\\<close> and \\<open>P2_1 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  partial_saturation S E1 S\n  P1_1 \\<in> S\n  P2_1 \\<in> S", "have \"redundant ?R1 S\""], ["proof (prove)\nusing this:\n  partial_saturation S E1 S\n  P1_1 \\<in> S\n  P2_1 \\<in> S\n\ngoal (1 subgoal):\n 1. redundant (resolvent_upon P1_1 P2_1 E1) S", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2.\n     P1 \\<in> S \\<longrightarrow>\n     P2 \\<in> S \\<longrightarrow> redundant (resolvent_upon P1 P2 E1) S\n  P1_1 \\<in> S\n  P2_1 \\<in> S\n\ngoal (1 subgoal):\n 1. redundant (resolvent_upon P1_1 P2_1 E1) S", "by auto"], ["proof (state)\nthis:\n  redundant (resolvent_upon P1_1 P2_1 E1) S\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "let ?R2 = \"resolvent_upon P1_2 P2_2 E1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>partial_saturation S E1 S\\<close> and \\<open>P1_2 \\<in> S\\<close> and \\<open>P2_2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  partial_saturation S E1 S\n  P1_2 \\<in> S\n  P2_2 \\<in> S", "have \"redundant ?R2 S\""], ["proof (prove)\nusing this:\n  partial_saturation S E1 S\n  P1_2 \\<in> S\n  P2_2 \\<in> S\n\ngoal (1 subgoal):\n 1. redundant (resolvent_upon P1_2 P2_2 E1) S", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2.\n     P1 \\<in> S \\<longrightarrow>\n     P2 \\<in> S \\<longrightarrow> redundant (resolvent_upon P1 P2 E1) S\n  P1_2 \\<in> S\n  P2_2 \\<in> S\n\ngoal (1 subgoal):\n 1. redundant (resolvent_upon P1_2 P2_2 E1) S", "by auto"], ["proof (state)\nthis:\n  redundant (resolvent_upon P1_2 P2_2 E1) S\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "let ?C = \"resolvent_upon ?R1 ?R2 E2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>C = resolvent_upon P1 P2 E1\\<close> and \\<open>P2 = resolvent_upon P2_1 P2_2 E2\\<close> \n    and \\<open>P1 = resolvent_upon P1_1 P1_2 E2\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E1\n  P2 = resolvent_upon P2_1 P2_2 E2\n  P1 = resolvent_upon P1_1 P1_2 E2", "have \"?C = C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E1\n  P2 = resolvent_upon P2_1 P2_2 E2\n  P1 = resolvent_upon P1_1 P1_2 E2\n\ngoal (1 subgoal):\n 1. resolvent_upon (resolvent_upon P1_1 P2_1 E1)\n     (resolvent_upon P1_2 P2_2 E1) E2 =\n    C", "by auto"], ["proof (state)\nthis:\n  resolvent_upon (resolvent_upon P1_1 P2_1 E1) (resolvent_upon P1_2 P2_2 E1)\n   E2 =\n  C\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E1\n            (S \\<union> R) \\<Longrightarrow>\n    False", "with \\<open>redundant ?R1 S\\<close> and \\<open>redundant ?R2 S\\<close> and \\<open>partial_saturation S E2 (S \\<union> R)\\<close> \n    and \\<open>\\<not> redundant C (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  redundant (resolvent_upon P1_1 P2_1 E1) S\n  redundant (resolvent_upon P1_2 P2_2 E1) S\n  partial_saturation S E2 (S \\<union> R)\n  \\<not> redundant C (S \\<union> R)\n  resolvent_upon (resolvent_upon P1_1 P2_1 E1) (resolvent_upon P1_2 P2_2 E1)\n   E2 =\n  C", "show \"False\""], ["proof (prove)\nusing this:\n  redundant (resolvent_upon P1_1 P2_1 E1) S\n  redundant (resolvent_upon P1_2 P2_2 E1) S\n  partial_saturation S E2 (S \\<union> R)\n  \\<not> redundant C (S \\<union> R)\n  resolvent_upon (resolvent_upon P1_1 P2_1 E1) (resolvent_upon P1_2 P2_2 E1)\n   E2 =\n  C\n\ngoal (1 subgoal):\n 1. False", "using resolvent_upon_and_partial_saturation"], ["proof (prove)\nusing this:\n  redundant (resolvent_upon P1_1 P2_1 E1) S\n  redundant (resolvent_upon P1_2 P2_2 E1) S\n  partial_saturation S E2 (S \\<union> R)\n  \\<not> redundant C (S \\<union> R)\n  resolvent_upon (resolvent_upon P1_1 P2_1 E1) (resolvent_upon P1_2 P2_2 E1)\n   E2 =\n  C\n  \\<lbrakk>redundant ?P1.0 ?S; redundant ?P2.0 ?S;\n   partial_saturation ?S ?A (?S \\<union> ?R);\n   ?C = resolvent_upon ?P1.0 ?P2.0 ?A\\<rbrakk>\n  \\<Longrightarrow> redundant ?C (?S \\<union> ?R)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma shows that the clauses inferred by applying the resolution rule\n upon a given atom contain no occurrence of this atom, unless the inference is redundant.\\<close>"], ["", "lemma resolvents_do_not_contain_atom :\n  assumes \"\\<not> tautology P1\"\n  assumes \"\\<not> tautology P2\"\n  assumes \"C = resolvent_upon P1 P2 E2\"\n  assumes \"\\<not> subsumes P1 C\"\n  assumes \"\\<not> subsumes P2 C\"\n  shows \"(Neg E2) \\<notin> C \\<and> (Pos E2) \\<notin> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg E2 \\<notin> C \\<and> Pos E2 \\<notin> C", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Neg E2 \\<notin> C\n 2. Pos E2 \\<notin> C", "from \\<open>C = resolvent_upon P1 P2 E2\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E2", "have \"C = (P1 - { Pos E2 }) \\<union> (P2 - { Neg E2 })\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (2 subgoals):\n 1. Neg E2 \\<notin> C\n 2. Pos E2 \\<notin> C", "show \"(Neg E2) \\<notin> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg E2 \\<notin> C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Neg E2 \\<in> C \\<Longrightarrow> False", "assume \"Neg E2 \\<in> C\""], ["proof (state)\nthis:\n  Neg E2 \\<in> C\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> C \\<Longrightarrow> False", "from \\<open>C = resolvent_upon P1 P2 E2\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E2", "have \"C = (P1 - { Pos E2 }) \\<union> (P2 - { Neg E2 })\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> C \\<Longrightarrow> False", "with \\<open>Neg E2 \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Neg E2 \\<in> C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "have \"Neg E2 \\<in> P1\""], ["proof (prove)\nusing this:\n  Neg E2 \\<in> C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> P1", "by auto"], ["proof (state)\nthis:\n  Neg E2 \\<in> P1\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> C \\<Longrightarrow> False", "from \\<open>\\<not> subsumes P1 C\\<close> and  \\<open>C = (P1 - { Pos E2 }) \\<union> (P2 - { Neg E2 })\\<close>"], ["proof (chain)\npicking this:\n  \\<not> subsumes P1 C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "have \"Pos E2 \\<in> P1\""], ["proof (prove)\nusing this:\n  \\<not> subsumes P1 C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> P1", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  \\<not> P1 \\<subseteq> C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> P1", "by auto"], ["proof (state)\nthis:\n  Pos E2 \\<in> P1\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> C \\<Longrightarrow> False", "from \\<open>Neg E2 \\<in> P1\\<close> and \\<open>Pos E2 \\<in> P1\\<close> and  \\<open>\\<not> tautology P1\\<close>"], ["proof (chain)\npicking this:\n  Neg E2 \\<in> P1\n  Pos E2 \\<in> P1\n  \\<not> tautology P1", "show \"False\""], ["proof (prove)\nusing this:\n  Neg E2 \\<in> P1\n  Pos E2 \\<in> P1\n  \\<not> tautology P1\n\ngoal (1 subgoal):\n 1. False", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  Neg E2 \\<in> P1\n  Pos E2 \\<in> P1\n  \\<nexists>A. Pos A \\<in> P1 \\<and> Neg A \\<in> P1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Neg E2 \\<notin> C\n\ngoal (1 subgoal):\n 1. Pos E2 \\<notin> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Pos E2 \\<notin> C", "show \"(Pos E2) \\<notin> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos E2 \\<notin> C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Pos E2 \\<in> C \\<Longrightarrow> False", "assume \"Pos E2 \\<in> C\""], ["proof (state)\nthis:\n  Pos E2 \\<in> C\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> C \\<Longrightarrow> False", "from \\<open>C = resolvent_upon P1 P2 E2\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E2", "have \"C = (P1 - { Pos E2 }) \\<union> (P2 - { Neg E2 })\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n\ngoal (1 subgoal):\n 1. C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "by auto"], ["proof (state)\nthis:\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> C \\<Longrightarrow> False", "with \\<open>Pos E2 \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Pos E2 \\<in> C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "have \"Pos E2 \\<in> P2\""], ["proof (prove)\nusing this:\n  Pos E2 \\<in> C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> P2", "by auto"], ["proof (state)\nthis:\n  Pos E2 \\<in> P2\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> C \\<Longrightarrow> False", "from \\<open>\\<not> subsumes P2 C\\<close> and  \\<open>C = (P1 - { Pos E2 }) \\<union> (P2 - { Neg E2 })\\<close>"], ["proof (chain)\npicking this:\n  \\<not> subsumes P2 C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})", "have \"Neg E2 \\<in> P2\""], ["proof (prove)\nusing this:\n  \\<not> subsumes P2 C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> P2", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  \\<not> P2 \\<subseteq> C\n  C = P1 - {Pos E2} \\<union> (P2 - {Neg E2})\n\ngoal (1 subgoal):\n 1. Neg E2 \\<in> P2", "by auto"], ["proof (state)\nthis:\n  Neg E2 \\<in> P2\n\ngoal (1 subgoal):\n 1. Pos E2 \\<in> C \\<Longrightarrow> False", "from \\<open>Neg E2 \\<in> P2\\<close> and \\<open>Pos E2 \\<in> P2\\<close> and  \\<open>\\<not> tautology P2\\<close>"], ["proof (chain)\npicking this:\n  Neg E2 \\<in> P2\n  Pos E2 \\<in> P2\n  \\<not> tautology P2", "show \"False\""], ["proof (prove)\nusing this:\n  Neg E2 \\<in> P2\n  Pos E2 \\<in> P2\n  \\<not> tautology P2\n\ngoal (1 subgoal):\n 1. False", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  Neg E2 \\<in> P2\n  Pos E2 \\<in> P2\n  \\<nexists>A. Pos A \\<in> P2 \\<and> Neg A \\<in> P2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pos E2 \\<notin> C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma shows that partial saturation can be ensured by computing all \n(non-redundant) resolvents upon the considered atom.\\<close>"], ["", "lemma ensures_partial_saturation :\n  assumes \"partial_saturation S E2 (S \\<union> R)\"\n  assumes \"all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\"\n  assumes \"all_fulfill (in_all_resolvents_upon S E2) R\"\n  assumes \"all_fulfill (\\<lambda>x. (\\<not>redundant x S)) R\"\n  shows \"partial_saturation (S \\<union> R) E2 (S \\<union> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_saturation (S \\<union> R) E2 (S \\<union> R)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E2\n            (S \\<union> R) \\<Longrightarrow>\n    False", "assume \"\\<not> partial_saturation (S \\<union> R) E2 (S \\<union> R)\""], ["proof (state)\nthis:\n  \\<not> partial_saturation (S \\<union> R) E2 (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E2\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> partial_saturation (S \\<union> R) E2 (S \\<union> R)", "obtain P1 P2 C where \"P1 \\<in> S \\<union> R\" and \"P2 \\<in> S \\<union> R\" and \"C = resolvent_upon P1 P2 E2\" \n    and \"\\<not> redundant C (S \\<union> R)\""], ["proof (prove)\nusing this:\n  \\<not> partial_saturation (S \\<union> R) E2 (S \\<union> R)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> S \\<union> R; P2 \\<in> S \\<union> R;\n         C = resolvent_upon P1 P2 E2;\n         \\<not> redundant C (S \\<union> R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2.\n             P1 \\<in> S \\<union> R \\<longrightarrow>\n             P2 \\<in> S \\<union> R \\<longrightarrow>\n             redundant (resolvent_upon P1 P2 E2) (S \\<union> R))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> S \\<union> R; P2 \\<in> S \\<union> R;\n         C = resolvent_upon P1 P2 E2;\n         \\<not> redundant C (S \\<union> R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S \\<union> R\n  P2 \\<in> S \\<union> R\n  C = resolvent_upon P1 P2 E2\n  \\<not> redundant C (S \\<union> R)\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E2\n            (S \\<union> R) \\<Longrightarrow>\n    False", "have \"P1 \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 \\<in> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "assume \"P1 \\<notin> S\""], ["proof (state)\nthis:\n  P1 \\<notin> S\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "with \\<open>P1 \\<in> S \\<union> R\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S \\<union> R\n  P1 \\<notin> S", "have \"P1 \\<in> R\""], ["proof (prove)\nusing this:\n  P1 \\<in> S \\<union> R\n  P1 \\<notin> S\n\ngoal (1 subgoal):\n 1. P1 \\<in> R", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> R\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "with assms(3)"], ["proof (chain)\npicking this:\n  all_fulfill (in_all_resolvents_upon S E2) R\n  P1 \\<in> R", "obtain P1_1 and P1_2 where \"P1_1 \\<in> S\" and \"P1_2 \\<in> S\" \n     and \"P1 = resolvent_upon P1_1 P1_2 E2\""], ["proof (prove)\nusing this:\n  all_fulfill (in_all_resolvents_upon S E2) R\n  P1 \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>P1_1 P1_2.\n        \\<lbrakk>P1_1 \\<in> S; P1_2 \\<in> S;\n         P1 = resolvent_upon P1_1 P1_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def in_all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     C \\<in> R \\<longrightarrow>\n     (\\<exists>P1 P2.\n         P1 \\<in> S \\<and> P2 \\<in> S \\<and> C = resolvent_upon P1 P2 E2)\n  P1 \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>P1_1 P1_2.\n        \\<lbrakk>P1_1 \\<in> S; P1_2 \\<in> S;\n         P1 = resolvent_upon P1_1 P1_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1_1 \\<in> S\n  P1_2 \\<in> S\n  P1 = resolvent_upon P1_1 P1_2 E2\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "from \\<open>all_fulfill (\\<lambda>x. \\<not>(tautology x)) S\\<close> and \\<open>P1_1 \\<in> S\\<close> and \\<open>P1_2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  P1_1 \\<in> S\n  P1_2 \\<in> S", "have \"\\<not> tautology P1_1\" and \"\\<not> tautology P1_2\""], ["proof (prove)\nusing this:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  P1_1 \\<in> S\n  P1_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology P1_1 &&& \\<not> tautology P1_2", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> \\<not> tautology C\n  P1_1 \\<in> S\n  P1_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology P1_1 &&& \\<not> tautology P1_2", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology P1_1\n  \\<not> tautology P1_2\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "from \\<open>all_fulfill (\\<lambda>x. (\\<not>redundant x S)) R\\<close> and \\<open>P1 \\<in> R\\<close> and \\<open>P1_1 \\<in> S\\<close> and \\<open>P1_2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill (\\<lambda>x. \\<not> redundant x S) R\n  P1 \\<in> R\n  P1_1 \\<in> S\n  P1_2 \\<in> S", "have \"\\<not> subsumes P1_1 P1\" and \"\\<not> subsumes P1_2 P1\""], ["proof (prove)\nusing this:\n  all_fulfill (\\<lambda>x. \\<not> redundant x S) R\n  P1 \\<in> R\n  P1_1 \\<in> S\n  P1_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> subsumes P1_1 P1 &&& \\<not> subsumes P1_2 P1", "unfolding redundant_def all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     C \\<in> R \\<longrightarrow>\n     \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C))\n  P1 \\<in> R\n  P1_1 \\<in> S\n  P1_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> subsumes P1_1 P1 &&& \\<not> subsumes P1_2 P1", "by auto"], ["proof (state)\nthis:\n  \\<not> subsumes P1_1 P1\n  \\<not> subsumes P1_2 P1\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "from \\<open>\\<not> tautology P1_1\\<close> \\<open>\\<not> tautology P1_2\\<close> \\<open>\\<not> subsumes P1_1 P1\\<close> and \\<open>\\<not> subsumes P1_2 P1\\<close> \n      and \\<open>P1 = resolvent_upon P1_1 P1_2 E2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology P1_1\n  \\<not> tautology P1_2\n  \\<not> subsumes P1_1 P1\n  \\<not> subsumes P1_2 P1\n  P1 = resolvent_upon P1_1 P1_2 E2", "have \"(Neg E2) \\<notin> P1 \\<and> (Pos E2) \\<notin> P1\""], ["proof (prove)\nusing this:\n  \\<not> tautology P1_1\n  \\<not> tautology P1_2\n  \\<not> subsumes P1_1 P1\n  \\<not> subsumes P1_2 P1\n  P1 = resolvent_upon P1_1 P1_2 E2\n\ngoal (1 subgoal):\n 1. Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1", "using resolvents_do_not_contain_atom [of P1_1 P1_2 P1 E2]"], ["proof (prove)\nusing this:\n  \\<not> tautology P1_1\n  \\<not> tautology P1_2\n  \\<not> subsumes P1_1 P1\n  \\<not> subsumes P1_2 P1\n  P1 = resolvent_upon P1_1 P1_2 E2\n  \\<lbrakk>\\<not> tautology P1_1; \\<not> tautology P1_2;\n   P1 = resolvent_upon P1_1 P1_2 E2; \\<not> subsumes P1_1 P1;\n   \\<not> subsumes P1_2 P1\\<rbrakk>\n  \\<Longrightarrow> Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1\n\ngoal (1 subgoal):\n 1. Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1", "by auto"], ["proof (state)\nthis:\n  Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "with \\<open>C = resolvent_upon P1 P2 E2\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E2\n  Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1", "have \"subsumes P1 C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n  Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1\n\ngoal (1 subgoal):\n 1. subsumes P1 C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n  Neg E2 \\<notin> P1 \\<and> Pos E2 \\<notin> P1\n\ngoal (1 subgoal):\n 1. P1 \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  subsumes P1 C\n\ngoal (1 subgoal):\n 1. P1 \\<notin> S \\<Longrightarrow> False", "with \\<open>\\<not> redundant C (S \\<union> R)\\<close> and \\<open>P1 \\<in> S \\<union> R\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)\n  P1 \\<in> S \\<union> R\n  subsumes P1 C", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n  P1 \\<in> S \\<union> R\n  subsumes P1 C\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n  P1 \\<in> S \\<union> R\n  subsumes P1 C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E2\n            (S \\<union> R) \\<Longrightarrow>\n    False", "have \"P2 \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 \\<in> S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "assume \"P2 \\<notin> S\""], ["proof (state)\nthis:\n  P2 \\<notin> S\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "with \\<open>P2 \\<in> S \\<union> R\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> S \\<union> R\n  P2 \\<notin> S", "have \"P2 \\<in> R\""], ["proof (prove)\nusing this:\n  P2 \\<in> S \\<union> R\n  P2 \\<notin> S\n\ngoal (1 subgoal):\n 1. P2 \\<in> R", "by auto"], ["proof (state)\nthis:\n  P2 \\<in> R\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "with assms(3)"], ["proof (chain)\npicking this:\n  all_fulfill (in_all_resolvents_upon S E2) R\n  P2 \\<in> R", "obtain P2_1 and P2_2 where \"P2_1 \\<in> S\" and \"P2_2 \\<in> S\" \n      and \"P2 = resolvent_upon P2_1 P2_2 E2\""], ["proof (prove)\nusing this:\n  all_fulfill (in_all_resolvents_upon S E2) R\n  P2 \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>P2_1 P2_2.\n        \\<lbrakk>P2_1 \\<in> S; P2_2 \\<in> S;\n         P2 = resolvent_upon P2_1 P2_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def in_all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     C \\<in> R \\<longrightarrow>\n     (\\<exists>P1 P2.\n         P1 \\<in> S \\<and> P2 \\<in> S \\<and> C = resolvent_upon P1 P2 E2)\n  P2 \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>P2_1 P2_2.\n        \\<lbrakk>P2_1 \\<in> S; P2_2 \\<in> S;\n         P2 = resolvent_upon P2_1 P2_2 E2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P2_1 \\<in> S\n  P2_2 \\<in> S\n  P2 = resolvent_upon P2_1 P2_2 E2\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "from \\<open>(all_fulfill (\\<lambda>x. \\<not>(tautology x)) S )\\<close> and \\<open>P2_1 \\<in> S\\<close> and \\<open>P2_2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  P2_1 \\<in> S\n  P2_2 \\<in> S", "have \"\\<not> tautology P2_1\" and \"\\<not> tautology P2_2\""], ["proof (prove)\nusing this:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) S\n  P2_1 \\<in> S\n  P2_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology P2_1 &&& \\<not> tautology P2_2", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C. C \\<in> S \\<longrightarrow> \\<not> tautology C\n  P2_1 \\<in> S\n  P2_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> tautology P2_1 &&& \\<not> tautology P2_2", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology P2_1\n  \\<not> tautology P2_2\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "from \\<open>all_fulfill (\\<lambda>x. (\\<not>redundant x S)) R\\<close> and \\<open>P2 \\<in> R\\<close> and \\<open>P2_1 \\<in> S\\<close> and \\<open>P2_2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill (\\<lambda>x. \\<not> redundant x S) R\n  P2 \\<in> R\n  P2_1 \\<in> S\n  P2_2 \\<in> S", "have \"\\<not> subsumes P2_1 P2\" and \"\\<not> subsumes P2_2 P2\""], ["proof (prove)\nusing this:\n  all_fulfill (\\<lambda>x. \\<not> redundant x S) R\n  P2 \\<in> R\n  P2_1 \\<in> S\n  P2_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> subsumes P2_1 P2 &&& \\<not> subsumes P2_2 P2", "unfolding redundant_def all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<forall>C.\n     C \\<in> R \\<longrightarrow>\n     \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> S \\<and> subsumes D C))\n  P2 \\<in> R\n  P2_1 \\<in> S\n  P2_2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> subsumes P2_1 P2 &&& \\<not> subsumes P2_2 P2", "by auto"], ["proof (state)\nthis:\n  \\<not> subsumes P2_1 P2\n  \\<not> subsumes P2_2 P2\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "from \\<open>\\<not> tautology P2_1\\<close> \\<open>\\<not> tautology P2_2\\<close> \\<open>\\<not> subsumes P2_1 P2\\<close> and \\<open>\\<not> subsumes P2_2 P2\\<close> \n      and \\<open>P2 = resolvent_upon P2_1 P2_2 E2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology P2_1\n  \\<not> tautology P2_2\n  \\<not> subsumes P2_1 P2\n  \\<not> subsumes P2_2 P2\n  P2 = resolvent_upon P2_1 P2_2 E2", "have \"(Neg E2) \\<notin> P2 \\<and> (Pos E2) \\<notin> P2\""], ["proof (prove)\nusing this:\n  \\<not> tautology P2_1\n  \\<not> tautology P2_2\n  \\<not> subsumes P2_1 P2\n  \\<not> subsumes P2_2 P2\n  P2 = resolvent_upon P2_1 P2_2 E2\n\ngoal (1 subgoal):\n 1. Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2", "using resolvents_do_not_contain_atom [of P2_1 P2_2 P2 E2]"], ["proof (prove)\nusing this:\n  \\<not> tautology P2_1\n  \\<not> tautology P2_2\n  \\<not> subsumes P2_1 P2\n  \\<not> subsumes P2_2 P2\n  P2 = resolvent_upon P2_1 P2_2 E2\n  \\<lbrakk>\\<not> tautology P2_1; \\<not> tautology P2_2;\n   P2 = resolvent_upon P2_1 P2_2 E2; \\<not> subsumes P2_1 P2;\n   \\<not> subsumes P2_2 P2\\<rbrakk>\n  \\<Longrightarrow> Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2\n\ngoal (1 subgoal):\n 1. Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2", "by auto"], ["proof (state)\nthis:\n  Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "with \\<open>C = resolvent_upon P1 P2 E2\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 E2\n  Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2", "have \"subsumes P2 C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n  Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2\n\ngoal (1 subgoal):\n 1. subsumes P2 C", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 E2\n  Neg E2 \\<notin> P2 \\<and> Pos E2 \\<notin> P2\n\ngoal (1 subgoal):\n 1. P2 \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  subsumes P2 C\n\ngoal (1 subgoal):\n 1. P2 \\<notin> S \\<Longrightarrow> False", "with \\<open>\\<not> redundant C (S \\<union> R)\\<close> and \\<open>P2 \\<in> S \\<union> R\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (S \\<union> R)\n  P2 \\<in> S \\<union> R\n  subsumes P2 C", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (S \\<union> R)\n  P2 \\<in> S \\<union> R\n  subsumes P2 C\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n  P2 \\<in> S \\<union> R\n  subsumes P2 C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (S \\<union> R) E2\n            (S \\<union> R) \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> S\\<close> and \\<open>P2 \\<in> S\\<close> and \\<open>partial_saturation S E2 (S \\<union> R)\\<close> \n    and \\<open>C = resolvent_upon P1 P2 E2\\<close> and \\<open>\\<not> redundant C (S \\<union> R)\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S\n  P2 \\<in> S\n  partial_saturation S E2 (S \\<union> R)\n  C = resolvent_upon P1 P2 E2\n  \\<not> redundant C (S \\<union> R)", "show \"False\""], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P2 \\<in> S\n  partial_saturation S E2 (S \\<union> R)\n  C = resolvent_upon P1 P2 E2\n  \\<not> redundant C (S \\<union> R)\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def partial_saturation_def"], ["proof (prove)\nusing this:\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<forall>P1 P2.\n     P1 \\<in> S \\<longrightarrow>\n     P2 \\<in> S \\<longrightarrow>\n     tautology (resolvent_upon P1 P2 E2) \\<or>\n     (\\<exists>D.\n         D \\<in> S \\<union> R \\<and> subsumes D (resolvent_upon P1 P2 E2))\n  C = resolvent_upon P1 P2 E2\n  \\<not> (tautology C \\<or>\n          (\\<exists>D. D \\<in> S \\<union> R \\<and> subsumes D C))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resolvents_preserve_equivalence:\n  shows \"equivalent S (S \\<union> (all_resolvents_upon S A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent S (S \\<union> all_resolvents_upon S A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equivalent S (S \\<union> all_resolvents_upon S A)", "have \"S \\<subseteq> (S \\<union> (all_resolvents_upon S A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S \\<union> all_resolvents_upon S A", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> S \\<union> all_resolvents_upon S A\n\ngoal (1 subgoal):\n 1. equivalent S (S \\<union> all_resolvents_upon S A)", "then"], ["proof (chain)\npicking this:\n  S \\<subseteq> S \\<union> all_resolvents_upon S A", "have \"entails_formula (S \\<union> (all_resolvents_upon S A)) S\""], ["proof (prove)\nusing this:\n  S \\<subseteq> S \\<union> all_resolvents_upon S A\n\ngoal (1 subgoal):\n 1. entails_formula (S \\<union> all_resolvents_upon S A) S", "using entailment_subset"], ["proof (prove)\nusing this:\n  S \\<subseteq> S \\<union> all_resolvents_upon S A\n  ?S2.0 \\<subseteq> ?S1.0 \\<Longrightarrow> entails_formula ?S1.0 ?S2.0\n\ngoal (1 subgoal):\n 1. entails_formula (S \\<union> all_resolvents_upon S A) S", "by auto"], ["proof (state)\nthis:\n  entails_formula (S \\<union> all_resolvents_upon S A) S\n\ngoal (1 subgoal):\n 1. equivalent S (S \\<union> all_resolvents_upon S A)", "have \"entails_formula S (S \\<union> (all_resolvents_upon S A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. entails_formula S (S \\<union> all_resolvents_upon S A)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> entails_formula S\n            (S \\<union> all_resolvents_upon S A) \\<Longrightarrow>\n    False", "assume \"\\<not>entails_formula S (S \\<union> (all_resolvents_upon S A))\""], ["proof (state)\nthis:\n  \\<not> entails_formula S (S \\<union> all_resolvents_upon S A)\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S\n            (S \\<union> all_resolvents_upon S A) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> entails_formula S (S \\<union> all_resolvents_upon S A)", "obtain C where \"C \\<in> (all_resolvents_upon S A)\" and \"\\<not>entails S C\""], ["proof (prove)\nusing this:\n  \\<not> entails_formula S (S \\<union> all_resolvents_upon S A)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_resolvents_upon S A;\n         \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding entails_formula_def"], ["proof (prove)\nusing this:\n  \\<not> Ball (S \\<union> all_resolvents_upon S A) (entails S)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_resolvents_upon S A;\n         \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using entails_member"], ["proof (prove)\nusing this:\n  \\<not> Ball (S \\<union> all_resolvents_upon S A) (entails S)\n  ?C \\<in> ?S \\<Longrightarrow> entails ?S ?C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> all_resolvents_upon S A;\n         \\<not> entails S C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> all_resolvents_upon S A\n  \\<not> entails S C\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S\n            (S \\<union> all_resolvents_upon S A) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> (all_resolvents_upon S A)\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> all_resolvents_upon S A", "obtain P1 P2 \n      where \"C = resolvent_upon P1 P2 A\" and \"P1 \\<in> S\" and \"P2 \\<in> S\""], ["proof (prove)\nusing this:\n  C \\<in> all_resolvents_upon S A\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>C = resolvent_upon P1 P2 A; P1 \\<in> S; P2 \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  C \\<in> {C. \\<exists>P1 P2.\n                 P1 \\<in> S \\<and>\n                 P2 \\<in> S \\<and> C = resolvent_upon P1 P2 A}\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>C = resolvent_upon P1 P2 A; P1 \\<in> S; P2 \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = resolvent_upon P1 P2 A\n  P1 \\<in> S\n  P2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S\n            (S \\<union> all_resolvents_upon S A) \\<Longrightarrow>\n    False", "from \\<open>C = resolvent_upon P1 P2 A\\<close> and \\<open>P1 \\<in> S\\<close> and \\<open>P2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 A\n  P1 \\<in> S\n  P2 \\<in> S", "have \"entails S C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 A\n  P1 \\<in> S\n  P2 \\<in> S\n\ngoal (1 subgoal):\n 1. entails S C", "using resolvent_upon_correct"], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 A\n  P1 \\<in> S\n  P2 \\<in> S\n  \\<lbrakk>?P1.0 \\<in> ?S; ?P2.0 \\<in> ?S;\n   ?C = resolvent_upon ?P1.0 ?P2.0 ?A\\<rbrakk>\n  \\<Longrightarrow> entails ?S ?C\n\ngoal (1 subgoal):\n 1. entails S C", "by auto"], ["proof (state)\nthis:\n  entails S C\n\ngoal (1 subgoal):\n 1. \\<not> entails_formula S\n            (S \\<union> all_resolvents_upon S A) \\<Longrightarrow>\n    False", "with \\<open>\\<not>entails S C\\<close>"], ["proof (chain)\npicking this:\n  \\<not> entails S C\n  entails S C", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> entails S C\n  entails S C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  entails_formula S (S \\<union> all_resolvents_upon S A)\n\ngoal (1 subgoal):\n 1. equivalent S (S \\<union> all_resolvents_upon S A)", "from \\<open>entails_formula (S \\<union> (all_resolvents_upon S A)) S\\<close> \n    and \\<open>entails_formula S (S \\<union> (all_resolvents_upon S A))\\<close>"], ["proof (chain)\npicking this:\n  entails_formula (S \\<union> all_resolvents_upon S A) S\n  entails_formula S (S \\<union> all_resolvents_upon S A)", "show ?thesis"], ["proof (prove)\nusing this:\n  entails_formula (S \\<union> all_resolvents_upon S A) S\n  entails_formula S (S \\<union> all_resolvents_upon S A)\n\ngoal (1 subgoal):\n 1. equivalent S (S \\<union> all_resolvents_upon S A)", "unfolding equivalent_def"], ["proof (prove)\nusing this:\n  entails_formula (S \\<union> all_resolvents_upon S A) S\n  entails_formula S (S \\<union> all_resolvents_upon S A)\n\ngoal (1 subgoal):\n 1. entails_formula S (S \\<union> all_resolvents_upon S A) \\<and>\n    entails_formula (S \\<union> all_resolvents_upon S A) S", "by auto"], ["proof (state)\nthis:\n  equivalent S (S \\<union> all_resolvents_upon S A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Given a sequence of atoms, we define a sequence of clauses obtained by resolving upon \neach atom successively. Simplification rules are applied at each iteration step.\\<close>"], ["", "fun resolvents_sequence :: \"(nat \\<Rightarrow> 'at) \\<Rightarrow> 'at Formula \\<Rightarrow> nat \\<Rightarrow> 'at Formula\"\n where \n  \"(resolvents_sequence A S 0) = (simplify S)\" |\n  \"(resolvents_sequence A S (Suc N)) = \n    (simplify ((resolvents_sequence A S N)\n      \\<union> (all_resolvents_upon (resolvents_sequence A S N) (A N))))\""], ["", "text \\<open>The following lemma states that partial saturation is preserved by simplification.\\<close>"], ["", "lemma redundancy_implies_partial_saturation:\n  assumes \"partial_saturation S1 A S1\"\n  assumes \"S2 \\<subseteq> S1\"\n  assumes \"all_fulfill (\\<lambda>x. redundant x S2) S1\"\n  shows \"partial_saturation S2 A S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_saturation S2 A S2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "assume \"\\<not>partial_saturation S2 A S2\""], ["proof (state)\nthis:\n  \\<not> partial_saturation S2 A S2\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> partial_saturation S2 A S2", "obtain P1 P2 C where \"P1 \\<in> S2\" \"P2 \\<in> S2\" and \"C = (resolvent_upon P1 P2 A)\" \n    and \"\\<not> redundant C S2\""], ["proof (prove)\nusing this:\n  \\<not> partial_saturation S2 A S2\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> S2; P2 \\<in> S2; C = resolvent_upon P1 P2 A;\n         \\<not> redundant C S2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2.\n             P1 \\<in> S2 \\<longrightarrow>\n             P2 \\<in> S2 \\<longrightarrow>\n             redundant (resolvent_upon P1 P2 A) S2)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> S2; P2 \\<in> S2; C = resolvent_upon P1 P2 A;\n         \\<not> redundant C S2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S2\n  P2 \\<in> S2\n  C = resolvent_upon P1 P2 A\n  \\<not> redundant C S2\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from \\<open>P1 \\<in> S2\\<close> and \\<open>S2 \\<subseteq> S1\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S2\n  S2 \\<subseteq> S1", "have \"P1 \\<in> S1\""], ["proof (prove)\nusing this:\n  P1 \\<in> S2\n  S2 \\<subseteq> S1\n\ngoal (1 subgoal):\n 1. P1 \\<in> S1", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S1\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from \\<open>P2 \\<in> S2\\<close> and \\<open>S2 \\<subseteq> S1\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> S2\n  S2 \\<subseteq> S1", "have \"P2 \\<in> S1\""], ["proof (prove)\nusing this:\n  P2 \\<in> S2\n  S2 \\<subseteq> S1\n\ngoal (1 subgoal):\n 1. P2 \\<in> S1", "by auto"], ["proof (state)\nthis:\n  P2 \\<in> S1\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from \\<open>P1 \\<in> S1\\<close> and \\<open>P2 \\<in> S1\\<close> and \\<open>partial_saturation S1 A S1\\<close> and \\<open>C = resolvent_upon P1 P2 A\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> S1\n  P2 \\<in> S1\n  partial_saturation S1 A S1\n  C = resolvent_upon P1 P2 A", "have \"redundant C S1\""], ["proof (prove)\nusing this:\n  P1 \\<in> S1\n  P2 \\<in> S1\n  partial_saturation S1 A S1\n  C = resolvent_upon P1 P2 A\n\ngoal (1 subgoal):\n 1. redundant C S1", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  P1 \\<in> S1\n  P2 \\<in> S1\n  \\<forall>P1 P2.\n     P1 \\<in> S1 \\<longrightarrow>\n     P2 \\<in> S1 \\<longrightarrow> redundant (resolvent_upon P1 P2 A) S1\n  C = resolvent_upon P1 P2 A\n\ngoal (1 subgoal):\n 1. redundant C S1", "by auto"], ["proof (state)\nthis:\n  redundant C S1\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from \\<open>\\<not> redundant C S2\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C S2", "have \"\\<not>tautology C\""], ["proof (prove)\nusing this:\n  \\<not> redundant C S2\n\ngoal (1 subgoal):\n 1. \\<not> tautology C", "unfolding redundant_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> S2 \\<and> subsumes D C))\n\ngoal (1 subgoal):\n 1. \\<not> tautology C", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "with \\<open>redundant C S1\\<close>"], ["proof (chain)\npicking this:\n  redundant C S1\n  \\<not> tautology C", "obtain D where \"D \\<in> S1\" and \"D \\<subseteq> C\""], ["proof (prove)\nusing this:\n  redundant C S1\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S1; D \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  tautology C \\<or> (\\<exists>D. D \\<in> S1 \\<and> D \\<subseteq> C)\n  \\<not> tautology C\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> S1; D \\<subseteq> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<in> S1\n  D \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from \\<open>D \\<in> S1\\<close> and \\<open>all_fulfill (\\<lambda>x. redundant x S2) S1\\<close>"], ["proof (chain)\npicking this:\n  D \\<in> S1\n  all_fulfill (\\<lambda>x. redundant x S2) S1", "have \"redundant D S2\""], ["proof (prove)\nusing this:\n  D \\<in> S1\n  all_fulfill (\\<lambda>x. redundant x S2) S1\n\ngoal (1 subgoal):\n 1. redundant D S2", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  D \\<in> S1\n  \\<forall>C. C \\<in> S1 \\<longrightarrow> redundant C S2\n\ngoal (1 subgoal):\n 1. redundant D S2", "by auto"], ["proof (state)\nthis:\n  redundant D S2\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from \\<open>\\<not> tautology C\\<close> and \\<open>D \\<subseteq> C\\<close>"], ["proof (chain)\npicking this:\n  \\<not> tautology C\n  D \\<subseteq> C", "have \"\\<not> tautology D\""], ["proof (prove)\nusing this:\n  \\<not> tautology C\n  D \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> tautology D", "unfolding tautology_def"], ["proof (prove)\nusing this:\n  \\<nexists>A. Pos A \\<in> C \\<and> Neg A \\<in> C\n  D \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<nexists>A. Pos A \\<in> D \\<and> Neg A \\<in> D", "by auto"], ["proof (state)\nthis:\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "with \\<open>redundant D S2\\<close>"], ["proof (chain)\npicking this:\n  redundant D S2\n  \\<not> tautology D", "obtain E where \"E \\<in> S2\" and \"E \\<subseteq> D\""], ["proof (prove)\nusing this:\n  redundant D S2\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<in> S2; E \\<subseteq> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  tautology D \\<or> (\\<exists>Da. Da \\<in> S2 \\<and> Da \\<subseteq> D)\n  \\<not> tautology D\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<in> S2; E \\<subseteq> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E \\<in> S2\n  E \\<subseteq> D\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from  \\<open>E \\<subseteq> D\\<close> and \\<open>D \\<subseteq> C\\<close>"], ["proof (chain)\npicking this:\n  E \\<subseteq> D\n  D \\<subseteq> C", "have \"E \\<subseteq> C\""], ["proof (prove)\nusing this:\n  E \\<subseteq> D\n  D \\<subseteq> C\n\ngoal (1 subgoal):\n 1. E \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  E \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation S2 A S2 \\<Longrightarrow> False", "from  \\<open>E \\<in> S2\\<close> and \\<open>E \\<subseteq> C\\<close> and \\<open>\\<not>redundant C S2\\<close>"], ["proof (chain)\npicking this:\n  E \\<in> S2\n  E \\<subseteq> C\n  \\<not> redundant C S2", "show \"False\""], ["proof (prove)\nusing this:\n  E \\<in> S2\n  E \\<subseteq> C\n  \\<not> redundant C S2\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  E \\<in> S2\n  E \\<subseteq> C\n  \\<not> (tautology C \\<or> (\\<exists>D. D \\<in> S2 \\<and> D \\<subseteq> C))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next theorem finally states that the implicate generation algorithm is sound and \ncomplete in the sense that the final clause set in the sequence is exactly the set of prime \nimplicates of the considered clause set.\\<close>"], ["", "theorem incremental_prime_implication_generation:\n  assumes \"atoms_formula S = { X. \\<exists>I::nat. I < N \\<and> X = (A I) }\"\n  assumes \"all_fulfill finite S\"\n  shows \"(prime_implicates S) = (resolvents_sequence A S N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "text \\<open>We define a set of invariants and show that they are satisfied by all sets in the \nabove sequence. For the last set in the sequence, the invariants ensure that the clause set is \nsaturated, which entails the desired property.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?Final = \"resolvents_sequence A S N\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "text \\<open>We define some properties and show by induction that they are satisfied by all the \nclause sets in the constructed sequence\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?equiv_init = \"\\<lambda>I.(equivalent S (resolvents_sequence A S I))\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?partial_saturation = \"\\<lambda>I. (\\<forall>J::nat. (J < I \n    \\<longrightarrow> (partial_saturation (resolvents_sequence A S I) (A J) (resolvents_sequence A S I))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?no_tautologies = \"\\<lambda>I.(all_fulfill (\\<lambda>x. \\<not>(tautology x)) (resolvents_sequence A S I) )\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?atoms_init = \"\\<lambda>I.(atoms_formula (resolvents_sequence A S I)  \n                      \\<subseteq>  { X. \\<exists>I::nat. I < N \\<and> X = (A I)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?non_redundant = \"\\<lambda>I.(non_redundant (resolvents_sequence A S I))\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "let ?finite =\"\\<lambda>I. (all_fulfill finite (resolvents_sequence A S I))\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "have \"\\<forall>I. (I \\<le> N   \\<longrightarrow> (?equiv_init I)  \\<and> (?partial_saturation I) \\<and>  (?no_tautologies I) \n          \\<and> (?atoms_init I) \\<and> (?non_redundant I) \\<and> (?finite I) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I\\<le>N.\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I)", "proof (rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I)", "fix I"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I)", "show \" (I \\<le> N  \n      \\<longrightarrow> (?equiv_init I) \\<and> (?partial_saturation I) \\<and>  (?no_tautologies I) \\<and> (?atoms_init I)    \n            \\<and> (?non_redundant I) \\<and> (?finite I) )\" (is \"I \\<le> N \\<longrightarrow> ?P I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<le> N \\<longrightarrow>\n    equivalent S (resolvents_sequence A S I) \\<and>\n    (\\<forall>J<I.\n        partial_saturation (resolvents_sequence A S I) (A J)\n         (resolvents_sequence A S I)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S I) \\<and>\n    atoms_formula (resolvents_sequence A S I)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S I) \\<and>\n    all_fulfill finite (resolvents_sequence A S I)", "proof (induction I)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)\n 2. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "text \\<open>We show that the properties are all satisfied by the initial clause set \n(after simplification).\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)\n 2. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "show \"0 \\<le> N \\<longrightarrow> ?P 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "proof (rule impI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "assume \"0 \\<le> N\""], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "let ?R = \"resolvents_sequence A S 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "from \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S", "have \"?equiv_init 0\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. equivalent S (resolvents_sequence A S 0)", "using simplify_preserves_equivalence"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  \\<lbrakk>?T = simplify ?S; all_fulfill finite ?S\\<rbrakk>\n  \\<Longrightarrow> equivalent ?S ?T\n\ngoal (1 subgoal):\n 1. equivalent S (resolvents_sequence A S 0)", "by auto"], ["proof (state)\nthis:\n  equivalent S (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "moreover"], ["proof (state)\nthis:\n  equivalent S (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "have \"?no_tautologies 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S 0)", "using simplify_def strictly_redundant_def all_fulfill_def"], ["proof (prove)\nusing this:\n  simplify ?S = {C \\<in> ?S. \\<not> strictly_redundant C ?S}\n  strictly_redundant ?C ?S =\n  (tautology ?C \\<or> (\\<exists>D. D \\<in> ?S \\<and> D \\<subset> ?C))\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S 0)", "by auto"], ["proof (state)\nthis:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "moreover"], ["proof (state)\nthis:\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "have \"?partial_saturation 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>J<0.\n       partial_saturation (resolvents_sequence A S 0) (A J)\n        (resolvents_sequence A S 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>J<0.\n     partial_saturation (resolvents_sequence A S 0) (A J)\n      (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>J<0.\n     partial_saturation (resolvents_sequence A S 0) (A J)\n      (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "from \\<open>all_fulfill finite S\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite S", "have \"?finite 0\""], ["proof (prove)\nusing this:\n  all_fulfill finite S\n\ngoal (1 subgoal):\n 1. all_fulfill finite (resolvents_sequence A S 0)", "using simplify_finite"], ["proof (prove)\nusing this:\n  all_fulfill finite S\n  all_fulfill finite ?S \\<Longrightarrow> all_fulfill finite (simplify ?S)\n\ngoal (1 subgoal):\n 1. all_fulfill finite (resolvents_sequence A S 0)", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "moreover"], ["proof (state)\nthis:\n  all_fulfill finite (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "have \"atoms_formula ?R \\<subseteq> atoms_formula S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S", "using atoms_formula_simplify"], ["proof (prove)\nusing this:\n  atoms_formula (simplify ?S) \\<subseteq> atoms_formula ?S\n\ngoal (1 subgoal):\n 1. atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S", "by auto"], ["proof (state)\nthis:\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "moreover"], ["proof (state)\nthis:\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "with \\<open>atoms_formula S = { X. \\<exists>I::nat. I < N \\<and> X = (A I) }\\<close>"], ["proof (chain)\npicking this:\n  atoms_formula S = {X. \\<exists>I<N. X = A I}\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S", "have v: \"?atoms_init 0\""], ["proof (prove)\nusing this:\n  atoms_formula S = {X. \\<exists>I<N. X = A I}\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S\n\ngoal (1 subgoal):\n 1. atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "unfolding simplify_def"], ["proof (prove)\nusing this:\n  atoms_formula S = {X. \\<exists>I<N. X = A I}\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S\n\ngoal (1 subgoal):\n 1. atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "by auto"], ["proof (state)\nthis:\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "moreover"], ["proof (state)\nthis:\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "have \"?non_redundant 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_redundant (resolvents_sequence A S 0)", "using simplify_non_redundant"], ["proof (prove)\nusing this:\n  non_redundant (simplify ?S)\n\ngoal (1 subgoal):\n 1. non_redundant (resolvents_sequence A S 0)", "by auto"], ["proof (state)\nthis:\n  non_redundant (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "ultimately"], ["proof (chain)\npicking this:\n  equivalent S (resolvents_sequence A S 0)\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S 0)\n  \\<forall>J<0.\n     partial_saturation (resolvents_sequence A S 0) (A J)\n      (resolvents_sequence A S 0)\n  all_fulfill finite (resolvents_sequence A S 0)\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  non_redundant (resolvents_sequence A S 0)", "show \"?P 0\""], ["proof (prove)\nusing this:\n  equivalent S (resolvents_sequence A S 0)\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S 0)\n  \\<forall>J<0.\n     partial_saturation (resolvents_sequence A S 0) (A J)\n      (resolvents_sequence A S 0)\n  all_fulfill finite (resolvents_sequence A S 0)\n  atoms_formula (resolvents_sequence A S 0) \\<subseteq> atoms_formula S\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  non_redundant (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. equivalent S (resolvents_sequence A S 0) \\<and>\n    (\\<forall>J<0.\n        partial_saturation (resolvents_sequence A S 0) (A J)\n         (resolvents_sequence A S 0)) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S 0) \\<and>\n    atoms_formula (resolvents_sequence A S 0)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S 0) \\<and>\n    all_fulfill finite (resolvents_sequence A S 0)", "by auto"], ["proof (state)\nthis:\n  equivalent S (resolvents_sequence A S 0) \\<and>\n  (\\<forall>J<0.\n      partial_saturation (resolvents_sequence A S 0) (A J)\n       (resolvents_sequence A S 0)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S 0) \\<and>\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S 0) \\<and>\n  all_fulfill finite (resolvents_sequence A S 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S 0) \\<and>\n  (\\<forall>J<0.\n      partial_saturation (resolvents_sequence A S 0) (A J)\n       (resolvents_sequence A S 0)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S 0) \\<and>\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S 0) \\<and>\n  all_fulfill finite (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "text \\<open>We then show that the properties are preserved by induction.\\<close>"], ["proof (state)\nthis:\n  0 \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S 0) \\<and>\n  (\\<forall>J<0.\n      partial_saturation (resolvents_sequence A S 0) (A J)\n       (resolvents_sequence A S 0)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S 0) \\<and>\n  atoms_formula (resolvents_sequence A S 0)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S 0) \\<and>\n  all_fulfill finite (resolvents_sequence A S 0)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "fix I"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "assume \"I \\<le> N \\<longrightarrow> ?P I\""], ["proof (state)\nthis:\n  I \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S I) \\<and>\n  (\\<forall>J<I.\n      partial_saturation (resolvents_sequence A S I) (A J)\n       (resolvents_sequence A S I)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S I) \\<and>\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S I) \\<and>\n  all_fulfill finite (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. \\<And>I.\n       I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S I) \\<and>\n       (\\<forall>J<I.\n           partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I)) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S I) \\<and>\n       atoms_formula (resolvents_sequence A S I)\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S I) \\<and>\n       all_fulfill finite (resolvents_sequence A S I) \\<Longrightarrow>\n       Suc I \\<le> N \\<longrightarrow>\n       equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n       (\\<forall>J<Suc I.\n           partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n            (resolvents_sequence A S (Suc I))) \\<and>\n       all_fulfill (\\<lambda>x. \\<not> tautology x)\n        (resolvents_sequence A S (Suc I)) \\<and>\n       atoms_formula (resolvents_sequence A S (Suc I))\n       \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n       non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n       all_fulfill finite (resolvents_sequence A S (Suc I))", "show \"(Suc I) \\<le> N \\<longrightarrow> (?P (Suc I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "proof (rule impI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "assume  \"(Suc I) \\<le> N\""], ["proof (state)\nthis:\n  Suc I \\<le> N\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "let ?Prec = \"resolvents_sequence A S I\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "let ?R = \"resolvents_sequence A S (Suc I)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from \\<open>Suc I \\<le> N\\<close> and \\<open>I \\<le> N \\<longrightarrow> ?P I\\<close>"], ["proof (chain)\npicking this:\n  Suc I \\<le> N\n  I \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S I) \\<and>\n  (\\<forall>J<I.\n      partial_saturation (resolvents_sequence A S I) (A J)\n       (resolvents_sequence A S I)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S I) \\<and>\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S I) \\<and>\n  all_fulfill finite (resolvents_sequence A S I)", "have \"?equiv_init I\" and \"?partial_saturation I\" and \"?no_tautologies I\" and \"?finite I\"\n            and \"?atoms_init I\" and \"?non_redundant I\""], ["proof (prove)\nusing this:\n  Suc I \\<le> N\n  I \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S I) \\<and>\n  (\\<forall>J<I.\n      partial_saturation (resolvents_sequence A S I) (A J)\n       (resolvents_sequence A S I)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S I) \\<and>\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S I) \\<and>\n  all_fulfill finite (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. (equivalent S (resolvents_sequence A S I) &&&\n     \\<forall>J<I.\n        partial_saturation (resolvents_sequence A S I) (A J)\n         (resolvents_sequence A S I) &&&\n     all_fulfill (\\<lambda>x. \\<not> tautology x)\n      (resolvents_sequence A S I)) &&&\n    all_fulfill finite (resolvents_sequence A S I) &&&\n    atoms_formula (resolvents_sequence A S I)\n    \\<subseteq> {X. \\<exists>I<N. X = A I} &&&\n    non_redundant (resolvents_sequence A S I)", "by auto"], ["proof (state)\nthis:\n  equivalent S (resolvents_sequence A S I)\n  \\<forall>J<I.\n     partial_saturation (resolvents_sequence A S I) (A J)\n      (resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill finite (resolvents_sequence A S I)\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  non_redundant (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"equivalent ?Prec (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent (resolvents_sequence A S I)\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))", "using resolvents_preserve_equivalence"], ["proof (prove)\nusing this:\n  equivalent ?S (?S \\<union> all_resolvents_upon ?S ?A)\n\ngoal (1 subgoal):\n 1. equivalent (resolvents_sequence A S I)\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))", "by auto"], ["proof (state)\nthis:\n  equivalent (resolvents_sequence A S I)\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from \\<open>?finite I\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite (resolvents_sequence A S I)", "have \"all_fulfill finite (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\""], ["proof (prove)\nusing this:\n  all_fulfill finite (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))", "using all_resolvents_upon_is_finite"], ["proof (prove)\nusing this:\n  all_fulfill finite (resolvents_sequence A S I)\n  all_fulfill finite ?S \\<Longrightarrow>\n  all_fulfill finite (?S \\<union> all_resolvents_upon ?S ?A)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "then"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))", "have \"all_fulfill finite (simplify (?Prec \\<union> (all_resolvents_upon ?Prec (A I))))\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (simplify\n       (resolvents_sequence A S I \\<union>\n        all_resolvents_upon (resolvents_sequence A S I) (A I)))", "using simplify_finite"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  all_fulfill finite ?S \\<Longrightarrow> all_fulfill finite (simplify ?S)\n\ngoal (1 subgoal):\n 1. all_fulfill finite\n     (simplify\n       (resolvents_sequence A S I \\<union>\n        all_resolvents_upon (resolvents_sequence A S I) (A I)))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "then"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))", "have \"?finite (Suc I)\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))\n\ngoal (1 subgoal):\n 1. all_fulfill finite (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  all_fulfill finite (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from \\<open>all_fulfill finite (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))", "have \"equivalent (?Prec \\<union> (all_resolvents_upon ?Prec (A I))) ?R\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. equivalent\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))\n     (resolvents_sequence A S (Suc I))", "using simplify_preserves_equivalence"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<lbrakk>?T = simplify ?S; all_fulfill finite ?S\\<rbrakk>\n  \\<Longrightarrow> equivalent ?S ?T\n\ngoal (1 subgoal):\n 1. equivalent\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))\n     (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  equivalent\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from \\<open>equivalent ?Prec (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\\<close> \n        and \\<open>equivalent (?Prec \\<union> (all_resolvents_upon ?Prec (A I))) ?R\\<close>"], ["proof (chain)\npicking this:\n  equivalent (resolvents_sequence A S I)\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  equivalent\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I))", "have \"equivalent ?Prec ?R\""], ["proof (prove)\nusing this:\n  equivalent (resolvents_sequence A S I)\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  equivalent\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. equivalent (resolvents_sequence A S I) (resolvents_sequence A S (Suc I))", "by (rule equivalent_transitive)"], ["proof (state)\nthis:\n  equivalent (resolvents_sequence A S I) (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from \\<open>?equiv_init I\\<close> and this"], ["proof (chain)\npicking this:\n  equivalent S (resolvents_sequence A S I)\n  equivalent (resolvents_sequence A S I) (resolvents_sequence A S (Suc I))", "have \"?equiv_init (Suc I)\""], ["proof (prove)\nusing this:\n  equivalent S (resolvents_sequence A S I)\n  equivalent (resolvents_sequence A S I) (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. equivalent S (resolvents_sequence A S (Suc I))", "by (rule equivalent_transitive)"], ["proof (state)\nthis:\n  equivalent S (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"?no_tautologies (Suc I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I))", "using simplify_def strictly_redundant_def all_fulfill_def"], ["proof (prove)\nusing this:\n  simplify ?S = {C \\<in> ?S. \\<not> strictly_redundant C ?S}\n  strictly_redundant ?C ?S =\n  (tautology ?C \\<or> (\\<exists>D. D \\<in> ?S \\<and> D \\<subset> ?C))\n  all_fulfill ?P ?S = (\\<forall>C. C \\<in> ?S \\<longrightarrow> ?P C)\n\ngoal (1 subgoal):\n 1. all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "let ?Delta = \"?R - ?Prec\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"?R \\<subseteq> ?Prec \\<union> ?Delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolvents_sequence A S (Suc I)\n    \\<subseteq> resolvents_sequence A S I \\<union>\n                (resolvents_sequence A S (Suc I) -\n                 resolvents_sequence A S I)", "by auto"], ["proof (state)\nthis:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"all_fulfill (\\<lambda>x. (redundant x ?R)) (?Prec \\<union> ?Delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "assume \"\\<not>all_fulfill (\\<lambda>x. (redundant x ?R)) (?Prec \\<union> ?Delta)\""], ["proof (state)\nthis:\n  \\<not> all_fulfill\n          (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> all_fulfill\n          (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "obtain x where \"\\<not>redundant x ?R\" and \"x \\<in> ?Prec \\<union> ?Delta\""], ["proof (prove)\nusing this:\n  \\<not> all_fulfill\n          (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<not> redundant x (resolvents_sequence A S (Suc I));\n         x \\<in> resolvents_sequence A S I \\<union>\n                 (resolvents_sequence A S (Suc I) -\n                  resolvents_sequence A S I)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C.\n             C \\<in> resolvents_sequence A S I \\<union>\n                     (resolvents_sequence A S (Suc I) -\n                      resolvents_sequence A S I) \\<longrightarrow>\n             redundant C (resolvents_sequence A S (Suc I)))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<not> redundant x (resolvents_sequence A S (Suc I));\n         x \\<in> resolvents_sequence A S I \\<union>\n                 (resolvents_sequence A S (Suc I) -\n                  resolvents_sequence A S I)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> redundant x (resolvents_sequence A S (Suc I))\n  x \\<in> resolvents_sequence A S I \\<union>\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "from \\<open>\\<not>redundant x ?R\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant x (resolvents_sequence A S (Suc I))", "have \"\\<not>x \\<in> ?R\""], ["proof (prove)\nusing this:\n  \\<not> redundant x (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. x \\<notin> resolvents_sequence A S (Suc I)", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  \\<not> (tautology x \\<or>\n          (\\<exists>D.\n              D \\<in> resolvents_sequence A S (Suc I) \\<and>\n              D \\<subseteq> x))\n\ngoal (1 subgoal):\n 1. x \\<notin> resolvents_sequence A S (Suc I)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> resolvents_sequence A S (Suc I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "with \\<open>x \\<in> ?Prec \\<union> ?Delta\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> resolvents_sequence A S I \\<union>\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  x \\<notin> resolvents_sequence A S (Suc I)", "have \"x \\<in> (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\""], ["proof (prove)\nusing this:\n  x \\<in> resolvents_sequence A S I \\<union>\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  x \\<notin> resolvents_sequence A S (Suc I)\n\ngoal (1 subgoal):\n 1. x \\<in> resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I)", "by auto"], ["proof (state)\nthis:\n  x \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "with \\<open>all_fulfill finite (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  x \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)", "have \"redundant x (simplify (?Prec \\<union> (all_resolvents_upon ?Prec (A I))))\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  x \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. redundant x\n     (simplify\n       (resolvents_sequence A S I \\<union>\n        all_resolvents_upon (resolvents_sequence A S I) (A I)))", "using simplify_and_membership"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  x \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n  \\<lbrakk>all_fulfill finite ?S; ?T = simplify ?S; ?C \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> redundant ?C ?T\n\ngoal (1 subgoal):\n 1. redundant x\n     (simplify\n       (resolvents_sequence A S I \\<union>\n        all_resolvents_upon (resolvents_sequence A S I) (A I)))", "by blast"], ["proof (state)\nthis:\n  redundant x\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "with \\<open>\\<not>redundant x ?R\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant x (resolvents_sequence A S (Suc I))\n  redundant x\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant x (resolvents_sequence A S (Suc I))\n  redundant x\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"all_fulfill (in_all_resolvents_upon ?Prec (A I)) ?Delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n     (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "assume \"\\<not> (all_fulfill (in_all_resolvents_upon ?Prec (A I)) ?Delta)\""], ["proof (state)\nthis:\n  \\<not> all_fulfill\n          (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> all_fulfill\n          (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)", "obtain C where \"C \\<in> ?Delta\" \n            and \"\\<not>in_all_resolvents_upon ?Prec (A I) C\""], ["proof (prove)\nusing this:\n  \\<not> all_fulfill\n          (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> resolvents_sequence A S (Suc I) -\n                         resolvents_sequence A S I;\n         \\<not> in_all_resolvents_upon (resolvents_sequence A S I) (A I)\n                 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C.\n             C \\<in> resolvents_sequence A S (Suc I) -\n                     resolvents_sequence A S I \\<longrightarrow>\n             in_all_resolvents_upon (resolvents_sequence A S I) (A I) C)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> resolvents_sequence A S (Suc I) -\n                         resolvents_sequence A S I;\n         \\<not> in_all_resolvents_upon (resolvents_sequence A S I) (A I)\n                 C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n  \\<not> in_all_resolvents_upon (resolvents_sequence A S I) (A I) C\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n  \\<not> in_all_resolvents_upon (resolvents_sequence A S I) (A I) C", "obtain C where \"C \\<in> ?Delta\" \n            and not_res: \"\\<forall> P1 P2. \\<not>(P1 \\<in> ?Prec \\<and> P2 \\<in> ?Prec \\<and> C = resolvent_upon P1 P2 (A I))\""], ["proof (prove)\nusing this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n  \\<not> in_all_resolvents_upon (resolvents_sequence A S I) (A I) C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> resolvents_sequence A S (Suc I) -\n                         resolvents_sequence A S I;\n         \\<forall>P1 P2.\n            \\<not> (P1 \\<in> resolvents_sequence A S I \\<and>\n                    P2 \\<in> resolvents_sequence A S I \\<and>\n                    C = resolvent_upon P1 P2 (A I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def in_all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n  \\<nexists>P1 P2.\n     P1 \\<in> resolvents_sequence A S I \\<and>\n     P2 \\<in> resolvents_sequence A S I \\<and>\n     C = resolvent_upon P1 P2 (A I)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> resolvents_sequence A S (Suc I) -\n                         resolvents_sequence A S I;\n         \\<forall>P1 P2.\n            \\<not> (P1 \\<in> resolvents_sequence A S I \\<and>\n                    P2 \\<in> resolvents_sequence A S I \\<and>\n                    C = resolvent_upon P1 P2 (A I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n  \\<forall>P1 P2.\n     \\<not> (P1 \\<in> resolvents_sequence A S I \\<and>\n             P2 \\<in> resolvents_sequence A S I \\<and>\n             C = resolvent_upon P1 P2 (A I))\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> ?Delta\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I", "have \"C \\<in> ?R\" and \"C \\<notin> ?Prec\""], ["proof (prove)\nusing this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S (Suc I) &&&\n    C \\<notin> resolvents_sequence A S I", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S (Suc I)\n  C \\<notin> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  C \\<in> resolvents_sequence A S (Suc I)\n  C \\<notin> resolvents_sequence A S I", "have \"C \\<in> simplify (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\""], ["proof (prove)\nusing this:\n  C \\<in> resolvents_sequence A S (Suc I)\n  C \\<notin> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. C \\<in> simplify\n             (resolvents_sequence A S I \\<union>\n              all_resolvents_upon (resolvents_sequence A S I) (A I))", "by auto"], ["proof (state)\nthis:\n  C \\<in> simplify\n           (resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  C \\<in> simplify\n           (resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I))", "have \"C \\<in> ?Prec \\<union> (all_resolvents_upon ?Prec (A I))\""], ["proof (prove)\nusing this:\n  C \\<in> simplify\n           (resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I)", "unfolding simplify_def"], ["proof (prove)\nusing this:\n  C \\<in> {C \\<in> resolvents_sequence A S I \\<union>\n                   all_resolvents_upon (resolvents_sequence A S I) (A I).\n           \\<not> strictly_redundant C\n                   (resolvents_sequence A S I \\<union>\n                    all_resolvents_upon (resolvents_sequence A S I) (A I))}\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I)", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "with \\<open>C \\<notin> ?Prec\\<close>"], ["proof (chain)\npicking this:\n  C \\<notin> resolvents_sequence A S I\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)", "have \"C \\<in> (all_resolvents_upon ?Prec (A I))\""], ["proof (prove)\nusing this:\n  C \\<notin> resolvents_sequence A S I\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. C \\<in> all_resolvents_upon (resolvents_sequence A S I) (A I)", "by auto"], ["proof (state)\nthis:\n  C \\<in> all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "with not_res"], ["proof (chain)\npicking this:\n  \\<forall>P1 P2.\n     \\<not> (P1 \\<in> resolvents_sequence A S I \\<and>\n             P2 \\<in> resolvents_sequence A S I \\<and>\n             C = resolvent_upon P1 P2 (A I))\n  C \\<in> all_resolvents_upon (resolvents_sequence A S I) (A I)", "show \"False\""], ["proof (prove)\nusing this:\n  \\<forall>P1 P2.\n     \\<not> (P1 \\<in> resolvents_sequence A S I \\<and>\n             P2 \\<in> resolvents_sequence A S I \\<and>\n             C = resolvent_upon P1 P2 (A I))\n  C \\<in> all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. False", "unfolding all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  \\<forall>P1 P2.\n     \\<not> (P1 \\<in> resolvents_sequence A S I \\<and>\n             P2 \\<in> resolvents_sequence A S I \\<and>\n             C = resolvent_upon P1 P2 (A I))\n  C \\<in> {C. \\<exists>P1 P2.\n                 P1 \\<in> resolvents_sequence A S I \\<and>\n                 P2 \\<in> resolvents_sequence A S I \\<and>\n                 C = resolvent_upon P1 P2 (A I)}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"all_fulfill (\\<lambda>x. (\\<not>redundant x ?Prec)) ?Delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n     (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "assume \"\\<not>all_fulfill (\\<lambda>x. (\\<not>redundant x ?Prec)) ?Delta\""], ["proof (state)\nthis:\n  \\<not> all_fulfill\n          (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> all_fulfill\n          (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)", "obtain C where \"C \\<in> ?Delta\" and redundant: \"redundant C ?Prec\""], ["proof (prove)\nusing this:\n  \\<not> all_fulfill\n          (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n          (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> resolvents_sequence A S (Suc I) -\n                         resolvents_sequence A S I;\n         redundant C (resolvents_sequence A S I)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_fulfill_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C.\n             C \\<in> resolvents_sequence A S (Suc I) -\n                     resolvents_sequence A S I \\<longrightarrow>\n             \\<not> redundant C (resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> resolvents_sequence A S (Suc I) -\n                         resolvents_sequence A S I;\n         redundant C (resolvents_sequence A S I)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n  redundant C (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> ?Delta\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I", "have \"C \\<in> ?R\" and \"C \\<notin> ?Prec\""], ["proof (prove)\nusing this:\n  C \\<in> resolvents_sequence A S (Suc I) - resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S (Suc I) &&&\n    C \\<notin> resolvents_sequence A S I", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S (Suc I)\n  C \\<notin> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. \\<not> all_fulfill\n            (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n            (resolvents_sequence A S (Suc I) -\n             resolvents_sequence A S I) \\<Longrightarrow>\n    False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"strictly_redundant C ?Prec\""], ["proof (state)\nthis:\n  strictly_redundant C (resolvents_sequence A S I)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  strictly_redundant C (resolvents_sequence A S I)", "have \"strictly_redundant C (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\""], ["proof (prove)\nusing this:\n  strictly_redundant C (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. strictly_redundant C\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))", "unfolding strictly_redundant_def"], ["proof (prove)\nusing this:\n  tautology C \\<or>\n  (\\<exists>D. D \\<in> resolvents_sequence A S I \\<and> D \\<subset> C)\n\ngoal (1 subgoal):\n 1. tautology C \\<or>\n    (\\<exists>D.\n        D \\<in> resolvents_sequence A S I \\<union>\n                all_resolvents_upon (resolvents_sequence A S I) (A I) \\<and>\n        D \\<subset> C)", "by auto"], ["proof (state)\nthis:\n  strictly_redundant C\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  strictly_redundant C\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))", "have \"C \\<notin> simplify (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\""], ["proof (prove)\nusing this:\n  strictly_redundant C\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. C \\<notin> simplify\n                (resolvents_sequence A S I \\<union>\n                 all_resolvents_upon (resolvents_sequence A S I) (A I))", "unfolding simplify_def"], ["proof (prove)\nusing this:\n  strictly_redundant C\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. C \\<notin> {C \\<in> resolvents_sequence A S I \\<union>\n                        all_resolvents_upon (resolvents_sequence A S I)\n                         (A I).\n                \\<not> strictly_redundant C\n                        (resolvents_sequence A S I \\<union>\n                         all_resolvents_upon (resolvents_sequence A S I)\n                          (A I))}", "by auto"], ["proof (state)\nthis:\n  C \\<notin> simplify\n              (resolvents_sequence A S I \\<union>\n               all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  C \\<notin> simplify\n              (resolvents_sequence A S I \\<union>\n               all_resolvents_upon (resolvents_sequence A S I) (A I))", "have \"C \\<notin> ?R\""], ["proof (prove)\nusing this:\n  C \\<notin> simplify\n              (resolvents_sequence A S I \\<union>\n               all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. C \\<notin> resolvents_sequence A S (Suc I)", "by auto"], ["proof (state)\nthis:\n  C \\<notin> resolvents_sequence A S (Suc I)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>C \\<in> ?R\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> resolvents_sequence A S (Suc I)\n  C \\<notin> resolvents_sequence A S (Suc I)", "show \"False\""], ["proof (prove)\nusing this:\n  C \\<in> resolvents_sequence A S (Suc I)\n  C \\<notin> resolvents_sequence A S (Suc I)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> strictly_redundant C\n            (resolvents_sequence A S I) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> strictly_redundant C\n            (resolvents_sequence A S I) \\<Longrightarrow>\n    False", "assume \"\\<not>strictly_redundant C ?Prec\""], ["proof (state)\nthis:\n  \\<not> strictly_redundant C (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. \\<not> strictly_redundant C\n            (resolvents_sequence A S I) \\<Longrightarrow>\n    False", "with redundant"], ["proof (chain)\npicking this:\n  redundant C (resolvents_sequence A S I)\n  \\<not> strictly_redundant C (resolvents_sequence A S I)", "have \"C \\<in> ?Prec\""], ["proof (prove)\nusing this:\n  redundant C (resolvents_sequence A S I)\n  \\<not> strictly_redundant C (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S I", "unfolding strictly_redundant_def redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  tautology C \\<or>\n  (\\<exists>D. D \\<in> resolvents_sequence A S I \\<and> D \\<subseteq> C)\n  \\<not> (tautology C \\<or>\n          (\\<exists>D.\n              D \\<in> resolvents_sequence A S I \\<and> D \\<subset> C))\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S I", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. \\<not> strictly_redundant C\n            (resolvents_sequence A S I) \\<Longrightarrow>\n    False", "with \\<open>C \\<notin> ?Prec\\<close>"], ["proof (chain)\npicking this:\n  C \\<notin> resolvents_sequence A S I\n  C \\<in> resolvents_sequence A S I", "show \"False\""], ["proof (prove)\nusing this:\n  C \\<notin> resolvents_sequence A S I\n  C \\<in> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have \"\\<forall>J::nat. (J < (Suc I)) \\<longrightarrow> (partial_saturation ?R (A J) ?R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>J<Suc I.\n       partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n        (resolvents_sequence A S (Suc I))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>J<Suc I.\n               partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n                (resolvents_sequence A S (Suc I))) \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>J::nat. (J < (Suc I)) \\<longrightarrow> (partial_saturation ?R (A J) ?R))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>J<Suc I.\n             partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n              (resolvents_sequence A S (Suc I)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>J<Suc I.\n               partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n                (resolvents_sequence A S (Suc I))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>J<Suc I.\n             partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n              (resolvents_sequence A S (Suc I)))", "obtain J where \"J < (Suc I)\" and \"\\<not>(partial_saturation ?R (A J) ?R)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>J<Suc I.\n             partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n              (resolvents_sequence A S (Suc I)))\n\ngoal (1 subgoal):\n 1. (\\<And>J.\n        \\<lbrakk>J < Suc I;\n         \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n                 (resolvents_sequence A S (Suc I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  J < Suc I\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>J<Suc I.\n               partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n                (resolvents_sequence A S (Suc I))) \\<Longrightarrow>\n    False", "from \\<open>\\<not>(partial_saturation ?R (A J) ?R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))", "obtain P1 P2 C \n          where \"P1 \\<in> ?R\" and \"P2 \\<in> ?R\" and \"C = resolvent_upon P1 P2 (A J)\" and \"\\<not> redundant C ?R\""], ["proof (prove)\nusing this:\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> resolvents_sequence A S (Suc I);\n         P2 \\<in> resolvents_sequence A S (Suc I);\n         C = resolvent_upon P1 P2 (A J);\n         \\<not> redundant C (resolvents_sequence A S (Suc I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2.\n             P1 \\<in> resolvents_sequence A S (Suc I) \\<longrightarrow>\n             P2 \\<in> resolvents_sequence A S (Suc I) \\<longrightarrow>\n             redundant (resolvent_upon P1 P2 (A J))\n              (resolvents_sequence A S (Suc I)))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> resolvents_sequence A S (Suc I);\n         P2 \\<in> resolvents_sequence A S (Suc I);\n         C = resolvent_upon P1 P2 (A J);\n         \\<not> redundant C (resolvents_sequence A S (Suc I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> resolvents_sequence A S (Suc I)\n  P2 \\<in> resolvents_sequence A S (Suc I)\n  C = resolvent_upon P1 P2 (A J)\n  \\<not> redundant C (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>J<Suc I.\n               partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n                (resolvents_sequence A S (Suc I))) \\<Longrightarrow>\n    False", "have \"partial_saturation ?Prec (A I) (?Prec \\<union> ?Delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S I) (A I)\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "assume \"\\<not>partial_saturation ?Prec (A I) (?Prec \\<union> ?Delta)\""], ["proof (state)\nthis:\n  \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "obtain P1 P2 C where \"P1 \\<in> ?Prec\" and \"P2 \\<in> ?Prec\" \n              and \"C = resolvent_upon P1 P2 (A I)\" and \n              \"\\<not>redundant C (?Prec \\<union> ?Delta)\""], ["proof (prove)\nusing this:\n  \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> resolvents_sequence A S I;\n         P2 \\<in> resolvents_sequence A S I; C = resolvent_upon P1 P2 (A I);\n         \\<not> redundant C\n                 (resolvents_sequence A S I \\<union>\n                  (resolvents_sequence A S (Suc I) -\n                   resolvents_sequence A S I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2.\n             P1 \\<in> resolvents_sequence A S I \\<longrightarrow>\n             P2 \\<in> resolvents_sequence A S I \\<longrightarrow>\n             redundant (resolvent_upon P1 P2 (A I))\n              (resolvents_sequence A S I \\<union>\n               (resolvents_sequence A S (Suc I) -\n                resolvents_sequence A S I)))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> resolvents_sequence A S I;\n         P2 \\<in> resolvents_sequence A S I; C = resolvent_upon P1 P2 (A I);\n         \\<not> redundant C\n                 (resolvents_sequence A S I \\<union>\n                  (resolvents_sequence A S (Suc I) -\n                   resolvents_sequence A S I))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> resolvents_sequence A S I\n  P2 \\<in> resolvents_sequence A S I\n  C = resolvent_upon P1 P2 (A I)\n  \\<not> redundant C\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "from \\<open>C = resolvent_upon P1 P2 (A I)\\<close> and \\<open>P1 \\<in> ?Prec\\<close> and \\<open>P2 \\<in> ?Prec\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 (A I)\n  P1 \\<in> resolvents_sequence A S I\n  P2 \\<in> resolvents_sequence A S I", "have \"C \\<in> ?Prec \\<union> (all_resolvents_upon ?Prec (A I))\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 (A I)\n  P1 \\<in> resolvents_sequence A S I\n  P2 \\<in> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S I \\<union>\n            all_resolvents_upon (resolvents_sequence A S I) (A I)", "unfolding all_resolvents_upon_def"], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 (A I)\n  P1 \\<in> resolvents_sequence A S I\n  P2 \\<in> resolvents_sequence A S I\n\ngoal (1 subgoal):\n 1. C \\<in> resolvents_sequence A S I \\<union>\n            {C. \\<exists>P1 P2.\n                   P1 \\<in> resolvents_sequence A S I \\<and>\n                   P2 \\<in> resolvents_sequence A S I \\<and>\n                   C = resolvent_upon P1 P2 (A I)}", "by auto"], ["proof (state)\nthis:\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "from \\<open>all_fulfill finite (?Prec \\<union> (all_resolvents_upon ?Prec (A I)))\\<close> \n              and this"], ["proof (chain)\npicking this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)", "have \"redundant C ?R\""], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n\ngoal (1 subgoal):\n 1. redundant C (resolvents_sequence A S (Suc I))", "using simplify_and_membership [of \"?Prec \\<union> (all_resolvents_upon ?Prec (A I))\" ?R C]"], ["proof (prove)\nusing this:\n  all_fulfill finite\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  C \\<in> resolvents_sequence A S I \\<union>\n          all_resolvents_upon (resolvents_sequence A S I) (A I)\n  \\<lbrakk>all_fulfill finite\n            (resolvents_sequence A S I \\<union>\n             all_resolvents_upon (resolvents_sequence A S I) (A I));\n   resolvents_sequence A S (Suc I) =\n   simplify\n    (resolvents_sequence A S I \\<union>\n     all_resolvents_upon (resolvents_sequence A S I) (A I));\n   C \\<in> resolvents_sequence A S I \\<union>\n           all_resolvents_upon (resolvents_sequence A S I) (A I)\\<rbrakk>\n  \\<Longrightarrow> redundant C (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. redundant C (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  redundant C (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "with \\<open>?R \\<subseteq> ?Prec \\<union> ?Delta\\<close>"], ["proof (chain)\npicking this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  redundant C (resolvents_sequence A S (Suc I))", "have \"redundant C (?Prec \\<union> ?Delta)\""], ["proof (prove)\nusing this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  redundant C (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. redundant C\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "using superset_preserves_redundancy [of C ?R \"(?Prec \\<union> ?Delta)\"]"], ["proof (prove)\nusing this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  redundant C (resolvents_sequence A S (Suc I))\n  \\<lbrakk>redundant C (resolvents_sequence A S (Suc I));\n   resolvents_sequence A S (Suc I)\n   \\<subseteq> resolvents_sequence A S I \\<union>\n               (resolvents_sequence A S (Suc I) -\n                resolvents_sequence A S I)\\<rbrakk>\n  \\<Longrightarrow> redundant C\n                     (resolvents_sequence A S I \\<union>\n                      (resolvents_sequence A S (Suc I) -\n                       resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. redundant C\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "by auto"], ["proof (state)\nthis:\n  redundant C\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. \\<not> partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) -\n              resolvents_sequence A S I)) \\<Longrightarrow>\n    False", "with \\<open>\\<not>redundant C (?Prec \\<union> ?Delta)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  redundant C\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C\n          (resolvents_sequence A S I \\<union>\n           (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  redundant C\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>J<Suc I.\n               partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n                (resolvents_sequence A S (Suc I))) \\<Longrightarrow>\n    False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"J = I\""], ["proof (state)\nthis:\n  J = I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>partial_saturation ?Prec (A I) (?Prec \\<union> ?Delta)\\<close> and \\<open>?no_tautologies I\\<close> \n              and \\<open>(all_fulfill (in_all_resolvents_upon ?Prec (A I)) ?Delta)\\<close> \n              and \\<open>all_fulfill (\\<lambda>x. (\\<not>redundant x ?Prec)) ?Delta\\<close>"], ["proof (chain)\npicking this:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)", "have \"partial_saturation (?Prec \\<union> ?Delta) (A I) (?Prec \\<union> ?Delta)\""], ["proof (prove)\nusing this:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. partial_saturation\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n     (A I)\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "using ensures_partial_saturation [of ?Prec \"(A I)\" ?Delta]"], ["proof (prove)\nusing this:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  \\<lbrakk>partial_saturation (resolvents_sequence A S I) (A I)\n            (resolvents_sequence A S I \\<union>\n             (resolvents_sequence A S (Suc I) - resolvents_sequence A S I));\n   all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I);\n   all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I);\n   all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\\<rbrakk>\n  \\<Longrightarrow> partial_saturation\n                     (resolvents_sequence A S I \\<union>\n                      (resolvents_sequence A S (Suc I) -\n                       resolvents_sequence A S I))\n                     (A I)\n                     (resolvents_sequence A S I \\<union>\n                      (resolvents_sequence A S (Suc I) -\n                       resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. partial_saturation\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n     (A I)\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "by auto"], ["proof (state)\nthis:\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>?R \\<subseteq> ?Prec \\<union> ?Delta\\<close> \n              and \\<open>all_fulfill (\\<lambda>x. (redundant x ?R)) (?Prec \\<union> ?Delta)\\<close>"], ["proof (chain)\npicking this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "have \"partial_saturation ?R (A I) ?R\""], ["proof (prove)\nusing this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S (Suc I)) (A I)\n     (resolvents_sequence A S (Suc I))", "using redundancy_implies_partial_saturation"], ["proof (prove)\nusing this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  \\<lbrakk>partial_saturation ?S1.0 ?A ?S1.0; ?S2.0 \\<subseteq> ?S1.0;\n   all_fulfill (\\<lambda>x. redundant x ?S2.0) ?S1.0\\<rbrakk>\n  \\<Longrightarrow> partial_saturation ?S2.0 ?A ?S2.0\n\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S (Suc I)) (A I)\n     (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  partial_saturation (resolvents_sequence A S (Suc I)) (A I)\n   (resolvents_sequence A S (Suc I))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>J = I\\<close> and \\<open>\\<not>(partial_saturation ?R (A J) ?R)\\<close>"], ["proof (chain)\npicking this:\n  J = I\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))\n  partial_saturation (resolvents_sequence A S (Suc I)) (A I)\n   (resolvents_sequence A S (Suc I))", "show \"False\""], ["proof (prove)\nusing this:\n  J = I\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))\n  partial_saturation (resolvents_sequence A S (Suc I)) (A I)\n   (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "assume \"J \\<noteq> I\""], ["proof (state)\nthis:\n  J \\<noteq> I\n\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "with \\<open>J < (Suc I)\\<close>"], ["proof (chain)\npicking this:\n  J < Suc I\n  J \\<noteq> I", "have \"J < I\""], ["proof (prove)\nusing this:\n  J < Suc I\n  J \\<noteq> I\n\ngoal (1 subgoal):\n 1. J < I", "by auto"], ["proof (state)\nthis:\n  J < I\n\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "with \\<open>?partial_saturation I\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>J<I.\n     partial_saturation (resolvents_sequence A S I) (A J)\n      (resolvents_sequence A S I)\n  J < I", "have \"partial_saturation ?Prec (A J) ?Prec\""], ["proof (prove)\nusing this:\n  \\<forall>J<I.\n     partial_saturation (resolvents_sequence A S I) (A J)\n      (resolvents_sequence A S I)\n  J < I\n\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S I) (A J)\n     (resolvents_sequence A S I)", "by auto"], ["proof (state)\nthis:\n  partial_saturation (resolvents_sequence A S I) (A J)\n   (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "with \\<open>partial_saturation ?Prec (A I) (?Prec \\<union> ?Delta)\\<close> and \\<open>?no_tautologies I\\<close> \n              and \\<open>(all_fulfill (in_all_resolvents_upon ?Prec (A I)) ?Delta)\\<close>\n              and \\<open>all_fulfill (\\<lambda>x. (\\<not>redundant x ?Prec)) ?Delta\\<close>"], ["proof (chain)\npicking this:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  partial_saturation (resolvents_sequence A S I) (A J)\n   (resolvents_sequence A S I)", "have \"partial_saturation (?Prec \\<union> ?Delta) (A J) (?Prec \\<union> ?Delta)\""], ["proof (prove)\nusing this:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  partial_saturation (resolvents_sequence A S I) (A J)\n   (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. partial_saturation\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n     (A J)\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "using partial_saturation_is_preserved [of ?Prec \"A J\" \"A I\" ?Delta]"], ["proof (prove)\nusing this:\n  partial_saturation (resolvents_sequence A S I) (A I)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I)\n  all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. \\<not> redundant x (resolvents_sequence A S I))\n   (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  partial_saturation (resolvents_sequence A S I) (A J)\n   (resolvents_sequence A S I)\n  \\<lbrakk>partial_saturation (resolvents_sequence A S I) (A J)\n            (resolvents_sequence A S I);\n   partial_saturation (resolvents_sequence A S I) (A I)\n    (resolvents_sequence A S I \\<union>\n     (resolvents_sequence A S (Suc I) - resolvents_sequence A S I));\n   all_fulfill (\\<lambda>x. \\<not> tautology x) (resolvents_sequence A S I);\n   all_fulfill (in_all_resolvents_upon (resolvents_sequence A S I) (A I))\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\\<rbrakk>\n  \\<Longrightarrow> partial_saturation\n                     (resolvents_sequence A S I \\<union>\n                      (resolvents_sequence A S (Suc I) -\n                       resolvents_sequence A S I))\n                     (A J)\n                     (resolvents_sequence A S I \\<union>\n                      (resolvents_sequence A S (Suc I) -\n                       resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. partial_saturation\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n     (A J)\n     (resolvents_sequence A S I \\<union>\n      (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "by auto"], ["proof (state)\nthis:\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A J)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "with \\<open>?R \\<subseteq> ?Prec \\<union> ?Delta\\<close> \n              and \\<open>all_fulfill (\\<lambda>x. (redundant x ?R)) (?Prec \\<union> ?Delta)\\<close>"], ["proof (chain)\npicking this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A J)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))", "have \"partial_saturation ?R (A J) ?R\""], ["proof (prove)\nusing this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A J)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n     (resolvents_sequence A S (Suc I))", "using redundancy_implies_partial_saturation"], ["proof (prove)\nusing this:\n  resolvents_sequence A S (Suc I)\n  \\<subseteq> resolvents_sequence A S I \\<union>\n              (resolvents_sequence A S (Suc I) - resolvents_sequence A S I)\n  all_fulfill (\\<lambda>x. redundant x (resolvents_sequence A S (Suc I)))\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  partial_saturation\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n   (A J)\n   (resolvents_sequence A S I \\<union>\n    (resolvents_sequence A S (Suc I) - resolvents_sequence A S I))\n  \\<lbrakk>partial_saturation ?S1.0 ?A ?S1.0; ?S2.0 \\<subseteq> ?S1.0;\n   all_fulfill (\\<lambda>x. redundant x ?S2.0) ?S1.0\\<rbrakk>\n  \\<Longrightarrow> partial_saturation ?S2.0 ?A ?S2.0\n\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n     (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n   (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. J \\<noteq> I \\<Longrightarrow> False", "with \\<open>\\<not>(partial_saturation ?R (A J) ?R)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))\n  partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n   (resolvents_sequence A S (Suc I))", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n          (resolvents_sequence A S (Suc I))\n  partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n   (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>J<Suc I.\n     partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n      (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "have  \"non_redundant ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_redundant (resolvents_sequence A S (Suc I))", "using simplify_non_redundant"], ["proof (prove)\nusing this:\n  non_redundant (simplify ?S)\n\ngoal (1 subgoal):\n 1. non_redundant (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  non_redundant (resolvents_sequence A S (Suc I))\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from \\<open>?atoms_init I\\<close>"], ["proof (chain)\npicking this:\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}", "have \"atoms_formula (all_resolvents_upon ?Prec (A I)) \n                                    \\<subseteq>  { X. \\<exists>I::nat. I < N \\<and> X = (A I)}\""], ["proof (prove)\nusing this:\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "using atoms_formula_resolvents [of ?Prec \"A I\"]"], ["proof (prove)\nusing this:\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> atoms_formula (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "by auto"], ["proof (state)\nthis:\n  atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "with \\<open>?atoms_init I\\<close>"], ["proof (chain)\npicking this:\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}", "have \"atoms_formula (?Prec \\<union> (all_resolvents_upon ?Prec (A I))) \n                \\<subseteq>  { X. \\<exists>I::nat. I < N \\<and> X = (A I)}\""], ["proof (prove)\nusing this:\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. atoms_formula\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "using atoms_formula_union [of ?Prec \"all_resolvents_upon ?Prec (A I)\"]"], ["proof (prove)\nusing this:\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  atoms_formula\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I)) =\n  atoms_formula (resolvents_sequence A S I) \\<union>\n  atoms_formula (all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. atoms_formula\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "by auto"], ["proof (state)\nthis:\n  atoms_formula\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from this"], ["proof (chain)\npicking this:\n  atoms_formula\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}", "have \"atoms_formula ?R \\<subseteq>  { X. \\<exists>I::nat. I < N \\<and> X = (A I)}\""], ["proof (prove)\nusing this:\n  atoms_formula\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "using atoms_formula_simplify [of \"?Prec \\<union> (all_resolvents_upon ?Prec (A I))\"]"], ["proof (prove)\nusing this:\n  atoms_formula\n   (resolvents_sequence A S I \\<union>\n    all_resolvents_upon (resolvents_sequence A S I) (A I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  atoms_formula\n   (simplify\n     (resolvents_sequence A S I \\<union>\n      all_resolvents_upon (resolvents_sequence A S I) (A I)))\n  \\<subseteq> atoms_formula\n               (resolvents_sequence A S I \\<union>\n                all_resolvents_upon (resolvents_sequence A S I) (A I))\n\ngoal (1 subgoal):\n 1. atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I}", "by auto"], ["proof (state)\nthis:\n  atoms_formula (resolvents_sequence A S (Suc I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. Suc I \\<le> N \\<Longrightarrow>\n    equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "from  \\<open>equivalent S (resolvents_sequence A S (Suc I))\\<close> \n          and \\<open>(\\<forall>J::nat. (J < (Suc I) \n            \\<longrightarrow> (partial_saturation (resolvents_sequence A S (Suc I)) (A J) \n                  (resolvents_sequence A S (Suc I)))))\\<close> \n          and \\<open>(all_fulfill (\\<lambda>x. \\<not>(tautology x)) (resolvents_sequence A S (Suc I)) )\\<close>\n          and \\<open>(all_fulfill finite (resolvents_sequence A S (Suc I)))\\<close>\n          and \\<open>non_redundant ?R\\<close>\n          and \\<open>atoms_formula (resolvents_sequence A S (Suc I))  \\<subseteq>  { X. \\<exists>I::nat. I < N \\<and> X = (A I)}\\<close>"], ["proof (chain)\npicking this:\n  equivalent S (resolvents_sequence A S (Suc I))\n  \\<forall>J<Suc I.\n     partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n      (resolvents_sequence A S (Suc I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S (Suc I))\n  all_fulfill finite (resolvents_sequence A S (Suc I))\n  non_redundant (resolvents_sequence A S (Suc I))\n  atoms_formula (resolvents_sequence A S (Suc I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}", "show \"?P (Suc I)\""], ["proof (prove)\nusing this:\n  equivalent S (resolvents_sequence A S (Suc I))\n  \\<forall>J<Suc I.\n     partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n      (resolvents_sequence A S (Suc I))\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S (Suc I))\n  all_fulfill finite (resolvents_sequence A S (Suc I))\n  non_redundant (resolvents_sequence A S (Suc I))\n  atoms_formula (resolvents_sequence A S (Suc I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n\ngoal (1 subgoal):\n 1. equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n    (\\<forall>J<Suc I.\n        partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n         (resolvents_sequence A S (Suc I))) \\<and>\n    all_fulfill (\\<lambda>x. \\<not> tautology x)\n     (resolvents_sequence A S (Suc I)) \\<and>\n    atoms_formula (resolvents_sequence A S (Suc I))\n    \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n    non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n    all_fulfill finite (resolvents_sequence A S (Suc I))", "by auto"], ["proof (state)\nthis:\n  equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n  (\\<forall>J<Suc I.\n      partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n       (resolvents_sequence A S (Suc I))) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S (Suc I)) \\<and>\n  atoms_formula (resolvents_sequence A S (Suc I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n  all_fulfill finite (resolvents_sequence A S (Suc I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc I \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S (Suc I)) \\<and>\n  (\\<forall>J<Suc I.\n      partial_saturation (resolvents_sequence A S (Suc I)) (A J)\n       (resolvents_sequence A S (Suc I))) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S (Suc I)) \\<and>\n  atoms_formula (resolvents_sequence A S (Suc I))\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S (Suc I)) \\<and>\n  all_fulfill finite (resolvents_sequence A S (Suc I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I \\<le> N \\<longrightarrow>\n  equivalent S (resolvents_sequence A S I) \\<and>\n  (\\<forall>J<I.\n      partial_saturation (resolvents_sequence A S I) (A J)\n       (resolvents_sequence A S I)) \\<and>\n  all_fulfill (\\<lambda>x. \\<not> tautology x)\n   (resolvents_sequence A S I) \\<and>\n  atoms_formula (resolvents_sequence A S I)\n  \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n  non_redundant (resolvents_sequence A S I) \\<and>\n  all_fulfill finite (resolvents_sequence A S I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>I\\<le>N.\n     equivalent S (resolvents_sequence A S I) \\<and>\n     (\\<forall>J<I.\n         partial_saturation (resolvents_sequence A S I) (A J)\n          (resolvents_sequence A S I)) \\<and>\n     all_fulfill (\\<lambda>x. \\<not> tautology x)\n      (resolvents_sequence A S I) \\<and>\n     atoms_formula (resolvents_sequence A S I)\n     \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n     non_redundant (resolvents_sequence A S I) \\<and>\n     all_fulfill finite (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "text \\<open>Using the above invariants, we show that the final clause set is saturated.\\<close>"], ["proof (state)\nthis:\n  \\<forall>I\\<le>N.\n     equivalent S (resolvents_sequence A S I) \\<and>\n     (\\<forall>J<I.\n         partial_saturation (resolvents_sequence A S I) (A J)\n          (resolvents_sequence A S I)) \\<and>\n     all_fulfill (\\<lambda>x. \\<not> tautology x)\n      (resolvents_sequence A S I) \\<and>\n     atoms_formula (resolvents_sequence A S I)\n     \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n     non_redundant (resolvents_sequence A S I) \\<and>\n     all_fulfill finite (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "from this"], ["proof (chain)\npicking this:\n  \\<forall>I\\<le>N.\n     equivalent S (resolvents_sequence A S I) \\<and>\n     (\\<forall>J<I.\n         partial_saturation (resolvents_sequence A S I) (A J)\n          (resolvents_sequence A S I)) \\<and>\n     all_fulfill (\\<lambda>x. \\<not> tautology x)\n      (resolvents_sequence A S I) \\<and>\n     atoms_formula (resolvents_sequence A S I)\n     \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n     non_redundant (resolvents_sequence A S I) \\<and>\n     all_fulfill finite (resolvents_sequence A S I)", "have \"\\<forall>J. (J < N \\<longrightarrow> partial_saturation ?Final (A J) ?Final)\" \n    and \"atoms_formula (resolvents_sequence A S N)  \\<subseteq>  { X. \\<exists>I::nat. I < N \\<and> X = (A I)}\" \n    and \"equivalent S ?Final\"\n    and \"non_redundant ?Final\"\n    and \"all_fulfill finite ?Final\""], ["proof (prove)\nusing this:\n  \\<forall>I\\<le>N.\n     equivalent S (resolvents_sequence A S I) \\<and>\n     (\\<forall>J<I.\n         partial_saturation (resolvents_sequence A S I) (A J)\n          (resolvents_sequence A S I)) \\<and>\n     all_fulfill (\\<lambda>x. \\<not> tautology x)\n      (resolvents_sequence A S I) \\<and>\n     atoms_formula (resolvents_sequence A S I)\n     \\<subseteq> {X. \\<exists>I<N. X = A I} \\<and>\n     non_redundant (resolvents_sequence A S I) \\<and>\n     all_fulfill finite (resolvents_sequence A S I)\n\ngoal (1 subgoal):\n 1. (\\<forall>J<N.\n        partial_saturation (resolvents_sequence A S N) (A J)\n         (resolvents_sequence A S N) &&&\n     atoms_formula (resolvents_sequence A S N)\n     \\<subseteq> {X. \\<exists>I<N. X = A I}) &&&\n    equivalent S (resolvents_sequence A S N) &&&\n    non_redundant (resolvents_sequence A S N) &&&\n    all_fulfill finite (resolvents_sequence A S N)", "by auto"], ["proof (state)\nthis:\n  \\<forall>J<N.\n     partial_saturation (resolvents_sequence A S N) (A J)\n      (resolvents_sequence A S N)\n  atoms_formula (resolvents_sequence A S N)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  equivalent S (resolvents_sequence A S N)\n  non_redundant (resolvents_sequence A S N)\n  all_fulfill finite (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "have \"saturated_binary_rule resolvent ?Final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_binary_rule resolvent (resolvents_sequence A S N)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule resolvent\n            (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "assume \"\\<not> saturated_binary_rule resolvent ?Final\""], ["proof (state)\nthis:\n  \\<not> saturated_binary_rule resolvent (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule resolvent\n            (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> saturated_binary_rule resolvent (resolvents_sequence A S N)", "obtain P1 P2 C where \"P1 \\<in> ?Final\" and \"P2 \\<in> ?Final\" and \"resolvent P1 P2 C\" \n      and \"\\<not>redundant C ?Final\""], ["proof (prove)\nusing this:\n  \\<not> saturated_binary_rule resolvent (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> resolvents_sequence A S N;\n         P2 \\<in> resolvents_sequence A S N; resolvent P1 P2 C;\n         \\<not> redundant C (resolvents_sequence A S N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding saturated_binary_rule_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P1 P2 C.\n             P1 \\<in> resolvents_sequence A S N \\<and>\n             P2 \\<in> resolvents_sequence A S N \\<and>\n             resolvent P1 P2 C \\<longrightarrow>\n             redundant C (resolvents_sequence A S N))\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2 C.\n        \\<lbrakk>P1 \\<in> resolvents_sequence A S N;\n         P2 \\<in> resolvents_sequence A S N; resolvent P1 P2 C;\n         \\<not> redundant C (resolvents_sequence A S N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> resolvents_sequence A S N\n  P2 \\<in> resolvents_sequence A S N\n  resolvent P1 P2 C\n  \\<not> redundant C (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule resolvent\n            (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "from \\<open>resolvent P1 P2 C\\<close>"], ["proof (chain)\npicking this:\n  resolvent P1 P2 C", "obtain B where \"C = resolvent_upon P1 P2 B\""], ["proof (prove)\nusing this:\n  resolvent P1 P2 C\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        C = resolvent_upon P1 P2 B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding resolvent_def"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     Pos A \\<in> P1 \\<and>\n     Neg A \\<in> P2 \\<and> C = P1 - {Pos A} \\<union> (P2 - {Neg A})\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        C = resolvent_upon P1 P2 B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = resolvent_upon P1 P2 B\n\ngoal (1 subgoal):\n 1. \\<not> saturated_binary_rule resolvent\n            (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"B \\<in> (atoms_formula ?Final)\""], ["proof (state)\nthis:\n  B \\<in> atoms_formula (resolvents_sequence A S N)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>atoms_formula ?Final \\<subseteq> { X. \\<exists>I::nat. I < N \\<and> X = (A I) }\\<close>"], ["proof (chain)\npicking this:\n  atoms_formula (resolvents_sequence A S N)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  B \\<in> atoms_formula (resolvents_sequence A S N)", "obtain I where \"B = (A I)\" and \"I < N\""], ["proof (prove)\nusing this:\n  atoms_formula (resolvents_sequence A S N)\n  \\<subseteq> {X. \\<exists>I<N. X = A I}\n  B \\<in> atoms_formula (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>B = A I; I < N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B = A I\n  I < N\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>B = (A I)\\<close> and \\<open>C = resolvent_upon P1 P2 B\\<close>"], ["proof (chain)\npicking this:\n  B = A I\n  C = resolvent_upon P1 P2 B", "have \"C = resolvent_upon P1 P2 (A I)\""], ["proof (prove)\nusing this:\n  B = A I\n  C = resolvent_upon P1 P2 B\n\ngoal (1 subgoal):\n 1. C = resolvent_upon P1 P2 (A I)", "by auto"], ["proof (state)\nthis:\n  C = resolvent_upon P1 P2 (A I)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from \\<open>\\<forall>J. (J < N \\<longrightarrow> partial_saturation ?Final (A J) ?Final)\\<close> and \\<open>B = (A I)\\<close>and \\<open>I < N\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>J<N.\n     partial_saturation (resolvents_sequence A S N) (A J)\n      (resolvents_sequence A S N)\n  B = A I\n  I < N", "have \"partial_saturation ?Final (A I) ?Final\""], ["proof (prove)\nusing this:\n  \\<forall>J<N.\n     partial_saturation (resolvents_sequence A S N) (A J)\n      (resolvents_sequence A S N)\n  B = A I\n  I < N\n\ngoal (1 subgoal):\n 1. partial_saturation (resolvents_sequence A S N) (A I)\n     (resolvents_sequence A S N)", "by auto"], ["proof (state)\nthis:\n  partial_saturation (resolvents_sequence A S N) (A I)\n   (resolvents_sequence A S N)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>C = resolvent_upon P1 P2 (A I)\\<close>and \\<open>P1 \\<in> ?Final\\<close> and \\<open>P2 \\<in> ?Final\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 (A I)\n  P1 \\<in> resolvents_sequence A S N\n  P2 \\<in> resolvents_sequence A S N\n  partial_saturation (resolvents_sequence A S N) (A I)\n   (resolvents_sequence A S N)", "have \"redundant C ?Final\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 (A I)\n  P1 \\<in> resolvents_sequence A S N\n  P2 \\<in> resolvents_sequence A S N\n  partial_saturation (resolvents_sequence A S N) (A I)\n   (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. redundant C (resolvents_sequence A S N)", "unfolding partial_saturation_def"], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 (A I)\n  P1 \\<in> resolvents_sequence A S N\n  P2 \\<in> resolvents_sequence A S N\n  \\<forall>P1 P2.\n     P1 \\<in> resolvents_sequence A S N \\<longrightarrow>\n     P2 \\<in> resolvents_sequence A S N \\<longrightarrow>\n     redundant (resolvent_upon P1 P2 (A I)) (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. redundant C (resolvents_sequence A S N)", "by auto"], ["proof (state)\nthis:\n  redundant C (resolvents_sequence A S N)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>\\<not>redundant C ?Final\\<close>"], ["proof (chain)\npicking this:\n  \\<not> redundant C (resolvents_sequence A S N)\n  redundant C (resolvents_sequence A S N)", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> redundant C (resolvents_sequence A S N)\n  redundant C (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. B \\<notin> atoms_formula (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<notin> atoms_formula (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "assume \"B \\<notin> atoms_formula ?Final\""], ["proof (state)\nthis:\n  B \\<notin> atoms_formula (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. B \\<notin> atoms_formula (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "with \\<open>P1 \\<in> ?Final\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> resolvents_sequence A S N\n  B \\<notin> atoms_formula (resolvents_sequence A S N)", "have \"B \\<notin> atoms_clause P1\""], ["proof (prove)\nusing this:\n  P1 \\<in> resolvents_sequence A S N\n  B \\<notin> atoms_formula (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. B \\<notin> atoms_clause P1", "by auto"], ["proof (state)\nthis:\n  B \\<notin> atoms_clause P1\n\ngoal (1 subgoal):\n 1. B \\<notin> atoms_formula (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  B \\<notin> atoms_clause P1", "have \"Pos B \\<notin> P1\""], ["proof (prove)\nusing this:\n  B \\<notin> atoms_clause P1\n\ngoal (1 subgoal):\n 1. Pos B \\<notin> P1", "by auto"], ["proof (state)\nthis:\n  Pos B \\<notin> P1\n\ngoal (1 subgoal):\n 1. B \\<notin> atoms_formula (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "with \\<open>C = resolvent_upon P1 P2 B\\<close>"], ["proof (chain)\npicking this:\n  C = resolvent_upon P1 P2 B\n  Pos B \\<notin> P1", "have \"P1 \\<subseteq> C\""], ["proof (prove)\nusing this:\n  C = resolvent_upon P1 P2 B\n  Pos B \\<notin> P1\n\ngoal (1 subgoal):\n 1. P1 \\<subseteq> C", "by auto"], ["proof (state)\nthis:\n  P1 \\<subseteq> C\n\ngoal (1 subgoal):\n 1. B \\<notin> atoms_formula (resolvents_sequence A S N) \\<Longrightarrow>\n    False", "with \\<open>P1 \\<in> ?Final\\<close> and  \\<open>\\<not>redundant C ?Final\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> resolvents_sequence A S N\n  \\<not> redundant C (resolvents_sequence A S N)\n  P1 \\<subseteq> C", "show \"False\""], ["proof (prove)\nusing this:\n  P1 \\<in> resolvents_sequence A S N\n  \\<not> redundant C (resolvents_sequence A S N)\n  P1 \\<subseteq> C\n\ngoal (1 subgoal):\n 1. False", "unfolding redundant_def subsumes_def"], ["proof (prove)\nusing this:\n  P1 \\<in> resolvents_sequence A S N\n  \\<not> (tautology C \\<or>\n          (\\<exists>D.\n              D \\<in> resolvents_sequence A S N \\<and> D \\<subseteq> C))\n  P1 \\<subseteq> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  saturated_binary_rule resolvent (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "with \\<open>all_fulfill finite ?Final\\<close> and \\<open>non_redundant ?Final\\<close>"], ["proof (chain)\npicking this:\n  all_fulfill finite (resolvents_sequence A S N)\n  non_redundant (resolvents_sequence A S N)\n  saturated_binary_rule resolvent (resolvents_sequence A S N)", "have \"prime_implicates ?Final = ?Final\""], ["proof (prove)\nusing this:\n  all_fulfill finite (resolvents_sequence A S N)\n  non_redundant (resolvents_sequence A S N)\n  saturated_binary_rule resolvent (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. prime_implicates (resolvents_sequence A S N) = resolvents_sequence A S N", "using prime_implicates_of_saturated_sets [of ?Final]"], ["proof (prove)\nusing this:\n  all_fulfill finite (resolvents_sequence A S N)\n  non_redundant (resolvents_sequence A S N)\n  saturated_binary_rule resolvent (resolvents_sequence A S N)\n  \\<lbrakk>saturated_binary_rule resolvent (resolvents_sequence A S N);\n   all_fulfill finite (resolvents_sequence A S N);\n   non_redundant (resolvents_sequence A S N)\\<rbrakk>\n  \\<Longrightarrow> resolvents_sequence A S N =\n                    prime_implicates (resolvents_sequence A S N)\n\ngoal (1 subgoal):\n 1. prime_implicates (resolvents_sequence A S N) = resolvents_sequence A S N", "by auto"], ["proof (state)\nthis:\n  prime_implicates (resolvents_sequence A S N) = resolvents_sequence A S N\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "with \\<open>equivalent S ?Final\\<close>"], ["proof (chain)\npicking this:\n  equivalent S (resolvents_sequence A S N)\n  prime_implicates (resolvents_sequence A S N) = resolvents_sequence A S N", "show ?thesis"], ["proof (prove)\nusing this:\n  equivalent S (resolvents_sequence A S N)\n  prime_implicates (resolvents_sequence A S N) = resolvents_sequence A S N\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "using  equivalence_and_prime_implicates"], ["proof (prove)\nusing this:\n  equivalent S (resolvents_sequence A S N)\n  prime_implicates (resolvents_sequence A S N) = resolvents_sequence A S N\n  equivalent ?S1.0 ?S2.0 \\<Longrightarrow>\n  prime_implicates ?S1.0 = prime_implicates ?S2.0\n\ngoal (1 subgoal):\n 1. prime_implicates S = resolvents_sequence A S N", "by auto"], ["proof (state)\nthis:\n  prime_implicates S = resolvents_sequence A S N\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}